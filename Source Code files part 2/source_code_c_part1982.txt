
                    FinishXkdcRequest();

                    // if they are no longer banned, we should succeed
                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserBannedAndNeedsTos : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    UserEditor userEditor = CreateAndAddUser(banTime);
                    userEditor.AcceptedTOSDate = SqlMinTime;

                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(0), BanTolerance);
                        for (int u = 1; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserBannedOneUserNeedsTos : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser().AcceptedTOSDate = SqlMinTime;
                    CreateAndAddUser(banTime);
                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", SRVersion>=6?0:HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT, Client.XkdcOutput.HrUser[0]); //For service address failed caused by another user, we strip out needs management and unknown trust
                    ValueCheck.Test("Xkdc User1 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[0]);
                        ValueCheck.Test("User 1 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(1), BanTolerance);
                        for (int u = 2; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class FourUsersWithDifferentStates : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser();
                    CreateAndAddUser().AcceptedTOSDate = SqlMinTime;
                    CreateAndAddUser(banTime);
                    CreateAndAddUser(System.DateTime.Now.AddDays(-2));
                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", SRVersion>=6?0:HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT, Client.XkdcOutput.HrUser[1]); //For service address failed caused by another user, we strip out needs management and unknown trust
                    ValueCheck.Test("Xkdc User2 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[0]);
                        ValueCheck.Test("User 1 Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[1]);
                        ValueCheck.Test("User 2 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(2), BanTolerance);
                        ValueCheck.Test("User 3 Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[3]);
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserBannedTitleUpdate : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);

                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.XkdcRequest.Input.TitleID = 0x3EEF0801;
                    Client.XkdcRequest.Input.TitleVersion = 1;
                    Client.XkdcRequest.Input.TitleRegion = 1;
                    Client.ExpectXkdcValidTicket = false;
                    Client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", HResult.XONLINE_E_LOGON_UPDATE_REQUIRED, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserBannedFlashUpdate : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);

                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.XkdcRequest.Input.FlashVersion = 22;
                    Client.ExpectXkdcValidTicket = false;
                    Client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserBannedTitleUpdateRequestAutoupdate : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);

                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.XkdcRequest.Input.TitleID = 0x3EEF0801;
                    Client.XkdcRequest.Input.TitleVersion = 1;
                    Client.XkdcRequest.Input.TitleRegion = 1;
                    Client.XkdcRequest.Input.AutoDiscoverServices = 0;
                    Client.XkdcRequest.Input.Services = new uint[] { (uint)xonline.common.service.XOService.Auto_Update };
                    Client.ExpectXkdcValidTicket = true;
                    Client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    ValueCheck.Test("AutoUpdate Service Result", 0, Client.XkdcOutput.ServiceResults[0].Hr);
                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserBannedRequestUacs : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);

                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.XkdcRequest.Input.AutoDiscoverServices = 0;
                    Client.XkdcRequest.Input.Services = new uint[] { (uint)xonline.common.service.XOService.User_Account };
                    Client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(0), BanTolerance);
                        for (int u = 1; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }
                    else
                    {
                        ValueCheck.Test("Uacs service result", 0, Client.XkdcOutput.ServiceResults[0].Hr);
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserBannedRequestStats : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);

                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.XkdcRequest.Input.AutoDiscoverServices = 0;
                    Client.XkdcRequest.Input.Services = new uint[] { (uint)xonline.common.service.XOService.Stats };
                    if (SRVersion < 6)
                    {
                        Client.ExpectXkdcValidTicket = false;
                    }
                    Client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(0), BanTolerance);
                        for (int u = 1; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

        }; //class User

        [TestGroup, Description("Only PCs can be banned by voucher.")]
        public class Voucher: TestNode
        {
            //TODO: Move PC voucher banning stuff to here
        }
    }; //class Banning
} //namespace XkdcTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\AlasPoorXbox1WeKnewTheeWell.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;

//DO NOT DELETE THIS FILE.
//This file contains valuable historic information (including loglines) about how xbox1 requests behaved in production before we shut it off.  We can never gather that information again.
//Xbox1 decommisioning happened in phases over the period of about a year:
//    1:
//        All non-auto-updated-related Xbox1 Xkdc requests would fail with a specific overall HR code that was specified by an npdb setting.
//        The HR code decided upon from testing out how the dash and halo2 responded best was: 0x80151001 (XONLINE_E_LOGON_CANNOT_ACCESS_SERVICE)
//        Autoupdate requests still succeed.  At this point everyone can still take autoupdates to games and the dash, but can't do anything else.
//    2:
//        The old presense servers which were kept around purely for xbox1 compatability were shut down.
//    3:
//        All Xbox1 requests to Xmacs, Askdc, and Xkdc fail with a kerberos error specified by an npdb setting.
//        The Kerberos error decided upon was 0x0C (KDC_ERR_POLICY).  This was an arbitrary decision.
//        Xbox1 user keys are no longer respected by the Askdc if the block is enabled.
//At this point xbox1 is completely unable to make any request of any type to the service.  The following tasks occur next, over time, as convenient:
//    4a:
//        Xbox1 code is stripped out of the KDC server except for stubs to detect an xbox1 request being made.
//        The KDC is hardcoded to respond to all xbox1 requests with a kerberos error: 0x0C (KDC_ERR_POLICY)
//        Xbox1 user keys are no longer ever respected by the Askdc.
//    4b:
//        Xbox1-only APIs and and other related processes and databases are removed.
//

//Loglines from production (2010 Febuary), showing an an xbox360 running fusion updating halo 2.
//2010/02/10 19:40:11.820|REQ|0|70.144.131.172|1.0.5849.12|0|4D530064|3|7|FA00000000125EFB|9A8D68D692379|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|1,2,4,6,7,8,9,13,14,15,16,18,19,20,0x4d530064|||0.0.0.0|14400000|1100505E2|0|80151002|0
//2010/02/10 19:40:20.884|REQ|1|70.144.131.172|1.0.5849.1|0|4D530064|3|7|FA00000000125EFB|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|3|sg/site1|3|65.55.42.180|14400000|1000585E2|0|0|0
//2010/02/10 19:41:29.777|REQ|1|70.144.131.172|1.0.5849.12|0|4D530064|803|7|FA00000000125EFB|9A8D68D692379|670C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|1,2,4,6,7,8,9,13,14,15,16,18,19,20,0x4d530064|sg/site1|1,2,4,6,7,8,9,13,14,15,16,18,19|65.55.42.180|14400000|1000585E2|0|0|0
//2010/02/10 19:41:29.995|REQ|1|70.144.131.172|1.0.5849.12|0|4D530064|803|7|FA00000000125EFB|9A8D68D692379|670C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|20,0x4d530064|sg/site9999|20|65.55.42.179|14400000|5000585E2|0|0|0
//2010/02/10 19:41:30.214|REQ|1|70.144.131.172|1.0.5849.12|0|4D530064|803|7|FA00000000125EFB|9A8D68D692379|670C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0x4d530064|ts/site1297285220|0x4d530064|131.107.135.138|432000000|5000585E2|0|0|0
//Loglines from production (2010 Febuary), showing an xbox1 updating halo 2.
//2010/02/14 09:48:00.708|REQ|0|67.167.188.139|1.0.5849.12|0|4D530064|303|7|000900000430B8D8|9000004320A92|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|1,2,4,6,7,8,9,13,14,15,16,18,19,20,0x4d530064|||0.0.0.0|14400000|1100505E2|0|80151002|0
//2010/02/14 09:48:07.307|REQ|1|67.167.188.139|1.0.5849.1|0|4D530064|303|7|000900000430B8D8|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|3|sg/site1|3|65.55.42.180|14400000|1000585E2|0|0|0
//2010/02/14 09:48:47.650|REQ|1|67.167.188.139|1.0.5849.12|0|4D530064|803|7|000900000430B8D8|9000004320A92|676C|80000010|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|1,2,4,6,7,8,9,13,14,15,16,18,19,20,0x4d530064|sg/site1|2,4,7,9,18|65.55.42.180|14400000|1000585E2|0|0|31
//2010/02/14 09:48:47.775|REQ|1|67.167.188.139|1.0.5849.12|0|4D530064|803|7|000900000430B8D8|9000004320A92|676C|80000010|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|20,0x4d530064|sg/site9999|20|65.55.42.179|14400000|5000585E2|0|0|0
//2010/02/14 09:48:47.915|REQ|1|67.167.188.139|1.0.5849.12|0|4D530064|803|7|000900000430B8D8|9000004320A92|676C|80000010|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0x4d530064|||0.0.0.0|432000000|5100505E2|0|0|0

//Halo2 request from a random production KDC log (2010 Febuary):
//2010/02/10 19:00:57.643|REQ|1|83.92.119.132|1.0.5849.12|0|4D530064|803|7|FA0000000094C9DF|900000152DE36|196C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|1,2,4,6,7,8,9,13,14,15,16,18,19,20,0x4d530064|sg/site1|1,2,4,6,7,8,9,13,14,15,16,18,19|65.55.42.180|14400000|1000585E2|0|0|15
//2010/02/10 19:00:57.862|REQ|1|83.92.119.132|1.0.5849.12|0|4D530064|803|7|FA0000000094C9DF|900000152DE36|196C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|20,0x4d530064|sg/site9999|20|65.55.42.179|14400000|5000585E2|0|0|0
//2010/02/10 19:00:58.064|REQ|1|83.92.119.132|1.0.5849.12|0|4D530064|803|7|FA0000000094C9DF|900000152DE36|196C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0x4d530064|ts/site1297285220|0x4d530064|131.107.135.138|432000000|5000585E2|0|0|0

//An xbox1 dashboard logline taken from StressNet.  Network troubleshooter is the same. (2010 Febuary):
//2010/02/12 22:26:23.642|REQ|1|10.195.101.87|1.0.5849.3|0|FFFE0000|185EAD00|7FFFFFFF|000900000119F166|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|4,5,11,20|sg/site1|4,5,11|10.184.224.33|1800000|1000585E2|0|0|0
//2010/02/12 22:26:23.689|REQ|1|10.195.101.87|1.0.5849.3|0|FFFE0000|185EAD00|7FFFFFFF|000900000119F166|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|20|sg/site9999|20|10.184.224.32|129600000|1000585E2|0|0|0

//An xbox1 dash frineds app logline from StressNet. (2010 Febuary):
//2010/02/12 22:34:34.546|REQ|1|10.195.101.87|1.0.5849.3|0|FFFE0000|185EAD00|7FFFFFFF|000900000119F166|91B6DB6EB6695|4000676C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|1,2,4,5,6,8,9,11,14,15,18,20|sg/site1|1,2,4,5,6,8,9,11,14,15,18|10.184.224.33|1800000|1000585E2|0|0|0
//2010/02/12 22:34:34.577|REQ|1|10.195.101.87|1.0.5849.3|0|FFFE0000|185EAD00|7FFFFFFF|000900000119F166|91B6DB6EB6695|4000676C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|20|sg/site9999|20|10.184.224.32|129600000|5000585E2|0|0|0


namespace XkdcTest
{
    [TestGroup, Description("Tests to verify xbox1 decommisioning."), TestCasePriority(2)]
    public class Xbox1: XkdcTestBaseGroup
    {
        public Xbox1()
        {
            ParentClientType=AuthContext.ClientTypes.Xbox; //default to xbox1
        }

        // -- helpers

        //verifies the overall hr and individual services are granted
        public static void XkdcVerifyAllRepliesAreGranted(XkdcGenericReplyOutput []replies)
        {
            foreach (XkdcGenericReplyOutput reply in replies)
            {
                //overall HR
                ValueCheck.Test("Overall HR for site "+reply.SiteIP, 0, reply.Hr);

                //verify that all requested services were granted or on another site
                foreach (XkdcGenericReplyOutput.ServiceResult service in reply.ServiceResults)
                {
                    if (!(service.Hr==0 || service.Hr==1))
                    {
                        if (service.Service==0x4d530064) //just warn for the halo2 lsp since it's unlikely to be set up in our test environments
                        {
                            Global.RO.Warn("Ignoring service 0x4d530064 (halo2 lsp) failure: "+service.Hr+" (It is likely not set up in this environment)");
                        }
                        else
                        {
                            throw new UnexpectedTestResultException("Service "+service.Service+" was not granted for site "+reply.SiteIP+": Hr="+service.Hr);
                        }
                    }
                }

                //user HRs should be 0
                XkdcVerifyUserHRsGood(reply);
            }
        }

        //verifies that the HR value for each user in a response are good
        public static void XkdcVerifyUserHRsGood(XkdcGenericReplyOutput reply)
        {
            //verify that all user HRs are good
            foreach (uint uhr in reply.HrUser)
            {
                ValueCheck.Test("User hr", 0, uhr);
            }
        }

        //verifies the overall hr and individual services hrs
        public static void XkdcVerifyAllRepliesAreBlocked(XkdcGenericReplyOutput []replies, uint overallBlockedHr)
        {
            foreach (XkdcGenericReplyOutput reply in replies)
            {
                //overall HR
                ValueCheck.Test("Overall HR for site "+reply.SiteIP, overallBlockedHr, reply.Hr);

                //verify that all requested services were granted or on another site
                foreach (XkdcGenericReplyOutput.ServiceResult service in reply.ServiceResults)
                {
                    if (service.Hr==0)
                    {
                        throw new UnexpectedTestResultException("Service "+service.Service+" was unexpectedly granted for site "+reply.SiteIP+": Hr="+service.Hr);
                    }
                }

                //user HRs should still be 0
                XkdcVerifyUserHRsGood(reply);
            }
        }

        // -- tests

        //Loglines from production (2010 Febuary), showing an xbox360 updating fusion.  They always do this first when trying to start an xbox1 title.
        //2010/02/10 19:38:44.424|REQ|0|70.144.131.172|2.0.8955.0|2022FB00|FFFE07D2|20075C00|FFFFFFFF|FA00000000125EFB|9A8D68D692379|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00||||0.0.0.0|14400000|1100505E2|0|80151002|0
        //2010/02/10 19:38:46.171|REQ|1|70.144.131.172|2.0.8955.0|2022FB00|FFFE07D2|20075C00|FFFFFFFF|FA00000000125EFB|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|3,21,25|sg/site1|3,21,25|65.55.42.180|14400000|5000585E2|0|0|0
        //2010/02/10 19:39:34.393|REQ|1|70.144.131.172|2.0.8955.0|2022FB00|FFFE07D2|2016C500|FFFFFFFF|FA00000000125EFB|9A8D68D692379|360676C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00||sg/site1|1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,19,21,25,26,27,29,223,224,225,226,227,228,229,230,231,232,234,235,238,240,242,243,244,245,246,247,248,249,250,251,252,253,254,255|65.55.42.180|14400000|1000585E2|0|0|15
        //2010/02/10 19:39:34.721|REQ|1|70.144.131.172|2.0.8955.0|2022FB00|FFFE07D2|2016C500|FFFFFFFF|FA00000000125EFB|9A8D68D692379|360676C|0|0.00|0|0|0|0.00|0|0|0|0.00|0|0|0|0.00|20|sg/site9999|20|65.55.42.179|14400000|5000585E2|0|0|0
        [TestCase, Description("The fusion title is actually an xbox360 title and should still be updateable like normal.")]
        public void VerifyFusionUpdateWorks()
        {
            //get an askdc ticket with 1 user and 1 machine
            KdcUser user=new KdcUser();
            user.CreateUser();

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.XkdcThrowOnOverallHRFailure=false;

            kdc.CreateAskdcUserRequest(user);
            kdc.ExecuteAskdc(true);
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //do an autodiscover request for version 20075Cff of fusion, which requires an update
            Global.RO.Debug("Doing request on old version");
            kdc.CreateXkdcRequest();
            kdc.XkdcRequest.Input.TitleID=0xFFFE07D2;
            kdc.XkdcRequest.Input.TitleVersion=0x20075Cff; //same as the sample request, but we've filled the qfe version bits to avoid possible real conflicts in test environments
            kdc.ExecuteXkdc(true);
            XkdcVerifyAllRepliesAreBlocked(new XkdcGenericReplyOutput[]{kdc.XkdcOutput}, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);

            //do a request for autoupdate, with no user
            Global.RO.Debug("Doing request for update");
            kdc.ClearXkdc();
            kdc.CreateXkdcRequest();
            kdc.XkdcRequest.Input.TitleID=0xFFFE07D2;
            kdc.XkdcRequest.Input.TitleVersion=0x20075Cff;
            kdc.XkdcRequest.Input.AutoDiscoverServices=0;
            kdc.XkdcRequest.Input.Services=new uint[]{3,21,25}; //autoupdate, drm, liveinfo
            kdc.XkdcRequest.Input.UserIDs=new ulong[0]; //no users
            kdc.ExecuteXkdc(true);
            XkdcVerifyAllRepliesAreGranted(new XkdcGenericReplyOutput[]{kdc.XkdcOutput});

            //do an autodiscover request for the updated version
            Global.RO.Debug("Doing request on new version");
            kdc.ClearXkdc();
            kdc.CreateXkdcRequest();
            kdc.XkdcRequest.Input.TitleID=0xFFFE07D2;
            kdc.XkdcRequest.Input.TitleVersion=0x2016C5ff; //same as the sample request, but we've filled the qfe version bits to avoid possible real conflicts in test environments
            kdc.ExecuteXkdc(true);
            XkdcVerifyAllRepliesAreGranted(new XkdcGenericReplyOutput[]{kdc.XkdcOutput});
        }

        // --

        [TestGroup, Description("Tests that verify the Kerberos Error method of blocking at xmacs, askdc, and xkdc works.")]
        public class KerberosErrorMethod: TestNode
        {
            // -- helpers
            public class VerifyXmacs: TestNode
            {
                public uint ExpectedKerbError;

                [TestCase, Description("Creating a new machine account")]
                public class Create: TestBase_KdcClient
                {
                    public override void Run()
                    {
                        ExpectedXmacsKerbError=((VerifyXmacs)Parent).ExpectedKerbError;
                        ExecuteXmacs(true);
                    }
                }

                [TestCase, Description("Resetting an existing machine account's key.")]
                public class Reset: TestBase_KdcClient
                {
                    public override void Run()
                    {
                        //directly create the machine in the db, then synthesize the XmacsOutput
                        MachineEditor me=MachineEditor.CreateNew(MachineType.Xbox1);
                        Client.XmacsOutput=new XmacsGenericReplyOutput();
                        Client.XmacsOutput.PopulateFromDatabase(me);

                        ExpectedXmacsKerbError=((VerifyXmacs)Parent).ExpectedKerbError;
                        ExecuteXmacs(true);
                    }
                }
            };

            public class VerifyAskdc: TestNode
            {
                public uint ExpectedMachineKerbError;
                public uint ExpectedUserKerbError;

                protected static void ExecuteAskdcExpectedKerbError(KdcClient client, uint expectedKerbError)
                {
                    try
                    {
                        client.ExecuteAskdc(true);

                        if (expectedKerbError!=0)
                        {
                            throw new UnexpectedTestResultException("Expected a kerberos error.");
                        }
                    }
                    catch (KerberosErrorException kee)
                    {
                        if (expectedKerbError==0)
                        {
                            throw;
                        }
                        else
                        {
                            ValueCheck.Test("Expected Kerberos Error", expectedKerbError, kee.Error.ErrorCode.Int64);
                        }
                    }
                }

                [TestCase, Description("Askdc user request")]
                public class User: TestNode
                {
                    public override void Run()
                    {
                        KdcClientXbox1 client=new KdcClientXbox1();

                        client.CreateAskdcUserRequest(new KdcUser());
                        ExecuteAskdcExpectedKerbError(client, ((VerifyAskdc)Parent).ExpectedUserKerbError);
                    }
                };

                [TestCase, Description("Askdc machine request")]
                public class Machine: TestNode
                {
                    public override void Run()
                    {
                        MachineEditor me=MachineEditor.CreateNew(MachineType.Xbox1);

                        KdcClientXbox1 client=new KdcClientXbox1();
                        client.XmacsOutput=new XmacsGenericReplyOutput();
                        client.XmacsOutput.PopulateFromDatabase(me);

                        client.CreateAskdcMachineRequest();
                        ExecuteAskdcExpectedKerbError(client, ((VerifyAskdc)Parent).ExpectedMachineKerbError);
                    }
                };
            };

            //Note that the intention was that Xkdc would return a kerberos error too.  However there is a bug in the KDC related to the removal of the xbox1 preauth handler that instead causes it to ignore the request.
            //Since after a couple weeks all askdc tickets will expire anyways, we decided to live with having the request time out instead.  So The tests here have been updated to expect a time out from xkdc.
            public class VerifyXkdc: TestNode
            {
                public MachineType TypeOfMachine;
                public uint ExpectedKerbError;

                [TestCase, Description("Machine with no users")]
                public class Machine: TestBase_KdcClient
                {
                    public override void Run()
                    {
                        //directly create the machine in the db, then synthesize the XmacsOutput
                        MachineEditor me=MachineEditor.CreateNew(((VerifyXkdc)Parent).TypeOfMachine);
                        Client.XmacsOutput=new XmacsGenericReplyOutput();
                        Client.XmacsOutput.PopulateFromDatabase(me);

                        //set up the askdc request, then just synthesize a response
                        Client.CreateAskdcMachineRequest();
                        Client.AskdcOutput=new AskdcGenericReplyOutput();
                        Client.AskdcOutput.PopulateFromInput(Client.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.CompoundIdentity);

                        //do xkdc now
                        Client.RetryLostPackets=false;
                        ExpectXkdcTimeout=true;
                        ExecuteXkdc(true);
                    }
                }

                [TestCase, Description("Request with a user")]
                public class User: TestBase_KdcClient
                {
                    public override void Run()
                    {
                        //directly create the machine in the db, then synthesize the XmacsOutput
                        MachineEditor me=MachineEditor.CreateNew(((VerifyXkdc)Parent).TypeOfMachine);
                        Client.XmacsOutput=new XmacsGenericReplyOutput();
                        Client.XmacsOutput.PopulateFromDatabase(me);

                        //set up the askdc request, then just synthesize a responses
                        Client.CreateAskdcUserRequest(new KdcUser());
                        Client.AskdcOutput=new AskdcGenericReplyOutput();
                        Client.AskdcOutput.PopulateFromInput(Client.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.CompoundIdentity);

                        Client.CreateAskdcMachineRequest();
                        Client.AskdcOutput=new AskdcGenericReplyOutput();
                        Client.AskdcOutput.PopulateFromInput(Client.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.CompoundIdentity);

                        //do xkdc now
                        Client.RetryLostPackets=false;
                        ExpectXkdcTimeout=true;
                        ExecuteXkdc(true);
                    }
                }
            };

            // -- tests
            [TestGroup, Description("Tests where we block xbox1."), TestCasePriority(1)]
            public class Block: TestNode
            {
                public const uint BlockKerbError=12;

                //We no longer need to enable the block in npdb in our PreRun since it's hardcoded in the KDC.

                [TestGroup, Description("Verifies xmacs is blocked for xbox1 with the correct kerberos error.")]
                public class Xmacs: VerifyXmacs
                {
                    public override void PreRun()
                    {
                        ExpectedKerbError=BlockKerbError;
                    }
                }

                [TestGroup, Description("Verifies askdc is blocked for xbox1 with the correct kerberos error.")]
                public class Askdc: VerifyAskdc
                {
                    public override void PreRun()
                    {
                        ExpectedMachineKerbError=BlockKerbError;
                        ExpectedUserKerbError=(uint)KerbErrCode.KDC_ERR_PREAUTH_FAILED; //failure here is simply a failure to validate using the key that is now not checked
                    }
                }

                [TestGroup, Description("Verifies xkdc is blocked for xbox1 with the correct kerberos error.")]
                public class Xkdc_Xbox1: VerifyXkdc
                {
                    public override void PreRun()
                    {
                        TypeOfMachine=MachineType.Xbox1;
                        ExpectedKerbError=BlockKerbError;
                    }
                }

                [TestGroup, Description("Verifies xkdc is blocked for fusion with the correct kerberos error.")]
                public class Xkdc_Fusion: VerifyXkdc
                {
                    public override void PreRun()
                    {
                        TypeOfMachine=MachineType.Xbox360;
                        ExpectedKerbError=BlockKerbError;
                    }
                }
            }; //class Block

        }; //class KerbError
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\AskdcEncryptedPassport.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace XkdcTest
{
    [TestGroup, Description("Tests for using an encrypted passport with askdc.")]
    public class AskdcEncryptedPassport: TestNode
    {
        public static KdcUser GetCachedPassportUser(int n, string cachedTicketPolicy, AuthClientBase.PassportSite rpsSiteToUse)
        {
            return GetCachedPassportUser(n, cachedTicketPolicy, AuthClientBase.GetPassportSite(rpsSiteToUse));
        }

        public static KdcUser GetCachedPassportUser(int n, string cachedTicketPolicy, string rpsSite)
        {
            if (cachedPassport==null)
            {
                cachedPassport=new KdcUser[4];
            }

            if (cachedPassport[n]==null)
            {
                KdcUser newUser=new KdcUser();
                newUser.CreateUser(true);

                cachedPassport[n]=newUser;
            }

            if (cachedTicketPolicy!=null)
            {
                cachedPassport[n].Passport.GetTicket(cachedTicketPolicy, rpsSite); //ensure the user has a cached ticket of the requested policy type ready to use
            }

            return cachedPassport[n].Clone();
        }

        private static KdcUser []cachedPassport=null;

        public override void PreRun()
        {
            cachedPassport=null;
        }

        // --

        [TestCase, Description("Verifies that a normal askdc request using only a key still uses the CT_RandomKey credential type for users in the authdata.")]
        public void KeyNoPassport()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();

            Global.RO.Debug("Creating a user...");
            KdcUser user=new KdcUser();
            user.CreateUser(false);

            //xmacs
            Global.RO.Debug("Making request...");
            kdc.CreateXmacsRequest();
            kdc.ExecuteXmacs(true);

            //askdc machine
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //askdc user
            kdc.CreateAskdcUserRequest(user);
            kdc.ExecuteAskdc(true);

            //now verify the askdc authdata
            ValueCheck.Test("Machine PAC Credential Type", WindowsPacAuthData.CT_RandomKey, kdc.AskdcReply.AuthData.FindPuidCredentialType(kdc.XmacsOutput.MachineId));
            ValueCheck.Test("User PAC Credential Type", WindowsPacAuthData.CT_RandomKey, kdc.AskdcReply.AuthData.FindPuidCredentialType(user.UserID));
        }

        [TestCase, Description("Verifies that the old passport preauth originally used by panorama has the expected credential type set for users in the authdata.")]
        public void OldUnencryptedPassport()
        {
            KdcClientPC kdc=new KdcClientPC();

            Global.RO.Debug("Creating a user with a passport...");
            KdcUser user=GetCachedPassportUser(0, "MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            user.Passport.EncryptForPanoramaByDefault=false;

            //xmacs
            Global.RO.Debug("Making request...");
            kdc.CreateXmacsRequest();
            kdc.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            kdc.ExecuteXmacs(true);

            //askdc user
            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            kdc.ExecuteAskdc(true);

            //askdc machine
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //now verify the askdc authdata
            ValueCheck.Test("Machine PAC Credential Type", WindowsPacAuthData.CT_RandomKey,  kdc.AskdcReply.AuthData.FindPuidCredentialType(kdc.XmacsOutput.MachineId));
            ValueCheck.Test("User PAC Credential Type", WindowsPacAuthData.CT_RawPassport, kdc.AskdcReply.AuthData.FindPuidCredentialType(user.UserID));
        }

        [TestCase, Description("Uses the encrypted passport preauth to authenticate a user and verify the credential type is set in the authdata.")]
        [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
        [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
        public void MainlineOneUser(TestNode self)
        {
            AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)self.MyValues[0];
            KdcClient kdc=new KdcClient(clientType);

            Global.RO.Debug("Creating a user with a passport...");
            KdcUser user=GetCachedPassportUser(0, "MBI", AuthClientBase.PassportSite.KdcXenon);
            user.Passport.EncryptForPanoramaByDefault=true;

            //xmacs
            Global.RO.Debug("Making request...");
            kdc.CreateXmacsRequest();
            if (clientType==AuthContext.ClientTypes.Panorama)
            {
                kdc.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            }
            kdc.ExecuteXmacs(true);

            //askdc machine
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //askdc user
            kdc.CreateAskdcUserRequest(user);
            if (clientType==AuthContext.ClientTypes.Panorama)
            {
                kdc.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);
            }
            else
            {
                kdc.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
            }
            kdc.ExecuteAskdc(true);

            //now verify the askdc authdata
            ValueCheck.Test("Machine PAC Credential Type", WindowsPacAuthData.CT_RandomKey,  kdc.AskdcReply.AuthData.FindPuidCredentialType(kdc.XmacsOutput.MachineId));
            ValueCheck.Test("User PAC Credential Type", WindowsPacAuthData.CT_EncryptedPassport, kdc.AskdcReply.AuthData.FindPuidCredentialType(user.UserID));
        }

        [TestCase, Description("Uses the encrypted passport preauth to authenticate a user as the first request in the chain.  Askdc prohibits this and will ignore the request.")]
        public void UserFirst(TestNode self)
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();

            Global.RO.Debug("Creating a user with a passport...");
            KdcUser user=GetCachedPassportUser(0, "MBI", AuthClientBase.PassportSite.KdcXenon);

            //xmacs
            Global.RO.Debug("Making request...");

            //askdc user
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);

            try
            {
                kdc.ExecuteAskdc(true);
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                return;
            }

            throw new UnexpectedTestResultException("Expected request to be ignored, but got a response.");
        }

        [TestCase, Description("Multiple users, some autheticated with encrypted passports some not.")]
        //                                               users passportauth
        [CompoundCase("EncPass EncPass EncPass EncPass", 4,    new bool[4]{true,  true,  true, true})]
        [CompoundCase("EncPass NoPass EncPass",          3,    new bool[3]{true,  false, true})]
        [CompoundCase("NoPass EncPass NoPass",           3,    new bool[3]{false, true,  false})]
        [CompoundCase("NoPass EncPass",                  2,    new bool[2]{false, true})]
        [CompoundCase("EncPass NoPass",                  2,    new bool[2]{true,  false})]
        public void MultipleUsers(TestNode self)
        {
            int userCount=(int)self.MyValues[0];
            bool []usePassport=(bool[])self.MyValues[1];

            //prepare users
            Global.RO.Debug("Creating users with passports...");
            KdcUser []users=new KdcUser[userCount];
            for (int i=0; i<userCount; ++i)
            {
                users[i]=GetCachedPassportUser(i, "MBI", AuthClientBase.PassportSite.KdcXenon);
            }

            //xmacs
            Global.RO.Debug("Making request...");
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateXmacsRequest();
            kdc.ExecuteXmacs(true);

            //askdc machine
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //askdc user
            for (int i=0; i<userCount; ++i)
            {
                kdc.CreateAskdcUserRequest(users[i]);
                if (usePassport[i])
                {
                    kdc.AskdcRequest.Input.PlainPassport=null;
                    kdc.AskdcRequest.Input.EncryptedPassport=users[i].Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
                }
                else
                {
                    kdc.AskdcRequest.Input.PlainPassport=null;
                    kdc.AskdcRequest.Input.EncryptedPassport=null;
                }
                kdc.ExecuteAskdc(true);
            }

            //verify the askdc authdata pac credential type
            ValueCheck.Test("Machine PAC Credential Type", WindowsPacAuthData.CT_RandomKey, kdc.AskdcReply.AuthData.FindPuidCredentialType(kdc.XmacsOutput.MachineId));
            for (int i=0; i<userCount; ++i)
            {
                uint expectedType=usePassport[i]?WindowsPacAuthData.CT_EncryptedPassport:WindowsPacAuthData.CT_RandomKey;
                ValueCheck.Test("User"+i+" PAC Credential Type", expectedType, kdc.AskdcReply.AuthData.FindPuidCredentialType(users[i].UserID));
            }
        }

        [TestCase, Description("Ticket size in the preauth is wrong."), TestCasePriority(2)]
        //                                              fixedlen dynlen restick fixedtick dyntick
        [CompoundCase("0 Length Normal Ticket",         0,       null,  false,  null,     null)]
        [CompoundCase("1 Length Normal Ticket",         1,       null,  false,  null,     null)]
        [CompoundCase("699 Length Normal Ticket",       699,     null,  false,  null,     null)]
        [CompoundCase("700 Length Normal Ticket",       700,     null,  false,  null,     null)]
        [CompoundCase("701 Length Normal Ticket",       701,     null,  false,  null,     null)]
        [CompoundCase("65535 Length Normal Ticket",     65535,   null,  false,  null,     null)]
        [CompoundCase("Shorter Length Normal Ticket",   null,    -1,    false,  null,     null)]
        [CompoundCase("Longer Length Normal Ticket",    null,    +1,    false,  null,     null)]
        [CompoundCase("0 Length Matching Ticket",       0,       null,  true,   null,     null)]
        [CompoundCase("1 Length Matching Ticket",       1,       null,  true,   null,     null)]
        [CompoundCase("699 Length Matching Ticket",     699,     null,  true,   null,     null)]
        [CompoundCase("700 Length Matching Ticket",     700,     null,  true,   null,     null)]
        [CompoundCase("701 Length Matching Ticket",     701,     null,  true,   null,     null)]
        [CompoundCase("65535 Length Matching Ticket",   65535,   null,  true,   null,     null)]
        [CompoundCase("Shorter Length Matching Ticket", null,    -1,    true,   null,     null)]
        [CompoundCase("Longer Length Matching Ticket",  null,    +1,    true,   null,     null)]
        [CompoundCase("Normal Length 0 Ticket",         null,    null,  false,  0,        null)]
        [CompoundCase("Normal Length 1 Ticket",         null,    null,  false,  1,        null)]
        [CompoundCase("Normal Length 699 Ticket",       null,    null,  false,  699,      null)]
        [CompoundCase("Normal Length 700 Ticket",       null,    null,  false,  700,      null)]
        [CompoundCase("Normal Length 701 Ticket",       null,    null,  false,  701,      null)]
        [CompoundCase("Normal Length 65535 Ticket",     null,    null,  false,  65535,    null)]
        [CompoundCase("Normal Length Shorter Ticket",   null,    null,  false,  null,     -1)]
        [CompoundCase("Normal Length Longer Ticket",    null,    null,  false,  null,     +1)]
        public void BadTicketSize(TestNode self)
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();

            Global.RO.Debug("Creating a user with a passport...");
            KdcUser user=GetCachedPassportUser(3, "MBI", AuthClientBase.PassportSite.KdcXenon);
            user.Passport.EncryptForPanoramaByDefault=true;

            //xmacs
            Global.RO.Debug("Making request...");
            kdc.CreateXmacsRequest();
            kdc.ExecuteXmacs(true);

            //askdc machine
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //askdc user
            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
            kdc.AskdcRequest.Input.GeneratePreauths();

            Kerberos.Preauth<Kerberos.PreauthEncryptedPassport> paep=kdc.AskdcRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthEncryptedPassport>>();

            if (self.MyValues[0]!=null)
            {
                paep.Data.PassportTicketLength=(ushort)(int)self.MyValues[0];
            }
            else if (self.MyValues[1]!=null)
            {
                paep.Data.PassportTicketLength=(ushort)(paep.Data.PassportTicketLength+(int)self.MyValues[1]);
            }

            if (self.MyValues[2]!=null && (bool)self.MyValues[2])
            {
                System.Array.Resize(ref paep.Data.PassportTicket, paep.Data.PassportTicketLength);
            }

            if (self.MyValues[3]!=null)
            {
                System.Array.Resize(ref paep.Data.PassportTicket, (int)self.MyValues[3]);
            }
            else if (self.MyValues[4]!=null)
            {
                System.Array.Resize(ref paep.Data.PassportTicket, paep.Data.PassportTicket.Length+(int)self.MyValues[4]);
            }

            kdc.AskdcRequest.SetRequest();

            kdc.RetryLostPackets=false;
            try
            {
                kdc.ExecuteAskdc(false);
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                return;
            }

            throw new UnexpectedTestResultException("Askdc request unexpectedly succeeded.");
        }

        [TestCase, Description("Uses the encrypted passport preauth to authenticate a user and verify the credential type is set in the authdata.")]
        public void CorruptedTicket(TestNode self)
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();

            Global.RO.Debug("Creating a user with a passport...");
            KdcUser user=GetCachedPassportUser(0, "MBI", AuthClientBase.PassportSite.KdcXenon);
            user.Passport.EncryptForPanoramaByDefault=true;

            //xmacs
            Global.RO.Debug("Making request...");
            kdc.CreateXmacsRequest();
            kdc.ExecuteXmacs(true);

            //askdc machine
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //askdc user
            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
            for (int i=0; i<kdc.AskdcRequest.Input.EncryptedPassport.Bytes.Length; i+=8)
            {
                kdc.AskdcRequest.Input.EncryptedPassport.Bytes[i]=(byte)'X';
            }

            kdc.RetryLostPackets=false;
            try
            {
                kdc.ExecuteAskdc(true);
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                return;
            }

            throw new UnexpectedTestResultException("Askdc request unexpectedly succeeded.");
        }

        //NOTE: The native 4.5 rps server code doesn't work right for different policy durations.  Our KDC enforces times based on an npdb setting instead.  This is why MBI_60SECTEST doesn't work.
        [TestCase, Description("Use a passport RPS ticket that has expired.")]
        [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
        [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
        public class ExpiredPassportTicket: TestNode
        {
            private SettingState origSetting=null;
            private AuthContext.ClientTypes clientType;

            public override void PreRun()
            {
                clientType=(AuthContext.ClientTypes)MyValues[0];

                string settingName;
                if (clientType==AuthContext.ClientTypes.Xenon)
                {
                    settingName=xonline.common.config.Setting.kdcsvc_managed_rpsXenonLifetimeInSeconds;
                }
                else
                {
                    settingName=xonline.common.config.Setting.kdcsvc_managed_rpsPCLifetimeInSeconds;
                }
                origSetting=Global.XEnv.GetOverrideSettingState("ALL", "ALL", settingName, 1);
                Global.XEnv.OverrideSetting("ALL", "ALL", settingName, "10"); //10 second window
                Suite.RefreshKDCsConfig();
            }

            public override void PostRun()
            {
                if (origSetting!=null)
                {
                    //restore the original trust setting state
                    Global.XEnv.RestoreOverrideSettingState(origSetting);
                    origSetting=null;
                    Suite.RefreshKDCsConfig();
                }
            }

            public override void Run()
            {
                KdcClient kdc=new KdcClient(clientType);
                kdc.ExecuteXmacs(true);

                KdcUser user=new KdcUser();
                user.CreateUser(true);
                user.Passport.EncryptForPanoramaByDefault=true;
                PassportTicket shortLivedTicket=null;
                if (clientType==AuthContext.ClientTypes.Xenon)
                {
                    shortLivedTicket=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
                }
                else
                {
                    shortLivedTicket=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);
                }

                //should work immediately
                Global.RO.Debug("Verifying the ticket works now.");
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                kdc.CreateAskdcUserRequest(user);
                kdc.AskdcRequest.Input.EncryptedPassport=shortLivedTicket;
                kdc.ExecuteAskdc(true);

                //wait for it to expire, should fail
                Global.RO.Debug("Waiting 20 seconds for the 10 second ticket to expire.");
                System.Threading.Thread.Sleep(20000);

                Global.RO.Debug("Verifying the ticket that expired fails correctly.");
                kdc.ClearAskdc();

                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                kdc.CreateAskdcUserRequest(user);
                kdc.AskdcRequest.Input.EncryptedPassport=shortLivedTicket;

                kdc.AskdcThrowOnKerberosError=false;
                kdc.ExecuteAskdc(true);
                ValueCheck.Test("Got a Kerberos error response", true, kdc.AskdcError!=null);
                ValueCheck.Test("Kerberos Error", KerbErrCode.KDC_ERR_REVOKED_CERTIFICATE, kdc.AskdcError.ErrorCode.Int64);
            }
        }

        [TestCase, Description("Use a passport RPS ticket for a different user.")]
        public void MismatchedPassportPuid()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.ExecuteXmacs(true);

            KdcUser correctUser=GetCachedPassportUser(0, "MBI", AuthClientBase.PassportSite.KdcXenon);

            KdcUser otherUser=new KdcUser();
            otherUser.CreateUser(true);

            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            kdc.CreateAskdcUserRequest(correctUser);
            kdc.AskdcRequest.Input.EncryptedPassport=otherUser.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);

            kdc.AskdcThrowOnKerberosError=false;
            kdc.ExecuteAskdc(true);
            ValueCheck.Test("Got a Kerberos error response", true, kdc.AskdcError!=null);
            ValueCheck.Test("Kerberos Error", KerbErrCode.KDC_ERR_PASSPORT_PUID_MISMATCH, kdc.AskdcError.ErrorCode.Int64);
        }

        [TestCase, Description("Use a passport RPS ticket that is not associated with any xbox live user.")]
        public void NonXboxPassportPuid()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.ExecuteXmacs(true);

            KdcUser correctUser=GetCachedPassportUser(0, "MBI", AuthClientBase.PassportSite.KdcXenon);

            PassportAuth otherPassport=new PassportAuth();
            otherPassport.CreateUser();

            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            kdc.CreateAskdcUserRequest(correctUser);
            kdc.AskdcRequest.Input.EncryptedPassport=otherPassport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);

            kdc.AskdcThrowOnKerberosError=false;
            kdc.ExecuteAskdc(true);
            ValueCheck.Test("Got a Kerberos error response", true, kdc.AskdcError!=null);
            ValueCheck.Test("Kerberos Error", KerbErrCode.KDC_ERR_PASSPORT_PUID_MISMATCH, kdc.AskdcError.ErrorCode.Int64);
        }

        [TestCase, Description("Uses the encrypted passport preauth with a ticket obtained for the wrong site.  Unrelated sites are not valid.")]
        public void WrongPassportSiteNotConfigured()
        {
            const string TotallyDifferentPassportSite="xuacs.cert.xboxlive.com";

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.ExecuteXmacs(true);

            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            KdcUser user=GetCachedPassportUser(0, "MBI", TotallyDifferentPassportSite);

            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", TotallyDifferentPassportSite);

            try
            {
                kdc.RetryLostPackets=false;
                kdc.ExecuteAskdc(true);
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                return;
            }

            throw new UnexpectedTestResultException("Expected request to be ignored, but got a response.");
        }

        [TestCase, Description("THIS WILL FAIL ON XBLOBS since xuacs and kdc share the same rps site id.  Use the encrypted passport preauth with a ticket obtained for the wrong site.  Legacy site is not valid for roaming profiles even though the KDC's RPS config has both sites.")]
        public void WrongPassportSiteConfigured()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.ExecuteXmacs(true);

            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            KdcUser user=GetCachedPassportUser(0, "MBI", AuthClientBase.PassportSite.KdcPanorama);

            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            try
            {
                kdc.RetryLostPackets=false;
                kdc.ExecuteAskdc(true);
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                return;
            }

            throw new UnexpectedTestResultException("Expected request to be ignored, but got a response.");
        }

        /*
        Our KDC isn't currently accepting these.  They seem to have a different size anyways, so aren't really suitable for testing.
        [TestCase, Ignore("Doesn't currently work, our KDC is rejecting these tickets for some reason."), Description("Sanity check that a test-synthesized passport works.  NOTE: Synthesized tickets generally are a different size than real ones, do not use for any tests except when there is no other option.")]
        public void SanityTestSynthesizedPassport()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();

            Global.RO.Debug("Creating a user without a passport...");
            KdcUser user=new KdcUser();
            user.CreateUser(false);

            Global.RO.Debug("Generating and linking passport...");
            user.LinkSynthesizedTicket(null);

            //xmacs
            Global.RO.Debug("Making request...");
            kdc.CreateXmacsRequest();
            kdc.ExecuteXmacs(true);

            //askdc machine
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //askdc user
            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.EncryptedPassport=user.Passport;

            kdc.ExecuteAskdc(true);
        }
        */

    }; //class AskdcEncryptedPassport
} //namespace XkdcTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\ClientVersionTracking.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;

namespace XkdcTest
{
    [TestGroup, Description("Tests for the column added to t_machines that tracks the last seen client version of a machine."), TestCasePriority(2)]
    public class ClientVersionTracking
    {
        // -- utils

        public static uint MakeFlashNumber(uint major, uint minor, uint build, uint qfe)
        {
            //validate parameter ranges
            if ((qfe&~0xff)!=0) throw new System.Exception("Bad value for qfe.");
            if ((build&~0xffff)!=0) throw new System.Exception("Bad value for build.");
            if ((minor&~0xf)!=0) throw new System.Exception("Bad value for minor.");
            if ((major&~0xf)!=0) throw new System.Exception("Bad value for major.");

            //build
            uint number=0;
            number|=qfe;
            number|=build<<8;
            number|=minor<<24;
            number|=major<<28;
            return number;
        }

        public static string FlashNumberToString(uint number)
        {
            uint qfe=  (number&0x000000ff);
            uint build=(number&0x00ffff00)>>8;
            uint minor=(number&0x0f000000)>>24;
            uint major=(number&0xf0000000)>>28;
            return string.Format("{0:D2}.{1:D2}.{2:D5}.{3:D3}", major, minor, build, qfe);
        }

        // -- tests

        [TestGroup, AsyncGroup(1), Description("Mainline cases for the platforms of interest.")]
        [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
        [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
        public class TrackingPlatforms: TestNode
        {
            public override void PreRun()
            {
                CreateContextData();
                SetContextData("PlatformType", MyValues[0]);
            }

            //
            [TestCase, Description("A machine that has never connected to live before.")]
            public class NewMachine: TestNode
            {
                public override void Run()
                {
                    AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");

                    uint flashNumber=MakeFlashNumber(1,2,4,8);
                    string flashString=FlashNumberToString(flashNumber);

                    //create a new machine but don't get a ticket from it yet
                    AuthContext ctx=new AuthContext(clientType);
                    ctx.TitleInfo.FlashVersion=flashNumber;

                    XmacsClient xmacs=new XmacsClient(ctx);
                    xmacs.SignInXmacs();

                    //verify client version in db
                    MachineEditor dbMachine=MachineEditor.FromId(ctx.UsersMachine.xuid.qwUserID);
                    ValueCheck.Test("Current flash version in db after xmacs", "", dbMachine.ClientFlashVersion);

                    //now get a ticket from the xkdc
                    XkdcClient xkdc=new XkdcClient(ctx);
                    xkdc.SignInXkdc();
                    if (ctx.GetXkdcResult().ServiceHR!=0)
                    {
                        throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
                    }

                    //verify client version in db
                    ValueCheck.Test("current flash version in db after xkdc", flashString, dbMachine.ClientFlashVersion);

                    Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
                }
            };

            [TestCase, Description("A machine that has connected to live before.")]
            [CompoundCase("Empty Version",  null, 1, 1)]
            [CompoundCase("Lower Version",  2,    3, 3)]
            [CompoundCase("Higher Version", 6,    5, 5)]
            [CompoundCase("Same Version",   4,    4, 4)]
            public class ExistingMachine: TestNode
            {
                public override void Run()
                {
                    //gather parameters
                    AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");
                    string initialDbVersion="";
                    if (MyValues[0]!=null) initialDbVersion=FlashNumberToString(MakeFlashNumber(7, 8, (uint)(int)MyValues[0], 9));
                    uint loginBuild=(uint)(int)MyValues[1];
                    uint loginFlashNumber=MakeFlashNumber(7, 8, loginBuild, 9);
                    string expectFlashInDb=FlashNumberToString(MakeFlashNumber(7, 8, (uint)(int)MyValues[2], 9));

                    //setup machine in DB
                    MachineEditor dbMachine=MachineEditor.CreateNew(MachineEditor.AuthClientTypeToMachineType(clientType));
                    dbMachine.ClientFlashVersion=initialDbVersion;
                    Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);

                    //get a ticket from the xkdc
                    Global.RO.Debug("Getting a ticket with version: "+FlashNumberToString(loginFlashNumber));
                    AuthContext ctx=new AuthContext(clientType);
                    ctx.SetMachine(dbMachine);
                    ctx.TitleInfo.FlashVersion=loginFlashNumber;

                    XkdcClient xkdc=new XkdcClient(ctx);
                    xkdc.SignInXkdc();
                    if (ctx.GetXkdcResult().ServiceHR!=0)
                    {
                        throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
                    }

                    //verify db
                    ValueCheck.Test("current flash version in db", expectFlashInDb, dbMachine.ClientFlashVersion);

                    Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
                }
            };

            [TestCase, Description("Check that flash is updated when an error is returned.")]
            public void KerberosError()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");
                uint flashNumber=MakeFlashNumber(4,3,2,1);
                string flashString=FlashNumberToString(flashNumber);

                //try to get ticket
                Global.RO.Debug("Attempting to get a ticket to a bad title with version: "+flashString);
                AuthContext ctx=new AuthContext(clientType);
                ctx.SetTitle(0x78901234, 56, 78);
                ctx.TitleInfo.FlashVersion=flashNumber;
                XkdcClient xkdc=new XkdcClient(ctx);
                xkdc.SignInXkdc();
                if (ctx.GetXkdcResult().ServiceHR!=0x80151912) //invalid title id error
                {
                    throw new UnexpectedTestResultException("Xkdc request result was wrong: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
                }

                //check db
                MachineEditor dbMachine=MachineEditor.FromId(ctx.UsersMachine.xuid.qwUserID);
                ValueCheck.Test("Current flash version in db after xmacs", flashString, dbMachine.ClientFlashVersion);
                Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
            }
        };

        //Support for all non-tracking platforms was removed from the KDC.  Commenting out attributes so they don't get picked up, but still compiled in case a new platform is added in the future.
        //[TestGroup, AsyncGroup(1), Description("We don't track versions for xbox1 or fusion, should always be empty.")]
        //[CompoundCase("Xbox1", AuthContext.ClientTypes.Xbox)]
        //[CompoundCase("Fusion", AuthContext.ClientTypes.XenonBackCompat)]
        public class NontrackingPlatforms: TestNode
        {
            public override void PreRun()
            {
                CreateContextData();
                SetContextData("PlatformType", MyValues[0]);
            }

            //
            [TestCase]
            public void NewMachine()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");

                //create a new machine
                AuthContext ctx=new AuthContext(clientType);
                XmacsClient xmacs=new XmacsClient(ctx);
                xmacs.SignInXmacs();

                //verify client version in db
                MachineEditor dbMachine=MachineEditor.FromId(ctx.UsersMachine.xuid.qwUserID);
                ValueCheck.Test("Current flash version in db after xmacs", "", dbMachine.ClientFlashVersion);

                //get a ticket
                XkdcClient xkdc=new XkdcClient(ctx);
                xkdc.SignInXkdc();
                if (ctx.GetXkdcResult().ServiceHR!=0)
                {
                    throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
                }

                //verify client version in db
                dbMachine=MachineEditor.FromId(ctx.UsersMachine.xuid.qwUserID);
                ValueCheck.Test("Current flash version in db after xkdc", "", dbMachine.ClientFlashVersion);

                Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
            }

            [TestCase]
            public void ExistingMachine()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");

                //directly create a new machine
                MachineEditor dbMachine=MachineEditor.CreateNew(MachineEditor.AuthClientTypeToMachineType(clientType));

                //get a ticket
                AuthContext ctx=new AuthContext(clientType);
                ctx.SetMachine(dbMachine);
                XkdcClient xkdc=new XkdcClient(ctx);
                xkdc.SignInXkdc();
                if (ctx.GetXkdcResult().ServiceHR!=0)
                {
                    throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
                }

                //verify client version in db
                ValueCheck.Test("Current flash version in db after xkdc", "", dbMachine.ClientFlashVersion);
                Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
            }
        };

        [TestCase, AsyncGroup(2), Description("Min valued version")]
        public void MinValue()
        {
            //get a ticket
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            XkdcClient xkdc=new XkdcClient(ctx);
            ctx.TitleInfo.FlashVersion=0;
            xkdc.SignInXkdc();
            if (ctx.GetXkdcResult().ServiceHR!=0)
            {
                throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
            }

            //verify client version in db
            MachineEditor dbMachine=MachineEditor.FromId(ctx.UsersMachine.xuid.qwUserID);
            ValueCheck.Test("current flash version in db after xkdc", "", dbMachine.ClientFlashVersion);
            Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
        }

        [TestCase, AsyncGroup(2), Description("Max valued version")]
        public void MaxValue()
        {
            //get a ticket
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            XkdcClient xkdc=new XkdcClient(ctx);
            ctx.TitleInfo.FlashVersion=~(uint)0;
            xkdc.SignInXkdc();
            if (ctx.GetXkdcResult().ServiceHR!=0)
            {
                throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
            }

            //verify client version in db
            MachineEditor dbMachine=MachineEditor.FromId(ctx.UsersMachine.xuid.qwUserID);
            ValueCheck.Test("current flash version in db after xkdc", "15.15.65535.255", dbMachine.ClientFlashVersion);
            Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
        }

        [TestCase, AsyncGroup(2), Description("A valid value not representable by a client request already in the db, we should still be able to get a ticket")]
        public void ImpossibleValueInDb()
        {
            //create machine
            MachineEditor dbMachine=MachineEditor.CreateNew(MachineType.Xbox360);
            dbMachine.ClientFlashVersion="99.99.99999.999";

            //verify we can get a ticket
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            XkdcClient xkdc=new XkdcClient(ctx);
            ctx.TitleInfo.FlashVersion=~(uint)0;
            xkdc.SignInXkdc();
            if (ctx.GetXkdcResult().ServiceHR!=0)
            {
                throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
            }

            Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
        }

        [TestCase, AsyncGroup(2), Description("A totally bogus in the db, we should still be able to get a ticket")]
        public void InvalidValueInDb()
        {
            //create machine
            MachineEditor dbMachine=MachineEditor.CreateNew(MachineType.Xbox360);
            dbMachine.ClientFlashVersion="X$#!\"'`[b}+*@/\\";

            //verify we can get a ticket
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            XkdcClient xkdc=new XkdcClient(ctx);
            ctx.TitleInfo.FlashVersion=~(uint)0;
            xkdc.SignInXkdc();
            if (ctx.GetXkdcResult().ServiceHR!=0)
            {
                throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
            }

            Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
        }

        [TestCase(BugID=25603, BugDatabase="Xbox 360 Console Software"), Description("Rollback flash and bypass db check")]
        public void RollbackFlashToBypassDbCheckRepro()
        {
            uint flashNumber=MakeFlashNumber(1,2,3,4);

            //create a new machine with xmacs
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            XmacsClient xmacs=new XmacsClient(ctx);
            xmacs.SignInXmacs();

            //verify client version in db
            MachineEditor dbMachine=MachineEditor.FromId(ctx.UsersMachine.xuid.qwUserID);
            ValueCheck.Test("Current flash version in db after xmacs", "", dbMachine.ClientFlashVersion);

            //now get a ticket from the xkdc
            Global.RO.Debug("Doing auto-discover xbox360 request on "+FlashNumberToString(flashNumber));
            ctx.TitleInfo.FlashVersion=flashNumber;
            XkdcClient xkdc=new XkdcClient(ctx);
            xkdc.SetRequest(null, true);
            xkdc.SignInXkdc();
            Global.RO.Debug(ctx.GetXkdcResult().ToString());

            if (ctx.GetXkdcResult().ServiceHR!=0)
            {
                throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
            }

            //verify client version in db
            Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
            ValueCheck.Test("Current flash version in db after xkdc", FlashNumberToString(flashNumber), dbMachine.ClientFlashVersion);

            //sign in again, since the last one populated the initial flash version. we 
            //need to clear the xkdc cache so it gets populated with version 1.2.3.4 
            //instead of 0. an auto-discover request will do that.
            xkdc.SignInXkdc();

            //roll back flash version
            uint hackedFlashNumber=MakeFlashNumber(1,2,3,3);

            //get auto-discovered services
            uint[] services = ctx.GetXkdcResult().ServiceIDs;

            //now get the second ticket from the xkdc
            Global.RO.Debug("Doing manual xbox360 request on "+FlashNumberToString(hackedFlashNumber));
            ctx.TitleInfo.FlashVersion=hackedFlashNumber;
            xkdc.SetRequest(services, false);  // no autodiscover
            xkdc.SignInXkdc();
            Global.RO.Debug(ctx.GetXkdcResult().ToString());

            if (ctx.GetXkdcResult().ServiceHR!=0)
            {
                throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
            }

            //verify client version in db is the new, lower one.
            Global.RO.Debug("Flash version in DB: "+dbMachine.ClientFlashVersion);
            ValueCheck.Test("Current flash version in db after xkdc", FlashNumberToString(hackedFlashNumber), dbMachine.ClientFlashVersion);

            // @@@ Note: only action currently when a rollback is detected is an NT event 
            // (id 10000, source xkdc). This test does not check for that. It should.

            // This test *should* return FAILED if there is no event, or PASSED if there 
            // is an event.
        }

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\DBLimiter.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace XkdcTest
{
    //DBLimiter works based on three settings:
    // - kdcsvc_managed_limitThreadPercentThreshold: Once this percent of the worker threads (kdcsvc_core_ATQThreads) are in use, per-partition throttling is enabled.
    // - kdcsvc_managed_limitThreadPercentDeactivationThreshold: If throttling is enabled, then once the percent of worker threads drops below this amount, throttling is disabled.
    // - kdcsvc_managed_limitThreadPercentPerPartition: No more than this percent of the worker thread pool is allowed on any single partition.  Requests to these partitions will fail with KDC_ERR_SERVICE_NOTYET.
    //To facilitate testing, there is a third setting which can only be enabled in development environments:
    // - kdcsvc_managed_simulateDbLatencyInMs: All DB calls have this much latency added to them (sleep in the KDC managed code right where the SQL call is made).

    //These tests will attempt to max out the thread limit on all partitions then make a request, and verify the return code and execution time.  Also verify that the threads that made it succeed.
    //Note that the failure at the DB layer can propegate back through many different KDC code paths.

    //These tests are very tightly coupled with the order in which the KDC makes its requests to the databases.  Orders are listed below.  If these change then these tests will need updated.
    // - Xmacs Create (Xbox360): Request 1 to UODB hashed on ConsoleID, Request 2 to UODB hashed on ConsoleID, Request 3 to UODB hashed on MachinePuid
    // - Xmacs Reset (Xbox360): Request 1 to UODB hashed on ConsoleID, Request 2 to UODB hashed on ConsoleID, Request 3 to UODB hashed on MachinePuid
    // - Xmacs Create (PC): Request 1 to UODB hashed on passport puid, Request 2 to TokenDB hashed on voucher, Request 3 to UODB hashed on voucher, Request 4 to UODB hashed on voucher offer, Request 5 to UODB hashed on voucher, Request 6 to UODB hashed on consoleid, Request 7 to UODB hashed on machine puid, if requires activation then Request 8 to UODB hashed on token, if requires activation then Request 9 to UODB hashed on machine puid
    // - Xmacs Reset (PC): Roughly similar to create.
    // - Askdc Key: Request 1 to UODB hashed on principal name (gamertag or consoleid)
    // - Askdc Plain Passport: Request 1 to UODB hashed on passport puid, TODO(Request to UODB hashed on user puid?  Need to check.), Request 2 to UODB hashed on gamertag
    // - Askdc Encrypted Passport: Request 1 to UODB hashed on gamertag, Request 2 to UODB hashed on passport puid
    // - Xkdc Machine: Request 1 to UODB hashed on machine puid, if flash version changed then Request 2 to UODB hashed on machine puid.
    // - Xkdc User: Request 1 to UODB hashed on machne puid, if flash version changed then Request 2 to UODB hashed on machine puid, Request 3 to UODB hashed on user puid.

    [TestGroup, Description("Tests for DBLimiter, which throttles connections to database partitions that consume too many worker threads.")]
    public class DBLimiter: TestNode
    {
        // -- Setup

        SettingState orig_kdcsvc_managed_limitThreadPercentThreshold=null;
        SettingState orig_kdcsvc_managed_limitThreadPercentDeactivationThreshold=null;
        SettingState orig_kdcsvc_managed_limitThreadPercentPerPartition=null;
        SettingState orig_kdcsvc_managed_simulateDbLatencyInMs=null;
        SettingState orig_kdcsvc_askdc_echo_enabled=null;

        public override void PreRun()
        {
            //save the original settings
            orig_kdcsvc_managed_limitThreadPercentThreshold=Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentThreshold, 1);
            orig_kdcsvc_managed_limitThreadPercentDeactivationThreshold=Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentDeactivationThreshold, 1);
            orig_kdcsvc_managed_limitThreadPercentPerPartition=Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentPerPartition, 1);
            orig_kdcsvc_managed_simulateDbLatencyInMs=Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_managed_simulateDbLatencyInMs, 1);
            orig_kdcsvc_askdc_echo_enabled=Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_askdc_echo_enabled, 1);

            //echo complicates things and isn't affected by dblimiter, so let's disable it for these tests
            Global.RO.Debug("Setting kdcsvc_askdc_echo_enabled to: 0");
            Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_askdc_echo_enabled, "0");

            Suite.RefreshKDCsConfig();

            //reset state
            saturationUsersUodb=null;
        }

        public override void PostRun()
        {
            bool needRefresh=false;

            if (orig_kdcsvc_managed_limitThreadPercentThreshold!=null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring kdcsvc_managed_limitThreadPercentThreshold.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_managed_limitThreadPercentThreshold);
                orig_kdcsvc_managed_limitThreadPercentThreshold=null;
                needRefresh=true;
            }

            if (orig_kdcsvc_managed_limitThreadPercentDeactivationThreshold!=null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring kdcsvc_managed_limitThreadPercentDeactivationThreshold.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_managed_limitThreadPercentDeactivationThreshold);
                orig_kdcsvc_managed_limitThreadPercentDeactivationThreshold=null;
                needRefresh=true;
            }

            if (orig_kdcsvc_managed_limitThreadPercentPerPartition!=null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring kdcsvc_managed_limitThreadPercentPerPartition.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_managed_limitThreadPercentPerPartition);
                orig_kdcsvc_managed_limitThreadPercentPerPartition=null;
                needRefresh=true;
            }

            if (orig_kdcsvc_managed_simulateDbLatencyInMs!=null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring kdcsvc_managed_simulateDbLatencyInMs.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_managed_simulateDbLatencyInMs);
                orig_kdcsvc_managed_simulateDbLatencyInMs=null;
                needRefresh=true;
            }

            if (orig_kdcsvc_askdc_echo_enabled!=null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring kdcsvc_askdc_echo_enabled.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_askdc_echo_enabled);
                orig_kdcsvc_askdc_echo_enabled=null;
                needRefresh=true;
            }

            if (needRefresh)
            {
                Suite.RefreshKDCsConfig();
            }
        }

        // -- Test Helpers

        public class EnvironmentIsInadequateException: System.Exception
        {
            public EnvironmentIsInadequateException(string m): base(m) {}
        }

        //Unfortunately C# List sucks compared to C++ stl vector.  So I get to implement this myself.
        private static void ResizeList<T>(List<T> list, int count)
        {
            if (list.Count<count)
            {
                list.Capacity=count;
            }

            while (list.Count<count)
            {
                list.Add(default(T));
            }

            while (list.Count>count)
            {
                list.RemoveAt(list.Count-1);
            }
        }

        public static int GetPhysicalUodbPartitionCount()
        {
            return UodbWS.WstPhysicalPartitionCount();
        }

        public static int GetPhysicalUodbPartitionForUser(ulong userPuid)
        {
            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                return ws.GetPhysicalPartition(ws.Partition);
            }
        }

        public static int GetPhysicalUodbPartitionForUser(string gamertag)
        {
            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.SetHashVal(gamertag);
                return ws.GetPhysicalPartition(ws.Partition);
            }
        }

        public static int GetPhysicalTokendbPartitionCount()
        {
            return TokendbWS.WstPhysicalPartitionCount();
        }

        public static int GetPhysicalTokendbPartitionForVoucher(string voucher)
        {
            string voucherHash=TokendbWS.HashPanoramaVoucher(voucher);

            using (WSClient ws=new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.SetHashVal(voucherHash);
                return ws.GetPhysicalPartition(ws.Partition);
            }
        }

        private static List<KdcUser> saturationUsersUodb;
        private static KdcClientXbox360[] saturationClientsUodb;
        private static DateTime saturationBeginTimeUodb;
        private static System.Threading.Thread delaySaturationThread;

        private static void PrepareSaturationUsersUodb()
        {
            int partitionCount=GetPhysicalUodbPartitionCount();

            if (saturationUsersUodb==null)
            {
                Global.RO.Info("Creating a set of users evently distributed accross all "+partitionCount+" UODB partitions.");
                List<KdcUser> newUsers=new List<KdcUser>();
                ResizeList(newUsers, partitionCount);
                while (true)
                {
                    //if all partitions have a user we're done
                    bool anyPartitionMissing=false;
                    for (int i=0; i<partitionCount; ++i)
                    {
                        if (newUsers[i]==null)
                        {
                            anyPartitionMissing=true;
                            break;
                        }
                    }

                    if (!anyPartitionMissing)
                    {
                        break;
                    }

                    //make a new user and see if they landed on an empty slot
                    KdcUser newUser=new KdcUser();
                    newUser.CreateUser(false);

                    int newUserPartition=GetPhysicalUodbPartitionForUser(newUser.Gamertag);

                    if (newUsers[newUserPartition]==null)
                    {
                        newUsers[newUserPartition]=newUser;
                    }
                }
                saturationUsersUodb=newUsers;

                for (int i=0; i<partitionCount; ++i)
                {
                    Global.RO.Debug("SaturationUser["+i+"]("+saturationUsersUodb[i].Gamertag+string.Format(", 0x{0:X}", saturationUsersUodb[i].UserID)+") is on physical partition "+GetPhysicalUodbPartitionForUser(saturationUsersUodb[i].Gamertag));
                }
            }
        }

        //This will create (if needed) a batch of users who hash to every partition then send out an askdc key request for each of those users and return.
        public static void BeginSaturateUodbPartitions(params int[] partitionsToSaturate)
        {
            saturationClientsUodb=null;
            int partitionCount=GetPhysicalUodbPartitionCount();

            PrepareSaturationUsersUodb();

            if (partitionsToSaturate==null)
            {
                partitionsToSaturate=new Int32[partitionCount];
                for (int i=0; i<partitionsToSaturate.Length; ++i)
                {
                    partitionsToSaturate[i]=i;
                }
            }

            KdcClientXbox360[] clients=new KdcClientXbox360[partitionCount];
            foreach(Int32 partition in partitionsToSaturate)
            {
                Global.RO.Info("Saturating UODB partition "+partition+".");

                clients[partition]=new KdcClientXbox360();
                clients[partition].CreateAskdcUserRequest(saturationUsersUodb[partition]);

                clients[partition].AskdcRequest.Input.GeneratePreauths();
                clients[partition].AskdcRequest.SetRequest();
                clients[partition].AskdcRequest.ConstructRequest();
            }

            foreach (KdcClientXbox360 client in clients)
            {
                if (client!=null)
                {
                    byte[] packet=client.AskdcRequest.GetBytes();
                    client.SendPacket(packet);
                }
                //client.AskdcNOnces[client.AskdcNOncesUsed++]=client.AskdcRequest.Input.NOnce;
            }

            saturationClientsUodb=clients;
            saturationBeginTimeUodb=DateTime.UtcNow;

            System.Threading.Thread.Sleep(250); //we want to make sure these requests get processed before the test's requests are
        }

        struct DelayBeginSaturateUodbPartitions_Data
        {
            public int msToDelay;
            public int []partitions;
        }

        public static void DelayBeginSaturateUodbPartitions(int msToDelay, params int []partitions)
        {
            PrepareSaturationUsersUodb();

            if (delaySaturationThread!=null)
            {
                delaySaturationThread.Join();
                delaySaturationThread=null;
            }

            saturationBeginTimeUodb=System.DateTime.MinValue;

            DelayBeginSaturateUodbPartitions_Data data=new DelayBeginSaturateUodbPartitions_Data();
            data.msToDelay=msToDelay;
            data.partitions=partitions;

            delaySaturationThread=ThreadMaker.CreateThread(DelayBeginSaturateUodbPartitions_Proc, data);
            delaySaturationThread.Start();
        }

        private static void DelayBeginSaturateUodbPartitions_Proc(object o)
        {
            DelayBeginSaturateUodbPartitions_Data data=(DelayBeginSaturateUodbPartitions_Data)o;
            System.Threading.Thread.Sleep(data.msToDelay);
            BeginSaturateUodbPartitions(data.partitions);
        }

        //This will verify the results of the requests sent out by BeginSaturateUodbPartitions.
        public static void EndSaturateUodbPartitions()
        {
            if (delaySaturationThread!=null)
            {
                delaySaturationThread.Join();
                delaySaturationThread=null;
            }

            if (saturationClientsUodb==null)
            {
                throw new UnexpectedTestResultException("EndSaturateUodbPartitions called without BeginSaturateUodbPartitions?");
            }

            Global.RO.Info("Verifying the saturation requests all eventually succeeded.");
            int partitionCount=GetPhysicalUodbPartitionCount();

            foreach (KdcClientXbox360 client in saturationClientsUodb)
            {
                if (client==null)
                {
                    continue;
                }

                int timeBeforeTimeout=2000-(int)(DateTime.UtcNow-saturationBeginTimeUodb).TotalMilliseconds;
                if (timeBeforeTimeout<0)
                {
                    timeBeforeTimeout=0;
                }

                byte []packet=client.ReceivePacket(timeBeforeTimeout);
                if (packet==null)
                {
                    throw new UnexpectedTestResultException("Saturation request timed out.");
                }

                long replyBytesUsed;
                AsnValueBase asn=Compound.AsnValueParser.Parse(packet, 0, packet.Length, out replyBytesUsed);
                client.SetAskdcReply(asn);
                //Note that setting the reply will by default throw if there was a kerberos error returned
            }
        }

        public static void SendXmacsAndVerifyError(KdcClient client)
        {
            SendXmacsAndVerifyError(client, 0, 750);
        }

        public static void SendXmacsAndVerifyError(KdcClient client, int minExpectedTimeInMs, int maxExpectedTimeInMs)
        {
            Global.RO.Info("Sending request.");
            DateTime timeSent=DateTime.UtcNow;
            client.XmacsThrowOnKerberosError=false;
            client.RetryLostPackets=false;
            client.ExecuteXmacs(true);
            DateTime timeReceived=DateTime.UtcNow;
            int millisecondsConsumed=(int)(timeReceived-timeSent).TotalMilliseconds;

            ValueCheck.Test("Xmacs returned a kerberos reply", false, client.XmacsReply!=null);
            ValueCheck.Test("Xmacs returned a kerberos error", true, client.XmacsError!=null);
            ValueCheck.Test("Kerberos Error code returned", KerbErrCode.KDC_ERR_SERVICE_NOTYET, (KerbErrCode)client.XmacsError.ErrorCode.Int64);

            if (millisecondsConsumed<minExpectedTimeInMs)
            {
                throw new UnexpectedTestResultException("Execution time "+millisecondsConsumed+" was less than minimum expected "+minExpectedTimeInMs);
            }

            if (millisecondsConsumed>maxExpectedTimeInMs)
            {
                throw new UnexpectedTestResultException("Execution time "+millisecondsConsumed+" was greater than maximum expected "+maxExpectedTimeInMs);
            }

            Global.RO.Debug("Got expected error "+(KerbErrCode)client.XmacsError.ErrorCode.Int64+" after "+millisecondsConsumed+"ms.");
        }

        public static void SendAskdcAndVerifyError(KdcClient client)
        {
            SendAskdcAndVerifyError(client, 0, 750);
        }

        public static void SendAskdcAndVerifyError(KdcClient client, int minExpectedTimeInMs, int maxExpectedTimeInMs)
        {
            Global.RO.Info("Sending request.");
            DateTime timeSent=DateTime.UtcNow;
            client.AskdcThrowOnKerberosError=false;
            client.RetryLostPackets=false;
            client.ExecuteAskdc(true);
            DateTime timeReceived=DateTime.UtcNow;
            int millisecondsConsumed=(int)(timeReceived-timeSent).TotalMilliseconds;

            ValueCheck.Test("Askdc returned a kerberos reply", false, client.AskdcReply!=null);
            ValueCheck.Test("Askdc returned a kerberos error", true, client.AskdcError!=null);
            ValueCheck.Test("Kerberos Error code returned", KerbErrCode.KDC_ERR_SERVICE_NOTYET, (KerbErrCode)client.AskdcError.ErrorCode.Int64);

            if (millisecondsConsumed<minExpectedTimeInMs)
            {
                throw new UnexpectedTestResultException("Execution time "+millisecondsConsumed+" was less than minimum expected "+minExpectedTimeInMs);
            }

            if (millisecondsConsumed>maxExpectedTimeInMs)
            {
                throw new UnexpectedTestResultException("Execution time "+millisecondsConsumed+" was greater than maximum expected "+maxExpectedTimeInMs);
            }

            Global.RO.Debug("Got expected error "+(KerbErrCode)client.AskdcError.ErrorCode.Int64+" after "+millisecondsConsumed+"ms.");
        }

        public static void SendXkdcAndVerifyError(KdcClient client)
        {
            SendXkdcAndVerifyError(client, 0, 750);
        }

        public static void SendXkdcAndVerifyError(KdcClient client, int minExpectedTimeInMs, int maxExpectedTimeInMs)
        {
            Global.RO.Info("Sending request.");
            DateTime timeSent=DateTime.UtcNow;
            client.XkdcThrowOnKerberosError=false;
            client.RetryLostPackets=false;
            client.ExecuteXkdc(true);
            DateTime timeReceived=DateTime.UtcNow;
            int millisecondsConsumed=(int)(timeReceived-timeSent).TotalMilliseconds;

            ValueCheck.Test("Xkdc returned a kerberos reply", false, client.XkdcReply!=null);
            ValueCheck.Test("Xkdc returned a kerberos error", true, client.XkdcError!=null);
            ValueCheck.Test("Kerberos Error code returned", KerbErrCode.KDC_ERR_SERVICE_NOTYET, (KerbErrCode)client.XkdcError.ErrorCode.Int64);

            if (millisecondsConsumed<minExpectedTimeInMs)
            {
                throw new UnexpectedTestResultException("Execution time "+millisecondsConsumed+" was less than minimum expected "+minExpectedTimeInMs);
            }

            if (millisecondsConsumed>maxExpectedTimeInMs)
            {
                throw new UnexpectedTestResultException("Execution time "+millisecondsConsumed+" was greater than maximum expected "+maxExpectedTimeInMs);
            }

            Global.RO.Debug("Got expected error "+(KerbErrCode)client.XkdcError.ErrorCode.Int64+" after "+millisecondsConsumed+"ms.");
        }

        // -- Tests

        [TestGroup, Description("Tests that cross the high water mark then verify specific cases are blocked.")]
        public class HighMark: TestNode
        {
            public override void PreRun()
            {
                //override the settings.  We want throttling enabled after 1 request in progress.  We want 1 thread allowed per partition.  We want highly latent requests. Low mark = high mark.
                float currentMaxThreads=Config.GetIntSetting(Setting.kdcsvc_core_ATQThreads);
                float throttleStartPercent=100.01f/currentMaxThreads; //account for floating point error
                float percentPerPartition=100.01f/currentMaxThreads; //account for floating point error
                int dbLatencyInMs=1000; //1 seconds

                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentThreshold to: "+throttleStartPercent);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentThreshold, throttleStartPercent.ToString());
                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentDeactivationThreshold to: "+throttleStartPercent);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentDeactivationThreshold, throttleStartPercent.ToString());
                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentPerPartition to: "+percentPerPartition);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentPerPartition, percentPerPartition.ToString());
                Global.RO.Debug("Setting kdcsvc_managed_simulateDbLatencyInMs to: "+dbLatencyInMs);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_simulateDbLatencyInMs, dbLatencyInMs.ToString());

                Suite.RefreshKDCsConfig();
            }

            //Sanity check that partition saturation functions work as expected, since all other tests depend on them.  This doesn't do anything fancy like verify all the partitions are actually used, just verifies the code completes as expected.
            [TestCase]
            public class SanityCheckPartitionSaturation: TestNode
            {
                public override void Run()
                {
                    Global.RO.Info("Testing all partitions");
                    DateTime endStart;
                    DateTime endEnd;
                    try
                    {
                        BeginSaturateUodbPartitions(null);
                        endStart=DateTime.UtcNow;
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                    endEnd=DateTime.UtcNow;

                    int msForEnd=(int)(endEnd-endStart).TotalMilliseconds;
                    if (msForEnd<500 || msForEnd>1500) //expect 1 second since that's the latency we set
                    {
                        throw new UnexpectedTestResultException("Expected EndSaturateUodbPartitions to completely in around 1000ms(+=500), but it it took: "+msForEnd+"ms");
                    }

                    //

                    Global.RO.Info("Testing 1 partitions");
                    try
                    {
                        BeginSaturateUodbPartitions(0);
                        endStart=DateTime.UtcNow;
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                    endEnd=DateTime.UtcNow;

                    msForEnd=(int)(endEnd-endStart).TotalMilliseconds;
                    if (msForEnd<500 || msForEnd>1500) //expect 1 second since that's the latency we set
                    {
                        throw new UnexpectedTestResultException("Expected EndSaturateUodbPartitions to completely in around 1000ms(+=500), but it it took: "+msForEnd+"ms");
                    }
                }
            }

            //Xmacs Create
            [TestCase]
            public class XmacsCreateXbox360_ConsoleID: TestNode
            {
                //The first internal xmacs request will be hashed on consoleid.  It is a lookup and will fail in this case.

                public override void PreRun()
                {
                    BeginSaturateUodbPartitions(null);
                }

                public override void Run()
                {
                    try
                    {
                        KdcClientXbox360 client=new KdcClientXbox360();
                        client.CreateXmacsRequest();
                        SendXmacsAndVerifyError(client);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Xmacs Create
            //[TestCase] //TODO - How are we going to do this?  I don't think we can without additional KDC instrumentation.
            public class XmacsCreateXbox360_Puid: TestNode
            {
                //The first two internal xmacs request will be hashed on consoleid.  The third request is hashed on machine puid.
                //Xmacs picks the puid though, so we can't predict which partition that will end up on.
            }

            //Xmacs Reset
            //[TestCase] //TODO - How are we going to do this?  I don't think we can without additional KDC instrumentation.
            public class XmacsResetXbox360_ConsoleID: TestNode
            {
                //The first internal xmacs request is a lookup hashed on consoleid.
                //The second one is a write to the machine key.  We want to catch that here.  Unfortunately it's hashed the same way as the first one, so we can't time it to fail.
            }

            //Xmacs Reset
            [TestCase]
            public class XmacsResetXbox360_Puid: TestNode
            {
                //The first two internal xmacs requests will be hashed on consoleid.
                //The third request is hashed on machine puid.  We want this one to fail.

                KdcClient client;

                public override void PreRun()
                {
                    if (GetPhysicalUodbPartitionCount()<2)
                    {
                        throw new EnvironmentIsInadequateException("This test requires at least 2 UODB partitions.");
                    }

                    //create a machine whose consoleid hashes to a different partition than it's machine puid
                    int machinePartition=-1;
                    int consoleidPartition=-1;
                    while (machinePartition==consoleidPartition)
                    {
                        client=new KdcClientXbox360();
                        client.ExecuteXmacs(true);

                        machinePartition=GetPhysicalUodbPartitionForUser(client.XmacsOutput.MachineId);
                        consoleidPartition=GetPhysicalUodbPartitionForUser(client.XmacsOutput.ConsoleId);
                    }
                    Global.RO.Debug("Machine("+client.XmacsOutput.ConsoleId+string.Format(", 0x{0:X}", client.XmacsOutput.MachineId)+").");
                    Global.RO.Debug(" consoleid is on physical partition "+consoleidPartition);
                    Global.RO.Debug(" machine puid is on physical partition "+machinePartition);

                    DelayBeginSaturateUodbPartitions(1500, machinePartition);
                }

                public override void Run()
                {
                    try
                    {
                        client.CreateXmacsRequest(); //sets it up for a reset call rather than create
                        SendXmacsAndVerifyError(client, 1750, 2750);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Xmacs Create
            [TestCase]
            public class XmacsPC_Step1: TestNode
            {
                //First request is to UODB by passport puid.  We want this one to fail.

                KdcUser user;

                public override void PreRun()
                {
                    user=new KdcUser();
                    user.CreateUser(true);

                    user.Passport.GetTicket("MBI_KEY", AuthClientBase.PassportSite.KdcPanorama); //cache ticket locally now since later we're time-constrained

                    Global.RO.Debug("TestUser("+user.Gamertag+string.Format(", Puid=0x{0:X}", user.UserID)+string.Format(", Passport=0x{0:X}", user.Passport.Puid)+") passport is on physical partition "+GetPhysicalUodbPartitionForUser(user.Passport.Puid));

                    BeginSaturateUodbPartitions(null);
                }

                public override void Run()
                {
                    try
                    {
                        KdcClientPC client=new KdcClientPC();
                        client.CreateXmacsRequest();
                        client.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY", AuthClientBase.PassportSite.KdcPanorama);
                        SendXmacsAndVerifyError(client);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Xmacs Create
            //[TestCase] //TODO - How are we going to do this?  Xmacs PC requests hit UODB then TokenDB, we can't easilly make machines hash to different UODB partitions -and- distinct TokenDB partitinos at the same time.
            public class XmacsPC_Step2: TestNode
            {
                //First request is to UODB hashed on passport puid.
                //Second request is to TokenDB hashed on voucherhash.  We want this one to fail.
            }

            //Askdc User
            [TestCase]
            public class AskdcUserKey: TestNode
            {
                //The internal askdc request is hashed on gamertag.

                KdcUser user;

                public override void PreRun()
                {
                    user=new KdcUser();
                    user.CreateUser(false);
                    Global.RO.Debug("TestUser("+user.Gamertag+string.Format(", 0x{0:X}", user.UserID)+") gamertag is on physical partition "+GetPhysicalUodbPartitionForUser(user.Gamertag));

                    BeginSaturateUodbPartitions(null);
                }

                public override void Run()
                {
                    try
                    {
                        KdcClientXbox360 client=new KdcClientXbox360();
                        client.CreateAskdcUserRequest(user);
                        SendAskdcAndVerifyError(client);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Askdc Machine
            [TestCase]
            public class AskdcMachineKey: TestNode
            {
                //The internal askdc request is hashed on console id

                KdcClientXbox360 client;

                public override void PreRun()
                {
                    client=new KdcClientXbox360();
                    client.ExecuteXmacs(true);
                    Global.RO.Debug("Machine consoleid("+client.XmacsOutput.ConsoleId+") is on physical partition "+GetPhysicalUodbPartitionForUser(client.XmacsOutput.ConsoleId));

                    BeginSaturateUodbPartitions(null);
                }

                public override void Run()
                {
                    try
                    {
                        client.CreateAskdcMachineRequest();
                        SendAskdcAndVerifyError(client);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Askdc User
            [TestCase]
            public class AskdcUserPassportPlain: TestNode
            {
                //The first internal request here is going to be hashed on passport puid.

                KdcUser user;

                public override void PreRun()
                {
                    user=new KdcUser();
                    user.CreateUser(true);
                    Global.RO.Debug("TestUser("+user.Gamertag+string.Format(", Puid=0x{0:X}", user.UserID)+string.Format(", Passport=0x{0:X}", user.Passport.Puid)+") passport is on physical partition "+GetPhysicalUodbPartitionForUser(user.Passport.Puid));

                    user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama); //cache ticket locally now since later we're time-constrained

                    BeginSaturateUodbPartitions(null);
                }

                public override void Run()
                {
                    try
                    {
                        KdcClientPC client=new KdcClientPC();
                        client.CreateAskdcUserRequest(user);
                        client.AskdcRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                        SendAskdcAndVerifyError(client);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Askdc User
            [TestCase]
            public class AskdcUserPassportEncrypted_UserKey: TestNode
            {
                //The first internal request here is going to end up being to retrieve to user key, so hashed on gamertag.

                KdcUser user;
                KdcClientXbox360 client;

                public override void PreRun()
                {
                    user=new KdcUser();
                    user.CreateUser(true);
                    Global.RO.Debug("TestUser("+user.Gamertag+string.Format(", Puid=0x{0:X}", user.UserID)+string.Format(", Passport=0x{0:X}", user.Passport.Puid)+") gamertag is on physical partition "+GetPhysicalUodbPartitionForUser(user.Gamertag));

                    user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon); //cache ticket locally now since later we're time-constrained

                    client=new KdcClientXbox360();
                    client.CreateAskdcMachineRequest();
                    client.ExecuteAskdc(true);

                    BeginSaturateUodbPartitions(null);
                }

                public override void Run()
                {
                    try
                    {
                        client.CreateAskdcUserRequest(user);
                        client.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
                        SendAskdcAndVerifyError(client);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Askdc User
            [TestCase]
            public class AskdcUserPassportEncrypted_Passport: TestNode
            {
                //For this we need to create a user with a passport whose gamertag hashes to a different partition than their passport puid.
                //We kick off the request to the KDC.  The first internal request to the db will take 1000ms, so during that time we need to block the other partition, so we delay 500ms on our saturation call.
                //The first internal askdc request for gamertag will succeed, but the second for passport puid should fail.

                KdcUser user;
                KdcClientXbox360 client;

                public override void PreRun()
                {
                    if (GetPhysicalUodbPartitionCount()<2)
                    {
                        throw new EnvironmentIsInadequateException("This test requires at least 2 UODB partitions.");
                    }

                    int gamertagPartition=-1;
                    int passportPartition=-1;

                    while (gamertagPartition==passportPartition)
                    {
                        user=new KdcUser();
                        user.CreateUser(true);
                        passportPartition=GetPhysicalUodbPartitionForUser(user.Passport.Puid);
                        gamertagPartition=GetPhysicalUodbPartitionForUser(user.Gamertag);
                    }
                    Global.RO.Debug("TestUser("+user.Gamertag+string.Format(", Puid=0x{0:X}", user.UserID)+string.Format(", Passport=0x{0:X}", user.Passport.Puid)+").");
                    Global.RO.Debug(" gamertag is on physical partition "+gamertagPartition);
                    Global.RO.Debug(" passport puid is on physical partition "+passportPartition);

                    user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon); //cache ticket locally now since later we're time-constrained

                    client=new KdcClientXbox360();
                    client.CreateAskdcMachineRequest();
                    client.ExecuteAskdc(true);

                    DelayBeginSaturateUodbPartitions(500, passportPartition);
                }

                public override void Run()
                {
                    try
                    {
                        client.CreateAskdcUserRequest(user);
                        client.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
                        client.AskdcTimeoutTimeInMs=3000; //2000 is default, but askdc internally has to make 2 calls and calls take 1000ms during these tests so we need more time.
                        SendAskdcAndVerifyError(client, 750, 1750);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Xkdc Machine
            [TestCase]
            public class XkdcMachine: TestNode
            {
                //Xkdc will internally make a db call for the machine and then for each user.

                KdcClientXbox360 client;

                public override void PreRun()
                {
                    client = new KdcClientXbox360();
                    client.ExecuteXmacs(true);
                    Global.RO.Debug("Machine consoleid(" + client.XmacsOutput.ConsoleId + ") is on physical partition " + GetPhysicalUodbPartitionForUser(client.XmacsOutput.ConsoleId));
                    client.ExecuteAskdc(true);

                    BeginSaturateUodbPartitions(null);
                }

                public override void Run()
                {
                    try
                    {
                        client.CreateXkdcRequest();
                        SendXkdcAndVerifyError(client);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Xkdc Machine
            [TestCase, Description("Perform an XKDC request where the machine portion succeeds, and the user portion fails")]
            [CompoundCase("AutoDiscover", 1)]
            [CompoundCase("NoAutoDiscover", 0)]
            public class XkdcUser : TestNode
            {
                //The first internal xkdc request for the machine needs to succeed, so that the second one for the user fails.

                KdcClientXbox360 client;
                KdcUser user;

                public override void PreRun()
                {
                    if (GetPhysicalUodbPartitionCount() < 2)
                    {
                        throw new EnvironmentIsInadequateException("This test case requires at least two UODB partitions");
                    }

                    Int32 machinePartition;
                    Int32 userPartition;

                    client = new KdcClientXbox360();
                    client.ExecuteXmacs(true);
                    machinePartition = GetPhysicalUodbPartitionForUser(client.XmacsOutput.MachineId);
                    Global.RO.Debug("Machine consoleid(" + client.XmacsOutput.ConsoleId + ") is on physical partition " + machinePartition);

                    do
                    {
                        user = new KdcUser();
                        user.CreateUser(true);
                        userPartition = GetPhysicalUodbPartitionForUser(user.UserID);
                    } while (userPartition == machinePartition);
                    Global.RO.Debug("TestUser(" + user.Gamertag + string.Format(", 0x{0:X}", user.UserID) + ") is on physical partition " + userPartition);

                    client.CreateAskdcUserRequest(user);
                    client.ExecuteAskdc(true);

                    client.CreateAskdcMachineRequest();
                    client.ExecuteAskdc(true);

                    DelayBeginSaturateUodbPartitions(1500, userPartition);
                }

                public override void Run()
                {
                    try
                    {
                        client.CreateXkdcRequest();
                        client.XkdcRequest.Input.AutoDiscoverServices = Convert.ToUInt16(MyValues[0]);
                        if (client.XkdcRequest.Input.AutoDiscoverServices == 0)
                        {
                            client.XkdcRequest.Input.Services = new UInt32[] { 25 };
                        }
                        client.XkdcTimeoutTimeInMs=3000; //2000 is default, but xkdc internally has to make 3 calls and calls take 1000ms during these tests so we need more time.
                        SendXkdcAndVerifyError(client, 1750, 2750);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }

            //Xkdc Flash Version Update
            //[TestCase] //TODO - How are we going to do this?  I don't think we can without additional KDC instrumentation.
            public class XkdcFlashVersionUpdate: TestNode
            {
                //2nd call to UODB is a write of flash version if it changed.  Unfortunately this is on the same partition as the first call.
            }

            //Xkdc User Foresight
            [TestCase, Description("Even if machine auth would work we now fail out if we know a user auth is likely to fail.")]
            public class XkdcUserForesight: TestNode
            {
                KdcClientXbox360 client;

                public override void PreRun()
                {
                    if (GetPhysicalUodbPartitionCount() < 2)
                    {
                        throw new EnvironmentIsInadequateException("This test case requires at least two UODB partitions");
                    }

                    client=new KdcClientXbox360();
                    client.ExecuteXmacs(true);

                    //need a user on a different partition than the machine
                    int machinePartition=GetPhysicalUodbPartitionForUser(client.XmacsOutput.MachineId);
                    int userPartition=machinePartition;
                    KdcUser user=null;
                    while (machinePartition==userPartition)
                    {
                        user=new KdcUser();
                        user.CreateUser(false);
                        userPartition=GetPhysicalUodbPartitionForUser(user.UserID);
                    }

                    Global.RO.Debug("TestUser("+user.Gamertag+string.Format(", Puid=0x{0:X}", user.UserID)+") puid is on physical partition "+userPartition);
                    Global.RO.Debug("Machine("+client.XmacsOutput.ConsoleId+string.Format(", Puid=0x{0:X}", client.XmacsOutput.MachineId)+") puid is on physical partition "+machinePartition);

                    client.CreateAskdcMachineRequest();
                    client.ExecuteAskdc(true);
                    client.CreateAskdcUserRequest(user);
                    client.ExecuteAskdc(true);

                    BeginSaturateUodbPartitions(userPartition);
                }

                public override void Run()
                {
                    try
                    {
                        client.CreateXkdcRequest();
                        SendXkdcAndVerifyError(client, 0, 750);
                    }
                    finally
                    {
                        EndSaturateUodbPartitions();
                    }
                }
            }
        } //class HighMark

        [TestGroup, Description("Tests that cross the high water mark then verify the low water mark works as expected.")]
        public class LowMark: TestNode
        {
            public override void PreRun()
            {
                //override the settings.  We want throttling enabled after 4 requests in progress and disabled after dropping below 2 requests in progress..  We want 4 threads allowed per partition.  We want highly latent requests.
                float currentMaxThreads=Config.GetIntSetting(Setting.kdcsvc_core_ATQThreads);
                float throttleStartPercent=4*100.01f/currentMaxThreads; //account for floating point error
                float throttleStopPercent=2*100.01f/currentMaxThreads; //account for floating point error
                float percentPerPartition=1*100.01f/currentMaxThreads; //account for floating point error
                int dbLatencyInMs=1000; //1 seconds

                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentThreshold to: "+throttleStartPercent);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentThreshold, throttleStartPercent.ToString());
                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentDeactivationThreshold to: "+throttleStopPercent);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentDeactivationThreshold, throttleStopPercent.ToString());
                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentPerPartition to: "+percentPerPartition);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentPerPartition, percentPerPartition.ToString());
                Global.RO.Debug("Setting kdcsvc_managed_simulateDbLatencyInMs to: "+dbLatencyInMs);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_simulateDbLatencyInMs, dbLatencyInMs.ToString());

                Suite.RefreshKDCsConfig();
            }

            //Unfortunately the saturation helpers used for the HighMark tests don't really work for the situation here.  So here is a new helper that will send 4 requests out to a particular partition, delayed by a specified amount usually in the vacinity of 250ms each starting at 0ms.  This returns approximately 1000ms after the first request was made.  delayValuesInMs should be an array of 5 increasingly large numbers whose first value is 0 and whose final value is 1000.
            public static void SaturatePartitionsWith4Threads(int targetPartition, uint[] delayValuesInMs)
            {
                //prepare clients
                Global.RO.Debug("Preparing saturation users.");
                KdcClientXbox360 []clients=new KdcClientXbox360[5];
                bool allFull=false;
                while (!allFull)
                {
                    //make a new user and see where it fits
                    KdcUser user=new KdcUser();
                    user.CreateUser(false);
                    int clientPartition=GetPhysicalUodbPartitionForUser(user.Gamertag);
                    if (clientPartition!=targetPartition)
                    {
                        continue;
                    }

                    for (int n=0; n<5; ++n)
                    {
                        if (clients[n]==null)
                        {
                            KdcClientXbox360 client=new KdcClientXbox360();
                            client.CreateAskdcUserRequest(user);
                            client.AskdcRequest.Input.GeneratePreauths();
                            client.AskdcRequest.SetRequest();
                            client.AskdcRequest.ConstructRequest();
                            clients[n]=client;
                            break;
                        }
                    }

                    //see if we're done
                    allFull=true;
                    for (int n=0; n<5; ++n)
                    {
                        if (clients[n]==null)
                        {
                            allFull=false;
                        }
                    }
                }

                //Do a new request (1 for each partition) at 250ms intervals.  This is very time sensitive so we are not going to play nice with the CPU.
                Global.RO.Info("Saturating UODB partition "+targetPartition+" with 4 threads.");
                System.DateTime start=System.DateTime.UtcNow;

                for (int n=0; n<5; ++n)
                {
                    System.DateTime nextRequestTime=start+new System.TimeSpan(0, 0, 0, 0, (int)delayValuesInMs[n]);
                    while (nextRequestTime>System.DateTime.UtcNow)
                    {
                        System.Threading.Thread.Sleep(0);
                    }

                    if (n<4)
                    {
                        char layer=(char)('A'+n);
                        Global.RO.Debug("Layer "+layer);

                        byte[] packet=clients[n].AskdcRequest.GetBytes();
                        clients[n].SendPacket(packet);

                        //Global.XEnv.ExecuteXmgmtCommand("kdcsvc", "e :kdcmanagedproxy dblimiterstate"); //for debugging... note that this can actually slow things down and cause false failures

                        if (n==3) //double up the last one to actually trigger throttling
                        {
                            Global.RO.Debug("Layer E");
                            packet=clients[n+1].AskdcRequest.GetBytes();
                            clients[n+1].SendPacket(packet);

                            //Global.XEnv.ExecuteXmgmtCommand("kdcsvc", "e :kdcmanagedproxy dblimiterstate"); //for debugging... note that this can actually slow things down and cause false failures
                        }
                    }
                }
            }

            //Tests
            [TestCase, Description("Makes a request while 2 of the 4 threads are still is use on a partition.  Throttling should still be enabled so it should be blocked.")]
            public class JustAbove: TestNode
            {
                KdcClientXbox360 client;

                public override void PreRun()
                {
                    //pre-create a machine
                    client=new KdcClientXbox360();
                    client.ExecuteXmacs(true);

                    //saturate
                    int partition=GetPhysicalUodbPartitionForUser(client.XmacsOutput.ConsoleId);
                    SaturatePartitionsWith4Threads(partition, new uint[]{0, 100, 800, 900, 1000});
                }

                public override void Run()
                {
                    //At between 100-800ms after the saturation occurs, our request has to be made to hit the time when exactly 2 threads are in use.  It should be blocked.
                    System.Threading.Thread.Sleep(100+50);

                    //Global.XEnv.ExecuteXmgmtCommand("kdcsvc", "e :kdcmanagedproxy dblimiterstate"); //for debugging... note that this can actually slow things down and cause false failures

                    SendXmacsAndVerifyError(client, 0, (800-100)-50);
                }

                public override void PostRun()
                {
                    System.Threading.Thread.Sleep(1000); //make sure all has calmed down before the next test
                }
            }

            [TestCase, Description("Makes a request while 1 of the 4 threads are still is use on a partition.  Throttling should now be disabled so it should work.")]
            public class JustBelow: TestNode
            {
                KdcClientXbox360 client;

                public override void PreRun()
                {
                    //pre-create a machine
                    client=new KdcClientXbox360();
                    client.ExecuteXmacs(true);

                    //saturate
                    int partition=GetPhysicalUodbPartitionForUser(client.XmacsOutput.ConsoleId);
                    SaturatePartitionsWith4Threads(partition, new uint[]{0, 100, 200, 900, 1000});
                }

                public override void Run()
                {
                    //At between 500-750ms after the saturation occurs, our request has to be made to hit the time when exactly 1 thread is in use.  It should be succeed.
                    System.Threading.Thread.Sleep(200+50);
                    client.RetryLostPackets=false;

                    //Global.XEnv.ExecuteXmgmtCommand("kdcsvc", "e :kdcmanagedproxy dblimiterstate"); //for debugging... note that this can actually slow things down and cause false failures

                    Global.RO.Info("Sending request.");
                    client.ExecuteXmacs(true);
                }

                public override void PostRun()
                {
                    System.Threading.Thread.Sleep(1000); //make sure all has calmed down before the next test
                }
            }

        } //class LowMark

        [TestCase, Description("Tests for the low, high, and per-partition settings all being 0.  Throttling should be completely disabled in this state.")]
        public class Disabled: TestNode
        {
            KdcClientXbox360 client;

            public override void PreRun()
            {
                //override the settings.  We want all throttling values set to 0.
                int dbLatencyInMs=1000; //1 seconds

                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentThreshold to: 0");
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentThreshold, "0");
                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentDeactivationThreshold to: 0");
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentDeactivationThreshold, "0");
                Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentPerPartition to: 0");
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentPerPartition, "0");
                Global.RO.Debug("Setting kdcsvc_managed_simulateDbLatencyInMs to: "+dbLatencyInMs);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_simulateDbLatencyInMs, dbLatencyInMs.ToString());

                Suite.RefreshKDCsConfig();

                //
                client=new KdcClientXbox360();
                Global.RO.Info("Sending request.");
                client.ExecuteXmacs(true);

                BeginSaturateUodbPartitions(null);
            }

            public override void Run()
            {
                try
                {
                    //this isn't the best test, but will at least catch if we are misinterepreting 0 as "always throttle".
                    client.RetryLostPackets=false;
                    client.ExecuteXmacs(true);
                }
                finally
                {
                    EndSaturateUodbPartitions();
                }
            }

            public override void PostRun()
            {
                System.Threading.Thread.Sleep(1000); //make sure all has calmed down before the next test
            }
        }

    } //class DBLimiter
} //namespace XkdcTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\Expectations.cs ===
using System;
using System.Text;
using System.Xml;
using System.Reflection;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.config;


namespace XkdcTest
{
    class Expectations
    {
        // "Privilege" for access to Xbox 1 Live, actually controlled by column in t_users
        public static uint k_Xbox1LiveAccess = 242;

        // All available privileges, from t_privileges.
        // Populated by setup.
        public static uint[] k_DefaultAllPrivileges =
            { 192,193,/*242,*/243,244,245,246,247,248,249,250,251,252,253,254,255 };

        // From t_user_privilege_grants, certain users get these.  See UserInfo.
        // Populated by uodb-xkdctest.ini
        public static uint[] k_DefaultGrantedPrivileges = 
            { 251, 253 };

        // From t_user_privilege_restrictions, certain users get these.  See UserInfo.
        // Populated by uodb-xkdctest.ini
        public static uint[] k_DefaultRestrictedPrivileges = 
            { 254, 255 };

        // From t_tiers, how we map our [0,1,2] tiers to real tier ids
        public static uint[] k_IdxToTierId =
            { 3, 6, 0 };

        // From t_tier_region_privileges
        // Populated by static_populate.sql
        public static uint[][] k_DefaultExpectedPrivileges =
            new uint[][] {
                             new uint[] { 243,244,245,246,247,248,249,251,252,255 },         // tier 1 (id=3)
                             new uint[] { 242,243,244,245,246,247,248,249,250,251,252,253,254,255 },     // tier 2 (id=6)
                             new uint[] {  }                                     // tier 3 (n/a)
                         };

        // From t_tier_region_services
        // Only need to explicitly declare services ids between [0-31] and [8000-8100]
        // Populated by setup
        public static uint[][] k_DefaultExpectedServices = 
            new uint[][] { 
                             new uint[] { /*machine_only*/ 2,3,4,5,11,12,18,20,8001/*,8003*/ },                      // tier 1
                             new uint[] { 1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,18,19,20,8001 },   // tier 2
                             new uint[] {  }                                                                     // tier 3
                         };

        // Based on t_services and t_service_instances
        // Determined by looking at expected services and i_site_id
        public static uint[][] k_DefaultExpectedHRs = 
            new uint[][] { 
                             new uint[] { /*machine_only*/ 0,0,0,0, 0, 1, 1, 1,   1 },          // tier 1
                             new uint[] { 0,0,0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 0, 1, 1, 1,   1 },  // tier 2
                             new uint[] {  }                                                         // tier 3
                         };

        // Machine-only, independent of tier
        // Determined by looking at available services and filtering by machine_only
        public static uint[] k_DefaultExpectedMachineServices =
            new uint[] { 2,3,4,5,11,12,18,20,8001/*,8003*/ };
        public static uint[] k_DefaultExpectedMachineHRs = 
            new uint[] { 0,0,0,0, 0, 1, 1, 1,   1/*,   1*/ };

        // If a user from tier 1 and tier 2 sign in together. This is a bit of a hack as
        // I'm finding it difficult to write a good merge and adjust routine.
        // Populated by hand as the union of tier 1 and tier 2 services with the HRs as the intersection,
        // if that makes sense.
        //public static uint NA = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
        public static uint NA = 0x80151101;
        public static uint[] k_DefaultExpectedServicesTier12 =
            new uint[] { 1, 2, 3, 4, 5, 6, 7, 8, 9,11,12,13,14,15,16,18,19,20,8001 };
        public static uint[] k_DefaultExpectedHRsTier12 = 
            new uint[] {NA, 0, 0, 0, 0,NA,NA,NA,NA, 0, 1, 1, 1, 1,NA, 1, 1, 1,   1 };

        //Default expected machine privileges
        public static uint []k_DefaultExpectedMachinePrivileges=new uint[]{};

        /// <summary>
        /// Dump data in this class to an XML file
        /// </summary>
        /// <param name="filename"></param>
        public static void Export(string filename)
        {
            XmlTextWriter writer = new XmlTextWriter(filename, System.Text.Encoding.ASCII);
            writer.Formatting = Formatting.Indented;
            XmlDocument doc = GetXml();
            doc.WriteTo(writer);
            writer.Close();
        }

        /// <summary>
        /// Import data from an XML file to populate this class
        /// </summary>
        /// <param name="filename"></param>
        public static void Import(string filename)
        {
            bool bPopulateFromUodb = true;

            // First step: load from XML
            try
            {
                XmlTextReader reader = new XmlTextReader(filename);
                XmlDocument doc = new XmlDocument();
                doc.Load(filename);
                reader.Close();
                try
                {
                    PopulateFromXml(doc);
                }
                catch (Exception e)
                {
                    Global.RO.Error("Error parsing XML file {0}: {1}", filename, e.ToString());
                }

                // Check for UODB setting 
                XmlNode n = doc.SelectSingleNode("XkdcTest/Expectations/Uodb");
                if (n != null)
                {
                    XmlAttribute attr = n.Attributes["populatefrom"];
                    if (attr.Value.ToLower() == "no")
                    {
                        bPopulateFromUodb = false;
                    }
                }
            }
            catch(Exception e)
            {
                Global.RO.Debug("Error populating from XML file {0}: {1}", filename, e.Message);
            }

            // Second step: retrieve from UODB
            try
            {
                if (bPopulateFromUodb)
                {
                    Global.RO.Debug("Attempting connection to UODB for building test expectations");
                    PopulateFromUodb();
                }
            }
            catch(Exception e)
            {
                Global.RO.Debug("Error populating from UODB: " + e.Message);
            }

        }

        /// <summary>
        /// Creates an XmlDocument from the data in this class
        /// </summary>
        /// <returns></returns>
        public static XmlDocument GetXml()
        {
            XmlDocument doc = new XmlDocument();
            XmlElement root = doc.CreateElement("XkdcTest");
            XmlElement expectations = doc.CreateElement("Expectations");

            foreach (FieldInfo field in typeof(Expectations).GetFields(BindingFlags.Static | BindingFlags.Public))
            {
                string name = field.Name;
                object val = field.GetValue(null);
                expectations.AppendChild(FieldToNode(val, name, doc));
            }

            // Insert Uodb element
            XmlElement uodb = doc.CreateElement("Uodb");
            XmlAttribute populate = doc.CreateAttribute("populatefrom");
            populate.Value = "yes";
            uodb.Attributes.Append(populate);
            expectations.AppendChild(uodb);

            root.AppendChild(expectations);
            doc.AppendChild(root);
            return doc;
        }

        /// <summary>
        /// Sets the data in this class from an XmlDocument
        /// </summary>
        /// <param name="doc"></param>
        public static void PopulateFromXml(XmlDocument doc)
        {
            Type myType = typeof(Expectations);

            XmlNode expectations = doc.SelectSingleNode("XkdcTest/Expectations");
            foreach (XmlNode expect in expectations.SelectNodes("Field"))
            {
                string name = expect.Attributes["name"].Value;
                int count = expect.ChildNodes.Count;
                FieldInfo field = myType.GetField(name);

                if (count == 1)
                {
                    string valstr = expect.SelectSingleNode("values").InnerText;
                    uint[] val = StringToArray(valstr);
                    field.SetValue(null, val);
                    Global.RO.Debug("Setting field {0} with length {1}", name, val.Length);
                }
                else if (count > 1)
                {
                    uint[][] valOuter = new uint[count][];
                    int valOuterIdx = 0;
                    foreach (XmlNode tiervalue in expect.SelectNodes("values"))
                    {
                        string valstr = tiervalue.InnerText;
                        uint[] val = StringToArray(valstr);
                        string tierstr = (tiervalue.Attributes["tieridx"] != null) ? tiervalue.Attributes["tieridx"].Value : "<unk>";
                        valOuter[valOuterIdx++] = val;
                        Global.RO.Debug("Setting field {0}, tier idx {1}, with length {2}", name, tierstr, val.Length);
                    }
                    field.SetValue(null, valOuter);
                }
                else  // count == 0
                {
                    XmlAttribute attr = expect.Attributes["value"];
                    if (attr != null)
                        field.SetValue(null, (uint)uint.Parse(attr.Value));
                }
            }
        }

        /// <summary>
        /// Magically turns a single data field in this class into an XmlNode
        /// </summary>
        /// <param name="data"></param>
        /// <param name="dataName"></param>
        /// <param name="doc"></param>
        /// <returns></returns>
        private static XmlNode FieldToNode(object data, string dataName, XmlDocument doc)
        {
            XmlElement expect = doc.CreateElement("Field");
            XmlAttribute attr = doc.CreateAttribute("name");
            attr.Value = dataName;
            expect.Attributes.Append(attr);

            if (data.GetType() == typeof(uint[][]))
            {
                uint[][] d = (uint[][])data;
                for (int i = 0; i < d.Length; i++)
                {
                    if (d[i] != null && d[i].Length > 0)
                    {
                        XmlNode valuenode = ArrayToValueNode(d[i], doc);
                        XmlAttribute tierattr = doc.CreateAttribute("tieridx");
                        tierattr.Value = i.ToString();
                        valuenode.Attributes.Append(tierattr);
                        expect.AppendChild(valuenode);
                    }
                }
            }
            else if (data.GetType() == typeof(uint[]))
            {
                uint[] d = (uint[])data;
                expect.AppendChild(ArrayToValueNode(d, doc));
            }
            else if (data.GetType() == typeof(uint))
            {
                XmlAttribute a = doc.CreateAttribute("value");
                a.Value = ((uint)data).ToString();
                expect.Attributes.Append(a);
                //                XmlElement n = doc.CreateElement("value");
                //                n.AppendChild(doc.CreateTextNode(((uint)data).ToString()));
                //                expect.AppendChild(n);
            }

            return expect;
        }

        /// <summary>
        /// Translates a single-dimension array to an XmlNode
        /// </summary>
        /// <param name="data"></param>
        /// <param name="doc"></param>
        /// <returns></returns>
        private static XmlNode ArrayToValueNode(uint[] data, XmlDocument doc)
        {
            StringBuilder sb = new StringBuilder(100);
            for (int i = 0; i < data.Length; i++)
            {
                sb.Append(data[i].ToString());
                sb.Append(",");
            }
            // Remove trailing comma
            string s = null;
            if (sb.Length > 0)
            {
                s = sb.ToString(0, sb.Length - 1);
            }
            XmlElement n = doc.CreateElement("values");
            XmlText textnode = doc.CreateTextNode(s);
            n.AppendChild(textnode);
            return n;
        }

        /// <summary>
        /// Converts a comma-delimited uint string, like that found in the 'values' tag in the
        /// XML document, back into a real uint[].
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        private static uint[] StringToArray(string data)
        {
            string[] elements = data.Split(new char[] { ',' });
            if (elements == null || elements.Length <= 0)
                return null;
            uint[] val = new uint[elements.Length];
            for (int i = 0; i < elements.Length; i++)
            {
                if (elements[i] == "")
                    continue;
                val[i] = uint.Parse(elements[i]);
            }
            return val;
        }       

        /// <summary>
        /// Retrieve UODB IP from ConfigDB and populate this class from there.
        /// </summary>
        public static void PopulateFromUodb()
        {
            string[] uodb = Global.XEnv.GetServerListByInterface(Interface.uodb);

            // We only need one. Let's select one at random.
            Random r = new Random();
            int idx = r.Next(uodb.Length);
            PopulateFromUodb(uodb[idx]);
        }

        /// <summary>
        /// Populate data in this class from the UODB
        /// </summary>
        /// <param name="uodbServerName"></param>
        public static void PopulateFromUodb(string uodbServerName)
        {
            SqlConnection sqlConnection = new SqlConnection("server=" + uodbServerName + ";database=uodb;Integrated Security=SSPI;Connect Timeout=10");
            try
            {
                sqlConnection.Open();
            }
            catch 
            {
                throw;
            }

            k_IdxToTierId = UodbToArray
                ("select i_tier_id, rcount = (select count(*) from t_tiers where i_tier_id > 0) from t_tiers where i_tier_id > 0", 4, sqlConnection);

            // Single arrays
            k_DefaultAllPrivileges = UodbToArray
                ("select ti_privilege_id, rcount = (select count(*) from t_privileges) from t_privileges", 1, sqlConnection);
            k_DefaultExpectedMachineServices = UodbToArray
                ("select i_service_id, rcount = (select count(*) from t_services where i_machine_only=1) from t_services where i_machine_only=1", 4, sqlConnection);
            k_DefaultExpectedMachineHRs = UodbToArray
                ("SELECT  t_service_instances.i_site_id, rcount = (select count(*) from t_service_instances INNER JOIN t_services ON t_service_instances.i_service_id = t_services.i_service_id WHERE   (t_services.i_machine_only = 1) AND (t_service_instances.i_service_available = 1)) FROM t_service_instances INNER JOIN t_services ON t_service_instances.i_service_id = t_services.i_service_id WHERE   (t_services.i_machine_only = 1) AND (t_service_instances.i_service_available = 1)", 4, sqlConnection);

            // Double arrays
            int numtiers = k_IdxToTierId.Length;
            k_DefaultExpectedPrivileges = new uint[numtiers][];
            //k_DefaultExpectedServices = new uint[numtiers][];
            //k_DefaultExpectedHRs = new uint[numtiers][];

            for (int tier = 0; tier < numtiers; tier++)
            {
                uint tierId = k_IdxToTierId[tier];
                uint baseCountryId = 103;  // US
                k_DefaultExpectedPrivileges[tier] = UodbToArray
                    ("select ti_privilege_id, rcount = (select count(*) from t_tier_region_privileges where i_tier_id=" + tierId + " and ti_country_id=" + baseCountryId + ") from t_tier_region_privileges where i_tier_id=" + tierId + " and ti_country_id=" + baseCountryId, 1, sqlConnection);

                // No k_DefaultExpectedServices
                // No k_DefaultExpectedHRs
            }

            // Hard-coded defaults
            //k_DefaultGrantedPrivileges = new uint[] { 251, 253 };       // from uodb-xkdctest.ini
            //k_DefaultRestrictedPrivileges = new uint[] { 254, 255 };    // from uodb-xkdctest.ini

            // Special process HR array
            uint first;
            first = k_DefaultExpectedMachineHRs[0];
            for (int i = 0; i < k_DefaultExpectedMachineHRs.Length; i++)
            {
                if (k_DefaultExpectedMachineHRs[i] == first)
                {
                    k_DefaultExpectedMachineHRs[i] = 0;
                }
                else
                {
                    k_DefaultExpectedMachineHRs[i] = 1;
                }
            }

            //k_DefaultExpectedMachinePrivileges todo

            // Remove Xbox1LiveAccess privilege from all arrays since it isn't really a privilege
            XkdcUtilities.RemoveFromArray(ref k_DefaultAllPrivileges, new uint[] { k_Xbox1LiveAccess });


            sqlConnection.Close();
        }

        /// <summary>
        /// Execute a SELECT statement that returns two columns:
        ///   Col 1: the data
        ///   Col 2: the number of rows
        /// and create a uint[] out of the data
        /// </summary>
        /// <param name="selectStatement"></param>
        /// <param name="dataSize"></param>
        /// <param name="sqlConnection"></param>
        /// <returns></returns>
        private static uint[] UodbToArray(string selectStatement, int dataSize, SqlConnection sqlConnection)
        {
            SqlCommand command;
            SqlDataReader dr;
            int i;
            uint[] val = null;

            command = new SqlCommand(selectStatement, sqlConnection);
            dr = command.ExecuteReader(CommandBehavior.SingleResult);
            i = 0;
            while (dr.Read())
            {
                if (i == 0)
                    val = new uint[dr.GetInt32(1)];
                if (dataSize == 1)
                    val[i] = (uint)dr.GetByte(0);
                else if (dataSize == 4)
                    val[i] = (uint)dr.GetInt32(0);
                i++;

            }
            dr.Close();
            return val;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncSetup.cs ===
// "setup" cases for checking titles and populating the db and such.

using System;
using System.Collections;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.DBPoster;
using ServerTestFramework.Database;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;

namespace XkdcTest
{

[TestGroup]
public class _Setup: TestNode
{
    //list of DBPoster machines and users (for the new pre-clean phase)
    public static string []DBPMachines=
    {
        "XE.000000000101",
        "XE.000000000112",
        "XE.000000000123",
        "XE.000000000134",
        //beta group data
        "XE.133700000004",
        "XE.133700000105",
        "XE.133700000206",
        "XE.133700000307",
        "XE.133700000701",
        "PC.133700000813",
        "PC.133700000217",
        "XE.133700010005",
        "XE.133700020006",
        "XE.133700030007",
        "XE.133700070001",
        "PC.133700080013",
        "XE.133700001601",
        "XE.133700003205",
        "XE.133700006404",
        "XE.133800000184",
        "XE.133700160001",
        "XE.133700320005",
        "XE.133700640004",
        "XE.133700960009",
        "XE.133701000005",
        "XE.133702000006",
        "XE.133900000017"
    };

    public static string []DBPUsers=
    {
        "xktuser7a",
        "xktuser7b",
        "xktuser7c",
        "xktuser7d",
        "xkt space",
        "xktcntry53",
        "xktcntry76",
        "xktcntry44",
        "xkttflag1",
        "xkttflag2",
        "xkttflag4",
        "xkttflag5",
        "xkttflag7",
        "xkttflag9",
        "xkttflag65295",
        "xktactrsmnow",
        "xktactrsmtmrw",
        "xktactrsmyest",
        "xktactrsmfvr",
        "xktvocrsmnow",
        "xktvocrsmtmrw",
        "xktvocrsmyest",
        "xktvocrsmfvr",
        "xktnamechng",
        "xkttosbefore",
        "xkttosexact",
        "xkttosafter",
        "xkttoswayafter",
        "xktbilstatfals",
        "xktbilstatfail",
        "xktsubnone",
        "xktsub1",
        "xktsub2",
        "xktsub3",
        "xktsub4",
        "xktsub5",
        "xktsuball",
        "xktsub1nobase",
        "xktsubx2",
        "xktsub123",
        "xktsub23",
        "xktsubx23",
        "xktsubx2x3",
        "xktusert1a",
        "xktusert1b",
        "xktusert1c",
        "xktusert1d",
        "xktusert1e",
        "xktusert1f",
        "xktusert2a",
        "xktusert2b",
        "xktusert2c",
        "xktusert2d",
        "xktusert2e",
        "xktusert2f",
        "xktrestrictedt2",
        "xktgrantedt2",
        "xktxeusert1a",
        "xktduusert1a",
        "xktxbusert2a",
        "xktxeusert2a",
        "xktduusert2a",
        "xktdudifft2a",
        "xktxeusert2ar",
        "xktduusert2ar",
        "xktdulsput2a",
        "xktxbchilt2a",
        "xktduchilt2a",
        "xktcntry16t1",
        "xktcntry24t1",
        "xktcntry44t1",
        "xktcntry25t1",
        "xktcntry75t1",
        "xktcntry46",
        "xktcntry46t1",
        "xktcntry46t1r",
        "xktcntry46t2",
        "xktdupcg1t2a",
        "xktdupcg1t2ar",
        "xktdupcg1t2d",
        "xktxesubexpt2",
        "xktxesubexpt1",
        "xktxesubmixt1",
        "xktxesublspt2",
        "xktxesub48ht1",
        "xktxesub48et1",
        "xktxesub48h46t1",
        "xktxesub48e46t1",
        "xktxesublsp44t1",
        "xktofferprivres",
        "xktbanned",
        "xktzerokeys",
        "xktzeroppas",
        "xktnewsub7one",
        "xktnewsub7two",
        "xktnewsub7exp",
        "xktnewsub8",
        "xktnewsub9",
        "xktnewsub10",
        "xktverylongname",
        "xktuserInvWLID",
        "xktuserValWLID",
        "xktownerValWLID",
        "xktownerInvWLID",
        "xktoAnduInvWLID",
        "xktad4a",
        "xktad4b",
        "xktad4c",
        "xktad4d",
        "xktxxxT15",
        "xktxxxTf9abcde8",
        "xktsuba3"
    };


    // --


    [TestCase, Description("Checks that required titles are propped.")]
    class CheckTitles: TestNode
    {
        public override void Run()
        {
            bool ok=true;
            ok=Suite.CheckTitle(0xFFFE07D1,0,AuthContext.ClientTypes.Xenon) && ok;    //xenon dash
            ok=Suite.CheckTitle(0xFFFE07D2,0,AuthContext.ClientTypes.Xenon) && ok;    //fusion
            ok=Suite.CheckTitle(0xFFFE07FF,0,AuthContext.ClientTypes.Xenon) && ok;    //xdk launcher
            ok=Suite.CheckTitle(0xFFFE0000,0,AuthContext.ClientTypes.Xbox) && ok;     //xbox1 dash
            ok=Suite.CheckTitle(0x585207D1,0,AuthContext.ClientTypes.Panorama) && ok; //panorama machine account creation
            ok=Suite.CheckTitle(0x4d530064,0,AuthContext.ClientTypes.Xbox) && ok;     //Halo2
            ok=Suite.CheckTitle(0xffff0072,0,AuthContext.ClientTypes.Xenon) && ok;    //lsptest
            if (!ok)
            {
                throw new UnexpectedTestResultException("Required titles are not propped.  This environment is not is a state where XkdcTest will run correctly.");
            }
        }
    }

    [TestCase, Ignore("Not really neccesary"), Description("Removes the xkdc test suite's 'fixed' DB users from uodb."), TestCasePriority(3)]
    public class CleanDBMachines: TestNode
    {
        bool prevCacheDefault=false;

        public override void PreRun()
        {
            prevCacheDefault=EditorCommon.EnableCachingByDefaultForNewInstances;
            EditorCommon.EnableCachingByDefaultForNewInstances=true;
        }

        public override void PostRun()
        {
            EditorCommon.EnableCachingByDefaultForNewInstances=prevCacheDefault;
        }

        public override void Run()
        {
            ServerTestFramework.Utilities.AsyncUtils.ParallelRunner.Run(DoDeleteMachineList, (uint)DBPMachines.Length, (uint)8, DBPMachines);
        }
    }

    [TestCase, Ignore("Not really neccesary"), Description("Removes the xkdc test suite's 'fixed' DB users from uodb."), TestCasePriority(3)]
    public class CleanDBUsers: TestNode
    {
        bool prevCacheDefault=false;

        public override void PreRun()
        {
            prevCacheDefault=EditorCommon.EnableCachingByDefaultForNewInstances;
            EditorCommon.EnableCachingByDefaultForNewInstances=true;
        }

        public override void PostRun()
        {
            EditorCommon.EnableCachingByDefaultForNewInstances=prevCacheDefault;
        }

        public override void Run()
        {
            ServerTestFramework.Utilities.AsyncUtils.ParallelRunner.Run(DoDeleteUserList, (uint)DBPUsers.Length, (uint)8, DBPUsers);
        }
    }

    [TestCase, Description("Prop test geneaology data.  Needed for xbox1.  We want to keep this to verify xbox1 decom though.")]
    public void PropTestGenealogyData()
    {
        string geneConnectionString="Data Source=" + Global.XEnv.GetServerListByInterface("genealogy")[0] + ";Initial Catalog=Genealogy;Integrated Security=SSPI";
        Global.RO.Info("Genealogy connection string: "+geneConnectionString);
        SqlConnection con=new SqlConnection(geneConnectionString);
        con.Open();

        //count existing matching entries to see if we need to post the data
        string rowCountQuery="select count(*) from OnlineGaming where SerialNumber like '%00007701' and PartNumber='F23-00061'";
        SqlDataReader reader=new SqlCommand(rowCountQuery, con).ExecuteReader();
        reader.Read();
        int rowCount=(int)reader[0];
        reader.Close();

        if (rowCount>9000)
        {
            Global.RO.Warn("Unexpectedly high number of matching rows in genealogy db: "+rowCount+".  While harmless, you may want to verify that the test data is propped correctly.");
        }
        else if (rowCount==9000)
        {
            Global.RO.Info("Exactly "+rowCount+" rows matched genealogy query.  Test data looks like it is already propped, so not propping.");
        }
        else //prop it
        {
            if (rowCount>0)
            {
                Global.RO.Warn("Low number of rows matched genealogy query: "+rowCount+".  Will reprop data to be on the safe side, but there may be errors if some rows already exist.");
            }
            Global.RO.Info("Propping test genealogy data...");

            //do 1 at a time in case any have errors
            string []lines=System.IO.File.ReadAllLines("SuitesData\\XKdc\\gene-stress.sql");
            int errors=0;
            string lastError="";
            foreach (string line in lines)
            {
                try
                {
                    SqlCommand sql=new SqlCommand(line, con);
                    sql.ExecuteNonQuery();
                }
                catch (Exception e)
                {
                    ++errors;
                    lastError=e.ToString();
                }
            }

            if (errors>0)
            {
                Global.RO.Error(errors+" exceptions propping data.  Most recent: "+lastError);
            }
            Global.RO.Info("Genealogy rows propped successfully: "+(lines.Length-errors));

            Suite.ReloadKDCs();
        }

        con.Close();
    }

    private static int machineDeleteCountRemoved=0;
    private static void DoDeleteMachineList(uint num, object list)
    {
        string []machineList=(string[])list;

        MachineEditor m=null;
        try
        {
            m=MachineEditor.FromName(machineList[num]);
        }
        catch (RowDoesNotExistException)
        {}

        if (m!=null && m.Id!=0)
        {
            m.CompletelyRemoveMachine();
        }

        int progressNum=System.Threading.Interlocked.Increment(ref machineDeleteCountRemoved);
        if (progressNum%250==249)
        {
            Global.RO.Debug("Deleted "+(progressNum+1)+"...");
        }
    }

    private static int userDeleteCountRemoved=0;
    private static void DoDeleteUserList(uint num, object list)
    {
        string []userList=(string[])list;

        UserEditor u=UserEditor.FromGamerTag(userList[num]);
        if (u.Puid!=0)
        {
            u.CompletelyRemoveUser();
        }

        int progressNum=System.Threading.Interlocked.Increment(ref userDeleteCountRemoved);
        if (progressNum%250==249)
        {
            Global.RO.Debug("Deleted "+(progressNum+1)+"...");
        }
    }

    // --

    //populate data into uodb - this used to be done by dbposter
    //it is important that these tests are run in order, so that foreign key constraints are satisfied
    [TestGroup, Description("Populates test data into uodb")]
    public class PopulateUODB: TestNode
    {
        bool prevCacheDefault=false;

        public override void PreRun()
        {
            prevCacheDefault=EditorCommon.EnableCachingByDefaultForNewInstances;
            EditorCommon.EnableCachingByDefaultForNewInstances=true;
        }

        public override void PostRun()
        {
            EditorCommon.EnableCachingByDefaultForNewInstances=prevCacheDefault;
        }

        [TestCase]
        public class Sites: TestNode
        {
            public override void Run()
            {
                // Fake Sites with specific AuthData versions.  The IPs and site IDs
                // provided make it easy to distinguish which site is being used

                // AuthData2 (XKERB_AD_XBOX2)
                {
                    SiteEditor site7002 = SiteEditor.CreateOrUseExistingId(7002);
                    site7002.AuthDataVersion = 2;
                    site7002.SetVirtualInterfaceIp("sgsvc", "1.1.1.2");
                }
                // AuthData3 (XKERB_AD_XENON)
                {
                    SiteEditor site7003 = SiteEditor.CreateOrUseExistingId(7003);
                    site7003.AuthDataVersion = 3;
                    site7003.SetVirtualInterfaceIp("sgsvc", "1.1.1.3");
                }

                // AuthData4 (XKERB_AD_XENON2)
                {
                    SiteEditor site7004 = SiteEditor.CreateOrUseExistingId(7004);
                    site7004.AuthDataVersion = 4;
                    site7004.SetVirtualInterfaceIp("sgsvc", "1.1.1.4");
                }

                {
                    SiteEditor site7045=SiteEditor.CreateOrUseExistingId(7045);
                    site7045.AuthDataVersion=3;
                    site7045.SetVirtualInterfaceIp("sgsvc", "1.1.1.1");
                }
                {
                    SiteEditor site7046=SiteEditor.CreateOrUseExistingId(7046);
                    site7046.AuthDataVersion=3;
                    site7046.SetVirtualInterfaceIp("sgsvc", "1.1.1.1");
                }
                {
                    SiteEditor site7047=SiteEditor.CreateOrUseExistingId(7047);
                    site7047.AuthDataVersion=2;
                    site7047.SetVirtualInterfaceIp("sgsvc", "1.1.1.1");
                }
            }
        }

        [TestCase]
        public class Privileges: TestNode
        {
            public override void Run()
            {
                //add our 2 test privileges
                PrivilegeEditor priv192=PrivilegeEditor.CreateOrUseExistingId(192);
                priv192.Name="TEST_PRIVILEGE1";

                PrivilegeEditor priv193=PrivilegeEditor.CreateOrUseExistingId(193);
                priv193.Name="TEST_PRIVILEGE2";
            }
        }

        [TestCase]
        public class Services : TestNode
        {
            private void CreateService(uint serviceId, uint siteId, bool machineOnly, params uint[] titleInstances)
            {
                ServiceEditor service = ServiceEditor.CreateOrUseExistingId(serviceId);
                service.KerberosServiceName = "sg";
                service.KerberosDomainName = "S" + serviceId;
                service.Name = "xkt" + serviceId;
                service.MachineOnly = machineOnly ? 1 : 0;

                service.RemoveAllInstances();
                foreach (uint titleId in titleInstances)
                {
                    service.AddInstance(titleId, 0, 0, siteId, serviceId, 1);
                }
            }

            public override void Run()
            {
                {
                    ServiceEditor serv8001 = ServiceEditor.CreateOrUseExistingId(8001);
                    serv8001.KerberosServiceName = "sg";
                    serv8001.KerberosDomainName = "S8001";
                    serv8001.Name = "xkt8001";
                    serv8001.MachineOnly = 1;
                    serv8001.AddInstance(0, 0, 0, 7045, 8001, 1);
                }
                {
                    ServiceEditor serv8002 = ServiceEditor.CreateOrUseExistingId(8002);
                    serv8002.KerberosServiceName = "sg";
                    serv8002.KerberosDomainName = "S8002";
                    serv8002.Name = "xkt8002";
                    serv8002.MachineOnly = 0;
                    serv8002.AddInstance(0, 0, 0, 7045, 8002, 1);
                }
                {
                    ServiceEditor serv8004 = ServiceEditor.CreateOrUseExistingId(8004);
                    serv8004.KerberosServiceName = "sg";
                    serv8004.KerberosDomainName = "S8004";
                    serv8004.Name = "xkt8004";
                    serv8004.MachineOnly = 0;
                    serv8004.AddInstance(0, 0, 0, 7046, 8004, 1);
                }
                {
                    ServiceEditor serv8005 = ServiceEditor.CreateOrUseExistingId(8005);
                    serv8005.KerberosServiceName = "sg";
                    serv8005.KerberosDomainName = "S8005";
                    serv8005.Name = "xkt8005";
                    serv8005.MachineOnly = 0;
                    serv8005.AddInstance(0xFFC0FE00, 0, 0, 1, 8005, 1);
                    serv8005.AddInstance(0xC0FE0800, 0, 0, 1, 8005, 1);
                }
                {
                    ServiceEditor serv8006 = ServiceEditor.CreateOrUseExistingId(8006);
                    serv8006.KerberosServiceName = "sg";
                    serv8006.KerberosDomainName = "S8006";
                    serv8006.Name = "xkt8006";
                    serv8006.MachineOnly = 0;
                    serv8006.AddInstance(0xFFC0FE00, 1, 0, 7045, 8006, 1);
                    serv8006.AddInstance(0xC0FE0800, 1, 0, 7045, 8006, 1);
                    serv8006.AddInstance(0x3EEF0821, 1, 0, 7045, 8006, 1);
                }
                {
                    ServiceEditor serv8007 = ServiceEditor.CreateOrUseExistingId(8007);
                    serv8007.KerberosServiceName = "sg";
                    serv8007.KerberosDomainName = "S8007";
                    serv8007.Name = "xkt8007";
                    serv8007.MachineOnly = 0;
                    serv8007.AddInstance(0xFFC0FE00, 1, 0, 7045, 8007, 0);
                    serv8007.AddInstance(0xC0FE0800, 1, 0, 7045, 8007, 0);
                }
                {
                    ServiceEditor serv8008 = ServiceEditor.CreateOrUseExistingId(8008);
                    serv8008.KerberosServiceName = "sg";
                    serv8008.KerberosDomainName = "S8008";
                    serv8008.Name = "xkt8008";
                    serv8008.MachineOnly = 0;
                    serv8008.AddInstance(0xFFBEEF21, 1, 0, 7045, 8008, 1);
                    serv8008.AddInstance(0xFFBEEF21, 2, 0, 7045, 8008, 1);
                    serv8008.AddInstance(0xFFBEEF21, 3, 0, 7045, 8108, 1);
                    serv8008.AddInstance(0xFFBEEF21, 4, 0, 7046, 8008, 1);
                    serv8008.AddInstance(0x3EEF0821, 1, 0, 7045, 8008, 1);
                    serv8008.AddInstance(0x3EEF0821, 2, 0, 7045, 8008, 1);
                    serv8008.AddInstance(0x3EEF0821, 3, 0, 7045, 8108, 1);
                    serv8008.AddInstance(0x3EEF0821, 4, 0, 7046, 8008, 1);
                }
                {
                    ServiceEditor serv8009 = ServiceEditor.CreateOrUseExistingId(8009);
                    serv8009.KerberosServiceName = "sg";
                    serv8009.KerberosDomainName = "S8009";
                    serv8009.Name = "xkt8009";
                    serv8009.MachineOnly = 0;
                }
                {
                    ServiceEditor serv8010 = ServiceEditor.CreateOrUseExistingId(8010);
                    serv8010.KerberosServiceName = "sg";
                    serv8010.KerberosDomainName = "S8010";
                    serv8010.Name = "xkt8010";
                    serv8010.MachineOnly = 0;
                    serv8010.AddInstance(0, 0, 0, 7047, 8010, 1);
                }
                {
                    ServiceEditor serv8011 = ServiceEditor.CreateOrUseExistingId(8011);
                    serv8011.KerberosServiceName = "sg";
                    serv8011.KerberosDomainName = "S8011";
                    serv8011.Name = "xkt8011";
                    serv8011.MachineOnly = 0;
                    serv8011.AddInstance(0, 0, 0, 7045, 8011, 1);
                }
                {
                    ServiceEditor serv8012 = ServiceEditor.CreateOrUseExistingId(8012);
                    serv8012.KerberosServiceName = "sg";
                    serv8012.KerberosDomainName = "S8012";
                    serv8012.Name = "xkt8012";
                    serv8012.MachineOnly = 0;
                    serv8012.AddInstance(0x3EEF0840, 0, 0, 7045, 8012, 1);
                }
                {
                    ServiceEditor serv8013 = ServiceEditor.CreateOrUseExistingId(8013);
                    serv8013.KerberosServiceName = "sg";
                    serv8013.KerberosDomainName = "S8012"; //was this intentional?
                    serv8013.Name = "xkt8013";
                    serv8013.MachineOnly = 0;
                    serv8013.AddInstance(0x3EEF0840, 1, 0, 7045, 8013, 1);
                    serv8013.AddInstance(0xFFBEEF2a, 1, 0, 7045, 8013, 1);
                    serv8013.AddInstance(0xFFBEEF2b, 1, 0, 7045, 8013, 1);
                }
                {
                    ServiceEditor serv8014 = ServiceEditor.CreateOrUseExistingId(8014);
                    serv8014.KerberosServiceName = "sg";
                    serv8014.KerberosDomainName = "S8014";
                    serv8014.Name = "xkt8014";
                    serv8014.MachineOnly = 0;
                    serv8014.AddInstance(0, 1, 0, 7045, 8014, 1);
                    serv8014.AddInstance(0xFFBEEF2a, 1, 0, 7047, 8014, 1);
                }
                {
                    ServiceEditor serv8015 = ServiceEditor.CreateOrUseExistingId(8015);
                    serv8015.KerberosServiceName = "sg";
                    serv8015.KerberosDomainName = "S8015";
                    serv8015.Name = "xkt8015";
                    serv8015.MachineOnly = 0;
                    serv8015.AddInstance(0, 0, 0, 7046, 8015, 1);
                }
                { //used for the "xna-like" offer test
                    ServiceEditor serv8105 = ServiceEditor.CreateOrUseExistingId(8105);
                    serv8105.KerberosServiceName = "sg";
                    serv8105.KerberosDomainName = "S8105";
                    serv8105.Name = "xkt8105";
                    serv8105.MachineOnly = 0;
                    serv8105.AddInstance(0xC0FE1005, 0, 0, 9999, 3074, 1);
                }

                // Test services using different versions of AuthData
                //CreateService(9002, 7002, false, 0xFFFE0004);
                //CreateService(9102, 7002, false, 0xFFFE0004);

                //CreateService(9003, 7003, false, 0xFFFE0004);
                //CreateService(9103, 7003, false, 0xFFFE0004);

                // A DWORD service associated with an AuthData4 site
                CreateService(9004, 7004, false, 0xFFFE0004);
                //CreateService(9104, 7004, true, 0x0);

                // A service with an ID > 255.  Should be treated as a DWORD
                // service.
                CreateService(256, 7004, false, 0xFFFE0004);
            }
        }

        [TestCase]
        public class Offers: TestNode
        {
            public override void Run()
            {
                //are these ends dates all intentionally in the past(2006)...?  or are the test data just that old that we passed the end date? (edit: I've added 100 years to the "expire in 2006" ones)
                {
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0001 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0001);
                    offerFFC0FE00C0FE0001.Name = "Xkdctest Subscription #1";
                    offerFFC0FE00C0FE0001.ConsoleType = 0;
                    offerFFC0FE00C0FE0001.StartDate = new System.DateTime(2002, 2, 2);
                    offerFFC0FE00C0FE0001.EndDate = new System.DateTime(2106, 2, 2);
                    offerFFC0FE00C0FE0001.OfferType = 1;
                    offerFFC0FE00C0FE0001.FrequencyId = 1;
                    offerFFC0FE00C0FE0001.Cancelable = 0;
                    offerFFC0FE00C0FE0001.ESRBRating = 6;
                    offerFFC0FE00C0FE0001.BitFilter = 1;
                    offerFFC0FE00C0FE0001.PolicyFlags = 1;
                    offerFFC0FE00C0FE0001.GlobalOfferDetails = 2;
                    offerFFC0FE00C0FE0001.AddService(8001);
                    offerFFC0FE00C0FE0001.AddPrivilege(192);
                    offerFFC0FE00C0FE0001.AddSubscription();

                    //new subscription family
                    PrivilegeSetEditor pse=PrivilegeSetEditor.CreateOrUseExistingId(0xfb01);
                    pse.Name="Xkdctest Migrated Subscription #1";
                    pse.AddPrivilege(192);

                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc01);
                    sse.Name="Xkdctest Migrated Subscription #1";
                    sse.AddService(8001);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa01);
                    spse.Name="Xkdctest Migrated Subscription #1";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=unchecked((short)pse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000001"));
                    sfe.Name="Xkdctest Migrated Subscription #1";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000001"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);

                    //The new subscription families have a behaviour change.  Offer privileges used to be granted even if the current title wasn't in the old t_offer_titles.  Now it MUST be in t_subscription_family_title.  This brings it in line with how service grants worked.  Since this affects a lot of tests that use this subscription, we'll add all titles used by tests here so the old tests still work.
                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0xFFBEEF00);
                    sfe.AddTitleId(0xFFBEEF01);
                    sfe.AddTitleId(0xFFBEEF02);
                    sfe.AddTitleId(0xFFBEEF03);
                    sfe.AddTitleId(0xFFBEEF04);
                    sfe.AddTitleId(0xFFBEEF05);
                    sfe.AddTitleId(0xFFBEEF06);
                    sfe.AddTitleId(0xFFBEEF07);
                    sfe.AddTitleId(0xFFBEEF08);
                    sfe.AddTitleId(0xFFBEEF09);
                    sfe.AddTitleId(0xFFBEEF0a);
                    sfe.AddTitleId(0xFFBEEF0b);
                    sfe.AddTitleId(0xFFBEEF0c);
                    sfe.AddTitleId(0xFFBEEF0d);
                    sfe.AddTitleId(0xFFBEEF0e);
                    sfe.AddTitleId(0xFFBEEF0f);
                    sfe.AddTitleId(0xC0FE0800);
                    sfe.AddTitleId(0xC0FE0900);
                    sfe.AddTitleId(0xFFC0FE00);
                    sfe.AddTitleId(0xfffe07d1);
                    sfe.AddTitleId(0x585207d1);
                    sfe.AddTitleId(0xfffe0000);
                    sfe.AddTitleId(0x3DEF0802);
                }
                {
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0002 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0002);
                    offerFFC0FE00C0FE0002.Name = "Xkdctest Subscription #2";
                    offerFFC0FE00C0FE0002.ConsoleType = 0;
                    offerFFC0FE00C0FE0002.StartDate = new System.DateTime(2002, 2, 2);
                    offerFFC0FE00C0FE0002.EndDate = new System.DateTime(2002, 2, 3);
                    offerFFC0FE00C0FE0002.OfferType = 1;
                    offerFFC0FE00C0FE0002.FrequencyId = 1;
                    offerFFC0FE00C0FE0002.Cancelable = 0;
                    offerFFC0FE00C0FE0002.ESRBRating = 6;
                    offerFFC0FE00C0FE0002.BitFilter = 1;
                    offerFFC0FE00C0FE0002.PolicyFlags = 1;
                    offerFFC0FE00C0FE0002.GlobalOfferDetails = 2;
                    offerFFC0FE00C0FE0002.AddService(8002);
                    offerFFC0FE00C0FE0002.AddService(8012);
                    offerFFC0FE00C0FE0002.AddService(8013);
                    offerFFC0FE00C0FE0002.AddSubscription();

                    //new subscription family
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc02);
                    sse.Name="Xkdctest Migrated Subscription #2";
                    sse.AddService(8002);
                    sse.AddService(8012);
                    sse.AddService(8013);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa02);
                    spse.Name="Xkdctest Migrated Subscription #2";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000002"));
                    sfe.Name="Xkdctest Migrated Subscription #2";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0x3EEF0821);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                {
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0003 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0003);
                    offerFFC0FE00C0FE0003.Name = "Xkdctest Subscription #3";
                    offerFFC0FE00C0FE0003.ConsoleType = 0;
                    offerFFC0FE00C0FE0003.StartDate = new System.DateTime(2006, 2, 2);
                    offerFFC0FE00C0FE0003.EndDate = new System.DateTime(2106, 2, 3);
                    offerFFC0FE00C0FE0003.OfferType = 1;
                    offerFFC0FE00C0FE0003.FrequencyId = 1;
                    offerFFC0FE00C0FE0003.Cancelable = 0;
                    offerFFC0FE00C0FE0003.ESRBRating = 6;
                    offerFFC0FE00C0FE0003.BitFilter = 1;
                    offerFFC0FE00C0FE0003.PolicyFlags = 1;
                    offerFFC0FE00C0FE0003.GlobalOfferDetails = 2;
                    offerFFC0FE00C0FE0003.AddService(8002);
                    offerFFC0FE00C0FE0003.AddSubscription();

                    //new subscription family
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc03);
                    sse.Name="Xkdctest Migrated Subscription #3";
                    sse.AddService(8002);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa03);
                    spse.Name="Xkdctest Migrated Subscription #3";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000003"));
                    sfe.Name="Xkdctest Migrated Subscription #3";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0x3EEF0821);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000003"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                {
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0004 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0004);
                    offerFFC0FE00C0FE0004.Name = "Xkdctest Subscription #4";
                    offerFFC0FE00C0FE0004.ConsoleType = 0;
                    offerFFC0FE00C0FE0004.StartDate = new System.DateTime(2002, 2, 2);
                    offerFFC0FE00C0FE0004.EndDate = new System.DateTime(2106, 2, 2);
                    offerFFC0FE00C0FE0004.OfferType = 1;
                    offerFFC0FE00C0FE0004.FrequencyId = 1;
                    offerFFC0FE00C0FE0004.Cancelable = 0;
                    offerFFC0FE00C0FE0004.ESRBRating = 6;
                    offerFFC0FE00C0FE0004.BitFilter = 1;
                    offerFFC0FE00C0FE0004.PolicyFlags = 1;
                    offerFFC0FE00C0FE0004.GlobalOfferDetails = 2;
                    offerFFC0FE00C0FE0004.AddService(8001);
                    offerFFC0FE00C0FE0004.AddService(8002);
                    offerFFC0FE00C0FE0004.AddService(8004);
                    offerFFC0FE00C0FE0004.AddSubscription();

                    //new subscription family
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc04);
                    sse.Name="Xkdctest Migrated Subscription #4";
                    sse.AddService(8001);
                    sse.AddService(8002);
                    sse.AddService(8004);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa04);
                    spse.Name="Xkdctest Migrated Subscription #4";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000004"));
                    sfe.Name="Xkdctest Migrated Subscription #4";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0x3EEF0821);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000004"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                {
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0005 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0005);
                    offerFFC0FE00C0FE0005.Name = "Xkdctest Subscription #5";
                    offerFFC0FE00C0FE0005.ConsoleType = 0;
                    offerFFC0FE00C0FE0005.StartDate = new System.DateTime(2002, 2, 2);
                    offerFFC0FE00C0FE0005.EndDate = new System.DateTime(2106, 2, 2);
                    offerFFC0FE00C0FE0005.OfferType = 1;
                    offerFFC0FE00C0FE0005.FrequencyId = 1;
                    offerFFC0FE00C0FE0005.Cancelable = 0;
                    offerFFC0FE00C0FE0005.ESRBRating = 6;
                    offerFFC0FE00C0FE0005.BitFilter = 1;
                    offerFFC0FE00C0FE0005.PolicyFlags = 1;
                    offerFFC0FE00C0FE0005.GlobalOfferDetails = 2;
                    offerFFC0FE00C0FE0005.AddService(8006);
                    offerFFC0FE00C0FE0005.AddService(8007);
                    offerFFC0FE00C0FE0005.AddService(8008);
                    offerFFC0FE00C0FE0005.AddService(8009);
                    offerFFC0FE00C0FE0005.AddService(8010);
                    offerFFC0FE00C0FE0005.AddService(8011);
                    offerFFC0FE00C0FE0005.AddSubscription();

                    //new subscription family
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc05);
                    sse.Name="Xkdctest Migrated Subscription #5";
                    sse.AddService(8006);
                    sse.AddService(8007);
                    sse.AddService(8008);
                    sse.AddService(8009);
                    sse.AddService(8010);
                    sse.AddService(8011);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa05);
                    spse.Name="Xkdctest Migrated Subscription #5";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000005"));
                    sfe.Name="Xkdctest Migrated Subscription #5";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0x3EEF0821);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000005"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                {
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE00FF = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE00FF);
                    offerFFC0FE00C0FE00FF.Name = "Xkdctest Subscription #6";
                    offerFFC0FE00C0FE00FF.ConsoleType = 0;
                    offerFFC0FE00C0FE00FF.StartDate = new System.DateTime(2002, 2, 2);
                    offerFFC0FE00C0FE00FF.EndDate = new System.DateTime(2106, 2, 2);
                    offerFFC0FE00C0FE00FF.OfferType = 1;
                    offerFFC0FE00C0FE00FF.FrequencyId = 1;
                    offerFFC0FE00C0FE00FF.Cancelable = 0;
                    offerFFC0FE00C0FE00FF.ESRBRating = 6;
                    offerFFC0FE00C0FE00FF.BitFilter = 1;
                    offerFFC0FE00C0FE00FF.PolicyFlags = 1;
                    offerFFC0FE00C0FE00FF.GlobalOfferDetails = 2;
                    offerFFC0FE00C0FE00FF.AddPrivilegeRestriction(255);
                    offerFFC0FE00C0FE00FF.AddPrivilegeRestriction(254);
                    offerFFC0FE00C0FE00FF.AddPrivilegeRestriction(245);
                    offerFFC0FE00C0FE00FF.AddPrivilegeRestriction(244);
                    offerFFC0FE00C0FE00FF.AddPrivilegeRestriction(192);
                    offerFFC0FE00C0FE00FF.AddSubscription();

                    //new subscription family
                    PrivilegeSetEditor pse=PrivilegeSetEditor.CreateOrUseExistingId(0xfbff);
                    pse.Name="Xkdctest Migrated Subscription #6";
                    //Privilege restrictions are not supported in the new system.  The tests that care have been updated to let this through.
                    //pse.AddPrivilegeRestrictions(255, 254, 245, 244, 192);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfaff);
                    spse.Name="Xkdctest Migrated Subscription #6";
                    spse.ServiceSet=null;
                    spse.PrivilegeSet=unchecked((short)pse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-0000000000ff"));
                    sfe.Name="Xkdctest Migrated Subscription #6";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000ff"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                {
                    //only used for vouchers
                    OfferEditor offerFFC0FE00C0FE0006 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0006);
                    offerFFC0FE00C0FE0006.Name = "Xkdctest PC Subscription #1";
                    offerFFC0FE00C0FE0006.ConsoleType = 0;
                    offerFFC0FE00C0FE0006.StartDate = new System.DateTime(2002, 2, 2);
                    offerFFC0FE00C0FE0006.EndDate = new System.DateTime(2106, 2, 2);
                    offerFFC0FE00C0FE0006.OfferType = 0x40000;
                    offerFFC0FE00C0FE0006.FrequencyId = 1;
                    offerFFC0FE00C0FE0006.Cancelable = 0;
                    offerFFC0FE00C0FE0006.ESRBRating = 6;
                    offerFFC0FE00C0FE0006.BitFilter = 1;
                    offerFFC0FE00C0FE0006.PolicyFlags = 1;
                    offerFFC0FE00C0FE0006.GlobalOfferDetails = 2;
                    offerFFC0FE00C0FE0006.AddSubscription(); //TODO: verify that this one is right...
                }
                {
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0007 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0007);
                    offerFFC0FE00C0FE0007.Name = "Xkdctest Subscription #7";
                    offerFFC0FE00C0FE0007.ConsoleType = 0;
                    offerFFC0FE00C0FE0007.StartDate = new System.DateTime(2002, 2, 2);
                    offerFFC0FE00C0FE0007.EndDate = new System.DateTime(2106, 2, 2);
                    offerFFC0FE00C0FE0007.OfferType = 1;
                    offerFFC0FE00C0FE0007.FrequencyId = 1;
                    offerFFC0FE00C0FE0007.Cancelable = 0;
                    offerFFC0FE00C0FE0007.ESRBRating = 6;
                    offerFFC0FE00C0FE0007.BitFilter = 1;
                    offerFFC0FE00C0FE0007.PolicyFlags = 1;
                    offerFFC0FE00C0FE0007.GlobalOfferDetails = 2;
                    offerFFC0FE00C0FE0007.AddService(8015);
                    offerFFC0FE00C0FE0007.AddSubscription();

                    //new subscription family
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc07);
                    sse.Name="Xkdctest Migrated Subscription #7";
                    sse.AddService(8015);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa07);
                    spse.Name="Xkdctest Migrated Subscription #7";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000007"));
                    sfe.Name="Xkdctest Migrated Subscription #7";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0xC0FE0801);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000007"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                { //no title grants the game subscription service even though the service family has it
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0008 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0008);
                    offerFFC0FE00C0FE0008.Name = "Xkdctest Subscription #8";
                    offerFFC0FE00C0FE0008.ConsoleType = 0;
                    offerFFC0FE00C0FE0008.OfferType = 512;
                    offerFFC0FE00C0FE0008.AddService(8015);
                    offerFFC0FE00C0FE0008.AddSubscription();

                    //new subscription family
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc08);
                    sse.Name="Xkdctest Migrated Subscription #8";
                    sse.AddService(8015);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa08);
                    spse.Name="Xkdctest Migrated Subscription #8";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000008"));
                    sfe.Name="Xkdctest Migrated Subscription #8";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000008"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                { //xbox.com subscription
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0009 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0009);
                    offerFFC0FE00C0FE0009.Name = "Xkdctest Subscription #9";
                    offerFFC0FE00C0FE0009.ConsoleType = 1;
                    offerFFC0FE00C0FE0009.OfferType = 1;
                    offerFFC0FE00C0FE0009.AddService(8015);
                    offerFFC0FE00C0FE0009.AddSubscription();

                    //new subscription family, there is no notion of console type now, so just make it normal
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc09);
                    sse.Name="Xkdctest Migrated Subscription #9";
                    sse.AddService(8015);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa09);
                    spse.Name="Xkdctest Migrated Subscription #9";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000009"));
                    sfe.Name="Xkdctest Migrated Subscription #9";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0xC0FE0800);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000009"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                { //xenon subscription
                    //old offer id
                    OfferEditor offerFFC0FE00C0FE0010 = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0010);
                    offerFFC0FE00C0FE0010.Name = "Xkdctest Subscription #10";
                    offerFFC0FE00C0FE0010.ConsoleType = 2;
                    offerFFC0FE00C0FE0010.OfferType = 1;
                    offerFFC0FE00C0FE0010.AddService(8015);
                    offerFFC0FE00C0FE0010.AddSubscription();

                    //new subscription family, there is no notion of console type now, so just make it normal
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc10);
                    sse.Name="Xkdctest Migrated Subscription #10";
                    sse.AddService(8015);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa10);
                    spse.Name="Xkdctest Migrated Subscription #10";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-000000000010"));
                    sfe.Name="Xkdctest Migrated Subscription #10";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0xC0FE0800);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000010"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                { // title activation #0, this is used as a "legacy title" case (no ssa)
                    OfferEditor offerC0FE09000FF00000 = OfferEditor.CreateOrUseExistingId(0xC0FE09000FF00000);
                    offerC0FE09000FF00000.Name = "PC Account Creation Test Title C0FE0900";
                    offerC0FE09000FF00000.ConsoleType = 4;
                    offerC0FE09000FF00000.OfferType = 0x40000;
                }
                { // title activation #1
                    OfferEditor offerC0FE09010FF00000 = OfferEditor.CreateOrUseExistingId(0xC0FE09010FF00000);
                    offerC0FE09010FF00000.Name = "PC Account Creation Test Title C0FE0901";
                    offerC0FE09010FF00000.ConsoleType = 4;
                    offerC0FE09010FF00000.OfferType = 0x40000;
                }
                { // title activation #2
                    OfferEditor offerC0FE09020FF00000 = OfferEditor.CreateOrUseExistingId(0xC0FE09020FF00000);
                    offerC0FE09020FF00000.Name = "PC Account Creation Test Title C0FE0902";
                    offerC0FE09020FF00000.ConsoleType = 4;
                    offerC0FE09020FF00000.OfferType = 0x40000;
                }

                {
                    //"Xbox Live 12 Month Online Subscription" - this should be part of normal deployment already
                    //old offer id
                    OfferEditor offerFFFE000080000008 = OfferEditor.FromId(0xFFFE000080000008);
                    offerFFFE000080000008.AddService(8005); //This is a non-base service on a base offer, so it should not be granted

                    //subscription family should already be migrated, so just add the services
                    //TODO: This hasn't been migrated by their scripts...
                    //TODO: I don't really want to "replace" their service set with my own... or alter the service_set_service, as it could be shared with other stuff... what to do...
                    //TODO: I will probably have to track down what case is verifying this and just make a new subscription that tests specifically this situation.
                }
                {
                    //"Xbox Live 12 mo. Gold Membership" - this should be part of normal deployment already
                    //old offer id
                    OfferEditor offerFFFE07D18000000A = OfferEditor.FromId(0xFFFE07D18000000A);
                    offerFFFE07D18000000A.AddService(8004); //This is a non-base service on a base offer, so it should not be granted

                    //subscription family should already be migrated, so just add the services
                    //TODO: I don't really want to "replace" their service set with my own... or alter the service_set_service, as it could be shared with other stuff... what to do...
                    //TODO: I will probably have to track down what case is verifying this and just make a new subscription that tests specifically this situation.
                }

                {
                    // CAuthData4 Offer
                    //old offer id
                    OfferEditor offerFFFE000400000000 = OfferEditor.CreateOrUseExistingId(0xFFFE000400000000);
                    offerFFFE000400000000.AddService(256);
                    offerFFFE000400000000.AddService(9004);
                    //offerFFFE000400000000.AddService(9104); //temporarily removed due to an issue with machine-only dword services.
                    offerFFFE000400000000.AddSubscription();

                    //new subscription family, there is no notion of console type now, so just make it normal
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfc80);
                    sse.Name="Xkdctest Migrated Subscription CAuthData4";
                    sse.AddService(256);
                    sse.AddService(9004);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfa80);
                    spse.Name="Xkdctest Migrated Subscription CAuthData4";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=null;

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFFE0004-C0FE-0000-0000-0000FFFE0004"));
                    sfe.Name="Xkdctest Migrated Subscription CAuthData4";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();
                    sfe.AddTitleId(0xFFFE0004);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFFE0004-C0FE-0000-ffff-0000FFFE0004"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }

                //Base subscription grants tier 15, services 1, 3, 11, and privilge 237
                {
                    //make sure tier 15 exists
                    UodbWS.ExecuteSQLNonQuery("if ((select count(*) from t_tiers where i_tier_id=15)=0) begin insert into t_tiers (i_tier_id, vc_name) values (15, 'XkdcTest Tier 15') end", null);

                    //old offer id
                    OfferEditor oldOffer = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE00A0);
                    oldOffer.Name = "Xkdctest Subscription #A0";
                    oldOffer.AddService(1);
                    oldOffer.AddService(3);
                    oldOffer.AddService(11);
                    oldOffer.AddPrivilege(237);
                    oldOffer.AddSubscription(1, 15, 1);

                    //new subscription family
                    PrivilegeSetEditor pse=PrivilegeSetEditor.CreateOrUseExistingId(0xfba0);
                    pse.Name="Xkdctest Subscription #A0";
                    pse.AddPrivilege(237);

                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfca0);
                    sse.Name="Xkdctest Subscription #A0";
                    sse.AddService(1);
                    sse.AddService(3);
                    sse.AddService(11);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfaa0);
                    spse.Name="Xkdctest Subscription #A0";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=unchecked((short)pse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-0000000000A0"));
                    sfe.Name="Xkdctest Subscription #A0";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=1; //base
                    sfe.TierId=15;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A0"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }

                //Base subscription grants tier 0xf9abcde8, services 11
                {
                    //make sure tier 0xf9abcde8 exists
                    UodbWS.ExecuteSQLNonQuery("if ((select count(*) from t_tiers where i_tier_id=0xf9abcde8)=0) begin insert into t_tiers (i_tier_id, vc_name) values (0xf9abcde8, 'XkdcTest Tier 0xf9abcde8') end", null);

                    //old offer id
                    OfferEditor oldOffer = OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE00A1);
                    oldOffer.Name = "Xkdctest Subscription #A1";
                    oldOffer.AddService(11);
                    oldOffer.AddSubscription(1, 0xf9abcde8, 1);

                    //new subscription family
                    PrivilegeSetEditor pse=PrivilegeSetEditor.CreateOrUseExistingId(0xfba1);
                    pse.Name="Xkdctest Subscription #A1";

                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfca1);
                    sse.Name="Xkdctest Subscription #A1";
                    sse.AddService(11);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfaa1);
                    spse.Name="Xkdctest Subscription #A1";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=unchecked((short)pse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-0000000000A1"));
                    sfe.Name="Xkdctest Subscription #A1";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=1; //base
                    sfe.TierId=unchecked((int)0xf9abcde8);
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.RemoveAllTitleIds();

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A1"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }

                //Subscription grants service 8014
                {
                    //old offer id
                    OfferEditor oldOffer=OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE00A3);
                    oldOffer.Name = "Xkdctest Subscription #A3";
                    oldOffer.OfferType=1;
                    oldOffer.AddService(8014);
                    oldOffer.RemoveSubscriptions();
                    oldOffer.AddSubscription();

                    //new subscription family
                    ServiceSetEditor sse=ServiceSetEditor.CreateOrUseExistingId(0xfca3);
                    sse.Name="Xkdctest Subscription #A3";
                    sse.AddService(8014);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfaa3);
                    spse.Name="Xkdctest Subscription #A3";
                    spse.ServiceSet=unchecked((short)sse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-0000000000A3"));
                    sfe.Name="Xkdctest Subscription #A3";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //base
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.AddTitleId(0xC0FE0800);
                    sfe.AddTitleId(0xFFBEEF2A);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A3"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }

                // Subscription grants services 80-119 to New Testland
                {
                    OfferEditor oldOffer=OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE00A4);
                    oldOffer.Name="Xkdctest Subscription #A4";
                    oldOffer.OfferType=1;

                    oldOffer.RemoveSubscriptions();
                    oldOffer.AddSubscription(1, 0, 0);

                    ServiceSetEditor sse = ServiceSetEditor.CreateOrUseExistingId(0xfca4);
                    sse.Name="Xkdctest Subscription #A4"; //populated in Beyond32ServicesData
                    sse.RemoveAllServices();

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfaa4);
                    spse.Name="Xkdctest Subscription #A4";
                    spse.ServiceSet=unchecked((short)sse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-0000000000A4"));
                    sfe.Name="Xkdctest Subscription #A4";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //base
                    sfe.TierId=6;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.AddTitleId(0xC0FE0800);
                    sfe.AddTitleId(0xFFBEEF2A);
                    sfe.AddTitleId(0xFFFE07D1);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A4"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }

                { //An offer set up similar to the XNA offer (just different numbers), to verify their specific scenario still works exactly like we expect
                    //64-bit offers
                    OfferEditor oldOffer=OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE00A5);
                    oldOffer.Name="Xkdctest Subscription #A5 (like XNA)";
                    oldOffer.OfferType=1;

                    oldOffer.RemoveSubscriptions();
                    oldOffer.AddSubscription(1, 0, 0);

                    oldOffer.AddService(8105);
                    oldOffer.AddPrivilege(222); //XPRIVILEGE_CONTENT_AUTHOR

                    //subscription famililies
                    PrivilegeSetEditor pse=PrivilegeSetEditor.CreateOrUseExistingId(0xfba5);
                    pse.Name="Xkdctest Subscription #A5 (like XNA)";
                    pse.AddPrivilege(222); //XPRIVILEGE_CONTENT_AUTHOR

                    ServiceSetEditor sse = ServiceSetEditor.CreateOrUseExistingId(0xfca5);
                    sse.Name="Xkdctest Subscription #A5 (like XNA)";
                    sse.AddService(8105);

                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfaa5);
                    spse.Name="Xkdctest Subscription #A5 (like XNA)";
                    spse.ServiceSet=unchecked((short)sse.Id);
                    spse.PrivilegeSet=unchecked((short)pse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-0000000000A5"));
                    sfe.Name="Xkdctest Subscription #A5 (like XNA)";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=3; //Game
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.AddTitleId(0xC0FE1005);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A5"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }

                //Two different offers that grant the same privilege (game subscription privilege) to different titles and one common title, modeled after the EA/Activision/etc game subscription offers
                {
                    //64-bit offers
                    OfferEditor oldOffer=OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE00A6);
                    oldOffer.Name="Xkdctest Subscription #A6 (game privilege)";
                    oldOffer.OfferType=1;

                    oldOffer.RemoveSubscriptions();
                    oldOffer.AddSubscription(2, 0, 0);

                    oldOffer.AddPrivilege(218); //XPRIVILEGE_SUBSCRIPTION_TITLE

                    //subscription famililies
                    PrivilegeSetEditor pse=PrivilegeSetEditor.CreateOrUseExistingId(0xfba6);
                    pse.Name="Xkdctest Subscription #A6 (game privilege)";
                    pse.AddPrivilege(218); //XPRIVILEGE_SUBSCRIPTION_TITLE


                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfaa6);
                    spse.Name="Xkdctest Subscription #A6 (game privilege)";
                    spse.PrivilegeSet=unchecked((short)pse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-0000000000A6"));
                    sfe.Name="Xkdctest Subscription #A6 (game privilege)";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=2;
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.AddTitleId(0xC0FE1006);
                    sfe.AddTitleId(0xC0FE1008);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A6"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
                {
                    //64-bit offers
                    OfferEditor oldOffer=OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE00A7);
                    oldOffer.Name="Xkdctest Subscription #A7 (game privilege)";
                    oldOffer.OfferType=1;

                    oldOffer.RemoveSubscriptions();
                    oldOffer.AddSubscription(2, 0, 0);

                    oldOffer.AddPrivilege(218); //XPRIVILEGE_SUBSCRIPTION_TITLE

                    //subscription famililies
                    PrivilegeSetEditor pse=PrivilegeSetEditor.CreateOrUseExistingId(0xfba7);
                    pse.Name="Xkdctest Subscription #A7 (game privilege)";
                    pse.AddPrivilege(218); //XPRIVILEGE_SUBSCRIPTION_TITLE


                    ServicePrivilegeSetEditor spse=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfaa7);
                    spse.Name="Xkdctest Subscription #A7 (game privilege)";
                    spse.PrivilegeSet=unchecked((short)pse.Id);

                    SubscriptionFamilyEditor sfe=SubscriptionFamilyEditor.CreateOrUseExistingId(new System.Guid("FFC0FE00-C0FE-0000-0000-0000000000A7"));
                    sfe.Name="Xkdctest Subscription #A7 (game privilege)";
                    sfe.ServiceType=1; //xbox live
                    sfe.SubscriptionType=2;
                    sfe.TierId=0;
                    sfe.ServicePrivilegeSet=unchecked((short)spse.Id);

                    sfe.AddTitleId(0xC0FE1007);
                    sfe.AddTitleId(0xC0FE1008);

                    OfferInstanceSubscriptionFamilyMappingEditor oisfme=OfferInstanceSubscriptionFamilyMappingEditor.FromId(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A7"));
                    oisfme.RemoveAllSubscriptionFamilies();
                    oisfme.AddSubscriptionFamily(sfe.Id);
                }
            }
        }

        [TestCase]
        public class Titles: TestNode
        {
            public override void Run()
            {
                unchecked
                {
                    {
                        TitleEditor titleFFC0FE00 = TitleEditor.CreateOrUseExistingId(0xFFC0FE00);
                        titleFFC0FE00.ConsoleType = 0;
                        titleFFC0FE00.RemoveAllVersions();
                        titleFFC0FE00.AddVersion(1, 1, 1, 0);
                        titleFFC0FE00.SetTitleTrustConstants(1, 1, 1, 1, 1, 0, 0, 0, 1, 0.25f, 2, 4, 2592000, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000, 10000, 0, 0, 0, 0, 0, 0, 0, 2, 8, 16, 32, 64, 0, 0, 0, 1, 8, 4, 2, 1, 1, 2, 4, 8);
                        titleFFC0FE00.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleC0FE0800 = TitleEditor.CreateOrUseExistingId(0xC0FE0800);
                        titleC0FE0800.ConsoleType = 0;
                        titleC0FE0800.RemoveAllVersions();
                        titleC0FE0800.AddVersion(1, 1, 1, 2);
                        titleC0FE0800.SetTitleTrustConstants(1, 1, 1, 1, 1, 0, 0, 0, 1, 0.25f, 2, 4, 2592000, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000, 10000, 0, 0, 0, 0, 0, 0, 0, 2, 8, 16, 32, 64, 0, 0, 0, 1, 8, 4, 2, 1, 1, 2, 4, 8);
                        titleC0FE0800.AddOffer(0xFFC0FE00C0FE0009);
                        titleC0FE0800.AddOffer(0xFFC0FE00C0FE0010);
                        titleC0FE0800.AddOffer(0xFFC0FE00C0FE00A3);
                        titleC0FE0800.AddOffer(0xFFC0FE00C0FE0001);
                        titleC0FE0800.AddOffer(0xFFC0FE00C0FE00A4);
                    }
                    {
                        TitleEditor titleC0FE0801 = TitleEditor.CreateOrUseExistingId(0xC0FE0801);
                        titleC0FE0801.ConsoleType = 0;
                        titleC0FE0801.RemoveAllVersions();
                        titleC0FE0801.AddVersion(0, 0, 0, 2);
                        titleC0FE0801.AddOffer(0xFFC0FE00C0FE0007);
                    }
                    {
                        TitleEditor titleFFBEEF00 = TitleEditor.CreateOrUseExistingId(0xFFBEEF00);
                        titleFFBEEF00.ConsoleType = 0;
                        titleFFBEEF00.RemoveAllVersions();
                        titleFFBEEF00.AddVersion(1, 1, 1, 0);
                        titleFFBEEF00.SetTitleTrustConstants(1, 1, 1, 1, 1, 0, 0, 0, 1, 0.25f, 2, 4, 2592000, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000, 10000, 50000, 5000, 0, 0, 0, 0, 0, 2, 8, 16, 32, 64, 0, 0, 0, 1, 8, 4, 2, 1, 1, 2, 4, 8);
                        titleFFBEEF00.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF01 = TitleEditor.CreateOrUseExistingId(0xFFBEEF01);
                        titleFFBEEF01.ConsoleType = 0;
                        titleFFBEEF01.RemoveAllVersions();
                        titleFFBEEF01.AddVersion(1, 3, 3, 0);
                        titleFFBEEF01.AddVersion(2, 3, 3, 0);
                        titleFFBEEF01.AddVersion(3, 3, 3, 0);
                        titleFFBEEF01.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF02 = TitleEditor.CreateOrUseExistingId(0xFFBEEF02);
                        titleFFBEEF02.ConsoleType = 0;
                        titleFFBEEF02.RemoveAllVersions();
                        titleFFBEEF02.AddVersion(1, 1, 1, 0);
                        titleFFBEEF02.AddVersion(2, 2, 2, 0);
                        titleFFBEEF02.AddVersion(2147483647, 2147483647, 2147483647, 0);
                        titleFFBEEF02.AddVersion((uint)-2147483648, (uint)-2147483648, (uint)-2147483648, 0);
                        titleFFBEEF02.AddVersion((uint)-1, (uint)-1, (uint)-1, 0);
                        titleFFBEEF02.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF03 = TitleEditor.CreateOrUseExistingId(0xFFBEEF03);
                        titleFFBEEF03.ConsoleType = 0;
                        titleFFBEEF03.RemoveAllVersions();
                        titleFFBEEF03.AddVersion(2, 2, 2, 0);
                        titleFFBEEF03.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF04 = TitleEditor.CreateOrUseExistingId(0xFFBEEF04);
                        titleFFBEEF04.ConsoleType = 0;
                        titleFFBEEF04.RemoveAllVersions();
                        titleFFBEEF04.AddVersion(2147483646, 2147483647, 2147483647, 0);
                        titleFFBEEF04.AddVersion(2147483647, 2147483647, 2147483647, 0);
                        titleFFBEEF04.AddVersion((uint)-2147483648, (uint)-2147483647, (uint)-2147483647, 0);
                        titleFFBEEF04.AddVersion((uint)-2147483647, (uint)-2147483647, (uint)-2147483647, 0);
                        titleFFBEEF04.AddVersion((uint)-2, (uint)-1, (uint)-1, 0);
                        titleFFBEEF04.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF05 = TitleEditor.CreateOrUseExistingId(0xFFBEEF05);
                        titleFFBEEF05.ConsoleType = 0;
                        titleFFBEEF05.RemoveAllVersions();
                        titleFFBEEF05.AddVersion(2147483647, (uint)-2147483648, (uint)-2147483648, 0);
                        titleFFBEEF05.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF06 = TitleEditor.CreateOrUseExistingId(0xFFBEEF06);
                        titleFFBEEF06.ConsoleType = 0;
                        titleFFBEEF06.RemoveAllVersions();
                        titleFFBEEF06.AddVersion(1, 5, 5, 0);
                        titleFFBEEF06.AddVersion(2, 5, 5, 0);
                        titleFFBEEF06.AddVersion(3, 4, 4, 0);
                        titleFFBEEF06.AddVersion(4, 4, 4, 0);
                        titleFFBEEF06.AddVersion(5, 5, 5, 0);
                        titleFFBEEF06.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF07 = TitleEditor.CreateOrUseExistingId(0xFFBEEF07);
                        titleFFBEEF07.ConsoleType = 0;
                        titleFFBEEF07.RemoveAllVersions();
                        titleFFBEEF07.AddVersion(1, 1, 1, 0);
                        titleFFBEEF07.AddVersion(3, 1, 1, 0);
                        titleFFBEEF07.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF08 = TitleEditor.CreateOrUseExistingId(0xFFBEEF08);
                        titleFFBEEF08.ConsoleType = 0;
                        titleFFBEEF08.RemoveAllVersions();
                        titleFFBEEF08.AddVersion(1, 2, 2, 0);
                        titleFFBEEF08.AddVersion(2, 1, 1, 0);
                        titleFFBEEF08.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF09 = TitleEditor.CreateOrUseExistingId(0xFFBEEF09);
                        titleFFBEEF09.ConsoleType = 0;
                        titleFFBEEF09.RemoveAllVersions();
                        titleFFBEEF09.AddVersion(1, 2, 2, 0);
                        titleFFBEEF09.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF0A = TitleEditor.CreateOrUseExistingId(0xFFBEEF0A);
                        titleFFBEEF0A.ConsoleType = 0;
                        titleFFBEEF0A.RemoveAllVersions();
                        titleFFBEEF0A.AddVersion(1, 1, 2, 0);
                        titleFFBEEF0A.AddVersion(2, 2, 2, 0);
                        titleFFBEEF0A.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF0B = TitleEditor.CreateOrUseExistingId(0xFFBEEF0B);
                        titleFFBEEF0B.ConsoleType = 0;
                        titleFFBEEF0B.RemoveAllVersions();
                        titleFFBEEF0B.AddVersion(1, 2, 3, 0);
                        titleFFBEEF0B.AddVersion(2, 2, 3, 0);
                        titleFFBEEF0B.AddVersion(3, 2, 3, 0);
                        titleFFBEEF0B.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF0C = TitleEditor.CreateOrUseExistingId(0xFFBEEF0C);
                        titleFFBEEF0C.ConsoleType = 0;
                        titleFFBEEF0C.RemoveAllVersions();
                        titleFFBEEF0C.AddVersion(1, 3, 2, 0);
                        titleFFBEEF0C.AddVersion(2, 2, 2, 0);
                        titleFFBEEF0C.AddVersion(3, 3, 2, 0);
                        titleFFBEEF0C.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF0D = TitleEditor.CreateOrUseExistingId(0xFFBEEF0D);
                        titleFFBEEF0D.ConsoleType = 0;
                        titleFFBEEF0D.RemoveAllVersions();
                        titleFFBEEF0D.AddVersion(0, 0, 0, 0);
                        titleFFBEEF0D.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF0E = TitleEditor.CreateOrUseExistingId(0xFFBEEF0E);
                        titleFFBEEF0E.ConsoleType = 0;
                        titleFFBEEF0E.RemoveAllVersions();
                        titleFFBEEF0E.AddVersion(0, 1, 1, 0);
                        titleFFBEEF0E.AddVersion(1, 1, 1, 0);
                        titleFFBEEF0E.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF0F = TitleEditor.CreateOrUseExistingId(0xFFBEEF0F);
                        titleFFBEEF0F.ConsoleType = 0;
                        titleFFBEEF0F.RemoveAllVersions();
                        titleFFBEEF0F.AddVersion(0, 0, 0, 0);
                        titleFFBEEF0F.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor titleFFBEEF20 = TitleEditor.CreateOrUseExistingId(0xFFBEEF20);
                        titleFFBEEF20.ConsoleType = 0;
                        titleFFBEEF20.RemoveAllVersions();
                        titleFFBEEF20.AddVersion(1, 1, 1, 0);
                    }
                    {
                        TitleEditor titleFFBEEF21 = TitleEditor.CreateOrUseExistingId(0xFFBEEF21);
                        titleFFBEEF21.ConsoleType = 0;
                        titleFFBEEF21.RemoveAllVersions();
                        titleFFBEEF21.AddVersion(1, 1, 1, 0);
                        titleFFBEEF21.AddVersion(2, 2, 2, 0);
                        titleFFBEEF21.AddVersion(3, 3, 3, 0);
                        titleFFBEEF21.AddVersion(4, 4, 4, 0);
                    }
                    {
                        TitleEditor titleFFBEEF2A = TitleEditor.CreateOrUseExistingId(0xFFBEEF2A);
                        titleFFBEEF2A.ConsoleType = 0;
                        titleFFBEEF2A.RemoveAllVersions();
                        titleFFBEEF2A.AddVersion(1, 1, 1, 0);
                        titleFFBEEF2A.AddPrivilege(193);
                        titleFFBEEF2A.AddService(8013);

                        titleFFBEEF2A.AddOffer(0xFFC0FE00C0FE00A3);
                        titleFFBEEF2A.AddOffer(0xFFC0FE00C0FE00A4);
                    }
                    {
                        TitleEditor titleFFBEEF2B = TitleEditor.CreateOrUseExistingId(0xFFBEEF2B);
                        titleFFBEEF2B.ConsoleType = 0;
                        titleFFBEEF2B.RemoveAllVersions();
                        titleFFBEEF2B.AddVersion(1, 1, 1, 2);
                        titleFFBEEF2B.AddPrivilege(193);
                        titleFFBEEF2B.AddService(8013);
                    }
                    {
                        TitleEditor titleFFBEEF30 = TitleEditor.CreateOrUseExistingId(0xFFBEEF30);
                        titleFFBEEF30.ConsoleType = 0;
                        titleFFBEEF30.RemoveAllVersions();
                    }
                    {
                        TitleEditor titleFFBDEF01 = TitleEditor.CreateOrUseExistingId(0xFFBDEF01);
                        titleFFBDEF01.ConsoleType = 0;
                        titleFFBDEF01.RemoveAllVersions();
                        titleFFBDEF01.AddVersion(1, 1, 2, 0);
                        titleFFBDEF01.AddVersion(2, 1, 2, 0);
                    }
                    {
                        TitleEditor title3DEF0801 = TitleEditor.CreateOrUseExistingId(0x3DEF0801);
                        title3DEF0801.ConsoleType = 0;
                        title3DEF0801.RemoveAllVersions();
                        title3DEF0801.AddVersion(1, 1, 2, 2);
                        title3DEF0801.AddVersion(2, 1, 2, 2);
                    }
                    {
                        TitleEditor title3EEF0800 = TitleEditor.CreateOrUseExistingId(0x3EEF0800);
                        title3EEF0800.ConsoleType = 0;
                        title3EEF0800.RemoveAllVersions();
                        title3EEF0800.AddVersion(1, 1, 1, 2);
                        title3EEF0800.SetTitleTrustConstants(1, 1, 1, 1, 1, 0, 0, 0, 1, 0.25f, 2, 4, 2592000, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100000, 10000, 50000, 5000, 0, 0, 0, 0, 0, 2, 8, 16, 32, 64, 0, 0, 0, 1, 8, 4, 2, 1, 1, 2, 4, 8);
                    }
                    {
                        TitleEditor title3EEF0801 = TitleEditor.CreateOrUseExistingId(0x3EEF0801);
                        title3EEF0801.ConsoleType = 0;
                        title3EEF0801.RemoveAllVersions();
                        title3EEF0801.AddVersion(1, 3, 3, 2);
                        title3EEF0801.AddVersion(2, 3, 3, 2);
                        title3EEF0801.AddVersion(3, 3, 3, 2);
                    }
                    {
                        TitleEditor title3EEF0802 = TitleEditor.CreateOrUseExistingId(0x3EEF0802);
                        title3EEF0802.ConsoleType = 0;
                        title3EEF0802.RemoveAllVersions();
                        title3EEF0802.AddVersion(1, 1, 1, 2);
                        title3EEF0802.AddVersion(2, 2, 2, 2);
                        title3EEF0802.AddVersion(2147483647, 2147483647, 2147483647, 2);
                        title3EEF0802.AddVersion((uint)-2147483648, (uint)-2147483648, (uint)-2147483648, 2);
                        title3EEF0802.AddVersion((uint)-1, (uint)-1, (uint)-1, 2);
                    }
                    {
                        TitleEditor title3EEF0803 = TitleEditor.CreateOrUseExistingId(0x3EEF0803);
                        title3EEF0803.ConsoleType = 0;
                        title3EEF0803.RemoveAllVersions();
                        title3EEF0803.AddVersion(2, 2, 2, 2);
                    }
                    {
                        TitleEditor title3EEF0804 = TitleEditor.CreateOrUseExistingId(0x3EEF0804);
                        title3EEF0804.ConsoleType = 0;
                        title3EEF0804.RemoveAllVersions();
                        title3EEF0804.AddVersion(2147483646, 2147483647, 2147483647, 2);
                        title3EEF0804.AddVersion(2147483647, 2147483647, 2147483647, 2);
                        title3EEF0804.AddVersion((uint)-2147483648, (uint)-2147483647, (uint)-2147483647, 2);
                        title3EEF0804.AddVersion((uint)-2147483647, (uint)-2147483647, (uint)-2147483647, 2);
                        title3EEF0804.AddVersion((uint)-2, (uint)-1, (uint)-1, 2);
                    }
                    {
                        TitleEditor title3EEF0805 = TitleEditor.CreateOrUseExistingId(0x3EEF0805);
                        title3EEF0805.ConsoleType = 0;
                        title3EEF0805.RemoveAllVersions();
                        title3EEF0805.AddVersion(2147483647, (uint)-2147483648, (uint)-2147483648, 2);
                    }
                    {
                        TitleEditor title3EEF0806 = TitleEditor.CreateOrUseExistingId(0x3EEF0806);
                        title3EEF0806.ConsoleType = 0;
                        title3EEF0806.RemoveAllVersions();
                        title3EEF0806.AddVersion(1, 5, 5, 2);
                        title3EEF0806.AddVersion(2, 5, 5, 2);
                        title3EEF0806.AddVersion(3, 4, 4, 2);
                        title3EEF0806.AddVersion(4, 4, 4, 2);
                        title3EEF0806.AddVersion(5, 5, 5, 2);
                    }
                    {
                        TitleEditor title3EEF0807 = TitleEditor.CreateOrUseExistingId(0x3EEF0807);
                        title3EEF0807.ConsoleType = 0;
                        title3EEF0807.RemoveAllVersions();
                        title3EEF0807.AddVersion(1, 1, 1, 2);
                        title3EEF0807.AddVersion(3, 1, 1, 2);
                    }
                    {
                        TitleEditor title3EEF0808 = TitleEditor.CreateOrUseExistingId(0x3EEF0808);
                        title3EEF0808.ConsoleType = 0;
                        title3EEF0808.RemoveAllVersions();
                        title3EEF0808.AddVersion(1, 2, 2, 2);
                        title3EEF0808.AddVersion(2, 1, 1, 2);
                    }
                    {
                        TitleEditor title3EEF0809 = TitleEditor.CreateOrUseExistingId(0x3EEF0809);
                        title3EEF0809.ConsoleType = 0;
                        title3EEF0809.RemoveAllVersions();
                        title3EEF0809.AddVersion(1, 2, 2, 2);
                    }
                    {
                        TitleEditor title3EEF080A = TitleEditor.CreateOrUseExistingId(0x3EEF080A);
                        title3EEF080A.ConsoleType = 0;
                        title3EEF080A.RemoveAllVersions();
                        title3EEF080A.AddVersion(1, 1, 2, 2);
                        title3EEF080A.AddVersion(2, 2, 2, 2);
                    }
                    {
                        TitleEditor title3EEF080B = TitleEditor.CreateOrUseExistingId(0x3EEF080B);
                        title3EEF080B.ConsoleType = 0;
                        title3EEF080B.RemoveAllVersions();
                        title3EEF080B.AddVersion(1, 2, 3, 2);
                        title3EEF080B.AddVersion(2, 2, 3, 2);
                        title3EEF080B.AddVersion(3, 3, 3, 2);
                    }
                    {
                        TitleEditor title3EEF080C = TitleEditor.CreateOrUseExistingId(0x3EEF080C);
                        title3EEF080C.ConsoleType = 0;
                        title3EEF080C.RemoveAllVersions();
                        title3EEF080C.AddVersion(1, 3, 2, 2);
                        title3EEF080C.AddVersion(2, 2, 2, 2);
                        title3EEF080C.AddVersion(3, 3, 2, 2);
                    }
                    {
                        TitleEditor title3EEF080D = TitleEditor.CreateOrUseExistingId(0x3EEF080D);
                        title3EEF080D.ConsoleType = 0;
                        title3EEF080D.RemoveAllVersions();
                        title3EEF080D.AddVersion(0, 0, 0, 2);
                    }
                    {
                        TitleEditor title3EEF080E = TitleEditor.CreateOrUseExistingId(0x3EEF080E);
                        title3EEF080E.ConsoleType = 0;
                        title3EEF080E.RemoveAllVersions();
                        title3EEF080E.AddVersion(0, 1, 1, 2);
                        title3EEF080E.AddVersion(1, 1, 1, 2);
                    }
                    {
                        TitleEditor title3EEF080F = TitleEditor.CreateOrUseExistingId(0x3EEF080F);
                        title3EEF080F.ConsoleType = 0;
                        title3EEF080F.RemoveAllVersions();
                        title3EEF080F.AddVersion(0, 0, 0, 2);
                    }
                    {
                        TitleEditor title3EEF0820 = TitleEditor.CreateOrUseExistingId(0x3EEF0820);
                        title3EEF0820.ConsoleType = 0;
                        title3EEF0820.RemoveAllVersions();
                        title3EEF0820.AddVersion(1, 1, 1, 2);
                    }
                    {
                        TitleEditor title3EEF0821 = TitleEditor.CreateOrUseExistingId(0x3EEF0821);
                        title3EEF0821.ConsoleType = 0;
                        title3EEF0821.RemoveAllVersions();
                        title3EEF0821.AddVersion(1, 1, 1, 2);
                        title3EEF0821.AddVersion(2, 2, 2, 2);
                        title3EEF0821.AddVersion(3, 3, 3, 2);
                        title3EEF0821.AddVersion(4, 4, 4, 2);
                        title3EEF0821.AddOffer(0xFFC0FE00C0FE0005);
                        title3EEF0821.AddOffer(0xFFC0FE00C0FE0003);
                        title3EEF0821.AddOffer(0xFFC0FE00C0FE0004);
                        title3EEF0821.AddOffer(0xFFC0FE00C0FE0002);
                    }
                    {
                        TitleEditor title3EEF0830 = TitleEditor.CreateOrUseExistingId(0x3EEF0830);
                        title3EEF0830.ConsoleType = 0;
                        title3EEF0830.RemoveAllVersions();
                        title3EEF0830.AddVersion(1, 1, 1, 2);
                        title3EEF0830.AddVersion(2, 2, 1, 2);
                        title3EEF0830.AddAlternateID(0, 0, 0x03FEEBFF, null, null, null);
                    }
                    {
                        TitleEditor title3EEF0831 = TitleEditor.CreateOrUseExistingId(0x3EEF0831);
                        title3EEF0831.ConsoleType = 0;
                        title3EEF0831.RemoveAllVersions();
                        title3EEF0831.AddVersion(1, 1, 1, 2);
                        title3EEF0831.AddAlternateID(0, 0, 0x03FEEBFE, null, null, null);
                        title3EEF0831.AddAlternateID(1, 0, 0x13FEEBFF, null, null, null);
                        title3EEF0831.AddAlternateID(0, 1, 0x13FEEBFE, null, null, null);
                        title3EEF0831.AddAlternateID(1, 1, 0x13FEEBFD, null, null, null);
                    }
                    {
                        TitleEditor title3EEF0832 = TitleEditor.CreateOrUseExistingId(0x3EEF0832);
                        title3EEF0832.ConsoleType = 0;
                        title3EEF0832.RemoveAllVersions();
                        title3EEF0832.AddVersion(1, 1, 1, 2);
                        title3EEF0832.AddAlternateID(0, 0, 0x3EEF0832, null, new uint[] { 3 }, new uint[] { 0x23feebff });
                        title3EEF0832.AddAlternateID(1, 0, 0x3EEF0832, null, new uint[] { 3 }, new uint[] { 0x23feebff });
                        title3EEF0832.AddAlternateID(1, 2, 0x3EEF0830, null, new uint[] { 3 }, new uint[] { 0x3EEF0831 });
                    }
                    {
                        TitleEditor title3EEF0833 = TitleEditor.CreateOrUseExistingId(0x3EEF0833);
                        title3EEF0833.ConsoleType = 0;
                        title3EEF0833.RemoveAllVersions();
                        title3EEF0833.AddVersion(0, 0, 0, 2);
                        title3EEF0833.AddAlternateID(1, 1, 0x33FEEBFF, null, new uint[] { 3 }, new uint[] { 0x3EEF0833 });
                    }
                    {
                        TitleEditor title3DEF0802 = TitleEditor.CreateOrUseExistingId(0x3DEF0802);
                        title3DEF0802.ConsoleType = 0;
                        title3DEF0802.RemoveAllVersions();
                        title3DEF0802.AddVersion(1, 1, 1, 2);
                        title3DEF0802.AddPrivilege(193);
                        title3DEF0802.AddOffer(0xFFC0FE00C0FE0001);
                    }
                    {
                        TitleEditor title3DEF0803 = TitleEditor.CreateOrUseExistingId(0x3DEF0803);
                        title3DEF0803.ConsoleType = 0;
                        title3DEF0803.RemoveAllVersions();
                        title3DEF0803.AddVersion(1, 1, 1, 2);
                        title3DEF0803.AddPrivilege(193, 6);
                    }
                    {
                        TitleEditor title3EEF0840 = TitleEditor.CreateOrUseExistingId(0x3EEF0840);
                        title3EEF0840.ConsoleType = 0;
                        title3EEF0840.RemoveAllVersions();
                        title3EEF0840.AddVersion(0, 0, 0, 2);
                        title3EEF0840.AddVersion(1, 1, 1, 2);
                        title3EEF0840.AddService(8012);
                        title3EEF0840.AddService(8013);
                    }
                    {
                        TitleEditor title3EEF0841 = TitleEditor.CreateOrUseExistingId(0x3EEF0841);
                        title3EEF0841.ConsoleType = 0;
                        title3EEF0841.RemoveAllVersions();
                        title3EEF0841.AddVersion(0, 0, 0, 2);
                        title3EEF0841.AddService(8002);
                    }
                    {
                        TitleEditor titleC0FE0900 = TitleEditor.CreateOrUseExistingId(0xC0FE0900);
                        titleC0FE0900.ConsoleType = 0;
                        titleC0FE0900.RemoveAllVersions();
                        titleC0FE0900.AddVersion(1, 1, 1, 4);
                        titleC0FE0900.AddOffer(0xC0FE09000FF00000);
                        titleC0FE0900.AddOffer(0xFFC0FE00C0FE0001);

                        //this is one of our original pc test titles... we want it to work like an older one, so mark it as a legacy title (no ssa)
                        string []legacyTitles=Global.XEnv.MultiSettingRead(xonline.common.config.MultiSetting.kdcsvc_xkdc_legacyPcTitles);
                        if (System.Array.Find(legacyTitles, delegate(string s){return s=="C0FE0900";})==null)
                        {
                            Global.XEnv.MultiSettingAddBase(xonline.common.config.MultiSetting.kdcsvc_xkdc_legacyPcTitles, "C0FE0900");
                        }
                    }
                    { // Requires activation
                        TitleEditor titleC0FE0901 = TitleEditor.CreateOrUseExistingId(0xC0FE0901);
                        titleC0FE0901.ConsoleType = 0;
                        titleC0FE0901.RemoveAllVersions();
                        titleC0FE0901.AddVersion(1, 1, 1, 4);
                        titleC0FE0901.SetTitleInfo(4, true);
                        titleC0FE0901.AddOffer(0xC0FE09010FF00000);
                    }
                    { // Requires activation, cross platform
                        TitleEditor titleC0FE0902 = TitleEditor.CreateOrUseExistingId(0xC0FE0902);
                        titleC0FE0902.ConsoleType = 0;
                        titleC0FE0902.RemoveAllVersions();
                        titleC0FE0902.AddVersion(1, 1, 1, 2);
                        titleC0FE0902.AddVersion(1, 1, 1, 4);
                        titleC0FE0902.SetTitleInfo(4, true);
                        titleC0FE0902.AddOffer(0xC0FE09020FF00000);
                    }
                    {
                        TitleEditor title3EEF0900 = TitleEditor.CreateOrUseExistingId(0x3EEF0900);
                        title3EEF0900.ConsoleType = 0;
                        title3EEF0900.RemoveAllVersions();
                        title3EEF0900.AddVersion(1, 1, 1, 4);
                    }
                    {
                        TitleEditor title7EEF0801 = TitleEditor.CreateOrUseExistingId(0x7EEF0801);
                        title7EEF0801.ConsoleType = 0;
                        title7EEF0801.RemoveAllVersions();
                        title7EEF0801.AddVersion(1, 3, 3, 4);
                        title7EEF0801.AddVersion(2, 3, 3, 4);
                        title7EEF0801.AddVersion(3, 3, 3, 4);
                    }
                    {
                        TitleEditor title3EEF0950 = TitleEditor.CreateOrUseExistingId(0x3EEF0950);
                        title3EEF0950.ConsoleType = 0;
                        title3EEF0950.RemoveAllVersions();
                        title3EEF0950.AddVersion(1, 1, 1, 4);
                        title3EEF0950.AddVersion(2, 10, 2, 4);
                        title3EEF0950.AddVersion(3, 3, 10, 4);
                        title3EEF0950.AddVersion(4, 10, 10, 4);
                    }

                    { //publisher bits match the system publisher bits, but title bits are different
                        TitleEditor titleFFFEEEEE = TitleEditor.CreateOrUseExistingId(0xFFFEEEEE);
                        titleFFFEEEEE.AddVersion(1, 1, 1, 2);
                    }

                    { //xna-like title
                        TitleEditor titleC0FE1005=TitleEditor.CreateOrUseExistingId(0xC0FE1005);
                        titleC0FE1005.RemoveAllVersions();
                        titleC0FE1005.AddVersion(0, 0, 0, 2);
                        titleC0FE1005.AddVersion(0, 0, 0, 4);
                        titleC0FE1005.AddOffer(0xFFC0FE00C0FE00A5);
                    }

                    { //game subscription title unique 0
                        TitleEditor titleC0FE1006=TitleEditor.CreateOrUseExistingId(0xC0FE1006);
                        titleC0FE1006.RemoveAllVersions();
                        titleC0FE1006.AddVersion(0, 0, 0, 2);
                        titleC0FE1006.AddOffer(0xFFC0FE00C0FE00A6);
                    }

                    { //game subscription title unique 1
                        TitleEditor titleC0FE1007=TitleEditor.CreateOrUseExistingId(0xC0FE1007);
                        titleC0FE1007.RemoveAllVersions();
                        titleC0FE1007.AddVersion(0, 0, 0, 2);
                        titleC0FE1007.AddOffer(0xFFC0FE00C0FE00A7);
                    }

                    { //game subscription title shared
                        TitleEditor titleC0FE1008=TitleEditor.CreateOrUseExistingId(0xC0FE1008);
                        titleC0FE1008.RemoveAllVersions();
                        titleC0FE1008.AddVersion(0, 0, 0, 2);
                        titleC0FE1008.AddOffer(0xFFC0FE00C0FE00A6);
                        titleC0FE1008.AddOffer(0xFFC0FE00C0FE00A7);
                    }

                    { //PC account creation title should always be propped - add a couple test versions
                        TitleEditor title585207D1 = TitleEditor.FromId(0x585207D1);
                        title585207D1.AddVersion(22, 23, 22, 4);
                        title585207D1.AddVersion(23, 23, 26, 4);
                        title585207D1.AddVersion(24, 23, 24, 4);
                        title585207D1.AddVersion(27, 28, 28, 2);
                        title585207D1.AddOffer(0xFFC0FE00C0FE0001);
                    }

                    { //xenon dash title should always be propped - add a couple test versions
                        TitleEditor titleFFFE07D1 = TitleEditor.FromId(0xFFFE07D1);
                        titleFFFE07D1.AddVersion(22, 23, 22, 2);
                        titleFFFE07D1.AddVersion(23, 23, 26, 2);
                        titleFFFE07D1.AddVersion(24, 23, 24, 2);
                        titleFFFE07D1.AddVersion(27, 28, 28, 2);
                        titleFFFE07D1.AddOffer(0xFFC0FE00C0FE0001);
                        titleFFFE07D1.AddOffer(0xFFC0FE00C0FE00A4);
                    }

                    { //xbox1 dash title should always be propped - add some test data
                        TitleEditor titleFFFE0000 = TitleEditor.FromId(0xFFFE0000);
                        titleFFFE0000.AddOffer(0xFFC0FE00C0FE0001);
                    }

                    { //?
                        TitleEditor titleFFFE0004 = TitleEditor.CreateOrUseExistingId(0xFFFE0004);
                        titleFFFE0004.AddVersion(1, 1, 1, 2);
                        titleFFFE0004.AddOffer(0xFFFE000400000000);
                    }
                } //unchecked
            }
        }

        [TestCase]
        public class Vouchers: TestNode
        {
            public override void Run()
            {
                //TODO: offer ids here will changed for the subscription family stuff in the future, but that catalog work hasn't been done yet so we're ok for now.
                {
                    VoucherEditor voucher00000=VoucherEditor.CreateOrUseExistingToken("22222-11111-11111-22222-00000", 0xFFC0FE00C0FE0006);
                    voucher00000.UseCount=-1;
                    voucher00000.Status=0;
                    voucher00000.ConsoleVersion=2;
                }
                {
                    VoucherEditor voucher00001=VoucherEditor.CreateOrUseExistingToken("22222-11111-11111-22222-00001", 0xFFC0FE00C0FE0006);
                    voucher00001.UseCount=-1;
                    voucher00001.Status=1;
                    voucher00001.ConsoleVersion=2;
                }
                {
                    VoucherEditor voucher00002=VoucherEditor.CreateOrUseExistingToken("22222-11111-11111-22222-00002", 0xFFC0FE00C0FE0006);
                    voucher00002.UseCount=-1;
                    voucher00002.Status=2;
                    voucher00002.ConsoleVersion=2;
                }
                {
                    VoucherEditor voucher00003=VoucherEditor.CreateOrUseExistingToken("22222-11111-11111-22222-00003", 0xFFC0FE00C0FE0006);
                    voucher00003.UseCount=5;
                    voucher00003.Status=0;
                    voucher00003.ConsoleVersion=2;
                }
                {
                    VoucherEditor voucher00004=VoucherEditor.CreateOrUseExistingToken("22222-11111-11111-22222-00004", 0xFFC0FE00C0FE0006);
                    voucher00004.UseCount=5;
                    voucher00004.Status=1;
                    voucher00004.ConsoleVersion=2;
                }
                {
                    VoucherEditor voucher00005=VoucherEditor.CreateOrUseExistingToken("22222-11111-11111-22222-00005", 0xFFC0FE00C0FE0006);
                    voucher00005.UseCount=5;
                    voucher00005.Status=2;
                    voucher00005.ConsoleVersion=2;
                }
                {
                    VoucherEditor voucher0NOPC=VoucherEditor.CreateOrUseExistingToken("22222-11111-11111-22222-0NOPC", 0xFFC0FE00C0FE0001);
                    voucher0NOPC.UseCount=-1;
                    voucher0NOPC.Status=0;
                    voucher0NOPC.ConsoleVersion=2;
                }
                {
                    VoucherEditor voucher000FF=VoucherEditor.CreateOrUseExistingToken("22222-11111-11111-22222-000FF", 0xFFC0FE00C0FE00FF);
                    voucher000FF.UseCount=-1;
                    voucher000FF.Status=0;
                    voucher000FF.ConsoleVersion=2;
                }
            }
        }

        [TestCase]
        public class Countries: TestNode
        {
            public override void Run()
            {
                { //Country 254 is for testing 32+ services
                    CountryEditor country=CountryEditor.CreateOrUseExistingId(254);
                    country.Name="TL0";
                    country.FriendlyName="New Testland";

                    //Service Type Mapping for this is added in Beyond32ServicesData
                }
                { //Country 253 is for testing curfews
                    CountryEditor country=CountryEditor.CreateOrUseExistingId(253);
                    country.Name="CL0";
                    country.FriendlyName="New Curfewland";

                    CountrySetEditor countrySet=CountrySetEditor.CreateOrUseExistingId(0xB8FD);
                    countrySet.RemoveAllCountries();
                    countrySet.AddCountry(253); //New Curfewland

                    ServiceTypeMappingEditor stmXenon=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB8FD); //for xbox360
                    stmXenon.Name="XkdcTest - New Curfewland - Xbox360";
                    stmXenon.ServiceType=1; //xbox live
                    stmXenon.ClientType=2; //xbox360
                    stmXenon.CountrySet=unchecked((short)countrySet.Id); //New Curfewland
                    stmXenon.PrivilegeSet=100; //default for live
                    stmXenon.ServiceSet=100; //default for live
                    stmXenon.SubscriptionType=100;
                    stmXenon.IsFreeTrial=0;

                    ServiceTypeMappingEditor stmPanorama=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB7FD); //for pc
                    stmPanorama.Name="XkdcTest - New Curfewland - PC";
                    stmPanorama.ServiceType=1; //xbox live
                    stmPanorama.ClientType=4; //pc
                    stmPanorama.CountrySet=unchecked((short)countrySet.Id); //New Curfewland
                    stmPanorama.PrivilegeSet=100; //default for live
                    stmPanorama.ServiceSet=100; //default for live
                    stmPanorama.SubscriptionType=100;
                    stmPanorama.IsFreeTrial=0;
                }
            }
        }

        [TestCase]
        public class FreeTrials: TestNode
        {
            public override void Run()
            {
                unchecked
                {
                    { //free trial of privilege 254 for country 16
                        CountrySetEditor cnt=CountrySetEditor.CreateOrUseExistingId(0xB042);
                        cnt.AddCountry(16);
                        PrivilegeSetEditor ps=PrivilegeSetEditor.CreateOrUseExistingId(0xB042);
                        ps.AddPrivilege(254);

                        ServiceTypeMappingEditor stmXe=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB042); //for xenon
                        stmXe.Name="KDC Free Trial Test";
                        stmXe.ServiceType=1;
                        stmXe.ClientType=2;
                        stmXe.CountrySet=(short)cnt.Id;
                        stmXe.PrivilegeSet=(short)ps.Id;
                        stmXe.StartDate=System.DateTime.UtcNow-new System.TimeSpan(1,0,0,0);
                        stmXe.EndDate=System.DateTime.UtcNow+new System.TimeSpan(365*5, 0, 0, 0);
                        stmXe.IsFreeTrial=1;

                        ServiceTypeMappingEditor stmXb=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB142); //for xbox1
                        stmXb.Name="KDC Free Trial Test";
                        stmXb.ServiceType=stmXe.ServiceType;
                        stmXb.ClientType=1;
                        stmXb.CountrySet=(short)cnt.Id;
                        stmXb.PrivilegeSet=(short)ps.Id;
                        stmXb.StartDate=stmXe.StartDate;
                        stmXb.EndDate=stmXe.EndDate;
                        stmXb.IsFreeTrial=1;
                    }
                    { //expired free trial of privilege 254 and service 8002 for country 24
                        CountrySetEditor cnt=CountrySetEditor.CreateOrUseExistingId(0xB043);
                        cnt.AddCountry(24);
                        PrivilegeSetEditor ps=PrivilegeSetEditor.CreateOrUseExistingId(0xB043);
                        ps.AddPrivilege(254);
                        ServiceSetEditor ss=ServiceSetEditor.CreateOrUseExistingId(0xB043);
                        ss.Name="XkdcTest B043";
                        ss.AddService(8002);

                        ServiceTypeMappingEditor stmXe=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB043); //for xenon
                        stmXe.Name="KDC Free Trial Test";
                        stmXe.ServiceType=1;
                        stmXe.ClientType=2;
                        stmXe.CountrySet=(short)cnt.Id;
                        stmXe.PrivilegeSet=(short)ps.Id;
                        stmXe.ServiceSet=(short)ss.Id;
                        stmXe.StartDate=System.DateTime.UtcNow-new System.TimeSpan(365,0,0,0);
                        stmXe.EndDate=System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0);
                        stmXe.IsFreeTrial=1;

                        ServiceTypeMappingEditor stmXb=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB143); //for xbox1
                        stmXb.Name="KDC Free Trial Test";
                        stmXb.ServiceType=stmXe.ServiceType;
                        stmXb.ClientType=1;
                        stmXb.CountrySet=(short)cnt.Id;
                        stmXb.PrivilegeSet=(short)ps.Id;
                        stmXb.ServiceSet=(short)ss.Id;
                        stmXb.StartDate=stmXe.StartDate;
                        stmXb.EndDate=stmXe.EndDate;
                        stmXb.IsFreeTrial=1;
                    }
                    { //free trial of privilege 253 and 254 and service 8002 for country 44
                        CountrySetEditor cnt=CountrySetEditor.CreateOrUseExistingId(0xB044);
                        cnt.AddCountry(44);
                        PrivilegeSetEditor ps=PrivilegeSetEditor.CreateOrUseExistingId(0xB044);
                        ps.AddPrivilege(253);
                        ps.AddPrivilege(254);
                        ServiceSetEditor ss=ServiceSetEditor.CreateOrUseExistingId(0xB044);
                        ss.Name="XkdcTest B044";
                        ss.AddService(8002);

                        ServiceTypeMappingEditor stmXe=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB044); //for xenon
                        stmXe.Name="KDC Free Trial Test";
                        stmXe.ServiceType=1;
                        stmXe.ClientType=2;
                        stmXe.CountrySet=(short)cnt.Id;
                        stmXe.PrivilegeSet=(short)ps.Id;
                        stmXe.ServiceSet=(short)ss.Id;
                        stmXe.StartDate=System.DateTime.UtcNow-new System.TimeSpan(1,0,0,0);
                        stmXe.EndDate=System.DateTime.UtcNow+new System.TimeSpan(365*5, 0, 0, 0);
                        stmXe.IsFreeTrial=1;

                        ServiceTypeMappingEditor stmXb=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB144); //for xbox1
                        stmXb.Name="KDC Free Trial Test";
                        stmXb.ServiceType=stmXe.ServiceType;
                        stmXb.ClientType=1;
                        stmXb.CountrySet=(short)cnt.Id;
                        stmXb.PrivilegeSet=(short)ps.Id;
                        stmXb.ServiceSet=(short)ss.Id;
                        stmXb.StartDate=stmXe.StartDate;
                        stmXb.EndDate=stmXe.EndDate;
                        stmXb.IsFreeTrial=1;
                    }
                    { //free trial of service 8002 for country 25
                        CountrySetEditor cnt=CountrySetEditor.CreateOrUseExistingId(0xB045);
                        cnt.AddCountry(25);
                        ServiceSetEditor ss=ServiceSetEditor.CreateOrUseExistingId(0xB045);
                        ss.Name="XkdcTest B045";
                        ss.AddService(8002);

                        ServiceTypeMappingEditor stmXe=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB045); //for xenon
                        stmXe.Name="KDC Free Trial Test";
                        stmXe.ServiceType=1;
                        stmXe.ClientType=2;
                        stmXe.CountrySet=(short)cnt.Id;
                        stmXe.ServiceSet=(short)ss.Id;
                        stmXe.StartDate=System.DateTime.UtcNow-new System.TimeSpan(1,0,0,0);
                        stmXe.EndDate=System.DateTime.UtcNow+new System.TimeSpan(365*5, 0, 0, 0);
                        stmXe.IsFreeTrial=1;

                        ServiceTypeMappingEditor stmXb=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB145); //for xbox1
                        stmXb.Name="KDC Free Trial Test";
                        stmXb.ServiceType=stmXe.ServiceType;
                        stmXb.ClientType=1;
                        stmXb.CountrySet=(short)cnt.Id;
                        stmXb.ServiceSet=(short)ss.Id;
                        stmXb.StartDate=stmXe.StartDate;
                        stmXb.EndDate=stmXe.EndDate;
                        stmXb.IsFreeTrial=1;
                    }
                    { //free trial of privilege 254 and services 1,6,8 for country 46
                        CountrySetEditor cnt=CountrySetEditor.CreateOrUseExistingId(0xB046);
                        cnt.AddCountry(46);
                        PrivilegeSetEditor ps=PrivilegeSetEditor.CreateOrUseExistingId(0xB046);
                        ps.AddPrivilege(254);
                        ServiceSetEditor ss=ServiceSetEditor.CreateOrUseExistingId(0xB046);
                        ss.Name="XkdcTest B046";
                        ss.RemoveAllServices();
                        ss.AddService(1);
                        ss.AddService(6);
                        ss.AddService(8);

                        ServiceTypeMappingEditor stmXe=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB046); //for xenon
                        stmXe.Name="KDC Free Trial Test";
                        stmXe.ServiceType=1;
                        stmXe.ClientType=2;
                        stmXe.CountrySet=(short)cnt.Id;
                        stmXe.PrivilegeSet=(short)ps.Id;
                        stmXe.ServiceSet=(short)ss.Id;
                        stmXe.StartDate=System.DateTime.UtcNow-new System.TimeSpan(1,0,0,0);
                        stmXe.EndDate=System.DateTime.UtcNow+new System.TimeSpan(365*5, 0, 0, 0);
                        stmXe.IsFreeTrial=1;

                        ServiceTypeMappingEditor stmXb=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB146); //for xbox1
                        stmXb.Name="KDC Free Trial Test";
                        stmXb.ServiceType=stmXe.ServiceType;
                        stmXb.ClientType=1;
                        stmXb.CountrySet=(short)cnt.Id;
                        stmXb.PrivilegeSet=(short)ps.Id;
                        stmXb.ServiceSet=(short)ss.Id;
                        stmXb.StartDate=stmXe.StartDate;
                        stmXb.EndDate=stmXe.EndDate;
                        stmXb.IsFreeTrial=1;
                    }
                    { //free trial of services 1 and 8002 for country 91, xbox1 only
                        CountrySetEditor cnt=CountrySetEditor.CreateOrUseExistingId(0xB091);
                        cnt.AddCountry(91);
                        ServiceSetEditor ss=ServiceSetEditor.CreateOrUseExistingId(0xB091);
                        ss.Name="XkdcTest B091";
                        ss.AddService(1);
                        ss.AddService(8002);

                        ServiceTypeMappingEditor stmXb=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB091); //for xbox1
                        stmXb.Name="KDC Free Trial Test";
                        stmXb.ServiceType=1;
                        stmXb.ClientType=1;
                        stmXb.CountrySet=(short)cnt.Id;
                        stmXb.ServiceSet=(short)ss.Id;
                        stmXb.StartDate=System.DateTime.UtcNow-new System.TimeSpan(1,0,0,0);
                        stmXb.EndDate=System.DateTime.UtcNow+new System.TimeSpan(365*5, 0, 0, 0);
                        stmXb.IsFreeTrial=1;
                    }
                }
            }
        }

        [TestCase]
        public class Cultures: TestNode
        {
            public override void Run()
            {
                {
                    CultureEditor testerians=CultureEditor.CreateOrUseExistingId(-1032);
                    testerians.Name="Liveless Testerians";
                    testerians.IsLiveSupported=0;
                    testerians.IsXboxComSupported=0;
                    testerians.LiveLanguageId=0;
                    testerians.LiveCultureId=0;
                }

                {
                    CultureEditor testerians=CultureEditor.CreateOrUseExistingId(-254);
                    testerians.Name="New Testland";
                    testerians.IsLiveSupported=1;
                    testerians.IsXboxComSupported=1;
                    testerians.LiveLanguageId=1;
                    testerians.LanguageId=1;
                    testerians.CountryId=254;
                    testerians.LiveCultureId=-254;
                }

                {
                    CultureEditor testerians=CultureEditor.CreateOrUseExistingId(-253);
                    testerians.Name="New Curfewland";
                    testerians.IsLiveSupported=1;
                    testerians.IsXboxComSupported=1;
                    testerians.LiveLanguageId=1;
                    testerians.LanguageId=1;
                    testerians.CountryId=253;
                    testerians.LiveCultureId=-253;
                }
            }
        }

        [TestCase]
        public class Users: TestNode
        {
            public override void Run()
            {
                unchecked
                {
                    {
                        UserEditor user7a = UserEditor.CreateOrUseExistingGamerTag("xktuser7a", UserCreationType.Xbox1);
                        user7a.SetUserTitleTrustRating(0xFFC0FE00, 0, 1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF00, 1, 1, 5, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF01, -1, 1, 1, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF02, 10, 1, 5, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF03, 100, 1, 50, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF04, 1000, 4294967295, 500, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF05, 10000, 1000000000, 50000, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF06, 1.5f, 1.01f, 0.1f, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF07, 1.01f, 1.5f, 0.01f, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF08, 1000000000, 10000, -1, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF09, 4294967295, 1000, 4294967295, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF0A, 1, 100, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF0B, 1, 10, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF0C, 1, -1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF0D, 1, 1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xFFBEEF0E, 0, 1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0xC0FE0800, 0, 1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0800, 1, 1, 5, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0801, -1, 1, 1, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0802, 10, 1, 5, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0803, 100, 1, 50, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0804, 1000, 4294967295, 500, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0805, 10000, 1000000000, 50000, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0806, 1.5f, 1.01f, 0.1f, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0807, 1.01f, 1.5f, 0.01f, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0808, 1000000000, 10000, -1, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF0809, 4294967295, 1000, 4294967295, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF080A, 1, 100, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF080B, 1, 10, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF080C, 1, -1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF080D, 1, 1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                        user7a.SetUserTitleTrustRating(0x3EEF080E, 0, 1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 0, 1, 1, 1, 10, 1);
                    }
                    {
                        UserEditor InvalidWLIDUser = UserEditor.CreateOrUseExistingGamerTag("xktuserInvWLID");
                        InvalidWLIDUser.UserWLIDInvalid = 1;

                        InvalidWLIDUser = UserEditor.CreateOrUseExistingGamerTag("xktuserValWLID");

                        InvalidWLIDUser = UserEditor.CreateOrUseExistingGamerTag("xktownerInvWLID");
                        InvalidWLIDUser.OwnerWLIDInvalid = 1;

                        UserEditor userInvalidWLID = UserEditor.CreateOrUseExistingGamerTag("xktownerValWLID");

                        InvalidWLIDUser = UserEditor.CreateOrUseExistingGamerTag("xktoAnduInvWLID");
                        InvalidWLIDUser.OwnerWLIDInvalid = 1;
                        InvalidWLIDUser.UserWLIDInvalid = 1;
                    }
                    {
                        UserEditor user7b = UserEditor.CreateOrUseExistingGamerTag("xktuser7b", UserCreationType.Xbox1);
                        user7b.SetUserTitleTrustRating(0xFFBEEF00, 10, 5, 0, 2, 5, 1, 4, 5, 6, 200, 1, 1, 1, 2, 2, 60, 5);
                        user7b.SetUserTitleTrustRating(0x3EEF0800, 10, 5, 0, 2, 5, 1, 4, 5, 6, 200, 1, 1, 1, 2, 2, 60, 5);
                    }
                    {
                        UserEditor user7c = UserEditor.CreateOrUseExistingGamerTag("xktuser7c", UserCreationType.Xbox1);
                        user7c.SetUserTitleTrustRating(0xFFBEEF00, 100, 10, 1, 50, 52, 13, 10, 20, 15, 300, 119, 2, 0, 3, 3, 300, 10);
                        user7c.SetUserTitleTrustRating(0x3EEF0800, 100, 10, 1, 50, 52, 13, 10, 20, 15, 300, 119, 2, 0, 3, 3, 300, 10);
                    }
                    {
                        UserEditor user7d = UserEditor.CreateOrUseExistingGamerTag("xktuser7d", UserCreationType.Xbox1);
                        user7d.SetUserTitleTrustRating(0xFFBEEF00, 1000, 20, 1000, 565, 4, 342, 119, 85, 22, 400, 340, 10, 3, 4, 4, 900, 20);
                        user7d.SetUserTitleTrustRating(0x3EEF0800, 1000, 20, 1000, 565, 4, 342, 119, 85, 22, 400, 340, 10, 3, 4, 4, 900, 20);
                    }
                    {
                        UserEditor space = UserEditor.CreateOrUseExistingGamerTag("xkt space", UserCreationType.Xbox1);
                    }
                    {
                        UserEditor cntry53 = UserEditor.CreateOrUseExistingGamerTag("xktcntry53", UserCreationType.Xbox1);
                        cntry53.CountryId = 53;
                        cntry53.LanguageId = 2;
                        cntry53.CultureId = 1041;
                    }
                    {
                        UserEditor cntry76 = UserEditor.CreateOrUseExistingGamerTag("xktcntry76", UserCreationType.Xbox1);
                        cntry76.CountryId = 76;
                    }
                    {
                        UserEditor cntry44 = UserEditor.CreateOrUseExistingGamerTag("xktcntry44", UserCreationType.Xbox1);
                        cntry44.CountryId = 44;
                    }
                    {
                        UserEditor flag1 = UserEditor.CreateOrUseExistingGamerTag("xkttflag1", UserCreationType.Xbox1);
                        flag1.ExtraTicketFlags = 1;
                    }
                    {
                        UserEditor flag2 = UserEditor.CreateOrUseExistingGamerTag("xkttflag2", UserCreationType.Xbox1);
                        flag2.ExtraTicketFlags = 2;
                    }
                    {
                        UserEditor flag3 = UserEditor.CreateOrUseExistingGamerTag("xkttflag3", UserCreationType.Xbox1);
                        flag3.ExtraTicketFlags = 3;
                    }
                    {
                        UserEditor flag4 = UserEditor.CreateOrUseExistingGamerTag("xkttflag4", UserCreationType.Xbox1);
                        flag4.ExtraTicketFlags = 4;
                    }
                    {
                        UserEditor flag5 = UserEditor.CreateOrUseExistingGamerTag("xkttflag5", UserCreationType.Xbox1);
                        flag5.ExtraTicketFlags = 5;
                    }
                    {
                        UserEditor flag6 = UserEditor.CreateOrUseExistingGamerTag("xkttflag6", UserCreationType.Xbox1);
                        flag6.ExtraTicketFlags = 6;
                    }
                    {
                        UserEditor flag7 = UserEditor.CreateOrUseExistingGamerTag("xkttflag7", UserCreationType.Xbox1);
                        flag7.ExtraTicketFlags = 7;
                    }
                    {
                        UserEditor flag8 = UserEditor.CreateOrUseExistingGamerTag("xkttflag8", UserCreationType.Xbox1);
                        flag8.ExtraTicketFlags = 8;
                    }
                    {
                        UserEditor flag9 = UserEditor.CreateOrUseExistingGamerTag("xkttflag9", UserCreationType.Xbox1);
                        flag9.ExtraTicketFlags = 9;
                    }
                    {
                        UserEditor flag65295 = UserEditor.CreateOrUseExistingGamerTag("xkttflag65295", UserCreationType.Xbox1);
                        flag65295.ExtraTicketFlags = -241;
                    }
                    {
                        UserEditor actrsmnow = UserEditor.CreateOrUseExistingGamerTag("xktactrsmnow", UserCreationType.Xbox1);
                        actrsmnow.BannedUntilDate = System.DateTime.UtcNow;
                    }
                    {
                        UserEditor actrsmtmrw = UserEditor.CreateOrUseExistingGamerTag("xktactrsmtmrw", UserCreationType.Xbox1);
                        actrsmtmrw.BannedUntilDate = System.DateTime.UtcNow + new System.TimeSpan(1, 0, 0, 0);
                    }
                    {
                        UserEditor actrsmyest = UserEditor.CreateOrUseExistingGamerTag("xktactrsmyest", UserCreationType.Xbox1);
                        actrsmyest.BannedUntilDate = System.DateTime.UtcNow - new System.TimeSpan(1, 0, 0, 0);
                    }
                    {
                        UserEditor actrsmfvr = UserEditor.CreateOrUseExistingGamerTag("xktactrsmfvr", UserCreationType.Xbox1);
                        actrsmfvr.BannedUntilDate = new System.DateTime(9999, 12, 30);
                    }
                    {
                        UserEditor vocrsmnow = UserEditor.CreateOrUseExistingGamerTag("xktvocrsmnow", UserCreationType.Xbox1);
                        vocrsmnow.VoiceBannedUntilDate = System.DateTime.UtcNow;
                    }
                    {
                        UserEditor vocrsmtmrw = UserEditor.CreateOrUseExistingGamerTag("xktvocrsmtmrw", UserCreationType.Xbox1);
                        vocrsmtmrw.VoiceBannedUntilDate = System.DateTime.UtcNow + new System.TimeSpan(1, 0, 0, 0);
                    }
                    {
                        UserEditor vocrsmyest = UserEditor.CreateOrUseExistingGamerTag("xktvocrsmyest", UserCreationType.Xbox1);
                        vocrsmyest.VoiceBannedUntilDate = System.DateTime.UtcNow - new System.TimeSpan(1, 0, 0, 0);
                    }
                    {
                        UserEditor vocrsmfvr = UserEditor.CreateOrUseExistingGamerTag("xktvocrsmfvr", UserCreationType.Xbox1);
                        vocrsmfvr.VoiceBannedUntilDate = new System.DateTime(9999, 12, 30);
                    }
                    {
                        UserEditor namechng = UserEditor.CreateOrUseExistingGamerTag("xktnamechng", UserCreationType.Xbox1);
                        namechng.NameChangeRequired = 1;
                    }
                    {
                        UserEditor tosbefore = UserEditor.CreateOrUseExistingGamerTag("xkttosbefore", UserCreationType.Xbox1);
                        tosbefore.AcceptedTOSDate = new System.DateTime(2001, 11, 14, 23, 59, 59);
                    }
                    {
                        UserEditor tosexact = UserEditor.CreateOrUseExistingGamerTag("xkttosexact", UserCreationType.Xbox1);
                        tosexact.AcceptedTOSDate = new System.DateTime(2001, 11, 15, 0, 0, 0);
                    }
                    {
                        UserEditor tosafter = UserEditor.CreateOrUseExistingGamerTag("xkttosafter", UserCreationType.Xbox1);
                        tosafter.AcceptedTOSDate = new System.DateTime(2001, 11, 15, 0, 0, 1);
                    }
                    {
                        UserEditor tosafter = UserEditor.CreateOrUseExistingGamerTag("xkttoswayafter", UserCreationType.Xbox1);
                        tosafter.AcceptedTOSDate = new System.DateTime(2010, 6, 6, 0, 0, 0);
                    }
                    {
                        UserEditor bilstatfail = UserEditor.CreateOrUseExistingGamerTag("xktbilstatfail", UserCreationType.Xbox1);
                        bilstatfail.BillingAccountStatus = -2147467259;
                    }
                    {
                        UserEditor sub1 = UserEditor.CreateOrUseExistingGamerTag("xktsub1", UserCreationType.Xbox1);
                        sub1.RemoveAllSubscriptions(false);
                        sub1.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000001"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000001"), 0xFFC0FE00C0FE0001);
                        sub1.SetUserTitleTrustRating(0xFFBEEF00, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF01, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF02, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF03, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF04, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF05, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF06, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF07, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF08, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF09, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF0A, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF0B, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF0C, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF0D, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF0E, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0xFFBEEF0F, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0800, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0801, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0802, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0803, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0804, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0805, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0806, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0807, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0808, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF0809, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF080A, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF080B, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF080C, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF080D, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF080E, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                        sub1.SetUserTitleTrustRating(0x3EEF080F, 1, 1, 0, 1, 1, 2, 1, 2, 3, 10, 0, 1, 1, 1, 1, 10, 1);
                    }
                    {
                        UserEditor sub2 = UserEditor.CreateOrUseExistingGamerTag("xktsub2", UserCreationType.Xbox1);
                        sub2.RemoveAllSubscriptions(false);
                        sub2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000002"), 0xFFC0FE00C0FE0002);
                        sub2.SetUserTitleTrustRating(0x3EEF0800, 1, 1, 0, 1, 1, 2, 1, 2, 3, 100, 0, 100, 0, 0, 1, 10, 1);
                        sub2.SetUserTitleTrustRating(0xFFBEEF00, 1, 1, 0, 1, 1, 2, 1, 2, 3, 100, 0, 100, 0, 0, 1, 10, 1);
                    }
                    {
                        UserEditor sub3 = UserEditor.CreateOrUseExistingGamerTag("xktsub3", UserCreationType.Xbox1);
                        sub3.RemoveAllSubscriptions(false);
                        sub3.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000003"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000003"), 0xFFC0FE00C0FE0003);
                        sub3.SetUserTitleTrustRating(0xFFBEEF00, 1, 1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 100, 10, 10, 1, 10, 1);
                        sub3.SetUserTitleTrustRating(0x3EEF0800, 1, 1, 0, 1, 1, 2, 1, 2, 3, 100, 10, 100, 10, 10, 1, 10, 1);
                    }
                    {
                        UserEditor sub4 = UserEditor.CreateOrUseExistingGamerTag("xktsub4", UserCreationType.Xbox1);
                        sub4.RemoveAllSubscriptions(false);
                        sub4.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000004"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000004"), 0xFFC0FE00C0FE0004);
                        sub4.SetUserTitleTrustRating(0x3EEF0800, 1, 1, 0, 1, 1, 2, 1, 2, 3, 100, 100, 100, 100, 100, 1, 10, 1);
                        sub4.SetUserTitleTrustRating(0xFFBEEF00, 1, 1, 0, 1, 1, 2, 1, 2, 3, 100, 100, 100, 100, 100, 1, 10, 1);
                    }
                    {
                        UserEditor sub5 = UserEditor.CreateOrUseExistingGamerTag("xktsub5", UserCreationType.Xbox1);
                        sub5.RemoveAllSubscriptions(false);
                        sub5.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000005"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000005"), 0xFFC0FE00C0FE0005);
                    }
                    {
                        UserEditor suball = UserEditor.CreateOrUseExistingGamerTag("xktsuball", UserCreationType.Xbox1);
                        suball.RemoveAllSubscriptions(false);
                        suball.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000004"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000004"), 0xFFC0FE00C0FE0004);
                        suball.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000005"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000005"), 0xFFC0FE00C0FE0005);
                    }
                    {
                        UserEditor sub1nobase = UserEditor.CreateOrUseExistingGamerTag("xktsub1nobase", UserCreationType.Xbox1);
                        sub1nobase.RemoveAllSubscriptions(true);
                        sub1nobase.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000001"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000001"), 0xFFC0FE00C0FE0001);
                    }
                    {
                        UserEditor xktsubx2 = UserEditor.CreateOrUseExistingGamerTag("xktsubx2", UserCreationType.Xbox1);
                        xktsubx2.RemoveAllSubscriptions(false);
                        xktsubx2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000001"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000001"), 0xFFC0FE00C0FE0001, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 0, 1, null);
                    }
                    {
                        UserEditor sub123 = UserEditor.CreateOrUseExistingGamerTag("xktsub123", UserCreationType.Xbox1);
                        sub123.RemoveAllSubscriptions(false);
                        sub123.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000001"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000001"), 0xFFC0FE00C0FE0001);
                        sub123.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000002"), 0xFFC0FE00C0FE0002);
                        sub123.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000003"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000003"), 0xFFC0FE00C0FE0003);
                    }
                    {
                        UserEditor sub23 = UserEditor.CreateOrUseExistingGamerTag("xktsub23", UserCreationType.Xbox1);
                        sub23.RemoveAllSubscriptions(false);
                        sub23.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000002"), 0xFFC0FE00C0FE0002);
                        sub23.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000003"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000003"), 0xFFC0FE00C0FE0003);
                    }
                    {
                        UserEditor subx23 = UserEditor.CreateOrUseExistingGamerTag("xktsubx23", UserCreationType.Xbox1);
                        subx23.RemoveAllSubscriptions(false);
                        subx23.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000002"), 0xFFC0FE00C0FE0002, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 0, 1, null);
                        subx23.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000003"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000003"), 0xFFC0FE00C0FE0003);
                    }
                    {
                        UserEditor subx2x3 = UserEditor.CreateOrUseExistingGamerTag("xktsubx2x3", UserCreationType.Xbox1);
                        subx2x3.RemoveAllSubscriptions(false);
                        subx2x3.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000002"), 0xFFC0FE00C0FE0002, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 0, 1, null);
                        subx2x3.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000003"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000003"), 0xFFC0FE00C0FE0003, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 0, 1, null);
                    }
                    {
                        UserEditor usert1a = UserEditor.CreateOrUseExistingGamerTag("xktusert1a");
                        usert1a.RemoveAllSubscriptions(true);
                        usert1a.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor usert1b = UserEditor.CreateOrUseExistingGamerTag("xktusert1b");
                        usert1b.AddPrivilegeRestrictions(new byte[] { 254, 255 });
                        usert1b.RemoveAllSubscriptions(true);
                        usert1b.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor usert1c = UserEditor.CreateOrUseExistingGamerTag("xktusert1c");
                        usert1c.AddPrivilegeGrants(new byte[] { 251, 253 });
                        usert1c.RemoveAllSubscriptions(true);
                        usert1c.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor usert1d = UserEditor.CreateOrUseExistingGamerTag("xktusert1d");
                        usert1d.AddPrivilegeRestrictions(new byte[] { 254, 255 });
                        usert1d.AddPrivilegeGrants(new byte[] { 251, 253 });
                        usert1d.RemoveAllSubscriptions(true);
                        usert1d.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    { //restricted from all privileges
                        UserEditor usert1e = UserEditor.CreateOrUseExistingGamerTag("xktusert1e");
                        usert1e.AddPrivilegeRestrictions(System.Array.ConvertAll(Expectations.k_DefaultAllPrivileges, new System.Converter<uint, byte>(System.Convert.ToByte)));
                        usert1e.RemoveAllSubscriptions(true);
                        usert1e.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor usert1f = UserEditor.CreateOrUseExistingGamerTag("xktusert1f");
                        usert1f.AddPrivilegeGrants(new byte[] { 192, 193, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 });
                        usert1f.RemoveAllSubscriptions(true);
                        usert1f.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor usert2a = UserEditor.CreateOrUseExistingGamerTag("xktusert2a");
                    }
                    {
                        UserEditor usert2b = UserEditor.CreateOrUseExistingGamerTag("xktusert2b");
                        usert2b.AddPrivilegeRestrictions(new byte[] { 254, 255 });
                    }
                    {
                        UserEditor usert2c = UserEditor.CreateOrUseExistingGamerTag("xktusert2c");
                        usert2c.AddPrivilegeGrants(new byte[] { 251, 253 });
                    }
                    {
                        UserEditor usert2d = UserEditor.CreateOrUseExistingGamerTag("xktusert2d");
                        usert2d.AddPrivilegeRestrictions(new byte[] { 254, 255 });
                        usert2d.AddPrivilegeGrants(new byte[] { 251, 253 });
                    }
                    { //restricted from all privileges
                        UserEditor usert2e = UserEditor.CreateOrUseExistingGamerTag("xktusert2e");
                        usert2e.AddPrivilegeRestrictions(System.Array.ConvertAll(Expectations.k_DefaultAllPrivileges, new System.Converter<uint, byte>(System.Convert.ToByte)));
                    }
                    {
                        UserEditor usert2f = UserEditor.CreateOrUseExistingGamerTag("xktusert2f");
                        usert2f.AddPrivilegeGrants(new byte[] { 192, 193, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 });
                    }
                    { //restricted from all privileges
                        UserEditor restrictedt2 = UserEditor.CreateOrUseExistingGamerTag("xktrestrictedt2", UserCreationType.Xbox1);
                        restrictedt2.AddPrivilegeRestrictions(System.Array.ConvertAll(Expectations.k_DefaultAllPrivileges, new System.Converter<uint, byte>(System.Convert.ToByte)));
                        restrictedt2.RemoveAllSubscriptions(true);
                        restrictedt2.AddBaseSubscription(BaseSubscriptions.Xbox360Gold);
                        restrictedt2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000001"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000001"), 0xFFC0FE00C0FE0001);
                    }
                    {
                        UserEditor grantedt2 = UserEditor.CreateOrUseExistingGamerTag("xktgrantedt2", UserCreationType.Xbox1);
                        grantedt2.AddPrivilegeGrants(new byte[] { 193 });
                        grantedt2.RemoveAllSubscriptions(false);
                        grantedt2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000001"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000001"), 0xFFC0FE00C0FE0001);
                    }
                    {
                        UserEditor xeusert1a = UserEditor.CreateOrUseExistingGamerTag("xktxeusert1a");
                        xeusert1a.RemoveAllSubscriptions(true);
                        xeusert1a.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor duusert1a = UserEditor.CreateOrUseExistingGamerTag("xktduusert1a");
                        duusert1a.RemoveAllSubscriptions(true);
                        duusert1a.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor xbusert2a = UserEditor.CreateOrUseExistingGamerTag("xktxbusert2a", UserCreationType.Xbox1);
                        xbusert2a.RemoveAllSubscriptions(true);
                        xbusert2a.AddBaseSubscription(BaseSubscriptions.Xbox360Gold);
                        xbusert2a.RemoveXenonKey();
                    }
                    {
                        UserEditor xeusert2a = UserEditor.CreateOrUseExistingGamerTag("xktxeusert2a");
                    }
                    {
                        UserEditor duusert2a = UserEditor.CreateOrUseExistingGamerTag("xktduusert2a");
                    }
                    {
                        UserEditor dudifft2a = UserEditor.CreateOrUseExistingGamerTag("xktdudifft2a");
                    }
                    {
                        UserEditor xeusert2ar = UserEditor.CreateOrUseExistingGamerTag("xktxeusert2ar");
                        xeusert2ar.AllowXbox1Login = 0;
                    }
                    {
                        UserEditor duusert2ar = UserEditor.CreateOrUseExistingGamerTag("xktduusert2ar");
                        duusert2ar.AllowXbox1Login = 0;
                    }
                    {
                        UserEditor dulsput2a = UserEditor.CreateOrUseExistingGamerTag("xktdulsput2a");
                        dulsput2a.RemoveAllSubscriptions(false);
                        dulsput2a.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000002"), 0xFFC0FE00C0FE0002);
                    }
                    {
                        UserEditor xbchilt2a = UserEditor.CreateOrUseExistingGamerTag("xktxbchilt2a", UserCreationType.Xbox1);
                        xbchilt2a.UserPassportPuid = 111;
                        xbchilt2a.OwnerPassportPuid = 222;
                        xbchilt2a.RemoveAllSubscriptions(true);
                        xbchilt2a.AddBaseSubscription(BaseSubscriptions.Xbox360Gold);
                        xbchilt2a.RemoveXenonKey();
                    }
                    {
                        UserEditor duchilt2a = UserEditor.CreateOrUseExistingGamerTag("xktduchilt2a");
                        duchilt2a.UserPassportPuid = 2222;
                        duchilt2a.OwnerPassportPuid = 333;
                    }
                    {
                        UserEditor cntry16t1 = UserEditor.CreateOrUseExistingGamerTag("xktcntry16t1");
                        cntry16t1.CountryId = 16;
                        cntry16t1.RemoveAllSubscriptions(true);
                        cntry16t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor cntry24t1 = UserEditor.CreateOrUseExistingGamerTag("xktcntry24t1");
                        cntry24t1.CountryId = 24;
                        cntry24t1.LanguageId = 2;
                        cntry24t1.CultureId = -1032;
                        cntry24t1.RemoveAllSubscriptions(true);
                        cntry24t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor cntry44t1 = UserEditor.CreateOrUseExistingGamerTag("xktcntry44t1");
                        cntry44t1.CountryId = 44;
                        cntry44t1.LanguageId = 3;
                        cntry44t1.CultureId = -1032;
                        cntry44t1.RemoveAllSubscriptions(true);
                        cntry44t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor cntry25t1 = UserEditor.CreateOrUseExistingGamerTag("xktcntry25t1");
                        cntry25t1.CountryId = 25;
                        cntry25t1.LanguageId = 4;
                        cntry25t1.CultureId = -1032;
                        cntry25t1.RemoveAllSubscriptions(true);
                        cntry25t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor cntry75t1 = UserEditor.CreateOrUseExistingGamerTag("xktcntry75t1");
                        cntry75t1.CountryId = 75;
                        cntry75t1.LanguageId = 1;
                        cntry75t1.CultureId = 1044;
                        cntry75t1.RemoveAllSubscriptions(true);
                        cntry75t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor cntry46 = UserEditor.CreateOrUseExistingGamerTag("xktcntry46", UserCreationType.Xbox1);
                        cntry46.CountryId = 46;
                        cntry46.LanguageId = 5;
                    }
                    {
                        UserEditor cntry46t1 = UserEditor.CreateOrUseExistingGamerTag("xktcntry46t1");
                        cntry46t1.CountryId = 46;
                        cntry46t1.LanguageId = 5;
                        cntry46t1.RemoveAllSubscriptions(true);
                        cntry46t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor cntry46t1r = UserEditor.CreateOrUseExistingGamerTag("xktcntry46t1r");
                        cntry46t1r.CountryId = 46;
                        cntry46t1r.LanguageId = 5;
                        cntry46t1r.AllowXbox1Login = 0;
                        cntry46t1r.RemoveAllSubscriptions(true);
                        cntry46t1r.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor cntry46t2 = UserEditor.CreateOrUseExistingGamerTag("xktcntry46t2");
                        cntry46t2.CountryId = 46;
                        cntry46t2.LanguageId = 5;
                    }
                    {
                        UserEditor dupcg1t2a = UserEditor.CreateOrUseExistingGamerTag("xktdupcg1t2a");
                        dupcg1t2a.AllowXbox1Login = 0;
                        dupcg1t2a.ParentalControlGroup = 1;
                    }
                    {
                        UserEditor dupcg1t2ar = UserEditor.CreateOrUseExistingGamerTag("xktdupcg1t2ar");
                        dupcg1t2ar.AllowXbox1Login = 0;
                        dupcg1t2ar.ParentalControlGroup = 1;
                    }
                    {
                        UserEditor dupcg1t2d = UserEditor.CreateOrUseExistingGamerTag("xktdupcg1t2d");
                        dupcg1t2d.AllowXbox1Login = 0;
                        dupcg1t2d.ParentalControlGroup = 1;
                        dupcg1t2d.AddPrivilegeRestrictions(new byte[] { 254, 255 });
                        dupcg1t2d.AddPrivilegeGrants(new byte[] { 251, 253 });
                    }
                    {
                        UserEditor xbcntry91 = UserEditor.CreateOrUseExistingGamerTag("xktxbcntry91", UserCreationType.Xbox1);
                        xbcntry91.CountryId = 91;
                    }
                    {
                        UserEditor xbcntry91exp = UserEditor.CreateOrUseExistingGamerTag("xktxbcntry91exp", UserCreationType.Xbox1);
                        xbcntry91exp.CountryId = 91;
                        xbcntry91exp.RemoveAllSubscriptions(true);
                        xbcntry91exp.AddBaseSubscription(BaseSubscriptions.Xbox1Online, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 3, 1, null); //expired xbox1 subscription
                    }
                    {
                        UserEditor xecntry91t1 = UserEditor.CreateOrUseExistingGamerTag("xktxecntry91t1");
                        xecntry91t1.CountryId = 91;
                        xecntry91t1.RemoveAllSubscriptions(true);
                        xecntry91t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor xesubexpt2 = UserEditor.CreateOrUseExistingGamerTag("xktxesubexpt2");
                        xesubexpt2.RemoveAllSubscriptions(true);
                        xesubexpt2.AddBaseSubscription(BaseSubscriptions.Xbox360Gold, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 3, 1, null);
                    }
                    {
                        UserEditor xesubexpt1 = UserEditor.CreateOrUseExistingGamerTag("xktxesubexpt1");
                        xesubexpt1.RemoveAllSubscriptions(true);
                        xesubexpt1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 3, 1, null);
                    }
                    {
                        UserEditor xesubmixt1 = UserEditor.CreateOrUseExistingGamerTag("xktxesubmixt1");
                        xesubmixt1.RemoveAllSubscriptions(true);
                        xesubmixt1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                    }
                    {
                        UserEditor xesublspt2 = UserEditor.CreateOrUseExistingGamerTag("xktxesublspt2");
                        xesublspt2.RemoveAllSubscriptions(false);
                        xesublspt2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000002"), 0xFFC0FE00C0FE0002, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 3, 1, null);
                    }
                    {
                        UserEditor xesub48ht1 = UserEditor.CreateOrUseExistingGamerTag("xktxesub48ht1");
                        xesub48ht1.RemoveAllSubscriptions(true);
                        xesub48ht1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                        xesub48ht1.AddSubscription(0xFFFE07D10990000A);
                    }
                    {
                        UserEditor xesub48et1 = UserEditor.CreateOrUseExistingGamerTag("xktxesub48et1");
                        xesub48et1.RemoveAllSubscriptions(true);
                        xesub48et1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                        xesub48et1.AddSubscription(0xFFFE07D10990000A, 1, "xkdctest", System.DateTime.UtcNow - new System.TimeSpan(1, 0, 0, 0), System.DateTime.UtcNow, 1, 1);
                    }
                    {
                        UserEditor xesub48h46t1 = UserEditor.CreateOrUseExistingGamerTag("xktxesub48h46t1");
                        xesub48h46t1.CountryId = 46;
                        xesub48h46t1.RemoveAllSubscriptions(true);
                        xesub48h46t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                        xesub48h46t1.AddSubscription(0xFFFE07D10990000A);
                    }
                    {
                        UserEditor xesub48e46t1 = UserEditor.CreateOrUseExistingGamerTag("xktxesub48e46t1");
                        xesub48e46t1.CountryId = 46;
                        xesub48e46t1.RemoveAllSubscriptions(true);
                        xesub48e46t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                        xesub48e46t1.AddSubscription(0xFFFE07D10990000A, 1, "xkdctest", System.DateTime.UtcNow - new System.TimeSpan(1, 0, 0, 0), System.DateTime.UtcNow, 1, 1);
                    }
                    {
                        UserEditor xesublsp44t1 = UserEditor.CreateOrUseExistingGamerTag("xktxesublsp44t1");
                        xesublsp44t1.CountryId = 44;
                        xesublsp44t1.RemoveAllSubscriptions(true);
                        xesublsp44t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                        xesublsp44t1.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000002"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000002"), 0xFFC0FE00C0FE0002);
                    }
                    {
                        UserEditor offerprivres = UserEditor.CreateOrUseExistingGamerTag("xktofferprivres");
                        offerprivres.RemoveAllSubscriptions(true);
                        offerprivres.AddBaseSubscription(BaseSubscriptions.Xbox1Online);
                        offerprivres.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000ff"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000ff"), 0xFFC0FE00C0FE00FF);
                        offerprivres.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000001"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000001"), 0xFFC0FE00C0FE0001);
                    }
                    {
                        UserEditor banned = UserEditor.CreateOrUseExistingGamerTag("xktbanned");
                        banned.BannedUntilDate = new System.DateTime(9999, 12, 30);
                    }
                    {
                        UserEditor zerokeys = UserEditor.CreateOrUseExistingGamerTag("xktzerokeys", UserCreationType.Xbox1);
                        zerokeys.SetXenonPassword(new byte[] { 0 });
                        zerokeys.SetXbox1Password(new byte[] { 0 });
                    }
                    {
                        UserEditor zeroppas = UserEditor.CreateOrUseExistingGamerTag("xktzeroppas", UserCreationType.Xbox1);
                        zeroppas.SetXbox1PPA2(new byte[] { 0 });
                        zeroppas.SetXenonPPA2(new byte[] { 0 });
                        zeroppas.SetXbox1SPPA1(new byte[] { 0 });
                        zeroppas.SetXenonSPPA1(new byte[] { 0 });
                    }
                    {
                        UserEditor newsub7one = UserEditor.CreateOrUseExistingGamerTag("xktnewsub7one");
                        newsub7one.RemoveAllSubscriptions(false);
                        newsub7one.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000007"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000007"), 0xFFC0FE00C0FE0007);
                    }
                    {
                        UserEditor newsub7two = UserEditor.CreateOrUseExistingGamerTag("xktnewsub7two");
                        newsub7two.RemoveAllSubscriptions(false);
                        newsub7two.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000007"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000007"), 0xFFC0FE00C0FE0007);
                    }
                    {
                        UserEditor newsub7exp = UserEditor.CreateOrUseExistingGamerTag("xktnewsub7exp");
                        newsub7exp.RemoveAllSubscriptions(false);
                        newsub7exp.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000007"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000007"), 0xFFC0FE00C0FE0007, 1, "xkdctest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 3, 1, null); //expired
                    }
                    { //user has a subscription to a non-subscription
                        UserEditor newsub8 = UserEditor.CreateOrUseExistingGamerTag("xktnewsub8");
                        newsub8.RemoveAllSubscriptions(false);
                        newsub8.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000008"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000008"), 0xFFC0FE00C0FE0008);
                    }
                    { //user has an xbox.com subscription that grants 8015
                        UserEditor newsub9 = UserEditor.CreateOrUseExistingGamerTag("xktnewsub9");
                        newsub9.RemoveAllSubscriptions(false);
                        newsub9.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000009"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000009"), 0xFFC0FE00C0FE0009);
                    }
                    { //user has an xenon subscription that grants 8015
                        UserEditor newsub10 = UserEditor.CreateOrUseExistingGamerTag("xktnewsub10");
                        newsub10.RemoveAllSubscriptions(false);
                        newsub10.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-000000000010"), new System.Guid("FFC0FE00-C0FE-0000-8888-000000000010"), 0xFFC0FE00C0FE0010);
                    }
                    { //normal user that has a max valid length name (15 chars)
                        UserEditor verylongname = UserEditor.CreateOrUseExistingGamerTag("xktverylongname");
                    }
                    {
                        UserEditor authdata4User = UserEditor.CreateOrUseExistingGamerTag("xktad4a");
                        authdata4User.RemoveAllSubscriptions(false);
                        authdata4User.AddSubscription(new System.Guid("FFFE0004-C0FE-0000-ffff-0000FFFE0004"), new System.Guid("FFFE0004-C0FE-0000-8888-0000FFFE0004"), 0xFFFE000400000000);
                    }
                    {
                        UserEditor authdata4User = UserEditor.CreateOrUseExistingGamerTag("xktad4b");
                        authdata4User.RemoveAllSubscriptions(false);
                        authdata4User.AddSubscription(new System.Guid("FFFE0004-C0FE-0000-ffff-0000FFFE0004"), new System.Guid("FFFE0004-C0FE-0000-8888-0000FFFE0004"), 0xFFFE000400000000);
                    }
                    {
                        UserEditor authdata4User = UserEditor.CreateOrUseExistingGamerTag("xktad4c");
                        authdata4User.RemoveAllSubscriptions(false);
                        authdata4User.AddSubscription(new System.Guid("FFFE0004-C0FE-0000-ffff-0000FFFE0004"), new System.Guid("FFFE0004-C0FE-0000-8888-0000FFFE0004"), 0xFFFE000400000000);
                    }
                    {
                        UserEditor authdata4User = UserEditor.CreateOrUseExistingGamerTag("xktad4d");
                        authdata4User.RemoveAllSubscriptions(false);
                        authdata4User.AddSubscription(new System.Guid("FFFE0004-C0FE-0000-ffff-0000FFFE0004"), new System.Guid("FFFE0004-C0FE-0000-8888-0000FFFE0004"), 0xFFFE000400000000);
                    }

                    //users with different base subscriptions (added for testing the new subscription families)
                    { //tier 9, normal family gold offer that is part of deployment
                        UserEditor user=UserEditor.CreateOrUseExistingGamerTag("xktxxxT9");
                        user.RemoveAllSubscriptions(true);
                        user.AddBaseSubscription(BaseSubscriptions.Xbox360FamilyGold);
                    }
                    { //tier 15
                        UserEditor user=UserEditor.CreateOrUseExistingGamerTag("xktxxxT15");
                        user.RemoveAllSubscriptions(true);
                        user.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A0"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A0"), 0xFFC0FE00C0FE00A0);
                    }
                    { //tier 0xf9abcde8, can't be represented by the 4 bit user flags for it
                        UserEditor user=UserEditor.CreateOrUseExistingGamerTag("xktxxxTf9abcde8");
                        user.RemoveAllSubscriptions(true);
                        user.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A1"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A1"), 0xFFC0FE00C0FE00A1);
                    }
                    { //silver user with service 8014 for all titles
                        UserEditor suba3 = UserEditor.CreateOrUseExistingGamerTag("xktsuba3");
                        suba3.RemoveAllSubscriptions(true);
                        suba3.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                        suba3.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A3"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A3"), 0xFFC0FE00C0FE00A3);
                    }

                    //
                    { //User with the XNA-like subscription
                        UserEditor xna0=UserEditor.CreateOrUseExistingGamerTag("xktxna0");
                        xna0.RemoveAllSubscriptions(false);
                        xna0.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A5"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A5"), 0xFFC0FE00C0FE00A5);
                    }

                    { //User with game subscription 6
                        UserEditor xktsubgame0=UserEditor.CreateOrUseExistingGamerTag("xktsubgame0");
                        xktsubgame0.RemoveAllSubscriptions(false);
                        xktsubgame0.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A6"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A6"), 0xFFC0FE00C0FE00A6);
                    }
                    { //User with game subscription 7
                        UserEditor xktsubgame1=UserEditor.CreateOrUseExistingGamerTag("xktsubgame1");
                        xktsubgame1.RemoveAllSubscriptions(false);
                        xktsubgame1.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A7"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A7"), 0xFFC0FE00C0FE00A7);
                    }
                    { //User with game subscription 6 and 7
                        UserEditor xktsubgame2=UserEditor.CreateOrUseExistingGamerTag("xktsubgame2");
                        xktsubgame2.RemoveAllSubscriptions(false);
                        xktsubgame2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A6"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A6"), 0xFFC0FE00C0FE00A6);
                        xktsubgame2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A7"), new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A7"), 0xFFC0FE00C0FE00A7);
                    }
                } //unchecked
            }
        }

        [TestCase]
        public class BetaGroupData: TestNode
        {
            public override void Run()
            {
                // -- create machines

                MachineEditor machNone=     MachineEditor.CreateOrUseExistingName("XE.133700000004"); //not in any group

                //flash only updates                                                      mmTtff#c
                MachineEditor machF0=       MachineEditor.CreateOrUseExistingName("XE.133700000105");
                MachineEditor machF1=       MachineEditor.CreateOrUseExistingName("XE.133700000206");
                //MachineEditor machF0F1=     MachineEditor.CreateOrUseExistingName("XE.133700000307"); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                //MachineEditor machF0F1F2=   MachineEditor.CreateOrUseExistingName("XE.133700000701"); //flash version 31 conflict between 1 and 2 //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                MachineEditor machF4=       MachineEditor.CreateOrUseExistingName("XE.133700001601");
                MachineEditor machF5=       MachineEditor.CreateOrUseExistingName("XE.133700003205");
                MachineEditor machF6=       MachineEditor.CreateOrUseExistingName("XE.133700006404"); //flash update in the past
                MachineEditor machF7=       MachineEditor.CreateOrUseExistingName("XE.133800000184"); //flash update in the future
                MachineEditor pcF3=         MachineEditor.CreateOrUseExistingName("PC.133700000813");
                MachineEditor pcF1=         MachineEditor.CreateOrUseExistingName("PC.133700000217");

                //title only updates                                                      mmttff#c
                MachineEditor machT0=      MachineEditor.CreateOrUseExistingName("XE.133700010005");
                MachineEditor machT1=      MachineEditor.CreateOrUseExistingName("XE.133700020006");
                //MachineEditor machT0T1=    MachineEditor.CreateOrUseExistingName("XE.133700030007"); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                //MachineEditor machT0T1T2=  MachineEditor.CreateOrUseExistingName("XE.133700070001"); //title0 version 131 conflict between 1 and 2 //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                MachineEditor machT4=      MachineEditor.CreateOrUseExistingName("XE.133700160001");
                MachineEditor machT5=      MachineEditor.CreateOrUseExistingName("XE.133700320005");
                MachineEditor machT6=      MachineEditor.CreateOrUseExistingName("XE.133700640004"); //title update in the past
                MachineEditor machT7=      MachineEditor.CreateOrUseExistingName("XE.133700960009"); //title update in the future
                MachineEditor pcT3=        MachineEditor.CreateOrUseExistingName("PC.133700080013");

                //mixed updates                                                          mmttff#c
                MachineEditor machM0=      MachineEditor.CreateOrUseExistingName("XE.133701000005");
                MachineEditor machM1=      MachineEditor.CreateOrUseExistingName("XE.133702000006");

                //misc
                MachineEditor machLots=    MachineEditor.CreateOrUseExistingName("XE.133900000017"); //machine is in more than 5 beta groups; KDC has a constant of 5 max right now, but should handle this gracefully.

                MachineEditor machOldMask=    MachineEditor.CreateOrUseExistingName("XE.133900000028"); //machine has the old beta title mask set -- This and the associated test should be removed when the column is actually deleted
                machOldMask.BetaUser=0xff;
                machOldMask.BetaTitle=unchecked((int)0xffffffff);

                // -- create beta groups

                //flash beta groups
                BetaGroupEditor bgeFlash0=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000000"));
                bgeFlash0.Name="XKDCTest Flash Beta Group 0";
                bgeFlash0.RemoveAllMachines();
                bgeFlash0.AddMachine(machF0.Id);
                //bgeFlash0.AddMachine(machF0F1.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                //bgeFlash0.AddMachine(machF0F1F2.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.

                BetaGroupEditor bgeFlash1=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000001"));
                bgeFlash1.Name="XKDCTest Flash Beta Group 1";
                bgeFlash1.RemoveAllMachines();
                bgeFlash1.AddMachine(machF1.Id);
                //bgeFlash1.AddMachine(machF0F1.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                //bgeFlash1.AddMachine(machF0F1F2.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                bgeFlash1.AddMachine(pcF1.Id);

                BetaGroupEditor bgeFlash2=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000002"));
                bgeFlash2.Name="XKDCTest Flash Beta Group 2";
                bgeFlash2.RemoveAllMachines();
                //bgeFlash2.AddMachine(machF0F1F2.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.

                BetaGroupEditor bgeFlash3=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000003"));
                bgeFlash3.Name="XKDCTest Flash Beta Group 3";
                bgeFlash3.RemoveAllMachines();
                bgeFlash3.AddMachine(pcF3.Id);

                BetaGroupEditor bgeFlash4=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000004"));
                bgeFlash4.Name="XKDCTest Flash Beta Group 4";
                bgeFlash4.RemoveAllMachines();
                bgeFlash4.AddMachine(machF4.Id);

                BetaGroupEditor bgeFlash5=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000005"));
                bgeFlash5.Name="XKDCTest Flash Beta Group 5";
                bgeFlash5.RemoveAllMachines();
                bgeFlash5.AddMachine(machF5.Id);

                BetaGroupEditor bgeFlash6=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000006"));
                bgeFlash6.Name="XKDCTest Flash Beta Group 6";
                bgeFlash6.RemoveAllMachines();
                bgeFlash6.AddMachine(machF6.Id);

                BetaGroupEditor bgeFlash7=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000007"));
                bgeFlash7.Name="XKDCTest Flash Beta Group 7";
                bgeFlash7.RemoveAllMachines();
                bgeFlash7.AddMachine(machF7.Id);

                //title beta groups
                BetaGroupEditor bgeTitle0=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000010"));
                bgeTitle0.Name="XKDCTest Title Beta Group 0";
                bgeTitle0.RemoveAllMachines();
                bgeTitle0.AddMachine(machT0.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                //bgeTitle0.AddMachine(machT0T1.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                //bgeTitle0.AddMachine(machT0T1T2.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.

                BetaGroupEditor bgeTitle1=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000011"));
                bgeTitle1.Name="XKDCTest Title Beta Group 1";
                bgeTitle1.RemoveAllMachines();
                bgeTitle1.AddMachine(machT1.Id);
                //bgeTitle1.AddMachine(machT0T1.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                //bgeTitle1.AddMachine(machT0T1T2.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.

                BetaGroupEditor bgeTitle2=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000012"));
                bgeTitle2.Name="XKDCTest Title Beta Group 2";
                bgeTitle2.RemoveAllMachines();
                //bgeTitle2.AddMachine(machT0T1T2.Id); //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.

                BetaGroupEditor bgeTitle3=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000013"));
                bgeTitle3.Name="XKDCTest Title Beta Group 3";
                bgeTitle3.RemoveAllMachines();
                bgeTitle3.AddMachine(pcT3.Id);

                BetaGroupEditor bgeTitle4=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000014"));
                bgeTitle4.Name="XKDCTest Title Beta Group 4";
                bgeTitle4.RemoveAllMachines();
                bgeTitle4.AddMachine(machT4.Id);

                BetaGroupEditor bgeTitle5=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000015"));
                bgeTitle5.Name="XKDCTest Title Beta Group 5";
                bgeTitle5.RemoveAllMachines();
                bgeTitle5.AddMachine(machT5.Id);

                BetaGroupEditor bgeTitle6=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000016"));
                bgeTitle6.Name="XKDCTest Title Beta Group 6";
                bgeTitle6.RemoveAllMachines();
                bgeTitle6.AddMachine(machT6.Id);

                BetaGroupEditor bgeTitle7=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000017"));
                bgeTitle7.Name="XKDCTest Title Beta Group 7";
                bgeTitle7.RemoveAllMachines();
                bgeTitle7.AddMachine(machT7.Id);

                //mixed beta groups
                BetaGroupEditor bgeMixed0=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000020"));
                bgeMixed0.Name="XKDCTest Mixed Beta Group 0";
                bgeMixed0.RemoveAllMachines();
                bgeMixed0.AddMachine(machM0.Id);

                BetaGroupEditor bgeMixed1=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000021"));
                bgeMixed1.Name="XKDCTest Mixed Beta Group 1";
                bgeMixed1.RemoveAllMachines();
                bgeMixed1.AddMachine(machM1.Id);

                //misc beta groups
                /*for (int i=0; i<10; ++i) //BE7ABE7A-7E57-C0DE-F00D-000000000030-BE7ABE7A-7E57-C0DE-F00D-000000000039: put a machine into 10 beta groups
                {
                    BetaGroupEditor bgeMiscLots=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-00000000003"+i));
                    bgeMiscLots.Name="XKDCTest Misc Lots Beta Group "+i;
                    bgeMiscLots.RemoveAllMachines();
                    bgeMiscLots.AddMachine(machLots.Id);
                }*/ //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.

                // -- create titles and title versions

                //add flash betas
                TitleEditor titleFFFE07D1=TitleEditor.FromId(0xfffe07d1);
                titleFFFE07D1.RemoveBaseVersion(30);
                titleFFFE07D1.RemoveBaseVersion(31);
                titleFFFE07D1.RemoveBaseVersion(32);
                titleFFFE07D1.RemoveBaseVersion(34);
                titleFFFE07D1.RemoveBaseVersion(35);
                titleFFFE07D1.RemoveBaseVersion(37);
                titleFFFE07D1.RemoveBaseVersion(38);
                titleFFFE07D1.RemoveBaseVersion(40);
                titleFFFE07D1.RemoveBaseVersion(41);
                titleFFFE07D1.RemoveBaseVersion(43);
                titleFFFE07D1.RemoveBaseVersion(50);
                titleFFFE07D1.RemoveBaseVersion(100);
                titleFFFE07D1.RemoveBaseVersion(101);
                titleFFFE07D1.RemoveBaseVersion(102);

                titleFFFE07D1.AddVersion(30, 40, 2, bgeFlash0.Id);
                titleFFFE07D1.AddVersion(31, 41, 2, bgeFlash1.Id);
                titleFFFE07D1.AddVersion(32, 42, 2, bgeFlash1.Id);
                titleFFFE07D1.AddVersion(35, 35, 2, bgeFlash1.Id);
                titleFFFE07D1.AddVersion(31, 43, 2, bgeFlash2.Id);
                titleFFFE07D1.AddVersion(34, 34, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                UodbWS.ExecuteSQLNonQuery("update t_title_versions set i_beta_version=666 where i_title_id=0xfffe07d1 and i_base_version=34 and ti_console_type_id=2", null); // This should be removed when these columns are actually deleted from the db in production

                titleFFFE07D1.AddVersion(37, 38, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                titleFFFE07D1.AddVersion(37, 39, 2, bgeFlash4.Id);
                titleFFFE07D1.AddVersion(37, 37, 2, bgeFlash5.Id);
                titleFFFE07D1.AddVersion(38, 38, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                titleFFFE07D1.AddVersion(38, 37, 2, bgeFlash4.Id);

                titleFFFE07D1.AddVersion(40, 50, 2, bgeFlash6.Id, System.DateTime.UtcNow-new System.TimeSpan(10,0,0,0), System.DateTime.UtcNow-new System.TimeSpan(0,0,10,0)); //beta group in the past
                titleFFFE07D1.AddVersion(40, 50, 2, bgeFlash7.Id, System.DateTime.UtcNow+new System.TimeSpan(20,0,0,0), System.DateTime.UtcNow+new System.TimeSpan(100,0,0,0)); //beta group in the future
                titleFFFE07D1.AddVersion(41, 41, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                titleFFFE07D1.AddVersion(41, 50, 2, bgeFlash6.Id, System.DateTime.UtcNow-new System.TimeSpan(10,0,0,0), System.DateTime.UtcNow-new System.TimeSpan(0,0,10,0)); //beta group in the past

                titleFFFE07D1.AddVersion(43, 43, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                titleFFFE07D1.AddVersion(43, 44, 2, bgeFlash0.Id);
                titleFFFE07D1.AddVersion(43, 44, 2, bgeFlash1.Id);
                titleFFFE07D1.AddVersion(43, 44, 2, bgeFlash2.Id);

                titleFFFE07D1.AddVersion(50, 51, 2, new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000035")); //one of the beta groups the lots machine is in has an update

                TitleEditor titleFFFE0000=TitleEditor.FromId(0xfffe0000);
                titleFFFE0000.AddVersion(31, 41, 0, bgeFlash1.Id);

                TitleEditor title585207d1=TitleEditor.FromId(0x585207d1);
                title585207d1.AddVersion(32, 40, 4, bgeFlash3.Id);

                //add title betas
                TitleEditor title1337FF00=TitleEditor.CreateOrUseExistingId(0x1337FF00);
                title1337FF00.RemoveAllVersions();
                title1337FF00.AddVersion(130, 140, 2, bgeTitle0.Id);
                title1337FF00.AddVersion(131, 141, 2, bgeTitle1.Id);
                title1337FF00.AddVersion(132, 142, 2, bgeTitle1.Id);
                title1337FF00.AddVersion(135, 135, 2, bgeTitle1.Id);
                title1337FF00.AddVersion(131, 143, 2, bgeTitle2.Id);
                title1337FF00.AddVersion(134, 134, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));

                title1337FF00.AddVersion(137, 138, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                title1337FF00.AddVersion(137, 139, 2, bgeTitle4.Id);
                title1337FF00.AddVersion(137, 137, 2, bgeTitle5.Id);
                title1337FF00.AddVersion(138, 138, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                title1337FF00.AddVersion(138, 137, 2, bgeTitle4.Id);

                title1337FF00.AddVersion(140, 150, 2, bgeTitle6.Id, System.DateTime.UtcNow-new System.TimeSpan(10,0,0,0), System.DateTime.UtcNow-new System.TimeSpan(0,0,10,0)); //beta group in the past
                title1337FF00.AddVersion(140, 150, 2, bgeTitle7.Id, System.DateTime.UtcNow+new System.TimeSpan(20,0,0,0), System.DateTime.UtcNow+new System.TimeSpan(100,0,0,0)); //beta group in the future
                title1337FF00.AddVersion(141, 141, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                title1337FF00.AddVersion(141, 150, 2, bgeTitle6.Id, System.DateTime.UtcNow-new System.TimeSpan(10,0,0,0), System.DateTime.UtcNow-new System.TimeSpan(0,0,10,0)); //beta group in the past

                title1337FF00.AddVersion(143, 143, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                title1337FF00.AddVersion(143, 144, 2, bgeTitle0.Id);
                title1337FF00.AddVersion(143, 144, 2, bgeTitle1.Id);
                title1337FF00.AddVersion(143, 144, 2, bgeTitle2.Id);

                TitleEditor title1337FF01=TitleEditor.CreateOrUseExistingId(0x1337FF01);
                title1337FF01.RemoveAllVersions();
                title1337FF01.AddVersion(131, 141, 0, bgeTitle1.Id);
                title1337FF01.AddVersion(141, 141, 0, new System.Guid("00000000-0000-0000-0000-000000000000"));

                TitleEditor title1337FF02=TitleEditor.CreateOrUseExistingId(0x1337FF02);
                title1337FF02.RemoveAllVersions();
                title1337FF02.AddVersion(132, 140, 4, bgeTitle3.Id);

                //add mixed betas
                TitleEditor title1337FF10=TitleEditor.CreateOrUseExistingId(0x1337FF10);
                title1337FF10.RemoveAllVersions();
                title1337FF10.AddVersion(100, 100, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                title1337FF10.AddVersion(100, 120, 2, bgeMixed0.Id);
                titleFFFE07D1.AddVersion(100, 100, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                titleFFFE07D1.AddVersion(100, 120, 2, bgeMixed0.Id);

                title1337FF10.AddVersion(101, 101, 2, bgeMixed0.Id);
                title1337FF10.AddVersion(101, 120, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                titleFFFE07D1.AddVersion(101, 101, 2, bgeMixed0.Id);
                titleFFFE07D1.AddVersion(101, 120, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));

                title1337FF10.AddVersion(102, 101, 2, bgeMixed0.Id);
                title1337FF10.AddVersion(102, 120, 2, bgeMixed1.Id);
                titleFFFE07D1.AddVersion(102, 101, 2, bgeMixed0.Id);
                titleFFFE07D1.AddVersion(102, 120, 2, bgeMixed1.Id);
            }
        };

        [TestCase, Description("Data used by the xbox1 decomission tests.")]
        public class Xbox1DecomData: TestNode
        {
            public override void Run()
            {
                TitleEditor titleFFFE07d2=TitleEditor.FromId(0xfffe07d2); //fusion
                titleFFFE07d2.AddVersion(0x20075Cff, 0x2016C5ff, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                titleFFFE07d2.AddVersion(0x2016C5ff, 0x2016C5ff, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));

                TitleEditor titleFFFE0000=TitleEditor.FromId(0xfffe0000); //xbox1 dash
                titleFFFE0000.AddVersion(0x185EADfe, 0x185EADff, 0, new System.Guid("00000000-0000-0000-0000-000000000000"));
                titleFFFE0000.AddVersion(0x185EADff, 0x185EADff, 0, new System.Guid("00000000-0000-0000-0000-000000000000"));

                TitleEditor title4d530064=TitleEditor.FromId(0x4d530064); //halo2
                title4d530064.AddVersion(0xf0000003, 0xf0000803, 0, new System.Guid("00000000-0000-0000-0000-000000000000"));
                title4d530064.AddVersion(0xf0000803, 0xf0000803, 0, new System.Guid("00000000-0000-0000-0000-000000000000"));
            }
        }

        [TestCase, Description("Data used to test going beyond 32 services")]
        public class Beyond32ServicesData: TestNode
        {
            public override void Run()
            {
                //configure an additional 40 services.  this does not cause them to be granted to anyone, so its safe.
                for (int s=80; s<80+40; ++s)
                {
                    ServiceEditor serv=ServiceEditor.CreateOrUseExistingId((uint)s);
                    serv.KerberosServiceName="sg";
                    serv.KerberosDomainName="S"+s;
                    serv.Name="xkdctest extra "+s;
                    serv.MachineOnly=0;
                    serv.AddInstance(0, 0, 0, 1, (uint)s, 1);
                }

                //set up a service set that contains the normal services as well as the extra set
                ServiceSetEditor ss=ServiceSetEditor.CreateOrUseExistingId(0xB8FE);
                ss.Name="Services for New Testland";
                ss.RemoveAllServices();
                foreach (uint s in ServiceSetEditor.FromId(100).GetAllServices())
                {
                    ss.AddService(s);
                }

                for (int s=80; s<80+40; ++s)
                {
                    ss.AddService((uint)s);
                }

                //we don't want everyone to get these services by default since it will break older clients, so create a special country set that will receive them and set up that mapping
                CountrySetEditor countrySet=CountrySetEditor.CreateOrUseExistingId(0xB8FE);
                countrySet.RemoveAllCountries();
                countrySet.AddCountry(254); //New Testland

                ServiceTypeMappingEditor stmXenon=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB8FE); //for xbox360
                stmXenon.Name="XkdcTest - New Testland - Xbox360";
                stmXenon.ServiceType=1; //xbox live
                stmXenon.ClientType=2; //xbox360
                stmXenon.CountrySet=unchecked((short)0xB8FE); //New Testland
                stmXenon.PrivilegeSet=100; //default for live
                stmXenon.ServiceSet=unchecked((short)0xB8FE);
                stmXenon.SubscriptionType=100;
                stmXenon.IsFreeTrial=0;

                ServiceTypeMappingEditor stmPanorama=ServiceTypeMappingEditor.CreateOrUseExistingId(0xB7FE); //for pc
                stmPanorama.Name="XkdcTest - New Testland - PC";
                stmPanorama.ServiceType=1; //xbox live
                stmPanorama.ClientType=4; //pc
                stmPanorama.CountrySet=unchecked((short)0xB8FE); //New Testland
                stmPanorama.PrivilegeSet=100; //default for live
                stmPanorama.ServiceSet=unchecked((short)0xB8FE);
                stmPanorama.SubscriptionType=100;
                stmPanorama.IsFreeTrial=0;

                //add the new services to the test land subscription.
                OfferEditor offerFFC0FE00C0FE00A4=OfferEditor.FromId(0xFFC0FE00C0FE00A4);
                ServiceSetEditor setFCA4=ServiceSetEditor.FromId(0xfca4);
                for (int i=80; i<80+40; ++i)
                {
                    offerFFC0FE00C0FE00A4.AddService((uint)i);
                    setFCA4.AddService((uint)i);
                }

                //create users that live in New Testland

                UserEditor cntry254t1=UserEditor.CreateOrUseExistingGamerTag("xktcntry254t1"); //silver user
                cntry254t1.CountryId=254;
                cntry254t1.LanguageId=1;
                cntry254t1.RemoveAllSubscriptions(true);
                cntry254t1.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                cntry254t1.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A4"),new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A4"),0xFFC0FE00C0FE00A4);

                UserEditor cntry254t2=UserEditor.CreateOrUseExistingGamerTag("xktcntry254t2"); //gold user
                cntry254t2.CountryId=254;
                cntry254t2.LanguageId=1;
                cntry254t2.RemoveAllSubscriptions(false);
                cntry254t2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A4"),new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A4"),0xFFC0FE00C0FE00A4);

                UserEditor cntry254t2a=UserEditor.CreateOrUseExistingGamerTag("xktcntry254t2a"); //gold user
                cntry254t2a.CountryId=254;
                cntry254t2a.LanguageId=1;
                cntry254t2a.RemoveAllSubscriptions(false);
                cntry254t2a.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A4"),new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A4"),0xFFC0FE00C0FE00A4);

                UserEditor cntry254t2a2=UserEditor.CreateOrUseExistingGamerTag("xktcntry254t2a2"); //gold user
                cntry254t2a2.CountryId=254;
                cntry254t2a2.LanguageId=1;
                cntry254t2a2.RemoveAllSubscriptions(false);
                cntry254t2a2.AddSubscription(new System.Guid("FFC0FE00-C0FE-0000-ffff-0000000000A4"),new System.Guid("FFC0FE00-C0FE-0000-8888-0000000000A4"),0xFFC0FE00C0FE00A4);
            }
        }

        [TestCase, Description("This data is not used by the xkdctest suite.  It is for manually testing that a console handles >32 services."), Ignore("It will do bad things to every client using the old preauth"), RunDependency("Beyond32ServicesData")]
        public class ManualConsoleTestData_PreauthV5: TestNode
        {
            public override void Run()
            {
                //add 40 extra services to the base live set.  This should give us well over 32 services being granted to all normal xenon clients.
                ServiceSetEditor ssLive=ServiceSetEditor.FromId(100); //Xbox Live (main set currently used by everything)
                for (int s=80; s<80+40; ++s)
                {
                    ssLive.AddService((uint)s);
                }
            }
        }

        [TestCase]
        public class ReloadKDCs: TestNode
        {
            public override void Run()
            {
                Suite.RefreshKDCsConfig();
                Suite.ReloadKDCs();
            }
        }
    }
};

} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncXKDCAuth.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace XkdcTest
{
    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(250), AsyncThreadCount(10)]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XKDCAuth : XkdcTestBaseGroup
    {
        // For titles 0xFFBEEF00 (-4264192) through 0xFFBEEF0F using
        // version 1, region 1, the expected HR (update required or not?)
        // 16 of them
        private const uint UPDREQ = HResult.XONLINE_E_LOGON_UPDATE_REQUIRED;
        private const uint OK = HResult.S_OK;
        private static readonly uint[] hrsForTitles = new uint[16]
            { OK, UPDREQ, OK, OK, OK, OK, UPDREQ, OK, UPDREQ, UPDREQ, OK, UPDREQ, UPDREQ, OK, OK, OK };

        /// [Test_Xkdc_User_1_Logon_Auth_a]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF00..0xFFBEEF0E (-4264192..-4264178)
        /// services=useraccount, base, presence
        /// stoponfail=yes
        [TestCase, Description("User logon test with Auth Verify (xktuser7a)")]
        class Test_Xkdc_User_1_Logon_Auth_a : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                int titleID = -4264192;
                uint[] ExpectedHRs = new uint[12];
                for(int i = 0; i < 16; i++)
                {
                    TitleInfo TI = new TitleInfo(titleID+i, 1, 1);
                    TEST_RESULTS result = GetUserSTCheckAuth(UserTimer.AccessSharedUser("xktuser7a"),
                        new uint[] {(uint)XOService.User_Account,
                            (uint)XOService.Base_Subscription,
                            (uint)XOService.PresNotification},
                        TI,
                        ExpectedHRs,
                        hrsForTitles[i],
                        's');

                    if (result != TEST_RESULTS.PASSED)
                    {
                        Global.RO.Warn("Failed at TitleId=0x{0:X} ({1})", titleID+i, titleID+i);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_b]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7b
        /// titleid=0xFFBEEF00..0xFFBEEF0E (-4264192..-4264178)
        /// services=useraccount, base, presence
        /// stoponfail=yes
        [TestCase, Description("User logon test with Auth Verify (xktuser7b)")]
        class Test_Xkdc_User_1_Logon_Auth_b : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                int titleID = -4264192;
                uint[] ExpectedHRs = new uint[12];
                for(int i = 0; i < 16; i++)
                {
                    TitleInfo TI = new TitleInfo(titleID+i, 1, 1);
                    TEST_RESULTS result = GetUserSTCheckAuth(UserTimer.AccessSharedUser("xktuser7b"),
                        new uint[] {(uint)XOService.User_Account,
                            (uint)XOService.Base_Subscription,
                            (uint)XOService.PresNotification},
                        TI,
                        ExpectedHRs,
                        hrsForTitles[i],
                        's');

                    if (result != TEST_RESULTS.PASSED)
                    {
                        Global.RO.Warn("Failed at TitleId=0x{0:X} ({1})", titleID+i, titleID+i);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_c]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7c
        /// titleid=0xFFBEEF00..0xFFBEEF0E (-4264192..-4264178)
        /// services=useraccount, base, presence
        /// stoponfail=yes
        [TestCase, Description("User logon test with Auth Verify (xktuser7c)")]
        class Test_Xkdc_User_1_Logon_Auth_c : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                int titleID = -4264192;
                uint[] ExpectedHRs = new uint[12];
                for(int i = 0; i < 16; i++)
                {
                    TitleInfo TI = new TitleInfo(titleID+i, 1, 1);
                    TEST_RESULTS result = GetUserSTCheckAuth(UserTimer.AccessSharedUser("xktuser7c"),
                        new uint[] {(uint)XOService.User_Account,
                            (uint)XOService.Base_Subscription,
                            (uint)XOService.PresNotification},
                        TI,
                        ExpectedHRs,
                        hrsForTitles[i],
                        's');

                    if (result != TEST_RESULTS.PASSED)
                    {
                        Global.RO.Warn("Failed at TitleId=0x{0:X} ({1})", titleID+i, titleID+i);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_d]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7d
        /// titleid=0xFFBEEF00..0xFFBEEF0E (-4264192..-4264178)
        /// services=useraccount, base, presence
        /// stoponfail=yes
        [TestCase, Description("User logon test with Auth Verify (xktuser7d)")]
        class Test_Xkdc_User_1_Logon_Auth_d : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                int titleID = -4264192;
                uint[] ExpectedHRs = new uint[12];
                for(int i = 0; i < 16; i++)
                {
                    TitleInfo TI = new TitleInfo(titleID+i, 1, 1);
                    TEST_RESULTS result = GetUserSTCheckAuth(UserTimer.AccessSharedUser("xktuser7d"),
                        new uint[] {(uint)XOService.User_Account,
                            (uint)XOService.Base_Subscription,
                            (uint)XOService.PresNotification},
                        TI,
                        ExpectedHRs,
                        hrsForTitles[i],
                        's');

                    if (result != TEST_RESULTS.PASSED)
                    {
                        Global.RO.Warn("Failed at TitleId=0x{0:X} ({1})", titleID+i, titleID+i);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_Title_with_no_Trust]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF21 (-4264159)
        /// services=useraccount, base, presence
        /// stoponfail=yes
        [TestCase, Description("User logon test with Auth Verify")]
        class Test_Xkdc_User_1_Logon_Auth_Title_with_no_Trust : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                TitleInfo TI = new TitleInfo(-4264159, 1, 1);
                TEST_RESULTS result = GetUserSTCheckAuth(UserTimer.AccessSharedUser("xktuser7a"),
                        new uint[] {(uint)XOService.User_Account,
                            (uint)XOService.Base_Subscription,
                            (uint)XOService.PresNotification},
                        TI,
                        ExpectedHRs,
                        HResult.S_OK,
                        's');
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_Basic]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFC0FE00 (-4129280)
        /// services=useraccount, base, presence
        /// stoponfail=yes
        [TestCase, Description("User logon test with Auth Verify")]
        class Test_Xkdc_User_1_Logon_Auth_Basic : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                TitleInfo TI = new TitleInfo(-4129280, 1, 1);
                ResultCode = GetUserSTCheckAuth(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account,
                        (uint)XOService.Base_Subscription,
                        (uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_1]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub2
        /// titleid=0xFFBEEF00 (-4264192)
        /// services=useraccount, base, presence
        /// rating 0 stars
        [TestCase, Description("Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_1 (xktsub2, 0 stars rating)")]
        class Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_1 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264192, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 0;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktsub2"),
                    new uint[] {(uint)XOService.User_Account,
                        (uint)XOService.Base_Subscription,
                        (uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'd');
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_2]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub3
        /// titleid=0xFFBEEF00 (-4264192)
        /// services=useraccount, base, presence
        /// rating 3 stars
        [TestCase, Description("Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_2 (xktsub3, 3 stars rating)")]
        class Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_2 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                // This test is sensitive to trust-related munging. Someone
                // else seems to be altering the title & user trust ratings in 
                // the database. If this test fails, fix the db by running:
                // dbposter -update uodb-tables.ini uodb-xkdctest.ini
                TitleInfo TI = new TitleInfo(-4264192, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 3;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktsub3"),
                    new uint[] {(uint)XOService.User_Account,
                        (uint)XOService.Base_Subscription,
                        (uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'd');
            }
        }


        /// [Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_3]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub4
        /// titleid=0xFFBEEF00 (-4264192)
        /// services=useraccount, base, presence
        /// rating 7 stars
        [TestCase, Description("Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_3 (xktsub4, 7 stars rating)")]
        class Test_Xkdc_User_1_Logon_Auth_CheckDisconnects_3 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264192, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 7;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktsub4"),
                    new uint[] {(uint)XOService.User_Account,
                        (uint)XOService.Base_Subscription,
                        (uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'd');
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_CheckSessions_1]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub2
        /// titleid=0xFFBEEF00 (-4264192)
        /// services=useraccount, base, presence
        /// rating 0 stars
        [TestCase, Description("Test_Xkdc_User_1_Logon_Auth_CheckSessions_1 (xktsub2, 0 stars rating)")]
        class Test_Xkdc_User_1_Logon_Auth_CheckSessions_1 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264192, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 0;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktsub2"),
                    new uint[] {(uint)XOService.User_Account,
                        (uint)XOService.Base_Subscription,
                        (uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'n');
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_CheckSessions_2]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub3
        /// titleid=0xFFBEEF00 (-4264192)
        /// services=useraccount, base, presence
        /// rating 3 stars
        [TestCase, Description("Test_Xkdc_User_1_Logon_Auth_CheckSessions_2 (xktsub3, 3 stars rating)")]
        class Test_Xkdc_User_1_Logon_Auth_CheckSessions_2 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                // This test is sensitive to trust-related munging. Someone
                // else seems to be altering the title & user trust ratings in 
                // the database. If this test fails, fix the db by running:
                // dbposter -update uodb-tables.ini uodb-xkdctest.ini
                TitleInfo TI = new TitleInfo(-4264192, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 3;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktsub3"),
                    new uint[] {(uint)XOService.User_Account,
                        (uint)XOService.Base_Subscription,
                        (uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'n');
            }
        }


        /// [Test_Xkdc_User_1_Logon_Auth_CheckSessions_3]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub4
        /// titleid=0xFFBEEF00 (-4264192)
        /// services=useraccount, base, presence
        /// rating 7 stars
        [TestCase, Description("Test_Xkdc_User_1_Logon_Auth_CheckSessions_3 (xktsub4, 7 stars rating)")]
        class Test_Xkdc_User_1_Logon_Auth_CheckSessions_3 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264192, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 7;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktsub4"),
                    new uint[] {(uint)XOService.User_Account,
                        (uint)XOService.Base_Subscription,
                        (uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'n');
            }
        }

        /// [Test_Xkdc_User_1_Logon_Auth_Matrix]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub1
        /// titleid=0xFFBEEF00..0xFFBEEF0F (-4264192..-4264177)
        /// services=useraccount, base, presence
        /// rating 7 stars
        [TestCase, Description("Test_Xkdc_User_1_Logon_Auth_Matrix (xktsub1, 7 stars rating, 4 titleids)")]
        class Test_Xkdc_User_1_Logon_Auth_Matrix : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                // I don't know what the data for this test used to look like, but the titles
                // it uses have been all mangled with their version numbers.  The following
                // data I pulled from the database (which came from dbposter's uodb-xkdctest.ini)
                // It should provide the most up-to-date version for each title, but a few
                // are so mangled that there's no option but UPDATE_REQUIRED. I think this
                // still preserves the intent of this test..  -kgoodier
                int[] TitleVersions = { 1, 3, 1, 2, 1, 1, 5, 1, 1/**/, 2, 2, 3, 3, 1, 1, 0/**/ };
                uint[] ExpectedHR = { 0, 0, 0, 0, 0, 0, 0, 0, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED, 0, 0, 0, 0, 0, 0, 0 };
                for(int i = 0; i < 16; i++)
                {
                    uint expectedHRtemp;
                    if (ExpectedHR[i] == 0)
                    {
                        expectedHRtemp = 0;
                    }
                    else
                    {
                        expectedHRtemp = 1;
                    }
                    for (int j = 0; j < ExpectedHRs.Length; j++)
                    {
                        ExpectedHRs[j] = expectedHRtemp;
                    }

                    TitleInfo TI = new TitleInfo(-4264192+i, TitleVersions[i], 1);
                    if(GetUserSTCheckAuth(UserTimer.AccessSharedUser("xktsub1"),
                        new uint[] {(uint)XOService.User_Account,
                            (uint)XOService.Base_Subscription,
                            (uint)XOService.PresNotification},
                        TI,
                        ExpectedHRs,
                        ExpectedHR[i],
                        's') != TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncAntiDos.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;

namespace XkdcTest
{
    [TestGroup, TestFrequency("Regression"), TestCasePriority(2)]
    public class AntiDos : TestNode
    {
        // -- xmacs
        [TestGroup, AsyncGroup(1)]
        public class Xmacs: TestNode
        {
            public override void PreRun()
            {
                //verify that anti-dos is actually enabled
                ValueCheck.Test("Xmacs AntiDos-1 enabled", true, XkdcTestBaseGroup.settingXmacsDOSEnabled);
                ValueCheck.Test("Xmacs AntiDos-2 enabled", true, XkdcTestBaseGroup.settingXmacsDOS2Enabled);
            }

            [TestCase, Description("Verifies that packet replays are ignored.")]
            [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
            [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
            public void Replay(TestNode self)
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)self.MyValues[0];
                KdcClient client=new KdcClient(clientType);

                //initial normal request
                client.ExecuteXmacs(true);

                //now resend the exact same packet, it should be ignored
                try
                {
                    client.RetryLostPackets=false;
                    client.ExecuteXmacs(false);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Expected the packet replay to be ignored, but the request instead succeeded!");
            }

            [TestCase, Description("Verifies the xmacs DOS2 mechinism, which allows a specific number of requests from a console within a specific number of time.  Exceeding that number results in a temporary ban.")]
            public void Xbox360_Dos2()
            {
                KdcClientXbox360 client=new KdcClientXbox360();
                client.RetryLostPackets=false;

                //TODO: read these from the npdb settings instead
                int dos2MaxRequests=20;
                int dos2Interval=60;
                int dos2BlockTime=120;

                //do the first request
                Global.RO.Debug("Doing the first set of requsts that will be accepted.");
                client.ExecuteXmacs(true);
                System.DateTime firstRequestTime=System.DateTime.UtcNow;

                //now do all requests that we can that won't be ignored
                for (int i=1; i<dos2MaxRequests; ++i)
                {
                    client.ExecuteXmacs(true);
                }

                //the next request should be ignored
                Global.RO.Debug("The next request should be blocked.");

                if ((int)(System.DateTime.UtcNow-firstRequestTime).TotalSeconds>=dos2Interval-1)
                {
                    throw new System.Exception("Test could not run fast enough to trigger anti-dos.");
                }

                try
                {
                    client.ExecuteXmacs(true);
                    throw new UnexpectedTestResultException("Request "+(dos2MaxRequests+1)+" was unexpectedly accepted by xmacs.");
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                }

                //now we wait for the blocking time to expire, though we'll test it once shortly before it does expire
                int sleepTime=dos2BlockTime-10-4; //10 seconds before ban ends (4 seconds are for the xmacs timeout time)
                Global.RO.Debug("Making random xmacs requests on other clients for "+sleepTime+" seconds.  (ban duration is "+dos2BlockTime+" seconds)");

                System.DateTime sleepStartTime=System.DateTime.UtcNow;
                while (System.DateTime.UtcNow-sleepStartTime < new System.TimeSpan(0, 0, sleepTime))
                {
                    KdcClientXbox360 randomClient=new KdcClientXbox360();
                    randomClient.ExecuteXmacs(true);
                    System.Threading.Thread.Sleep(250);
                }

                //we're 10 seconds before the ban ends... try a request, it should still be blocked
                Global.RO.Debug("Verifying ban has not expired yet.");
                try
                {
                    client.ExecuteXmacs(true);
                    throw new UnexpectedTestResultException("Request was unexpectedly accepted by xmacs.");
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                }

                //now wait for the ban to expire and verify a request works again
                Global.RO.Debug("Waiting for the temporary ban to expire.");
                System.Threading.Thread.Sleep(11*1000);

                client.ExecuteXmacs(true);
            }

            [TestCase, AsyncGroup(1), DVT, Description("Sign in 20 times, check we are banned next call")]
            class PC_DoS2_Trigger_1Interval : TestBase_PanoramaXmacs
            {
                override protected void RunTest()
                {
                    DisableRetryBehaviour=true;
                    // TODO: pull these values from the npdb
                    // kdcsvc_xmacs_DoS2_maxRequests = 20
                    // kdcsvc_xmacs_DoS2_interval = 60
                    // kdcsvc_xmacs_DoS2_blockingTime = 300 

                    uint maxRequests = 20;
                    uint reqnum;
                    for (reqnum = 0; reqnum < maxRequests; reqnum++)
                    {
                        DoPanoramaRequest(null);
                    }
                    // Gonna get banned
                    DoPanoramaRequest(E_NoResponse);

                    // Make sure we are still banned
                    System.Threading.Thread.Sleep(3000);
                    DoPanoramaRequest(E_NoResponse);

                    // Still banned?
                    System.Threading.Thread.Sleep(3000);
                    DoPanoramaRequest(E_NoResponse);
                }
            }

            [TestCase, AsyncGroup(1), Description("Sign in 20 times, sign in random clients quickly for 60 seconds, sign in original machine 20 times, check we are banned on next call")]
            class PC_DoS2_Trigger_2Interval : TestBase_PanoramaXmacs
            {
                override protected void RunTest()
                {
                    DisableRetryBehaviour=true;
                    // TODO: pull these values from the npdb
                    // kdcsvc_xmacs_DoS2_maxRequests = 20
                    // kdcsvc_xmacs_DoS2_interval = 60
                    // kdcsvc_xmacs_DoS2_blockingTime = 300 

                    uint maxRequests = 20;
                    uint interval = 60;
                    uint reqnum;
                    for (reqnum = 0; reqnum < maxRequests; reqnum++)
                    {
                        DoPanoramaRequest(null);
                    }
                    ro.Debug("Signed in pcid {0} {1} times", Hexer.tohex(ctx.PcId), maxRequests);

                    ro.Debug("Signing in random clients for {0} seconds...", interval);
                    DateTime start = DateTime.Now;
                    uint count = 0;
                    XmacsClient xmacs = new XmacsClient(new AuthContext(AuthContext.ClientTypes.Panorama));
                    while ((DateTime.Now - start).TotalSeconds < (interval + 1))
                    {
                        // Need a new ticket since the passport user name is the DoS2 key.  
                        // But we can re-use each one a couple of times.
                        if (xmacs == null || (count % 10) == 0)
                        {
                            xmacs = new XmacsClient(new AuthContext(AuthContext.ClientTypes.Panorama));
                            ctx.ClearPassport();
                            ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                        }
                        try
                        {
                            xmacs.SignInXmacs();
                            count++;
                        }
                        catch (ServerTestFramework.Utilities.TimeoutException)
                        {
                            Fail("Timed out for random client #{0}, pcid {1}", count, Hexer.tohex(xmacs.Context.PcId));
                            return;
                        }

                        System.Threading.Thread.Sleep(1000);
                    }

                    ro.Debug("Done. Signed in {0} clients. Now signing in our original one {1}+1 times.", count, maxRequests);
                    for (reqnum = 0; reqnum < maxRequests; reqnum++)
                    {
                        DoPanoramaRequest(null);
                    }
                    // Gonna get banned
                    DoPanoramaRequest(E_NoResponse);

                    // Make sure we are still banned
                    System.Threading.Thread.Sleep(3000);
                    DoPanoramaRequest(E_NoResponse);

                    // Still banned?
                    System.Threading.Thread.Sleep(3000);
                    DoPanoramaRequest(E_NoResponse);
                }
            }
        } //class Xmacs

        // -- askdc
        [TestGroup, AsyncThreadDelay(3000)]
        public class Askdc: TestNode
        {
            public override void PreRun()
            {
                //verify that anti-dos is actually enabled
                ValueCheck.Test("Askdc AntiDos-1 enabled", true, XkdcTestBaseGroup.settingAskdcDOSEnabled);
                //ValueCheck.Test("Askdc AntiDos-2 enabled", true, XkdcTestBaseGroup.settingAskdcDOS2Enabled); //This value is more than just this setting... investigate the right one later.  For not commenting out to allow test to run.
            }

            [TestCase, Description("Verifies that packet replays are ignored for machine requests.")]
            [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
            [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
            public void ReplayMachine(TestNode self)
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)self.MyValues[0];
                KdcClient client=new KdcClient(clientType);

                //initial normal request
                client.ExecuteAskdc(true);

                //now resend the exact same packet, it should be ignored
                try
                {
                    client.RetryLostPackets=false;
                    client.ExecuteAskdc(false);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Expected the packet replay to be ignored, but the request instead succeeded!");
            }

            [TestCase, Description("Verifies that packet replays are ignored for user requests.")]
            [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
            [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
            public void ReplayUser(TestNode self)
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)self.MyValues[0];
                KdcClient client=new KdcClient(clientType);

                //initial normal request
                client.CreateAskdcUserRequest(new KdcUser());
                client.ExecuteAskdc(true);

                //now resend the exact same packet, it should be ignored
                try
                {
                    client.RetryLostPackets=false;
                    client.ExecuteAskdc(false);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Expected the packet replay to be ignored, but the request instead succeeded!");
            }

            [TestCase, AsyncGroup(1)]
            class DoS_Create_1_SigninXenon : TestBase_Xenon_Askdc
            {
                override protected void RunTest()
                {
                    DisableRetryBehaviour=true;

                    Create(1);
                    SignIn(0, true);
                    try 
                    {
                        SignIn(0, true);
                        // If this succeeds, then we fail
                        Fail("Second signin succeeded");
                    }
                    catch (ServerTestFramework.Utilities.TimeoutException)
                    {
                        ro.Debug("Second signin timed out like expected");
                    }
                }
            }

            [TestCase, AsyncGroup(1)]
            class DoS_Create_1_SigninXenon_EncryptedPassport: TestNode
            {
                public override void Run()
                {
                    //auth machine
                    KdcClientXbox360 client=new KdcClientXbox360();
                    client.ExecuteXmacs(true);

                    client.CreateAskdcMachineRequest();
                    client.ExecuteAskdc(true);

                    //auth user once
                    KdcUser user=new KdcUser();
                    user.CreateUser(true);
                    client.CreateAskdcUserRequest(user);
                    client.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);

                    Global.RO.Debug("Sending request #1");
                    client.ExecuteAskdc(true);

                    //this second user auth be blocked since it is within 1 second
                    try 
                    {
                        client.RetryLostPackets=false;
                        Global.RO.Debug("Sending request #2");
                        client.ExecuteAskdc(true);
                        throw new UnexpectedTestResultException("Unexpectedly succeeded at signin.");
                    }
                    catch (ServerTestFramework.Utilities.TimeoutException)
                    {
                        Global.RO.Debug("Second request timed out like expected");
                    }
                }
            }

            [TestCase, AsyncGroup(1), Description("Machine only sign in, should trigger DoS1 cache. Expect error")]
            class PC_DoS_Machine : TestBase_PanoramaAskdc
            {
                override protected void RunTest()
                {
                    DisableRetryBehaviour=true;

                    SignInAskdc();
                    SignInAskdc(E_NoResponse);
                }
            }

            [TestCase, AsyncGroup(1), Description("Only sign in user, no machine. Expect success.")]
            class PC_DoS_User : TestBase_PanoramaAskdc
            {
                override protected void RunTest()
                {
                    DisableRetryBehaviour=true;

                    authContext.SetNewPassportUser(0);
                    SignInAskdc();
                    // Only sign in user.. see if it triggers the old DoS cache 
                    authContext.UsersMachine = null;
                    SignInAskdc();
                }
            }

            [TestGroup]
            public class DoS2: TestNode
            {
                public static DateTime lastDosTrigger;
                bool dos2EnabledBeforeRun=false;

                //setup dos2 state
                public override void PreRun()
                {
                    lastDosTrigger=System.DateTime.UtcNow;
                    dos2EnabledBeforeRun=XkdcTestBaseGroup.settingAskdcDOS2Enabled;
                    Suite.AlterAskdcIPAntiDos(true);
                }

                public override void PostRun()
                {
                    Suite.AlterAskdcIPAntiDos(dos2EnabledBeforeRun);

                    SleepTillBanPasses();
                }

                public static void SleepTillBanPasses()
                {
                    double timeSinceBan=(System.DateTime.UtcNow-lastDosTrigger).TotalSeconds;
                    if (timeSinceBan<=60 && timeSinceBan>=0)
                    {
                        int sleepMs=(60-(int)timeSinceBan)*1000+1000;
                        Global.RO.Debug("Sleeping "+(sleepMs/1000)+" seconds to wait for existing temp bans to pass.");
                        System.Threading.Thread.Sleep(sleepMs);
                    }
                }

                //dos2 cases
                [TestCase]
                public class VerifyNoBlockForNoEcho: TestNode
                {
                    public override void Run()
                    {
                        SleepTillBanPasses();

                        // TODO: pull these values from the npdb (these have changed)
                        // kdcsvc_askdc_DoS2_maxRequests = 60
                        // kdcsvc_askdc_DoS2_interval = 120
                        // kdcsvc_askdc_DoS2_blockingTime = 300 

                        // Alternate between several machine accounts, to avoid DoS1 cache (1 per second).

                        AuthContext []contexts=new AuthContext[100];
                        Global.RO.Debug("Creating {0} machine accounts...", contexts.Length);
                        for (int i=0; i<contexts.Length; ++i)
                        {
                            contexts[i]=new AuthContext(AuthContext.ClientTypes.Xenon);
                            XmacsClient xmacs = new XmacsClient(contexts[i]);
                            xmacs.EmulateClientBehavior=false;
                            xmacs.SignInXmacs();
                        }

                        uint maxRequests=600*2; //do twice the limit, we should never get temp-banned
                        for (uint reqnum=0; reqnum<maxRequests; ++reqnum)
                        {
                            if (reqnum%100==99 || reqnum>=maxRequests-3)
                            {
                                Global.RO.Debug("Doing request "+(reqnum+1)+"/"+maxRequests);
                            }

                            try
                            {
                                AskdcClient askdc=new AskdcClient(contexts[reqnum%contexts.Length]);
                                askdc.EmulateClientBehavior=false;
                                askdc.AutomaticallyRespondToEcho=false;
                                askdc.SignInAskdc();
                            }
                            catch (KerbErrException ke)
                            {
                                //only 0x19: Preauth Required, is expected
                                if (ke.KerbErr!=KerbErrCode.KDC_ERR_PREAUTH_REQUIRED)
                                {
                                    throw;
                                }
                            }

                            System.Threading.Thread.Sleep(8 + 1000/contexts.Length);
                        }
                    }
                }

                [TestCase, Ignore] //with 600 requests in 1 minute now, it's impossible to hit this in the PC case, since it is based on passport and dos1 prevents more than 1 per second
                class PC_DoS2_User_Trigger_1Interval : TestBase_PanoramaAskdc
                {
                    override protected void RunTest()
                    {
                        DisableRetryBehaviour=true;
                        SleepTillBanPasses();

                        // TODO: pull these values from the npdb
                        // kdcsvc_askdc_DoS2_maxRequests = 60
                        // kdcsvc_askdc_DoS2_interval = 120
                        // kdcsvc_askdc_DoS2_blockingTime = 300 
                        //
                        // If the old DoS cache throttles our machine request to once per second, 
                        // then we can't send requests any faster than that.  But doing 30 
                        // requests will take 30 seconds, which is the interval.. so we can't 
                        // really test the ASKDC DoS2 cache machine-only.. but we should be able 
                        // to with a user. this seems like an abnormal case, though.
                        //
                        // Alternate between several machine accounts, to avoid the XMACS DoS2 
                        // cache (20 request in 60 seconds) and the ASKDC machine DoS1 cache (1 
                        // per second).

                        XonlinepUser[] machines = new XonlinepUser[20];
                        ro.Debug("Creating {0} cached machine accounts...", machines.Length);
                        for (int i = 0; i < machines.Length; i++)
                        {
                            XmacsClient xmacs = new XmacsClient(new AuthContext(AuthContext.ClientTypes.Panorama));
                            xmacs.SignInXmacs();
                            machines[i] = (XonlinepUser)xmacs.Context.UsersMachine.Clone();
                        }

                        authContext.SetNewPassportUser(0);
                        uint maxRequests = 600;
                        uint reqnum;
                        for (reqnum = 0; reqnum < maxRequests; reqnum++)
                        {
                            ro.Debug("Signing in user #{0} with machine[{1}]...", reqnum, reqnum % machines.Length);
                            authContext.UsersMachine = machines[reqnum % machines.Length];
                            SignInAskdc();
                            System.Threading.Thread.Sleep(8+1000 / machines.Length);
                        }

                        lastDosTrigger=DateTime.UtcNow;

                        // Gonna get banned
                        System.Threading.Thread.Sleep(1000);
                        SignInAskdc(E_NoResponse);

                        // Make sure we are still banned
                        System.Threading.Thread.Sleep(6000);
                        SignInAskdc(E_NoResponse);

                        // Still banned?
                        System.Threading.Thread.Sleep(6000);
                        SignInAskdc(E_NoResponse);
                    }
                }

                [TestCase]
                class IPBlock : TestBase_Xkdc
                {
                    public IPBlock()
                    {
                        ClientType=AuthContext.ClientTypes.Xenon;
                    }

                    override protected void RunTest()
                    {
                        SleepTillBanPasses();
                        ResultCode = TEST_RESULTS.PASSED;

                        // TODO: pull these values from the npdb
                        // kdcsvc_askdc_DoS2_maxRequests = 60
                        // kdcsvc_askdc_DoS2_interval = 120
                        // kdcsvc_askdc_DoS2_blockingTime = 300 

                        // Alternate between several machine accounts, to avoid DoS1 cache (1 per second).

                        XmacsClient xmacs;
                        AuthContext []contexts=new AuthContext[100];
                        AuthContext freshContext=new AuthContext(AuthContext.ClientTypes.Xenon);
                        ro.Debug("Creating {0} machine accounts...", contexts.Length+1);
                        for (int i=0; i<contexts.Length; ++i)
                        {
                            contexts[i]=new AuthContext(AuthContext.ClientTypes.Xenon);
                            xmacs = new XmacsClient(contexts[i]);
                            xmacs.SignInXmacs();
                        }
                        xmacs = new XmacsClient(freshContext);
                        xmacs.SignInXmacs();

                        System.Threading.Thread.Sleep(5000); //rest a little to avoid timing issues with previous tests

                        uint maxRequests = 600;
                        uint reqnum;
                        ro.Debug("Signing in repeatedly over a spread of "+contexts.Length+" machines...");
                        for (reqnum = 0; reqnum < maxRequests; ++reqnum)
                        {
                            if (reqnum%100==99 || reqnum>maxRequests-5)
                            {
                                ro.Debug("Doing request "+(reqnum+1)+"/"+maxRequests);
                            }

                            AskdcClient askdc=new AskdcClient(contexts[reqnum%contexts.Length]);
                            askdc.EmulateClientBehavior=false;
                            askdc.SignInAskdc();

                            System.Threading.Thread.Sleep(15 + 1000/contexts.Length);
                        }

                        lastDosTrigger=DateTime.UtcNow;

                        //verify we're temp banned
                        System.Threading.Thread.Sleep(1000);
                        ro.Debug("Verifying temp ban...");
                        uint succeeded=0;
                        for (uint i=0; i<3; ++i)
                        {
                            AskdcClient askdc = new AskdcClient(freshContext);
                            askdc.EmulateClientBehavior=false;
                            try
                            {
                                askdc.SignInAskdc();
                                succeeded=i+1;
                                break;
                            }
                            catch (ServerTestFramework.Utilities.TimeoutException)
                            {
                            }

                            System.Threading.Thread.Sleep(6000);
                        }

                        if (succeeded!=0)
                        {
                            Fail("Unexpectedly succeeded at Askdc sign-in on try "+succeeded);
                        }
                    }
                }
            }
        } //class Askdc

        // -- xkdc
        [TestGroup, AsyncGroup(1)]
        public class Xkdc: TestNode
        {
            public override void PreRun()
            {
                //verify that anti-dos is actually enabled
                ValueCheck.Test("Xkdc AntiDos-1 enabled", true, XkdcTestBaseGroup.settingXkdcDOSEnabled);
                ValueCheck.Test("Xkdc AntiDos-2 enabled", true, XkdcTestBaseGroup.settingXkdcDOS2Enabled);
            }

            [TestCase, Description("Verifies that packet replays are ignored.")]
            [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
            [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
            public void Replay(TestNode self)
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)self.MyValues[0];
                KdcClient client=new KdcClient(clientType);

                //initial normal request
                client.ExecuteXkdc(true);

                //now resend the exact same packet, it should be ignored
                try
                {
                    client.RetryLostPackets=false;
                    client.ExecuteXkdc(false);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Expected the packet replay to be ignored, but the request instead succeeded!");
            }

            [TestCase, AsyncGroup(1)]
            class PC_DoS2_Trigger_1Interval : TestBase_PanoramaXkdc
            {
                override protected void RunTest()
                {
                    // TODO: pull these values from the npdb
                    // kdcsvc_xkdc_DoS2_maxRequests = 60
                    // kdcsvc_xkdc_DoS2_interval = 60
                    // kdcsvc_xkdc_DoS2_blockingTime = 300 

                    uint maxRequests = 60;
                    uint reqnum;

                    authContext.SetNewPassportUser(0);
                    System.Threading.Thread.Sleep(2000);
                    SignInAskdc();
                    Global.RO.Debug("Resting to let DoS timers calm down before we DoS ourself.");
                    System.Threading.Thread.Sleep(60000); //give us some breathing room.. this keeps getting DoS'd early when run along with other tests for some reason.

                    XkdcClient xkdc = new XkdcClient(authContext, null, true);
                    xkdc.EmulateClientRetryAndTimingBehavior=false;
                    XkdcClient.SetDefaults(authContext);

                    for (reqnum = 0; reqnum < maxRequests / 2; reqnum++)
                    {
                        ro.Debug("Sign-in #{0}", reqnum);
                        // 1 autodiscover, 1 site9999 non-autodiscover
                        xkdc.SetRequest(null, true);
                        xkdc.SignInXkdc();

                        xkdc.SetRequest(new uint[] { 20 }, false);
                        xkdc.SignInXkdc();
                    }

                    // Gonna get banned
                    try
                    {
                        xkdc.SetRequest(null, true);
                        xkdc.SignInXkdc();
                    }
                    catch (ServerTestFramework.Utilities.TimeoutException)
                    {
                        // this is good
                        return;
                    }
                    Fail("Unexpectedly succeeded XKDC sign-in");
                }
            }

            [TestCase, AsyncGroup(1)]
            class DoS2_Xkdc_Trigger_1Interval : TestBase_Xkdc
            {
                public DoS2_Xkdc_Trigger_1Interval()
                {
                    ClientType=AuthContext.ClientTypes.Xenon;
                }

                override protected void RunTest()
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    // TODO: pull these values from the npdb
                    // kdcsvc_xkdc_DoS2_maxRequests = 60
                    // kdcsvc_xkdc_DoS2_interval = 60
                    // kdcsvc_xkdc_DoS2_blockingTime = 300 

                    uint maxRequests = 60;
                    uint reqnum;
                    authContext=new AuthContext(AuthContext.ClientTypes.Xenon);
                    XkdcClient xkdc = new XkdcClient(authContext, null, true);
                    xkdc.EmulateClientRetryAndTimingBehavior=false;
                    XkdcClient.SetDefaults(authContext);

                    ro.Debug("Signing into the xkdc "+maxRequests+" times...");
                    for (reqnum = 0; reqnum < maxRequests / 2; reqnum++)
                    {
                        // 1 autodiscover, 1 site9999 non-autodiscover
                        xkdc.SetRequest(null, true);
                        xkdc.SignInXkdc();

                        xkdc.SetRequest(new uint[] { 20 }, false);
                        xkdc.SignInXkdc();

                        System.Threading.Thread.Sleep(250);
                    }

                    // Gonna get banned
                    ro.Debug("Checking that we're tempbanned now...");
                    try
                    {
                        xkdc.SetRequest(null, true);
                        xkdc.SignInXkdc();
                    }
                    catch (ServerTestFramework.Utilities.TimeoutException)
                    {
                        // this is good
                        return;
                    }
                    Fail("Unexpectedly succeeded XKDC sign-in");
                }
            }

            [TestCase, Ignore, Description("Enables kdcsvc_xkdc_ignoreDuplicateRequests then sends two requests at the exact same time... 1 should not get a response.")]
            class BlockDuplicateRequests: TestNode
            {
                bool settingEnabled=false;
                bool settingNeedsRestored=false;

                public override void PreRun()
                {
                    //get the current setting, then change it and refresh the config
                    settingEnabled=Global.XEnv.GetBoolSetting("kdcsvc_xkdc_ignoreDuplicateRequests");
                    if (!settingEnabled)
                    {
                        settingNeedsRestored=true;
                        Global.XEnv.OverrideSetting("kdcsvc", "ALL", "kdcsvc_xkdc_ignoreDuplicateRequests", "1", -1);
                        Suite.RefreshKDCsConfig();
                    }
                }

                public override void Run()
                {
                    //this behaviour is extremely time-sensitive... so try it several times... and if we see what we want one of the times, consider it good
                    //TODO: If we ever get SQL behavior injection for the KDC, making SQL calls latent will make this test much more reliable.
                    for (int i=0; i<3; ++i)
                    {
                        Global.RO.Debug("Try "+i+" of 3.  Setting up 2 contexts...");
                        //do up to the askdc request.  we don't want ourselves added to the xkdc's short-lived cache yet, since we want our request to take a moment.
                        //unfortunately we don't have a way to just build 2 requests and not send them yet... so lets get 2 contexts set up for the same machine.
                        AuthContext ctxA=new AuthContext(AuthContext.ClientTypes.Xenon);
                        XmacsClient xmacsA=new XmacsClient(ctxA);
                        xmacsA.SignInXmacs();
                        AskdcClient askdc=new AskdcClient(ctxA);
                        askdc.SignInAskdc();

                        System.Threading.Thread.Sleep(1300); //avoid askdc anti-dos

                        AuthContext ctxB=new AuthContext(AuthContext.ClientTypes.Xenon);
                        XmacsClient xmacsB=new XmacsClient(ctxB);
                        xmacsB.SignInXmacsWithMachinePuid(xmacsA.MachinePuid);
                        askdc=new AskdcClient(ctxB);
                        askdc.SignInAskdc();

                        //since our sign-in calls are blocking calls unfortunately.. spin up 2 threads to watch the clock like a hawk that try to fire of the requests at the same time.  count how many responses we get back.
                        //note that you need at least dual core machine for this to work reasonably well
                        Global.RO.Debug("Preparing to fling the 2 packets...");
                        responses=0;
                        responsesGood=0;
                        timeOuts=0;
                        fireTime=System.DateTime.UtcNow+new System.TimeSpan(0,0,1);
                        ThreadMaker.CreateThread(FireRequestThread, ctxA).Start();
                        ThreadMaker.CreateThread(FireRequestThread, ctxB).Start();

                        while (timeOuts+responses!=2)
                        {
                            System.Threading.Thread.Sleep(100);
                        }

                        Global.RO.Info("Got "+responses+" responses("+responsesGood+" good) and "+timeOuts+" timeouts.");
                        if (responses==1 && timeOuts==1)
                        {
                            return;
                        }

                        Global.RO.Error("Expected 1 response and 1 timeout.");
                    }

                    throw new UnexpectedTestResultException("Test failed after 3 attempts.");
                }

                System.DateTime fireTime;
                int responses;
                int responsesGood;
                int timeOuts;

                void FireRequestThread(object objCtx)
                {
                    //prepare...
                    AuthContext ctx=(AuthContext)objCtx;
                    XkdcClient xkdc=new XkdcClient(ctx);
                    xkdc.EmulateClientRetryAndTimingBehavior=false;
                    xkdc.SetRequest(new uint[0], true);

                    //fire on the mark!
                    while (System.DateTime.UtcNow<fireTime)
                    {
                        System.Threading.Thread.Sleep(0); //yield but don't give up the time
                    }

                    try
                    {
                        xkdc.SignInXkdc();
                        System.Threading.Interlocked.Increment(ref responses);
                        System.Threading.Interlocked.Increment(ref responsesGood);
                    }
                    catch (ServerTestFramework.Utilities.TimeoutException)
                    {
                        System.Threading.Interlocked.Increment(ref timeOuts);
                    }
                    catch (Exception e)
                    {
                        System.Threading.Interlocked.Increment(ref responses);
                        Global.RO.Warn("Exception from xkdc sign in: "+e);
                    }
                }

                public override void PostRun()
                {
                    //restore the setting
                    if (settingNeedsRestored)
                    {
                        Global.XEnv.DeleteOverrideSetting("kdcsvc", "ALL", "kdcsvc_xkdc_ignoreDuplicateRequests", -1);
                        Suite.RefreshKDCsConfig();
                    }
                }
            }
        } //class Xkdc
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuzzTests.cs ===
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    [TestGroup, Ignore, Description("Temporary playground for working on fuzzing, these are not regression tests.")]
    public class FuzzTests: TestNode
    {
        public static void VerifyKdcIsStillAlive()
        {
            try
            {
                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateXmacsRequest();
                kdc.ExecuteXmacs(true);
            }
            catch (System.Exception e)
            {
                throw new UnexpectedTestResultException("Got exception while verifying that the KDC is still alive.  Pleave verify it did not crash.\n"+e);
            }
        }

        [TestCase]
        public void Xbox360Xmacs_MachineOnly_NoRecalcAfter()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateXmacsRequest();
            kdc.XmacsRequest.Input.GeneratePreauths();
            kdc.XmacsRequest.SetRequest();
            kdc.XmacsRequest.ConstructRequest();

            AsnFuzzing.Fuzz(kdc.XmacsRequest);

            kdc.ExecuteXmacs(false);
        }

        [TestCase]
        public void Xbox360Askdc_MachineOnly_NoRecalcAfter()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.ExecuteXmacs(true);

            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.GeneratePreauths();
            kdc.AskdcRequest.SetRequest();
            kdc.AskdcRequest.ConstructRequest();

            AsnFuzzing.Fuzz(kdc.AskdcRequest);

            kdc.ExecuteAskdc(false);
        }

        [TestCase]
        public void Xbox360Xkdc_MachineOnly_NoRecalcAfter()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.ExecuteAskdc(true);

            kdc.CreateXkdcRequest();
            kdc.XkdcRequest.Input.GeneratePreauths();
            kdc.XkdcRequest.SetRequest();
            kdc.XkdcRequest.ConstructRequest();

            AsnFuzzing.Fuzz(kdc.XkdcRequest);

            kdc.ExecuteXkdc(false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncXKDC.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(250), AsyncThreadCount(10)]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XKDCGroup : XkdcTestBaseGroup
    {
        //static protected KerbClient kcl = new KerbClient();

        /// [Test_Xkdc_Client_Skew]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=base
        /// stoponfail=yes
        [TestCase, Description("Test_Xkdc_Client_Skew")]
        class Test_Xkdc_Client_Skew : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                try
                {
                    ExpectedServices = new uint[] {(uint)XOService.Base_Subscription};
                    ExpectedHRs = new uint[] { 0 };
                    SignInXkdc();
                }
                catch(KerbErrException ke)
                {
                    if(ke.KerbErr == KerbErrCode.KRB_AP_ERR_SKEW)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        /// [Test_Xkdc_Machine_Logon_Basic]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=base
        /// stoponfail=yes
        [TestCase, Description("Machine logon: base")]
        class Test_Xkdc_Machine_Logon_Basic : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetMachineST(new uint[] {(uint)XOService.Base_Subscription},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_Machine_Logon_Max]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=uint.max
        /// stoponfail=yes
        [TestCase, Description("Max Service ID Test: all services set to maxint")]
        class Test_Xkdc_Machine_Logon_Max : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs;
                uint[] Services;

                // SPECIAL XENON CASE
                // We can only request 4 DWORD services now, so this test is rather different.
                if (IsXenonClient)
                {
                    ExpectedHRs = new uint[4];
                    Services = new uint[4] {(uint)uint.MaxValue,
                                               (uint)uint.MaxValue,
                                               (uint)uint.MaxValue,
                                               (uint)uint.MaxValue };
                }
                else
                {
                    ExpectedHRs = new uint[12];
                    Services = new uint[] {(uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue,
                                              (uint)uint.MaxValue};
                }
                for(uint i = 0; i < ExpectedHRs.Length; i++)
                {
                    ExpectedHRs[i] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                }
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(
                    Services,
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Basic]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// services=useraccount, base, presence
        /// stoponfail=yes
        [TestCase, Description("User logon test: useraccount, base, presence")]
        class Test_Xkdc_User_1_Logon_Basic : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account,
                                (uint)XOService.Base_Subscription,
                                (uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Expire]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=base
        /// kerberr=KDC_ERR_TGT_REVOKED
        [TestCase, Description("User logon test, ticket expired")]
        class Test_Xkdc_Machine_Logon_Expire : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;

                int[] timeAdd = new int[] {-290, 290, -310, 310, -5401, 5401, -24*60*60, 24*60*60, -365*24*60*60, 365*24*60*60};

                for(uint i=0; i<timeAdd.Length; ++i)
                {
                    bool expired=(timeAdd[i]<-300);
                    bool succeeded=false;

                    SetDefaults();
                    authContext.ClearXmacs();
                    AskdcClient askdc = new AskdcClient(authContext);
                    askdc.SignInAskdc();
                    AuthClientBase.DLL_AddToTicketTimeRemaining(
                        ServiceKeys.GetServiceKey(ServiceKeys.Key_KdcXboxCom),
                        authContext.CombinedTgt.tgtToken,
                        timeAdd[i]);
                    ExpectedServices = new uint[] {(uint)XOService.Base_Subscription};
                    ExpectedHRs = new uint[] { 0 };

                    try
                    {
                        SignInXkdc();

                        //only gets here on success
                        succeeded=true;
                        if (expired)
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                    catch(KerbErrException ke)
                    {
                        if (expired)
                        {
                            if(ke.KerbErr != KerbErrCode.KDC_ERR_TGT_REVOKED)
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                        }

                        Global.RO.Debug("Added "+timeAdd[i]+"s to tgt: "+ke.KerbErr);
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error("Unexpected exception: "+e.Message);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    if (succeeded) Global.RO.Debug("Added "+timeAdd[i]+"s to tgt: Got ticket.");
                }
            }
        }
        
        /// [Test_Xkdc_Machine_WrongTime_01..04]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=base
        /// timeskew=(anything over +/-300 will get KRB_AP_ERR_SKEW)
        /// kerberr=KRB_AP_ERR_SKEW
        [TestCase, AsyncGroup(0), Description("Time skew for service request")]
        class Test_Xkdc_Machine_WrongTime : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                try
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    AskdcClient askdc = new AskdcClient(authContext);
                    askdc.SignInAskdc();

                    long[] skew = new long[] {-240, 240, -360, 360, -8*60*60, 8*60*60, -24*60*60, 24*60*60, -365*24*60*60, 365*24*60*60};
                    for(uint i = 0; i < skew.Length; ++i)
                    {
                        try
                        {
                            authContext.ClearXkdc();
                            AuthClientBase.DLL_SetTimeSkew(skew[i]);
                            ExpectedServices = new uint[] {(uint)XOService.Base_Subscription};
                            ExpectedHRs = new uint[] { 0 };
                            SignInXkdc();
                            Global.RO.Debug("Time skew of "+skew[i]+"s: Request succeeded.");
                            // No exception thrown, so we succeeded without an error
                            if (skew[i] >= -300 && skew[i] <= 300)
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                            else
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                                return;
                            }
                        }
                        catch(KerbErrException ke)
                        {
                            Global.RO.Debug("Time skew of "+skew[i]+"s: Request failed with code "+ke.KerbErr);
                            if(ke.KerbErr == KerbErrCode.KRB_AP_ERR_SKEW && (skew[i] < -300 || skew[i] > 300))
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                            else
                            {
                                ResultCode = TEST_RESULTS.FAILED;
                                return;
                            }
                        }
                        catch (Exception e)
                        {
                            Global.RO.Error("Unexpected exception: "+e.Message);
                            ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                } 
                finally  //put us back to a good state if we fail here
                {
                    AuthClientBase.DLL_SetTimeSkew(0);
                }
            }
        }

        /// Run a good portion of the matrix but split out a few in order to keep unnescessary test cases down
        /// [Test_Xkdc_Machine_Logon_ServiceMatrix_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// servicesmatrix=presence, message, autoupdate, base, matchmaking, feedback
        /// grantedmatrix=no, yes, yes, yes, no, no
        /// subcases=63
        [TestCase, Description("Machine logon: -presence, message, autoupdate, base, -matchmaking, -feedback")]
        class Test_Xkdc_Machine_Logon_ServiceMatrix_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Presence
                ExpectedHRs[4] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // matchmaking
                ExpectedHRs[5] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Feedback
                ResultCode = GetMachineST(new uint[] {(uint)XOService.PresNotification,
                                                         (uint)XOService.StringService,
                                                         (uint)XOService.Auto_Update,
                                                         (uint)XOService.Base_Subscription,
                                                         (uint)XOService.Matchmaking,
                                                         (uint)XOService.Feedback},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_Machine_Logon_ServiceMatrix_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// servicesmatrix=feedback, base, useraccount
        /// grantedmatrix=no, yes, yes
        /// subcases=7
        [TestCase, Description("Machine logon: -feedback, base, useraccount")]
        class Test_Xkdc_Machine_Logon_ServiceMatrix_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Feedback
                ResultCode = GetMachineST(new uint[] {(uint)XOService.Feedback,
                                                         (uint)XOService.Base_Subscription,
                                                         (uint)XOService.User_Account},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_Machine_Logon_ServiceMatrix_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// servicesmatrix=billing, message, stats
        /// grantedmatrix=no, yes, no
        /// subcases=7
        [TestCase, Description("Machine logon: -billing, message, -stats")]
        class Test_Xkdc_Machine_Logon_ServiceMatrix_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Billing
                ExpectedHRs[2] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Stats
                ResultCode = GetMachineST(new uint[] {(uint)XOService.Billing_Offering,
                                                       (uint)XOService.StringService,
                                                       (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_Machine_Logon_NoServices_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=
        /// kerberr=KDC_ERR_NO_RESPONSE
        [TestCase, Description("Get machine ST with 1 service with id 0")]
        class Test_Xkdc_Machine_Logon_NoServices_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;

                // This test was changed in Xenon M2. This will now time out instead of returning an error.
                // I think we can leave the old behavior in and wrap it in a try/catch block for ServerTestFramework.Utilities.TimeoutException
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    uint[] ExpectedHRs = new uint[12];
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE; // Invalid
                    GetMachineST(new uint[] { 0 }, null,  ExpectedHRs, HResult.S_OK);
                }
                catch(KerbErrException ke)
                {
                    if(ke.KerbErr == KerbErrCode.KRB_ERR_GENERIC)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// [Test_Xkdc_Machine_Logon_NoServices_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=
        /// kerberr=KDC_ERR_NO_RESPONSE
        [TestCase, Description("Get machine ST with no services")]
            class Test_Xkdc_Machine_Logon_NoServices_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;

                // This test was changed in Xenon M2. This will now time out instead of returning an error.
                // I think we can leave the old behavior in and wrap it in a try/catch block for ServerTestFramework.Utilities.TimeoutException
                ResultCode = TEST_RESULTS.PASSED;
                try
                {
                    uint[] ExpectedHRs = new uint[12];
                    GetMachineST(new uint[] { }, null,  ExpectedHRs, HResult.S_OK);
                }
                catch(KerbErrException ke)
                {
                    if(ke.KerbErr == KerbErrCode.KRB_ERR_GENERIC)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// [Test_Xkdc_Machine_Logon_NonexistantMatrix_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// servicesmatrix=stats, fake, base
        /// grantedmatrix=no, nonexistant, yes
        /// subcases=7
        [TestCase, Description("Machine logon: -stats, -fake (9999), base")]
        class Test_Xkdc_Machine_Logon_NonexistantMatrix_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Stats
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Fake
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ statis, base_sub, 9999 ], thus indices 1 & 2 flip
                    uint temp = ExpectedHRs[2];
                    ExpectedHRs[2] = ExpectedHRs[1];
                    ExpectedHRs[1] = temp;
                }
                ResultCode = GetMachineST(new uint[] {(uint)XOService.Stats,
                                                                           9999,
                                                                           (uint)XOService.Base_Subscription},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// ;Run a good portion of the matrix but split out a few in order to keep unnescessary test cases down
        /// [Test_Xkdc_User_1_Logon_ServiceMatrix_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// servicesmatrix=presence, message, autoupdate, base, matchmaking, feedback
        /// grantedmatrix=yes, yes, yes, yes, yes, yes
        /// subcases=63
        [TestCase, Description("User logon: presence, message, autoupdate, base, matchmaking, feedback")]
        class Test_Xkdc_User_1_Logon_ServiceMatrix_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.PresNotification,
                                (uint)XOService.StringService,
                                (uint)XOService.Auto_Update,
                                (uint)XOService.Base_Subscription,
                                (uint)XOService.Matchmaking,
                                (uint)XOService.Feedback},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Logon_ServiceMatrix_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// servicesmatrix=feedback, base, useraccount
        /// grantedmatrix=yes, yes, yes
        /// subcases=7
        [TestCase, Description("User logon: feedback, base, useraccount")]
        class Test_Xkdc_User_1_Logon_ServiceMatrix_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.Feedback,
                    (uint)XOService.Base_Subscription,
                    (uint)XOService.User_Account},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Logon_ServiceMatrix_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7b
        /// servicesmatrix=billing, message, stats
        /// grantedmatrix=yes, yes, yes
        /// subcases=7
        [TestCase, Description("User logon: billing, message, stats")]
        class Test_Xkdc_User_1_Logon_ServiceMatrix_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7b"),
                    new uint[] {(uint)XOService.Billing_Offering,
                                (uint)XOService.StringService,
                                (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Logon_NoServices_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7c
        /// services=
        /// kerberr=KDC_ERR_NO_RESPONSE
        [TestCase, Description("User logon: 1 service with id 0")]
        class Test_Xkdc_User_1_Logon_NoServices_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;

                // This test was changed in Xenon M2. This will now time out instead of returning an error.
                // I think we can leave the old behavior in and wrap it in a try/catch block for ServerTestFramework.Utilities.TimeoutException
                try 
                {
                    uint[] ExpectedHRs = new uint[12];
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE; // Invalid
                    ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7c"),
                        new uint[] {0},
                        null,
                        ExpectedHRs,
                        HResult.S_OK,
                        's');
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// [Test_Xkdc_User_1_Logon_NoServices_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7c
        /// services=
        /// kerberr=KDC_ERR_NO_RESPONSE
        [TestCase, Description("User logon: no services")]
            class Test_Xkdc_User_1_Logon_NoServices_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;

                // This test was changed in Xenon M2. This will now time out instead of returning an error.
                // I think we can leave the old behavior in and wrap it in a try/catch block for ServerTestFramework.Utilities.TimeoutException
                try 
                {
                    uint[] ExpectedHRs = new uint[12];
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE; // Invalid
                    ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7c"),
                        new uint[] {},
                        null,
                        ExpectedHRs,
                        HResult.S_OK,
                        's');
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// [Test_Xkdc_User_1_Logon_NonexistantMatrix_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7d
        /// servicesmatrix=stats, fake, base
        /// grantedmatrix=yes, nonexistant, yes
        /// subcases=7
        [TestCase, Description("User logon: stats, -fake (9999), base")]
        class Test_Xkdc_User_1_Logon_NonexistantMatrix_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;  // Fake service
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ stats, base_sub, 9999 ], thus indices 1 & 2 flip
                    uint temp = ExpectedHRs[2];
                    ExpectedHRs[2] = ExpectedHRs[1];
                    ExpectedHRs[1] = temp;
                }
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7d"),
                    new uint[] {(uint)XOService.Stats,
                               9999,
                              (uint)XOService.Base_Subscription},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// ;Run a good portion of the matrix but split out a few in order to keep unnescessary test cases down
        /// [Test_Xkdc_User_Multi_Logon_ServiceMatrix_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a, xktuser7b, xktuser7c, xktuser7d
        /// servicesmatrix=presence, message, autoupdate, base, matchmaking, feedback
        /// grantedmatrix=yes, yes, yes, yes, yes, yes
        /// subcases=63
        [TestCase, Description("User logon 4: presence, message, autoupdate, base, matchmaking, feedback")]
            class Test_Xkdc_User_Multi_Logon_ServiceMatrix_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                String[] users = new String[4];
                users[0] = "xktuser7a";
                users[1] = "xktuser7b";
                users[2] = "xktuser7c";
                users[3] = "xktuser7d";
                uint[] Services = new uint[] {(uint)XOService.PresNotification,
                                                 (uint)XOService.StringService,
                                                 (uint)XOService.Auto_Update,
                                                 (uint)XOService.Base_Subscription,
                                                 (uint)XOService.Matchmaking,
                                                 (uint)XOService.Feedback};
                // Verify that each user can in fact log in with these services
                foreach(String user in users)
                {
                    UserTimer.AccessSharedUser(user);
                    if(GetUserST(user, Services, null, ExpectedHRs, HResult.S_OK, 's') == TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_Multi_Logon_ServiceMatrix_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a, xktuser7b
        /// servicesmatrix=feedback, base, useraccount
        /// grantedmatrix=yes, yes, yes
        /// subcases=7
        [TestCase, Description("User logon 4: feedback, base, useraccount")]
        class Test_Xkdc_User_Multi_Logon_ServiceMatrix_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                String[] users = new String[2];
                users[0] = "xktuser7a";
                users[1] = "xktuser7b";
                uint[] Services = new uint[] {(uint)XOService.Feedback,
                                                 (uint)XOService.Base_Subscription,
                                                 (uint)XOService.User_Account};
                // Verify that each user can in fact log in with these services
                foreach(String user in users)
                {
                    UserTimer.AccessSharedUser(user);
                    if(GetUserST(user, Services, null, ExpectedHRs, HResult.S_OK, 's') == TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_Multi_Logon_ServiceMatrix_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7b, xktuser7c, xktuser7d
        /// servicesmatrix=billing, message, stats
        /// grantedmatrix=yes, yes, yes
        /// subcases=7
        [TestCase, Description("User logon 4: billing, message, stats")]
        class Test_Xkdc_User_Multi_Logon_ServiceMatrix_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                String[] users = new String[3];
                users[0] = "xktuser7b";
                users[1] = "xktuser7c";
                users[2] = "xktuser7d";
                uint[] Services = new uint[] {(uint)XOService.Billing_Offering,
                                                 (uint)XOService.StringService,
                                                 (uint)XOService.Stats};
                // Verify that each user can in fact log in with these services
                foreach(String user in users)
                {
                    UserTimer.AccessSharedUser(user);
                    if(GetUserST(user, Services, null, ExpectedHRs, HResult.S_OK, 's') == TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_Multi_Logon_NoServices_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7c, xktuser7b, xktuser7d
        /// services=
        /// kerberr=KDC_ERR_NO_RESPONSE
        [TestCase, Description("User logon 4: no services")]
        class Test_Xkdc_User_Multi_Logon_NoServices_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;

                // This test was changed in Xenon M2. This will now time out instead of returning an error.
                // I think we can leave the old behavior in and wrap it in a try/catch block for ServerTestFramework.Utilities.TimeoutException
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE; // Invalid
                String[] users = new String[3];
                users[0] = "xktuser7c";
                users[1] = "xktuser7b";
                users[2] = "xktuser7d";
                uint[] Services = new uint[] {0};
                // Verify that each user can in fact log in with these services
                foreach(String user in users)
                {
                    UserTimer.AccessSharedUser(user);
                    try
                    {
                        if(GetUserST(user, Services, null, ExpectedHRs, HResult.S_OK, 's') == TEST_RESULTS.PASSED)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.FAILED;
                            return;
                        }
                    }
                    catch (ServerTestFramework.Utilities.TimeoutException)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_Multi_Logon_NonexistantMatrix_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7d, xktuser7c, xktuser7b, xktuser7a
        /// servicesmatrix=stats, fake, base
        /// grantedmatrix=yes, nonexistant, yes
        /// subcases=7
        [TestCase, Description("User logon 4: stats, -fake (9999), base")]
        class Test_Xkdc_User_Multi_Logon_NonexistantMatrix_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Invalid
                String[] users = new String[4];
                users[0] = "xktuser7d";
                users[1] = "xktuser7c";
                users[2] = "xktuser7b";
                users[3] = "xktuser7a";
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ statis, base_sub, 9999 ], thus indices 1 & 2 flip
                    uint temp = ExpectedHRs[2];
                    ExpectedHRs[2] = ExpectedHRs[1];
                    ExpectedHRs[1] = temp;
                }
                uint[] Services = new uint[] {(uint)XOService.Stats,
                                                 9999,
                                                 (uint)XOService.Base_Subscription};
                // Verify that each user can in fact log in with these services
                foreach(String user in users)
                {
                    UserTimer.AccessSharedUser(user);
                    if(GetUserST(user, Services, null, ExpectedHRs, HResult.S_OK, 's') == TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_1_Logon_LotsOfServices]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// services=presence, message, autoupdate, base, useraccount, matchmaking, stats, feedback, billing, tou, nameres, signature
        /// granted=yes, yes, yes, yes, yes, yes, yes, yes, yes, yes, false, yes
        [TestCase, Description("User logon: 12 services")]
        class Test_Xkdc_User_1_Logon_LotsOfServices : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[10] = HResult.S_FALSE;  // Name Resolution // False (S_FALSE)
                ExpectedHRs[11] = HResult.S_FALSE;  // Signature (seems like we can't request it with the rest of these)
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {/*(uint)XOService.PresNotification,
                                   (uint)XOService.StringService,
                                   (uint)XOService.Auto_Update,
                                   (uint)XOService.Base_Subscription,
                                   (uint)XOService.User_Account,
                                   (uint)XOService.Matchmaking,
                                   (uint)XOService.Stats,
                                   (uint)XOService.Feedback,
                                   (uint)XOService.Billing_Offering,
                                   (uint)XOService.Tou,
                                   (uint)XOService.Name_Resolution,*/
                                   (uint)XOService.Signature_Server},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Logon_13_Services]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// services=presence, message, autoupdate, base, useraccount, matchmaking, stats, feedback, billing, tou, nameres, signature, name_verification
        /// Should time out
        [TestCase, Ignore, Description("User logon: 13 services")]
        class Test_Xkdc_User_1_Logon_13_Services : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[13];
                ExpectedHRs[10] = HResult.S_FALSE;  // Name Resolution // False (S_FALSE)
                try
                {
                    ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                        new uint[] {(uint)XOService.PresNotification,
                                       (uint)XOService.StringService,
                                       (uint)XOService.Auto_Update,
                                       (uint)XOService.Base_Subscription,
                                       (uint)XOService.User_Account,
                                       (uint)XOService.Matchmaking,
                                       (uint)XOService.Stats,
                                       (uint)XOService.Feedback,
                                       (uint)XOService.Billing_Offering,
                                       (uint)XOService.Tou,
                                       (uint)XOService.Name_Resolution,
                                       (uint)XOService.Signature_Server},
                        null,
                        ExpectedHRs,
                        HResult.S_OK,
                        's');
                }
                catch(Exception e)
                {
                    ro.Debug("Got exception: " + e.Message);
                    ResultCode = TEST_RESULTS.PASSED;
                }

                // We only accept 12 services so we bail
                if(ResultCode == TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        /// [Test_Xkdc_User_1_Logon_17_Services]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// services=presence, message, autoupdate, base, useraccount, matchmaking, stats, feedback, billing, tou, nameres, signature
        /// Should time out
        [TestCase, Description("User logon: 17 services")]
        class Test_Xkdc_User_1_Logon_17_Services : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[17];
                ExpectedHRs[10] = HResult.S_FALSE;  // Name Resolution // False (S_FALSE)
                // Anything over 16 should throw an exception
                try
                {
                    // SPECIAL XENON CASE
                    // In the Xbox case, this test throws an exception, thus it doesn't matter 
                    // what the ExpectedHRs are set to.  They never get verified.  
                    // In the Xenon case, this test succeeds, thus it DOES matter what the result
                    // is.  Max services and 17 services are already covered in the Xenon specific
                    // tests, so we can skip this here.
                    if (IsXenonClient)
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        return;
                    }
                    ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                        new uint[] {(uint)XOService.PresNotification,
                                       (uint)XOService.StringService,
                                       (uint)XOService.Auto_Update,
                                       (uint)XOService.Base_Subscription,
                                       (uint)XOService.User_Account,
                                       (uint)XOService.Matchmaking,
                                       (uint)XOService.Stats,
                                       (uint)XOService.Feedback,
                                       (uint)XOService.Billing_Offering,
                                       (uint)XOService.Tou,
                                       (uint)XOService.Name_Resolution,
                                       (uint)XOService.Signature_Server,
                                       (uint)XOService.Arbitration,
                                       (uint)XOService.Base_Subscription,
                                       (uint)XOService.Lists,
                                       (uint)XOService.MaxService},
                        null,
                        ExpectedHRs,
                        HResult.S_OK,
                        's');
                }
                catch(Exception)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        //simple test that an askdc+xkdc request works on a reset machine account
        [TestCase, Description("test that an askdc+xkdc request works on a reset machine account")]
        class Test_Xkdc_ResetMachineAccount: TestBase_XboxOld
        {
            override protected void RunTest()
            {
                authContext=null;
                SetDefaults();

                XmacsClient xmacs=new XmacsClient(authContext);
                xmacs.SignInXmacs(); //initial machine account
                xmacs.SignInXmacs(); //reset machine account

                SignInXkdc();
            }
        }

        //do a request with a bad title id, no users
        [TestCase, Description("xkdc machine only request with a bad title id")]
        class Test_Xkdc_Machine_BadTitle: TestBase_XboxOld
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0xbad71713, 1, 1);
                XkdcClient xkdc=new XkdcClient(authContext);
                xkdc.SignInXkdc();

                ValueCheck.Test("Overall HR for request", HResult.XONLINE_E_LOGON_UNKNOWN_TITLE, authContext.GetXkdcResult().ServiceHR);
            }
        }

        [TestCase, Description("Test that we do not get a service for an offer that grants a service, which is not of a subscription type but that we have a subscription to")]
        class NonSubscriptionOfferSubscription : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0]=HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktnewsub8"),
                    new uint[] {8015},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        [TestCase, Description("User has a subscription of xbox.com type which grants service 8015")]
        class XboxComOnlySub : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                bVerifyHRs=true;
                uint[] ExpectedHRs = new uint[12];
                //As best as I can tell, the kdc blindly uses offers for all console types, regardless of the console type field in the offer
                //ExpectedHRs[0]=HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;

                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktnewsub9"),
                    new uint[] {8015},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        [TestCase, Description("User has a subscription of xenon type which grants service 8015")]
        class XenonOnlySub : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                bVerifyHRs=true;
                uint[] ExpectedHRs = new uint[12];
                //As best as I can tell, the kdc blindly uses offers for all console types, regardless of the console type field in the offer
                //if (!IsXenonClient)
                //{
                //    ExpectedHRs[0]=HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                //}

                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktnewsub10"),
                    new uint[] {8015},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        [TestCase, Description("sign in witha ticket that's older than the user's reset date")]
        class ResetDateAfterTgtDate: TestBase_XboxOld
        {
            override protected void RunTest()
            {
                authContext=null;
                SetDefaults();

                //sign into the askdc with the user
                ServerTestFramework.Database.UserEditor user=ServerTestFramework.Database.UserEditor.CreateNew();
                authContext.SetUser(user, 0);

                AskdcClient askdc=new AskdcClient(authContext);
                askdc.SignInAskdc();

                //now change their reset date to be in the future.
                user.ResetDate=System.DateTime.UtcNow+new System.TimeSpan(1,0,0);

                //and now sign in, we should get "revoked".
                XkdcClient xkdc=new XkdcClient(authContext);

                try
                {
                    xkdc.SignInXkdc();
                }
                catch (KerbErrException ke)
                {
                    if(ke.KerbErr!=KerbErrCode.KDC_ERR_TGT_REVOKED)
                    {
                        throw;
                    }
                    return;
                }

                throw new UnexpectedTestResultException("Expected request to fail.");
            }
        }

        [TestCase, Description("Test event id 54663, puid in preauth but not in TGT")]
        class MismatchedPuidsInTgtAndPreauth_NoValidUsers : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                authContext=null;
                SetDefaults();

                //sign into the askdc with the user
                ServerTestFramework.Database.UserEditor user=ServerTestFramework.Database.UserEditor.CreateNew();
                authContext.SetUser(user, 0);

                AskdcClient askdc=new AskdcClient(authContext);
                askdc.SignInAskdc();

                //change which user puids will be used in the preauth in the request. not 
                //changing the tgt puids.
                if (authContext.ServiceCtxXe != null)
                {
                    authContext.ServiceCtxXe.UserID[0] = 1; 
                }
                if (authContext.ServiceCtxXbox != null)
                {
                    authContext.ServiceCtxXbox.UserID[0] = 1; 
                }

                XkdcClient xkdc=new XkdcClient(authContext);

                try
                {
                    xkdc.SignInXkdc();
                }
                catch (KerbErrException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Did not expect request to succeed.");

                //BUG - Xbox360 Console Software 176947: We changed the behaviour here.  We used to expect a machine-only ticket with userHRs set to 0x80151200.  Now we block the entire request.
            }
        }


        [TestCase, Description("Test event id 54663, puid in preauth but not in TGT")]
        class MismatchedPuidsInTgtAndPreauth_1ValidUser : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                authContext=null;
                SetDefaults();

                //sign into the askdc with the user
                ServerTestFramework.Database.UserEditor user=ServerTestFramework.Database.UserEditor.CreateNew();
                authContext.SetUser(user, 0);
                user=ServerTestFramework.Database.UserEditor.CreateNew();
                authContext.SetUser(user, 1);
                user=ServerTestFramework.Database.UserEditor.CreateNew();
                authContext.SetUser(user, 2);
                user=ServerTestFramework.Database.UserEditor.CreateNew();
                authContext.SetUser(user, 3);

                AskdcClient askdc=new AskdcClient(authContext);
                askdc.SignInAskdc();

                //change which user puids will be used in the preauth in the request. not 
                //changing the tgt puids.
                if (authContext.ServiceCtxXe != null)
                {
                    authContext.ServiceCtxXe.UserID[0] = 0;  // valid
                    authContext.ServiceCtxXe.UserID[1] = 1;
                    authContext.ServiceCtxXe.UserID[2] = 2;
                    authContext.ServiceCtxXe.UserID[3] = 0;  // valid
                }
                if (authContext.ServiceCtxXbox != null)
                {
                    authContext.ServiceCtxXbox.UserID[0] = 0;  // valid
                    authContext.ServiceCtxXbox.UserID[1] = 1;
                    authContext.ServiceCtxXbox.UserID[2] = 2;
                    authContext.ServiceCtxXbox.UserID[3] = 0;  // valid
                }

                XkdcClient xkdc=new XkdcClient(authContext);

                try
                {
                    xkdc.SignInXkdc();
                }
                catch (KerbErrException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Did not expect request to succeed.");

                //BUG - Xbox360 Console Software 176947: We changed the behaviour here.  We used to expect a machine-only ticket with the relevent userHRs set to 0x80151200.  Now we block the entire request.
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\krb5.cpp ===
#include "xonp.h"


//ASN1module_t KRB5_Module = NULL;

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val);
static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(const PKERB_LAST_REQUEST_Seq *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val);
static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val);
static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val);
static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val);
static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val);
static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val);
static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val);
static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(const KERB_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val);
static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val);
static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val);
static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val);
static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val);
static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val);
static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val);
static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val);
static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val);
static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val);
static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val);
static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val);
static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[51] = {
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_PREAUTH_DATA_LIST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_PRIV,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_CRED,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTION_KEY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_CHECKSUM,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_ETYPE_INFO,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGT_REQUEST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PKCS_SIGNATURE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REP,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_REPLY_KEY_PACKAGE2,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_KDC_DH_KEY_INFO,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REQ,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_DH_PARAMTER,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TYPED_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_SERV_REFERRAL,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PAC_REQUEST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_CHANGE_PASSWORD_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ERROR_METHOD_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_EXT_ERROR,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_FOR_USER,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST_EX, //28
    (ASN1EncFun_t) ASN1Enc_KERB_TICKET, // 29
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTHENTICATOR, // 31
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REQUEST, // 32
#ifndef XONLINE_FEATURE_VXBOX
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
#else
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
#endif
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SAFE_MESSAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PRIV_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_CRED, // 37
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGT_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AUTH_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_COMPOUND_IDENTITY,
    (ASN1EncFun_t) ASN1Enc_KERB_MARSHALLED_REQUEST_BODY, // 42
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_AS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REP2,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REQUEST, //48
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REQUEST, //49
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REQ2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[51] = {
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_PREAUTH_DATA_LIST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_PRIV,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTION_KEY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CHECKSUM,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_ETYPE_INFO,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGT_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PKCS_SIGNATURE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REP,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_REPLY_KEY_PACKAGE2,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_KDC_DH_KEY_INFO,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REQ,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_DH_PARAMTER,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TYPED_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_SERV_REFERRAL,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PAC_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CHANGE_PASSWORD_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ERROR_METHOD_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_EXT_ERROR,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_FOR_USER,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PAC_REQUEST_EX,
    (ASN1DecFun_t) ASN1Dec_KERB_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TICKET,
#ifndef XONLINE_FEATURE_VXBOX    
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AP_REQUEST,
#else
    (ASN1DecFun_t) ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REQUEST,
#endif
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AP_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SAFE_MESSAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PRIV_MESSAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CRED,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGT_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AUTH_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_COMPOUND_IDENTITY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REP2,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AS_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGS_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REQ2,
};
static const ASN1FreeFun_t freefntab[51] = {
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
};
static const ULONG sizetab[51] = {
    SIZE_KRB5_Module_PDU_0,
    SIZE_KRB5_Module_PDU_1,
    SIZE_KRB5_Module_PDU_2,
    SIZE_KRB5_Module_PDU_3,
    SIZE_KRB5_Module_PDU_4,
    SIZE_KRB5_Module_PDU_5,
    SIZE_KRB5_Module_PDU_6,
    SIZE_KRB5_Module_PDU_7,
    SIZE_KRB5_Module_PDU_8,
    SIZE_KRB5_Module_PDU_9,
    SIZE_KRB5_Module_PDU_10,
    SIZE_KRB5_Module_PDU_11,
    SIZE_KRB5_Module_PDU_12,
    SIZE_KRB5_Module_PDU_13,
    SIZE_KRB5_Module_PDU_14,
    SIZE_KRB5_Module_PDU_15,
    SIZE_KRB5_Module_PDU_16,
    SIZE_KRB5_Module_PDU_17,
    SIZE_KRB5_Module_PDU_18,
    SIZE_KRB5_Module_PDU_19,
    SIZE_KRB5_Module_PDU_20,
    SIZE_KRB5_Module_PDU_21,
    SIZE_KRB5_Module_PDU_22,
    SIZE_KRB5_Module_PDU_23,
    SIZE_KRB5_Module_PDU_24,
    SIZE_KRB5_Module_PDU_25,
    SIZE_KRB5_Module_PDU_26,
    SIZE_KRB5_Module_PDU_27,
    SIZE_KRB5_Module_PDU_28,
    SIZE_KRB5_Module_PDU_29,
    SIZE_KRB5_Module_PDU_30,
    SIZE_KRB5_Module_PDU_31,
    SIZE_KRB5_Module_PDU_32,
    SIZE_KRB5_Module_PDU_33,
    SIZE_KRB5_Module_PDU_34,
    SIZE_KRB5_Module_PDU_35,
    SIZE_KRB5_Module_PDU_36,
    SIZE_KRB5_Module_PDU_37,
    SIZE_KRB5_Module_PDU_38,
    SIZE_KRB5_Module_PDU_39,
    SIZE_KRB5_Module_PDU_40,
    SIZE_KRB5_Module_PDU_41,
    SIZE_KRB5_Module_PDU_42,
    SIZE_KRB5_Module_PDU_43,
    SIZE_KRB5_Module_PDU_44,
    SIZE_KRB5_Module_PDU_45,
    SIZE_KRB5_Module_PDU_46,
    SIZE_KRB5_Module_PDU_47,
    SIZE_KRB5_Module_PDU_48,
    SIZE_KRB5_Module_PDU_49,
    SIZE_KRB5_Module_PDU_50,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL KRB5_Module_Startup(ASN1module_t pASN1Module)
{
    ASN1_InitModule(pASN1Module, 0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 51, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x3562726b);
}

void ASN1CALL KRB5_Module_Cleanup(void)
{
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PAC_REQUEST_EX_pac_sections f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PAC_REQUEST_EX_pac_sections)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_encryption_type f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000008, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000008, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_encryption_type)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->te_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->te_data).length, ((val)->te_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->te_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->te_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->te_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PRINCIPAL_NAME_name_string f;
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	t = lstrlenA(f->value);
	if (!ASN1DEREncCharString(enc, 0x1b, t, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PRINCIPAL_NAME_name_string)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd, 0x1b, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1ztcharstring_free(f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->last_request_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->last_request_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(const PKERB_LAST_REQUEST_Seq *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->auth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->auth_data).length, ((val)->auth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->auth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->auth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->auth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->address_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->address_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->addr_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->addr_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_HOST_ADDRESSES_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_HOST_ADDRESSES)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_HOST_ADDRESSES_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_AUTHORIZATION_DATA)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_LAST_REQUEST_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_LAST_REQUEST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_LAST_REQUEST_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_LAST_REQUEST_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->name_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME_name_string(enc, 0, &(val)->name_string))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->name_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME_name_string(dd, 0, &(val)->name_string))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME_name_string(&(val)->name_string);
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_TICKET_EXTENSIONS)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->transited_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contents).length, ((val)->contents).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->transited_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->contents))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->contents);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->preauth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->preauth_data).length, ((val)->preauth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->preauth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->preauth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->preauth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_PREAUTH_DATA_LIST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001c, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001c, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001d, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(enc, 0, &(val)->ticket_info))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001d, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(dd, 0, &(val)->ticket_info))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(&(val)->ticket_info);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->server_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->error_code))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	t = lstrlenA((val)->client_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->error_text).length, ((val)->error_text).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000c, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->error_data).length, ((val)->error_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->server_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->error_code))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecCharString(dd0, 0x1b, &(val)->error_text))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000c, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->error_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1ztcharstring_free((val)->client_realm);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x8) {
	    ASN1charstring_free(&(val)->error_text);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1octetstring_free(&(val)->error_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cipher_text).length, ((val)->cipher_text).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cipher_text))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cipher_text);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keytype))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyvalue).length, ((val)->keyvalue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->keytype))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->keyvalue))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->keyvalue);
    }
}

static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->checksum_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->checksum).length, ((val)->checksum).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->checksum_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(const KERB_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->salt);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_ETYPE_INFO_ENTRY(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_ETYPE_INFO)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_ETYPE_INFO_ENTRY(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_ETYPE_INFO_ENTRY(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->server_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->server_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->pkcs_signature).length, ((val)->pkcs_signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->pkcs_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->signature_algorithm);
	ASN1bitstring_free(&(val)->pkcs_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.dh_signed_data).length, ((val)->u.dh_signed_data).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.key_package).length, ((val)->u.key_package).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.dh_signed_data))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.key_package))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.dh_signed_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.key_package);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->u.pkinit_enveloped_data).length, ((val)->u.pkinit_enveloped_data).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000001:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000004, &(val)->u.pkinit_enveloped_data))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->u.encrypted_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.pkinit_enveloped_data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
	if ((val)->o[0] & 0x80) {
	    ASN1bitstring_free(&(val)->subject_public_key);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->subject_public_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->signed_auth_pack).length, ((val)->signed_auth_pack).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->kdc_cert).length, ((val)->kdc_cert).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->encryption_cert).length, ((val)->encryption_cert).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->signed_auth_pack))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString(dd, 0x80000003, &(val)->kdc_cert))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecOctetString(dd, 0x80000004, &(val)->encryption_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(&(val)->trusted_certifiers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->kdc_cert);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->encryption_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->kdc_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->kdc_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cusec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->kdc_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cusec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->kdc_name);
	ASN1ztcharstring_free((val)->kdc_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->algorithm);
	ASN1bitstring_free(&(val)->subjectPublicKey);
    }
}

static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->prime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->base))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->private_value_length))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->prime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->base))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->private_value_length))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cert_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cert_data).length, ((val)->cert_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cert_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cert_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cert_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->data_value);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(enc, 0, &(val)->elements))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(dd, 0, &(val)->elements))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_KERB_SIGNATURE(&(val)->checksum);
	ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(&(val)->elements);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->referred_server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->referred_server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->referred_server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->referred_server_name);
	}
	ASN1ztcharstring_free((val)->referred_server_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->new_password).length, ((val)->new_password).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->target_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->target_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->new_password))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->target_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->new_password);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->target_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->target_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->data_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->status))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->klininfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->flags))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->status))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->klininfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->userName))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->userRealm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->userRealm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->cksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->authentication_package);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->authentication_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->authorization_data).length, ((val)->authorization_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->userName))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->userRealm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->cksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->authentication_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->userName);
	ASN1ztcharstring_free((val)->userRealm);
	ASN1Free_KERB_CHECKSUM(&(val)->cksum);
	ASN1ztcharstring_free((val)->authentication_package);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(enc, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(dd, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(&(val)->pac_sections);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_ISSUED_AUTH_DATA_elements f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_ISSUED_AUTH_DATA_elements)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_user_certs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_user_certs)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REP2_kdc_cert f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REP2_kdc_cert)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000c, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000c, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REPLY_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REPLY_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000001, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->ticket_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS(enc, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000001, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->ticket_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
#ifndef XONLINE_FEATURE_VXBOX    
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS(dd0, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
#endif
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS(&(val)->ticket_extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TRANSITED_ENCODING(enc, 0, &(val)->transited))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TRANSITED_ENCODING(dd0, 0, &(val)->transited))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->flags);
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TRANSITED_ENCODING(&(val)->transited);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000002, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->authenticator_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	//if (!ASN1BEREncSX(enc, 0x2, &(val)->sequence_number))
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000002, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->authenticator_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	//if (!ASN1BERDecSXVal(dd0, 0x2, &(val)->sequence_number))
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_CHECKSUM(&(val)->checksum);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
	/*
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequence_number);
	}
	*/
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->kdc_options).length, ((val)->kdc_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(enc, 0, &(val)->encryption_type))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(enc, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->kdc_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(dd, 0, &(val)->encryption_type))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x2;
	if (!ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(dd, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->kdc_options);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	}
	ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(&(val)->encryption_type);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->addresses);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->enc_authorization_data);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(&(val)->additional_tickets);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REPLY_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REPLY_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REPLY_preauth_data(&(val)->preauth_data);
	}
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->session_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_PKERB_LAST_REQUEST(enc, 0, &(val)->last_request))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(enc, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->session_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST(dd0, 0, &(val)->last_request))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(dd, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->session_key);
	ASN1Free_PKERB_LAST_REQUEST(&(val)->last_request);
	if ((val)->o[0] & 0x80) {
	}
	ASN1bitstring_free(&(val)->flags);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	ASN1ztcharstring_free((val)->server_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(&(val)->encrypted_pa_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->ap_options).length, ((val)->ap_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->ap_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->ap_options);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->authenticator);
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000f, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000f, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001b, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001b, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000014, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SAFE_BODY(enc, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000014, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SAFE_BODY(dd0, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_SAFE_BODY(&(val)->safe_body);
	ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000015, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000015, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000016, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CRED_tickets(enc, 0, &(val)->tickets))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000016, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_CRED_tickets(dd, 0, &(val)->tickets))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val)
{
    if (val) {
	ASN1Free_KERB_CRED_tickets(&(val)->tickets);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->principal_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->principal_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	t = lstrlenA((val)->service_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->service_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 2);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->principal_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x2;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x1;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->service_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[1] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[1] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->principal_realm);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1bitstring_free(&(val)->flags);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x8) {
	}
	if ((val)->o[0] & 0x4) {
	}
	if ((val)->o[0] & 0x2) {
	}
	if ((val)->o[0] & 0x1) {
	    ASN1ztcharstring_free((val)->service_realm);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->service_name);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_TICKET(&(val)->ticket);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_REPLY_KEY_PACKAGE2(enc, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_REPLY_KEY_PACKAGE2(dd0, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_REPLY_KEY_PACKAGE2(&(val)->reply_key_package);
	ASN1Free_KERB_SIGNATURE(&(val)->reply_key_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    if (val) {
	ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->kdc_public_value);
	ASN1Free_KERB_SIGNATURE(&(val)->kdc_public_value_sig);
    }
}

static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_KERBEROS_NAME(enc, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.ca_name).length, ((val)->u.ca_name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.issuer_and_serial).length, ((val)->u.issuer_and_serial).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_KERBEROS_NAME(dd0, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.ca_name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.issuer_and_serial))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_KERBEROS_NAME(&(val)->u.principal_name);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.ca_name);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.issuer_and_serial);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PK_AUTHENTICATOR(enc, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PK_AUTHENTICATOR(dd0, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_PK_AUTHENTICATOR(&(val)->pk_authenticator);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->client_public_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_COMPOUND_IDENTITY)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TRUSTED_CAS(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TRUSTED_CAS(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TRUSTED_CAS(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_CRED_ticket_info f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CRED_INFO(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_CRED_ticket_info)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CRED_INFO(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CRED_INFO(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_CRED_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_CRED_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_additional_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000b, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000b, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_additional_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REQUEST_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, 0, &(val)->request_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REQUEST_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dd0, 0, &(val)->request_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REQUEST_preauth_data(&(val)->preauth_data);
	}
	ASN1Free_KERB_KDC_REQUEST_BODY(&(val)->request_body);
    }
}

static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST_BODY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000b, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000b, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000d, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000d, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000019, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000019, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(enc, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(enc, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(enc, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(dd0, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(dd0, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(dd, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->key_package);
	}
	ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(&(val)->temp_key_package);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(&(val)->signed_kdc_public_value);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(&(val)->kdc_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_AUTH_PACKAGE(enc, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_AUTH_PACKAGE(dd0, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_AUTH_PACKAGE(&(val)->auth_package);
	ASN1Free_KERB_SIGNATURE(&(val)->auth_package_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(enc, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(enc, 0, &(val)->user_certs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->serial_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(dd0, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(dd, 0, &(val)->user_certs))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->serial_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val)
{
    if (val) {
	ASN1Free_KERB_SIGNED_AUTH_PACKAGE(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(&(val)->user_certs);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(&(val)->trusted_certifiers);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncXKDCPolicy.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace XkdcTest
{
    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(250), AsyncThreadCount(10)]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XKDCPolicy : XkdcTestBaseGroup
    {
        //static protected KerbClient kcl = new KerbClient();

        /// [Test_Xkdc_Machine_Policy_Basic]
        /// type=XOnlineLogon
        /// machine=M1
        /// stoponfail=yes
        /// This test case is already covered in another Class and is not Policy specific

        /// [Test_Xkdc_User_1_Policy_Basic]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// services=presence
        /// stoponfail=yes
        /// This test case is already covered in another Class and is not Policy specific

        /// [Test_Xkdc_User_1_Policy_Space]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=presence
        /// users=xkt space
        [TestCase, Description("Test_Xkdc_User_1_Policy_Space")]
        class Test_Xkdc_User_1_Policy_Space : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xkt space"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Policy_Country_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktcntry53
        /// services=presence
        /// country=53
        [TestCase, Description("Test_Xkdc_User_1_Policy_Country_01")]
        class Test_Xkdc_User_1_Policy_Country_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 53;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktcntry53"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'c');
            }
        }

        /// [Test_Xkdc_User_1_Policy_Country_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktcntry76
        /// services=presence
        /// country=76
        [TestCase, Description("Test_Xkdc_User_1_Policy_Country_02")]
        class Test_Xkdc_User_1_Policy_Country_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 76;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktcntry76"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'c');
            }
        }

        /// [Test_Xkdc_User_1_Policy_Country_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktcntry44
        /// services=presence
        /// country=44
        [TestCase, Description("Test_Xkdc_User_1_Policy_Country_03")]
        class Test_Xkdc_User_1_Policy_Country_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 44;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktcntry44"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'c');
            }
        }

        /// [Test_Xkdc_User_1_Policy_UserFlags_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xkttflag1(2,4,5,7,9,65295)
        /// services=presence
        /// userflags=1,2,4,5,7,9,65295 (each is an atomic test)
        /// 65295 (0xFF0F), or (short)-241,
        /// is chosen because it lights up all 16 bits in si_ticket_flags except for the tier_id ones [0x00F0] returned by xkdcpolicy.
        [TestCase, Description("Test_Xkdc_User_1_Policy_UserFlags_01thru07")]
        class Test_Xkdc_User_1_Policy_UserFlags_01thru07 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                short[] index = new short[7];
                String[] users = new String[7];
                index[0] = 1;
                index[1] = 2;
                index[2] = 4;
                index[3] = 5;
                index[4] = 7;
                index[5] = 9;
                index[6] = -241;   // 0xFF0F, lights up all bits in 2-byte ticketflags except the recently added tier id bits
                for(uint i = 0; i < index.Length; i++)
                {
                    // Create the correct user name
                    // this first thing is a hack, sometimes i hate C#
                    if (index[i] == -241)
                        users[i] = "xkttflag65295";
                    else
                        users[i] = "xkttflag" + index[i].ToString();
                    // Set up the userFlag array for that user
                    userFlags[0] = index[i];
                    // Set the return result if we fail.
                    if(TEST_RESULTS.FAILED == GetUserSTwithFlags(UserTimer.AccessSharedUser(users[i]),
                        new uint[] {(uint)XOService.PresNotification},
                        null,
                        ExpectedHRs,
                        HResult.S_OK,
                        userFlags,
                        'f'))
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_User_Valid_WLID]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuserValWLID
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_Valid_WLID"), TestFrequency("Regression"), Owner("nickperk")]
        class Test_Xkdc_User_Valid_WLID : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_OK;
                bVerifyUserHRs = true;
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuserValWLID"),
                    new uint[] { (uint)XOService.PresNotification, (uint)XOService.Stats },
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u');
            }
        }

        /// [Test_Xkdc_User_Invalid_WLID]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuserInvWLID
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_Invalid_WLID"), TestFrequency("Regression"), Owner("nickperk")]
        class Test_Xkdc_User_Invalid_WLID : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                if (IsXenonClient)
                {
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                }
                else
                {
                    ExpectedHRs[0] = HResult.S_OK;
                }
                bVerifyUserHRs = true;
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuserInvWLID"),
                    new uint[] { (uint)XOService.PresNotification, (uint)XOService.Stats },
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u');

                VerifyNoUserPrivileges();
            }
        }

        /// [Test_Xkdc_Owner_Valid_WLID]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktownerValWLID
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_Owner_Valid_WLID"), TestFrequency("Regression"), Owner("nickperk")]
        class Test_Xkdc_Owner_Valid_WLID : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_OK;
                bVerifyUserHRs = true;
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktownerValWLID"),
                    new uint[] { (uint)XOService.PresNotification, (uint)XOService.Stats },
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u');
            }
        }

        /// [Test_Xkdc_Owner_Invalid_WLID]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktownerInvWLID
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_Owner_Invalid_WLID"), TestFrequency("Regression"), Owner("nickperk")]
        class Test_Xkdc_Owner_Invalid_WLID : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                if (IsXenonClient)
                {
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                }
                else
                {
                    ExpectedHRs[0] = HResult.S_OK;
                }
                bVerifyUserHRs = true;
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktownerInvWLID"),
                    new uint[] { (uint)XOService.PresNotification, (uint)XOService.Stats },
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u');

                VerifyNoUserPrivileges();
            }
        }

        /// [Test_Xkdc_Owner_And_User_Invalid_WLID]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktoAnduInvWLID
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_Owner_And_User_Invalid_WLID"), TestFrequency("Regression"), Owner("nickperk")]
        class Test_Xkdc_Owner_And_User_Invalid_WLID : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                if (IsXenonClient)
                {
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                }
                else
                {
                    ExpectedHRs[0] = HResult.S_OK;
                }
                bVerifyUserHRs = true;
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktoAnduInvWLID"),
                    new uint[] { (uint)XOService.PresNotification, (uint)XOService.Stats },
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u');

                VerifyNoUserPrivileges();
            }
        }

        /// [Test_Xkdc_User_1_Policy_VoiceResume_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktvocrsmnow
        /// services=presence
        [TestCase, Description("Test_Xkdc_User_1_Policy_VoiceResume_01")]
        class Test_Xkdc_User_1_Policy_VoiceResume_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktvocrsmnow"),
                    new uint[] {(uint)XOService.PresNotification}, null, ExpectedHRs, HResult.S_OK, 's');
            }
        }

        /// [Test_Xkdc_User_1_Policy_VoiceResume_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktvocrsmtmrw
        /// services=presence
        /// userflags=1
        [TestCase, Description("Test_Xkdc_User_1_Policy_VoiceResume_02")]
        class Test_Xkdc_User_1_Policy_VoiceResume_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                // This test is sensitive to trust-related munging. Someone
                // else seems to be altering the title & user trust ratings in 
                // the database. If this test fails, fix the db by running:
                // dbposter -update uodb-tables.ini uodb-xkdctest.ini
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 1;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktvocrsmtmrw"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'f');
            }
        }

        /// [Test_Xkdc_User_1_Policy_VoiceResume_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktvocrsmyest
        /// services=presence
        [TestCase, Description("Test_Xkdc_User_1_Policy_VoiceResume_03")]
        class Test_Xkdc_User_1_Policy_VoiceResume_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktvocrsmyest"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK, 
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Policy_VoiceResume_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktvocrsmfvr
        /// services=presence
        /// userflags=1
        [TestCase, Description("Test_Xkdc_User_1_Policy_VoiceResume_04")]
        class Test_Xkdc_User_1_Policy_VoiceResume_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 1;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktvocrsmfvr"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'f');
            }
        }

        /// [Test_Xkdc_User_1_Policy_UserFlags_VoiceResume_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xkttflag7
        /// services=presence
        /// userflags=7
        [TestCase, Description("Test_Xkdc_User_1_Policy_UserFlags_VoiceResume_01")]
        class Test_Xkdc_User_1_Policy_UserFlags_VoiceResume_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 7;
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xkttflag7"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'f');
            }
        }

        /// [Test_Xkdc_User_1_Policy_NameChange_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktnamechng
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_1_Policy_NameChange_01")]
        class Test_Xkdc_User_1_Policy_NameChange_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktnamechng"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u');

                VerifyNoUserPrivileges();
            }
        }

        /// [Test_Xkdc_User_1_Policy_TOS_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xkttosbefore
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_1_Policy_TOS_01")]
        class Test_Xkdc_User_1_Policy_TOS_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xkttosbefore"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u');

                VerifyNoUserPrivileges();
            }
        }

        /// [Test_Xkdc_User_1_Policy_TOS_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xkttosexact
        /// services=presence
        [TestCase, Description("Test_Xkdc_User_1_Policy_TOS_02")]
        class Test_Xkdc_User_1_Policy_TOS_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xkttosexact"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Policy_TOS_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xkttosafter
        /// services=presence
        [TestCase, Description("Test_Xkdc_User_1_Policy_TOS_03")]
        class Test_Xkdc_User_1_Policy_TOS_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xkttosafter"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        public static void SetPerCountryTOS(DateTime tosDate, byte countryId)
        {
            UodbWS.ExecuteSQLNonQuery("   INSERT INTO t_terms_of_service(ti_service_type,ti_country_id,dt_latest_tos)" +
                                        "   VALUES(1," + countryId + ",'" + tosDate.ToString("yyyy-MM-dd HH:mm:ss.fff") + "')", null);
        }

        public static void RemovePerCountryTOS(DateTime tosDate, byte countryId)
        {
            UodbWS.ExecuteSQLNonQuery("   DELETE FROM t_terms_of_service" +
                                        "   WHERE ti_country_id = " + countryId + " AND dt_latest_tos = '" + tosDate.ToString("yyyy-MM-dd HH:mm:ss.fff") + "'", null);
        }

        /// [Test_Xkdc_User_1_Policy_TOS_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xkttosafter
        /// services=presence
        [TestCase, Description("Test_Xkdc_User_1_Policy_TOS_04")]
        class Test_Xkdc_User_1_Policy_TOS_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                try
                {
                    // say Japan gets a new required TOS
                    SetPerCountryTOS(new DateTime(2011, 6, 6), 53);

                    uint[] ExpectedHRs = new uint[12];
                    ResultCode = GetUserST(UserTimer.AccessSharedUser("xkttoswayafter"),
                        new uint[] { (uint)XOService.PresNotification, (uint)XOService.Stats },
                        null,
                        ExpectedHRs,
                        HResult.S_OK,
                        's');
                }
                finally
                {
                    RemovePerCountryTOS(new DateTime(2011, 6, 6), 53);
                }
            }
        }

        /// [Test_Xkdc_User_1_Policy_TOS_05]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xkttosbefore
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_1_Policy_TOS_05")]
        class Test_Xkdc_User_1_Policy_TOS_05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                try
                {
                    // say the US gets a new required TOS
                    SetPerCountryTOS(new DateTime(2011, 6, 6), 103);

                    uint[] ExpectedHRs = new uint[12];
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                    ResultCode = GetUserST(UserTimer.AccessSharedUser("xkttoswayafter"),
                        new uint[] { (uint)XOService.PresNotification, (uint)XOService.Stats },
                        null,
                        ExpectedHRs,
                        HResult.S_OK,
                        'u');
                }
                finally
                {
                    RemovePerCountryTOS(new DateTime(2011, 6, 6), 103);
                }

                VerifyNoUserPrivileges();
            }
        }

        /// [Test_Xkdc_User_1_Policy_BillingStatus_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktbilstatfals
        /// services=presence
        [TestCase, Description("Test_Xkdc_User_1_Policy_BillingStatus_01")]
        class Test_Xkdc_User_1_Policy_BillingStatus_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xkttosafter"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_Policy_BillingStatus_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktbilstatfail
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_1_Policy_BillingStatus_02")]
        class Test_Xkdc_User_1_Policy_BillingStatus_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktbilstatfail"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u');

                VerifyNoUserPrivileges();
            }
        }

        /// [Test_Xkdc_User_Multi_Policy_UserFlags_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xkttflag9, xktuser7b
        /// services=presence
        /// userflags=9, 0
        [TestCase, Description("Test_Xkdc_User_Multi_Policy_UserFlags_01")]
        class Test_Xkdc_User_Multi_Policy_UserFlags_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 9;
                if(GetUserSTwithFlags(UserTimer.AccessSharedUser("xkttflag9"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'f') != TEST_RESULTS.PASSED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                userFlags[0] = 0;
                if(GetUserSTwithFlags(UserTimer.AccessSharedUser("xktuser7b"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'f') != TEST_RESULTS.PASSED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_User_Multi_Policy_UserFlags_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7b, xkttflag9
        /// services=presence
        /// userflags=0, 9
        [TestCase, Description("Test_Xkdc_User_Multi_Policy_UserFlags_02")]
        class Test_Xkdc_User_Multi_Policy_UserFlags_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 0;
                if(GetUserSTwithFlags(UserTimer.AccessSharedUser("xktuser7b"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'f') != TEST_RESULTS.PASSED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                userFlags[0] = 9;
                if(GetUserSTwithFlags(UserTimer.AccessSharedUser("xkttflag9"),
                    new uint[] {(uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    userFlags,
                    'f') != TEST_RESULTS.PASSED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_User_Multi_Policy_NameChange_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktnamechng, xktuser7a
        /// services=presence
        /// hruser=XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT, S_OK
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_Multi_Policy_NameChange_01")]
        class Test_Xkdc_User_Multi_Policy_NameChange_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                if(GetUserST(UserTimer.AccessSharedUser("xktnamechng"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u') == TEST_RESULTS.FAILED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                VerifyNoUserPrivileges();

                ExpectedHRs[0] = HResult.S_OK;
                if(GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u') == TEST_RESULTS.FAILED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_User_Multi_Policy_NameChange_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a, xktnamechng
        /// services=presence
        /// hruser=S_OK, XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_Multi_Policy_NameChange_02")]
        class Test_Xkdc_User_Multi_Policy_NameChange_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                if(GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u') == TEST_RESULTS.FAILED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                if(GetUserST(UserTimer.AccessSharedUser("xktnamechng"),
                    new uint[] {(uint)XOService.PresNotification, (uint)XOService.Stats},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    'u') == TEST_RESULTS.FAILED)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                VerifyNoUserPrivileges();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncXmacsXenon.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;
using System.Diagnostics;
using ServerTestFramework.Database;

namespace XkdcTest
{
    abstract public class TestBase_XmacsXenon: TestBase_Xmacs
    {
        public TestBase_XmacsXenon()
        {
            ClientType=AuthContext.ClientTypes.Xenon;
        }

        public override void PreRun()
        {
            UseXenonMacRequest2=(bool)GetContextData("UseMacRequest2");
        }

        protected XonlinepUser MachineGt(string name, string key, bool bSetCertConsoleId)
        {
            XonlinepUser machine = new XonlinepUser();
            byte[] keyBytes = Hexer.unhex(key);
            ValueCheck.Test("machine.Key length", machine.Key.Length, keyBytes.Length);

            if (name == null)
            {
                name = XmacsClient.GenerateXenonPrincipal();
            }

            // Set gamertag
            AuthClientBase.StringToBytes(machine.Gamertag, name);

            // Set cert's console id
            if (bSetCertConsoleId)
                this.consoleCert.SetConsoleIdFromGamertag(name);

            // Set key
            machine.Key = keyBytes;

            // Set kerb realm
            AuthClientBase.StringToBytes(machine.KerberosRealm, "MACS.XBOX.COM");

            return machine;
        }

        protected XonlinepUser MachineGt(string name, string key, string realm, bool bSetCertConsoleId)
        {
            XonlinepUser machine = MachineGt(name, key, bSetCertConsoleId);

            // Override default kerb realm
            AuthClientBase.StringToBytes(machine.KerberosRealm, realm);

            return machine;
        }

        protected XonlinepUser MachineId(string consoleId, string key, bool bSetCertConsoleId)
        {
            XonlinepUser machine = new XonlinepUser();
            byte[] keyBytes = Hexer.unhex(key);
            ValueCheck.Test("machine.Key length", machine.Key.Length, keyBytes.Length);
            byte[] idBytes = Hexer.unhex(consoleId);
            ValueCheck.Test("consoleId.Length", 5, idBytes.Length);

            // Set gamertag
            AuthClientBase.BuildXenonConsolePrincipal(idBytes, machine.Gamertag);

            // Set cert's console id
            if (bSetCertConsoleId)
                Array.Copy(idBytes, this.consoleCert.ConsoleId, idBytes.Length);

            // Set key
            machine.Key = keyBytes;

            // Set kerb realm
            AuthClientBase.StringToBytes(machine.KerberosRealm, "MACS.XBOX.COM");

            return machine;
        }

        protected XonlinepUser MachineId(string consoleId, string key, string realm, bool bSetCertConsoleId)
        {
            XonlinepUser machine = MachineId(consoleId, key, bSetCertConsoleId);

            // Override default kerb realm
            AuthClientBase.StringToBytes(machine.KerberosRealm, realm);

            return machine;
        }


    }


    [TestGroup]
    [CompoundCase("MacPreauth1", false)]
    [CompoundCase("MacPreauth2", true)]
    public class XmacsCreateXenon : XkdcTestBaseGroup
    {
        public XmacsCreateXenon() : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }

        public override void PreRun()
        {
            base.PreRun();

            CreateContextData();
            SetContextData("UseMacRequest2", MyValues[0]);
        }

        [TestCase, Description("Create a Xenon devkit account"), EnvRequirement("NCipher")]
            class Simple_Valid_RealXmacsKey : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                base.bUseXmacsTestKey = false;
                DoRequest(MachineGt("XE.100456789011",  "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase, Description("Create a Xenon devkit account")]
        class Simple_Valid_TestXmacsKey : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                base.bUseXmacsTestKey = true;
                DoRequest(MachineGt("XE.100456789011", "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase, Description("Create a Xenon devkit account")]
            class Simple_Valid_Extra : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                XmacsClient xmacs = new XmacsClient(new AuthContext());
                xmacs.SignInXmacs();

                // Exact same gamertag for both of these
                xmacs = DoRequest(MachineId("0x2DFDC1C356",     "0x00000000000000000000000000000000", true));
                xmacs = DoRequest(MachineGt("XE.123456789016",  "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase, Description("Create a bad Xenon devkit account")]
            class PrincipalName_Invalid : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // These tests do not modify the default console certificate.
                // PrincipalName is the Gamertag in the XonlinepUser structure. Normally it is based entirely
                // on the console id. None of these gamertags will match the ConsoleId in the certificate.

                // TODO: followup, is this the behavior we want from the server?

                // Wrong console id, wrong checksum
                DoRequest(MachineGt("XE.000000000010",  "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("XE.123456789026",  "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("XE.999999999993",  "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("XE.101010101010",  "0x00000000000000000000000000000000", false), E_NoResponse);

                // Correct console id, wrong checksum
                DoRequest(MachineGt("XE.123456789010",  "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineId("0x2DFDC1C350",     "0x00000000000000000000000000000000", false), E_NoResponse);

                // Wrong console id, correct checksum
                DoRequest(MachineGt("XE.123456789027",  "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("XE.101010101016",  "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("XE.000000000011",  "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("XE.999999999999",  "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineId("0x0000000000",     "0x00000000000000000000000000000000", false), E_NoResponse);
            }
        }

        [TestCase, Description("Use various valid console ids and principal names and keys")]
            class ConsoleIdsAndKeys_Valid : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                // + This should be perfectly valid, it's what we've been doing for the mainline cases
                DoRequest(MachineId("0x2DFDC1C356",       "0x00000000000000000000000000000000", true));
                DoRequest(MachineGt("XE.123456789016",    "0x00000000000000000000000000000000", true));

                // Try some new valid console ids
                DoRequest(MachineGt("XE.123456789027",    "0x00000000000000000000000000000000", true));
                DoRequest(MachineGt("XE.103406789020",    "0x00000000000000000000000000000000", true));
                DoRequest(MachineGt("XE.103406789020",    "0xAA0000000000000000000000000000BB", true));
                DoRequest(MachineId("0x0000000022",       "0x00000000000000000000000000000000", true));
                DoRequest(MachineId("0x0000000107",       "0x00000000000000000000000000000000", true));
                DoRequest(MachineId("0x0000000011",       "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase, Description("Create a Xenon devkit account and verify by signing in to ASKDC")]
            class ConsoleIdsAndKeys_Valid_Verify : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                // This test is similar to the previous one but actually signs into the ASKDC with the 
                // newly created accounts.  This takes longer, thus we only hit a few items.
                DoRequestVerify(MachineGt("XE.123456789016",    "0x00000000000000000000000000000000", true));
                DoRequestVerify(MachineGt("XE.103406789020",    "0xAA0000000000000000000000000000BB", true));
                DoRequestVerify(MachineGt("XE.000000000011",    "0x00000000000000000000000000000000", true));
                System.Threading.Thread.Sleep(1100); //avoid askdc anti-dos code
                DoRequestVerify(MachineGt("XE.101010101016",    "0x00000000000000000000000000000000", true));
                System.Threading.Thread.Sleep(1100); //avoid askdc anti-dos code
                DoRequestVerify(MachineGt("XE.101010101016",    "0x99999999999999999999999999999999", true));
                DoRequestVerify(MachineId("0x2DFDC1C356",       "0x00000000000000000000000000000001", true));
                System.Threading.Thread.Sleep(1100); //avoid askdc anti-dos code
                DoRequestVerify(MachineId("0x2DFDC1C356",       "0x0123456789ABCDEF0123456789ABCDEF", true));

                // Max ID, these are the same
                DoRequestVerify(MachineGt("XE.687194767353",    "0x00000000000000000000000000000000", true));
                System.Threading.Thread.Sleep(1100); //avoid askdc anti-dos code
                DoRequestVerify(MachineId("0xFFFFFFFFF3",       "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase(BugID=162935, BugDatabase="Unknown"), Description("Create bad console ids in the certificate and the gamertag")]
            class ConsoleIdsAndKeys_InvalidChecksums : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Try some console ids with invalid checksums
                DoRequest(MachineGt("XE.123456789020",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.103406789029",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.103406789021",          "0xAA0000000000000000000000000000BB", true), E_NoResponse);
                DoRequest(MachineId("0x2DFDC1C350",             "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineId("0x0000000020",             "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineId("0x0000000101",             "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineId("0x0000000001",             "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineId("0xFFFFFFFFFF",             "0x00000000000000000000000000000000", true), E_NoResponse);

                // TODO: some way to make really funky ones, that aren't valid whatsoever.

            }
        }

        [TestCase, Description("Create bad console ids in the certificate and the gamertag")]
            class ConsoleIdsAndKeys_InvalidGamertags : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Some poorly formatted gamertags with good checksums
                DoRequest(MachineGt("xe.123456789016",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("SN.123456789016",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("sn.123456789016",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("   123456789016",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("  .123456789016",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("00.123456789016",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("000123456789016",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("000000000000011",          "0x00000000000000000000000000000000", true), E_NoResponse);

                // Poorly formatted with bad checksum
                DoRequest(MachineGt("SN.123456789010",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("   123456789010",          "0x00000000000000000000000000000000", true), E_NoResponse);

                // TODO: some way to make really funky ones, that aren't valid whatsoever.
            }
        }

        [TestCase, Description("Create bad console ids in the certificate and the gamertag")]
            class ConsoleIdsAndKeys_InvalidGamertagsMismatchCert : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Poorly formatted with mismatched gamertag from console id
                DoRequest(MachineGt("SN.000000000011",          "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("   000000000011",          "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("  .000000000011",          "0x00000000000000000000000000000000", false), E_NoResponse);
                DoRequest(MachineGt("sn.000000000010",          "0x00000000000000000000000000000000", false), E_NoResponse);

                // TODO: some way to make really funky ones, that aren't valid whatsoever.
            }
        }

        [TestCase, Description("Create bad console ids where gamertag value is larger than console id bytes")]
            class ConsoleIdsOverflow_Valid : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                // XE.999999999999 = 0x74876E7FF9 = XE.312805232639, checksum = 5
                // Doing it this way, we get XE.312805232635, which has correct checksum = 5.  Should be valid.
                DoRequest(MachineId("0x74876E7FF5",             "0x00000000000000000000000000000000", true));
                DoRequest(MachineGt("XE.312805232635",          "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase, Description("Create bad console ids where gamertag value is larger than console id bytes")]
            class ConsoleIdsOverflow_Invalid_MaxAll : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Since we can't encode a gamertag this large into 5 bytes, this should result in a 
                // mismatched console id / gamertag.  For the max console id, the checksum nibble 
                // should be 3.  

                // Correct checksum for gamertag, incorrect for binary id
                DoRequest(MachineGt("XE.999999999999",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.999999999988",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.999999999977",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.999999999995",          "0x00000000000000000000000000000000", true), E_NoResponse);

            }
        }

        [TestCase, Description("Create bad console ids where gamertag value is larger than console id bytes")]
            class ConsoleIdsOverflow_Invalid_Max_BadChecksumGamertag : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Incorrect checksum for gamertag, correct for binary id
                DoRequest(MachineGt("XE.999999999993",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.999999999982",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.999999999971",          "0x00000000000000000000000000000000", true), E_NoResponse);
            }
        }

        [TestCase, Description("Create bad console ids where gamertag value is larger than console id bytes")]
            class ConsoleIdsOverflow_Invalid_Over_BadChecksumId : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Max binary console ID +1, +2, +3 with correct checksum for gamertag, incorrect for binary id
                DoRequest(MachineGt("XE.687194767364",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.687194767375",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.687194767386",          "0x00000000000000000000000000000000", true), E_NoResponse);
            }
        }
        [TestCase, Description("Create bad console ids where gamertag value is larger than console id bytes")]
            class ConsoleIdsOverflow_Invalid_Over_BadChecksumGamertag : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Max binary console ID +1, +2, +3 with incorrect checksum for gamertag, correct for binary id
                DoRequest(MachineGt("XE.687194767360",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.687194767371",          "0x00000000000000000000000000000000", true), E_NoResponse);
                DoRequest(MachineGt("XE.687194767382",          "0x00000000000000000000000000000000", true), E_NoResponse);
            }
        }

        [TestCase, Description("")]
            class KerbRealm_Invalid : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Correct realm is MACS.XBOX.COM
                DoRequest(MachineGt("XE.123456789016",  "0x00000000000000000000000000000000", "XBOX.COM", true),        E_NoResponse);
                DoRequest(MachineGt("XE.123456789016",  "0x00000000000000000000000000000000", "PASSPORT.NET", true),    (Suite.IsAskdcIPAntiDosEnabled?(Exception)E_PreauthRequired: (Exception)E_NoResponse)); //with ppa gone, preauth whitelist causes no response for this when echo is disabled.
                DoRequest(MachineGt("XE.123456789016",  "0x00000000000000000000000000000000", "COM", true),             E_NoResponse);
                DoRequest(MachineGt("XE.123456789016",  "0x00000000000000000000000000000000", "MACS XBOX.COM", true),   E_NoResponse);
                DoRequest(MachineGt("XE.123456789016",  "0x00000000000000000000000000000000", " MACS.XBOX.COM", true),  E_NoResponse);
                DoRequest(MachineGt("XE.123456789016",  "0x00000000000000000000000000000000", "MACS.XBOX.CO", true),    E_NoResponse);
                DoRequest(MachineGt("XE.123456789016",  "0x00000000000000000000000000000000", "krbtgt", true),          E_NoResponse);
            }
        }

        [TestCase, Description("Verify machine puids for xenon Xmacs requests are as expected")]
            class MachinePuid_Xenon_Verify : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong mask = 0xFA00000000000000;

                // Xenon
                ClientType = AuthContext.ClientTypes.Xenon;
                AuthContext ctx = new AuthContext(ClientType);
                XmacsClient xmacs = new XmacsClient(ctx);

                bool useXenonMacRequest2=(bool)GetContextData("UseMacRequest2");
                if (!useXenonMacRequest2)
                {
                    ctx.ConsoleSerialNumber=null;
                }

                xmacs.SignInXmacs();
                ulong puid2 = xmacs.Context.UsersMachine.xuid.qwUserID;
                if ((puid2 & mask) != mask)
                {
                    Fail("Error, PUID is 0x{0:X}, expected mask 0x{1:X} for machine {2}", 
                         puid2, mask, AuthClientBase.BytesToString(ctx.UsersMachine.Gamertag));
                }
            }
        }

        [TestCase, Description("ConsoleType is 1 (devkit)")]
            class ConsoleCert_ConsoleType_Devkit : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_DEV);
                DoRequest(MachineGt(null,                 "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase, EnvRequirement("NCipher"), Description("ConsoleType is 2 (retail)")]
            class ConsoleCert_ConsoleType_Retail : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_RETAIL);
                DoRequest(MachineGt(null,                 "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase, Description("ConsoleType is 1 (testkit devkit)")]
            class ConsoleCert_ConsoleType_Devkit_Testkit : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_DEV | ConsoleCertificate.CONSOLE_TYPE_TESTKIT);
                DoRequest(MachineGt(null,                 "0x00000000000000000000000000000000", true));
            }
        }

        [TestCase, Description("ConsoleType is 2 (testkit retail)")]
            class ConsoleCert_ConsoleType_Retail_Testkit : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                // Valid devkit
                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_RETAIL | ConsoleCertificate.CONSOLE_TYPE_TESTKIT);
                DoRequest(MachineGt(null,                 "0x00000000000000000000000000000000", true));
            }
        }



        [TestCase, Description("Set a bit outside the mask for a valid devkit")]
            class ConsoleCert_ConsoleType_NotInMask : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;
                // Mask should be 0xC0000003 or 11000000 00000000 00000000 00000011
                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_DEV + 128);
                DoRequest(MachineGt(null,                  "0x00000000000000000000000000000000", true), E_NoResponse);
            }
        }

        [TestCase, Description("Set all mask bits")]
            class ConsoleCert_ConsoleType_NotInMask_AllBits : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;
                this.consoleCert.SetConsoleTypeTest(uint.MaxValue);
                DoRequest(MachineGt(null,                 "0x00000000000000000000000000000000", true), E_NoResponse);
            }
        }

        [TestCase, Description("")]
            class ConsoleCert_ConsoleType_Invalid : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // What XMACS will allow for a given environment is determined by the kdcsvc_xmacs_consoleTypeMask and
                // kdcsvc_xmacs_consoleExceptionList settings in the ConfigDB. 
                // consoleTypeMask is currently set to 1.
                // NOTE: ConsoleType is a dword and must be byteswapped.

                // Invalid
                //this.consoleCert.SetConsoleTypeTest(0x00000000);
                //DoRequest(MachineGt("XE.000000000101",    "0x00000000000000000000000000000000", true), E_NoResponse); //we now allow banned consoles through xmacs
                this.consoleCert.SetConsoleTypeTest(0x00000004);
                DoRequest(MachineGt("XE.000000000202",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.SetConsoleTypeTest(0x01000000);
                DoRequest(MachineGt("XE.000000000303",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.SetConsoleTypeTest(0x02000000);
                DoRequest(MachineGt("XE.000000000404",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.SetConsoleTypeTest(0x03000000);
                DoRequest(MachineGt("XE.000000000505",    "0x00000000000000000000000000000000", true), E_NoResponse);

                // Same console type as Exempt test below
                // Invalid, but not exempt
                this.consoleCert.SetConsoleTypeTest(0x00000004);
                DoRequest(MachineGt("XE.000000000167",    "0x00000000000000000000000000000000", true), E_NoResponse);
            }
        }

        [TestCase(BugID=26118, BugDatabase="Xenon"), Description("Verify exception list works for checkin 152001 bug 26118")]
            class ConsoleCert_ConsoleType_Invalid_Exempt_Auto : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                // What XMACS will allow for a given environment is determined by the kdcsvc_xmacs_consoleTypeMask and
                // kdcsvc_xmacs_consoleExceptionList settings in the ConfigDB.  
                // consoleTypeMask is currently set to 0xC0000003.
                // but kdcsvc_xmacs_consoleExceptionList (comman separated list) will allow certain console ids to
                // be exempted from the consoletype check.
                // NOTE: ConsoleType is a dword and must be byteswapped.
                //
                // BIG NOTE: Need to add "XE.000000000156" to NPDB t_settings 
                // kdcsvc_xmacs_consoleExceptionList

                OverrideSetting("kdcsvc_xmacs_consoleExceptionList", "XE.000000000156");

                // Invalid, but exempt
                try
                {
                    this.consoleCert.SetConsoleTypeTest(0x00000004);
                    DoRequest(MachineGt("XE.000000000156",    "0x00000000000000000000000000000000", true));
                }
                finally
                {
                    RevertSettingOverrides();
                }
            }
        }

        [TestCase(BugID=26118, BugDatabase="Xenon"), Description("Console id 000000000156 should be added to kdcsvc_xmacs_consoleExceptionList")]
            class ConsoleCert_ConsoleType_Invalid_Exempt_Manual : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                OverrideSetting("kdcsvc_xmacs_consoleExceptionList", "XE.000000000156");

                // Invalid, but exempt
                try
                {
                    this.consoleCert.SetConsoleTypeTest(0x00000004);
                    DoRequest(MachineGt("XE.000000000156",    "0x00000000000000000000000000000000", true));
                }
                finally
                {
                    RevertSettingOverrides();
                }
            }
        }

        [TestCase(BugID=36278, BugDatabase="Xenon"), Description("Verify checkin 162935 and 164480 (bugs 35127 and 36278)")]
            class ConsoleCert_ConsoleType_Invalid_TestBitNotSet : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                // Do not set the high bit of the console type, but otherwise this is a perfectly
                // valid test certificate. Currently, this will fail.
                // Update: currently, this will succeed.  The special code for funky real certs was
                // removed.

                // Valid devkit
                this.consoleCert.ConsoleType = ConsoleCertificate.BYTESWAP32(1);
                DoRequest(MachineGt("XE.000000001001",    "0x00000000000000000000000000000000", true));
            }
        }

        // TODO:
        [TestCase, Ignore, Description("")]
            class ConsoleCert_ConsoleType_Mismatch : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Don't change certificate signature, just the value. Fail.
                // TODO: kerbclient currently signs every console, so this is impossible right now.
                // FIX THIS!
                // What XMACS will allow for a given environment is determined by the kdcsvc_xmacs_consoleTypeMask and
                // kdcsvc_xmacs_consoleExceptionList settings in the ConfigDB. 
                this.consoleCert.SetConsoleTypeTest(3);
                DoRequest(MachineGt("XE.123456789016",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.SetConsoleTypeTest(4);
                DoRequest(MachineGt("XE.123456789016",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.SetConsoleTypeTest(int.MaxValue);
                DoRequest(MachineGt("XE.123456789016",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.SetConsoleTypeTest(int.MaxValue - 1);
                DoRequest(MachineGt("XE.123456789016",    "0x00000000000000000000000000000000", true), E_NoResponse);

            }
        }

        [TestCase, Description("")]
            class ConsoleCert_Size_Invalid : TestBase_XmacsXenon
        {
            ushort swap(ushort n)
            {
                return NetConstants.HTONS(n);
            }

            override protected void Execute()
            {
                DisableRetryBehaviour=true;
                ResultCode = TEST_RESULTS.PASSED;

                // Don't forget to byteswap these
                ushort OldGoodSize = 423;   // CONSOLE_CERTIFICATE
                ushort GoodSize = 424;      // XE_CONSOLE_CERTIFICATE

                // Valid
                this.consoleCert.CertSize = swap(GoodSize);
                DoRequest(MachineGt("XE.100000000001",    "0x00000000000000000000000000000000", true));

                // Invalid
                this.consoleCert.CertSize = swap((ushort)(GoodSize+1));
                DoRequest(MachineGt("XE.200000000002",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.CertSize = swap((ushort)(GoodSize-1));
                DoRequest(MachineGt("XE.300000000003",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.CertSize = swap((ushort)0);
                DoRequest(MachineGt("XE.400000000004",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.CertSize = swap(ushort.MaxValue);
                DoRequest(MachineGt("XE.500000000005",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.CertSize = swap(OldGoodSize);
                DoRequest(MachineGt("XE.600000000006",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.CertSize = GoodSize;
                DoRequest(MachineGt("XE.700000000007",    "0x00000000000000000000000000000000", true), E_NoResponse);
                this.consoleCert.CertSize = OldGoodSize;
                DoRequest(MachineGt("XE.800000000008",    "0x00000000000000000000000000000000", true), E_NoResponse);

            }
        }


        [TestCase]
        class MachineExists : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                XmacsClient xmacs;
                // Just make the call twice
                xmacs = DoRequestVerify(MachineGt("XE.000000000202", "0x00000000000000000000000000000000", true));
                XonlinepUser u1 = (XonlinepUser)xmacs.Context.UsersMachine.Clone();
                System.Threading.Thread.Sleep(1100); //avoid askdc anti-dos code
                xmacs = DoRequestVerify(MachineGt("XE.000000000202", "0x00000000000000000000000000000000", true));
                XonlinepUser u2 = (XonlinepUser)xmacs.Context.UsersMachine.Clone();

                // Puids should match
                if (u1.xuid.qwUserID != u2.xuid.qwUserID)
                {
                    Global.RO.Debug("Puids don't match.  Machine1=0x{0:X}, Machine2=0x{1:X}", u1.xuid.qwUserID, u2.xuid.qwUserID);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                // Compare keys.  Should be different.
                int i = 0;
                for (i = 0; i < u1.Key.Length; i++)
                {
                    if (u1.Key[i] != u2.Key[i])
                        break;
                }
                if (i == u1.Key.Length)
                {
                    Global.RO.Debug("Machine keys match.  They should be different.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("For verifying bug 48175, make sure t_machines is correct")]
        class VerifyDatabase_Xenon_Dev : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ClientType = AuthContext.ClientTypes.Xenon;
                consoleCert.SetConsoleType(ConsoleCertificate.CONSOLE_TYPE_DEV);
                XmacsClient xmacs = DoRequest(null);
                VerifyDatabase(xmacs);
            }
        }

        [TestCase, EnvRequirement("NCipher"), Description("For verifying bug 48175, make sure t_machines is correct")]
        class VerifyDatabase_Xenon_Retail : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ClientType = AuthContext.ClientTypes.Xenon;
                consoleCert.SetConsoleType(ConsoleCertificate.CONSOLE_TYPE_RETAIL);
                XmacsClient xmacs = DoRequest(null);
                VerifyDatabase(xmacs);
            }
        }

        [TestCase, Description("For verifying bug 48175, make sure t_machines is correct")]
        class VerifyDatabase_Xenon_TestkitDev : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ClientType = AuthContext.ClientTypes.Xenon;
                consoleCert.SetConsoleType(ConsoleCertificate.CONSOLE_TYPE_DEV | ConsoleCertificate.CONSOLE_TYPE_TESTKIT);
                XmacsClient xmacs = DoRequest(null);
                VerifyDatabase(xmacs);
            }
        }

        [TestCase, EnvRequirement("NCipher"), Description("For verifying bug 48175, make sure t_machines is correct")]
        class VerifyDatabase_Xenon_TestkitRetail : TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ClientType = AuthContext.ClientTypes.Xenon;
                consoleCert.SetConsoleType(ConsoleCertificate.CONSOLE_TYPE_DEV | ConsoleCertificate.CONSOLE_TYPE_TESTKIT);
                XmacsClient xmacs = DoRequest(null);
                VerifyDatabase(xmacs);
            }
        }


        [TestCase, EnvRequirement("NCipher"), Description("Create account as dev testkit, then reset account as retail testkit")]
        class Testkit_CreateDev_ResetRetail: TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                XmacsClient xmacs;
                XonlinepUser m1, m2;
                string name = XmacsClient.GenerateXenonPrincipal();

                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_DEV | ConsoleCertificate.CONSOLE_TYPE_TESTKIT);
                xmacs = DoRequest(MachineGt(name,                 "0x00000000000000000000000000000000", true));
                m1 = xmacs.Context.UsersMachine;

                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_RETAIL | ConsoleCertificate.CONSOLE_TYPE_TESTKIT);
                xmacs = DoRequest(MachineGt(name,                 "0x00000000000000000000000000000000", true));
                m2 = xmacs.Context.UsersMachine;

                // Should be same 
                CompareMachines(m1, m2, true);
            }
        }

        [TestCase, EnvRequirement("NCipher"), Description("Create account as dev testkit, ban it, then reset account as retail testkit")]
        class Testkit_CreateDev_Ban_ResetRetail: TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                XmacsClient xmacs;
                XonlinepUser m1;
                string name = XmacsClient.GenerateXenonPrincipal();

                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_DEV | ConsoleCertificate.CONSOLE_TYPE_TESTKIT);
                xmacs = DoRequest(MachineGt(name,                 "0x00000000000000000000000000000000", true));
                m1 = xmacs.Context.UsersMachine;

                ulong puid=xmacs.GetMachinePuid();
                MachineEditor machEd=MachineEditor.FromId(puid);
                machEd.BanMachine();

                this.consoleCert.SetConsoleTypeTest(ConsoleCertificate.CONSOLE_TYPE_RETAIL | ConsoleCertificate.CONSOLE_TYPE_TESTKIT);
                xmacs = DoRequest(MachineGt(name,                 "0x00000000000000000000000000000000", true)); //, E_NoResponse); //xmacs now allows banned consoles through
            }
        }

        [TestCase, Ignore] //we currently have no xmacs replay prevention
        class ReplayAttack: TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //do normal request
                ClientType = AuthContext.ClientTypes.Xenon;
                AuthContext ctx = new AuthContext(ClientType);
                XmacsClient xmacs = new XmacsClient(ctx);
                xmacs.SignInXmacs();

                //do replay
                try
                {
                    xmacs.ResendLastPacketAndRecv();
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Expected that resend to time out.");
            }
        }

        [TestCase, Description("Refurb sets t_user_keys version to 0.  Test that reset works on that.")]
        class RefurbReset: TestBase_XmacsXenon
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                //do normal request
                Global.RO.Debug("Creating a machine...");
                ClientType = AuthContext.ClientTypes.Xenon;
                AuthContext ctx = new AuthContext(ClientType);

                bool useXenonMacRequest2=(bool)GetContextData("UseMacRequest2");
                if (!useXenonMacRequest2)
                {
                    ctx.ConsoleSerialNumber=null;
                }

                XmacsClient xmacs = new XmacsClient(ctx);
                xmacs.SignInXmacs();

                //"refurb" the console... this means its user key verion gets set to 0
                Global.RO.Debug("\"Refurbing\" the machine...");
                UodbWS.ExecuteSQLNonQuery("update t_user_keys set i_key_version=0, i_key_enc_key_version=0 where vc_gamertag='XE."+xmacs.ConsoleId+"'", null); //harmless since it shouldn't exist in the new xmacs, but this is how legacy machine rows were updated
                UodbWS.ExecuteSQLNonQuery("update t_machine_xenon_keys set i_key_version=0, i_key_enc_key_version=0 where vc_console_id='XE."+xmacs.ConsoleId+"'", null);

                //do a request with it again
                Global.RO.Debug("Using the \"Refurbed\" machine...");
                xmacs.SignInXmacs();
            }
        }

        [TestCase, Description("Make an xmacs request using a randomly generated key pair for the console key, rather than the fixed hardcoded one used by default.")]
        public void RandomValidConsoleKeyPair()
        {
            KdcClientXbox360 client=new KdcClientXbox360();
            client.CreateXmacsRequest();

            client.XmacsRequest.Input.ConsoleCert=new ConsoleCertificate();
            client.XmacsRequest.Input.ConsoleCert.SetConsoleIdFromGamertag(client.XmacsRequest.Input.ConsoleId);
            client.XmacsRequest.Input.ConsoleCert.ConsolePublicKey.GenerateRandomKey();
            client.XmacsRequest.Input.ConsoleCert.Sign();

            bool useXenonMacRequest2=(bool)GetContextData("UseMacRequest2");
            if (!useXenonMacRequest2)
            {
                client.XmacsRequest.Input.ConsoleSerialNumber=null;
            }

            client.ExecuteXmacs(true);
        }

        [TestCase, Description("Verify a request where the client time is out of sync with the server time will result in a time skew error back to the client.")]
        [CompoundCase("-1 year",     -365*24*60)]
        [CompoundCase("-1 day",      -001*24*60)]
        [CompoundCase("-10 minutes", -001*01*10)]
        [CompoundCase("+1 year",     +365*24*60)]
        [CompoundCase("+1 day",      +001*24*60)]
        [CompoundCase("+10 minutes", +001*01*10)]
        public void TimeSkew(TestNode self)
        {
            int minutesOffset=(int)self.MyValues[0];

            KdcClientXbox360 client=new KdcClientXbox360();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.RequestTime=System.DateTime.UtcNow+new System.TimeSpan(0, minutesOffset, 0);

            bool useXenonMacRequest2=(bool)GetContextData("UseMacRequest2");
            if (!useXenonMacRequest2)
            {
                client.XmacsRequest.Input.ConsoleSerialNumber=null;
            }

            try
            {
                client.ExecuteXmacs(true);
            }
            catch (KerberosErrorException kee)
            {
                if ((int)kee.Error.ErrorCode.Int64==(int)KerbErrCode.KRB_AP_ERR_SKEW)
                {
                    return; //error was the expected KRB_AP_ERR_SKEW
                }

                throw;
            }

            throw new UnexpectedTestResultException("Expected request to fail but it succeeded.");
        }

        [TestCase, Description("Alter the AuthTime used in the preauth to verify that the server is validating it correctly.  By default it needs to be within 5 minutes of the current time.  THIS IS BROKEN.  In 2012 March we started to ship a fix for this, but it turned out that the xbox360 client is sending up garbage for this field.  As a result, validating it prevented every xbox360 from being able to call xmacs.  So we have disable the validation logic.  These tests now expect that we do not enforce this field.")]
        [CompoundCase("-1 year",     -365*24*60)]
        [CompoundCase("-1 day",      -001*24*60)]
        [CompoundCase("-10 minutes", -001*01*10)]
        [CompoundCase("-3 minutes",  -001*01*03)]
        [CompoundCase("+1 year",     +365*24*60)]
        [CompoundCase("+1 day",      +001*24*60)]
        [CompoundCase("+10 minutes", +001*01*10)]
        [CompoundCase("+3 minutes",  +001*01*03)]
        [CompoundCase("now",         +000*00*00)]
        public void AuthTimeInPreauth(TestNode self)
        {
            int minutesOffset=(int)self.MyValues[0];

            KdcClientXbox360 client=new KdcClientXbox360();
            client.RetryLostPackets=false;
            client.CreateXmacsRequest();

            //setup request
            bool useXenonMacRequest2=(bool)GetContextData("UseMacRequest2");
            if (!useXenonMacRequest2)
            {
                client.XmacsRequest.Input.ConsoleSerialNumber=null;
            }

            client.XmacsRequest.Input.GeneratePreauths();

            Kerberos.Preauth<Kerberos.PreauthXenonMacRequest> mac1=client.XmacsRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonMacRequest>>(209); //PADATA_XENON_MAC_REQUEST
            if (mac1!=null)
            {
                mac1.Data.AuthTime=(ulong)(System.DateTime.UtcNow+new System.TimeSpan(0, minutesOffset, 0)).ToFileTimeUtc();
                mac1.Data.Sign();
            }

            Kerberos.Preauth<Kerberos.PreauthXenonMacRequest2> mac2=client.XmacsRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonMacRequest2>>(219); //PADATA_XENON_MAC_REQUEST2
            if (mac2!=null)
            {
                mac2.Data.AuthTime=(ulong)(System.DateTime.UtcNow+new System.TimeSpan(0, minutesOffset, 0)).ToFileTimeUtc();
                mac2.Data.Sign();
            }

            client.XmacsRequest.SetRequest();
            client.XmacsRequest.ConstructRequest();

            //execute it
            //bool expectSuccess=Math.Abs(minutesOffset)<5;
            bool expectSuccess=true;

            if (!expectSuccess)
            {
                try
                {
                    client.ExecuteXmacs(false);
                }
                catch (KerberosErrorException kee)
                {
                    if ((int)kee.Error.ErrorCode.Int64==(int)KerbErrCode.KRB_AP_ERR_SKEW)
                    {
                        return; //error was the expected KRB_AP_ERR_SKEW
                    }

                    throw;
                }

                throw new UnexpectedTestResultException("Expected request to fail but it succeeded.");
            }
            else
            {
                client.ExecuteXmacs(false);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncXKDCAutoU.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace XkdcTest
{
    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(100), AsyncThreadCount(8)]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XKDCAutoUpdate : XkdcTestBaseGroup
    {
        //static protected KerbClient kcl = new KerbClient();

        /// [Test_Xkdc_Machine_TitleID_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xBAAD00
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE
        [TestCase, Description("Test_Xkdc_Machine_TitleID_01")]
        class Test_Xkdc_Machine_TitleID_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(0xBAAD00, 1, 1);
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE; // Since the logon will fail
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UNKNOWN_TITLE);
            }
        }

        /// [Test_Xkdc_Machine_TitleID_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xBAAD00
        /// services=base
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE
        [TestCase, Description("Test_Xkdc_Machine_TitleID_02")]
        class Test_Xkdc_Machine_TitleID_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(0xBAAD00, 1, 1);
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE; // Since the logon will fail
                ResultCode = GetMachineST(new uint[] {(uint)XOService.Base_Subscription},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UNKNOWN_TITLE);
            }
        }

        /// [Test_Xkdc_Machine_TitleID_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xBAAD00
        /// services=presence
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE
        [TestCase, Description("Test_Xkdc_Machine_TitleID_03")]
        class Test_Xkdc_Machine_TitleID_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(0xBAAD00, 1, 1);
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE; // Since the logon will fail
                ResultCode = GetMachineST(new uint[] {(uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UNKNOWN_TITLE);
            }
        }

        /// [Test_Xkdc_User_1_TitleID_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xBAAD00
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE
        [TestCase, Description("Test_Xkdc_User_1_TitleID_01")]
        class Test_Xkdc_User_1_TitleID_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(0xBAAD00, 1, 1);
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE; // Since the logon will fail
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UNKNOWN_TITLE,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_01_All]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF00 (-4264192)
        /// titleversion=
        /// titleregion=2, 2147483647, -2147483648, -1
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE or S_OK
        /// bug=19829
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_01_All")]
        class Test_Xkdc_Machine_AutoUpdate_01_All : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int[] version = {2,2147483647,-2147483648,-1};
                uint[] ExpectedHRs = new uint[1];
                uint ExpectedHR = HResult.S_OK;
                if (XkdcTestBaseGroup.settingAllowUnknownVersions)
                {
                    ExpectedHR = HResult.S_OK;
                    ExpectedHRs[0] = HResult.S_OK;
                }
                else
                {
                    ExpectedHR = HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
                    ExpectedHRs[0] = HResult.S_FALSE;
                }

                for(uint i = 0; i < 4; i++)
                {
                    TitleInfo TI = new TitleInfo(-4264192, version[i], 1);
                    ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        ExpectedHR);
                    if (ResultCode == TEST_RESULTS.FAILED)
                        return;
                }
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_02_1to3]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=1
        /// titleregion=1
        /// services=presence/useraccount/presence,useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_02_1to3")]
        class Test_Xkdc_Machine_AutoUpdate_02_1to3 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[2];
                ExpectedHRs[0] = HResult.S_FALSE; // Since the logon will fail
                ExpectedHRs[1] = HResult.S_FALSE; // Since the logon will fail
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);

                TEST_RESULTS result = GetMachineST(new uint[] {(uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
                if(result == TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.FAILED;

                result = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
                if(result == TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.FAILED;

                result = GetMachineST(new uint[] {(uint)XOService.PresNotification,
                                                  (uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
                if(result == TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_02_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=
        /// titleregion=
        /// services=autoupdate
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_02_04")]
        class Test_Xkdc_Machine_AutoUpdate_02_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetMachineST(new uint[] {(uint)XOService.Auto_Update},
                                   TI,
                                   ExpectedHRs,
                                   HResult.S_OK);
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_02_05]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=
        /// titleregion=
        /// services=useraccount,autoupdate
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_02_05")]
        class Test_Xkdc_Machine_AutoUpdate_02_05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[2];
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account,
                                                    (uint)XOService.Auto_Update},
                    TI,
                    ExpectedHRs,
                    (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0));
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_02_06]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=
        /// titleregion=
        /// services=presence,autoupdate
        /// granted=no,yes
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_02_06")]
        class Test_Xkdc_Machine_AutoUpdate_02_06 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;  // presence
                ResultCode = GetMachineST(new uint[] {(uint)XOService.PresNotification,
                                                        (uint)XOService.Auto_Update},
                    TI,
                    ExpectedHRs,
                    (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0));
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_02_07]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=
        /// titleregion=
        /// services=useraccount,presence,autoupdate
        /// granted=yes,no,yes
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_02_07")]
            class Test_Xkdc_Machine_AutoUpdate_02_07 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[3];
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;  // presence
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account,
                                                       (uint)XOService.PresNotification,
                                                       (uint)XOService.Auto_Update},
                    TI,
                    ExpectedHRs,
                    (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0));
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_02_08]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=2
        /// titleregion=
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_02_08")]
        class Test_Xkdc_Machine_AutoUpdate_02_08 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE; // Since the logon will fail
                TitleInfo TI = new TitleInfo(-4264191, 2, 1);
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_02_09]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=3
        /// titleregion=
        /// services=useraccount
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_02_09")]
        class Test_Xkdc_Machine_AutoUpdate_02_09 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                TitleInfo TI = new TitleInfo(-4264191, 3, 1);
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_02_10]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=4
        /// titleregion=
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE or S_OK
        /// bug=19829
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_02_10")]
        class Test_Xkdc_Machine_AutoUpdate_02_10 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[12];
                TitleInfo TI = new TitleInfo(-4264191, 4, 1);
                uint ExpectedHR = HResult.S_OK;
                if (XkdcTestBaseGroup.settingAllowUnknownVersions)
                {
                    ExpectedHR = HResult.S_OK;
                    ExpectedHRs[0] = HResult.S_OK;
                }
                else
                {
                    ExpectedHR = HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
                    ExpectedHRs[0] = HResult.S_FALSE;
                }
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    ExpectedHR);
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_03_ALL]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF02 (-4264190)
        /// titleversion=1,2,2147483647,-2147483648,-1
        /// services=useraccount
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_03_All")]
        class Test_Xkdc_Machine_AutoUpdate_03_All : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                // Valid versions (cases 03.02-03.05)
                int[] version = {1,2,2147483647,-2147483648,-1};
                uint[] ExpectedHRs = new uint[1];
                for(uint i = 0; i < version.Length; i++)
                {
                    TitleInfo TI = new TitleInfo(-4264190, version[i], 1);
                    if(GetMachineST(new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        HResult.S_OK) != TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_04.01]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF03 (-4264189)
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE or S_OK
        /// bug=19829
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_04_01")]
        class Test_Xkdc_Machine_AutoUpdate_04_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                TitleInfo TI = new TitleInfo(-4264189, 1, 1);
                uint ExpectedHR = HResult.S_OK;
                if (XkdcTestBaseGroup.settingAllowUnknownVersions)
                {
                    ExpectedHR = HResult.S_OK;
                    ExpectedHRs[0] = HResult.S_OK;
                }
                else
                {
                    ExpectedHR = HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
                    ExpectedHRs[0] = HResult.S_FALSE;
                }

                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    ExpectedHR);
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_05_ALL]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF04 (-4264188)
        /// titleversion=2147483646,-2147483648,-2
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_05_All")]
        class Test_Xkdc_Machine_AutoUpdate_05_All : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;  // Since logon will fail
                // Bad versions (cases 03.02-03.05)
                int[] version = {2147483646,-2147483648,-2};
                for(uint i = 0; i < version.Length; i++)
                {
                    TitleInfo TI = new TitleInfo(-4264188, version[i], 1);
                    if(GetMachineST(new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        HResult.XONLINE_E_LOGON_UPDATE_REQUIRED) != TEST_RESULTS.PASSED)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_06.01]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF05 (-4264187)
        /// titleversion=2147483647
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_06_01")]
        class Test_Xkdc_Machine_AutoUpdate_06_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;  // Since logon will fail
                TitleInfo TI = new TitleInfo(-4264187, 2147483647, 1);
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_07_01to03]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF06 (-4264186)
        /// titleversion=1,2,3
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_07_01to03")]
        class Test_Xkdc_Machine_AutoUpdate_07_01to03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;  // Since logon will fail
                int[] version = {1,2,3};
                for(uint i = 0; i < version.Length; i++)
                {
                    TitleInfo TI = new TitleInfo(-4264186, version[i], 1);
                    if(GetMachineST(new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        HResult.XONLINE_E_LOGON_UPDATE_REQUIRED) != TEST_RESULTS.PASSED)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_07_04to05]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF06 (-4264186)
        /// titleversion=4,5
        /// services=useraccount
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_07_04to05")]
        class Test_Xkdc_Machine_AutoUpdate_07_04to05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                int[] version = {4,5};
                for(uint i = 0; i < version.Length; i++)
                {
                    TitleInfo TI = new TitleInfo(-4264186, version[i], 1);
                    if(GetMachineST(new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        HResult.S_OK) != TEST_RESULTS.PASSED)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_08_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF07 (-4264185)
        /// services=useraccount
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_08_01")]
        class Test_Xkdc_Machine_AutoUpdate_08_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                TitleInfo TI = new TitleInfo(-4264185, 1, 1);
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_08_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF07 (-4264185)
        /// titleversion=3
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_08_02")]
        class Test_Xkdc_Machine_AutoUpdate_08_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // Since logon will fail
                TitleInfo TI = new TitleInfo(-4264185, 3, 1);
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_09_01to02]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF08 (-4264184)
        /// titleversion=1,2
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_09_01to02")]
        class Test_Xkdc_Machine_AutoUpdate_09_01to02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // since logon will fail
                int[] version = {1,2};
                for(uint i = 0; i < version.Length; i++)
                {
                    TitleInfo TI = new TitleInfo(-4264184, version[i], 1);
                    if(GetMachineST(new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        HResult.XONLINE_E_LOGON_UPDATE_REQUIRED) != TEST_RESULTS.PASSED)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_Machine_AutoUpdate_10_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF09 (-4264183)
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        [TestCase, Description("Test_Xkdc_Machine_AutoUpdate_10_01")]
        class Test_Xkdc_Machine_AutoUpdate_10_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // since logon will fail
                TitleInfo TI = new TitleInfo(-4264183, 1, 1);
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        /// country=0
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_01")]
        class Test_Xkdc_User_1_AutoUpdate_02_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // since logon will fail
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetUserST("xktuser7a",
                    new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=presence
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        /// country=0
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_02")]
        class Test_Xkdc_User_1_AutoUpdate_02_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // since logon will fail
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=useraccount, presence
        /// granted=false, false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        /// country=0
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_03")]
        class Test_Xkdc_User_1_AutoUpdate_02_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[2];
                ExpectedHRs[0] = HResult.S_FALSE;    // since logon will fail
                ExpectedHRs[1] = HResult.S_FALSE;    // since logon will fail
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account,
                                (uint)XOService.PresNotification},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=autoupdate
        /// country=0
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_04")]
        class Test_Xkdc_User_1_AutoUpdate_02_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.Auto_Update},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02.05]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=useraccount, autoupdate
        /// country=0
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_05")]
        class Test_Xkdc_User_1_AutoUpdate_02_05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[2];
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account,
                                (uint)XOService.Auto_Update},
                    TI,
                    ExpectedHRs,
                    (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0),
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02_06]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=presence, autoupdate
        /// granted=no, yes
        /// country=0
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_06")]
        class Test_Xkdc_User_1_AutoUpdate_02_06 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[2];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Presence
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.PresNotification,
                                   (uint)XOService.Auto_Update},
                    TI,
                    ExpectedHRs,
                    (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0),
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02_07]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=useraccount, presence, autoupdate
        /// granted=yes, no, yes
        /// country=0
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_07")]
        class Test_Xkdc_User_1_AutoUpdate_02_07 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[3];
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Presence
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account,
                                (uint)XOService.PresNotification,
                                (uint)XOService.Auto_Update},
                    TI,
                    ExpectedHRs,
                    (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0),
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02.08]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=2
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        /// country=0
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_08")]
        class Test_Xkdc_User_1_AutoUpdate_02_08 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // Since logon will fail
                TitleInfo TI = new TitleInfo(-4264191, 2, 1);
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02.09]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=3
        /// services=useraccount
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_09")]
        class Test_Xkdc_User_1_AutoUpdate_02_09 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                TitleInfo TI = new TitleInfo(-4264191, 3, 1);
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_User_1_AutoUpdate_02.10]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=4
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE or S_OK
        /// country=0
        /// bug=19829
        [TestCase, Description("Test_Xkdc_User_1_AutoUpdate_02_10")]
        class Test_Xkdc_User_1_AutoUpdate_02_10 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[1];
                TitleInfo TI = new TitleInfo(-4264191, 4, 1);
                uint ExpectedHR = HResult.S_OK;
                if (XkdcTestBaseGroup.settingAllowUnknownVersions)
                {
                    ExpectedHR = HResult.S_OK;
                    ExpectedHRs[0] = HResult.S_OK;
                }
                else
                {
                    ExpectedHR = HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
                    ExpectedHRs[0] = HResult.S_FALSE;
                }
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktuser7a"),
                    new uint[] {(uint)XOService.User_Account},
                    TI,
                    ExpectedHRs,
                    ExpectedHR,
                    's');
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a, xktuser7b
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        /// country=0, 0
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_01")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // Since logon fails
                String[] users = new String[2];
                users[0] = "xktuser7a";
                users[1] = "xktuser7b";
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    if(GetUserST(name,
                        new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,
                        's') != TEST_RESULTS.PASSED)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a, xktuser7c
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=presence
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        /// country=0, 0
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_02")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // Since logon fails
                String[] users = new String[2];
                users[0] = "xktuser7a";
                users[1] = "xktuser7c";
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    if(GetUserST(name,
                        new uint[] {(uint)XOService.PresNotification},
                        TI,
                        ExpectedHRs,
                        HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,
                        's') != TEST_RESULTS.PASSED)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7d, xktuser7c, xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=useraccount, presence
        /// granted=false, false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        /// country=0, 0, 0
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_03")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[2];
                ExpectedHRs[0] = HResult.S_FALSE;    // Since logon fails - user account
                ExpectedHRs[1] = HResult.S_FALSE;    // Since logon fails - presence
                String[] users = new String[3];
                users[0] = "xktuser7d";
                users[1] = "xktuser7c";
                users[2] = "xktuser7a";
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    if(GetUserST(name,
                        new uint[] {(uint)XOService.User_Account,
                                    (uint)XOService.PresNotification},
                        TI,
                        ExpectedHRs,
                        HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,
                        's') != TEST_RESULTS.PASSED)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7b, xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=autoupdate, stats
        /// granted=yes, no
        /// country=0, 0
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_04")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[2];
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Stats
                String[] users = new String[2];
                users[0] = "xktuser7b";
                users[1] = "xktuser7a";
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    if(GetUserST(name,
                        new uint[] {(uint)XOService.Auto_Update,
                                    (uint)XOService.Stats},
                        TI,
                        ExpectedHRs,
                        (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0),
                        's') != TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_05]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a, xktuser7b, xktuser7c, xktuser7d
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=useraccount, autoupdate
        /// country=0, 0, 0, 0
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_05")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[2];
                String[] users = new String[4];
                users[0] = "xktuser7a";
                users[1] = "xktuser7b";
                users[2] = "xktuser7c";
                users[3] = "xktuser7d";
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    if(GetUserST(name,
                        new uint[] {(uint)XOService.User_Account,
                                    (uint)XOService.Auto_Update},
                        TI,
                        ExpectedHRs,
                        (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0),
                        's') != TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_06]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7d, xktuser7c
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=presence, autoupdate
        /// granted=no, yes
        /// country=0, 0
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_06")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_06 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[2];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Presence
                String[] users = new String[2];
                users[0] = "xktuser7d";
                users[1] = "xktuser7c";
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    if(GetUserST(name,
                        new uint[] {(uint)XOService.PresNotification,
                                       (uint)XOService.Auto_Update},
                        TI,
                        ExpectedHRs,
                        (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0),
                        's') != TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_07]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7a, xktuser7b, xktuser7d
        /// titleid=0xFFBEEF01 (-4264191)
        /// services=useraccount, presence, autoupdate
        /// granted=yes, no, yes
        /// country=0, 0, 0
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_07")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_07 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[3];
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED; // Presence
                String[] users = new String[3];
                users[0] = "xktuser7a";
                users[1] = "xktuser7b";
                users[2] = "xktuser7d";
                TitleInfo TI = new TitleInfo(-4264191, 1, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    if(GetUserST(name,
                        new uint[] {(uint)XOService.User_Account,
                                       (uint)XOService.PresNotification,
                                       (uint)XOService.Auto_Update},
                        TI,
                        ExpectedHRs,
                        (IsXenonClient?HResult.XONLINE_E_LOGON_UPDATE_REQUIRED:0),
                        's') != TEST_RESULTS.PASSED)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02.08]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7b, xktuser7d, xktuser7b
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=2
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UPDATE_REQUIRED
        /// country=0, 0, 0
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_08")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_08 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.S_FALSE;    // since logon will fail
                String[] users = new String[3];
                users[0] = "xktuser7b";
                users[1] = "xktuser7d";
                users[2] = "xktuser7b";
                TitleInfo TI = new TitleInfo(-4264191, 2, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    if(GetUserST(name,
                        new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,
                        's') != TEST_RESULTS.PASSED)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_09]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7b, xktuser7a, xktuser7c
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=3
        /// services=useraccount
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_09")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_09 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                String[] users = new String[3];
                users[0] = "xktuser7b";
                users[1] = "xktuser7a";
                users[2] = "xktuser7c";
                TitleInfo TI = new TitleInfo(-4264191, 3, 1);
                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    ResultCode = GetUserST(name,
                        new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        HResult.S_OK,
                        's');
                }
            }
        }

        /// [Test_Xkdc_User_Multi_AutoUpdate_02_10]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktuser7d, xktuser7c, xktuser7b, xktuser7a
        /// titleid=0xFFBEEF01 (-4264191)
        /// titleversion=4
        /// services=useraccount
        /// granted=false
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE or S_OK
        /// country=0, 0, 0, 0
        /// bug=19829
        [TestCase, Description("Test_Xkdc_User_Multi_AutoUpdate_02_10")]
        class Test_Xkdc_User_Multi_AutoUpdate_02_10 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint[] ExpectedHRs = new uint[1];
                String[] users = new String[4];
                users[0] = "xktuser7d";
                users[1] = "xktuser7c";
                users[2] = "xktuser7b";
                users[3] = "xktuser7a";
                TitleInfo TI = new TitleInfo(-4264191, 4, 1);
                uint ExpectedHR = HResult.S_OK;
                if (XkdcTestBaseGroup.settingAllowUnknownVersions)
                {
                    ExpectedHR = HResult.S_OK;
                    ExpectedHRs[0] = HResult.S_OK;
                }
                else
                {
                    ExpectedHR = HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
                    ExpectedHRs[0] = HResult.S_FALSE;
                }

                foreach(String name in users)
                {
                    UserTimer.AccessSharedUser(name);
                    ResultCode = GetUserST(name,
                        new uint[] {(uint)XOService.User_Account},
                        TI,
                        ExpectedHRs,
                        ExpectedHR,
                        's');
                    if (ResultCode == TEST_RESULTS.FAILED)
                        return;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncXKDCMultiServiceRequests.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;

//These tests are designed to more closely mimic the type of behavior that a normal client uses to acquire its services.
//  these were written to test the kdc request caching.
//Some of the tests expect there to be more than one site, so may have issues on weird environments.

namespace XkdcTest
{
    #region Base

    //base for a test case that signs into the xmacs/askdc and makes multiple requests to the xkdc.
    public abstract class TestBase_MultiRequest: TestBase_Xkdc
    {
        public bool Verbose=true;
        public bool ExpectUnauthorizedServices=false;

        //signs into the xkdc initially, using auto
        public bool SignInXkdc_Auto()
        {
            DisableRetryBehaviour=true;
            bVerifyServices=false;

            bool success=SignInXkdc(true,null,null,false);
            if (success)
            {
                uint []missingServices=GetMissingServices();
                uint numMissing=(missingServices==null?0:(uint)missingServices.Length);
                if (Verbose) ro.Info("Signed in with auto and got " + GetNumServicesReturned() + " service responses.  " + numMissing + " of these are hr 1.");
                SpewResultServiceHRs();
            }
            return success;
        }

        //signs into the xkdc initially, using manual service requests
        public bool SignInXkdc_Manual(uint []requests)
        {
            DisableRetryBehaviour=true;
            bVerifyServices=false;

            ExpectedServices=requests;
            bool success=SignInXkdc(false,null,null,false);
            if (success)
            {
                uint []missingServices=GetMissingServices();
                uint numMissing=(missingServices==null?0:(uint)missingServices.Length);
                if (Verbose) ro.Info("Signed in with requests for " + requests.Length + " services(" + UintArrayToString(requests) + "), and got " + GetNumServicesReturned() + " service responses.  " + numMissing + " of these are hr 1.");
                SpewResultServiceHRs();
            }
            return success;
        }

        //signs into tho xkdc and requests and services that previously had 1 as a return value
        //returns true if there are more services not yet retrieved
        public bool SignInXkdc_MissingServices()
        {
            return SignInXkdc_MissingServices(null);
        }
        public bool SignInXkdc_MissingServices(uint []extraServices)
        {
            bVerifyServices=false;

            if (result==null)
            {
                Fail("You must sign into the xkdc initially first, before calling this.");
                return false;
            }

            //find all hr=1's to make a new list of services we want
            uint []missingServices=GetMissingServices();
            if (missingServices==null) return false;

            if (extraServices!=null)
            {
                XkdcUtilities.AddToArrayNonunique(ref missingServices, extraServices);
            }

            //sign in, requesting those services
            ExpectedServices=missingServices;
            SignInXkdc(false,null,null,false);
            missingServices=GetMissingServices();
            uint numMissing=(missingServices==null?0:(uint)missingServices.Length);
            if (Verbose) ro.Info("Signed in with requests for " + ExpectedServices.Length + " services(" + UintArrayToString(ExpectedServices) + "), and got " + GetNumServicesReturned() + " service responses.  " + numMissing + " of these are hr 1.");
            SpewResultServiceHRs();

            //if we signed in with the same the same request twice, it means we made no progress.. so give up.  Should never happen.
            if (lastMissingRequest!=null && missingServices!=null && ArrayEx.Compare(lastMissingRequest,missingServices)==true)
            {
                Fail("We made the same request twice, and no progress was made toward acquiring more services... this shouldn't happen.  Giving up.");
                return false;
            }

            //
            lastMissingRequest=missingServices;
            return numMissing!=0;
        }

        //makes and sets a new user correctly, based on platform type
        public void MakeAndSetNewUser(bool gold, int slot)
        {
            if (ClientType==AuthContext.ClientTypes.Panorama)
            {
                authContext.SetNewPassportUser(slot, gold);
            }
            else
            {
                UserEditor user = UserEditor.CreateNew();
                if (!gold)
                {
                    user.RemoveAllSubscriptions(true);
                    user.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                }
                authContext.SetUser(user, slot);
            }
        }

        //returns a list of services that returned 1, or null if none
        protected uint[] GetMissingServices()
        {
            if (result==null)
            {
                Fail("No result from kdc sign-in?");
                return null;
            }

            //count them
            uint count=0;
            for (uint i=0; i<result.ServiceIDs.Length; ++i)
            {
                if (result.ServiceHRs[i]==1)
                    ++count;
            }

            if (count==0)
                return null;

            //make a list of them
            uint []otherServices=new uint[count];
            count=0;
            for (uint i=0; i<result.ServiceIDs.Length; ++i)
            {
                if (result.ServiceHRs[i]==1)
                {
                    otherServices[count]=result.ServiceIDs[i];
                    ++count;
                }
            }

            //
            return otherServices;
        }

        //gets the number of non-zero service ids returned
        uint GetNumServicesReturned()
        {
            if (result==null) return 0;

            uint count=0;
            for (uint i=0; i<result.ServiceIDs.Length; ++i)
            {
                if (result.ServiceIDs[i]!=0) ++count;
            }

            return count;
        }

        //debug: spew full service list
        private void SpewResultServiceHRs()
        {
            if (result==null) return;

            string svc="Services list: ";
            bool first=true;
            bool oddness=false;
            for (uint i=0; i<result.ServiceIDs.Length; ++i)
            {
                if (result.ServiceIDs[i]!=0)
                {
                    if (!first) svc+=", ";
                    first=false;
                    string val=result.ServiceHRs[i].ToString();
                    if (result.ServiceHRs[i]==0) val+="(success)";
                    else if (result.ServiceHRs[i]==1) val+="(different site)";
                    else if (result.ServiceHRs[i]==HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED)
                    {
                        val+="(XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED)";
                        if (!ExpectUnauthorizedServices) oddness=true;
                    }
                    else
                    {
                        val+="???";
                        oddness=true;
                    }
                    svc+=result.ServiceIDs[i].ToString() + "=" + val;
                }
            }

            if (oddness)
            {
                Fail("Unexpected result in services list: " + svc);
            }
            else
            {
                if (Verbose) ro.Debug(svc);
            }
        }

        //
        private string UintArrayToString(uint []arr)
        {
            bool first=true;
            string str="";
            for (uint i=0; i<arr.Length; ++i)
            {
                if (!first) str+=", ";
                first=false;
                str+=arr[i].ToString();
            }

            return str;
        }

        //
        uint []lastMissingRequest=null;
    };

    #endregion //Base

    [TestGroup, AsyncThreadCount(4), AsyncThreadDelay(200), AsyncGroup(1, 0), TestCasePriority(2)]
    public class XKDCMultiRequest: XkdcTestBaseGroup
    {
        #region MainLine

        //
        [TestCase, Description("Sign into the xkdc with auto then repeatedly request services that we didn't get until we get them all")]
        [CompoundCase("XenonUserSilver",    AuthContext.ClientTypes.Xenon,    true,  false)] //client type, user or machine, user gold
        [CompoundCase("PanoramaUserSilver", AuthContext.ClientTypes.Panorama, true,  false)]
        [CompoundCase("XenonUserGold",      AuthContext.ClientTypes.Xenon,    true,  true)]
        [CompoundCase("PanoramaUserGold",   AuthContext.ClientTypes.Panorama, true,  true)]
        [CompoundCase("XenonMachine",       AuthContext.ClientTypes.Xenon,    false)]
        [CompoundCase("PanoramaMachine",    AuthContext.ClientTypes.Panorama, false)]
        class DefaultAuto: TestBase_MultiRequest
        {
            override protected void RunTest()
            {
                ClientType=(AuthContext.ClientTypes)MyValues[0];
                authContext=null;
                SetDefaults();

                if ((bool)MyValues[1])
                    MakeAndSetNewUser((bool)MyValues[2], 0);

                SignInXkdc_Auto();
                if (GetMissingServices().Length==0)
                    throw new System.Exception("There were no services returned on a different site.");

                while (SignInXkdc_MissingServices()) {}
            }
        }

        //
        [TestCase, Description("Similar to what was seen from the logs of a real title")]
        public class MainlineXenon: TestBase_MultiRequest
        {
            private bool stress=false;

            public MainlineXenon()
            {
                ClientType=AuthContext.ClientTypes.Xenon;
                authContext=null;
            }
            public MainlineXenon(bool isStress): this()
            {
                stress=isStress;
                if (stress) bSetDefaults=false;
            }

            public void SetAuthContext(AuthContext ctx)
            {
                authContext=ctx;
            }

            override protected void RunTest()
            {
                uint []newServices=new uint[] {14,15};
                if (!stress)
                {
                    SetDefaults();
                    MakeAndSetNewUser(true, 0);
                }
                else
                {
                    if (authContext.Users[0]!=null && authContext.Users[0].Gamertag[0]=='x') //functional user, may have odd restrictions
                    {
                        ExpectUnauthorizedServices=true;
                    }

                    newServices=new uint[] {9};
                }
                SignInXkdc_Auto();
                if (SignInXkdc_MissingServices(newServices))
                {
                    while (SignInXkdc_MissingServices()) {}
                }
            }
        }

        //
        [TestCase, Description("Similar to what was seen from the logs of a real title")]
        public class MainlinePanorama: TestBase_MultiRequest
        {
            private bool stress=false;
            public MainlinePanorama()
            {
                ClientType=AuthContext.ClientTypes.Panorama;
                authContext=null;
            }
            public MainlinePanorama(bool isStress): this()
            {
                stress=isStress;
                if (stress) bSetDefaults=false;
            }

            public void SetAuthContext(AuthContext ctx)
            {
                authContext=ctx;
            }

            override protected void RunTest()
            {
                if (!stress)
                {
                    ClientType=AuthContext.ClientTypes.Panorama;
                    authContext=null;
                    SetDefaults();
                    authContext.SetNewPassportUser(0,true);
                }
                else
                {
                    ExpectUnauthorizedServices=true;
                }
                SignInXkdc_Auto();
                if (SignInXkdc_MissingServices(new uint[] {14,15} ))
                {
                    while (SignInXkdc_MissingServices()) {}
                }
            }
        }

        //
        [TestCase, Description("")]
        public class MainlinePanoramaLimited: TestBase_MultiRequest
        {
            private bool stress=false;
            public MainlinePanoramaLimited()
            {
                ClientType=AuthContext.ClientTypes.Panorama;
                authContext=null;
            }
            public MainlinePanoramaLimited(bool isStress): this()
            {
                stress=isStress;
                if (stress) bSetDefaults=false;
            }

            public void SetAuthContext(AuthContext ctx)
            {
                authContext=ctx;
            }

            override protected void RunTest()
            {
                if (!stress)
                {
                    ClientType=AuthContext.ClientTypes.Panorama;
                    authContext=null;
                    SetDefaults();
                    authContext.SetNewPassportUser(0,true);
                }
                else
                {
                    ExpectUnauthorizedServices=true;
                }
                authContext.SponsorToken=PanoramaLimited.c_LimitedToken;
                authContext.IsPCLimited=true;
                SignInXkdc_Auto();
                if (SignInXkdc_MissingServices(new uint[] {14,15} ))
                {
                    while (SignInXkdc_MissingServices()) {}
                }
            }
        }

        #endregion //MainLine

        #region Unusual

        //
        [TestCase, Description("Xenon, doing a manual like xbox1 normally does")]
        class NoAutoXenon: TestBase_MultiRequest
        {
            override protected void RunTest()
            {
                ClientType=AuthContext.ClientTypes.Xenon;
                authContext=null;
                SetDefaults();
                MakeAndSetNewUser(true, 0);
                SignInXkdc_Manual(new uint[] {1, 2, 4, 6, 7, 8, 9, 13, 14, 15, 16, 18, 19, 20});
                while (SignInXkdc_MissingServices()) {}
            }
        }

        //
        [TestCase, Description("Xenon, doing a manual like xbox1 normally does once... then start over and do auto")]
        class NoAutoThenAutoXenon: TestBase_MultiRequest
        {
            override protected void RunTest()
            {
                ClientType=AuthContext.ClientTypes.Xenon;
                authContext=null;
                SetDefaults();
                MakeAndSetNewUser(true, 0);
                SignInXkdc_Manual(new uint[] {1, 2, 4, 6, 7, 8, 9, 13, 14, 15, 16, 18, 19, 20});
                SignInXkdc_Auto();
                while (SignInXkdc_MissingServices()) {}
            }
        }

        //
        [TestCase, Description("Request a bunch of services, but do it one at a time")]
        [CompoundCase("Xenon",AuthContext.ClientTypes.Xenon)]
        [CompoundCase("Panorama",AuthContext.ClientTypes.Panorama)]
        class ManyTinyRequests: TestBase_MultiRequest
        {
            override protected void RunTest()
            {
                ClientType=(AuthContext.ClientTypes)MyValues[0];
                authContext=null;
                SetDefaults();

                MakeAndSetNewUser(true, 0);

                uint []services;
                if (ClientType==AuthContext.ClientTypes.Xbox)
                {
                    authContext.SetTitle(0x4d530064, 1, 1);
                    services=new uint[]{1, 2, 4, 6, 7, 8, 9, 13, 14, 15, 16, 18, 19, 20};
                }
                else
                    services=new uint[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 16, 18, 19, 21, 14, 15};

                foreach (uint s in services)
                {
                    SignInXkdc_Manual(new uint[]{s});
                }
            }
        }

        #endregion //Unusual

        #region CacheTests

        //
        [TestCase, Description("Sign in with auto, ban in uodb, then request hr1's.  The signin will fail miserably without request caching, and succeed with it.")]
        [CompoundCase("XenonUser",AuthContext.ClientTypes.Xenon, true)]
        [CompoundCase("PanoramaUser",AuthContext.ClientTypes.Panorama, true)]
        //[CompoundCase("XboxMachine",AuthContext.ClientTypes.Xbox, false)] //this case fails.  known kdc bug, won't fix: 94012
        [CompoundCase("XenonMachine",AuthContext.ClientTypes.Xenon, false)]
        [CompoundCase("PanoramaMachine",AuthContext.ClientTypes.Panorama, false)]
        class CacheCheck: TestBase_MultiRequest
        {
            override protected void RunTest()
            {
                ClientType=(AuthContext.ClientTypes)MyValues[0];
                authContext=null;
                SetDefaults();
                AskdcClient.SetDefaults(authContext);

                //make user for user tests
                if ((bool)MyValues[1])
                {
                    ro.Info("Making and setting user...");
                    MakeAndSetNewUser(true, 0);
                }

                //explicitely do xmacs so we can access the machine puid
                ro.Info("Signing in xmacs...");
                XmacsClient xmacs=new XmacsClient(authContext);
                xmacs.SignInXmacs();

                //make initial request (should hit uodb)
                ro.Info("Making initial request...");
                if (ClientType==AuthContext.ClientTypes.Xbox) //xbox1
                {
                    if ((bool)MyValues[1]) SignInXkdc_Manual(new uint[] {4, 6, 7, 8, 9, 13, 14, 15, 16, 18, 19, 20}); //user
                    else SignInXkdc_Manual(new uint[] {4, 7, 9, 20}); //machine
                }
                else //xenon, panorama
                {
                    SignInXkdc_Auto();
                }

                if (GetMissingServices().Length==0)
                    throw new System.Exception("There were no services returned on a different site.");

                //mark as banned in uodb
                ulong puid=xmacs.GetMachinePuid();
                MachineEditor machEd=MachineEditor.FromId(puid);
                machEd.BanMachine();

                //finish requests (if we have caching enabled and it works, we won't pick up the ban for 10s still, so we can finish the requests)
                ro.Info("Doing followup requests...");
                while (SignInXkdc_MissingServices()) {}
            }
        }

        //
        [TestCase, AsyncGroup(0), Description("Sign into the xdc, change titles to one that gets a special service, then sign in again")]
        [CompoundCase("Xenon",AuthContext.ClientTypes.Xenon)]
        class ChangeTitle_Service: TestBase_MultiRequest
        {
            override protected void RunTest()
            {
                ClientType=(AuthContext.ClientTypes)MyValues[0];
                authContext=null;
                SetDefaults();
                authContext.SetUser(UserTimer.AccessSharedUser("xktdulsput2a"), 0);
                ExpectUnauthorizedServices=true;
                ro.Info("Signing in with a title without access to 8013...");
                bool success=(ClientType==AuthContext.ClientTypes.Xenon?SignInXkdc_Auto():SignInXkdc_Manual(new uint[] {2, 4, 20, 8013}));
                uint status;
                if (WasServiceOffered(8013, out status) && status!=HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED)
                {
                    throw new System.Exception("Should not have been offered service 8013 yet..");
                }
                while (SignInXkdc_MissingServices()) {}

                authContext.ClearXkdc();

                if (ClientType==AuthContext.ClientTypes.Xenon) authContext.SetTitle(0xFFBEEF2b, 1, 1); //xenon
                else authContext.SetTitle(0xFFBEEF2a, 1, 1); //xbox1

                ExpectUnauthorizedServices=false;
                ro.Info("Signing in with a title that gets service 8013...");
                success=(ClientType==AuthContext.ClientTypes.Xenon?SignInXkdc_Auto():SignInXkdc_Manual(new uint[] {2, 4, 20, 8013}));
                if (!WasServiceOffered(8013, out status) || !(status==0 || status==1))
                {
                    throw new System.Exception("Expected to be offered service 8013");
                }
                while (SignInXkdc_MissingServices()) {}
            }
        }

        //
        [TestCase, Description("make a request on the normal title, change to a title that gets an extra privelege, then change back to a normal one")]
        class ChangeTitlePrivelegeXenon: TestBase_MultiRequest
        {
            override protected void RunTest()
            {
                ClientType=AuthContext.ClientTypes.Xenon;
                authContext=null;
                SetDefaults();
                authContext.SetNewUser(0,false);

                //
                ro.Info("Signing in a title without the extra privelege...");
                authContext.SetTitle(0xC0FE0800, 1, 1);
                SignInXkdc_Auto();
                if (WasPrivelegeOffered(193,0))
                {
                    throw new System.Exception("We should NOT have gotten privelege 193 to start with.");
                }
                while (SignInXkdc_MissingServices()) {}
                
                //
                authContext.ClearXkdc();
                authContext.SetTitle(0xFFBEEF2b, 1, 1);
                ro.Info("Signing in with extra title privelege...");
                SignInXkdc_Auto();
                if (!WasPrivelegeOffered(193,0))
                {
                    throw new System.Exception("We did not get our extra privelege of 193.");
                }
                while (SignInXkdc_MissingServices()) {}

                //
                ro.Info("Signing in a different title without that privelege...");
                authContext.SetTitle(0xC0FE0800, 1, 1);
                BuildExpectations(true, new uint[0]);
                SignInXkdc_Auto();
                if (WasPrivelegeOffered(193,0))
                {
                    throw new System.Exception("We should NOT have gotten privelege 193 this time.");
                }
                while (SignInXkdc_MissingServices()) {}
            }
        }

        //
        [TestCase, Description("Sign into the xdc repeatedly.. and get banned at some point. The cache should flushed at some point so the ban is picked up")]
        [CompoundCase("Xenon",AuthContext.ClientTypes.Xenon)]
        [CompoundCase("Panorama",AuthContext.ClientTypes.Panorama)]
        class CacheFlushBan: TestBase_MultiRequest
        {
            override protected void RunTest()
            {
                const uint maxFlushTime=20; //must be greater than kdc cache flush timer

                ClientType=(AuthContext.ClientTypes)MyValues[0];
                authContext=null;
                SetDefaults();

                MakeAndSetNewUser(true, 0);

                XmacsClient xmacs=new XmacsClient(authContext);
                xmacs.SignInXmacs();

                bool didBan=false;
                for (uint count=0; count<maxFlushTime; ++count)
                {
                    bool success;
                    if (ClientType==AuthContext.ClientTypes.Xbox) success=SignInXkdc_Manual(new uint[] {4, 6, 7, 8, 9, 13, 14, 15, 16, 18, 19, 20});
                    else success=SignInXkdc_Auto();

                    if (success)
                    {
                        while (SignInXkdc_MissingServices()) {}
                    }
                    else
                    {
                        if (!didBan)
                        {
                            throw new System.Exception("failed to sign in, but we haven't even banned them yet.");
                        }
                        else //this is what should happen eventually (or immediately, before cache is implemented on the kdc)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                            return;
                        }
                    }

                    if (count==4) //ban them, rar!
                    {
                        ulong puid=xmacs.GetMachinePuid();
                        MachineEditor machEd=MachineEditor.FromId(puid);
                        machEd.BanMachine();

                        didBan=true;
                    }

                    System.Threading.Thread.Sleep(1000);
                }

                throw new System.Exception("We never picked up the new banned state...");
            }
        }

        #endregion //CacheFlushCheck
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\FuncXKDCSites.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;

namespace XkdcTest
{
    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(250), AsyncThreadCount(10)]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XKDCSites : XkdcTestBaseGroup
    {
        /// [Test_Xkdc_Machine_Logon_Sites_01_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// site=7045
        /// services=8001
        /// granted=yes
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_01")]
        class Test_Xkdc_Machine_Logon_Sites_01_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetMachineSTwithSite(new uint[] {8001},
                    ExpectedHRs,
                    HResult.S_OK,
                    7045);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// site=7045
        /// services=8001
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_01")]
        class Test_Xkdc_User_1_Logon_Sites_01_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8001},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8002
        /// granted=no
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_02")]
        class Test_Xkdc_Machine_Logon_Sites_01_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8002},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// site=7045
        /// services=8002
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_02")]
        class Test_Xkdc_User_1_Logon_Sites_01_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_OK;    // 8001 fails
                TitleInfo ti = null;
                if (authContext.IsXenonTitle)
                {
                    ti = new TitleInfo(0x3EEF0821, 1, 1);
                }
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8002},
                    ti,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=useraccount, 8001
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_03")]
        class Test_Xkdc_Machine_Logon_Sites_01_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;    // 8001 fails
                ResultCode = GetMachineST(new uint[] {(uint)XOService.User_Account,
                                                         8001},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// services=useraccount, 8001
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_03")]
        class Test_Xkdc_User_1_Logon_Sites_01_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;    // 8001 fails
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {(uint)XOService.User_Account, 8001},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8001, useraccount
        /// granted=false, yes
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_04")]
        class Test_Xkdc_Machine_Logon_Sites_01_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_FALSE;    // 8001 fails
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ user_account, 8001], thus indices 0 & 1 flip
                    uint temp = ExpectedHRs[1];
                    ExpectedHRs[1] = ExpectedHRs[0];
                    ExpectedHRs[0] = temp;
                }
                ResultCode = GetMachineST(new uint[] {8001,
                                                      (uint)XOService.User_Account},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// services=8001, useraccount
        /// granted=false, yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_04")]
        class Test_Xkdc_User_1_Logon_Sites_01_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_FALSE;    // 8001 fails
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ user_account, 8001], thus indices 0 & 1 flip
                    uint temp = ExpectedHRs[1];
                    ExpectedHRs[1] = ExpectedHRs[0];
                    ExpectedHRs[0] = temp;
                }
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8001, (uint)XOService.User_Account},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_05]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=presence, 8001
        /// granted=no, false
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_05")]
        class Test_Xkdc_Machine_Logon_Sites_01_05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;    // NOT granted
                ExpectedHRs[1] = HResult.S_FALSE;    // 8001 fails
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {(uint)XOService.PresNotification, 8001},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_05]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// services=presence, 8001
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_05")]
        class Test_Xkdc_User_1_Logon_Sites_01_05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;    // 8001 fails
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {(uint)XOService.PresNotification, 8001},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_06]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8001, presence
        /// granted=false, no
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_06")]
        class Test_Xkdc_Machine_Logon_Sites_01_06 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_FALSE;    // 8001 fails
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;    // NOT granted
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ user_account, 8001], thus indices 0 & 1 flip
                    uint temp = ExpectedHRs[1];
                    ExpectedHRs[1] = ExpectedHRs[0];
                    ExpectedHRs[0] = temp;
                }
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8001, (uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_06]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// services=8001, presence
        /// granted=false, yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_06")]
        class Test_Xkdc_User_1_Logon_Sites_01_06 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_FALSE;    // 8001 fails
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ user_account, 8001], thus indices 0 & 1 flip
                    uint temp = ExpectedHRs[1];
                    ExpectedHRs[1] = ExpectedHRs[0];
                    ExpectedHRs[0] = temp;
                }
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8001, (uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_07]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=useraccount, 8002
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_07")]
        class Test_Xkdc_Machine_Logon_Sites_01_07 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;    // 8002 fails
                ResultCode = GetMachineST(new uint[] {(uint) XOService.User_Account,
                                                         8002},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_07]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// services=useraccount, 8002
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_07")]
        class Test_Xkdc_User_1_Logon_Sites_01_07 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;    // 8002 fails
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {(uint)XOService.User_Account, 8002},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_08]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8002, useraccount
        /// granted=false, yes
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_08")]
        class Test_Xkdc_Machine_Logon_Sites_01_08 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_FALSE;    // 8002 fails
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ user_account, 8001], thus indices 0 & 1 flip
                    uint temp = ExpectedHRs[1];
                    ExpectedHRs[1] = ExpectedHRs[0];
                    ExpectedHRs[0] = temp;
                }
                ResultCode = GetMachineST(new uint[] {8002,
                                                    (uint) XOService.User_Account},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_08]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// services=8002, useraccount
        /// granted=false, yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_08")]
        class Test_Xkdc_User_1_Logon_Sites_01_08 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_FALSE;    // 8002 fails
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ user_account, 8001], thus indices 0 & 1 flip
                    uint temp = ExpectedHRs[1];
                    ExpectedHRs[1] = ExpectedHRs[0];
                    ExpectedHRs[0] = temp;
                }
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8002, (uint)XOService.User_Account},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_09]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=presence, 8002
        /// granted=no, false
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_09")]
        class Test_Xkdc_Machine_Logon_Sites_01_09 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                ExpectedHRs[1] = HResult.S_FALSE;    // 8002 fails
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {(uint) XOService.PresNotification, 8002},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_09]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// services=presence, 8002
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_09")]
        class Test_Xkdc_User_1_Logon_Sites_01_09 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;    // 8002 fails
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {(uint)XOService.PresNotification, 8002},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_10]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8002, presence
        /// granted=false, no
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_10")]
        class Test_Xkdc_Machine_Logon_Sites_01_10 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_FALSE;    // 8002 fails
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ user_account, 8001], thus indices 0 & 1 flip
                    uint temp = ExpectedHRs[1];
                    ExpectedHRs[1] = ExpectedHRs[0];
                    ExpectedHRs[0] = temp;
                }
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8002, (uint) XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_10]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// services=8002, presence
        /// granted=false, yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_10")]
        class Test_Xkdc_User_1_Logon_Sites_01_10 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.S_FALSE;    // 8002 fails
                // SPECIAL XENON CASE
                // Xenon requests don't always return service results in the exact same order. 
                // Base services (< 256) will be the same order, and dword services (> 256) will 
                // be the same order.  But if you mix them, they won't.  The result always
                // includes the base services first, in your order, followed by the dword services,
                // in your order.
                if (IsXenonClient)
                {
                    // We're going to get [ user_account, 8001], thus indices 0 & 1 flip
                    uint temp = ExpectedHRs[1];
                    ExpectedHRs[1] = ExpectedHRs[0];
                    ExpectedHRs[0] = temp;
                }
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8002, (uint)XOService.PresNotification},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_11]
        /// type=XOnlineLogon
        /// machine=M1
        /// site=7045
        /// services=8001, 8002
        /// granted=yes, no
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_11")]
        class Test_Xkdc_Machine_Logon_Sites_01_11 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineSTwithSite(new uint[] {8001, 8002},
                    ExpectedHRs,
                    HResult.S_OK,
                    7045);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_11]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// site=7045
        /// services=8001, 8002
        /// granted=yes, yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_11")]
        class Test_Xkdc_User_1_Logon_Sites_01_11 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8001, 8002},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_12]
        /// type=XOnlineLogon
        /// machine=M1
        /// site=7045
        /// services=8002, 8001
        /// granted=no, yes
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_12")]
        class Test_Xkdc_Machine_Logon_Sites_01_12 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineSTwithSite(new uint[] {8002, 8001},
                    ExpectedHRs,
                    HResult.S_OK,
                    7045);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_12]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// site=7045
        /// services=8002, 8001
        /// granted=yes, yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_12")]
        class Test_Xkdc_User_1_Logon_Sites_01_12 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8002,8001},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_13]
        /// type=XOnlineLogon
        /// machine=M1
        /// site=7045
        /// services=8001, 8003
        /// granted=yes, false
        [TestCase, Ignore, Description("Test_Xkdc_Machine_Logon_Sites_01_13")]
        class Test_Xkdc_Machine_Logon_Sites_01_13 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;
                ResultCode = GetMachineSTwithSite(new uint[] {8001,
                                                                 8003},
                    ExpectedHRs,
                    HResult.S_OK,
                    7045);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_13]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// site=7045
        /// services=8001, 8003
        /// granted=yes, false
        [TestCase, Ignore, Description("Test_Xkdc_User_1_Logon_Sites_01_13")]
        class Test_Xkdc_User_1_Logon_Sites_01_13 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8001,8003},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_14]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8002, 8003
        /// granted=no, false
        [TestCase, Ignore, Description("Test_Xkdc_Machine_Logon_Sites_01_14")]
        class Test_Xkdc_Machine_Logon_Sites_01_14 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                ExpectedHRs[1] = HResult.S_FALSE;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8002, 8003},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_14]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// site=7045
        /// services=8002, 8003
        /// granted=yes, false
        [TestCase, Ignore, Description("Test_Xkdc_User_1_Logon_Sites_01_14")]
        class Test_Xkdc_User_1_Logon_Sites_01_14 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8002,8003},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_15]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8002, 8004
        /// granted=no, false
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_15")]
        class Test_Xkdc_Machine_Logon_Sites_01_15 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                ExpectedHRs[1] = HResult.S_FALSE;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8002, 8004},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_15]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// site=7045
        /// services=8002, 8004
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_15")]
        class Test_Xkdc_User_1_Logon_Sites_01_15 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;
                TitleInfo ti = null;
                if (authContext.IsXenonTitle)
                {
                    ti = new TitleInfo(0x3EEF0821, 1, 1);
                }
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8002,8004},
                    ti,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_Logon_Sites_01_16]
        /// type=XOnlineLogon
        /// machine=M1
        /// site=7045
        /// services=8001, 8004
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_Machine_Logon_Sites_01_16")]
        class Test_Xkdc_Machine_Logon_Sites_01_16 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;
                ResultCode = GetMachineSTwithSite(new uint[] {8001,
                                                         8004},
                    ExpectedHRs,
                    HResult.S_OK,
                    7045);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Sites_01_16]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsuball
        /// site=7045
        /// services=8001, 8004
        /// granted=yes, false
        [TestCase, Description("Test_Xkdc_User_1_Logon_Sites_01_16")]
        class Test_Xkdc_User_1_Logon_Sites_01_16 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[1] = HResult.S_FALSE;
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuball"),
                    new uint[] {8001, 8004},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Offers_02_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub1
        /// site=7045
        /// services=8001
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Offers_02_01")]
        class Test_Xkdc_User_1_Logon_Offers_02_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsub1"),
                    new uint[] {8001},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Offers_02_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub2
        /// site=7045
        /// services=8002
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Offers_02_02")]
        class Test_Xkdc_User_1_Logon_Offers_02_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                TitleInfo ti = null;
                if (authContext.IsXenonTitle)
                {
                    //ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                    ti = new TitleInfo(0x3EEF0821, 1, 1);
                }
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsub2"),
                    new uint[] {8002},
                    ti,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_User_1_Logon_Offers_02_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub3
        /// site=7045
        /// services=8002
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_Logon_Offers_02_03")]
        class Test_Xkdc_User_1_Logon_Offers_02_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                TitleInfo ti = null;
                if (authContext.IsXenonTitle)
                {
                    ti = new TitleInfo(0x3EEF0821, 1, 1);
                }
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsub3"),
                    new uint[] {8002},
                    ti,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleID_03_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8005
        /// granted=no
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleID_03_01")]
        class Test_Xkdc_Machine_ServicesInstances_TitleID_03_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8005},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleID_03_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// services=8005
        /// granted=yes //really? looks like no...
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleID_03_01")]
        class Test_Xkdc_User_1_ServicesInstances_TitleID_03_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8005},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleID_03_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF20 (-4264160)
        /// services=8005
        /// granted=no
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleID_03_02")]
        class Test_Xkdc_Machine_ServicesInstances_TitleID_03_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264160, 1, 1);
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8005},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleID_03_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// titleid=0xFFBEEF20 (-4264160)
        /// services=8005
        /// granted=no
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleID_03_02")]
        class Test_Xkdc_User_1_ServicesInstances_TitleID_03_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264160, 1, 1);
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8005}, 
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleVersionRegionAvailable_04_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8006
        /// granted=no
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_01")]
        class Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                SetUser(UserTimer.AccessSharedUser("xktsuball"));
                TitleInfo ti = null;
                if (authContext.IsXenonTitle)
                {
                    ti = new TitleInfo(0x3EEF0821, 1, 1);
                }
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8006},
                    ti,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleVersionRegionAvailable_04_01]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// site=7045
        /// services=8006
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_01")]
        class Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_01 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                TitleInfo ti = null;
                if (authContext.IsXenonTitle)
                {
                    ti = new TitleInfo(0x3EEF0821, 1, 1);
                }
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8006},
                    ti,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleVersionRegionAvailable_04_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleversion=2
        /// services=8006
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE
        /// granted=false
        /// country=0
        /// bug=19829
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_02")]
        class Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                // If the KDC AllowUnknownVersions=1, a title with an unknown version is 
                // allowed to log on.  UNKNOWN_TITLE will not be reported. This test was
                // wrong, as far as I can tell.  Larry confirmed the KDC behavior with
                // regard to this setting.  When AllowUnknownVersions=0, this test used
                // to succeed. I'm inverting this. -kgoodier
                //
                TitleInfo TI = new TitleInfo(-4264160, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                userFlags[0] = 0;
                uint ExpectedHR = HResult.S_OK;
                if (XkdcTestBaseGroup.settingAllowUnknownVersions)
                {
                    ExpectedHR = HResult.S_OK;
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                }
                else
                {
                    ExpectedHR = HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
                    ExpectedHRs[0] = HResult.S_FALSE;
                }
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineSTwithFlags(new uint[] {8006},
                    TI,
                    ExpectedHRs,
                    ExpectedHR,
                    userFlags,
                    'c');
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleVersionRegionAvailable_04_02]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// titleversion=2
        /// services=8006
        /// hronline=XONLINE_E_LOGON_UNKNOWN_TITLE
        /// granted=false
        /// country=0
        /// bug=19829
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_02")]
        class Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_02 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                // See comments for previous test
                //
                TitleInfo TI = new TitleInfo(-4264160, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                short[] userFlags = new short[1];
                uint ExpectedHR = HResult.S_OK;
                if (XkdcTestBaseGroup.settingAllowUnknownVersions)
                {
                    ExpectedHR = HResult.S_OK;
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                    userFlags[0] = 103;  // 103 = 0x67 = United States
                }
                else
                {
                    ExpectedHR = HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
                    ExpectedHRs[0] = HResult.S_FALSE;
                    userFlags[0] = 0;
                }
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetUserSTwithFlags(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8006},
                    TI,
                    ExpectedHRs,
                    ExpectedHR,
                    userFlags,
                    'c');
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleVersionRegionAvailable_04_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// services=8007
        /// granted=unavailable
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_03")]
        class Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8007},
                    null,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleVersionRegionAvailable_04_03]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// services=8007
        /// granted=unavailable
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_03")]
        class Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_03 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetUserST(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8007},
                    null,
                    ExpectedHRs,
                    HResult.S_OK,
                    's');
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleVersionRegionAvailable_04_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF21 (-4264159)
        /// services=8008
        /// granted=no
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_04")]
        class Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264159, 1, 1);
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8008},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleVersionRegionAvailable_04_04]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// titleid=0xFFBEEF21 (-4264159)
        /// site=7045
        /// services=8008
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_04")]
        class Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_04 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264159, 1, 1);
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8008},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleVersionRegionAvailable_04_05]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF21 (-4264159)
        /// titleversion=2
        /// services=8008
        /// granted=no
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_05")]
        class Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264159, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8008},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleVersionRegionAvailable_04_05]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// titleid=0xFFBEEF21 (-4264159)
        /// titleversion=2
        /// site=7045
        /// services=8008
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_05")]
        class Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_05 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264159, 2, 1);
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8008},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleVersionRegionAvailable_04_06]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF21 (-4264159)
        /// titleversion=3
        /// services=8008b
        /// granted=no
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_06")]
        class Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_06 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264159, 3, 1);
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8008},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleVersionRegionAvailable_04_06]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// titleid=0xFFBEEF21 (-4264159)
        /// titleversion=3
        /// site=7045
        /// services=8008b
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_06")]
        class Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_06 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264159, 3, 1);
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8008},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7045);
            }
        }

        /// [Test_Xkdc_Machine_ServicesInstances_TitleVersionRegionAvailable_04_07]
        /// type=XOnlineLogon
        /// machine=M1
        /// titleid=0xFFBEEF21 (-4264159)
        /// titleversion=4
        /// services=8008
        /// granted=no
        [TestCase, Description("Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_07")]
        class Test_Xkdc_Machine_ServicesInstances_TitleVRA_04_07 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264159, 4, 1);
                uint[] ExpectedHRs = new uint[12];
                ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                ResultCode = GetMachineST(new uint[] {8008},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK);
            }
        }

        /// [Test_Xkdc_User_1_ServicesInstances_TitleVersionRegionAvailable_04_07]
        /// type=XOnlineLogon
        /// machine=M1
        /// users=xktsub5
        /// titleid=0xFFBEEF21 (-4264159)
        /// titleversion=4
        /// site=7046
        /// services=8008
        /// granted=yes
        [TestCase, Description("Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_07")]
        class Test_Xkdc_User_1_ServicesInstances_TitleVRA_04_07 : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                TitleInfo TI = new TitleInfo(-4264159, 4, 1);
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsub5"),
                    new uint[] {8008},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    7046);
            }
        }

        //
        [TestCase(BugID=111709, BugDatabase="Xenon"), Description("2 service instances, one with title ID 0 and another with a real title ID on a site greater than the first")]
        [CompoundCase("SpecificTitle", 0xFFBEEF2a, 7047)]
        [CompoundCase("DefaultTitle", 0xFFC0FE00, 7045)]
        class SharedServiceID : TestBase_XboxOld
        {
            override protected void RunTest()
            {
                uint titleToUse=(uint)MyValues[0];
                uint expectedSite=(uint)(int)MyValues[1];

                TitleInfo TI = new TitleInfo(titleToUse, 1, 1);
                uint[] ExpectedHRs = new uint[12];
                ResultCode = GetUserSTwithSite(UserTimer.AccessSharedUser("xktsuba3"),
                    new uint[] {8014},
                    TI,
                    ExpectedHRs,
                    HResult.S_OK,
                    's',
                    expectedSite);
            }
        }

        //
        [TestCase, Description("Sign in a user with a subscription to a service that lives on a site with entries with bad data")]
        class SiteBadData: TestBase_XboxOld
        {
            override protected void RunTest()
            {
                SiteEditor siteBAAD517E=null;
                ServiceEditor serv8049=null;
                OfferEditor offerFFC0FE00C0FE0049=null;
                UserEditor newsub49=null;

                try
                {
                    ro.Info("Propping bad test data...");
                    siteBAAD517E=SiteEditor.CreateOrUseExistingId(0xBAAD517E);
                    serv8049=ServiceEditor.CreateOrUseExistingId(8049);
                    offerFFC0FE00C0FE0049=OfferEditor.CreateOrUseExistingId(0xFFC0FE00C0FE0049);
                    newsub49=UserEditor.CreateOrUseExistingGamerTag("xktnewsub49");

                    //populate the "bad test data"
                    siteBAAD517E.SetVirtualInterfaceIp("sgsvc", "abcdefghijklmnopabcdefghijklmnop");
                    siteBAAD517E.SetVirtualInterfaceIp("sgsvc_xlsp", "abcdefghijklmnopabcdefghijklmnop");
                    siteBAAD517E.AuthDataVersion=unchecked((int)0xBAAD517E);

                    serv8049.KerberosServiceName="badbadbadbadbadbadbadbadbadbad";
                    serv8049.KerberosDomainName="badbadbadbadbadbadbadbadbadbad";
                    serv8049.Name="xkt8049xkt8049xkt8049xkt8049xt";
                    serv8049.MachineOnly=0;
                    serv8049.AddInstance(0, 0, 0, 0xBAAD517E, 8049, 1);

                    offerFFC0FE00C0FE0049.Name="Xkdctest Subscription #49";
                    offerFFC0FE00C0FE0049.ConsoleType=0;
                    offerFFC0FE00C0FE0049.StartDate=new System.DateTime(2002, 2, 2);
                    offerFFC0FE00C0FE0049.EndDate=new System.DateTime(2106, 2, 2);
                    offerFFC0FE00C0FE0049.OfferType=1;
                    offerFFC0FE00C0FE0049.FrequencyId=1;
                    offerFFC0FE00C0FE0049.Cancelable=0;
                    offerFFC0FE00C0FE0049.ESRBRating=6;
                    offerFFC0FE00C0FE0049.BitFilter=1;
                    offerFFC0FE00C0FE0049.PolicyFlags=1;
                    offerFFC0FE00C0FE0049.GlobalOfferDetails=2;
                    offerFFC0FE00C0FE0049.AddService(8049);
                    offerFFC0FE00C0FE0049.AddSubscription();

                    newsub49.RemoveAllSubscriptions(false);
                    newsub49.AddSubscription(0xFFC0FE00C0FE0049);

                    Suite.ReloadKDCs();
                    Suite.RefreshKDCsConfig();

                    //run test
                    ro.Info("Running test...");
                    TitleInfo TI = new TitleInfo(-4264159, 4, 1);
                    uint[] ExpectedHRs = new uint[12];
                    ExpectedHRs[0] = HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                    authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                    ResultCode = GetUserST(UserTimer.AccessSharedUser("xktnewsub49"),
                        new uint[] {8049},
                        TI,
                        ExpectedHRs,
                        HResult.S_OK,
                        's');
                }
                finally
                {
                    //clean up the "bad test data", else the KDC will not be able to start up again if it is ever stopped
                    ro.Info("cleaning up bad test data...");
                    if (serv8049!=null) serv8049.CompletelyRemoveService();
                    if (siteBAAD517E!=null) siteBAAD517E.CompletelyRemoveSite();

                    Suite.ReloadKDCs();
                    Suite.RefreshKDCsConfig();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PacketFlingerPlugin.cs ===
using System;
using System.Windows.Forms;
using System.Net;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;

namespace STFGui.Plugins
{
    // -- gui stuff

    /// <summary>
    /// The udp packets shall prevail.
    /// </summary>
    public class KerberosPacketFlinger: STFGui.Plugins.IPluginGui
    {
        Report ro=new Report("KerbPacket");

        private System.Windows.Forms.ListBox listboxServers;
        private System.Windows.Forms.Button buttonRefresh;

        private System.Windows.Forms.TextBox textboxData;
        private System.Windows.Forms.Button buttonSend;

        //Our Tab Page
        public System.Windows.Forms.TabPage GetNewTabPage()
        {
            System.Windows.Forms.TabPage masterPage=new System.Windows.Forms.TabPage();
            masterPage.Text="KerbPacketFlinger";
            masterPage.Width=1000;
            masterPage.Height=500;

            //server list and its refresh button
            listboxServers=new System.Windows.Forms.ListBox();
            listboxServers.Location=new System.Drawing.Point(5, 60);
            listboxServers.Width=120;
            listboxServers.Height=350;
            listboxServers.Anchor=AnchorStyles.Top|AnchorStyles.Bottom|AnchorStyles.Left;
            masterPage.Controls.Add(listboxServers);

            buttonRefresh=new System.Windows.Forms.Button();
            buttonRefresh.Text="Refresh List";
            buttonRefresh.Location=new System.Drawing.Point(13, 10);
            buttonRefresh.Width=100;
            buttonRefresh.Height=40;
            buttonRefresh.Click+=Button_Refresh;
            masterPage.Controls.Add(buttonRefresh);

            //packet data and its send button
            textboxData=new System.Windows.Forms.TextBox();
            textboxData.Location=new System.Drawing.Point(130, 35);
            textboxData.Width=875;
            textboxData.Height=460;
            textboxData.Multiline=true;
            textboxData.Anchor=AnchorStyles.Right|AnchorStyles.Top|AnchorStyles.Left|AnchorStyles.Bottom;
            masterPage.Controls.Add(textboxData);

            System.Windows.Forms.Label labelData=new System.Windows.Forms.Label();
            labelData.Text="Packet bytes to send (hex):";
            labelData.Location=new System.Drawing.Point(130, 15);
            labelData.Width=400;
            labelData.Height=20;
            masterPage.Controls.Add(labelData);

            buttonSend=new System.Windows.Forms.Button();
            buttonSend.Text="Send Packet";
            buttonSend.Location=new System.Drawing.Point(21, 430);
            buttonSend.Width=80;
            buttonSend.Height=25;
            buttonSend.Anchor=AnchorStyles.Bottom|AnchorStyles.Left;
            buttonSend.Click+=Button_Send;
            masterPage.Controls.Add(buttonSend);

            return masterPage;
        }

        // Called when the button to refresh the server list is clicked
        private void Button_Refresh(object sender, EventArgs e)
        {
            listboxServers.Items.Clear();

            //get all KDCs
            string []KDCs=Global.XEnv.GetServerListByInterface("kdcsvc");
            foreach (string s in KDCs)
            {
                listboxServers.Items.Add(s);
            }
        }

        // Called when the button to refresh the server list is clicked
        private void Button_Send(object sender, EventArgs e)
        {
            //get the IP to send it to
            string server=(listboxServers.SelectedItem!=null?(string)listboxServers.SelectedItem:null);
            if (server==null || server.Length==0)
            {
                ro.Error("No server selected to send to.");
                return;
            }

            IPEndPoint ep=Global.XEnv.GetInterface("kdcsvc", server);
            if (ep==null)
            {
                ro.Error("No endpoint available for kdcsvc on "+server+" in this environment.");
                return;
            }

            //parse the data to send
            string blob=textboxData.Text.Replace(" ","");
            blob=blob.Replace("\r","");
            blob=blob.Replace("\n","");

            byte []bytes=Hexer.unhex(blob);

            //send it
            ro.Info("Sending "+bytes.Length+" byte packet to "+ep.Address+":"+ep.Port);

            UdpClient udp=new UdpClient();
            udp.Send(bytes, bytes.Length, ep);
        }

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public System.Windows.Forms.MenuItem GetNewMenu ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PanoramaLimited.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;

using ServerTestFramework.LiveService.Billing;

//
namespace XkdcTest
{
    [TestGroup, /*AsyncGroup(1),*/ AsyncThreadDelay(1000), AsyncThreadCount(4), TestCasePriority(2)] //why do the billing servers suck such that I can't reliably run more than 1 thread at a time?
    public class PanoramaLimited: XkdcTestBaseGroup
    {
        public PanoramaLimited()
        {
            ParentClientType=AuthContext.ClientTypes.Panorama;
        }

        public override void PreRun()
        {
            TestBase_Panorama.ClearMachineCache();
        }

        public const string c_LimitedToken = "#############################";

        #region Helpers

        public abstract class TestBase_PanoramaLimitedTests: TestBase_Panorama
        {
            public override bool UseCachedMachineAccount()
            {
                return false;
            }

            public TestBase_PanoramaLimitedTests()
            {
                bTooManyServicesOk=false;
                bVerifyServices=true;
                bVerifyAuthdata=true;
                bVerifyUserFlags=true;
            }

            //verifies that the limited machine bit is or is not present (not needed as the base verifies, but here for better debug spew)
            protected void CheckLimitedAuthDataBit(bool expected)
            {
                bool isLimited=((authContext.GetXkdcResult().authData.AuthDataFlags&Authdata_Xenon.FLAGS_ISLIMITEDMACHINE) != 0);

                if (isLimited!=expected)
                {
                    throw new UnexpectedTestResultException("Expected limited machine bit to be "+expected+", but it was "+isLimited);
                }
            }

            //buy 1000 points on a user
            protected void BuyPoints(XeUser user)
            {
                for (int count=0; count<2; ++count)
                {
                    for (int i=0; i<3; ++i)
                    {
                        try
                        {
                            user.AddPoints_500();
                            break;
                        }
                        catch (System.Exception e)
                        {
                            if (i<3-1)
                            {
                                Global.RO.Warn("AddPoints failed: "+e.Message+" (will retry)");
                            }
                            else
                            {
                                throw;
                            }
                            System.Threading.Thread.Sleep(i*5000);
                        }
                    }
                }
            }

            //buy gamertag change on a user
            protected void BuyGamertag(XeUser user)
            {
                //need some points first
                BuyPoints(user);

                //check that context is setup
                if (!authContext.IsSignedInXmacs)
                {
                    throw new System.Exception("Sign into xmacs first so we have a machine puid to use.");
                }
                if (authContext.Users[0]==null)
                {
                    throw new System.Exception("Set a user first so we have a gamertag to use for the request");
                }

                //buy gamertag
                XmacsClient xmc=new XmacsClient(authContext);
                ServerTestFramework.LiveService.Billing.XRLXeOfferPurchaseGamertag buy=new ServerTestFramework.LiveService.Billing.XRLXeOfferPurchaseGamertag();

                buy.UserPuid=user.UserPuid;
                buy.MachinePuid=xmc.GetMachinePuid();
                buy.Gamertag="test"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(9);
                buy.GamertagLength=(ushort)buy.Gamertag.Length;

                for (int i=0; i<3; ++i)
                {
                    try
                    {
                        ServerTestFramework.LiveService.Billing.XRLXeOfferPurchaseGamertagResponse res;
                        if (!buy.Execute(out res))
                        {
                            throw new System.Exception("Failed to buy gamertag for user");
                        }
                        break;
                    }
                    catch (System.Exception e)
                    {
                        if (i<3-1)
                        {
                            Global.RO.Warn(e.Message+" (will retry)");
                        }
                        else
                        {
                            throw;
                        }
                        System.Threading.Thread.Sleep(i*5000);
                    }
                }
            }

            protected void BuyPointsAndOffer(XeUser user, ulong offerID, uint buyPointIters)
            {
                BuyPointsAndOffer(user, offerID, buyPointIters, false);
            }
            protected void BuyPointsAndOffer(XeUser user, ulong offerID, uint buyPointIters, bool useCCInstead)
            {
                //need to buy some points first
                for (int i=0; i<buyPointIters; ++i)
                    BuyPoints(user);

                //check that context is setup
                if (!authContext.IsSignedInXmacs)
                {
                    throw new System.Exception("Sign into xmacs first so we have a machine puid to use.");
                }
                if (authContext.Users[0]==null)
                {
                    throw new System.Exception("Set a user first so we have a gamertag to use for the request");
                }

                //buy it
                XmacsClient xmc=new XmacsClient(authContext);
                XRLXeOfferPurchase req=new XRLXeOfferPurchase();

                req.SetDefaults();
                req.UserPuid=user.UserPuid;
                user.MachinePuid=xmc.GetMachinePuid();
                req.MachinePuid=xmc.GetMachinePuid();
                req.OfferID=offerID;

                if (useCCInstead)
                {
                    req.PaymentType=(uint)PaymentTypeEnum.CreditCard;
                    req.PaymentInstrumentID=XbosOffer.AddPaymentInstrumentVisa(user.UserPuid, 103);
                }

                for (int i=0; i<3; ++i)
                {
                    try
                    {
                        if (!req.Execute())
                        {
                            throw new System.Exception(string.Format("Failed to buy offer 0x{0:x}: "+req.ErrorStatusMessage, offerID));
                        }
                        break;
                    }
                    catch (System.Exception e)
                    {
                        if (i<3-1)
                        {
                            Global.RO.Warn(e.Message+" (will retry)");
                        }
                        else
                        {
                            throw;
                        }
                        System.Threading.Thread.Sleep(i*5000);
                    }
                }
            }

            protected void BuyPointsAndMediaOffer(XeUser user, OfferMediaTypeExpectedPrice omtep, uint buyPointIters)
            {
                //need to buy some points first
                for (int i=0; i<buyPointIters; ++i)
                    BuyPoints(user);

                //check that context is setup
                if (!authContext.IsSignedInXmacs)
                {
                    throw new System.Exception("Sign into xmacs first so we have a machine puid to use.");
                }
                if (authContext.Users[0]==null)
                {
                    throw new System.Exception("Set a user first so we have a gamertag to use for the request");
                }

                XmacsClient xmc=new XmacsClient(authContext);

                //buy it
                XRLPurchaseMediaOffers req=new XRLPurchaseMediaOffers();

                req.UserPuid=user.UserPuid;
                user.MachinePuid=xmc.GetMachinePuid();
                req.MachinePuid=xmc.GetMachinePuid();

                OfferMediaTypeExpectedPrice[] offers=new OfferMediaTypeExpectedPrice[] { omtep };

                req.Offers=offers;

                req.PaymentType=(uint)PaymentTypeEnum.Points;
                req.BillingToken="";
                req.PaymentInstrumentID="";

                for (int i=0; i<3; ++i)
                {
                    try
                    {
                        if (!req.Execute())
                        {
                            throw new System.Exception(string.Format("Failed to buy offer {0}: "+req.ErrorStatusMessage, omtep.OfferId));
                        }
                        break;
                    }
                    catch (System.Exception e)
                    {
                        if (i<3-1)
                        {
                            Global.RO.Warn(e.Message+" (will retry)");
                        }
                        else
                        {
                            throw;
                        }
                        System.Threading.Thread.Sleep(i*5000);
                    }
                }
            }

            protected void BuyArcadeTitle(XeUser user)
            {
                //BuyPointsAndOffer(user, 0x584107F600000001, 1); //Full Game - Texas Holdem

                OfferMediaTypeExpectedPrice omtep=new OfferMediaTypeExpectedPrice();
                omtep.ExpectedPriceWhole=800; // this seems wrong
                omtep.ExpectedPriceFractional=0;
                omtep.MediaTypeId=23; //Arcade Game
                omtep.OfferId=new System.Guid("00000001-0000-4000-8000-0000584107F6");

                BuyPointsAndMediaOffer(user, omtep, 1);
            }

            protected void BuyXnaSubscription(XeUser user, bool demo)
            {
                if (demo)
                {
                    BuyPointsAndOffer(user, 0x584E07D10CAFE001, 0); //XNA Creator's Club Demo
                }
                else
                {
                    BuyPointsAndOffer(user, 0x584E07D109900001, 0, true); //XNA Creator's Club 4-mo Online Subscription
                }
            }

            protected void ExpireXnaSubscription(XeUser user)
            {
                int rows=UodbWS.ExecuteSQLNonQuery("update t_subscriptions set dt_end_date='2000-01-01 00:00:00.000', i_subscription_status_id=3 where bi_primary_puid="+(long)user.UserPuid+" and bi_offer_id=0x584E07D109900001",null);
                if (rows==0) throw new System.Exception("0 rows affected by update query.");
            }
        }

        #endregion //Helpers


        #region Tests

        //
        [TestCase, Description("Created a limited PC account using the limited token")]
        class Limited: TestBase_PanoramaLimitedTests
        {
            override protected void RunTest()
            {
                authContext.SponsorToken=c_LimitedToken;
                authContext.IsPCLimited=true;

                SignInXkdc(true);
                CheckLimitedAuthDataBit(true); //extra check, not really needed
            }
        }

        //
        [TestCase, Description("Create a limited PC account with the limited token, but the user is gold, so they shouldn't be limited")]
        class LimitedButGold: TestBase_PanoramaLimitedTests
        {
            override protected void RunTest()
            {
                KdcUser user=AuthContext.MakeNewGenericUser(true, true);
                SetUser(user, 0);
                authContext.SponsorToken=c_LimitedToken;
                authContext.IsPCLimited=false;

                SignInXkdc(true);
                CheckLimitedAuthDataBit(false); //extra check, not really needed
            }
        }

        //
        [TestCase, Description("Create a limited PC account with the limited token, but the user is family gold, so they shouldn't be limited")]
        class LimitedButFamilyGold: TestBase_PanoramaLimitedTests
        {
            override protected void RunTest()
            {
                KdcUser user=new KdcUser();
                user.CreateUser(true);

                UserEditor ue=UserEditor.FromPuid(user.UserID);
                ue.RemoveAllSubscriptions(true);
                ue.AddBaseSubscription(BaseSubscriptions.Xbox360FamilyGold);

                SetUser(user, 0);
                authContext.SponsorToken=c_LimitedToken;
                authContext.IsPCLimited=false;

                SignInXkdc(true);
                CheckLimitedAuthDataBit(false); //extra check, not really needed
            }
        }

        //
        [TestCase, EnvRequirement("Billing"), Description("Create a limited PC account with the limited token, then buy something.  Now continue on and do askdc/xdc and verify we are/are not limited.")]
        [CompoundCase("Points",     0, true)]
        [CompoundCase("Gamertag",   1, true)] //see bug 105105 - this does not unlimit you
        [CompoundCase("ArcadeGame", 2, false, BugDatabase="Xbox360 Console Software", BugID=166258)]
        [CompoundCase("XnaSub", 3, false)]
        [CompoundCase("ExpiredXnaSub", 4, true)]
        //[CompoundCase("XnaDemo", 5, true)] //TODO: revisit the problems purchasing this later, I think the offer is gone...
        //[CompoundCase("XnaLauncher", 6, true)] //TODO: would be an interesting case if we can get the purchase to work
        class LimitedPurchase: TestBase_PanoramaLimitedTests
        {
            override protected void RunTest()
            {
                //make user, and a limited machine
                ro.Debug("Making user...");
                XeUser user=AuthContext.MakeNewBillingUser(true, false, true);
                SetUser(user,0);
                authContext.SponsorToken=c_LimitedToken;
                authContext.IsPCLimited=true;

                ro.Debug("Making machine account...");
                XmacsClient xmc=new XmacsClient(authContext);
                xmc.SignInXmacs();

                //buy something
                ro.Debug("Buying something...");
                if ((int)MyValues[0]==0) //points
                    BuyPoints(user);
                else if ((int)MyValues[0]==1) //gamertag
                    BuyGamertag(user);
                else if ((int)MyValues[0]==2) //arcade title
                    BuyArcadeTitle(user);
                else if ((int)MyValues[0]==3) //valid xna subscription
                    BuyXnaSubscription(user,false);
                else if ((int)MyValues[0]==4) //expired xna subscription
                {
                    BuyXnaSubscription(user,false);
                    ExpireXnaSubscription(user);
                }
                else if ((int)MyValues[0]==5) //xna demo
                    BuyXnaSubscription(user,true);
                else if ((int)MyValues[0]==6) //xna launcher
                    BuyPointsAndOffer(user, 0x584E07D10CAFE002, 1);

                //continue on now
                ro.Debug("Checking xkdc privileges...");
                authContext.IsPCLimited=(bool)MyValues[1];
                SignInXkdc(true);
                CheckLimitedAuthDataBit((bool)MyValues[1]); //extra check, not really needed
            }
        }

        //
        [TestCase, AsyncGroup(1), Description("Created a limited machine account 100 times with 1 passport, after that it shouldn't work")]
        [CompoundCase("Limited",  true,  true)]
        [CompoundCase("Upgraded", false, true)]
        class UseLimit100: TestBase_PanoramaLimitedTests
        {
            public override bool UseCachedMachineAccount()
            {
                return false;
            }

            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                bVerifyServices=false;

                authContext.ClearPcMachine();
                SetDefaults();

                bool isLimited=(bool)MyValues[0];
                bool isCapped=(bool)MyValues[1];

                authContext.SponsorToken=c_LimitedToken;
                authContext.IsPCLimited=isLimited;

                if (!isLimited)
                {
                    KdcUser user=AuthContext.MakeNewGenericUser(true,true);
                    SetUser(user,0);
                }

                //#1
                Global.RO.Debug("Doing #1...");
                SignInXkdc(true);

                //#2-99
                Global.RO.Debug("Doing #2-#100...");
                for (int i=2; i<=100; ++i)
                {
                    authContext.ClearXmacs();
                    XmacsClient xmacs=new XmacsClient(authContext);
                    xmacs.EmulateClientBehavior=false;
                    xmacs.SignInXmacs();

                    if (i%20==0 && (XkdcTestBaseGroup.settingXmacsDOSEnabled || XkdcTestBaseGroup.settingXmacsDOS2Enabled))
                    {
                        Global.RO.Debug("Finished #"+i+".  Waiting 1 minute to avoid anti-dos code.");
                        System.Threading.Thread.Sleep(60000);
                    }
                }

                //#100
                Global.RO.Debug("Doing #101, should fail");
                try
                {
                    authContext.ClearXmacs();
                    XmacsClient xmacs=new XmacsClient(authContext);
                    xmacs.EmulateClientBehavior=false;
                    xmacs.SignInXmacs();

                    if (isCapped)
                    {
                        Fail("Request should have failed");
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Debug(e.Message);

                    if (!isCapped)
                    {
                        Fail("Request should have succeeded");
                    }
                }
            }
        }

        #endregion //Tests
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\KerberosTests.cs ===
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    [TestGroup, Description("Tests that mess with the kerberos protocol.")]
    public class KerberosTests: TestNode
    {
        public static void VerifyKdcIsStillAlive()
        {
            try
            {
                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateXmacsRequest();
                kdc.ExecuteXmacs(true);
            }
            catch (System.Exception e)
            {
                throw new UnexpectedTestResultException("Got exception while verifying that the KDC is still alive.  Pleave verify it did not crash.\n"+e);
            }
        }

        [TestGroup, Ignore, Description("Tests of different flags for the kdc-options in the KDC-REQ-BODY")]
        public class BodyFlags: TestNode
        {
            private static KdcClientXbox360 CreateXmacsWith0Flags()
            {
                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.RetryLostPackets=false;
                kdc.CreateXmacsRequest();
                kdc.XmacsRequest.Input.GeneratePreauths();
                kdc.XmacsRequest.SetRequest();
                kdc.XmacsRequest.ConstructRequest();
                System.Array.Clear(kdc.XmacsRequest.Options.Bytes, 0, kdc.XmacsRequest.Options.Bytes.Length);
                return kdc;
            }

            private static KdcClientXbox360 CreateAskdcWith0Flags()
            {
                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.RetryLostPackets=false;
                kdc.CreateAskdcMachineRequest();
                kdc.AskdcRequest.Input.GeneratePreauths();
                kdc.AskdcRequest.SetRequest();
                kdc.AskdcRequest.ConstructRequest();
                System.Array.Clear(kdc.AskdcRequest.Options.Bytes, 0, kdc.AskdcRequest.Options.Bytes.Length);
                return kdc;
            }

            private static KdcClientXbox360 CreateXkdcWith0Flags()
            {
                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.RetryLostPackets=false;
                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.GeneratePreauths();
                kdc.XkdcRequest.SetRequest();
                kdc.XkdcRequest.ConstructRequest();
                System.Array.Clear(kdc.XkdcRequest.Options.Bytes, 0, kdc.XkdcRequest.Options.Bytes.Length);
                return kdc;
            }

            [TestCase]
            public void Xmacs_Zero()
            {
                KdcClientXbox360 kdc=CreateXmacsWith0Flags();

                kdc.XmacsRequest.RecalculateLengths();
                kdc.ExecuteXmacs(false);
            }

            [TestCase]
            public void Askdc_Zero()
            {
                KdcClientXbox360 kdc=CreateAskdcWith0Flags();

                kdc.AskdcRequest.RecalculateLengths();
                kdc.ExecuteAskdc(false);
            }

            [TestCase]
            public void Xkdc_Zero()
            {
                KdcClientXbox360 kdc=CreateXkdcWith0Flags();

                kdc.XkdcRequest.RecalculateLengths();
                kdc.ExecuteXkdc(false);
            }
        }

        [TestGroup, Description("See Microsoft Security Bulletin MS04-007")]
        public class MS04_007: TestNode
        {
            [TestCase(BugID=41204, BugDatabase="Xbox360 Console Software"), Description("Puts a bad specifically malformed bitstring inside of the kdc-options in the KDC-REQ-BODY of the request.")]
            public void BodyOptions_BadBitString()
            {
                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.RetryLostPackets=false;
                kdc.CreateXmacsRequest();
                kdc.XmacsRequest.Input.GeneratePreauths();
                kdc.XmacsRequest.SetRequest();
                kdc.XmacsRequest.ConstructRequest();

                byte []bytes=new byte[5]{
                    0x23, 0x03,         //constructed bit string of length 3 bytes
                    0x03, 0x01, 0x07};  //simple bitstring of length 1 byte with 7 unused bits, but no byte is actually provided
                kdc.XmacsRequest.OptionsTag.GetValueTagLengthValue().SetBytes(bytes, 0, bytes.Length);
                kdc.XmacsRequest.RecalculateLengths();

                Global.RO.Debug("KDC-REQ-BODY kdc-options bytes (including explicit tlv) are now: 0x"+Hexer.tohex(kdc.XmacsRequest.OptionsTag.GetBytes()));

                try
                {
                    kdc.ExecuteXmacs(false);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    VerifyKdcIsStillAlive();
                    return;
                }

                throw new UnexpectedTestResultException("Expected request to be ignored but we got a response.");
            }

            [TestCase, Description("Encode a generalized string of length 0xffffffff (but don't provide the actual string) for the realm.")]
            public void GeneralizedString_LengthFFFFFFFF()
            {
                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.RetryLostPackets=false;
                kdc.CreateXmacsRequest();
                kdc.XmacsRequest.Input.GeneratePreauths();
                kdc.XmacsRequest.SetRequest();
                kdc.XmacsRequest.ConstructRequest();

                kdc.XmacsRequest.Realm.String="1234"; //set the realm such that we get 6 bytes total for the tag+length+value.  we will replace this after everything else has a valid length recalculated.
                kdc.XmacsRequest.RecalculateLengths();

                kdc.XmacsRequest.RealmTag.GetValueTagLengthValue().Tag.Bytes=new byte[]{0x1B}; //generalized string
                kdc.XmacsRequest.RealmTag.GetValueTagLengthValue().Length.Bytes=new byte[]{0x84, 0xFF, 0xFF, 0xFF, 0xFF}; //length 0xffffffff
                kdc.XmacsRequest.RealmTag.GetValueTagLengthValue().Value=null; //we're not actually providing any data for the string

                Global.RO.Debug("KDC-REQ-BODY realm bytes (including explicit tlv) are now: 0x"+Hexer.tohex(kdc.XmacsRequest.RealmTag.GetBytes()));

                try
                {
                    kdc.ExecuteXmacs(false);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    VerifyKdcIsStillAlive();
                    return;
                }

                throw new UnexpectedTestResultException("Expected request to be ignored but we got a response.");
            }

            [TestCase, Description("Encode a octet of length 0xffffffff for the encrypted timestamp preauth")]
            public void OctetString_LengthFFFFFFFF()
            {
                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.RetryLostPackets=false;
                kdc.CreateXmacsRequest();
                kdc.XmacsRequest.Input.GeneratePreauths();
                kdc.XmacsRequest.SetRequest();
                kdc.XmacsRequest.ConstructRequest();

                Kerberos.Preauth<Kerberos.PreauthEncryptedTimestamp> paet=kdc.XmacsRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthEncryptedTimestamp>>();

                paet.Data.EncryptedBytes.Bytes=new byte[4]; //set the cipher text of the encrypted data such that we get 6 bytes total for the tag+length+value.  we will replace this after everything else has a valid length recalculated.
                kdc.XmacsRequest.RecalculateLengths();

                paet.Data.EncryptedBytesTag.GetValueTagLengthValue().Tag.Bytes=new byte[]{0x04}; //generalized string
                paet.Data.EncryptedBytesTag.GetValueTagLengthValue().Length.Bytes=new byte[]{0x84, 0xFF, 0xFF, 0xFF, 0xFF}; //length 0xffffffff
                paet.Data.EncryptedBytes.Bytes=new byte[0]; //we're not actually providing any data for the thing

                Global.RO.Debug("preauth encrypted timestamp data bytes (including explicit tlv) are now: 0x"+Hexer.tohex(paet.Data.EncryptedBytesTag.GetBytes()));

                try
                {
                    kdc.ExecuteXmacs(false);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    VerifyKdcIsStillAlive();
                    return;
                }

                throw new UnexpectedTestResultException("Expected request to be ignored but we got a response.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PanoramaAskdc.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    abstract public class TestBase_PanoramaAskdc : TestBase_Panorama
    {
        public TestBase_PanoramaAskdc()
        {
            ClientType=AuthContext.ClientTypes.Panorama;
        }
    }

    /// <summary>
    /// Panorama AKA Live on Windows tests go here
    /// </summary>
    [TestGroup]
    public class PanoramaAskdc: XkdcTestBaseGroup
    {
        public PanoramaAskdc()
        {
            ParentClientType=AuthContext.ClientTypes.Panorama;
        }

        public override void PreRun()
        {
            TestBase_Panorama.ClearMachineCache();
        }

        [TestCase, DVT]
        class Simple_Machine: TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                SignInAskdc();
            }
        }

        [TestCase, DVT]
        class Simple_NewUser: TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                authContext.SetNewPassportUser(0);
                SignInAskdc();
            }
        }

        [TestCase, DVT]
        class Simple_LimitedMachine: TestBase_PanoramaAskdc
        {
            //We don't want to use the cached normal machine account for this test
            public override bool UseCachedMachineAccount()
            {
                return false;
            }

            //
            override protected void RunTest()
            {
                authContext.SetNewPassportUser(0);
                authContext.SponsorToken = PanoramaLimited.c_LimitedToken;

                SignInAskdc();
            }
        }




        [TestCase]
        class DualSignin_NewUsers: TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                authContext.SetNewPassportUser(0);
                SignInAskdc();

                // Do it again. Reuse machine account.
                Throttle();
                authContext.SetNewPassportUser(0);
                SignInAskdc();
            }
        }

        [TestCase]
        class Ticket_Corrupted : TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                // Ticket is only used for a user sign-in
                authContext.SetNewPassportUser(0);
                authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                authContext.PassportTicket[0]++;
                SignInAskdc(E_NoResponse);
            }
        }

        [TestCase]
        class Ticket_Short : TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                authContext.SetNewPassportUser(0);
                authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                authContext.PassportTicket = new byte[1];
                SignInAskdc(E_NoResponse);
            }
        }

        //67888 is the work item for this... it's currently a fall 2007 item, so this test will fail until then.
        [TestCase(18268, BugDatabase="Xbox 360 Console Software"), Description("Sign in 2 PC users (1 with passport, 1 just from live) on 1 machine. Panorama is supposed to only support 1 user per machine")] //Original Xenon BugID=67888
        class User_2User_Passport_Live: TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                authContext.SetNewPassportUser(0);
                authContext.SetNewUser(1);
                SignInAskdc(E_NoResponse);
            }
        }

        [TestCase, Description("PC.")]
        class MachineName_Invalid : TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                authContext.SetNewPassportUser(0);
                authContext.UsersMachine.SetGamertag("PC.");
                SignInAskdc(E_PreauthFailed);
            }
        }

        [TestCase, Description("QC.<correct numbers>")]
        class MachineName_Invalid2 : TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                authContext.SetNewPassportUser(0);
                authContext.UsersMachine.Gamertag[0]++;
                SignInAskdc(E_PreauthFailed);
            }
        }

        [TestCase, Description("PC.USER")]
        class MachineName_Invalid3 : TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                authContext.SetNewPassportUser(0);
                authContext.UsersMachine.SetGamertag("PC.USER");
                SignInAskdc(E_PreauthFailed);
            }
        }

        [TestCase, Description("(15 blanks)")]
        class MachineName_Invalid4 : TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                authContext.SetNewPassportUser(0);
                authContext.UsersMachine.SetGamertag("               ");
                SignInAskdc(E_PreauthFailed);
            }
        }

        [TestCase]
        class BadRealm : TestBase_PanoramaAskdc
        {
            private void Go(string realm)
            {
                DisableRetryBehaviour=true;
                ro.Debug("Setting k_PassportKerberosRealm to {0}", realm);
                authContext.SetNewPassportUser(0);
                authContext.Users[0].SetRealm(realm);
                SignInAskdc(E_NoResponse);
                Throttle();
            }
            override protected void RunTest()
            {
                try
                {
                    // Correct one is PASSPORT.NET
                    Go("@passport.net");
                    Go("passport");
                    Go("passport net");
                    Go(".net");
                    Go("macx.xbox.com");
                    Go("xbox.com");
                    try //since the xbox1 decom this will fail with the xbox1 decom kerb error code
                    {
                        Go("macs.xbox.com");
                    }
                    catch (ServerTestFramework.LiveService.Auth.KerbErrException kee)
                    {
                        if (kee.KerbErr!=KerbErrCode.KDC_ERR_POLICY)
                        {
                            throw;
                        }
                    }
                    Go("");
                    Go("passport.net  long string                                                                     see");
                }
                catch
                {
                    Fail("k_PassportKerberosRealm={0}", authContext.k_PassportKerberosRealm);
                    throw;
                }

            }
        }

        [TestCase]
        class BadUserName: TestNode
        {
            KdcUser user;
            KdcClientPC client;

            public override void PreRun()
            {
                user=new KdcUser();
                user.CreateUser(true);

                client=new KdcClientPC();
                client.CreateXmacsRequest();
                client.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                client.ExecuteXmacs(true);

                client.RetryLostPackets=false;
            }

            private void Go(string name)
            {
                Global.RO.Debug("Using principal {0}", name);
                client.ClearAskdc();
                client.CreateAskdcUserRequest(user);
                client.AskdcRequest.Input.ConsoleOrUserName=name;

                //should always time out
                try
                {
                    client.ExecuteAskdc(true);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Request unexpectedly succeeded for client name: "+name);
            }

            public override void Run()
            {
                // Correct one is PC.USER@XBOX.COM
                Go("PC@XBOX.COM");
                Go("XBOX.COM");
                Go("");
                Go("PC.USER@PASSPORT.NET");
                Go("@XBOX.COM");
                Go("PC.NAME@XBOX.COM");
                Go("PC.USER@XBOX.COM  long string                                                                  see");
            }
        }

        /*
        The old preauth uses the passport puid to locate the xbox user puid.  There is no concept of mismatch, only "found or not found".
        [TestCase, Description("Use a passport RPS ticket for a different user.")]
        public void MismatchedPassportPuid()
        {
            KdcUser correctUser=new KdcUser();
            correctUser.CreateUser(true);

            KdcClientPC kdc=new KdcClientPC();
            kdc.CreateXmacsRequest();
            kdc.XmacsRequest.Input.Passport=correctUser.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            kdc.ExecuteXmacs(true);

            KdcUser otherUser=new KdcUser();
            otherUser.CreateUser(true);

            kdc.CreateAskdcUserRequest(correctUser);
            kdc.AskdcRequest.Input.PlainPassport=otherUser.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

            kdc.AskdcThrowOnKerberosError=false;
            kdc.ExecuteAskdc(true);
            ValueCheck.Test("Got a Kerberos error response", true, kdc.AskdcError!=null);
            ValueCheck.Test("Kerberos Error", KerbErrCode.KDC_ERR_C_PRINCIPAL_UNKNOWN, kdc.AskdcError.ErrorCode.Int64);
        }*/

        [TestCase, Description("Use a passport RPS ticket that is not associated with any xbox live user.")]
        public void NonXboxPassportPuid()
        {
            KdcUser correctUser=new KdcUser();
            correctUser.CreateUser(true);

            KdcClientPC kdc=new KdcClientPC();
            kdc.CreateXmacsRequest();
            kdc.XmacsRequest.Input.PlainPassport=correctUser.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            kdc.ExecuteXmacs(true);

            PassportAuth otherPassport=new PassportAuth();
            otherPassport.CreateUser();

            kdc.CreateAskdcUserRequest(correctUser);
            kdc.AskdcRequest.Input.PlainPassport=otherPassport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

            kdc.AskdcThrowOnKerberosError=false;
            kdc.ExecuteAskdc(true);
            ValueCheck.Test("Got a Kerberos error response", true, kdc.AskdcError!=null);
            ValueCheck.Test("Kerberos Error", KerbErrCode.KDC_ERR_C_PRINCIPAL_UNKNOWN, kdc.AskdcError.ErrorCode.Int64);
        }

        [TestCase, Description("Simple mainline case of including the encrypted passport preauth.")]
        public void SimpleMainlineEncryptedPassportPreauth()
        {
            //make user
            Global.RO.Debug("Creating a user with a passport...");
            KdcUser user=new KdcUser();
            user.CreateUser(true);
            user.Passport.EncryptForPanoramaByDefault=true;

            //xmacs
            Global.RO.Debug("Making request...");
            KdcClientPC kdc=new KdcClientPC();
            kdc.CreateXmacsRequest();
            kdc.ExecuteXmacs(true);

            //askdc machine
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //askdc user
            kdc.CreateAskdcUserRequest(user);
            kdc.ExecuteAskdc(true);
        }

        [TestCase, Description("Simple mainline case of including the encrypted passport preauth.")]
        public class SimpleMainlineEncryptedPassportPreauth_NativeClient: TestBase_PanoramaAskdc
        {
            override protected void RunTest()
            {
                authContext.IncludeEncryptedPassportByDefault=true;
                authContext.SetNewPassportUser(0);
                SignInAskdc();

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PanoramaTitles.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace XkdcTest
{
    abstract public class TestBase_PanoramaTitles : TestBase_Panorama
    {
        protected const AuthContext.ClientTypes Xenon       = AuthContext.ClientTypes.Xenon;
        protected const AuthContext.ClientTypes Fusion      = AuthContext.ClientTypes.XenonBackCompat;
        protected const AuthContext.ClientTypes Panorama    = AuthContext.ClientTypes.Panorama;

        protected const uint XboxTitle      = 0xFFC0FE00;
        protected const uint XenonTitle     = 0xC0FE0800;
        protected const uint PanoramaTitle  = 0xC0FE0900;

        protected const uint HrOk           = HResult.S_OK;
        protected const uint HrUpdate       = HResult.XONLINE_E_LOGON_UPDATE_REQUIRED;
        protected const uint HrFlashUpdate  = HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED;
        protected const uint HrUnknown      = HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
        protected const uint HrBanned       = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;

        protected AuthContext   cachedMachine               = null;
        protected bool          bBanMachine                 = false;

        override public void SetDefaults()
        {
            // do nothing, it will all be done in Go()
        }

        protected void Go(
            AuthContext.ClientTypes clientType,
            uint titleId,
            uint titleVer,
            uint flashVersion,
            string user1,
            bool bAutoDiscover,
            uint expectedHR)
        {
            ResultCode = TEST_RESULTS.FAILED;
            bVerifyUserFlags = false;
            bVerifyServices = false;
            bVerifyPrivileges = false;

            // Reset client type, create new authcontext, set XKDC defaults
            this.ClientType = clientType;
            authContext = new AuthContext(ClientType);
            XkdcClient.SetDefaults(authContext);
            AskdcClient.SetDefaults(authContext);

            // Set title fields
            authContext.SetTitle(titleId, titleVer, 1);
            authContext.TitleInfo.FlashVersion = flashVersion;

            // May be null for machine signin
            //SetUser(user1, 0);

            // Set expected overall HR
            ExpectedHR = expectedHR;

            // Create machine if nothing cached OR we want to ban this machine
            if (cachedMachine != null)
            {
                authContext.PassportMemberName = cachedMachine.PassportMemberName;
                authContext.PassportPassword = cachedMachine.PassportPassword;
                authContext.PcId = cachedMachine.PcId;
                authContext.SponsorToken = cachedMachine.SponsorToken;
                authContext.MachineUser = cachedMachine.MachineUser;
                authContext.UsersMachine = cachedMachine.UsersMachine;
                authContext.PassportTicket = cachedMachine.PassportTicket;
                authContext.PassportSessionKey = cachedMachine.PassportSessionKey;
            }
            else
            {
                CreateMachine(bBanMachine);
            }

            // Set services to request
            if (!bAutoDiscover)
            {
                this.ExpectedServices = new uint[] { 1, 2, 3, 6, 15 };
                if (user1 == null)
                {
                    this.ExpectedHRs = new uint[] { 0x80151101, 0, 0, 0x80151101, 1 };
                }
                else
                {
                    this.ExpectedHRs = new uint[] { 0, 0, 0, 0, 1 };
                }
            }

            // Let's explicitly sign in to the ASKDC.. just 'cause.
            if (clientType != AuthContext.ClientTypes.Panorama && user1 != null)
            {
                SetUser(user1, 0);
            }
            else if (user1 != null)
            {
                authContext.SetNewPassportUser(0);
            }
            //MakePassportAccount();
            //SignInAskdc();

            // Sign in
            if (SignInXkdc(bAutoDiscover))
            {
                if (expectedHR == HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED ||
                    expectedHR == HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)
                {
                    // Sign in again and explicitly request only the auto-update service
                    authContext.ClearXkdc();
                    XkdcClient.SetDefaults(authContext);
                    this.result = null;
                    ExpectedServices = new uint[] { 3 };
                    bVerifyServices = true;
                    if (!bBanMachine)
                    {
                        ExpectedHRs = new uint[] { 0 };
                        ExpectedHR = HResult.S_OK;
                    }
                    else
                    {
                        ExpectedHRs = new uint[] { 1 };
                        ExpectedHR = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                    }
                    ro.Debug("Signing in again for the auto-update service...");
                    if (SignInXkdc(false))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        protected void CreateMachine(bool bBanMachine)
        {
            // If the authContext already has a PassportTicket, then letting Xmacs do its 
            // default thing won't override it.  It may change the passport member name 
            // fields, but the ticket itself will remain intact.
            XmacsClient xmacs = new XmacsClient(authContext);
            xmacs.SignInXmacs();
            Throttle();

            if (bBanMachine)
            {
                ro.Debug("Banning machine 0x{0:X}...",
                         xmacs.GetMachinePuid());

                ulong puid=xmacs.GetMachinePuid();
                MachineEditor machEd=MachineEditor.FromId(puid);
                machEd.BanMachine();
            }

            // bah!!!
            cachedMachine = authContext;
        }

        protected void GoMachineUser(
            AuthContext.ClientTypes clientType,
            uint titleId,
            uint titleVer,
            uint flashVersion,
            uint expectedHR)
        {
            string user = null;
            try
            {
                ClearUsers();
                Go(clientType, titleId, titleVer, flashVersion, user, 
                   clientType != AuthContext.ClientTypes.Xbox, expectedHR);
                if (ResultCode == TEST_RESULTS.FAILED)
                {
                    Fail("Failed machine signin for titleid=0x{0:X}, titlever={1}, flashver={2}", 
                        titleId, titleVer, flashVersion);
                    return;
                }
            }
            catch (Exception)
            {
                Fail("Failed machine signin for titleid=0x{0:X}, titlever={1}, flashver={2}", 
                        titleId, titleVer, flashVersion);
                throw;
            }

            try
            {
                Go(clientType, titleId, titleVer, flashVersion, user, 
                   clientType != AuthContext.ClientTypes.Xbox, expectedHR);
                if (ResultCode == TEST_RESULTS.FAILED)
                {
                    Fail("Failed user signin for titleid=0x{0:X}, titlever={1}, flashver={2}", 
                        titleId, titleVer, flashVersion);
                    return;
                }
            }
            catch (Exception)
            {
                Fail("Failed user ({0}) signin for titleid=0x{1:X}, titlever={2}, flashver={3}", 
                        user, titleId, titleVer, flashVersion);
                throw;
            }

        }



    }

    /// <summary>
    /// Panorama AKA Live on Windows tests go here
    /// </summary>
    [TestGroup]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class PanoramaTitles: XkdcTestBaseGroup
    {
        public PanoramaTitles()
        {
            ParentClientType=AuthContext.ClientTypes.Panorama;
        }

        public override void PreRun()
        {
            TestBase_Panorama.ClearMachineCache();
        }

        // Cases:
        // M  T  Sucess
        // x1 x1 y
        // x1 xe n
        // x1 pc n
        //
        // xe x1 y
        // xe xe y
        // xe pc n
        //
        // pc x1 n
        // pc xe n
        // pc pc y

        // Function signature:
        // GoMachineUser(clientType, titleId, titleVer, flashVer, expectedHR)

        [TestCase, Description("Expected success")]
        class PlatformEnforce_PlatXenon_TitleXbox : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Xenon, XboxTitle, 1, 1, HResult.S_OK);
            }
        }

        [TestCase, Description("Expected success")]
        class PlatformEnforce_PlatXenon_TitleXenon : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Xenon, XenonTitle, 1, 1, HResult.S_OK);
            }
        }

        [TestCase, Description("Expected error")]
        class PlatformEnforce_PlatXenon_TitlePanorama : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Xenon, PanoramaTitle, 1, 1, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE);
            }
        }


        [TestCase, Description("Expected error")]
        class PlatformEnforce_PlatPanorama_TitleXbox : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, XboxTitle, 1, 1, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE);
            }
        }

        [TestCase, Description("Expected error")]
        class PlatformEnforce_PlatPanorama_TitleXenon : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, XenonTitle, 1, 1, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE);
            }
        }

        [TestCase, Description("Expected success")]
        class PlatformEnforce_PlatPanorama_TitlePanorama : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, PanoramaTitle, 1, 1, HResult.S_OK);
            }
        }

        // Title Update Tests
        // Using a single Panorama title id (0x3EEF0950), sign in with all platform types 
        // and with regular machines. In addition, each test will do a 
        // machine-only sign in plus a single user sign-in.  For this test title, the 
        // following versions are in effect:
        //   BaseVer  Update
        //   1        n
        //   2        y


        // Xenon title update
        [TestCase, Description("Expect invalid title")]
        class PanTitleUpdate_Xenon_NoUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Xenon, 0x3EEF0950, 1, 1, HrUnknown);
            }
        }

        [TestCase, Description("Expect invalid title")]
        class PanTitleUpdate_Xenon_BaseUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Xenon, 0x3EEF0950, 2, 1, HrUnknown);
            }
        }

        [TestCase, Description("Banned machine")]
        class PanTitleUpdate_Xenon_BothUpdate_Banned : TestBase_PanoramaTitles {
            override protected void RunTest() {
                bBanMachine = true;
                GoMachineUser(Xenon, 0x3EEF0950, 2, 1, HrBanned);
            }
        }

        // Xenon beta title update
        [TestCase, Description("Expect invalid title")]
        class PanTitleUpdate_XenonBeta_NoUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Xenon, 0x3EEF0950, 1, 1, HrUnknown);
            }
        }

        [TestCase, Description("Expect invalid title")]
        class PanTitleUpdate_XenonBeta_BaseUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Xenon, 0x3EEF0950, 2, 1, HrUnknown);
            }
        }

        [TestCase, Description("Banned machine")]
        class PanTitleUpdate_XenonBeta_BothUpdate_Banned : TestBase_PanoramaTitles {
            override protected void RunTest() {
                bBanMachine = true;
                GoMachineUser(Xenon, 0x3EEF0950, 2, 1, HrBanned);
            }
        }


        // Panorama title update
        [TestCase, Description("Expect no update")]
        class PanTitleUpdate_Panorama_NoUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, 0x3EEF0950, 1, 1, HrOk);
            }
        }

        [TestCase, Description("Expect update")]
        class PanTitleUpdate_Panorama_BaseUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, 0x3EEF0950, 2, 1, HrUpdate);
            }
        }

        [TestCase, Description("Banned machine")]
        class PanTitleUpdate_Panorama_BothUpdate_Banned : TestBase_PanoramaTitles {
            override protected void RunTest() {
                bBanMachine = true;
                GoMachineUser(Panorama, 0x3EEF0950, 2, 1, HrBanned);
            }
        }

        // Panorama beta title update
        [TestCase, Description("Expect no update")]
        class PanTitleUpdate_PanoramaBeta_NoUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, 0x3EEF0950, 1, 1, HrOk);
            }
        }

        [TestCase, Description("Banned machine")]
        class PanTitleUpdate_PanoramaBeta_BothUpdate_Banned : TestBase_PanoramaTitles {
            override protected void RunTest() {
                bBanMachine = true;
                GoMachineUser(Panorama, 0x3EEF0950, 2, 1, HrBanned);
            }
        }


        // Panorama system updates
        // Title id: 0x585207D1
        // My dbposter stuff will set up a few "special" versions to be used for update 
        // testing.
        //
        // Flash versions:
        //   22  update Y  beta N
        //   24  update Y  beta N
        //


        // Test non-beta machines
        // System version requires base update
        [TestCase, Description("Expect flash update")]
        class PanSysUpdate_PanoramaMachine_SysBaseUpdate_TitleNoUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, 0x3EEF0950, 1, 22, HrFlashUpdate);
            }
        }

        [TestCase, Description("Expect flash update")]
        class PanSysUpdate_PanoramaMachine_SysBaseUpdate_TitleBaseUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, 0x3EEF0950, 2, 22, HrFlashUpdate);
            }
        }

        [TestCase, Description("Expect flash update")]
        class PanSysUpdate_PanoramaMachine_SysBaseUpdate_TitleBetaUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, 0x3EEF0950, 3, 22, HrFlashUpdate);
            }
        }

        // Test beta machines

        // System version requires base update
        [TestCase, Description("Expect flash update")]
        class PanSysUpdate_PanoramaMachineBeta_SysBaseUpdate_TitleNoUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, 0x3EEF0950, 1, 22, HrFlashUpdate);
            }
        }

        [TestCase, Description("Expect flash update")]
        class PanSysUpdate_PanoramaMachineBeta_SysBaseUpdate_TitleBaseUpdate : TestBase_PanoramaTitles {
            override protected void RunTest() {
                GoMachineUser(Panorama, 0x3EEF0950, 2, 22, HrFlashUpdate);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PreauthWhitelistXkdc.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    [TestGroup, Description("Tests for the preauth whitelist in xkdc."), AsyncThreadDelay(100)]
    public class PreauthWhitelistXkdc: TestNode
    {
        //expectSuccess: If bool then it expects success or timeout.  Else it's an int with the kerberos error to expected.
        public static void TryPreauthList(uint []preauths, object expectSuccess, AuthContext.ClientTypes clientType)
        {
            Global.RO.Debug("Preauths in request: "+StringUtils.MakeCommaSeparatedList(preauths));

            KdcClient client=new KdcClient(clientType);
            client.CreateXmacsRequest();
            if (clientType==AuthContext.ClientTypes.Panorama)
            {
                client.XmacsRequest.Input.PlainPassport=GetCachedPassportUser().Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            }

            client.CreateXkdcRequest();
            client.XkdcRequest.Input.PreauthsToGenerate=new System.Collections.Generic.LinkedList<int>();
            foreach (int pa in preauths)
            {
                client.XkdcRequest.Input.PreauthsToGenerate.AddLast((int)pa);
            }

            if (expectSuccess==null || (expectSuccess is bool && (bool)expectSuccess==true)) //expect success
            {
                client.ExecuteXkdc(true);
            }
            else if (expectSuccess is bool && (bool)expectSuccess==false) //expect timeout
            {
                client.RetryLostPackets=false;
                try
                {
                    client.ExecuteXkdc(true);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Request unexpectedly succeeded.");
            }
            else //expect kerberos error
            {
                int expectedKerbError=(int)expectSuccess;

                client.XkdcThrowOnKerberosError=false;
                client.ExecuteXkdc(true);

                if (client.XkdcError==null)
                {
                    throw new UnexpectedTestResultException("Request unexpectedly succeeded.");
                }

                ValueCheck.Test("Kerberos Error Returned", expectedKerbError, (int)client.XkdcError.ErrorCode.Int64);
            }
        }

        public static uint[] MergeArrays(uint []arr0, uint []arr1)
        {
            uint []newArr=new uint[arr0.Length+arr1.Length];
            System.Array.Copy(arr0, 0, newArr, 0, arr0.Length);
            System.Array.Copy(arr1, 0, newArr, arr0.Length, arr1.Length);
            return newArr;
        }

        public static uint[] ReverseArray(uint []arr)
        {
            uint []newArr=new uint[arr.Length];
            for (int i=0; i<arr.Length; ++i)
            {
                newArr[i]=arr[arr.Length-i-1];
            }
            return newArr;
        }

        //we keep a cache of users that we rotate through
        //we also limit their time-between-reuse to avoid triggering kdc anti-dos code
        private static TimedQueue<KdcUser> cachedUsers=null;

        public static KdcUser GetCachedPassportUser()
        {
            if (cachedUsers==null)
            {
                cachedUsers=new TimedQueue<KdcUser>();
                cachedUsers.MinimumReuseTime=new System.TimeSpan(0, 0, 0, 5);
                cachedUsers.MinimumQueueSize=5;
            }

            KdcUser user=cachedUsers.PopFront();

            if (user==null)
            {
                user=new KdcUser();
                user.CreateUser(true);
            }

            cachedUsers.PushBack(user);
            return user;
        }

        // -- mainline tests for what a real client will do

        public static uint []Xbox360LaunchPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_TGS_REQ, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up when it was first released."), TestCasePriority(1)]
        public void Xbox360Launch()
        {
            TryPreauthList(Xbox360LaunchPreauths, true, AuthContext.ClientTypes.Xenon);
        }

        public static uint []Xbox360BerlinPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_TGS_REQ, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up starting with the Berlin release in 2010."), TestCasePriority(1)]
        public void Xbox360Berlin()
        {
            TryPreauthList(Xbox360BerlinPreauths, true, AuthContext.ClientTypes.Xenon);
        }

        public static uint []Xbox360MadridPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_TGS_REQ};
        [TestCase, Description("Preauths the Xbox360 sent up starting with the Berlin release in late 2011."), TestCasePriority(1)]
        public void Xbox360Madrid()
        {
            TryPreauthList(Xbox360MadridPreauths, true, AuthContext.ClientTypes.Xenon);
        }

        public static uint []PanoramaLaunchPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_TGS_REQ, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Panorama client sent up when it was first released."), TestCasePriority(1)]
        public void PanoramaLaunch()
        {
            TryPreauthList(PanoramaLaunchPreauths, true, AuthContext.ClientTypes.Panorama);
        }

        // -- other tests

        [TestCase, Description("Preauths the Xbox360 sent up when it was first released, reversed."), TestCasePriority(2)]
        public void Xbox360LaunchReversed()
        {
            TryPreauthList(ReverseArray(Xbox360LaunchPreauths), true, AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Preauths the Xbox360 sent up starting with the Berlin release in 2010, reversed."), TestCasePriority(2)]
        public void Xbox360BerlinReversed()
        {
            TryPreauthList(ReverseArray(Xbox360BerlinPreauths), true, AuthContext.ClientTypes.Xenon);
        }

        //PanoramaLaunch is identical to xbox360 launch; Madrid is the same as Berlin except one preauth is omitted.  No reason to also have the reverse tests for these.

        // --

        //note that xbox360 and panorama use the exact same preauths for xkdc, so there is no reason to duplicate the xbox360 tests here for panorama
        [TestGroup, TestCasePriority(2)]
        [CompoundCase("SR2", 2)]
        [CompoundCase("SR3", 3)]
        public class Xbox360: TestNode
        {
            public override void PreRun()
            {
                CreateContextData();
                if ((int)MyValues[0]==2)
                {
                    SetContextData("SRPreauth", PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2);
                }
                else
                {
                    SetContextData("SRPreauth", PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3);
                }
            }

            //

            [TestCase, Description("Try with and without the optional preauths.")]
            [CompoundCase("Minimum", new uint[]{})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
            [CompoundCase("Both", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            public void OptionalPreauths(TestNode self)
            {
                uint []optionalPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ, (uint)GetContextData("SRPreauth")}, optionalPreauths);

                TryPreauthList(preauths, true, AuthContext.ClientTypes.Xenon);
            }

            [TestCase, Description("Include preauths that are not allowed."), AsyncGroup(2, 2), AsyncThreadDelay(100), AsyncThreadCount(20)]
            [CompoundCase("KRB5_PADATA_NONE", new uint[]{PreAuthType.KRB5_PADATA_NONE})]
            [CompoundCase("KRB5_PADATA_ENC_TIMESTAMP", new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP})]
            [CompoundCase("KRB5_PADATA_PW_SALT", new uint[]{PreAuthType.KRB5_PADATA_PW_SALT})]
            [CompoundCase("KRB5_PADATA_ENC_UNIX_TIME", new uint[]{PreAuthType.KRB5_PADATA_ENC_UNIX_TIME})]
            [CompoundCase("KRB5_PADATA_ENC_SANDIA_SECURID", new uint[]{PreAuthType.KRB5_PADATA_ENC_SANDIA_SECURID})]
            [CompoundCase("KRB5_PADATA_SESAME", new uint[]{PreAuthType.KRB5_PADATA_SESAME})]
            [CompoundCase("KRB5_PADATA_OSF_DCE", new uint[]{PreAuthType.KRB5_PADATA_OSF_DCE})]
            [CompoundCase("KRB5_CYBERSAFE_SECUREID", new uint[]{PreAuthType.KRB5_CYBERSAFE_SECUREID})]
            [CompoundCase("KRB5_PADATA_AFS3_SALT", new uint[]{PreAuthType.KRB5_PADATA_AFS3_SALT})]
            [CompoundCase("KRB5_PADATA_ETYPE_INFO", new uint[]{PreAuthType.KRB5_PADATA_ETYPE_INFO})]
            [CompoundCase("KRB5_PADATA_SAM_CHALLENGE", new uint[]{PreAuthType.KRB5_PADATA_SAM_CHALLENGE})]
            [CompoundCase("KRB5_PADATA_SAM_RESPONSE", new uint[]{PreAuthType.KRB5_PADATA_SAM_RESPONSE})]
            [CompoundCase("KRB5_PADATA_PK_AS_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REQ})]
            [CompoundCase("KRB5_PADATA_PK_AS_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REP})]
            [CompoundCase("KRB5_PADATA_PK_AS_SIGN", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_SIGN})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REQ})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REP})]
            [CompoundCase("KRB5_PADATA_REFERRAL_INFO", new uint[]{PreAuthType.KRB5_PADATA_REFERRAL_INFO})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_S4U", new uint[]{PreAuthType.KRB5_PADATA_S4U})]
            [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY})]
            [CompoundCase("KRB5_PADATA_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_CLIENT_VERSION})]
            [CompoundCase("KRB5_PADATA_XBOX_SERVICE_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XBOX_SERVICE_REQUEST})]
            [CompoundCase("KRB5_PADATA_XBOX_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA})]
            [CompoundCase("KRB5_PADATA_XBOX_ECHO", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ECHO})]
            [CompoundCase("KRB5_PADATA_XENON_MAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_PC_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION})]
            [CompoundCase("KRB5_PADATA_XENON_PPA", new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA})]
            [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION})]
            [CompoundCase("KRB5_PADATA_XENON_MAC_REQUEST2", new uint[]{PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST2})]
            public void NotAllowedPreauths(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ, (uint)GetContextData("SRPreauth")}, extraPreauths);

                TryPreauthList(preauths, false, AuthContext.ClientTypes.Xenon);
            }

            [TestCase, Description("Include a preauth twice.")]
            [CompoundCase("KRB5_PADATA_TGS_REQ", new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ})]
            [CompoundCase("SR", new uint[]{0})] //sentinal value replaced by test
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
            public void DuplicatePreauth(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                for (int i=0; i<extraPreauths.Length; ++i)
                {
                    if (extraPreauths[i]==0)
                    {
                        extraPreauths[i]=(uint)GetContextData("SRPreauth");
                    }
                }

                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ, (uint)GetContextData("SRPreauth")}, extraPreauths);

                TryPreauthList(preauths, false, AuthContext.ClientTypes.Xenon);
            }

            [TestCase, Description("Don't include tgs request preauth which is required.")]
            public void NoTgsReqPreauth()
            {
                TryPreauthList(new uint[]{
                    (uint)GetContextData("SRPreauth")},
                    KerbErrCode.KDC_ERR_PADATA_TYPE_NOSUPP, //ideally the kdc would just ignore the request, but in this case some lower-level code returns this instead when tgs req is missing
                    AuthContext.ClientTypes.Xenon);
            }

        };

        [TestCase, Description("Include both sr preauths.  Most network hardware will block this so it will fail the same way as the few places that let it through."), TestCasePriority(2), AsyncGroup(3)]
        public void BothXbox360SRs()
        {
            TryPreauthList(new uint[]{
                PreAuthType.KRB5_PADATA_TGS_REQ,
                PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2,
                PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3},
                false,
                AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Send no preauths."), TestCasePriority(2), AsyncGroup(3)]
        public void Nothing()
        {
            TryPreauthList(new uint[]{},
                KerbErrCode.KDC_ERR_PADATA_TYPE_NOSUPP, //ideally the kdc would just ignore the request, but in this case some lower-level code returns this instead when tgs req is missing
                AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Send only the optional preauths, not any required one."), TestCasePriority(2), AsyncGroup(3)]
        [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
        [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
        public void OptionalPreauthsOnly(TestNode self)
        {
            uint []optionalPreauths=(uint[])self.MyValues[0];

            TryPreauthList(optionalPreauths,
                KerbErrCode.KDC_ERR_PADATA_TYPE_NOSUPP, //ideally the kdc would just ignore the request, but in this case some lower-level code returns this instead when tgs req is missing
                AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Don't include the required service request preauth."), TestCasePriority(2), AsyncGroup(3)]
        public void NoSR()
        {
            TryPreauthList(new uint[]{
                PreAuthType.KRB5_PADATA_TGS_REQ},
                false,
                AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Include very large-numbered preauths."), TestCasePriority(2), AsyncGroup(3)]
        public void LargePreauthNumber()
        {
            TryPreauthList(new uint[]{
                PreAuthType.KRB5_PADATA_TGS_REQ,
                PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3,
                0x7fffffff}, //note that asn encoded integers actually have a range far more massive than a 32-bit value, but the automatic preauth helper test stuff doesn't support that.
                false,
                AuthContext.ClientTypes.Xenon);
        }
    };
}; //namespace XkdcTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PreauthWhitelistAskdc.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;

namespace XkdcTest
{
    //Note that echo is covered automatically by KdcClient in nearly all cases, so there aren't many specific tests incuding it.
    [TestGroup, Description("Tests for the preauth whitelists in askdc.  Note that Askdc has 2 separate whitelist sets, one for normal requests and one for raw passport user requests."), AsyncThreadDelay(100), AsyncGroup(1, 0), AsyncThreadCount(8)]
    public class PreauthWhitelistAskdc: TestNode
    {
        //Create a normal user request (client type is xbox360)
        public static KdcClient PrepareAskdcNormalUserRequest(uint []preauths)
        {
            return PrepareAskdcNormalUserRequest(preauths, false);
        }

        public static KdcClient PrepareAskdcNormalUserRequest(uint []preauths, bool askdcAuthDataHasMachineIfPresent)
        {
            KdcUser user=GetCachedUser();

            KdcClientXbox360 client=new KdcClientXbox360();
            PrepareClient(client, preauths, askdcAuthDataHasMachineIfPresent);
            client.CreateAskdcUserRequest(user);
            PrepareInputs(client, preauths, user);

            Global.RO.Debug("Preauths in request: "+StringUtils.MakeCommaSeparatedList(preauths));
            return client;
        }

        //Create a raw passport user request (client type is panorama).  This is unique in that it has a separate whitelist.
        public static KdcClient PrepareAskdcRawPassportUserRequest(uint []preauths)
        {
            KdcUser user=GetCachedUser();
            EnsureUserHasPassport(user);

            KdcClientPC client=new KdcClientPC();
            PrepareClient(client, preauths, false);
            client.CreateAskdcUserRequest(user);
            PrepareInputs(client, preauths, user);

            Global.RO.Debug("Preauths in request: "+StringUtils.MakeCommaSeparatedList(preauths));
            return client;
        }

        //Create a normal machine request.  This is essentially the same as a normal user request.
        public static KdcClient PrepareAskdcMachineRequest(uint []preauths, AuthContext.ClientTypes clientType)
        {
            KdcUser user=null;

            KdcClient client=new KdcClient(clientType);
            client.CreateXmacsRequest();
            if (clientType==AuthContext.ClientTypes.Panorama)
            {
                user=GetCachedUser();
                EnsureUserHasPassport(user);

                client.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            }

            PrepareClient(client, preauths, false);
            client.CreateAskdcMachineRequest();
            PrepareInputs(client, preauths, user);

            Global.RO.Debug("Preauths in request: "+StringUtils.MakeCommaSeparatedList(preauths));
            return client;
        }

        private static void PrepareClient(KdcClient client, uint []preauths, bool askdcAuthDataHasMachineIfPresent)
        {
            foreach (int pa in preauths)
            {
                //set up as if we had just made a user request
                if (pa==PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY)
                {
                    KdcClientXbox360 tempClient=new KdcClientXbox360();
                    if (askdcAuthDataHasMachineIfPresent) //use a machine
                    {
                        tempClient.CreateAskdcMachineRequest();
                        tempClient.AskdcOutput=new AskdcGenericReplyOutput();
                        tempClient.AskdcOutput.PopulateFromInput(tempClient.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.XboxIdentity);
                    }
                    else //use a users
                    {
                        tempClient.CreateAskdcUserRequest(new KdcUser());
                        tempClient.AskdcOutput=new AskdcGenericReplyOutput();
                        tempClient.AskdcOutput.PopulateFromInput(tempClient.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.XboxIdentity);
                    }

                    client.AskdcOutput=tempClient.AskdcOutput;
                }
            }
        }

        private static void PrepareInputs(KdcClient client, uint []preauths, KdcUser user)
        {
            client.AskdcRequest.Input.PreauthsToGenerate=new System.Collections.Generic.LinkedList<int>();

            foreach (int pa in preauths)
            {
                client.AskdcRequest.Input.PreauthsToGenerate.AddLast((int)pa);

                //include the correct passport ticket or other information if it will be needed
                if (pa==PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION)
                {
                    if (user==null)
                    {
                        user=GetCachedUser();
                    }
                    EnsureUserHasPassport(user);
                    client.AskdcRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                }
                else if (pa==PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION)
                {
                    if (user==null)
                    {
                        user=GetCachedUser();
                    }
                    EnsureUserHasPassport(user);
                    client.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
                }
            }
        }

        //expectSuccess: If bool then it expects success or timeout.  Else it's an int with the kerberos error to expected.
        public static void TryRequest(KdcClient client, object expectSuccess)
        {
            if (expectSuccess==null || (expectSuccess is bool && (bool)expectSuccess==true)) //expect success
            {
                client.ExecuteAskdc(true);
            }
            else if (expectSuccess is bool && (bool)expectSuccess==false) //expect timeout
            {
                client.RetryLostPackets=false;
                try
                {
                    client.ExecuteAskdc(true);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Request unexpectedly succeeded.");
            }
            else if (expectSuccess is int) //expect kerberos error
            {
                int expectedKerbError=(int)expectSuccess;

                client.AskdcThrowOnKerberosError=false;
                client.ExecuteAskdc(true);

                if (client.AskdcError==null)
                {
                    throw new UnexpectedTestResultException("Request unexpectedly succeeded.");
                }

                ValueCheck.Test("Kerberos Error Returned", expectedKerbError, (int)client.AskdcError.ErrorCode.Int64);
            }
            else
            {
                throw new UnexpectedTestResultException("Unexpected type for expectSuccess.");
            }
        }

        public static uint[] MergeArrays(uint []arr0, uint []arr1)
        {
            uint []newArr=new uint[arr0.Length+arr1.Length];
            System.Array.Copy(arr0, 0, newArr, 0, arr0.Length);
            System.Array.Copy(arr1, 0, newArr, arr0.Length, arr1.Length);
            return newArr;
        }

        public static uint[] ReverseArray(uint []arr)
        {
            uint []newArr=new uint[arr.Length];
            for (int i=0; i<arr.Length; ++i)
            {
                newArr[i]=arr[arr.Length-i-1];
            }
            return newArr;
        }

        //we keep a cache of users that we rotate through
        //we also limit their time-between-reuse to avoid triggering kdc anti-dos code
        private static TimedQueue<KdcUser> cachedUsers=null;

        public static KdcUser GetCachedUser()
        {
            if (cachedUsers==null)
            {
                cachedUsers=new TimedQueue<KdcUser>();
                cachedUsers.MinimumReuseTime=new System.TimeSpan(0, 0, 0, 5);
                cachedUsers.MinimumQueueSize=5;
            }

            KdcUser user=cachedUsers.PopFront();

            if (user==null)
            {
                user=new KdcUser();
                user.CreateUser(false);
            }

            cachedUsers.PushBack(user);
            return user;
        }

        public static void EnsureUserHasPassport(KdcUser user)
        {
            if (user.Passport==null)
            {
                user.LinkPassport(null);
            }
        }

        // -- mainline tests for what a real client will do

        public static uint []Xbox360LaunchMachineOnlyPreauths=new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up for a machine-only request when it was first released."), TestCasePriority(1)]
        public void Xbox360LaunchMachineOnly()
        {
            TryRequest(PrepareAskdcMachineRequest(Xbox360LaunchMachineOnlyPreauths, AuthContext.ClientTypes.Xenon), true);
        }

        public static uint []Xbox360LaunchMachineAfterUserPreauths=new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up for a machine request after a user request when it was first released."), TestCasePriority(1)]
        public void Xbox360LaunchMachineAfterUser()
        {
            TryRequest(PrepareAskdcMachineRequest(Xbox360LaunchMachineAfterUserPreauths, AuthContext.ClientTypes.Xenon), true);
        }

        public static uint []Xbox360LaunchUserOnlyPreauths=new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up for a user-only request when it was first released."), TestCasePriority(1)]
        public void Xbox360LaunchUserOnly()
        {
            TryRequest(PrepareAskdcNormalUserRequest(Xbox360LaunchUserOnlyPreauths), true);
        }

        public static uint []Xbox360LaunchUserAfterUserPreauths=new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up for a user request after a user request when it was first released."), TestCasePriority(1)]
        public void Xbox360LaunchUserAfterUser()
        {
            TryRequest(PrepareAskdcNormalUserRequest(Xbox360LaunchUserAfterUserPreauths), true);
        }

        public static uint []Xbox360BucharestMachineOnlyPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA, PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up for a machine-only request starting with the Bucharest release in early 2011."), TestCasePriority(1)]
        public void Xbox360BucharestMachineOnly()
        {
            TryRequest(PrepareAskdcMachineRequest(Xbox360BucharestMachineOnlyPreauths, AuthContext.ClientTypes.Xenon), true);
        }

        public static uint []Xbox360BucharestMachineAfterUserPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA, PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up for a machine request after a user request starting with the Bucharest release in early 2011."), TestCasePriority(1)]
        public void Xbox360BucharestMachineAfterUser()
        {
            TryRequest(PrepareAskdcMachineRequest(Xbox360BucharestMachineAfterUserPreauths, AuthContext.ClientTypes.Xenon), true);
        }

        public static uint []Xbox360BucharestUserOnlyPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA, PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up for a user-only request starting with the Bucharest release in early 2011."), TestCasePriority(1)]
        public void Xbox360BucharestUserOnly()
        {
            TryRequest(PrepareAskdcNormalUserRequest(Xbox360BucharestUserOnlyPreauths), true);
        }

        public static uint []Xbox360BucharestUserAfterUserPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA, PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up for a user request after a user request starting with the Bucharest release in early 2011."), TestCasePriority(1)]
        public void Xbox360BucharestUserAfterUser()
        {
            TryRequest(PrepareAskdcNormalUserRequest(Xbox360BucharestUserAfterUserPreauths), true);
        }

        //Note that madrid also sends user and machine requests that are identical to xbox360 launch in addition to these.
        //Madrid will also send user requests firsts, so they will always contain a compound identity.  Technically the first will be after a machine, but after a machine and after a user are for all practical purposes the same thing.
        public static uint []Xbox360MadridPassportUserPreauths=new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY};
        [TestCase, Description("Preauths the Xbox360 sent up for a user request after a user request starting with the Madrid release in early 2011."), TestCasePriority(1)]
        public void Xbox360MadridPassportUser()
        {
            TryRequest(PrepareAskdcNormalUserRequest(Xbox360MadridPassportUserPreauths, true), true);
        }

        //Note that panorama user requests cannot occur past the first request in the chain.
        public static uint []PanoramaLaunchUserOnlyPreauths=new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Panorama client sent up when it was first released."), TestCasePriority(1)]
        public void PanoramaLaunchUserOnly()
        {
            TryRequest(PrepareAskdcRawPassportUserRequest(PanoramaLaunchUserOnlyPreauths), true);
        }

        public static uint []PanoramaLaunchMachineOnlyPreauths=new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Panorama sent up for a machine-only request when it was first released."), TestCasePriority(1)]
        public void PanoramaLaunchMachineOnly()
        {
            TryRequest(PrepareAskdcMachineRequest(PanoramaLaunchMachineOnlyPreauths, AuthContext.ClientTypes.Panorama), true);
        }

        public static uint []PanoramaLaunchMachineAfterUserPreauths=new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Panorama sent up for a machine request after a user request when it was first released."), TestCasePriority(1)]
        public void PanoramaLaunchMachineAfterUser()
        {
            TryRequest(PrepareAskdcMachineRequest(PanoramaLaunchMachineAfterUserPreauths, AuthContext.ClientTypes.Panorama), true);
        }

        // -- other tests

        [TestCase, Description("Preauths the Xbox360 sent up for a machine-only request when it was first released, reversed."), TestCasePriority(2)]
        public void Xbox360LaunchMachineOnlyReversed()
        {
            TryRequest(PrepareAskdcMachineRequest(ReverseArray(Xbox360LaunchMachineOnlyPreauths), AuthContext.ClientTypes.Xenon), true);
        }

        [TestCase, Description("Preauths the Xbox360 sent up for a machine request after a user request when it was first released, reversed."), TestCasePriority(2)]
        public void Xbox360LaunchMachineAfterUserReversed()
        {
            TryRequest(PrepareAskdcMachineRequest(ReverseArray(Xbox360LaunchMachineAfterUserPreauths), AuthContext.ClientTypes.Xenon), true);
        }

        [TestCase, Description("Preauths the Xbox360 sent up for a user-only request when it was first released, reversed."), TestCasePriority(2)]
        public void Xbox360LaunchUserOnlyReversed()
        {
            TryRequest(PrepareAskdcNormalUserRequest(ReverseArray(Xbox360LaunchUserOnlyPreauths)), true);
        }

        [TestCase, Description("Preauths the Xbox360 sent up for a user request after a user request when it was first released, reversed."), TestCasePriority(2)]
        public void Xbox360LaunchUserAfterUserReversed()
        {
            TryRequest(PrepareAskdcNormalUserRequest(ReverseArray(Xbox360LaunchUserAfterUserPreauths)), true);
        }

        [TestCase, Description("Preauths the Xbox360 sent up for a machine-only request starting with the Bucharest release in early 2011, reversed."), TestCasePriority(2)]
        public void Xbox360BucharestMachineOnlyReversed()
        {
            TryRequest(PrepareAskdcMachineRequest(ReverseArray(Xbox360BucharestMachineOnlyPreauths), AuthContext.ClientTypes.Xenon), true);
        }

        [TestCase, Description("Preauths the Xbox360 sent up for a machine request after a user request starting with the Bucharest release in early 2011, reversed."), TestCasePriority(2)]
        public void Xbox360BucharestMachineAfterUserReversed()
        {
            TryRequest(PrepareAskdcMachineRequest(ReverseArray(Xbox360BucharestMachineAfterUserPreauths), AuthContext.ClientTypes.Xenon), true);
        }

        [TestCase, Description("Preauths the Xbox360 sent up for a user-only request starting with the Bucharest release in early 2011, reversed."), TestCasePriority(2)]
        public void Xbox360BucharestUserOnlyReversed()
        {
            TryRequest(PrepareAskdcNormalUserRequest(ReverseArray(Xbox360BucharestUserOnlyPreauths)), true);
        }

        [TestCase, Description("Preauths the Xbox360 sent up for a user request after a user request starting with the Bucharest release in early 2011, reversed."), TestCasePriority(2)]
        public void Xbox360BucharestUserAfterUserReversed()
        {
            TryRequest(PrepareAskdcNormalUserRequest(ReverseArray(Xbox360BucharestUserAfterUserPreauths)), true);
        }

        [TestCase, Description("Preauths the Xbox360 sent up for a user request after a user request starting with the Madrid release in early 2011, reversed."), TestCasePriority(2)]
        public void Xbox360MadridPassportUserReversed()
        {
            TryRequest(PrepareAskdcNormalUserRequest(ReverseArray(Xbox360MadridPassportUserPreauths), true), true);
        }

        [TestCase, Description("Preauths the Panorama client sent up when it was first released, reversed."), TestCasePriority(2)]
        public void PanoramaLaunchUserOnlyReversed()
        {
            TryRequest(PrepareAskdcRawPassportUserRequest(ReverseArray(PanoramaLaunchUserOnlyPreauths)), true);
        }

        [TestCase, Description("Preauths the Panorama sent up for a machine-only request when it was first released, reversed."), TestCasePriority(2)]
        public void PanoramaLaunchMachineOnlyReversed()
        {
            TryRequest(PrepareAskdcMachineRequest(ReverseArray(PanoramaLaunchMachineOnlyPreauths), AuthContext.ClientTypes.Panorama), true);
        }

        [TestCase, Description("Preauths the Panorama sent up for a machine request after a user request when it was first released, reversed."), TestCasePriority(2)]
        public void PanoramaLaunchMachineAfterUserReversed()
        {
            TryRequest(PrepareAskdcMachineRequest(ReverseArray(PanoramaLaunchMachineAfterUserPreauths), AuthContext.ClientTypes.Panorama), true);
        }

        //

        [TestGroup, Description("Tests that hit the standard askdc whitelist."), TestCasePriority(2)]
        public class NormalWhitelist: TestNode
        {
            [TestCase, Description("Try with and without the optional preauths.")]
            [CompoundCase("Minimum", new uint[]{}, false)]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX}, false)]
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION}, false)]
            [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA}, false)]
            [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY}, true)] //note that askdc requires a compound identity preauth and a machine identity present in the authdata.  this will make it through the whitelist but will later be rejected(ignored) because it has no machine identity.
            [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY}, false)]
            public void OptionalPreauthsMachine(TestNode self)
            {
                uint []optionalPreauths=(uint[])self.MyValues[0];
                bool expectTimeout=(bool)self.MyValues[1];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP}, optionalPreauths);

                TryRequest(PrepareAskdcMachineRequest(
                    preauths,
                    AuthContext.ClientTypes.Xenon),
                    !expectTimeout);
            }

            [TestCase, Description("Try with and without the optional preauths.")]
            [CompoundCase("Minimum", new uint[]{}, false)]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX}, false)]
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION}, false)]
            [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA}, false)]
            [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY}, true)] //note that askdc requires a compound identity preauth and a machine identity present in the authdata.  this will make it through the whitelist but will later be rejected(ignored) because it has no machine identity.
            [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY}, false)]
            public void OptionalPreauthsUser(TestNode self)
            {
                uint []optionalPreauths=(uint[])self.MyValues[0];
                bool expectTimeout=(bool)self.MyValues[1];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP}, optionalPreauths);

                TryRequest(PrepareAskdcNormalUserRequest(
                    preauths),
                    !expectTimeout);
            }

            [TestCase, Description("Include preauths that are not allowed."), AsyncGroup(2, 2), AsyncThreadDelay(100), AsyncThreadCount(20)]
            [CompoundCase("KRB5_PADATA_NONE", new uint[]{PreAuthType.KRB5_PADATA_NONE})]
            [CompoundCase("KRB5_PADATA_TGS_REQ", new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ})]
            [CompoundCase("KRB5_PADATA_ENC_TIMESTAMP", new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP})]
            [CompoundCase("KRB5_PADATA_PW_SALT", new uint[]{PreAuthType.KRB5_PADATA_PW_SALT})]
            [CompoundCase("KRB5_PADATA_ENC_UNIX_TIME", new uint[]{PreAuthType.KRB5_PADATA_ENC_UNIX_TIME})]
            [CompoundCase("KRB5_PADATA_ENC_SANDIA_SECURID", new uint[]{PreAuthType.KRB5_PADATA_ENC_SANDIA_SECURID})]
            [CompoundCase("KRB5_PADATA_SESAME", new uint[]{PreAuthType.KRB5_PADATA_SESAME})]
            [CompoundCase("KRB5_PADATA_OSF_DCE", new uint[]{PreAuthType.KRB5_PADATA_OSF_DCE})]
            [CompoundCase("KRB5_CYBERSAFE_SECUREID", new uint[]{PreAuthType.KRB5_CYBERSAFE_SECUREID})]
            [CompoundCase("KRB5_PADATA_AFS3_SALT", new uint[]{PreAuthType.KRB5_PADATA_AFS3_SALT})]
            [CompoundCase("KRB5_PADATA_ETYPE_INFO", new uint[]{PreAuthType.KRB5_PADATA_ETYPE_INFO})]
            [CompoundCase("KRB5_PADATA_SAM_CHALLENGE", new uint[]{PreAuthType.KRB5_PADATA_SAM_CHALLENGE})]
            [CompoundCase("KRB5_PADATA_SAM_RESPONSE", new uint[]{PreAuthType.KRB5_PADATA_SAM_RESPONSE})]
            [CompoundCase("KRB5_PADATA_PK_AS_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REQ})]
            [CompoundCase("KRB5_PADATA_PK_AS_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REP})]
            [CompoundCase("KRB5_PADATA_PK_AS_SIGN", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_SIGN})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REQ})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REP})]
            [CompoundCase("KRB5_PADATA_REFERRAL_INFO", new uint[]{PreAuthType.KRB5_PADATA_REFERRAL_INFO})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_S4U", new uint[]{PreAuthType.KRB5_PADATA_S4U})]
            [CompoundCase("KRB5_PADATA_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_CLIENT_VERSION})]
            [CompoundCase("KRB5_PADATA_XBOX_SERVICE_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XBOX_SERVICE_REQUEST})]
            [CompoundCase("KRB5_PADATA_XBOX_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_XENON_MAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST2", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2})]
            [CompoundCase("KRB5_PADATA_PC_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST3", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3})]
            [CompoundCase("KRB5_PADATA_XENON_MAC_REQUEST2", new uint[]{PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST2})]
            public void NotAllowedPreauths(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP}, extraPreauths);

                TryRequest(PrepareAskdcMachineRequest(
                    preauths,
                    AuthContext.ClientTypes.Xenon),
                    false);
            }

            [TestCase, Description("Include a preauth twice."), AsyncGroup(2, 2), AsyncThreadDelay(200), AsyncThreadCount(20)]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
            [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA, PreAuthType.KRB5_PADATA_XBOX_PPA})]
            [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION, PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY})] //note that askdc requires compound identity along with this one
            [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY, PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY})]
            [CompoundCase("KRB5_PADATA_ENC_TIMESTAMP", new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP})]
            public void DuplicatePreauth(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP}, extraPreauths);

                TryRequest(PrepareAskdcMachineRequest(
                    preauths,
                    AuthContext.ClientTypes.Xenon),
                    false);
            }

            [TestCase, Description("Include very large-numbered preauths."), TestCasePriority(2), AsyncGroup(3)]
            public void LargePreauthNumber()
            {
                TryRequest(PrepareAskdcMachineRequest(new uint[]{
                    PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                    0x7fffffff}, //note that asn encoded integers actually have a range far more massive than a 32-bit value, but the automatic preauth helper test stuff doesn't support that.
                    AuthContext.ClientTypes.Xenon),
                    false);
            }
        };

        [TestGroup, Description("Tests that his the raw passport user whitelist."), TestCasePriority(2), AsyncGroup(0)]
        public class RawPassportWhitelist: TestNode
        {
            [TestCase, Description("Try with and without the optional preauths.")]
            [CompoundCase("Minimum", new uint[]{})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            public void OptionalPreauths(TestNode self)
            {
                uint []optionalPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION}, optionalPreauths);

                TryRequest(PrepareAskdcRawPassportUserRequest(
                    preauths),
                    true);
            }

            [TestCase, Description("Include preauths that are not allowed."), AsyncGroup(2, 2), AsyncThreadDelay(250), AsyncThreadCount(4)]
            [CompoundCase("KRB5_PADATA_NONE", new uint[]{PreAuthType.KRB5_PADATA_NONE})]
            [CompoundCase("KRB5_PADATA_TGS_REQ", new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ})]
            [CompoundCase("KRB5_PADATA_ENC_TIMESTAMP", new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP})]
            [CompoundCase("KRB5_PADATA_PW_SALT", new uint[]{PreAuthType.KRB5_PADATA_PW_SALT})]
            [CompoundCase("KRB5_PADATA_ENC_UNIX_TIME", new uint[]{PreAuthType.KRB5_PADATA_ENC_UNIX_TIME})]
            [CompoundCase("KRB5_PADATA_ENC_SANDIA_SECURID", new uint[]{PreAuthType.KRB5_PADATA_ENC_SANDIA_SECURID})]
            [CompoundCase("KRB5_PADATA_SESAME", new uint[]{PreAuthType.KRB5_PADATA_SESAME})]
            [CompoundCase("KRB5_PADATA_OSF_DCE", new uint[]{PreAuthType.KRB5_PADATA_OSF_DCE})]
            [CompoundCase("KRB5_CYBERSAFE_SECUREID", new uint[]{PreAuthType.KRB5_CYBERSAFE_SECUREID})]
            [CompoundCase("KRB5_PADATA_AFS3_SALT", new uint[]{PreAuthType.KRB5_PADATA_AFS3_SALT})]
            [CompoundCase("KRB5_PADATA_ETYPE_INFO", new uint[]{PreAuthType.KRB5_PADATA_ETYPE_INFO})]
            [CompoundCase("KRB5_PADATA_SAM_CHALLENGE", new uint[]{PreAuthType.KRB5_PADATA_SAM_CHALLENGE})]
            [CompoundCase("KRB5_PADATA_SAM_RESPONSE", new uint[]{PreAuthType.KRB5_PADATA_SAM_RESPONSE})]
            [CompoundCase("KRB5_PADATA_PK_AS_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REQ})]
            [CompoundCase("KRB5_PADATA_PK_AS_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REP})]
            [CompoundCase("KRB5_PADATA_PK_AS_SIGN", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_SIGN})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REQ})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REP})]
            [CompoundCase("KRB5_PADATA_REFERRAL_INFO", new uint[]{PreAuthType.KRB5_PADATA_REFERRAL_INFO})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_S4U", new uint[]{PreAuthType.KRB5_PADATA_S4U})]
            [CompoundCase("KRB5_PADATA_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_CLIENT_VERSION})]
            [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY})]
            [CompoundCase("KRB5_PADATA_XBOX_SERVICE_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XBOX_SERVICE_REQUEST})]
            [CompoundCase("KRB5_PADATA_XBOX_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA})]
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
            [CompoundCase("KRB5_PADATA_XENON_MAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST2", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2})]
            [CompoundCase("KRB5_PADATA_PC_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST3", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3})]
            [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION})]
            [CompoundCase("KRB5_PADATA_XENON_MAC_REQUEST2", new uint[]{PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST2})]
            public void NotAllowedPreauths(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION}, extraPreauths);

                TryRequest(PrepareAskdcRawPassportUserRequest(
                    preauths),
                    false);
            }

            [TestCase, Description("Include a preauth twice."), AsyncGroup(2, 2), AsyncThreadDelay(200), AsyncThreadCount(20)]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            [CompoundCase("KRB5_PADATA_ENC_TIMESTAMP", new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP})]
            [CompoundCase("KRB5_PADATA_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION})]
            public void DuplicatePreauth(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION}, extraPreauths);

                TryRequest(PrepareAskdcRawPassportUserRequest(
                    preauths),
                    false);
            }

            [TestCase, Description("Include very large-numbered preauths."), TestCasePriority(2), AsyncGroup(3)]
            public void LargePreauthNumber()
            {
                TryRequest(PrepareAskdcRawPassportUserRequest(new uint[]{
                    PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                    PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION,
                    0x7fffffff}), //note that asn encoded integers actually have a range far more massive than a 32-bit value, but the automatic preauth helper test stuff doesn't support that.
                    false);
            }
        };

        [TestCase, Description("Send just the echo preauth"), TestCasePriority(2)]
        public void JustEcho()
        {
            TryRequest(PrepareAskdcMachineRequest(
                new uint[]{PreAuthType.KRB5_PADATA_XBOX_ECHO},
                AuthContext.ClientTypes.Xenon),
                false);
        }

        [TestCase, Description("Send no preauths."), TestCasePriority(2)]
        public void Nothing()
        {
            TryRequest(PrepareAskdcMachineRequest(
                new uint[0],
                AuthContext.ClientTypes.Xenon),
                false);
        }

        [TestCase, Description("Send only the optional preauths, not any required one."), TestCasePriority(2), AsyncGroup(3), AsyncThreadDelay(100)]
        [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
        [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
        [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA})]
        [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION})]
        [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY})]
        [CompoundCase("KRB5_PADATA_XENON_PPA", new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA})]
        public void OptionalPreauthsOnly(TestNode self)
        {
            uint []optionalPreauths=(uint[])self.MyValues[0];

            TryRequest(PrepareAskdcMachineRequest(
                optionalPreauths,
                AuthContext.ClientTypes.Xenon),
                false);
        }
    };
}; //namespace XkdcTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PreauthWhitelistXmacs.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    [TestGroup, Description("Tests for the preauth whitelist in xmacs."), AsyncThreadDelay(100)]
    public class PreauthWhitelistXmacs: TestNode
    {
        //expectSuccess: If bool then it expects success or timeout.  Else it's an int with the kerberos error to expected.
        public static void TryPreauthList(uint []preauths, object expectSuccess, AuthContext.ClientTypes clientType)
        {
            Global.RO.Debug("Preauths in request: "+StringUtils.MakeCommaSeparatedList(preauths));

            KdcClient client=new KdcClient(clientType);
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.PreauthsToGenerate=new System.Collections.Generic.LinkedList<int>();
            foreach (int pa in preauths)
            {
                client.XmacsRequest.Input.PreauthsToGenerate.AddLast((int)pa);
            }

            if (clientType==AuthContext.ClientTypes.Panorama)
            {
                bool isPc2=false;
                bool isPc1=false;
                foreach (uint pa in preauths)
                {
                    if (pa==PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION2)
                    {
                        isPc2=true;
                    }
                    else if (pa==PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION)
                    {
                        isPc1=true;
                    }
                }

                if (isPc2)
                {
                    client.XmacsRequest.Input.EncryptedPassport=GetCachedPassportUser().Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);
                }

                if (isPc1)
                {
                    client.XmacsRequest.Input.PlainPassport=GetCachedPassportUser().Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                }
            }

            if (expectSuccess==null || (expectSuccess is bool && (bool)expectSuccess==true)) //expect success
            {
                client.ExecuteXmacs(true);
            }
            else if (expectSuccess is bool && (bool)expectSuccess==false) //expect timeout
            {
                client.RetryLostPackets=false;
                try
                {
                    client.ExecuteXmacs(true);
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Request unexpectedly succeeded.");
            }
            else //expect kerberos error
            {
                int expectedKerbError=(int)expectSuccess;

                client.XmacsThrowOnKerberosError=false;
                client.ExecuteXmacs(true);

                if (client.XmacsError==null)
                {
                    throw new UnexpectedTestResultException("Request unexpectedly succeeded.");
                }

                ValueCheck.Test("Kerberos Error Returned", expectedKerbError, (int)client.XmacsError.ErrorCode.Int64);
            }
        }

        public static uint[] MergeArrays(uint []arr0, uint []arr1)
        {
            uint []newArr=new uint[arr0.Length+arr1.Length];
            System.Array.Copy(arr0, 0, newArr, 0, arr0.Length);
            System.Array.Copy(arr1, 0, newArr, arr0.Length, arr1.Length);
            return newArr;
        }

        public static uint[] ReverseArray(uint []arr)
        {
            uint []newArr=new uint[arr.Length];
            for (int i=0; i<arr.Length; ++i)
            {
                newArr[i]=arr[arr.Length-i-1];
            }
            return newArr;
        }

        //we keep a cache of users that we rotate through
        //we also limit their time-between-reuse to avoid triggering kdc anti-dos code
        private static TimedQueue<KdcUser> cachedUsers=null;

        public static KdcUser GetCachedPassportUser()
        {
            if (cachedUsers==null)
            {
                cachedUsers=new TimedQueue<KdcUser>();
                cachedUsers.MinimumReuseTime=new System.TimeSpan(0, 0, 0, 5);
                cachedUsers.MinimumQueueSize=5;
            }

            KdcUser user=cachedUsers.PopFront();

            if (user==null)
            {
                user=new KdcUser();
                user.CreateUser(true);
            }

            cachedUsers.PushBack(user);
            return user;
        }

        // -- mainline tests for what a real client will do

        public static uint []Xbox360LaunchPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX};
        [TestCase, Description("Preauths the Xbox360 sent up when it was first released."), TestCasePriority(1)]
        public void Xbox360Launch()
        {
            TryPreauthList(Xbox360LaunchPreauths, true, AuthContext.ClientTypes.Xenon);
        }

        public static uint []Xbox360MadridPreauths=new uint[]{PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST2, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION};
        [TestCase, Description("Preauths the Xbox360 sent up starting with the Madrid release in late 2011."), TestCasePriority(1)]
        public void Xbox360Madrid()
        {
            TryPreauthList(Xbox360MadridPreauths, true, AuthContext.ClientTypes.Xenon);
        }

        public static uint []PanoramaLaunchPreauths=new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION, PreAuthType.KRB5_PADATA_ENC_TIMESTAMP};
        [TestCase, Description("Preauths the panorama client sent up when it was first released."), TestCasePriority(1)]
        public void PanoramaLaunch()
        {
            TryPreauthList(PanoramaLaunchPreauths, true, AuthContext.ClientTypes.Panorama);
        }

        // -- other tests

        [TestCase, Description("Preauths the Xbox360 sent up when it was first released, reversed."), TestCasePriority(2)]
        public void Xbox360LaunchReversed()
        {
            TryPreauthList(ReverseArray(Xbox360LaunchPreauths), true, AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Preauths the Xbox360 sent up starting with the Madrid release in late 2011, reversed."), TestCasePriority(2)]
        public void Xbox360MadridReversed()
        {
            TryPreauthList(ReverseArray(Xbox360MadridPreauths), true, AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Preauths the panorama client sent up when it was first released, reversed."), TestCasePriority(2)]
        public void PanoramaLaunchReversed()
        {
            TryPreauthList(ReverseArray(PanoramaLaunchPreauths), true, AuthContext.ClientTypes.Panorama);
        }

        [TestGroup, TestCasePriority(2)]
        [CompoundCase("Mac1", 1)]
        [CompoundCase("Mac2", 2)]
        public class Xbox360: TestNode
        {
            public override void PreRun()
            {
                CreateContextData();
                if ((int)MyValues[0]==1)
                {
                    SetContextData("MacPreauth", PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST);
                }
                else
                {
                    SetContextData("MacPreauth", PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST2);
                }
            }

            //

            [TestCase, Description("Try with and without the optional preauths.")]
            [CompoundCase("Minimum", new uint[]{})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
            [CompoundCase("Both", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            public void OptionalPreauths(TestNode self)
            {
                uint []optionalPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, (uint)GetContextData("MacPreauth")}, optionalPreauths);

                TryPreauthList(preauths, true, AuthContext.ClientTypes.Xenon);
            }

            [TestCase, Description("Include preauths that are not allowed."), AsyncGroup(2, 2), AsyncThreadDelay(100), AsyncThreadCount(20)]
            [CompoundCase("KRB5_PADATA_NONE", new uint[]{PreAuthType.KRB5_PADATA_NONE})]
            [CompoundCase("KRB5_PADATA_TGS_REQ", new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ})]
            [CompoundCase("KRB5_PADATA_PW_SALT", new uint[]{PreAuthType.KRB5_PADATA_PW_SALT})]
            [CompoundCase("KRB5_PADATA_ENC_UNIX_TIME", new uint[]{PreAuthType.KRB5_PADATA_ENC_UNIX_TIME})]
            [CompoundCase("KRB5_PADATA_ENC_SANDIA_SECURID", new uint[]{PreAuthType.KRB5_PADATA_ENC_SANDIA_SECURID})]
            [CompoundCase("KRB5_PADATA_SESAME", new uint[]{PreAuthType.KRB5_PADATA_SESAME})]
            [CompoundCase("KRB5_PADATA_OSF_DCE", new uint[]{PreAuthType.KRB5_PADATA_OSF_DCE})]
            [CompoundCase("KRB5_CYBERSAFE_SECUREID", new uint[]{PreAuthType.KRB5_CYBERSAFE_SECUREID})]
            [CompoundCase("KRB5_PADATA_AFS3_SALT", new uint[]{PreAuthType.KRB5_PADATA_AFS3_SALT})]
            [CompoundCase("KRB5_PADATA_ETYPE_INFO", new uint[]{PreAuthType.KRB5_PADATA_ETYPE_INFO})]
            [CompoundCase("KRB5_PADATA_SAM_CHALLENGE", new uint[]{PreAuthType.KRB5_PADATA_SAM_CHALLENGE})]
            [CompoundCase("KRB5_PADATA_SAM_RESPONSE", new uint[]{PreAuthType.KRB5_PADATA_SAM_RESPONSE})]
            [CompoundCase("KRB5_PADATA_PK_AS_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REQ})]
            [CompoundCase("KRB5_PADATA_PK_AS_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REP})]
            [CompoundCase("KRB5_PADATA_PK_AS_SIGN", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_SIGN})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REQ})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REP})]
            [CompoundCase("KRB5_PADATA_REFERRAL_INFO", new uint[]{PreAuthType.KRB5_PADATA_REFERRAL_INFO})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_S4U", new uint[]{PreAuthType.KRB5_PADATA_S4U})]
            [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY})]
            [CompoundCase("KRB5_PADATA_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_CLIENT_VERSION})]
            [CompoundCase("KRB5_PADATA_XBOX_SERVICE_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XBOX_SERVICE_REQUEST})]
            [CompoundCase("KRB5_PADATA_XBOX_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA})]
            [CompoundCase("KRB5_PADATA_XBOX_ECHO", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ECHO})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST2", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2})]
            [CompoundCase("KRB5_PADATA_PC_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST3", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3})]
            [CompoundCase("KRB5_PADATA_XENON_PPA", new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA})]
            [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION})]
            public void NotAllowedPreauths(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, (uint)GetContextData("MacPreauth")}, extraPreauths);

                TryPreauthList(preauths, false, AuthContext.ClientTypes.Xenon);
            }

            [TestCase, Description("Include a preauth twice.")]
            [CompoundCase("KRB5_PADATA_ENC_TIMESTAMP", new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP})]
            [CompoundCase("Mac", new uint[]{0})] //sentinal value replaced by test
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX, PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION, PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
            public void DuplicatePreauth(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                for (int i=0; i<extraPreauths.Length; ++i)
                {
                    if (extraPreauths[i]==0)
                    {
                        extraPreauths[i]=(uint)GetContextData("MacPreauth");
                    }
                }

                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, (uint)GetContextData("MacPreauth")}, extraPreauths);

                TryPreauthList(preauths, false, AuthContext.ClientTypes.Xenon);
            }

            [TestCase, Description("Don't include encrypted timestamp which is required.")]
            public void NoTimestampPreauth()
            {
                TryPreauthList(new uint[]{
                    (uint)GetContextData("MacPreauth")},
                    false,
                    AuthContext.ClientTypes.Xenon);
            }
        };

        [TestGroup, TestCasePriority(2)]
        public class Panorama1: TestNode
        {
            //NOTE: There are no optional preauths for panorama.

            [TestCase, Description("Include preauths that are not allowed."), AsyncGroup(2, 2), AsyncThreadDelay(500), AsyncThreadCount(8)]
            [CompoundCase("KRB5_PADATA_NONE", new uint[]{PreAuthType.KRB5_PADATA_NONE})]
            [CompoundCase("KRB5_PADATA_AP_REQ", new uint[]{PreAuthType.KRB5_PADATA_AP_REQ})]
            [CompoundCase("KRB5_PADATA_TGS_REQ", new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ})]
            [CompoundCase("KRB5_PADATA_PW_SALT", new uint[]{PreAuthType.KRB5_PADATA_PW_SALT})]
            [CompoundCase("KRB5_PADATA_ENC_UNIX_TIME", new uint[]{PreAuthType.KRB5_PADATA_ENC_UNIX_TIME})]
            [CompoundCase("KRB5_PADATA_ENC_SANDIA_SECURID", new uint[]{PreAuthType.KRB5_PADATA_ENC_SANDIA_SECURID})]
            [CompoundCase("KRB5_PADATA_SESAME", new uint[]{PreAuthType.KRB5_PADATA_SESAME})]
            [CompoundCase("KRB5_PADATA_OSF_DCE", new uint[]{PreAuthType.KRB5_PADATA_OSF_DCE})]
            [CompoundCase("KRB5_CYBERSAFE_SECUREID", new uint[]{PreAuthType.KRB5_CYBERSAFE_SECUREID})]
            [CompoundCase("KRB5_PADATA_AFS3_SALT", new uint[]{PreAuthType.KRB5_PADATA_AFS3_SALT})]
            [CompoundCase("KRB5_PADATA_ETYPE_INFO", new uint[]{PreAuthType.KRB5_PADATA_ETYPE_INFO})]
            [CompoundCase("KRB5_PADATA_SAM_CHALLENGE", new uint[]{PreAuthType.KRB5_PADATA_SAM_CHALLENGE})]
            [CompoundCase("KRB5_PADATA_SAM_RESPONSE", new uint[]{PreAuthType.KRB5_PADATA_SAM_RESPONSE})]
            [CompoundCase("KRB5_PADATA_PK_AS_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REQ})]
            [CompoundCase("KRB5_PADATA_PK_AS_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REP})]
            [CompoundCase("KRB5_PADATA_PK_AS_SIGN", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_SIGN})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REQ})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REP})]
            [CompoundCase("KRB5_PADATA_REFERRAL_INFO", new uint[]{PreAuthType.KRB5_PADATA_REFERRAL_INFO})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_S4U", new uint[]{PreAuthType.KRB5_PADATA_S4U})]
            [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY})]
            [CompoundCase("KRB5_PADATA_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_CLIENT_VERSION})]
            [CompoundCase("KRB5_PADATA_XBOX_SERVICE_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XBOX_SERVICE_REQUEST})]
            [CompoundCase("KRB5_PADATA_XBOX_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA})]
            [CompoundCase("KRB5_PADATA_XBOX_ECHO", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ECHO})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST2", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2})]
            [CompoundCase("KRB5_PADATA_PC_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST3", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3})]
            [CompoundCase("KRB5_PADATA_XENON_PPA", new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA})]
            [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})] //optional for xbox but not for pc
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})] //optional for xbox but not for pc
            public void NotAllowedPreauths(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION}, extraPreauths);

                TryPreauthList(preauths, false, AuthContext.ClientTypes.Panorama);
            }

            [TestCase, Description("Include a preauth twice.")]
            [CompoundCase("KRB5_PADATA_ENC_TIMESTAMP", new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP})]
            [CompoundCase("KRB5_PADATA_PC_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION})]
            public void DuplicatePreauth(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION}, extraPreauths);

                TryPreauthList(preauths, false, AuthContext.ClientTypes.Panorama);
            }

            [TestCase, Description("Don't include encrypted timestamp which is required.")]
            public void NoTimestampPreauth()
            {
                TryPreauthList(new uint[]{
                    PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION},
                    false,
                    AuthContext.ClientTypes.Panorama);
            }
        };

        [TestGroup, TestCasePriority(2)]
        public class Panorama2: TestNode
        {
            //NOTE: There are no optional preauths for panorama.

            [TestCase, Description("Include preauths that are not allowed."), AsyncGroup(2, 2), AsyncThreadDelay(500), AsyncThreadCount(8)]
            [CompoundCase("KRB5_PADATA_NONE", new uint[]{PreAuthType.KRB5_PADATA_NONE})]
            [CompoundCase("KRB5_PADATA_AP_REQ", new uint[]{PreAuthType.KRB5_PADATA_AP_REQ})]
            [CompoundCase("KRB5_PADATA_TGS_REQ", new uint[]{PreAuthType.KRB5_PADATA_TGS_REQ})]
            [CompoundCase("KRB5_PADATA_PW_SALT", new uint[]{PreAuthType.KRB5_PADATA_PW_SALT})]
            [CompoundCase("KRB5_PADATA_ENC_UNIX_TIME", new uint[]{PreAuthType.KRB5_PADATA_ENC_UNIX_TIME})]
            [CompoundCase("KRB5_PADATA_ENC_SANDIA_SECURID", new uint[]{PreAuthType.KRB5_PADATA_ENC_SANDIA_SECURID})]
            [CompoundCase("KRB5_PADATA_SESAME", new uint[]{PreAuthType.KRB5_PADATA_SESAME})]
            [CompoundCase("KRB5_PADATA_OSF_DCE", new uint[]{PreAuthType.KRB5_PADATA_OSF_DCE})]
            [CompoundCase("KRB5_CYBERSAFE_SECUREID", new uint[]{PreAuthType.KRB5_CYBERSAFE_SECUREID})]
            [CompoundCase("KRB5_PADATA_AFS3_SALT", new uint[]{PreAuthType.KRB5_PADATA_AFS3_SALT})]
            [CompoundCase("KRB5_PADATA_ETYPE_INFO", new uint[]{PreAuthType.KRB5_PADATA_ETYPE_INFO})]
            [CompoundCase("KRB5_PADATA_SAM_CHALLENGE", new uint[]{PreAuthType.KRB5_PADATA_SAM_CHALLENGE})]
            [CompoundCase("KRB5_PADATA_SAM_RESPONSE", new uint[]{PreAuthType.KRB5_PADATA_SAM_RESPONSE})]
            [CompoundCase("KRB5_PADATA_PK_AS_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REQ})]
            [CompoundCase("KRB5_PADATA_PK_AS_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_REP})]
            [CompoundCase("KRB5_PADATA_PK_AS_SIGN", new uint[]{PreAuthType.KRB5_PADATA_PK_AS_SIGN})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REQ", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REQ})]
            [CompoundCase("KRB5_PADATA_PK_KEY_REP", new uint[]{PreAuthType.KRB5_PADATA_PK_KEY_REP})]
            [CompoundCase("KRB5_PADATA_REFERRAL_INFO", new uint[]{PreAuthType.KRB5_PADATA_REFERRAL_INFO})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST})]
            [CompoundCase("KRB5_PADATA_S4U", new uint[]{PreAuthType.KRB5_PADATA_S4U})]
            [CompoundCase("KRB5_PADATA_COMPOUND_IDENTITY", new uint[]{PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY})]
            [CompoundCase("KRB5_PADATA_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_CLIENT_VERSION})]
            [CompoundCase("KRB5_PADATA_XBOX_SERVICE_REQUEST", new uint[]{PreAuthType.KRB5_PADATA_XBOX_SERVICE_REQUEST})]
            [CompoundCase("KRB5_PADATA_XBOX_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_XBOX_PPA", new uint[]{PreAuthType.KRB5_PADATA_XBOX_PPA})]
            [CompoundCase("KRB5_PADATA_XBOX_ECHO", new uint[]{PreAuthType.KRB5_PADATA_XBOX_ECHO})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST2", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2})]
            [CompoundCase("KRB5_PADATA_PC_ACCOUNT_CREATION", new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION})]
            [CompoundCase("KRB5_PADATA_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION})]
            [CompoundCase("KRB5_PADATA_XENON_SERVICE_REQUEST3", new uint[]{PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3})]
            [CompoundCase("KRB5_PADATA_XENON_PPA", new uint[]{PreAuthType.KRB5_PADATA_XENON_PPA})]
            [CompoundCase("KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION", new uint[]{PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION})]
            [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})] //optional for xbox but not for pc
            [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})] //optional for xbox but not for pc
            public void NotAllowedPreauths(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION2}, extraPreauths);

                TryPreauthList(preauths, false, AuthContext.ClientTypes.Panorama);
            }

            [TestCase, Description("Include a preauth twice.")]
            [CompoundCase("KRB5_PADATA_ENC_TIMESTAMP", new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP})]
            [CompoundCase("KRB5_PADATA_PC_ACCOUNT_CREATION2", new uint[]{PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION2})]
            public void DuplicatePreauth(TestNode self)
            {
                uint []extraPreauths=(uint[])self.MyValues[0];
                uint []preauths=MergeArrays(new uint[]{PreAuthType.KRB5_PADATA_ENC_TIMESTAMP, PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION2}, extraPreauths);

                TryPreauthList(preauths, false, AuthContext.ClientTypes.Panorama);
            }

            [TestCase, Description("Don't include encrypted timestamp which is required.")]
            public void NoTimestampPreauth()
            {
                TryPreauthList(new uint[]{
                    PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION2},
                    false,
                    AuthContext.ClientTypes.Panorama);
            }
        };

        [TestCase, Description("Include both mac preauths.  Most network hardware will block this so it will fail the same way as the few places that let it through."), TestCasePriority(2), AsyncGroup(3)]
        public void BothXbox360Macs()
        {
            TryPreauthList(new uint[]{
                PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST,
                PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST2},
                false,
                AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Send no preauths."), TestCasePriority(2), AsyncGroup(3)]
        public void Nothing()
        {
            TryPreauthList(new uint[]{},
                KerbErrCode.KDC_ERR_POLICY, //if xmacs can't determine the client type it falls back to the xbox1 decom case
                AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Send only the optional preauths, not any required one."), TestCasePriority(2), AsyncGroup(3)]
        [CompoundCase("KRB5_PADATA_PAC_REQUEST_EX", new uint[]{PreAuthType.KRB5_PADATA_PAC_REQUEST_EX})]
        [CompoundCase("KRB5_PADATA_XBOX_CLIENT_VERSION", new uint[]{PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION})]
        public void OptionalPreauthsOnly(TestNode self)
        {
            uint []optionalPreauths=(uint[])self.MyValues[0];

            TryPreauthList(optionalPreauths, KerbErrCode.KDC_ERR_POLICY, AuthContext.ClientTypes.Xenon); //if xmacs can't determine the client type it falls back to the xbox1 decom case
        }

        [TestCase, Description("Don't include the required mac preauth."), TestCasePriority(2), AsyncGroup(3)]
        public void NoMac()
        {
            TryPreauthList(new uint[]{
                PreAuthType.KRB5_PADATA_ENC_TIMESTAMP},
                KerbErrCode.KDC_ERR_POLICY, //if xmacs can't determine the client type it falls back to the xbox1 decom case
                AuthContext.ClientTypes.Xenon);
        }

        [TestCase, Description("Include very large-numbered preauths."), TestCasePriority(2), AsyncGroup(3)]
        public void LargePreauthNumber()
        {
            TryPreauthList(new uint[]{
                PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST2,
                0x7fffffff}, //note that asn encoded integers actually have a range far more massive than a 32-bit value, but the automatic preauth helper test stuff doesn't support that.
                false,
                AuthContext.ClientTypes.Xenon);
        }
    }; //class PreauthXmacs
}; //namespace XkdcTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PanoramaXmacs2.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    [TestGroup, Description("Tests for the new xmacs preauth.  Might merge this with the other group later.")]
    public class PanoramaXmacs2: TestNode
    {
        public override void PreRun()
        {
            cachedUsers=new TimedQueue<KdcUser>();
            cachedUsers.MinimumReuseTime=new System.TimeSpan(0, 0, 1); //1 second between re-uses at least
            cachedVoucher=null;
        }

        //we will store a local cache of users to limitedly re-use so we don't have to spend a lot of time making new passports for every test
        private static TimedQueue<KdcUser> cachedUsers;
        public static KdcUser GetCachedUser()
        {
            KdcUser user=cachedUsers.PopFront();
            if (user==null)
            {
                user=new KdcUser();
                user.CreateUser(true);
            }

            cachedUsers.PushBack(user);
            return user;
        }

        //cached pc creation voucher
        private static string cachedVoucher;
        public static string GetCachedUnlimitedPcVoucher()
        {
            if (cachedVoucher==null)
            {
                cachedVoucher=TokendbWS.CreatePanoramaVoucher(-1);
                Global.RO.Debug("Created new unlimited use count PC voucher: "+cachedVoucher+"(Hash=0x"+Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(cachedVoucher))+")");
            }

            return cachedVoucher;
        }

        public static void VerifyBasics(XmacsGenericReplyOutput xmacsOutput)
        {
            //check key for obvious problems
            int zeroCount=0;
            for (int i=0; i<16; ++i)
            {
                if (xmacsOutput.MachineKey[i]==0)
                {
                    ++zeroCount;
                }
            }

            if (zeroCount>=3)
            {
                throw new UnexpectedTestResultException("Key returned from xmacs contains "+zeroCount+"/16 zero bytes.  Might be weak.");
            }

            //identity should be a pc identity
            ulong idMask=(xmacsOutput.MachineId&0xffff000000000000);
            ValueCheck.Test("Platform mask of returned machine puid", 0xfb00000000000000, idMask);
        }

        // --

        public enum MachineClass
        {
            Plain,
            Limited,
            SpecialTest,
            TitleActivation
        }

        public static string GetVoucherForMachineClass(MachineClass mc)
        {
            if (mc==MachineClass.Plain)
            {
                return GetCachedUnlimitedPcVoucher();
            }
            else if (mc==MachineClass.Limited)
            {
                return XmacsPCRequestInput.LIMITED_MACHINE_TOKEN;
            }
            else if (mc==MachineClass.SpecialTest)
            {
                return XmacsPCRequestInput.UNLIMITED_TEST_TOKEN;
            }
            else if (mc==MachineClass.TitleActivation)
            {
                return TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000); //offer is associated with title 0xC0FE0901, a special activation-configured title
            }
            else
            {
                throw new System.NotImplementedException(mc+" not handled.");
            }
        }

        [TestCase, Description("Simple mainline tests for different classes of pc machine creations.")]
        //                          type                          reset  cacheuser  expectactivationrow
        [CompoundCase("{0} Create", MachineClass.Plain,           false, true,      true)]
        [CompoundCase("{0} Reset",  MachineClass.Plain,           true,  true,      true)]
        [CompoundCase("{0} Create", MachineClass.Limited,         false, true,      false)]
        [CompoundCase("{0} Reset",  MachineClass.Limited,         true,  true,      false)]
        [CompoundCase("{0} Create", MachineClass.SpecialTest,     false, true,      true)]
        [CompoundCase("{0} Reset",  MachineClass.SpecialTest,     true,  true,      true)]
        [CompoundCase("{0} Create", MachineClass.TitleActivation, false, false,     true)]
        [CompoundCase("{0} Reset",  MachineClass.TitleActivation, true,  false,     true)]
        public void SimpleMainline(TestNode self)
        {
            MachineClass type=(MachineClass)self.MyValues[0];
            bool doReset=(bool)self.MyValues[1];
            bool allowCachedUser=(bool)self.MyValues[2];
            bool expectActivationRows=(bool)self.MyValues[3];

            //prepare user and voucher
            KdcUser user;
            if (allowCachedUser)
            {
                user=GetCachedUser();
            }
            else
            {
                user=new KdcUser();
                user.CreateUser(true);
            }

            string voucher=GetVoucherForMachineClass(type);

            //do create
            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            Global.RO.Debug("Sending create request.");
            client.ExecuteXmacs(true);
            VerifyBasics(client.XmacsOutput);

            //verify activation rows
            string queryMachine="select count(*) from t_machine_title_activations where bi_machine_puid=0x"+client.XmacsOutput.MachineId.ToString("X");
            int machineActivationRows=(int)UodbWS.ExecuteSQLScalar(queryMachine, client.XmacsOutput.MachineId);

            string queryUser="select count(*) from t_user_title_activations where bi_user_puid=0x"+user.UserID.ToString("X");
            int userActivationRows=(int)UodbWS.ExecuteSQLScalar(queryUser, user.UserID);

            if (expectActivationRows)
            {
                ValueCheck.TestGreaterThan("machineActivationRows", 0, machineActivationRows);
                ValueCheck.TestGreaterThan("userActivationRows", 0, userActivationRows);
            }
            else
            {
                ValueCheck.Test("machineActivationRows", 0, machineActivationRows);
                if (!allowCachedUser) //cached user may have activations added by other tests, so we won't check in this case
                {
                    ValueCheck.Test("userActivationRows", 0, userActivationRows);
                }
            }

            //do reset if specified
            if (doReset)
            {
                XmacsGenericReplyOutput originalOutput=client.XmacsOutput;

                client.CreateXmacsRequest();
                client.XmacsRequest.Input.SponsorToken=voucher;
                client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

                Global.RO.Debug("Sending reset request.");
                client.ExecuteXmacs(true);
                VerifyBasics(client.XmacsOutput);

                //verify our identity did not change but our key did
                ValueCheck.Test("Identity returned from xmacs reset", originalOutput.MachineId, client.XmacsOutput.MachineId);
                ValueCheck.TestDifferent("Key returned from xmacs reset", originalOutput.MachineKey, client.XmacsOutput.MachineKey);
            }
        }

        [TestCase, Description("AuthTime value in creation preauth is different than now.  Default settings allow a 5 minute window in either direction.")]
        [CompoundCase("-1 year",    -365*24*60, true)]
        [CompoundCase("-6 minutes", -6,         true)]
        [CompoundCase("-4 minutes", -4,         false)]
        [CompoundCase("now",        0,          false)]
        [CompoundCase("+4 minutes", 4,          false)]
        [CompoundCase("+6 minutes", 6,          true)]
        [CompoundCase("+1 year",    365*24*60,  true)]
        public void AuthTimeSkew(TestNode self)
        {
            int minutesToSkewAuthTimeBy=(int)self.MyValues[0];
            bool expectSkewError=(bool)self.MyValues[1];
            KdcUser user=GetCachedUser();
            string voucher=GetCachedUnlimitedPcVoucher();

            KdcClientPC client=new KdcClientPC();
            client.RetryLostPackets=false;
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            client.XmacsRequest.Input.GeneratePreauths();

            Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2> mac2=client.XmacsRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2>>(220);
            mac2.Data.EncryptedPart.AuthTime=(ulong)(System.DateTime.UtcNow+new System.TimeSpan(0, minutesToSkewAuthTimeBy, 0)).ToFileTimeUtc();
            mac2.Data.Encrypt();

            client.XmacsRequest.SetRequest();
            client.XmacsRequest.ConstructRequest();

            //execute it
            if (expectSkewError)
            {
                try
                {
                    client.ExecuteXmacs(false);
                }
                catch (KerberosErrorException kee)
                {
                    if ((int)kee.Error.ErrorCode.Int64==(int)KerbErrCode.KRB_AP_ERR_SKEW)
                    {
                        return; //error was the expected KRB_AP_ERR_SKEW
                    }

                    throw;
                }

                throw new UnexpectedTestResultException("Expected request to fail but it succeeded.");
            }
            else
            {
                client.ExecuteXmacs(false);
            }
        }

        [TestCase, Description("Passport ticket inside the encrypted blob is corrupt.")]
        public void PassportTicketCorrupt()
        {
            KdcUser user=GetCachedUser();
            string voucher=GetCachedUnlimitedPcVoucher();

            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            client.XmacsRequest.Input.EncryptedPassport=client.XmacsRequest.Input.EncryptedPassport.Clone(); //duplicate the bytes, else C# will just copy by ref and let us corrupt the bytes stored with the cached user
            for (int i=3; i<100; i+=5)
            {
                client.XmacsRequest.Input.EncryptedPassport.Bytes[i]=(byte)(~client.XmacsRequest.Input.EncryptedPassport.Bytes[i]);
            }

            Global.RO.Debug("Sending request.");
            try
            {
                client.RetryLostPackets=false;
                client.ExecuteXmacs(true);
                throw new UnexpectedTestResultException("Expected xmacs to ignore the request, but we got a response.");
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                //we expect this and only this
            }
        }

        [TestCase, Description("Passport ticket inside the encrypted blob has a weird size.")]
        [CompoundCase("0 bytes",         0,     null)]
        [CompoundCase("65535 bytes",     65535, null)]
        [CompoundCase("32767 bytes",     32767, null)]
        [CompoundCase("32768 bytes",     32768, null)]
        [CompoundCase("1 extra byte",    null,  1)]
        [CompoundCase("100 extra bytes", null,  100)]
        [CompoundCase("300 extra bytes", null,  300)]
        [CompoundCase("500 extra bytes", null,  500)]
        [CompoundCase("1 less byte",     null,  -1)]
        [CompoundCase("100 less bytes",  null,  -100)]
        public void PassportTicketSizeBad(TestNode self)
        {
            int ?newAbsoluteBytes=(self.MyValues[0]!=null?(int?)(int)self.MyValues[0]:(int?)null);
            int ?newRelativeBytes=(self.MyValues[1]!=null?(int?)(int)self.MyValues[1]:(int?)null);

            KdcUser user=GetCachedUser();
            string voucher=GetCachedUnlimitedPcVoucher();

            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            //muck around with the ticket bytes going into the input
            client.XmacsRequest.Input.EncryptedPassport=client.XmacsRequest.Input.EncryptedPassport.Clone(); //duplicate the bytes, else C# will just copy by ref and let us corrupt the bytes stored with the cached user
            int newByteCount=client.XmacsRequest.Input.EncryptedPassport.Bytes.Length;
            if (newAbsoluteBytes!=null)
            {
                newByteCount=(int)newAbsoluteBytes;
            }
            if (newRelativeBytes!=null)
            {
                newByteCount+=(int)newRelativeBytes;
            }
            System.Array.Resize(ref client.XmacsRequest.Input.EncryptedPassport.Bytes, newByteCount);

            //if the size is too big, the packet will be too big for udp and won't even make it to the KDC.  So cap the actual number of bytes in the ticket if it's over 1000 bytes, but leave the ticket length field set to the potentially larger number (which in this case will mismatch).
            client.XmacsRequest.Input.GeneratePreauths();

            Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2> mac2=client.XmacsRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2>>(220);
            if (mac2.Data.EncryptedPart.PassportTicket.Length>1000)
            {
                System.Array.Resize(ref mac2.Data.EncryptedPart.PassportTicket, 1000);
                mac2.Data.Encrypt();
            }

            client.XmacsRequest.SetRequest();
            client.XmacsRequest.ConstructRequest();

            Global.RO.Debug("Sending request.");
            bool validate=true;

            //note that due to some oddness with base64 to binary translation, it seems to be possible to mangle the last byte and still sometimes have a correct conversion.  so for the case of altering one byte, we won't actually fail if we get response.  We still want to send this request though for purposes of coverage.
            if (newAbsoluteBytes==null && System.Math.Abs((int)newRelativeBytes)==1)
            {
                validate=false;
            }

            try
            {
                client.RetryLostPackets=false;
                client.ExecuteXmacs(false);
                if (validate)
                {
                    throw new UnexpectedTestResultException("Expected xmacs to ignore the request, but we got a response.");
                }
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                //we expect this and only this
            }
        }

        [TestCase, Description("The wrong key is used to encrypt the encrypted part of the blob.  This is equivelent to having the data in the blob corrupted, since decryption will fail the same way.")]
        public void WrongKey()
        {
            KdcUser user=GetCachedUser();
            string voucher=GetCachedUnlimitedPcVoucher();

            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            client.XmacsRequest.Input.GeneratePreauths();

            Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2> mac2=client.XmacsRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2>>(220);
            mac2.Data.EncryptedPart.EncryptionKey=(byte[])mac2.Data.EncryptedPart.EncryptionKey.Clone();
            mac2.Data.EncryptedPart.EncryptionKey[3]=(byte)~mac2.Data.EncryptedPart.EncryptionKey[3];
            mac2.Data.EncryptedPart.Encrypt();
            mac2.Data.RepackEncryptedPartAndAllBytes();

            client.XmacsRequest.SetRequest();
            client.XmacsRequest.ConstructRequest();

            Global.RO.Debug("Sending request.");
            try
            {
                client.RetryLostPackets=false;
                client.ExecuteXmacs(false);
                throw new UnexpectedTestResultException("Expected xmacs to ignore the request, but we got a response.");
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                //we expect this and only this
            }
        }

        [TestCase, Description("The wrong passport site is used to get a passport ticket.  Xmacs should ignore the request.  NOTE: THIS WILL FAIL ON XBLOBS: Right now xuacs and kdc share the same passport site on xblobs, and so this works when it shouldn't.")]
        public void WrongPassportSite()
        {
            KdcUser user=GetCachedUser();
            string voucher=GetCachedUnlimitedPcVoucher();

            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);

            Global.RO.Debug("Sending request.");
            try
            {
                client.RetryLostPackets=false;
                client.ExecuteXmacs(true);
                throw new UnexpectedTestResultException("Expected xmacs to ignore the request, but we got a response.");
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                //we expect this and only this
            }
        }

        [TestCase, Description("Send vouchers of weird lengths.")]
        [CompoundCase("{0}",              0,   "\0", false, null)]
        [CompoundCase("{0} {1}",          1,   "-",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} {1}",          1,   "P",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} {1}",          28,  "-",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} {1}",          28,  "P",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("Normal",           29,  "\0", true,  null)] //normal
        [CompoundCase("Normal ExtraNull", 30,  "\0", true,  null)] //I vaguely recall something about the pc client appending a null
        [CompoundCase("{0} {1}",          30,  "-",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} {1}",          30,  "P",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} {1}",          31,  "-",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} 2Nulls",       31,  "\0", true,  null)] //kdc treats it as a sometimes-null-terminated string
        [CompoundCase("{0} {1}",          31,  "P",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} {1}",          39,  "-",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} {1}",          39,  "P",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)]
        [CompoundCase("{0} {1}",          40,  "-",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)] //XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH
        [CompoundCase("{0} {1}",          40,  "P",  true,  KerbErrCode.KDC_ERR_XBOX_TOKEN_INVALID)] //XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH
        [CompoundCase("{0} {1}",          41,  "-",  false, null)]
        [CompoundCase("{0} {1}",          41,  "P",  false, null)]
        [CompoundCase("{0} {1}",          42,  "-",  false, null)]
        [CompoundCase("{0} {1}",          42,  "P",  false, null)]
        [CompoundCase("{0} {1}",          500, "-",  false, null)]
        public void VoucherLengths(TestNode self)
        {
            int voucherLength=(int)self.MyValues[0]; //normal is 5x5+4=29
            string extraChar=(string)self.MyValues[1];
            bool expectResponse=(bool)self.MyValues[2];
            KerbErrCode ?expectError=(self.MyValues[3]!=null?(KerbErrCode?)(KerbErrCode)self.MyValues[3]:(KerbErrCode?)null);

            KdcUser user=GetCachedUser();
            string voucher=GetCachedUnlimitedPcVoucher();

            if (voucherLength<29)
            {
                voucher=voucher.Substring(0, voucherLength);
            }
            else if (voucherLength>29)
            {
                for (int i=29; i<voucherLength; ++i)
                {
                    voucher+=extraChar;
                }
            }

            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            Global.RO.Debug("Sending request.");
            if (!expectResponse)
            {
                try
                {
                    client.RetryLostPackets=false;
                    client.ExecuteXmacs(true);
                    throw new UnexpectedTestResultException("Expected xmacs to ignore the request, but we got a response.");
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    //we expect this and only this
                }
            }
            else
            {
                if (expectError==null)
                {
                    client.ExecuteXmacs(true);
                }
                else
                {
                    client.XmacsThrowOnKerberosError=false;
                    client.ExecuteXmacs(true);
                    if (client.XmacsError==null)
                    {
                        throw new UnexpectedTestResultException("Expected a kerberos error, but got a valid response.");
                    }

                    ValueCheck.Test("Expected kerberos error code", (KerbErrCode)expectError, (KerbErrCode)(int)client.XmacsError.ErrorCode.Int64);
                }
            }
        }

        [TestCase, Description("The bytes to be encrypted in the preauth are truncated or appended to.")]
        [CompoundCase("0 bytes",         0,    null)]
        [CompoundCase("1 byte",          1,    null)]
        [CompoundCase("2 bytes",         2,    null)]
        [CompoundCase("4 bytes",         4,    null)]
        [CompoundCase("1000 bytes",      1000, null)]
        [CompoundCase("1 extra byte",    null,  1)]
        [CompoundCase("2 extra bytes",   null,  2)]
        [CompoundCase("100 extra bytes", null,  100)]
        [CompoundCase("300 extra bytes", null,  300)]
        [CompoundCase("500 extra bytes", null,  500)]
        [CompoundCase("1 less byte",     null,  -1)]
        [CompoundCase("100 less bytes",  null,  -100)]
        public void ResizeEncryptedBytes(TestNode self)
        {
            int ?newAbsoluteBytes=(self.MyValues[0]!=null?(int?)(int)self.MyValues[0]:(int?)null);
            int ?newRelativeBytes=(self.MyValues[1]!=null?(int?)(int)self.MyValues[1]:(int?)null);

            KdcUser user=GetCachedUser();
            string voucher=GetCachedUnlimitedPcVoucher();

            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            client.XmacsRequest.Input.GeneratePreauths();

            Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2> mac2=client.XmacsRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2>>(220);
            byte []paEncPartBytes=mac2.Data.EncryptedPart.GetInnerBytes();

            int newByteCount=paEncPartBytes.Length;
            if (newAbsoluteBytes!=null)
            {
                newByteCount=(int)newAbsoluteBytes;
            }
            if (newRelativeBytes!=null)
            {
                newByteCount+=(int)newRelativeBytes;
            }
            System.Array.Resize(ref paEncPartBytes, newByteCount);

            mac2.Data.EncryptedPart.Encrypt(paEncPartBytes);
            mac2.Data.RepackEncryptedPartAndAllBytes();

            client.XmacsRequest.SetRequest();
            client.XmacsRequest.ConstructRequest();

            Global.RO.Debug("Sending request.");
            try
            {
                client.RetryLostPackets=false;
                client.ExecuteXmacs(false);
                throw new UnexpectedTestResultException("Expected xmacs to ignore the request, but we got a response.");
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                //we expect this and only this
            }
        }

        [TestCase, Description("Simple test that the kerbclient path works.")]
        public void NativeClient()
        {
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Panorama);
            ctx.DefaultPcXmacsPreauth=2;
            XmacsClient xmacs=new XmacsClient(ctx);
            xmacs.SignInXmacs();
        }

        //TODO: Anything we can test with ticket policy?
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PanoramaXmacs.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using xonline.common.user;
using xonline.common.utilities;
using xonline.common.protocol;

namespace XkdcTest
{
    abstract public class TestBase_PanoramaXmacs : TestBase_Xmacs
    {
        protected static ServerTestFramework.LiveService.Auth.PassportException E_Passport = new ServerTestFramework.LiveService.Auth.PassportException();

        protected AuthContext ctx;
        protected const uint PanoramaMacsTitleId = 0x585207D1;

        public TestBase_PanoramaXmacs()
        {
            ClientType = AuthContext.ClientTypes.Panorama;
            ctx = null;
        }

        public override void PreRun()
        {
            ctx = new AuthContext(ClientType);
            XmacsClient.SetDefaults(ctx);

            TestBase_Panorama.ClearMachineCache();
        }

        override protected void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;
            RunTest();
        }

        protected XmacsClient DoPanoramaRequest(Exception expectedException)
        {
            return DoPanoramaRequest(expectedException, null);
        }

        protected XmacsClient DoPanoramaRequest(Exception expectedException, string errorMessageFormat, params object[] args)
        {
            XmacsClient xmacs = null;
            try
            {
                if (ctx.PassportTicket == null)
                {
                    ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                }
                xmacs = DoRequest(ctx, expectedException, true);
                if (ResultCode == TEST_RESULTS.FAILED && errorMessageFormat != null)
                    ro.Warn("[DoPanoramaRequest error] " + errorMessageFormat, args);
            }
            catch (ServerTestFramework.LiveService.Auth.PassportException actual)
            {
                if (errorMessageFormat != null)
                    ro.Warn("[DoPanoramaRequest error] " + errorMessageFormat, args);

                if (expectedException is ServerTestFramework.LiveService.Auth.PassportException)
                {
                    ro.Debug("[OK] " + actual.Message);
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    ro.Error("[ERR] " + actual.Message);
                    if (!bContinueOnException)
                        throw new UnexpectedTestResultException("Passport error not expected", actual);
                }
            }
            catch (Exception)
            {
                if (errorMessageFormat != null)
                    ro.Warn("[DoPanoramaRequest error] " + errorMessageFormat, args);
                throw;
            }
            return xmacs;
        }

        protected enum TokenStatus
        {
            Valid,
            Invalid,
            Banned,
            Unknown,
            Bad,
            UsageExceeded,
            InUse
        }

        protected XmacsClient Go_Token(string token, TokenStatus status, XonlinepUser originalMachine, bool bMachinesEqual)
        {
            if (originalMachine==null)
            {
                throw new UnexpectedTestResultException("originalMachine is null.  Did the previous request unexpectedly fail?");
            }

            XonlinepUser m1 = (XonlinepUser)originalMachine.Clone();

            // Presumably this is the 2nd call for this machine 
            ctx.UsersMachine = null;
            XmacsClient xmacs = Go_Token(token, status);
            XonlinepUser m2 = ctx.UsersMachine;

            // Compare created machine with reset machine. Should be same except for the 
            // key.
            if (status == TokenStatus.Valid)
            {
                CompareMachines(m1, m2, bMachinesEqual);
            }
            else
            {
                // 2nd call should have failed
                if (m2 != null)
                {
                    Fail("Expected 2nd XMACS call to fail for SponsorToken {0}, TokenStatus {1}", token, status);
                }
            }
            return xmacs;
        }

        protected XmacsClient Go_Token(string token, TokenStatus status)
        {
            return Go_Token(token, status, true);
        }

        protected XmacsClient Go_Token(string token, TokenStatus status, bool fVerifyWithAskdc)
        {
            ctx.SponsorToken = token;
            Exception ee = null;
            switch (status)
            {
                case TokenStatus.Valid: 
                    ee = null;
                    break;
                case TokenStatus.Invalid: 
                    ee = E_TokenInvalid;
                    break;
                case TokenStatus.Banned: 
                    ee = E_TokenBanned;
                    break;
                case TokenStatus.Unknown: 
                    ee = E_TokenInvalid;
                    break;
                case TokenStatus.Bad:
                    ee = E_NoResponse;
                    break;
                case TokenStatus.UsageExceeded:
                    ee = E_TokenUsageExceeded;
                    break;
                case TokenStatus.InUse:
                    ee = E_TokenInUse;
                    break;
            }

            XmacsClient xmacs = DoPanoramaRequest(ee, "SponsorToken {0}, TokenStatus {1}", token, status);

            if (ctx.UsersMachine == null)
            {
                if (ee == null)
                    Fail("XMACS seems to have failed but we expected success. SponsorToken {0}, TokenStatus {1}", token, status);
                return xmacs;
            }

            ro.Debug("Created machine puid 0x{0:X}, PcId 0x{1:X}, Token {2}", ctx.UsersMachine.xuid.qwUserID, ServerTestFramework.Utilities.Hexer.tohex(ctx.PcId), token);

            if (!fVerifyWithAskdc)
            {
                return xmacs;
            }

            // Sign in to ASKDC to verify
            try
            {
                Verify(ctx);
                if (status != TokenStatus.Valid && ResultCode == TEST_RESULTS.PASSED)
                {
                    Fail("ASKDC let us sign in but our account should not have been created. SponsorToken {0}, TokenStatus {1}, Machine {2}", 
                         token, status, AuthClientBase.BytesToString(ctx.UsersMachine.Gamertag));
                }
            }

            catch (Exception e)
            {
                if (status == TokenStatus.Valid)
                {
                    Fail("ASKDC threw an exception but we expected no error. SponsorToken {0}, TokenStatus {1}, Machine {2}, Exception: \n{3}", 
                         token, status, AuthClientBase.BytesToString(ctx.UsersMachine.Gamertag), e.ToString());
                }
            }
            return xmacs;
        }


        protected abstract void RunTest();

    }

    /// <summary>
    /// Panorama AKA Live on Windows tests go here
    /// </summary>
    [TestGroup]
    public class PanoramaXmacs : XkdcTestBaseGroup
    {
        public PanoramaXmacs()
        {
            ParentClientType=AuthContext.ClientTypes.Panorama;
        }

        [TestCase, DVT, Description("Create a Machine Account using harness defaults.")]
        class BasicSignin_Machine : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DoPanoramaRequest(null);
            }
        }

        [TestCase, DVT, Description("Create a Machine Account using a new passport user.")]
        class BasicSignin_NewUser : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                ctx.SetNewPassportUser(0);
                DoPanoramaRequest(null);
            }
        }

        [TestCase, DVT]
        class BasicSignin_LimitedMachine : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                XmacsClient.SetDefaults(ctx);
                ctx.SponsorToken = PanoramaLimited.c_LimitedToken;

                DoPanoramaRequest(null);
            }
        }


        [TestCase, Description("Create a Machine Account, reset the key to default settings, and then ensure account is reset.")]
        class Accounts_Create : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DoPanoramaRequest(null);
                if (ctx.UsersMachine==null)
                {
                    throw new UnexpectedTestResultException("Did not get a response.");
                }
                XonlinepUser m1 = (XonlinepUser)ctx.UsersMachine.Clone();

                XmacsClient.SetDefaults(ctx);
                DoPanoramaRequest(null);
                if (ctx.UsersMachine==null)
                {
                    throw new UnexpectedTestResultException("Did not get a response.");
                }
                XonlinepUser m2 = (XonlinepUser)ctx.UsersMachine.Clone();

                CompareMachines(m1, m2, false);
            }
        }

        [TestCase, Description("Create a machine account, reset the key, and then ensure account is reset.")]
        class Accounts_Reset : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DoPanoramaRequest(null);
                XonlinepUser m1 = (XonlinepUser)ctx.UsersMachine.Clone();

                DoPanoramaRequest(null);
                XonlinepUser m2 = (XonlinepUser)ctx.UsersMachine.Clone();

                CompareMachines(m1, m2, true);
            }
        }


        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Description("Create a Machine Account, and confirm it creates title activations")]
        class CheckTitleActivation : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                // Create new token associated with title 0xC0FE0901
                string voucher = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);
                uint titleId = 0xC0FE0901;

                // create a new passport user
                Global.RO.Debug("Creating new user and retrieving Passport ticket...");
                KdcUser xeUser = ctx.SetNewPassportUser(1, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create the machine account
                Global.RO.Debug("Making machine...");
                XmacsClient xmacs = Go_Token(voucher, TokenStatus.Valid);

                Global.RO.Debug("Machine puid is (0x{0:X})", xmacs.MachinePuid);

                //Now check that uodb has machines for this title ID;
                bool foundUser = false;
                bool foundMachine = false;
                int totalFound = 0;

                string queryMachine = "select bi_machine_puid, i_title_id from t_machine_title_activations where bi_machine_puid=0x" + xmacs.MachinePuid.ToString("X");
                Global.RO.Debug("Machine activation query is " + queryMachine);

                string queryUser = "select bi_user_puid, i_title_id from t_user_title_activations where bi_user_puid=0x" + xeUser.UserID.ToString("X");
                Global.RO.Debug("User activation query is " + queryUser);

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.CommandSql = queryMachine;

                    for (int p = 0; p < ws.PhysicalPartitions; p++)
                    {
                        ws.PhysicalPartition = p;
                        using (WstDataReader reader = ws.Execute())
                        {
                            while (reader.Read())
                            {
                                ++totalFound;
                                ulong puid = (ulong)(long)reader[0];
                                uint title = (uint)(int)reader[1];
                                Global.RO.Debug("Found Machine puid " + puid + " for title  " + title + " on partition 0-based index " + p);
                                if ((puid == xmacs.MachinePuid) && (title == titleId)) 
                                    foundMachine = true;
                            }
                        }
                    }

                    ws.CommandSql = queryUser;

                    for (int p = 0; p < ws.PhysicalPartitions; p++)
                    {
                        ws.PhysicalPartition = p;
                        using (WstDataReader reader = ws.Execute())
                        {
                            while (reader.Read())
                            {
                                ++totalFound;
                                ulong puid = (ulong)(long)reader[0];
                                uint title = (uint)(int)reader[1];
                                Global.RO.Debug("Found User puid " + puid + " for title  " + title + " on partition 0-based index " + p);
                                // The token creator makes different tokens for just one offer:  Panorama Create a Machine account.
                                if ((puid == xeUser.UserID) && (title == titleId)) 
                                    foundUser = true;
                            }
                        }

                    }
                }

                if (!foundMachine) Fail("Machine Activation was not found.");
                if (!foundUser) Fail("User Activation was not found.");

                ValueCheck.Test("Total results from queries", 2, totalFound);
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Description("Attempt to use a voucher twice, for same user on same machine.")]
        class ReUseVoucherSameUser : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                string voucher = TokendbWS.CreatePanoramaVoucher(10);

                //Make machine
                Global.RO.Debug("Making machine...");

                // create a new passport user (in slot 1)
                ctx.SetNewPassportUser(1, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create the machine account
                XmacsClient xmacs1 = Go_Token(voucher, TokenStatus.Valid);

                //Reset 
                Global.RO.Debug("Resetting machine...");

                // create the machine account
                XmacsClient xmacs2 = Go_Token(voucher, TokenStatus.Valid);
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Description("Attempt to use a voucher twice, for same user on different machine.")]
        class ReUseVoucherSameUserDifferentMachine : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                string voucher = TokendbWS.CreatePanoramaVoucher(10);

                //Make machine
                Global.RO.Debug("Making machine...");

                // create a new passport user (in slot 1)
                ctx.SetNewPassportUser(1, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create the machine account
                XmacsClient xmacs1 = Go_Token(voucher, TokenStatus.Valid);

                // create a different machine account by resetting the PcId but leaving 
                // the Passport user info alone
                XmacsClient.SetDefaults(ctx);

                XmacsClient xmacs2 = Go_Token(voucher, TokenStatus.Valid);

            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Description("Attempt to use a voucher twice, with two users on same slot.")]
        class ReUseVoucherDifferentUser : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                string voucher = TokendbWS.CreatePanoramaVoucher(10);

                //Make machine
                Global.RO.Debug("Making machine...");

                // create a new passport user (in slot 1)
                ctx.SetNewPassportUser(1, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create the machine account
                XmacsClient xmacs1 = Go_Token(voucher, TokenStatus.Valid);

                //Reset machine
                Global.RO.Debug("Resetting machine with new user...");

                // create a new passport user
                ctx.SetNewPassportUser(1, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create the machine account again, with a new user. Since this user is 
                // valid, and the machine account is valid (from the first step), ASKDC 
                // will succeed. Let's not test it.
                XmacsClient xmacs2 = Go_Token(voucher, TokenStatus.Valid);
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Description("Attempt to use a voucher twice, with two users on different machines.")]
        class ReUseVoucherDifferentUserDifferentMachine : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                string voucher = TokendbWS.CreatePanoramaVoucher(10);

                //Make machine
                Global.RO.Debug("Making machine...");

                // create a new passport user (in slot 1)
                ctx.SetNewPassportUser(1, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create the machine account
                XmacsClient xmacs1 = Go_Token(voucher, TokenStatus.Valid);

                //Reset machine
                Global.RO.Debug("Resetting machine with new user...");

                // create a new passport user
                ctx.SetNewPassportUser(1, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create a different machine account by resetting the PcId but leaving 
                // the Passport user info alone
                XmacsClient.SetDefaults(ctx);

                // create the machine account again, with a new user
                XmacsClient xmacs2 = Go_Token(voucher, TokenStatus.Valid);
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Description("Attempt to use a voucher twice, with two users on same machine, different slots.")]
        class ReUseVoucherDifferentUserDifferentSlot : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                string voucher = TokendbWS.CreatePanoramaVoucher(10);

                //Make machine #1 
                Global.RO.Debug("Making machine...");

                // create a new passport user (in slot 0)
                ctx.SetNewPassportUser(0, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create the machine account
                XmacsClient xmacs1 = Go_Token(voucher, TokenStatus.Valid);

                // delete passport user (in slot 0)
                ctx.ClearUsers();

                //Make machine #2
                Global.RO.Debug("Making machine with new user...");

                // create a new passport user (in slot 1)
                ctx.SetNewPassportUser(1, true);

                // Get the passport ticket for this new user
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                // create a different machine account by resetting the PcId but leaving 
                // the Passport user info alone
                XmacsClient.SetDefaults(ctx);

                // create the machine account again, with a new user
                XmacsClient xmacs2 = Go_Token(voucher, TokenStatus.Valid);
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Description("Attempt to use a voucher after changing the users gamer tag .")]
        class ReUseVoucherAfterTagUpdate : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                string voucher = TokendbWS.CreatePanoramaVoucher(10);

                //Make machine
                Global.RO.Debug("Making machine...");

                // create a new passport user (in slot 1)
                KdcUser xeUser = ctx.SetNewPassportUser(1, true);

                // create the machine account
                XmacsClient xmacs1 = Go_Token(voucher, TokenStatus.Valid);

                // Make a request to set the User Account to expect a gamer tag change
                UserEditor userEdit=UserEditor.FromPuid(xeUser.UserID);
                userEdit.NameChangeRequired=1;

                // Make a request to change the gamertag
                XRLChangeGamerTag changeTagRequest = new XRLChangeGamerTag();
                changeTagRequest.userPuid = xeUser.UserID;
                changeTagRequest.machinePuid = xmacs1.MachinePuid;

                ServerTestFramework.Utilities.RandomEx rnd = new ServerTestFramework.Utilities.RandomEx();
                changeTagRequest.newTag = rnd.GenerateRandomString("PAN", 15);

                Global.RO.Debug("Changing gamer tag to " + changeTagRequest.newTag);

                if (!changeTagRequest.Execute())
                    throw new UnexpectedTestResultException("XRLChangeGamerTag failed: " + changeTagRequest.GetDumpString());
                if (changeTagRequest.XErr != ServerTestFramework.LiveService.HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLChangeGamerTag returned XErr=0x{0:x}", changeTagRequest.XErr));

                //Reset machine
                Global.RO.Debug("Resetting machine after tag update...");
                XmacsClient xmacs2 = Go_Token(voucher, TokenStatus.Valid);
            }
        }


        [TestCase, Description("Create 2 different machines with the same voucher, then verify that there are two machines in uodb")]
        class TwoMachinesOneVoucher: TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                string voucher = TokendbWS.CreatePanoramaVoucher(10);

                //Make machine #1
                Global.RO.Debug("Making machine #1...");
                AuthContext ctx1=new AuthContext(AuthContext.ClientTypes.Panorama);
                XmacsClient xmc1=new XmacsClient(ctx1);
                XmacsClient.SetDefaults(ctx1);
                ctx1.SponsorToken=voucher;
                xmc1.SignInXmacs();
                Global.RO.Debug("Machine1 puid is (0x{0:X})", xmc1.MachinePuid);

                //Make machine #2
                Global.RO.Debug("Making machine #2...");
                AuthContext ctx2=new AuthContext(AuthContext.ClientTypes.Panorama);
                XmacsClient xmc2=new XmacsClient(ctx2);
                XmacsClient.SetDefaults(ctx2);
                ctx2.SponsorToken=voucher;
                xmc2.SignInXmacs();
                Global.RO.Debug("Machine2 puid is (0x{0:X})", xmc2.MachinePuid);

                //Now check that uodb has the two machines for this voucher
                bool found1=false, found2=false;
                int totalFound=0;

                string query = "select bi_machine_puid from t_pc_accounts where bin_voucher_hash=0x" + TokendbWS.HashPanoramaVoucher(voucher);
                Global.RO.Debug("Query is "+query);

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.CommandSql = query;

                    for (int p = 0; p < ws.PhysicalPartitions; p++)
                    {
                        ws.PhysicalPartition = p;
                        using (WstDataReader reader=ws.Execute())
                        {
                            while (reader.Read())
                            {
                                ++totalFound;
                                ulong puid=(ulong)(long)reader[0];
                                Global.RO.Debug("Found puid "+puid+" on partition 0-based index "+p);
                                if (puid==xmc1.MachinePuid) found1=true;
                                if (puid==xmc2.MachinePuid) found2=true;
                            }
                        }
                    }
                }

                if (!found1) Fail("Machine1 was not found.");
                if (!found2) Fail("Machine2 was not found.");

                ValueCheck.Test("Total results from query", 2, totalFound);
            }
        }

        [TestCase, Description("Create account, ban it, then attempt to sign in again")]
        class Accounts_Banned : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                bVerbose = true;
                XmacsClient xmacs = DoPanoramaRequest(null);
                ulong puid=xmacs.GetMachinePuid();
                XonlinepUser m1 = (XonlinepUser)ctx.UsersMachine.Clone();
                ro.Debug("machine puid is 0x{0:X}", puid);
                ro.Debug("machine1 key is 0x{0}", ServerTestFramework.Utilities.Hexer.tohex(m1.Key));

                MachineEditor machEd=MachineEditor.FromId(puid);
                machEd.BanMachine();

                System.Threading.Thread.Sleep(1000);
                DoPanoramaRequest(E_NoResponse);
            }
        }

        [TestCase]
        class CorruptedPassportTicket : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                ctx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                ctx.PassportTicket[0]++;
                DoPanoramaRequest(E_NoResponse);
            }
        }

        // My tokens all begin with "22222-11111-11111-22222-nnnnn"
        // with the following 5 letter suffixes:
        //   00000 - valid inf. uses
        //   00001 - invalid inf. uses
        //   00002 - banned inf. uses
        //   00003 - valid 5 uses
        //   00004 - invalid 5 uses
        //   00005 - banned 5 uses
        //   99999 - doesn't exist (not in UODB)

        [TestCase]
        class SponsorToken_Simple_PPPPP : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("PPPPP-PPPPP-PPPPP-PPPPP-PPPPP", TokenStatus.Valid); 
            }
        }

        [TestCase]
        class SponsorToken_Simple_11111_Negative : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("11111-11111-11111-11111-11111", TokenStatus.Unknown); 
            }
        }

        [TestCase]
        class SponsorToken_ValidCreate : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid); 
            }
        }

        [TestCase]
        class SponsorToken_InvalidCreate : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00001", TokenStatus.Invalid); 
            }
        }

        [TestCase]
        class SponsorToken_BannedCreate : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00002", TokenStatus.Banned); 
            }
        }

        [TestCase]
        class SponsorToken_UnknownCreate : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-99999", TokenStatus.Unknown); 
            }
        }

        [TestCase, Description("Use a token that is not of a PC type")]
        class SponsorToken_ValidCreate_NotPc : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-0NOPC", TokenStatus.Invalid); 
            }
        }

        [TestCase]
        class SponsorToken_ValidCreate_ValidReset : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid);
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid, ctx.UsersMachine, true);
            }
        }

        [TestCase]
        class SponsorToken_ValidCreate_InvalidReset : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid); 
                Go_Token("22222-11111-11111-22222-00001", TokenStatus.Invalid, ctx.UsersMachine, true);
            }
        }

        [TestCase]
        class SponsorToken_ValidCreate_BannedReset : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid); 
                Go_Token("22222-11111-11111-22222-00002", TokenStatus.Banned, ctx.UsersMachine, true);
            }
        }

        [TestCase]
        class SponsorToken_ValidCreate_UnknownReset : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid); 
                Go_Token("22222-11111-11111-22222-99999", TokenStatus.Unknown, ctx.UsersMachine, true);
            }
        }

        [TestCase]
        class SponsorToken_MaxLengthPlus2 : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                // 40 characters is the max length, including dashes
                Go_Token("22222-11111-11111-22222-00000-00000-00000-", TokenStatus.Bad);
            }
        }

        [TestCase]
        class SponsorToken_MaxLengthPlus1 : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                // 40 characters is the max length, including dashes
                Go_Token("22222-11111-11111-22222-00000-00000-00000", TokenStatus.Bad);
            }
        }

        [TestCase, Ignore] //This test has never passed once... ever.  I suspect it may be a kerbclient bug... it causes a server event saying it failed to parse the pc xmacs preauth.
        class SponsorToken_MaxLength : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                // 40 characters is the max length, including dashes
                Go_Token("22222-11111-11111-22222-00000-00000-0000", TokenStatus.Unknown);
            }
        }

        [TestCase]
        class SponsorToken_ValidCreate_ValidReset_DiffTokens : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid); 
                Go_Token("PPPPP-PPPPP-PPPPP-PPPPP-PPPPP", TokenStatus.Valid, ctx.UsersMachine, false);
            }
        }

        [TestCase]
        class SponsorToken_Reuse : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid);
                if (ctx.UsersMachine==null)
                {
                    throw new UnexpectedTestResultException("Did not get a response.");
                }
                XonlinepUser m1 = (XonlinepUser)ctx.UsersMachine.Clone();

                ctx.UsersMachine = null;
                ctx.ClearPassport();
                XmacsClient.SetDefaults(ctx);
                Go_Token("22222-11111-11111-22222-00000", TokenStatus.Valid);
                if (ctx.UsersMachine==null)
                {
                    throw new UnexpectedTestResultException("Did not get a response.");
                }
                XonlinepUser m2 = (XonlinepUser)ctx.UsersMachine.Clone();

                // Ensure machines are different
                CompareMachines(m1, m2, false);
            }
        }

        [TestCase]
        class SponsorToken_Valid_5Uses : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                TokenStatus ts = TokenStatus.Valid;
                XmacsClient.ResetToken("22222-11111-11111-22222-00003", 5, 0, true);
                for (int i = 0; i < 6; i++)
                {
                    ro.Debug("Token use #{0} of 5", i);
                    if (i == 5)
                        ts = TokenStatus.UsageExceeded;
                    ctx.ClearPassport();
                    XmacsClient.SetDefaults(ctx);
                    ctx.UsersMachine = null;
                    Go_Token("22222-11111-11111-22222-00003", ts); 
                }
            }
        }

        [TestCase]
        class SponsorToken_Valid_5UsesWithResets : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                TokenStatus ts = TokenStatus.Valid;
                XmacsClient.ResetToken("22222-11111-11111-22222-00003", 5, 0, true);
                for (int i = 0; i < 6; i++)
                {
                    ro.Debug("Token use #{0} of 5", i);
                    if (i == 5)
                        ts = TokenStatus.UsageExceeded;
                    // New account
                    ctx.ClearPassport();
                    XmacsClient.SetDefaults(ctx);
                    ctx.UsersMachine = null;
                    Go_Token("22222-11111-11111-22222-00003", ts);
                    // Reset
                    System.Threading.Thread.Sleep(1015); //avoid askdc anti-dos
                    Go_Token("22222-11111-11111-22222-00003", ts);
                }
            }
        }

        [TestCase]
        class SponsorToken_Invalid_5Uses : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                TokenStatus ts = TokenStatus.Invalid;
                XmacsClient.ResetToken("22222-11111-11111-22222-00004", 5, 1, true);
                for (int i = 0; i < 6; i++)
                {
                    ro.Debug("Token use #{0} of 5", i);
                    if (i == 5)
                        ts = TokenStatus.Invalid;
                    ctx.ClearPassport();
                    XmacsClient.SetDefaults(ctx);
                    ctx.UsersMachine = null;
                    Go_Token("22222-11111-11111-22222-00004", ts); 
                }
            }
        }

        [TestCase]
        class SponsorToken_Banned_5Uses : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                TokenStatus ts = TokenStatus.Banned;
                XmacsClient.ResetToken("22222-11111-11111-22222-00005", 5, 2, true);
                for (int i = 0; i < 6; i++)
                {
                    ro.Debug("Token use #{0} of 5", i);
                    if (i == 5)
                        ts = TokenStatus.Banned;
                    ctx.ClearPassport();
                    XmacsClient.SetDefaults(ctx);
                    ctx.UsersMachine = null;
                    Go_Token("22222-11111-11111-22222-00005", ts); 
                }
            }
        }

        [TestCase, Description("5-use token, 1 machine account, 6 resets -- all ok")]
        class SponsorToken_Valid_5Uses_UnlimitedResets : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                TokenStatus ts = TokenStatus.Valid;
                XmacsClient.ResetToken("22222-11111-11111-22222-00003", 5, 0, true);
                for (int i = 0; i < 6; i++)
                {
                    ro.Debug("Token use #{0} of 6", i);
                    System.Threading.Thread.Sleep(1015); //avoid askdc anti-dos
                    Go_Token("22222-11111-11111-22222-00003", ts);
                }
            }
        }

        [TestCase, Description("5-use token, 1 machine account, 6 creates, 6 resets")]
        class SponsorToken_Valid_5Uses_UnlimitedResetsAfterCreates : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                TokenStatus ts = TokenStatus.Valid;
                XmacsClient.ResetToken("22222-11111-11111-22222-00003", 5, 0, true);
                // Create calls
                for (int i = 0; i < 6; i++)
                {
                    ro.Debug("Token use #{0} of 6", i);
                    if (i == 5)
                        ts = TokenStatus.UsageExceeded;
                    ctx.ClearPassport();
                    XmacsClient.SetDefaults(ctx);
                    ctx.UsersMachine = null;
                    Go_Token("22222-11111-11111-22222-00003", ts); 
                }
                // Reset calls
                ts = TokenStatus.UsageExceeded;
                ctx.ClearPassport();
                XmacsClient.SetDefaults(ctx);
                ctx.UsersMachine = null;
                for (int i = 0; i < 6; i++)
                {
                    ro.Debug("Token use (reset) #{0} of 6", i);
                    Go_Token("22222-11111-11111-22222-00003", ts); 
                }
            }
        }

        [TestCase, Description("token with 3 uses... verify that the 4th use fails")]
        class SponsorToken_Valid_VerifyUseLimit : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                ro.Debug("Making a token with 3 uses...");
                string voucher = ServerTestFramework.Database.TokendbWS.CreatePanoramaVoucher(3);

                ro.Debug("Using it 3 times...");
                for (uint i=0; i<3; ++i)
                {
                    AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Panorama);
                    XmacsClient xmc=new XmacsClient(ctx);
                    XmacsClient.SetDefaults(ctx);
                    ctx.SponsorToken=voucher;
                    xmc.SignInXmacs();
                }

                ro.Debug("Using it a 4th time... this should fail.");
                try
                {
                    AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Panorama);
                    XmacsClient xmc=new XmacsClient(ctx);
                    XmacsClient.SetDefaults(ctx);
                    ctx.SponsorToken=voucher;
                    xmc.SignInXmacs();
                }
                catch (Exception e)
                {
                    ro.Debug("Exception: "+e.Message);
                    if (e.Message.Contains("KDC_ERR_XBOX_TOKEN_USAGE_EXCEEDED"))
                    {
                        ResultCode=TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode=TEST_RESULTS.FAILED;
                    }
                    return;
                }

                Global.RO.Error("Should not have succeeded in that last request.");
                ResultCode=TEST_RESULTS.FAILED;
            }
        }

        [TestCase]
        class SponsorToken_LotsOfInvalid : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                Go_Token("1111111111111111111111111", TokenStatus.Invalid);
                Go_Token("", TokenStatus.Bad);
                Go_Token("12345678901234567890123456789012345678901", TokenStatus.Bad);
                Go_Token("12345678901234567890123456789012345678901234567890123456789012345678901234567890", TokenStatus.Bad);
                Go_Token("1", TokenStatus.Invalid);
                Go_Token("P", TokenStatus.Invalid);
                Go_Token("#", TokenStatus.Invalid);
                Go_Token("$", TokenStatus.Invalid);
                Go_Token("|", TokenStatus.Invalid);
                Go_Token("PPPPP-PPPPP-PPPPP-PPPPP-PPPP", TokenStatus.Invalid);
                Go_Token("123456789012345678901234567890123456789", TokenStatus.Bad);
                Go_Token("1234567890123456789012345678901234567890", TokenStatus.Bad);
                Go_Token("1 SPACE HAH", TokenStatus.Invalid);
                Go_Token("!?@$%xmacs     TEST", TokenStatus.Invalid);
            }
        }

        //unlikely this is possible since voucher is hashed... but just to be paranoid...
        [TestCase]
        class SponsorToken_SqlAttack : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("';select * from t_tiers;--   ", TokenStatus.Invalid);

                Go_Token("';delete from t_tiers;", TokenStatus.Invalid);
                Go_Token(";delete from t_tiers;", TokenStatus.Invalid);
                Go_Token("'delete from t_tiers;", TokenStatus.Invalid);
                Go_Token("\n';delete from t_tiers;", TokenStatus.Invalid);
                Go_Token("';delete from t_tiers;--", TokenStatus.Invalid);
                Go_Token("';delete from t_tiers;--     ", TokenStatus.Invalid);
                Go_Token("4';delete from t_tiers;--    ", TokenStatus.Invalid);
            }
        }
        
        [TestCase, Description("PcId: expected 8 bytes, any values are OK")]
        class PcId_Create_Valid : TestBase_PanoramaXmacs
        {
            protected void Go(byte[] pcid, bool bBad)
            {
                XmacsClient.SetDefaults(ctx);
                ctx.PcId = pcid;
                DoPanoramaRequest(bBad ? E_NoResponse : null);
            }
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                Go(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }, false);
                Go(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, false);
                Go(new byte[] { 255, 255, 255, 255, 255, 255, 255, 255 }, false);
            }
        }
        [TestCase, Description("PcId: expected 8 bytes, any values are OK")]
        class PcId_Create_Invalid : TestBase_PanoramaXmacs
        {
            protected void Go(byte[] pcid, bool bBad)
            {
                XmacsClient.SetDefaults(ctx);
                ctx.PcId = pcid;
                DoPanoramaRequest(bBad ? E_NoResponse : null);
            }
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;
                // Last digit gets truncated so this succeeds
                Go(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, false);

            }
        }

        [TestCase]
        class PcId_Reset_NewPcId : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                ctx.PcId = new byte[] { 255, 0, 1, 2, 3, 4, 5, 6 };

                XmacsClient xmacs=null;
                try
                {
                    xmacs=DoPanoramaRequest(null);
                }
                catch(Exception) {}

                if (xmacs==null)
                {
                    Fail("DoPanoramaRequest failed.");
                    return;
                }

                if (ctx.UsersMachine==null)
                {
                    Fail("No UserMachine to work with.");
                    return;
                }

                XonlinepUser m1 = (XonlinepUser)ctx.UsersMachine.Clone();

                ctx.PcId = new byte[] { 255, 255, 1, 2, 3, 4, 5, 6 };
                DoPanoramaRequest(null);
                XonlinepUser m2 = (XonlinepUser)ctx.UsersMachine.Clone();

                CompareMachines(m1, m2, false);
            }
        }

        [TestCase(BugID=18273, BugDatabase="Xbox 360 Console Software"), Description("PC Machine account where the entry in t_machines missing though t_pc_accounts is good.")]
        class PcId_Missing_t_machines_entry: TestNode
        {
            public override void Run()
            {
                //create the machine account normally
                string voucher=TokendbWS.CreatePanoramaVoucher(-1);
                Global.RO.Debug("Created new unlimited use count PC voucher: "+voucher+"(Hash=0x"+Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(voucher))+")");
                KdcClientPC client=new KdcClientPC();
                client.CreateXmacsRequest();
                client.XmacsRequest.Input.SponsorToken=voucher;
                client.ExecuteXmacs(true);

                //now delete from the other tables to simulate what would have happened
                UodbWS.ExecuteSQLNonQuery("delete from t_machine_title_activations where bi_machine_puid="+(long)client.XmacsOutput.MachineId, null);
                UodbWS.ExecuteSQLNonQuery("delete from t_machines where bi_machine_puid="+(long)client.XmacsOutput.MachineId, null);

                //now try to reset the machine account
                client.ExecuteXmacs(true);
            }
        }

        [TestCase, Description("PC Machine account where the entry in t_user_names and t_machines entry is missing though t_pc_accounts is good.  This can happen when some UODB partitions are in read-only mode during deployments.")]
        class PcId_Missing_t_user_names_entry : TestNode
        {
            public override void Run()
            {
                //create the machine account normally
                string voucher=TokendbWS.CreatePanoramaVoucher(-1);
                Global.RO.Debug("Created new unlimited use count PC voucher: "+voucher+"(Hash=0x"+Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(voucher))+")");
                KdcClientPC client=new KdcClientPC();
                client.CreateXmacsRequest();
                client.XmacsRequest.Input.SponsorToken=voucher;
                client.ExecuteXmacs(true);

                //now delete from the other tables to simulate what would have happened
                UodbWS.ExecuteSQLNonQuery("delete from t_machine_title_activations where bi_machine_puid="+(long)client.XmacsOutput.MachineId, null);
                UodbWS.ExecuteSQLNonQuery("delete from t_machines where bi_machine_puid="+(long)client.XmacsOutput.MachineId, null);
                UodbWS.ExecuteSQLNonQuery("delete from t_user_keys where vc_gamertag='"+client.XmacsOutput.ConsoleId+"'", null);
                UodbWS.ExecuteSQLNonQuery("delete from t_user_names where vc_gamertag='"+client.XmacsOutput.ConsoleId+"'", null);

                //now try to reset the machine account
                client.ExecuteXmacs(true);
            }
        }

        [TestCase]
        class BadRealm : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;

                try
                {
                    ctx.k_MacsKerberosRealm = "macx.xbox.com";
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_MacsKerberosRealm = "xbox.com";
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_MacsKerberosRealm = "passport.net";
                    DoPanoramaRequest(Suite.IsAskdcIPAntiDosEnabled?(Exception)E_PreauthRequired:(Exception)E_NoResponse);

                    ctx.k_MacsKerberosRealm = "";
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_MacsKerberosRealm = "macs@xbox.com";
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_MacsKerberosRealm = "macs.xbox.com  long string                                                                     see";
                    DoPanoramaRequest(E_NoResponse);
                }
                catch
                {
                    ro.Error("k_MacsKerberosRealm={0}", ctx.k_MacsKerberosRealm);
                    throw;
                }

            }
        }

        [TestCase]
        class BadPcMachineName : TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;

                try
                {
                    ctx.k_PcMachineName = "PC@XBOX.COM";
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_PcMachineName = "XBOX.COM";
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_PcMachineName = "";
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_PcMachineName = "PC.@PASSPORT.NET"; 
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_PcMachineName = "@XBOX.COM";
                    DoPanoramaRequest(E_NoResponse);

                    ctx.k_PcMachineName = "PC.@XBOX.COM  long string                                                                          see";
                    DoPanoramaRequest(E_NoResponse);
                }
                catch
                {
                    ro.Error("k_PcMachineName={0}", ctx.k_PcMachineName);
                    throw;
                }

            }
        }

        [TestCase(170284)]
        class SponsorToken_TestVoucherNotCaseSensetive: TestBase_PanoramaXmacs
        {
            override protected void RunTest()
            {
                Go_Token("PPPPP-PPPPP-PPPPP-PPPPP-PPPPP", TokenStatus.Valid);
                Go_Token("ppppp-ppppp-ppppp-ppppp-ppppp", TokenStatus.Valid, ctx.UsersMachine, true);
                Go_Token("PPPPP-PPPPP-PPPPP-PPPPP-PPPPP", TokenStatus.Valid, ctx.UsersMachine, true);
                Go_Token("ppppp-ppppp-ppppp-ppppp-ppppp", TokenStatus.Valid, ctx.UsersMachine, true);

                //If more than one row exists Xkdc will block us because we've "activated other title".  Verify we can get through xkdc fine.
                XkdcClient xkdc=new XkdcClient(ctx);
                xkdc.SignInXkdc();
                ValueCheck.Test("Xkdc response", 0, ctx.GetXkdcResult().ServiceHR);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\PanoramaXkdc.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
// Cryptography and Globalization are required for token hash creation
using System.Security.Cryptography;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities.DBPoster;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
  
using xonline.common.sql.webstore;
using xonline.common.service;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

namespace XkdcTest
{
    abstract public class TestBase_PanoramaXkdc : TestBase_Panorama
    {
        public TestBase_PanoramaXkdc()
        {
            ClientType=AuthContext.ClientTypes.Panorama;
        }
    }

    /// <summary>
    /// Panorama AKA Live on Windows tests go here
    /// </summary>
    [TestGroup]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class PanoramaXkdc: XkdcTestBaseGroup
    {
        public PanoramaXkdc()
        {
            ParentClientType=AuthContext.ClientTypes.Panorama;
        }

        public override void PreRun()
        {
            TestBase_Panorama.ClearMachineCache();
        }

        protected const uint PanoramaMacsTitleId = 0x585207D1;

        [TestCase, DVT]
        class Simple_Machine: TestBase_PanoramaXkdc
        {
            override protected void RunTest()
            {
                bVerifyAuthdata = true;
                SignInAskdc();
                SignInXkdc(true);
                ro.Debug(authContext.GetXkdcResult().ToString(true));
            }
        }

        [TestCase, DVT]
        class Simple_NewUser: TestBase_PanoramaXkdc
        {
            override protected void RunTest()
            {
                bVerifyAuthdata = true;
                SetUser(authContext.SetNewPassportUser(0), 0);
                authContext.SetTitle(PanoramaMacsTitleId, 1, 1); // main Panorama test title
                SignInAskdc();
                SignInXkdc(true);
                ro.Debug(authContext.GetXkdcResult().ToString(true));
            }
        }

        [TestCase, DVT]
        class Simple_LimitedMachine : TestBase_PanoramaXkdc
        {
            //We don't want to use the cached normal machine account for this test
            public override bool UseCachedMachineAccount()
            {
                return false;
            }

            //
            override protected void RunTest()
            {
                authContext.SponsorToken = PanoramaLimited.c_LimitedToken;

                bVerifyAuthdata = true;
                authContext.SetTitle(PanoramaMacsTitleId, 1, 1); // main Panorama test title

                SignInAskdc();
                authContext.IsPCLimited=true; //expect the limited bit to be set

                SignInXkdc(true);
                ro.Debug(authContext.GetXkdcResult().ToString(true));
            }
        }


        [TestCase]
        class GoldUserSignin : TestBase_Panorama
        {
            override protected void RunTest()
            {
                authContext.PassportMemberName = null; //our default for our default user = bad

                KdcUser user = CreateUserWithRetries(true);

                authContext.SetTitle(PanoramaMacsTitleId, 1, 1); // main Panorama test title
                SetUser(user, 0);

                SignInXkdc(true);
                ro.Debug(result.ToString());
            }
        }

        [TestCase]
        class SilverUserSignin : TestBase_Panorama
        {
            override protected void RunTest()
            {
                authContext.PassportMemberName = null; //our default for our default user = bad

                KdcUser user = CreateUserWithRetries(false);

                authContext.SetTitle(PanoramaMacsTitleId, 1, 1); // main Panorama test title
                SetUser(user, 0);

                SignInXkdc(true);
                ro.Debug(result.ToString());
            }
        }

        [TestCase, Description("Normal user, but they have their invalid user WLID bit set.  We should ignore that in the PC case.")]
        class InvalidWLIDFlag_User : TestBase_Panorama
        {
            protected override void RunTest ()
            {
                KdcUser xeu = authContext.SetNewPassportUser(0);
                UserEditor ue = UserEditor.FromPuid(xeu.UserID);
                ue.UserWLIDInvalid = 1;
                authContext.SetTitle(PanoramaMacsTitleId, 1, 1); // main Panorama test title

                SignInXkdc(true);
                Global.RO.Debug(authContext.GetXkdcResult().ToString(true));
                ValueCheck.Test("Service HR", 0, authContext.GetXkdcResult().ServiceHR);
                ValueCheck.Test("User0 HR", 0, authContext.GetXkdcResult().UserHRs[0]);
            }
        }

        [TestCase, Description("Normal user, but they have their invalid owner WLID bit set.  We should ignore that in the PC case.")]
        class InvalidWLIDFlag_Owner : TestBase_Panorama
        {
            protected override void RunTest ()
            {
                KdcUser xeu = authContext.SetNewPassportUser(0);
                UserEditor ue = UserEditor.FromPuid(xeu.UserID);
                ue.OwnerWLIDInvalid = 1;
                authContext.SetTitle(PanoramaMacsTitleId, 1, 1); // main Panorama test title

                SignInXkdc(true);
                Global.RO.Debug(authContext.GetXkdcResult().ToString(true));
                ValueCheck.Test("Service HR", 0, authContext.GetXkdcResult().ServiceHR);
                ValueCheck.Test("User0 HR", 0, authContext.GetXkdcResult().UserHRs[0]);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Check ability to sign in after a gamer tag change")]
        class Uacs_TagChange : TestBase_PanoramaXkdc
        {
            override protected void RunTest()
            {
                authContext.PassportMemberName = null; //our default for our default user = bad

                KdcUser user = CreateUserWithRetries(false);

                // authContext.SetTitle(0xC0FE0900, 1, 1); // main Panorama test title 
                authContext.SetTitle(PanoramaMacsTitleId, 1, 1); // main Panorama test title
                authContext.SetUser(user, 0);
                bVerifyServices = false;

                SignInXkdc(true);
                ro.Debug(result.ToString());

                ro.Debug(authContext.GetXkdcResult().ToString(true));
                // Make a request to set the User Account to expect a gamer tag change
                UserEditor userEdit=UserEditor.FromPuid(user.UserID);
                userEdit.NameChangeRequired=1;

                // Make a request to change the gamertag
                XRLChangeGamerTag changeTagRequest = new XRLChangeGamerTag();
                changeTagRequest.userPuid = user.UserID;
                // changeTagRequest.machinePuid = what exactly?  XmacsClient is obscured;

                RandomEx rnd = new RandomEx();
                changeTagRequest.newTag = rnd.GenerateRandomString("PAN", 15);

                Global.RO.Debug("Changing gamer tag to " + changeTagRequest.newTag);

                if (!changeTagRequest.Execute())
                    throw new UnexpectedTestResultException("XRLChangeGamerTag failed: " + changeTagRequest.GetDumpString());
                if (changeTagRequest.XErr != xonline.common.service.HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLChangeGamerTag returned XErr=0x{0:x}", changeTagRequest.XErr));

                // Now try to sign in once again
                SignInXkdc(true);
                ro.Debug(result.ToString());
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Make sure unable to sign in with a bad title.")]
        class GoldUserSigninBadTitle : TestBase_Panorama
        {
            override protected void RunTest()
            {
                authContext.PassportMemberName = null; //our default for our default user = bad

                KdcUser user = CreateUserWithRetries(true);

                authContext.SetTitle(0xfffe07d1, 1, 1); // LSP Test Title ID (Panorama user will create account with the MACS title ID)
                authContext.SetUser(user, 0);
                bVerifyServices = false;
                ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_UNKNOWN_TITLE;
                ExpectedUserHRs = new uint[] { 0 };
                SignInXkdc(true);
                ro.Debug(result.ToString());
            }
        }

        [TestCase]
        class Reset_Machine: TestBase_PanoramaXkdc
        {
            public override bool UseCachedMachineAccount()
            {
                return false;
            }

            override protected void RunTest()
            {
                authContext=null;
                SetDefaults();
                authContext.SetTitle(PanoramaMacsTitleId, 1, 1); // main Panorama test title

                XmacsClient xmacs=new XmacsClient(authContext);
                xmacs.SignInXmacs(); //new machine
                xmacs.SignInXmacs(); //reset machine

                SignInAskdc();
                SignInXkdc(true);
            }
        }

        [TestGroup]
        class TitleActivation: TestNode
        {
            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Confirm that KDC gives acces to title with actiavtion permission ON.")]
            class MainLine : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    // Title 0xC0FE0902 -> Offer 0xC0FE09020FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1); 

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Confirm that KDC doesn't allow use of a legacy voucher tied to a specific title on a ssa title.")]
            class LegacyTitleSpecificVoucherOnSSATitle : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Title 0xC0FE0900 -> Offer 0xC0FE09000FF00000 (legacy title)
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09000FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1); 

                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED;
                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Confirm that KDC doesn't allow use of a legacy voucher tied to the dash title on a ssa title.")]
            class LegacyDashVoucherOnSSATitle : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    //                     Offer 0x585207D10FF00001 ties to the PC dash title that all original vouchers were tied to
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0x585207D10FF00001);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1); 

                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED;
                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Confirm that limited vouchers will not work on SSA titles.")]
            class LimitedVoucherOnSSATitle : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    authContext.SponsorToken = "#############################";

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    // set title ID to 0xC0FE0901, which requires SSA
                    authContext.SetTitle(0xC0FE0901, 1, 1);

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Confirm that test vouchers will work on SSA titles.")]
            class TestVoucherOnSSATitle : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    authContext.SponsorToken = "PPPPP-PPPPP-PPPPP-PPPPP-PPPPP";

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    // set title ID to 0xC0FE0901, which requires SSA
                    authContext.SetTitle(0xC0FE0901, 1, 1);

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Valid User and Title, but title has not been activated.")]
            class ReuseTokenOnSameMachineForNewTitle : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    // Oops, wrong title -- but this other title still requires activation!
                    authContext.SetTitle(0xC0FE0902, 1, 1); 

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Validate User can activate and play 2 new titles.")]
            class UserPlaysTwoNewTitles : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = 0;
                    ExpectedUserHRs = new uint[] { 0 };

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);


                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create machine account for title #1 0xC0FE0901
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1);
                    SignInXkdc(true);
                    ro.Debug(result.ToString());


                    // Create new token associated with title 0xC0FE0902
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09020FF00000);

                    // Create 2nd machine account for title #2 0xC0FE0902
                    // Reset the PcId and xmacs results but leave user
                    XmacsClient.SetDefaults(authContext);
                    XmacsClient xmacs2 = new XmacsClient(authContext);
                    xmacs2.SignInXmacs();

                    authContext.SetTitle(0xC0FE0902, 1, 1);
                    SignInXkdc(true);
                    ro.Debug(result.ToString());

                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("New title activation works on an older title not requiring activation.")]
            class NewTokenButOldTitle : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Create new token associated with title 0xC0FE0901, which requires 
                    // activation
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    // Oops, wrong title -- user is actually playing 0xC0FE0900, which does 
                    // not require activation
                    authContext.SetTitle(0xC0FE0900, 1, 1); 

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_OTHER_TITLE_ACTIVATED;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("User tries to play title using token activated by another user.")]
            class WrongUserPlayingActivatedTitle : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1); 

                    // New user on this machine
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_USER_TITLE_ACTIVATION_REQUIRED;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Make sure Xbox360 can log into a title requiring activation.")]
            class CrossPlatformStillWorks : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    authContext.ClientType = AuthContext.ClientTypes.Xenon;
                    XmacsClient.SetDefaults(authContext);

                    // No way this user has activated anything
                    KdcUser user = CreateUserWithRetries(true);

                    authContext.SetUser(user, 0);

                    // This title requires activation for the PC but not the Xbox360.
                    authContext.SetTitle(0xC0FE0902, 1, 1); 

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.S_OK;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Fuzz Machine ID after successful XMACS."), Ignore("Server does not care about machine ID after XMACS")]
            class BadMachineId : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    // Title 0xC0FE0902 -> Offer 0xC0FE09020FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1);
                    authContext.UsersMachine.xuid.qwUserID = 99;

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.S_OK;
                    ExpectedUserHRs = new uint[] { xonline.common.service.HResult.XONLINE_E_LOGON_INVALID_CONSOLE_ID };

                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Fuzz Title ID after successful XMACS.")]
            class BadTitleId : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    // Title 0xC0FE0902 -> Offer 0xC0FE09020FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0x99, 1, 1);

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    // The "other title activated" check comes before the "unknown title id" 
                    // check.
                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_OTHER_TITLE_ACTIVATED;
                    ExpectedUserHRs = new uint[] { 0 };

                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Attempt to Logon to first title after successful XMACS with second title.")]
            class WrongTitleId : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    // Title 0xC0FE0902 -> Offer 0xC0FE09020FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    // Create new token associated with title 0xC0FE0902
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09020FF00000);

                    // Create second machine account for title
                    xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    // Set title ID to the first title created (which has been activated)
                    authContext.SetTitle(0xC0FE0901, 1, 1); 

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED;
                    ExpectedUserHRs = new uint[] { 0 };

                    // Set title ID to the first title created
                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Logon to first title after successful XMACS with second title, then first title.")]
            class SwitchTitleId : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    // Title 0xC0FE0902 -> Offer 0xC0FE09020FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    string sponsorToken1 = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);
                    // Create new token associated with title 0xC0FE0902
                    string sponsorToken2 = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09020FF00000);

                    authContext.SponsorToken = sponsorToken1;

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SponsorToken = sponsorToken2;

                    // Create machine account
                    xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    // retry first machine login
                    authContext.SponsorToken = sponsorToken1; 
                    xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1);
                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.S_OK;
                    ExpectedUserHRs = new uint[] { 0 };

                    SignInXkdc(true);
                    ro.Debug(result.ToString()); 
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Logon to Legacy title after successful XMACS with two users.")]
            class SwitchUser : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Create new token associated with default Panorama title
                    string sponsorToken1 = TokendbWS.CreatePanoramaVoucher(10);

                    authContext.SponsorToken = sponsorToken1;

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.S_OK;
                    ExpectedUserHRs = new uint[] { 0 };

                    SignInXkdc(true);
                    ro.Debug(result.ToString());

                    // Create second new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.S_OK;
                    ExpectedUserHRs = new uint[] { 0 };

                    SignInXkdc(true);
                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Confirm that KDC does NOT give access to title with activation permission ON, for a banned machine.")]
            class BannedMachine : TestBase_Panorama
            {
                override protected void RunTest()
                {
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    // Title 0xC0FE0902 -> Offer 0xC0FE09020FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    SetUser(authContext.SetNewPassportUser(0, true), 0);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1);

                    // first sign in before banning machine
                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);

                    // then attempt to sign in after banning machine
                    ulong puid=xmacs.GetMachinePuid();
                    MachineEditor machEd=MachineEditor.FromId(puid);
                    machEd.BanMachine();

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedUserHRs = new uint[] { 0 };
                    ExpectedHR = xonline.common.service.HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                    SignInXkdc(true);

                    ro.Debug(result.ToString());
                }
            }

            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Confirm that KDC does NOT give acces to title with activation permission ON, for a suspended user.")]
            class SuspendedUser : TestBase_Panorama
            {
                public void SuspendUser(ulong userPuid)
                {
                    DateTime resumeDate = DateTime.Now + TimeSpan.FromDays(7);

                    string sql = "update t_users " +
                        "set i_suspension_length = 1, " +
                        "dt_acct_resume_date = '" + resumeDate + "' " +
                        "where  bi_user_puid = 0x" +
                        userPuid.ToString("X");

                    UodbWS.ExecuteSQLNonQuery(sql, userPuid);
                }

                override protected void RunTest()
                {
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    // Title 0xC0FE0902 -> Offer 0xC0FE09020FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    KdcUser xeUser = authContext.SetNewPassportUser(0, true);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1);

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());

                    // then attempt to sign in after suspending user
                    SuspendUser(xeUser.UserID);

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.S_OK;
                    ExpectedUserHRs = new uint[] { DefaultXkdcXenonPreauthVersion<6?xonline.common.service.HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT:xonline.common.service.HResult.XONLINE_E_ACCOUNTS_ACCOUNT_BANNED };
                    SignInXkdc(true);

                    ro.Debug(result.ToString());
                }
            }


            [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Confirm that KDC does NOT give access to title with activation permission ON, for a banned token.")]
            class BannedToken : TestBase_Panorama
            {
                // Note that this test might belong in PanoramaXMacs, but there is a little bit of KDC canoodling.

                internal enum VoucherStatus
                {
                    Valid = 0,
                    Banned = 2
                }

                internal static void SetVoucherStatus(byte[] tokenhash, VoucherStatus status)
                {
                    int retval = 0;
                    WSClient _ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                    _ws.SetHashVal(BitConverter.ToInt64(tokenhash, 0));
                    _ws.StoredProc = "dbo.p_xmacs_set_voucher_status";

                    _ws.AddParameter(ParamType.INPUT, "@bin_voucher_hash", tokenhash, tokenhash.Length);
                    _ws.AddParameter(ParamType.INPUT, "@i_voucher_status_id", (int)status);
                    _ws.AddParameter(ParamType.RETVAL, "@RETVAL", retval);

                    _ws.ExecuteNonQuery();

                    retval = _ws.GetIntParameter("@RETVAL");
                    if (retval != 0)
                    {
                        Global.RO.Warn("Failed to set voucher hash to status {1}.", status);
                        throw new Exception(retval.ToString("X8"));
                    }
                }

                internal static byte[] TokenHashFromFiveByFive(string fivebyfive)
                {
                    if (fivebyfive.Length != 29)
                    {
                        Global.RO.Warn("5x5 tokens must of the form (xxxx-xxxx-xxxx-xxxx-xxxx).  Found " + fivebyfive);
                        return null;
                    }

                    SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();
                    UnicodeEncoding enc = new UnicodeEncoding();
                    return sha.ComputeHash(enc.GetBytes(fivebyfive.ToUpper() + "\0"));
                }

                override protected void RunTest()
                {
                    // Title 0xC0FE0901 -> Offer 0xC0FE09010FF00000
                    // Title 0xC0FE0902 -> Offer 0xC0FE09020FF00000
                    //
                    // Create new token associated with title 0xC0FE0901
                    authContext.SponsorToken = TokendbWS.CreatePanoramaVoucher(10, 0xC0FE09010FF00000);

                    // Create new gold Passport user and get ticket
                    KdcUser xeUser = authContext.SetNewPassportUser(0, true);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    XmacsClient xmacs = new XmacsClient(authContext);
                    xmacs.SignInXmacs();

                    authContext.SetTitle(0xC0FE0901, 1, 1);

                    bVerifyServices = false;
                    bVerifyUserHRs = true;
                    ExpectedHR = xonline.common.service.HResult.S_OK;
                    ExpectedUserHRs = new uint[] { 0 };
                    SignInXkdc(true);
                    ro.Debug(result.ToString());

                    ro.Debug("Banning the token {0}", authContext.SponsorToken);
                    // then attempt to sign in with same user after banning token
                    SetVoucherStatus(TokenHashFromFiveByFive(authContext.SponsorToken), VoucherStatus.Banned);

                    xmacs = new XmacsClient(authContext);
                    ro.Debug("Attempting to sign in to xmacs again with same user.");
                    try
                    {
                        xmacs.SignInXmacs();
                    }
                    catch (KerbErrException kerbErr)
                    {
                        if (kerbErr.KerbErr != KerbErrCode.KDC_ERR_XBOX_TOKEN_BANNED)
                            throw new UnexpectedTestResultException("KerbErr not expected.", kerbErr);
                    }

                    // Now, try to create a new account with the banned token
                    ro.Debug("Attempting to sign in to xmacs again with new user, but banned token.");

                    // Create new gold Passport user and get ticket
                    xeUser = authContext.SetNewPassportUser(0, true);
                    authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

                    // Create machine account
                    xmacs = new XmacsClient(authContext);
                    try
                    { 
                        xmacs.SignInXmacs();
                    }
                    catch (KerbErrException kerbErr)
                    {
                        if (kerbErr.KerbErr != KerbErrCode.KDC_ERR_XBOX_TOKEN_BANNED)
                            throw new UnexpectedTestResultException("KerbErr not expected.", kerbErr);
                    }
                }
            }
        } //class TitleAcvitation

        [TestCase, TestCasePriority(1)]
        public class BasicAutodiscover_MachineOnly: TestBase_KdcClient
        {
            public override void Run()
            {
                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class BasicAutodiscover_1User: TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktusert2a");
                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(2)]
        public class RequestAllServices_MachineOnly: TestBase_KdcClient
        {
            public override void Run()
            {
                SetXkdcDefaults();

                int maxServices = (DefaultXkdcXenonPreauthVersion < 5 ? 32 : 128);

                uint[] services = new uint[maxServices + 4];
                for (int i = 0; i < maxServices; ++i)
                {
                    services[i]=(uint)i;
                }
                services[maxServices + 0] = 8001;
                services[maxServices + 1] = 8002;
                services[maxServices + 2] = 8003;
                services[maxServices + 3] = 8004;
                Client.XkdcRequest.Input.SetServices(services);

                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(2)]
        public class RequestAllServices_1User: TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktusert2a");

                SetXkdcDefaults();

                int maxServices = (DefaultXkdcXenonPreauthVersion < 5 ? 32 : 128);

                uint[] services = new uint[maxServices + 4];
                for (int i = 0; i < maxServices; ++i)
                {
                    services[i]=(uint)i;
                }
                services[maxServices + 0] = 8001;
                services[maxServices + 1] = 8002;
                services[maxServices + 2] = 8003;
                services[maxServices + 3] = 8004;
                Client.XkdcRequest.Input.SetServices(services);

                ExecuteXkdc(true);
            }
        }

        [TestCase, Description("Sign in to an Authdata3 site")]
        [TestCasePriority(1)]
        public class AuthData3Site : TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktsubx2");
                SetXkdcDefaults();

                Client.XkdcRequest.Input.SetServices(new uint[]{8001});
                ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(8001, 0, 8001)};
                ExpectedAuthDataVersion=3;

                ExecuteXkdc(true);
            }
        }

        [TestCase, Description("Validate flowtokens with different combinations of authdata and servicerequest versions."), Owner("wisgt"), TestFrequency("Daily")]
        [TestCasePriority(1)]
        //Name,                                     User count, Authdata version, Extra site, Floken Provided
        [CompoundCase("Authdata3",                  1,          3,                false,      true)]
        [CompoundCase("Authdata4",                  1,          4,                false,      true)]
        [CompoundCase("Authdata4_NoFloken",         1,          4,                false,      false)]
        [CompoundCase("Authdata4_MultipleSites",    1,          4,                true,       true)]
        [CompoundCase("Authdata3_MultipleSites",    1,          3,                true,       true)]
        public class Flowtoken : TestBase_KdcClient
        {
            int userCount;
            int authdataVersion;
            int requestVersion;
            bool extraSite;
            bool flokenProvided;

            public override void PreRun()
            {
                base.PreRun();

                String[] userNames = new String[] { "xktad4a", "xktad4b", "xktad4c", "xktad4d" };

                userCount = (int)MyValues[0];
                authdataVersion = (int)MyValues[1];
                requestVersion = DefaultXkdcXenonPreauthVersion;
                extraSite = (bool)MyValues[2];
                flokenProvided = (bool)MyValues[3];

                Array.Resize(ref userNames, userCount); //Truncate to specified users.

                for (int slot=0; slot<userNames.Length; ++slot)
                {
                    SetUser(slot, userNames[slot]);
                }

                SetXkdcDefaults();

                if (authdataVersion == 3)
                {
                    Client.XkdcRequest.Input.SetServices(new UInt32[] { 8001 }); //V3 site
                    ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(8001, 0, 8001)};
                }

                if (extraSite)
                {
                    if (authdataVersion == 3)
                    {
                        Client.XkdcRequest.Input.SetServices(new UInt32[] { 8001, 8004 }); //V3 sites
                        ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(8001, 0, 8001), new XkdcGenericReplyOutput.ServiceResult(8004, 1, 0)};
                    }
                    else
                    {
                        Client.XkdcRequest.Input.SetServices(new UInt32[] { 20, 21 }); //V4 sites
                        ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(20, 0, 20), new XkdcGenericReplyOutput.ServiceResult(21, 1, 0)};
                    }
                }

                if (requestVersion >= 5)
                {
                    Client.XkdcRequest.Input.XenonPreauthVersion = 5;

                    if (requestVersion == 6)
                    {
                        Client.XkdcRequest.Input.ServiceRequestVersion = 6;
                    }
                }

                foreach (string user in userNames)
                {
                    UserMachineHistoryEditor history = UserMachineHistoryEditor.CreateOrUseExisting(ServerTestFramework.Database.UserEditor.FromGamerTag(user).Puid, Client.XmacsOutput.MachineId);
                }

                Global.RO.Info(String.Format("User count:{0} Authdata version:{1} Request version:{2}, Multiple Sites:{3}", userCount, authdataVersion, requestVersion, extraSite ));
            }

            public override void Run()
            {
                XkdcListener xkdcListener = new XkdcListener();

                if (DefaultXkdcXenonPreauthVersion >= 5)
                {
                    xkdcListener.StartXkdcListener();
                }

                try
                {
                    ExpectedAuthDataVersion=(uint)(DefaultXkdcXenonPreauthVersion < 5 ? 3 : authdataVersion);
                    ExecuteXkdc(true);

                    ulong ftVal = Client.XkdcOutput.FlowToken;

                    if (Client.XkdcOutput.XboxAuthData is Xenon2XkdcAuthData)
                        ftVal = ((Xenon2XkdcAuthData)Client.XkdcOutput.XboxAuthData).FlowToken;

                    if (DefaultXkdcXenonPreauthVersion >= 5)
                    {
                        xkdcListener.ValidatePresent(ftVal);
                        XkdcListener.FlushXomLogCache();
                    }

                    if (flokenProvided)
                    {
                        Client.XkdcRequest.Input.FlowToken = (ulong)System.DateTime.Now.Ticks;
                    }

                    Global.RO.Debug(String.Format("Set flowtoken to {0}", Client.XkdcRequest.Input.FlowToken));

                    Client.XkdcRequest.Input.PrepareForResend(); //need to use a new nonce for the request
                    ExecuteXkdc(true);

                    Global.RO.Debug(String.Format("Got flowtoken {0} back", Client.XkdcOutput.FlowToken));

                }
                finally
                {
                    if (DefaultXkdcXenonPreauthVersion >= 5)
                    {
                        xkdcListener.StopXkdcListener();
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\KdcStressForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;

namespace XkdcTest
{
    /// <summary>
    /// fuzz form.
    /// </summary>
    public class KdcStressForm : System.Windows.Forms.Form
    {
        private System.Windows.Forms.GroupBox groupBoxSettings;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.NumericUpDown fuzzIterations;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.TextBox textRandomSeed;
        private System.Windows.Forms.Button btnSetRandomSeed;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox textStartIteration;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        private GroupBox groupBox1;
        private NumericUpDown asnChanceCharStr;
        private Label label6;
        private Label label5;
        private Label label4;
        private NumericUpDown asnBitsCharStr;
        private Label label7;
        private NumericUpDown asnBitsOctStr;
        private Label label8;
        private NumericUpDown asnChanceOctStr;
        private NumericUpDown asnBitsInt32;
        private NumericUpDown asnBitsTag;
        private NumericUpDown asnBitsBitStr;
        private NumericUpDown asnBitsOpen;
        private NumericUpDown asnBitsObj;
        private Label label15;
        private Label label14;
        private Label label13;
        private Label label11;
        private Label label10;
        private NumericUpDown asnChanceInt32;
        private Label label9;
        private NumericUpDown asnChanceTag;
        private Label label16;
        private Label label12;
        private NumericUpDown asnChanceBitStr;
        private NumericUpDown asnChanceOpen;
        private NumericUpDown asnChanceObj;
        private NumericUpDown asnBitsLength;
        private NumericUpDown asnBitsEoc;
        private NumericUpDown asnBitsBool;
        private NumericUpDown asnBitsU32;
        private Label label23;
        private Label label22;
        private Label label21;
        private Label label19;
        private Label label18;
        private NumericUpDown asnChanceLength;
        private NumericUpDown asnChanceEoc;
        private Label label24;
        private Label label20;
        private NumericUpDown asnChanceBool;
        private NumericUpDown asnChanceU32;
        private NumericUpDown asnBitsGenTime;
        private Label label25;
        private NumericUpDown asnChanceGenTime;
        private Label label17;
        private NumericUpDown packetFuzzChance;
        private GroupBox groupBox2;
        private NumericUpDown reqBitsMisc;
        private NumericUpDown reqBitsKeys;
        private Label label40;
        private NumericUpDown reqChanceMisc;
        private Label label41;
        private NumericUpDown reqChanceKeys;
        private NumericUpDown reqBitsCert;
        private NumericUpDown reqBitsUser;
        private NumericUpDown reqBitsStrings;
        private Label label33;
        private Label label34;
        private Label label35;
        private Label label37;
        private Label label38;
        private NumericUpDown reqChanceCert;
        private Label label39;
        private NumericUpDown reqChanceUser;
        private NumericUpDown reqChanceStrings;
        private NumericUpDown reqBitsSC;
        private Label label27;
        private NumericUpDown reqBitsTGT;
        private NumericUpDown reqChanceTitle;
        private NumericUpDown reqBitsTicket;
        private NumericUpDown reqChanceTicket;
        private NumericUpDown reqBitsTitle;
        private Label TitleInfoLabel;
        private Label label26;
        private NumericUpDown reqChanceTGT;
        private Label label31;
        private Label label28;
        private Label label30;
        private Label label29;
        private NumericUpDown reqChanceSC;
        private GroupBox groupBox3;
        private CheckBox reqEnableAsPassport;
        private CheckBox reqEnablePcMachine;
        private CheckBox reqEnableXeTGS;
        private CheckBox reqEnableXeMachine;
        private CheckBox reqEnableAS;
        private Button allSetOff;
        private Button allSetNaughty;
        private Button allSetDoom;
        private GroupBox groupBox4;
        private Button allSetNice;
        private PictureBox pictureBox1;
        private TabControl tabControl1;
        private TabPage tabPage1;
        private DeterministicRandom randfuzz = null;

        public TabPage FuzzTabPage
        {
            get
            {
                return tabPage1;
            }
        }

        public KdcStressForm(): this(AuthClientBase.randfuzz)
        {
        }
        public KdcStressForm(DeterministicRandom randfuzz)
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
            this.randfuzz = randfuzz;
            Initialize();

            //add event handlers for asn fuzz change
            asnChanceCharStr.ValueChanged+=UpdateAsnFuzz;
            asnBitsCharStr.ValueChanged+=UpdateAsnFuzz;

            asnChanceOctStr.ValueChanged+=UpdateAsnFuzz;
            asnBitsOctStr.ValueChanged+=UpdateAsnFuzz;

            asnChanceInt32.ValueChanged+=UpdateAsnFuzz;
            asnBitsInt32.ValueChanged+=UpdateAsnFuzz;

            asnChanceTag.ValueChanged+=UpdateAsnFuzz;
            asnBitsTag.ValueChanged+=UpdateAsnFuzz;

            asnChanceBitStr.ValueChanged+=UpdateAsnFuzz;
            asnBitsBitStr.ValueChanged+=UpdateAsnFuzz;

            asnChanceOpen.ValueChanged+=UpdateAsnFuzz;
            asnBitsOpen.ValueChanged+=UpdateAsnFuzz;

            asnChanceObj.ValueChanged+=UpdateAsnFuzz;
            asnBitsObj.ValueChanged+=UpdateAsnFuzz;
            
            asnChanceLength.ValueChanged+=UpdateAsnFuzz;
            asnBitsLength.ValueChanged+=UpdateAsnFuzz;

            asnChanceEoc.ValueChanged+=UpdateAsnFuzz;
            asnBitsEoc.ValueChanged+=UpdateAsnFuzz;

            asnChanceBool.ValueChanged+=UpdateAsnFuzz;
            asnBitsBool.ValueChanged+=UpdateAsnFuzz;

            asnChanceU32.ValueChanged+=UpdateAsnFuzz;
            asnBitsU32.ValueChanged+=UpdateAsnFuzz;
            
            asnChanceGenTime.ValueChanged+=UpdateAsnFuzz;
            asnBitsGenTime.ValueChanged+=UpdateAsnFuzz;

            //add event handlers for kerb request fuzz change
            reqBitsMisc.ValueChanged+=UpdateKerbReqFuzz;
            reqChanceMisc.ValueChanged+=UpdateKerbReqFuzz;

            reqBitsKeys.ValueChanged+=UpdateKerbReqFuzz;
            reqChanceKeys.ValueChanged+=UpdateKerbReqFuzz;
            
            reqBitsCert.ValueChanged+=UpdateKerbReqFuzz;
            reqChanceCert.ValueChanged+=UpdateKerbReqFuzz;

            reqBitsUser.ValueChanged+=UpdateKerbReqFuzz;
            reqChanceUser.ValueChanged+=UpdateKerbReqFuzz;

            reqBitsStrings.ValueChanged+=UpdateKerbReqFuzz;
            reqChanceStrings.ValueChanged+=UpdateKerbReqFuzz;

            reqBitsSC.ValueChanged+=UpdateKerbReqFuzz;
            reqChanceSC.ValueChanged+=UpdateKerbReqFuzz;

            reqBitsTGT.ValueChanged+=UpdateKerbReqFuzz;
            reqChanceTGT.ValueChanged+=UpdateKerbReqFuzz;

            reqChanceTitle.ValueChanged+=UpdateKerbReqFuzz;
            reqChanceTicket.ValueChanged+=UpdateKerbReqFuzz;

            reqBitsTicket.ValueChanged+=UpdateKerbReqFuzz;
            reqBitsTitle.ValueChanged+=UpdateKerbReqFuzz;
            
            reqEnableAsPassport.CheckedChanged+=UpdateKerbReqFuzz;
            reqEnablePcMachine.CheckedChanged+=UpdateKerbReqFuzz;
            reqEnableXeTGS.CheckedChanged+=UpdateKerbReqFuzz;
            reqEnableXeMachine.CheckedChanged+=UpdateKerbReqFuzz;
            reqEnableAS.CheckedChanged+=UpdateKerbReqFuzz;
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.groupBoxSettings = new System.Windows.Forms.GroupBox();
            this.label17 = new System.Windows.Forms.Label();
            this.packetFuzzChance = new System.Windows.Forms.NumericUpDown();
            this.textStartIteration = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.btnSetRandomSeed = new System.Windows.Forms.Button();
            this.textRandomSeed = new System.Windows.Forms.TextBox();
            this.fuzzIterations = new System.Windows.Forms.NumericUpDown();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.asnBitsInt32 = new System.Windows.Forms.NumericUpDown();
            this.asnBitsLength = new System.Windows.Forms.NumericUpDown();
            this.asnBitsEoc = new System.Windows.Forms.NumericUpDown();
            this.asnBitsTag = new System.Windows.Forms.NumericUpDown();
            this.asnBitsBitStr = new System.Windows.Forms.NumericUpDown();
            this.asnBitsOctStr = new System.Windows.Forms.NumericUpDown();
            this.asnBitsGenTime = new System.Windows.Forms.NumericUpDown();
            this.asnBitsBool = new System.Windows.Forms.NumericUpDown();
            this.asnBitsU32 = new System.Windows.Forms.NumericUpDown();
            this.asnBitsOpen = new System.Windows.Forms.NumericUpDown();
            this.asnBitsObj = new System.Windows.Forms.NumericUpDown();
            this.asnBitsCharStr = new System.Windows.Forms.NumericUpDown();
            this.label23 = new System.Windows.Forms.Label();
            this.label15 = new System.Windows.Forms.Label();
            this.label22 = new System.Windows.Forms.Label();
            this.label14 = new System.Windows.Forms.Label();
            this.label7 = new System.Windows.Forms.Label();
            this.label21 = new System.Windows.Forms.Label();
            this.label13 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.label11 = new System.Windows.Forms.Label();
            this.label19 = new System.Windows.Forms.Label();
            this.label18 = new System.Windows.Forms.Label();
            this.asnChanceLength = new System.Windows.Forms.NumericUpDown();
            this.label10 = new System.Windows.Forms.Label();
            this.asnChanceEoc = new System.Windows.Forms.NumericUpDown();
            this.asnChanceInt32 = new System.Windows.Forms.NumericUpDown();
            this.label9 = new System.Windows.Forms.Label();
            this.asnChanceTag = new System.Windows.Forms.NumericUpDown();
            this.label25 = new System.Windows.Forms.Label();
            this.label24 = new System.Windows.Forms.Label();
            this.label20 = new System.Windows.Forms.Label();
            this.label8 = new System.Windows.Forms.Label();
            this.asnChanceGenTime = new System.Windows.Forms.NumericUpDown();
            this.label16 = new System.Windows.Forms.Label();
            this.asnChanceBool = new System.Windows.Forms.NumericUpDown();
            this.label12 = new System.Windows.Forms.Label();
            this.asnChanceU32 = new System.Windows.Forms.NumericUpDown();
            this.asnChanceBitStr = new System.Windows.Forms.NumericUpDown();
            this.asnChanceOpen = new System.Windows.Forms.NumericUpDown();
            this.label4 = new System.Windows.Forms.Label();
            this.asnChanceObj = new System.Windows.Forms.NumericUpDown();
            this.asnChanceOctStr = new System.Windows.Forms.NumericUpDown();
            this.asnChanceCharStr = new System.Windows.Forms.NumericUpDown();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.reqBitsMisc = new System.Windows.Forms.NumericUpDown();
            this.reqBitsKeys = new System.Windows.Forms.NumericUpDown();
            this.label40 = new System.Windows.Forms.Label();
            this.reqChanceMisc = new System.Windows.Forms.NumericUpDown();
            this.label41 = new System.Windows.Forms.Label();
            this.reqChanceKeys = new System.Windows.Forms.NumericUpDown();
            this.reqBitsCert = new System.Windows.Forms.NumericUpDown();
            this.reqBitsUser = new System.Windows.Forms.NumericUpDown();
            this.reqBitsStrings = new System.Windows.Forms.NumericUpDown();
            this.label33 = new System.Windows.Forms.Label();
            this.label34 = new System.Windows.Forms.Label();
            this.label35 = new System.Windows.Forms.Label();
            this.label37 = new System.Windows.Forms.Label();
            this.label38 = new System.Windows.Forms.Label();
            this.reqChanceCert = new System.Windows.Forms.NumericUpDown();
            this.label39 = new System.Windows.Forms.Label();
            this.reqChanceUser = new System.Windows.Forms.NumericUpDown();
            this.reqChanceStrings = new System.Windows.Forms.NumericUpDown();
            this.reqBitsSC = new System.Windows.Forms.NumericUpDown();
            this.label27 = new System.Windows.Forms.Label();
            this.reqBitsTGT = new System.Windows.Forms.NumericUpDown();
            this.reqChanceTitle = new System.Windows.Forms.NumericUpDown();
            this.reqBitsTicket = new System.Windows.Forms.NumericUpDown();
            this.reqChanceTicket = new System.Windows.Forms.NumericUpDown();
            this.reqBitsTitle = new System.Windows.Forms.NumericUpDown();
            this.TitleInfoLabel = new System.Windows.Forms.Label();
            this.label26 = new System.Windows.Forms.Label();
            this.reqChanceTGT = new System.Windows.Forms.NumericUpDown();
            this.label31 = new System.Windows.Forms.Label();
            this.label28 = new System.Windows.Forms.Label();
            this.label30 = new System.Windows.Forms.Label();
            this.label29 = new System.Windows.Forms.Label();
            this.reqChanceSC = new System.Windows.Forms.NumericUpDown();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.reqEnableAsPassport = new System.Windows.Forms.CheckBox();
            this.reqEnablePcMachine = new System.Windows.Forms.CheckBox();
            this.reqEnableXeTGS = new System.Windows.Forms.CheckBox();
            this.reqEnableXeMachine = new System.Windows.Forms.CheckBox();
            this.reqEnableAS = new System.Windows.Forms.CheckBox();
            this.allSetOff = new System.Windows.Forms.Button();
            this.allSetNaughty = new System.Windows.Forms.Button();
            this.allSetDoom = new System.Windows.Forms.Button();
            this.groupBox4 = new System.Windows.Forms.GroupBox();
            this.allSetNice = new System.Windows.Forms.Button();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.groupBoxSettings.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.packetFuzzChance)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.fuzzIterations)).BeginInit();
            this.groupBox1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsInt32)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsLength)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsEoc)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsTag)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsBitStr)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsOctStr)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsGenTime)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsBool)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsU32)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsOpen)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsObj)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsCharStr)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceLength)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceEoc)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceInt32)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceTag)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceGenTime)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceBool)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceU32)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceBitStr)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceOpen)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceObj)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceOctStr)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceCharStr)).BeginInit();
            this.groupBox2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsMisc)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsKeys)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceMisc)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceKeys)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsCert)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsUser)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsStrings)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceCert)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceUser)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceStrings)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsSC)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsTGT)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceTitle)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsTicket)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceTicket)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsTitle)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceTGT)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceSC)).BeginInit();
            this.groupBox3.SuspendLayout();
            this.groupBox4.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.tabControl1.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.SuspendLayout();
            // 
            // groupBoxSettings
            // 
            this.groupBoxSettings.Controls.Add(this.label17);
            this.groupBoxSettings.Controls.Add(this.packetFuzzChance);
            this.groupBoxSettings.Controls.Add(this.textStartIteration);
            this.groupBoxSettings.Controls.Add(this.label3);
            this.groupBoxSettings.Controls.Add(this.btnSetRandomSeed);
            this.groupBoxSettings.Controls.Add(this.textRandomSeed);
            this.groupBoxSettings.Controls.Add(this.fuzzIterations);
            this.groupBoxSettings.Controls.Add(this.label1);
            this.groupBoxSettings.Controls.Add(this.label2);
            this.groupBoxSettings.Location = new System.Drawing.Point(358, 6);
            this.groupBoxSettings.Name = "groupBoxSettings";
            this.groupBoxSettings.Size = new System.Drawing.Size(209, 118);
            this.groupBoxSettings.TabIndex = 0;
            this.groupBoxSettings.TabStop = false;
            this.groupBoxSettings.Text = "Packet";
            // 
            // label17
            // 
            this.label17.AutoSize = true;
            this.label17.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label17.Location = new System.Drawing.Point(99, 15);
            this.label17.Name = "label17";
            this.label17.Size = new System.Drawing.Size(54, 13);
            this.label17.TabIndex = 6;
            this.label17.Text = "% chance";
            // 
            // packetFuzzChance
            // 
            this.packetFuzzChance.DecimalPlaces = 1;
            this.packetFuzzChance.Location = new System.Drawing.Point(100, 32);
            this.packetFuzzChance.Name = "packetFuzzChance";
            this.packetFuzzChance.Size = new System.Drawing.Size(67, 20);
            this.packetFuzzChance.TabIndex = 6;
            this.packetFuzzChance.ValueChanged += new System.EventHandler(this.fuzzIterations_ValueChanged);
            // 
            // textStartIteration
            // 
            this.textStartIteration.Location = new System.Drawing.Point(8, 69);
            this.textStartIteration.Name = "textStartIteration";
            this.textStartIteration.Size = new System.Drawing.Size(72, 20);
            this.textStartIteration.TabIndex = 5;
            this.textStartIteration.Text = "0";
            this.textStartIteration.TextChanged += new System.EventHandler(this.textStartIteration_TextChanged);
            // 
            // label3
            // 
            this.label3.Location = new System.Drawing.Point(8, 53);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(77, 13);
            this.label3.TabIndex = 4;
            this.label3.Text = "Start iteration:";
            // 
            // btnSetRandomSeed
            // 
            this.btnSetRandomSeed.Location = new System.Drawing.Point(96, 93);
            this.btnSetRandomSeed.Name = "btnSetRandomSeed";
            this.btnSetRandomSeed.Size = new System.Drawing.Size(96, 20);
            this.btnSetRandomSeed.TabIndex = 3;
            this.btnSetRandomSeed.Text = "Use Timer Ticks";
            this.btnSetRandomSeed.Click += new System.EventHandler(this.btnSetRandomSeed_Click);
            // 
            // textRandomSeed
            // 
            this.textRandomSeed.Location = new System.Drawing.Point(100, 70);
            this.textRandomSeed.Name = "textRandomSeed";
            this.textRandomSeed.Size = new System.Drawing.Size(83, 20);
            this.textRandomSeed.TabIndex = 2;
            this.textRandomSeed.Text = "0";
            this.textRandomSeed.TextChanged += new System.EventHandler(this.textRandomSeed_TextChanged);
            // 
            // fuzzIterations
            // 
            this.fuzzIterations.Location = new System.Drawing.Point(8, 32);
            this.fuzzIterations.Maximum = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            this.fuzzIterations.Name = "fuzzIterations";
            this.fuzzIterations.Size = new System.Drawing.Size(72, 20);
            this.fuzzIterations.TabIndex = 1;
            this.fuzzIterations.ThousandsSeparator = true;
            this.fuzzIterations.ValueChanged += new System.EventHandler(this.fuzzIterations_ValueChanged);
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(8, 16);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(84, 16);
            this.label1.TabIndex = 0;
            this.label1.Text = "Fuzz iterations:";
            // 
            // label2
            // 
            this.label2.Location = new System.Drawing.Point(99, 53);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(93, 17);
            this.label2.TabIndex = 1;
            this.label2.Text = "Random seed:";
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.asnBitsInt32);
            this.groupBox1.Controls.Add(this.asnBitsLength);
            this.groupBox1.Controls.Add(this.asnBitsEoc);
            this.groupBox1.Controls.Add(this.asnBitsTag);
            this.groupBox1.Controls.Add(this.asnBitsBitStr);
            this.groupBox1.Controls.Add(this.asnBitsOctStr);
            this.groupBox1.Controls.Add(this.asnBitsGenTime);
            this.groupBox1.Controls.Add(this.asnBitsBool);
            this.groupBox1.Controls.Add(this.asnBitsU32);
            this.groupBox1.Controls.Add(this.asnBitsOpen);
            this.groupBox1.Controls.Add(this.asnBitsObj);
            this.groupBox1.Controls.Add(this.asnBitsCharStr);
            this.groupBox1.Controls.Add(this.label23);
            this.groupBox1.Controls.Add(this.label15);
            this.groupBox1.Controls.Add(this.label22);
            this.groupBox1.Controls.Add(this.label14);
            this.groupBox1.Controls.Add(this.label7);
            this.groupBox1.Controls.Add(this.label21);
            this.groupBox1.Controls.Add(this.label13);
            this.groupBox1.Controls.Add(this.label6);
            this.groupBox1.Controls.Add(this.label5);
            this.groupBox1.Controls.Add(this.label11);
            this.groupBox1.Controls.Add(this.label19);
            this.groupBox1.Controls.Add(this.label18);
            this.groupBox1.Controls.Add(this.asnChanceLength);
            this.groupBox1.Controls.Add(this.label10);
            this.groupBox1.Controls.Add(this.asnChanceEoc);
            this.groupBox1.Controls.Add(this.asnChanceInt32);
            this.groupBox1.Controls.Add(this.label9);
            this.groupBox1.Controls.Add(this.asnChanceTag);
            this.groupBox1.Controls.Add(this.label25);
            this.groupBox1.Controls.Add(this.label24);
            this.groupBox1.Controls.Add(this.label20);
            this.groupBox1.Controls.Add(this.label8);
            this.groupBox1.Controls.Add(this.asnChanceGenTime);
            this.groupBox1.Controls.Add(this.label16);
            this.groupBox1.Controls.Add(this.asnChanceBool);
            this.groupBox1.Controls.Add(this.label12);
            this.groupBox1.Controls.Add(this.asnChanceU32);
            this.groupBox1.Controls.Add(this.asnChanceBitStr);
            this.groupBox1.Controls.Add(this.asnChanceOpen);
            this.groupBox1.Controls.Add(this.label4);
            this.groupBox1.Controls.Add(this.asnChanceObj);
            this.groupBox1.Controls.Add(this.asnChanceOctStr);
            this.groupBox1.Controls.Add(this.asnChanceCharStr);
            this.groupBox1.Location = new System.Drawing.Point(6, 6);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(346, 227);
            this.groupBox1.TabIndex = 1;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "AsnData";
            // 
            // asnBitsInt32
            // 
            this.asnBitsInt32.Location = new System.Drawing.Point(269, 55);
            this.asnBitsInt32.Maximum = new decimal(new int[] {
            32,
            0,
            0,
            0});
            this.asnBitsInt32.Name = "asnBitsInt32";
            this.asnBitsInt32.Size = new System.Drawing.Size(67, 20);
            this.asnBitsInt32.TabIndex = 5;
            this.asnBitsInt32.ValueChanged += new System.EventHandler(this.numericUpDown2_ValueChanged);
            // 
            // asnBitsLength
            // 
            this.asnBitsLength.Location = new System.Drawing.Point(269, 197);
            this.asnBitsLength.Maximum = new decimal(new int[] {
            32,
            0,
            0,
            0});
            this.asnBitsLength.Name = "asnBitsLength";
            this.asnBitsLength.Size = new System.Drawing.Size(67, 20);
            this.asnBitsLength.TabIndex = 5;
            this.asnBitsLength.ValueChanged += new System.EventHandler(this.numericUpDown2_ValueChanged);
            // 
            // asnBitsEoc
            // 
            this.asnBitsEoc.Location = new System.Drawing.Point(269, 125);
            this.asnBitsEoc.Maximum = new decimal(new int[] {
            32,
            0,
            0,
            0});
            this.asnBitsEoc.Name = "asnBitsEoc";
            this.asnBitsEoc.Size = new System.Drawing.Size(67, 20);
            this.asnBitsEoc.TabIndex = 5;
            this.asnBitsEoc.ValueChanged += new System.EventHandler(this.numericUpDown2_ValueChanged);
            // 
            // asnBitsTag
            // 
            this.asnBitsTag.Location = new System.Drawing.Point(123, 125);
            this.asnBitsTag.Maximum = new decimal(new int[] {
            32,
            0,
            0,
            0});
            this.asnBitsTag.Name = "asnBitsTag";
            this.asnBitsTag.Size = new System.Drawing.Size(67, 20);
            this.asnBitsTag.TabIndex = 5;
            this.asnBitsTag.ValueChanged += new System.EventHandler(this.numericUpDown2_ValueChanged);
            // 
            // asnBitsBitStr
            // 
            this.asnBitsBitStr.Location = new System.Drawing.Point(196, 55);
            this.asnBitsBitStr.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.asnBitsBitStr.Name = "asnBitsBitStr";
            this.asnBitsBitStr.Size = new System.Drawing.Size(67, 20);
            this.asnBitsBitStr.TabIndex = 5;
            this.asnBitsBitStr.ValueChanged += new System.EventHandler(this.numericUpDown2_ValueChanged);
            // 
            // asnBitsOctStr
            // 
            this.asnBitsOctStr.Location = new System.Drawing.Point(123, 55);
            this.asnBitsOctStr.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.asnBitsOctStr.Name = "asnBitsOctStr";
            this.asnBitsOctStr.Size = new System.Drawing.Size(67, 20);
            this.asnBitsOctStr.TabIndex = 5;
            this.asnBitsOctStr.ValueChanged += new System.EventHandler(this.numericUpDown2_ValueChanged);
            // 
            // asnBitsGenTime
            // 
            this.asnBitsGenTime.Location = new System.Drawing.Point(196, 125);
            this.asnBitsGenTime.Maximum = new decimal(new int[] {
            128,
            0,
            0,
            0});
            this.asnBitsGenTime.Name = "asnBitsGenTime";
            this.asnBitsGenTime.Size = new System.Drawing.Size(67, 20);
            this.asnBitsGenTime.TabIndex = 5;
            this.asnBitsGenTime.ValueChanged += new System.EventHandler(this.numericUpDown2_ValueChanged_1);
            // 
            // asnBitsBool
            // 
            this.asnBitsBool.Location = new System.Drawing.Point(123, 197);
            this.asnBitsBool.Maximum = new decimal(new int[] {
            8,
            0,
            0,
            0});
            this.asnBitsBool.Name = "asnBitsBool";
            this.asnBitsBool.Size = new System.Drawing.Size(67, 20);
            this.asnBitsBool.TabIndex = 5;
            this.asnBitsBool.ValueChanged += new System.EventHandler(this.numericUpDown2_ValueChanged_1);
            // 
            // asnBitsU32
            // 
            this.asnBitsU32.Location = new System.Drawing.Point(50, 197);
            this.asnBitsU32.Maximum = new decimal(new int[] {
            32,
            0,
            0,
            0});
            this.asnBitsU32.Name = "asnBitsU32";
            this.asnBitsU32.Size = new System.Drawing.Size(67, 20);
            this.asnBitsU32.TabIndex = 5;
            // 
            // asnBitsOpen
            // 
            this.asnBitsOpen.Location = new System.Drawing.Point(50, 125);
            this.asnBitsOpen.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.asnBitsOpen.Name = "asnBitsOpen";
            this.asnBitsOpen.Size = new System.Drawing.Size(67, 20);
            this.asnBitsOpen.TabIndex = 5;
            // 
            // asnBitsObj
            // 
            this.asnBitsObj.Location = new System.Drawing.Point(196, 197);
            this.asnBitsObj.Maximum = new decimal(new int[] {
            32,
            0,
            0,
            0});
            this.asnBitsObj.Name = "asnBitsObj";
            this.asnBitsObj.Size = new System.Drawing.Size(67, 20);
            this.asnBitsObj.TabIndex = 5;
            // 
            // asnBitsCharStr
            // 
            this.asnBitsCharStr.Location = new System.Drawing.Point(50, 55);
            this.asnBitsCharStr.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.asnBitsCharStr.Name = "asnBitsCharStr";
            this.asnBitsCharStr.Size = new System.Drawing.Size(67, 20);
            this.asnBitsCharStr.TabIndex = 5;
            // 
            // label23
            // 
            this.label23.AutoSize = true;
            this.label23.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label23.Location = new System.Drawing.Point(4, 200);
            this.label23.Name = "label23";
            this.label23.Size = new System.Drawing.Size(40, 12);
            this.label23.TabIndex = 4;
            this.label23.Text = "max bits";
            // 
            // label15
            // 
            this.label15.AutoSize = true;
            this.label15.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label15.Location = new System.Drawing.Point(4, 128);
            this.label15.Name = "label15";
            this.label15.Size = new System.Drawing.Size(40, 12);
            this.label15.TabIndex = 4;
            this.label15.Text = "max bits";
            // 
            // label22
            // 
            this.label22.AutoSize = true;
            this.label22.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label22.Location = new System.Drawing.Point(4, 158);
            this.label22.Name = "label22";
            this.label22.Size = new System.Drawing.Size(23, 12);
            this.label22.TabIndex = 3;
            this.label22.Text = "func";
            this.label22.Click += new System.EventHandler(this.label6_Click);
            // 
            // label14
            // 
            this.label14.AutoSize = true;
            this.label14.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label14.Location = new System.Drawing.Point(4, 86);
            this.label14.Name = "label14";
            this.label14.Size = new System.Drawing.Size(23, 12);
            this.label14.TabIndex = 3;
            this.label14.Text = "func";
            this.label14.Click += new System.EventHandler(this.label6_Click);
            // 
            // label7
            // 
            this.label7.AutoSize = true;
            this.label7.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label7.Location = new System.Drawing.Point(4, 58);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(40, 12);
            this.label7.TabIndex = 4;
            this.label7.Text = "max bits";
            // 
            // label21
            // 
            this.label21.AutoSize = true;
            this.label21.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label21.Location = new System.Drawing.Point(4, 178);
            this.label21.Name = "label21";
            this.label21.Size = new System.Drawing.Size(45, 12);
            this.label21.TabIndex = 2;
            this.label21.Text = "% chance";
            // 
            // label13
            // 
            this.label13.AutoSize = true;
            this.label13.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label13.Location = new System.Drawing.Point(4, 106);
            this.label13.Name = "label13";
            this.label13.Size = new System.Drawing.Size(45, 12);
            this.label13.TabIndex = 2;
            this.label13.Text = "% chance";
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label6.Location = new System.Drawing.Point(4, 16);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(23, 12);
            this.label6.TabIndex = 3;
            this.label6.Text = "func";
            this.label6.Click += new System.EventHandler(this.label6_Click);
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label5.Location = new System.Drawing.Point(4, 36);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(45, 12);
            this.label5.TabIndex = 2;
            this.label5.Text = "% chance";
            // 
            // label11
            // 
            this.label11.AutoSize = true;
            this.label11.Location = new System.Drawing.Point(266, 16);
            this.label11.Name = "label11";
            this.label11.Size = new System.Drawing.Size(31, 13);
            this.label11.TabIndex = 1;
            this.label11.Text = "Int32";
            this.label11.Click += new System.EventHandler(this.label8_Click);
            // 
            // label19
            // 
            this.label19.AutoSize = true;
            this.label19.Location = new System.Drawing.Point(266, 158);
            this.label19.Name = "label19";
            this.label19.Size = new System.Drawing.Size(40, 13);
            this.label19.TabIndex = 1;
            this.label19.Text = "Length";
            this.label19.Click += new System.EventHandler(this.label8_Click);
            // 
            // label18
            // 
            this.label18.AutoSize = true;
            this.label18.Location = new System.Drawing.Point(266, 86);
            this.label18.Name = "label18";
            this.label18.Size = new System.Drawing.Size(29, 13);
            this.label18.TabIndex = 1;
            this.label18.Text = "EOC";
            this.label18.Click += new System.EventHandler(this.label8_Click);
            // 
            // asnChanceLength
            // 
            this.asnChanceLength.DecimalPlaces = 3;
            this.asnChanceLength.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceLength.Location = new System.Drawing.Point(269, 175);
            this.asnChanceLength.Name = "asnChanceLength";
            this.asnChanceLength.Size = new System.Drawing.Size(67, 20);
            this.asnChanceLength.TabIndex = 0;
            this.asnChanceLength.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged);
            // 
            // label10
            // 
            this.label10.AutoSize = true;
            this.label10.Location = new System.Drawing.Point(120, 86);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(26, 13);
            this.label10.TabIndex = 1;
            this.label10.Text = "Tag";
            this.label10.Click += new System.EventHandler(this.label8_Click);
            // 
            // asnChanceEoc
            // 
            this.asnChanceEoc.DecimalPlaces = 3;
            this.asnChanceEoc.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceEoc.Location = new System.Drawing.Point(269, 103);
            this.asnChanceEoc.Name = "asnChanceEoc";
            this.asnChanceEoc.Size = new System.Drawing.Size(67, 20);
            this.asnChanceEoc.TabIndex = 0;
            this.asnChanceEoc.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged);
            // 
            // asnChanceInt32
            // 
            this.asnChanceInt32.DecimalPlaces = 3;
            this.asnChanceInt32.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceInt32.Location = new System.Drawing.Point(269, 33);
            this.asnChanceInt32.Name = "asnChanceInt32";
            this.asnChanceInt32.Size = new System.Drawing.Size(67, 20);
            this.asnChanceInt32.TabIndex = 0;
            this.asnChanceInt32.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged);
            // 
            // label9
            // 
            this.label9.AutoSize = true;
            this.label9.Location = new System.Drawing.Point(193, 16);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(32, 13);
            this.label9.TabIndex = 1;
            this.label9.Text = "BitStr";
            this.label9.Click += new System.EventHandler(this.label8_Click);
            // 
            // asnChanceTag
            // 
            this.asnChanceTag.DecimalPlaces = 3;
            this.asnChanceTag.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceTag.Location = new System.Drawing.Point(123, 103);
            this.asnChanceTag.Name = "asnChanceTag";
            this.asnChanceTag.Size = new System.Drawing.Size(67, 20);
            this.asnChanceTag.TabIndex = 0;
            this.asnChanceTag.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged);
            // 
            // label25
            // 
            this.label25.AutoSize = true;
            this.label25.Location = new System.Drawing.Point(193, 86);
            this.label25.Name = "label25";
            this.label25.Size = new System.Drawing.Size(50, 13);
            this.label25.TabIndex = 1;
            this.label25.Text = "GenTime";
            this.label25.Click += new System.EventHandler(this.label24_Click);
            // 
            // label24
            // 
            this.label24.AutoSize = true;
            this.label24.Location = new System.Drawing.Point(120, 158);
            this.label24.Name = "label24";
            this.label24.Size = new System.Drawing.Size(28, 13);
            this.label24.TabIndex = 1;
            this.label24.Text = "Bool";
            this.label24.Click += new System.EventHandler(this.label24_Click);
            // 
            // label20
            // 
            this.label20.AutoSize = true;
            this.label20.Location = new System.Drawing.Point(47, 158);
            this.label20.Name = "label20";
            this.label20.Size = new System.Drawing.Size(27, 13);
            this.label20.TabIndex = 1;
            this.label20.Text = "U32";
            // 
            // label8
            // 
            this.label8.AutoSize = true;
            this.label8.Location = new System.Drawing.Point(120, 16);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(37, 13);
            this.label8.TabIndex = 1;
            this.label8.Text = "OctStr";
            this.label8.Click += new System.EventHandler(this.label8_Click);
            // 
            // asnChanceGenTime
            // 
            this.asnChanceGenTime.DecimalPlaces = 3;
            this.asnChanceGenTime.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceGenTime.Location = new System.Drawing.Point(196, 103);
            this.asnChanceGenTime.Name = "asnChanceGenTime";
            this.asnChanceGenTime.Size = new System.Drawing.Size(67, 20);
            this.asnChanceGenTime.TabIndex = 0;
            this.asnChanceGenTime.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged_1);
            // 
            // label16
            // 
            this.label16.AutoSize = true;
            this.label16.Location = new System.Drawing.Point(47, 86);
            this.label16.Name = "label16";
            this.label16.Size = new System.Drawing.Size(57, 13);
            this.label16.TabIndex = 1;
            this.label16.Text = "OpenType";
            // 
            // asnChanceBool
            // 
            this.asnChanceBool.DecimalPlaces = 3;
            this.asnChanceBool.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceBool.Location = new System.Drawing.Point(123, 175);
            this.asnChanceBool.Name = "asnChanceBool";
            this.asnChanceBool.Size = new System.Drawing.Size(67, 20);
            this.asnChanceBool.TabIndex = 0;
            this.asnChanceBool.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged_1);
            // 
            // label12
            // 
            this.label12.AutoSize = true;
            this.label12.Location = new System.Drawing.Point(193, 158);
            this.label12.Name = "label12";
            this.label12.Size = new System.Drawing.Size(44, 13);
            this.label12.TabIndex = 1;
            this.label12.Text = "ObjIden";
            // 
            // asnChanceU32
            // 
            this.asnChanceU32.DecimalPlaces = 3;
            this.asnChanceU32.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceU32.Location = new System.Drawing.Point(50, 175);
            this.asnChanceU32.Name = "asnChanceU32";
            this.asnChanceU32.Size = new System.Drawing.Size(67, 20);
            this.asnChanceU32.TabIndex = 0;
            // 
            // asnChanceBitStr
            // 
            this.asnChanceBitStr.DecimalPlaces = 3;
            this.asnChanceBitStr.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceBitStr.Location = new System.Drawing.Point(196, 33);
            this.asnChanceBitStr.Name = "asnChanceBitStr";
            this.asnChanceBitStr.Size = new System.Drawing.Size(67, 20);
            this.asnChanceBitStr.TabIndex = 0;
            this.asnChanceBitStr.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged);
            // 
            // asnChanceOpen
            // 
            this.asnChanceOpen.DecimalPlaces = 3;
            this.asnChanceOpen.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceOpen.Location = new System.Drawing.Point(50, 103);
            this.asnChanceOpen.Name = "asnChanceOpen";
            this.asnChanceOpen.Size = new System.Drawing.Size(67, 20);
            this.asnChanceOpen.TabIndex = 0;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(47, 16);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(42, 13);
            this.label4.TabIndex = 1;
            this.label4.Text = "CharStr";
            // 
            // asnChanceObj
            // 
            this.asnChanceObj.DecimalPlaces = 3;
            this.asnChanceObj.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceObj.Location = new System.Drawing.Point(196, 175);
            this.asnChanceObj.Name = "asnChanceObj";
            this.asnChanceObj.Size = new System.Drawing.Size(67, 20);
            this.asnChanceObj.TabIndex = 0;
            // 
            // asnChanceOctStr
            // 
            this.asnChanceOctStr.DecimalPlaces = 3;
            this.asnChanceOctStr.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceOctStr.Location = new System.Drawing.Point(123, 33);
            this.asnChanceOctStr.Name = "asnChanceOctStr";
            this.asnChanceOctStr.Size = new System.Drawing.Size(67, 20);
            this.asnChanceOctStr.TabIndex = 0;
            this.asnChanceOctStr.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged);
            // 
            // asnChanceCharStr
            // 
            this.asnChanceCharStr.DecimalPlaces = 3;
            this.asnChanceCharStr.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.asnChanceCharStr.Location = new System.Drawing.Point(50, 33);
            this.asnChanceCharStr.Name = "asnChanceCharStr";
            this.asnChanceCharStr.Size = new System.Drawing.Size(67, 20);
            this.asnChanceCharStr.TabIndex = 0;
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.reqBitsMisc);
            this.groupBox2.Controls.Add(this.reqBitsKeys);
            this.groupBox2.Controls.Add(this.label40);
            this.groupBox2.Controls.Add(this.reqChanceMisc);
            this.groupBox2.Controls.Add(this.label41);
            this.groupBox2.Controls.Add(this.reqChanceKeys);
            this.groupBox2.Controls.Add(this.reqBitsCert);
            this.groupBox2.Controls.Add(this.reqBitsUser);
            this.groupBox2.Controls.Add(this.reqBitsStrings);
            this.groupBox2.Controls.Add(this.label33);
            this.groupBox2.Controls.Add(this.label34);
            this.groupBox2.Controls.Add(this.label35);
            this.groupBox2.Controls.Add(this.label37);
            this.groupBox2.Controls.Add(this.label38);
            this.groupBox2.Controls.Add(this.reqChanceCert);
            this.groupBox2.Controls.Add(this.label39);
            this.groupBox2.Controls.Add(this.reqChanceUser);
            this.groupBox2.Controls.Add(this.reqChanceStrings);
            this.groupBox2.Controls.Add(this.reqBitsSC);
            this.groupBox2.Controls.Add(this.label27);
            this.groupBox2.Controls.Add(this.reqBitsTGT);
            this.groupBox2.Controls.Add(this.reqChanceTitle);
            this.groupBox2.Controls.Add(this.reqBitsTicket);
            this.groupBox2.Controls.Add(this.reqChanceTicket);
            this.groupBox2.Controls.Add(this.reqBitsTitle);
            this.groupBox2.Controls.Add(this.TitleInfoLabel);
            this.groupBox2.Controls.Add(this.label26);
            this.groupBox2.Controls.Add(this.reqChanceTGT);
            this.groupBox2.Controls.Add(this.label31);
            this.groupBox2.Controls.Add(this.label28);
            this.groupBox2.Controls.Add(this.label30);
            this.groupBox2.Controls.Add(this.label29);
            this.groupBox2.Controls.Add(this.reqChanceSC);
            this.groupBox2.Location = new System.Drawing.Point(6, 239);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(418, 158);
            this.groupBox2.TabIndex = 2;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "BuildRequest Types";
            // 
            // reqBitsMisc
            // 
            this.reqBitsMisc.Location = new System.Drawing.Point(344, 129);
            this.reqBitsMisc.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsMisc.Name = "reqBitsMisc";
            this.reqBitsMisc.Size = new System.Drawing.Size(67, 20);
            this.reqBitsMisc.TabIndex = 40;
            // 
            // reqBitsKeys
            // 
            this.reqBitsKeys.Location = new System.Drawing.Point(271, 129);
            this.reqBitsKeys.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsKeys.Name = "reqBitsKeys";
            this.reqBitsKeys.Size = new System.Drawing.Size(67, 20);
            this.reqBitsKeys.TabIndex = 41;
            // 
            // label40
            // 
            this.label40.AutoSize = true;
            this.label40.Location = new System.Drawing.Point(341, 90);
            this.label40.Name = "label40";
            this.label40.Size = new System.Drawing.Size(29, 13);
            this.label40.TabIndex = 39;
            this.label40.Text = "Misc";
            // 
            // reqChanceMisc
            // 
            this.reqChanceMisc.DecimalPlaces = 1;
            this.reqChanceMisc.Location = new System.Drawing.Point(344, 107);
            this.reqChanceMisc.Name = "reqChanceMisc";
            this.reqChanceMisc.Size = new System.Drawing.Size(67, 20);
            this.reqChanceMisc.TabIndex = 36;
            // 
            // label41
            // 
            this.label41.AutoSize = true;
            this.label41.Location = new System.Drawing.Point(268, 90);
            this.label41.Name = "label41";
            this.label41.Size = new System.Drawing.Size(30, 13);
            this.label41.TabIndex = 38;
            this.label41.Text = "Keys";
            // 
            // reqChanceKeys
            // 
            this.reqChanceKeys.DecimalPlaces = 1;
            this.reqChanceKeys.Location = new System.Drawing.Point(271, 107);
            this.reqChanceKeys.Name = "reqChanceKeys";
            this.reqChanceKeys.Size = new System.Drawing.Size(67, 20);
            this.reqChanceKeys.TabIndex = 37;
            // 
            // reqBitsCert
            // 
            this.reqBitsCert.Location = new System.Drawing.Point(125, 129);
            this.reqBitsCert.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsCert.Name = "reqBitsCert";
            this.reqBitsCert.Size = new System.Drawing.Size(67, 20);
            this.reqBitsCert.TabIndex = 32;
            // 
            // reqBitsUser
            // 
            this.reqBitsUser.Location = new System.Drawing.Point(52, 129);
            this.reqBitsUser.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsUser.Name = "reqBitsUser";
            this.reqBitsUser.Size = new System.Drawing.Size(67, 20);
            this.reqBitsUser.TabIndex = 35;
            // 
            // reqBitsStrings
            // 
            this.reqBitsStrings.Location = new System.Drawing.Point(198, 129);
            this.reqBitsStrings.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsStrings.Name = "reqBitsStrings";
            this.reqBitsStrings.Size = new System.Drawing.Size(67, 20);
            this.reqBitsStrings.TabIndex = 34;
            // 
            // label33
            // 
            this.label33.AutoSize = true;
            this.label33.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label33.Location = new System.Drawing.Point(6, 132);
            this.label33.Name = "label33";
            this.label33.Size = new System.Drawing.Size(40, 12);
            this.label33.TabIndex = 31;
            this.label33.Text = "max bits";
            // 
            // label34
            // 
            this.label34.AutoSize = true;
            this.label34.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label34.Location = new System.Drawing.Point(6, 90);
            this.label34.Name = "label34";
            this.label34.Size = new System.Drawing.Size(31, 12);
            this.label34.TabIndex = 30;
            this.label34.Text = "param";
            // 
            // label35
            // 
            this.label35.AutoSize = true;
            this.label35.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label35.Location = new System.Drawing.Point(6, 110);
            this.label35.Name = "label35";
            this.label35.Size = new System.Drawing.Size(45, 12);
            this.label35.TabIndex = 29;
            this.label35.Text = "% chance";
            // 
            // label37
            // 
            this.label37.AutoSize = true;
            this.label37.Location = new System.Drawing.Point(122, 90);
            this.label37.Name = "label37";
            this.label37.Size = new System.Drawing.Size(26, 13);
            this.label37.TabIndex = 26;
            this.label37.Text = "Cert";
            // 
            // label38
            // 
            this.label38.AutoSize = true;
            this.label38.Location = new System.Drawing.Point(49, 90);
            this.label38.Name = "label38";
            this.label38.Size = new System.Drawing.Size(29, 13);
            this.label38.TabIndex = 27;
            this.label38.Text = "User";
            // 
            // reqChanceCert
            // 
            this.reqChanceCert.DecimalPlaces = 1;
            this.reqChanceCert.Location = new System.Drawing.Point(125, 107);
            this.reqChanceCert.Name = "reqChanceCert";
            this.reqChanceCert.Size = new System.Drawing.Size(67, 20);
            this.reqChanceCert.TabIndex = 21;
            // 
            // label39
            // 
            this.label39.AutoSize = true;
            this.label39.Location = new System.Drawing.Point(195, 90);
            this.label39.Name = "label39";
            this.label39.Size = new System.Drawing.Size(39, 13);
            this.label39.TabIndex = 25;
            this.label39.Text = "Strings";
            // 
            // reqChanceUser
            // 
            this.reqChanceUser.DecimalPlaces = 1;
            this.reqChanceUser.Location = new System.Drawing.Point(52, 107);
            this.reqChanceUser.Name = "reqChanceUser";
            this.reqChanceUser.Size = new System.Drawing.Size(67, 20);
            this.reqChanceUser.TabIndex = 24;
            // 
            // reqChanceStrings
            // 
            this.reqChanceStrings.DecimalPlaces = 1;
            this.reqChanceStrings.Location = new System.Drawing.Point(198, 107);
            this.reqChanceStrings.Name = "reqChanceStrings";
            this.reqChanceStrings.Size = new System.Drawing.Size(67, 20);
            this.reqChanceStrings.TabIndex = 23;
            // 
            // reqBitsSC
            // 
            this.reqBitsSC.Location = new System.Drawing.Point(271, 55);
            this.reqBitsSC.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsSC.Name = "reqBitsSC";
            this.reqBitsSC.Size = new System.Drawing.Size(67, 20);
            this.reqBitsSC.TabIndex = 18;
            // 
            // label27
            // 
            this.label27.AutoSize = true;
            this.label27.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label27.Location = new System.Drawing.Point(6, 16);
            this.label27.Name = "label27";
            this.label27.Size = new System.Drawing.Size(31, 12);
            this.label27.TabIndex = 15;
            this.label27.Text = "param";
            // 
            // reqBitsTGT
            // 
            this.reqBitsTGT.Location = new System.Drawing.Point(125, 55);
            this.reqBitsTGT.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsTGT.Name = "reqBitsTGT";
            this.reqBitsTGT.Size = new System.Drawing.Size(67, 20);
            this.reqBitsTGT.TabIndex = 17;
            this.reqBitsTGT.ValueChanged += new System.EventHandler(this.reqBitsTGT_ValueChanged);
            // 
            // reqChanceTitle
            // 
            this.reqChanceTitle.DecimalPlaces = 1;
            this.reqChanceTitle.Location = new System.Drawing.Point(198, 33);
            this.reqChanceTitle.Name = "reqChanceTitle";
            this.reqChanceTitle.Size = new System.Drawing.Size(67, 20);
            this.reqChanceTitle.TabIndex = 8;
            // 
            // reqBitsTicket
            // 
            this.reqBitsTicket.Location = new System.Drawing.Point(52, 55);
            this.reqBitsTicket.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsTicket.Name = "reqBitsTicket";
            this.reqBitsTicket.Size = new System.Drawing.Size(67, 20);
            this.reqBitsTicket.TabIndex = 20;
            // 
            // reqChanceTicket
            // 
            this.reqChanceTicket.DecimalPlaces = 1;
            this.reqChanceTicket.Location = new System.Drawing.Point(52, 33);
            this.reqChanceTicket.Name = "reqChanceTicket";
            this.reqChanceTicket.Size = new System.Drawing.Size(67, 20);
            this.reqChanceTicket.TabIndex = 9;
            // 
            // reqBitsTitle
            // 
            this.reqBitsTitle.Location = new System.Drawing.Point(198, 55);
            this.reqBitsTitle.Maximum = new decimal(new int[] {
            256,
            0,
            0,
            0});
            this.reqBitsTitle.Name = "reqBitsTitle";
            this.reqBitsTitle.Size = new System.Drawing.Size(67, 20);
            this.reqBitsTitle.TabIndex = 19;
            // 
            // TitleInfoLabel
            // 
            this.TitleInfoLabel.AutoSize = true;
            this.TitleInfoLabel.Location = new System.Drawing.Point(195, 16);
            this.TitleInfoLabel.Name = "TitleInfoLabel";
            this.TitleInfoLabel.Size = new System.Drawing.Size(45, 13);
            this.TitleInfoLabel.TabIndex = 10;
            this.TitleInfoLabel.Text = "TitleInfo";
            // 
            // label26
            // 
            this.label26.AutoSize = true;
            this.label26.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label26.Location = new System.Drawing.Point(6, 58);
            this.label26.Name = "label26";
            this.label26.Size = new System.Drawing.Size(40, 12);
            this.label26.TabIndex = 16;
            this.label26.Text = "max bits";
            // 
            // reqChanceTGT
            // 
            this.reqChanceTGT.DecimalPlaces = 1;
            this.reqChanceTGT.Location = new System.Drawing.Point(125, 33);
            this.reqChanceTGT.Name = "reqChanceTGT";
            this.reqChanceTGT.Size = new System.Drawing.Size(67, 20);
            this.reqChanceTGT.TabIndex = 6;
            // 
            // label31
            // 
            this.label31.AutoSize = true;
            this.label31.Location = new System.Drawing.Point(49, 16);
            this.label31.Name = "label31";
            this.label31.Size = new System.Drawing.Size(37, 13);
            this.label31.TabIndex = 12;
            this.label31.Text = "Ticket";
            // 
            // label28
            // 
            this.label28.AutoSize = true;
            this.label28.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.5F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label28.Location = new System.Drawing.Point(6, 36);
            this.label28.Name = "label28";
            this.label28.Size = new System.Drawing.Size(45, 12);
            this.label28.TabIndex = 14;
            this.label28.Text = "% chance";
            // 
            // label30
            // 
            this.label30.AutoSize = true;
            this.label30.Location = new System.Drawing.Point(122, 16);
            this.label30.Name = "label30";
            this.label30.Size = new System.Drawing.Size(29, 13);
            this.label30.TabIndex = 11;
            this.label30.Text = "TGT";
            // 
            // label29
            // 
            this.label29.AutoSize = true;
            this.label29.Location = new System.Drawing.Point(268, 16);
            this.label29.Name = "label29";
            this.label29.Size = new System.Drawing.Size(79, 13);
            this.label29.TabIndex = 13;
            this.label29.Text = "ServiceContext";
            // 
            // reqChanceSC
            // 
            this.reqChanceSC.DecimalPlaces = 1;
            this.reqChanceSC.Location = new System.Drawing.Point(271, 33);
            this.reqChanceSC.Name = "reqChanceSC";
            this.reqChanceSC.Size = new System.Drawing.Size(67, 20);
            this.reqChanceSC.TabIndex = 7;
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.reqEnableAsPassport);
            this.groupBox3.Controls.Add(this.reqEnablePcMachine);
            this.groupBox3.Controls.Add(this.reqEnableXeTGS);
            this.groupBox3.Controls.Add(this.reqEnableXeMachine);
            this.groupBox3.Controls.Add(this.reqEnableAS);
            this.groupBox3.Location = new System.Drawing.Point(360, 184);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(207, 130);
            this.groupBox3.TabIndex = 3;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "BuildRequest Methods";
            // 
            // reqEnableAsPassport
            // 
            this.reqEnableAsPassport.AutoSize = true;
            this.reqEnableAsPassport.Location = new System.Drawing.Point(8, 103);
            this.reqEnableAsPassport.Name = "reqEnableAsPassport";
            this.reqEnableAsPassport.Size = new System.Drawing.Size(184, 17);
            this.reqEnableAsPassport.TabIndex = 5;
            this.reqEnableAsPassport.Text = "kcl_BuildAsWithPassportRequest";
            this.reqEnableAsPassport.UseVisualStyleBackColor = true;
            // 
            // reqEnablePcMachine
            // 
            this.reqEnablePcMachine.AutoSize = true;
            this.reqEnablePcMachine.Location = new System.Drawing.Point(8, 82);
            this.reqEnablePcMachine.Name = "reqEnablePcMachine";
            this.reqEnablePcMachine.Size = new System.Drawing.Size(163, 17);
            this.reqEnablePcMachine.TabIndex = 4;
            this.reqEnablePcMachine.Text = "kcl_BuildPcMachineRequest";
            this.reqEnablePcMachine.UseVisualStyleBackColor = true;
            // 
            // reqEnableXeTGS
            // 
            this.reqEnableXeTGS.AutoSize = true;
            this.reqEnableXeTGS.Location = new System.Drawing.Point(8, 61);
            this.reqEnableXeTGS.Name = "reqEnableXeTGS";
            this.reqEnableXeTGS.Size = new System.Drawing.Size(158, 17);
            this.reqEnableXeTGS.TabIndex = 2;
            this.reqEnableXeTGS.Text = "kcl_BuildXenonTgsRequest";
            this.reqEnableXeTGS.UseVisualStyleBackColor = true;
            // 
            // reqEnableXeMachine
            // 
            this.reqEnableXeMachine.AutoSize = true;
            this.reqEnableXeMachine.Location = new System.Drawing.Point(7, 40);
            this.reqEnableXeMachine.Name = "reqEnableXeMachine";
            this.reqEnableXeMachine.Size = new System.Drawing.Size(181, 17);
            this.reqEnableXeMachine.TabIndex = 1;
            this.reqEnableXeMachine.Text = "kcl_BuildXenonMachineRequest";
            this.reqEnableXeMachine.UseVisualStyleBackColor = true;
            // 
            // reqEnableAS
            // 
            this.reqEnableAS.AutoSize = true;
            this.reqEnableAS.Location = new System.Drawing.Point(7, 19);
            this.reqEnableAS.Name = "reqEnableAS";
            this.reqEnableAS.Size = new System.Drawing.Size(129, 17);
            this.reqEnableAS.TabIndex = 0;
            this.reqEnableAS.Text = "XkerbBuildAsRequest";
            this.reqEnableAS.UseVisualStyleBackColor = true;
            // 
            // allSetOff
            // 
            this.allSetOff.Location = new System.Drawing.Point(6, 16);
            this.allSetOff.Name = "allSetOff";
            this.allSetOff.Size = new System.Drawing.Size(43, 22);
            this.allSetOff.TabIndex = 4;
            this.allSetOff.Text = "Off";
            this.allSetOff.UseVisualStyleBackColor = true;
            this.allSetOff.Click += new System.EventHandler(this.allSetNice_Click);
            // 
            // allSetNaughty
            // 
            this.allSetNaughty.Location = new System.Drawing.Point(98, 16);
            this.allSetNaughty.Name = "allSetNaughty";
            this.allSetNaughty.Size = new System.Drawing.Size(55, 22);
            this.allSetNaughty.TabIndex = 5;
            this.allSetNaughty.Text = "Naughty";
            this.allSetNaughty.UseVisualStyleBackColor = true;
            this.allSetNaughty.Click += new System.EventHandler(this.allSetNaughty_Click);
            // 
            // allSetDoom
            // 
            this.allSetDoom.Location = new System.Drawing.Point(153, 16);
            this.allSetDoom.Name = "allSetDoom";
            this.allSetDoom.Size = new System.Drawing.Size(49, 22);
            this.allSetDoom.TabIndex = 6;
            this.allSetDoom.Text = "DOOM";
            this.allSetDoom.UseVisualStyleBackColor = true;
            this.allSetDoom.Click += new System.EventHandler(this.allSetDoom_Click);
            // 
            // groupBox4
            // 
            this.groupBox4.Controls.Add(this.allSetNice);
            this.groupBox4.Controls.Add(this.allSetNaughty);
            this.groupBox4.Controls.Add(this.allSetDoom);
            this.groupBox4.Controls.Add(this.allSetOff);
            this.groupBox4.Location = new System.Drawing.Point(358, 131);
            this.groupBox4.Name = "groupBox4";
            this.groupBox4.Size = new System.Drawing.Size(209, 45);
            this.groupBox4.TabIndex = 7;
            this.groupBox4.TabStop = false;
            this.groupBox4.Text = "Set All";
            // 
            // allSetNice
            // 
            this.allSetNice.Location = new System.Drawing.Point(49, 16);
            this.allSetNice.Name = "allSetNice";
            this.allSetNice.Size = new System.Drawing.Size(49, 22);
            this.allSetNice.TabIndex = 7;
            this.allSetNice.Text = "Nice";
            this.allSetNice.UseVisualStyleBackColor = true;
            this.allSetNice.Click += new System.EventHandler(this.allSetNice_Click_1);
            // 
            // pictureBox1
            // 
            this.pictureBox1.ImageLocation = "SuitesData/Xkdc/fuzz.jpg";
            this.pictureBox1.Location = new System.Drawing.Point(440, 315);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(119, 86);
            this.pictureBox1.TabIndex = 8;
            this.pictureBox1.TabStop = false;
            // 
            // tabControl1
            // 
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Location = new System.Drawing.Point(9, 12);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(580, 433);
            this.tabControl1.TabIndex = 9;
            // 
            // tabPage1
            // 
            this.tabPage1.AutoScroll = true;
            this.tabPage1.Controls.Add(this.groupBox3);
            this.tabPage1.Controls.Add(this.groupBox1);
            this.tabPage1.Controls.Add(this.pictureBox1);
            this.tabPage1.Controls.Add(this.groupBoxSettings);
            this.tabPage1.Controls.Add(this.groupBox4);
            this.tabPage1.Controls.Add(this.groupBox2);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage1.Size = new System.Drawing.Size(572, 407);
            this.tabPage1.TabIndex = 0;
            this.tabPage1.Text = "KerbFuzz";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // KdcStressForm
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(590, 447);
            this.Controls.Add(this.tabControl1);
            this.MaximizeBox = false;
            this.Name = "KdcStressForm";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.Text = "Kdc Fuzz Form";
            this.groupBoxSettings.ResumeLayout(false);
            this.groupBoxSettings.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.packetFuzzChance)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.fuzzIterations)).EndInit();
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsInt32)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsLength)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsEoc)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsTag)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsBitStr)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsOctStr)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsGenTime)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsBool)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsU32)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsOpen)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsObj)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnBitsCharStr)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceLength)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceEoc)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceInt32)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceTag)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceGenTime)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceBool)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceU32)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceBitStr)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceOpen)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceObj)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceOctStr)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.asnChanceCharStr)).EndInit();
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsMisc)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsKeys)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceMisc)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceKeys)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsCert)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsUser)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsStrings)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceCert)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceUser)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceStrings)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsSC)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsTGT)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceTitle)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsTicket)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceTicket)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqBitsTitle)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceTGT)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.reqChanceSC)).EndInit();
            this.groupBox3.ResumeLayout(false);
            this.groupBox3.PerformLayout();
            this.groupBox4.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.tabControl1.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.ResumeLayout(false);

        }
        #endregion

        public void Initialize()
        {
            this.Update();
            this.textRandomSeed.Text = DateTime.Now.Ticks.ToString();
        }

        public static KdcStressForm CreateAndShow(DeterministicRandom randfuzz)
        {
            KdcStressForm form = new KdcStressForm(randfuzz);
            Show(form);
            return form;
        }

        public static void Show(KdcStressForm form)
        {
            StressFormThread thr = new StressFormThread(form);
            thr.Go();
            System.Threading.Thread.Sleep(100);
        }

        private void btnSetRandomSeed_Click(object sender, System.EventArgs e)
        {
            this.textRandomSeed.Text = ((int)(DateTime.Now.Ticks)).ToString();
        }

        private void textRandomSeed_TextChanged(object sender, System.EventArgs e)
        {
            randfuzz.Seed(RandomSeed);
        }

        private void textStartIteration_TextChanged(object sender, System.EventArgs e)
        {
            randfuzz.JumpToIteration(StartIteration);
        }

        private void fuzzIterations_ValueChanged(object sender, System.EventArgs e)
        {
            AuthClientBase.SetFuzzParameters(FuzzIterations, FuzzChance);
        }

        public int FuzzIterations
        {
            get
            {
                return (int)fuzzIterations.Value;
            }
            set
            {
                fuzzIterations.Value = value;
                Update();
            }
        }

        public float FuzzChance
        {
            get
            {
                return (float)packetFuzzChance.Value/100.0f;
            }
        }

        public bool IsFuzzEnabled
        {
            get { return fuzzIterations.Value > 0; }
        }

        public int RandomSeed
        {
            get 
            { 
                try
                {
                    return int.Parse(this.textRandomSeed.Text); 
                }
                catch (System.OverflowException)
                {
                    this.textRandomSeed.Text = "0";
                    return 0;
                }
            }
        }

        public int StartIteration
        {
            get 
            { 
                try 
                {
                    return int.Parse(this.textStartIteration.Text); 
                }
                catch (System.OverflowException)
                {
                    this.textStartIteration.Text = "0";
                    return 0;
                }
            }
        }

        private void label6_Click(object sender,EventArgs e)
        {

        }

        private void label8_Click(object sender,EventArgs e)
        {

        }

        private void numericUpDown1_ValueChanged(object sender,EventArgs e)
        {

        }

        private void numericUpDown2_ValueChanged(object sender,EventArgs e)
        {

        }

        private void label24_Click(object sender,EventArgs e)
        {

        }

        private void numericUpDown1_ValueChanged_1(object sender,EventArgs e)
        {

        }

        private void numericUpDown2_ValueChanged_1(object sender,EventArgs e)
        {

        }

        //Updates the asn fuzz params into kerbclient
        private void UpdateAsnFuzz(Object sender, EventArgs e)
        {
            AuthClientBase.SAsnFuzzParams p;

            p.ber_charStr.chance=(float)asnChanceCharStr.Value/100.0f;
            p.ber_charStr.maxBits=(uint)asnBitsCharStr.Value;

            p.ber_octStr.chance=(float)asnChanceOctStr.Value/100.0f;
            p.ber_octStr.maxBits=(uint)asnBitsOctStr.Value;

            p.ber_int32.chance=(float)asnChanceInt32.Value/100.0f;
            p.ber_int32.maxBits=(uint)asnBitsInt32.Value;

            p.ber_tag.chance=(float)asnChanceTag.Value/100.0f;
            p.ber_tag.maxBits=(uint)asnBitsTag.Value;

            p.ber_bitStr.chance=(float)asnChanceBitStr.Value/100.0f;
            p.ber_bitStr.maxBits=(uint)asnBitsBitStr.Value;

            p.ber_openType.chance=(float)asnChanceOpen.Value/100.0f;
            p.ber_openType.maxBits=(uint)asnBitsOpen.Value;

            p.ber_objIden1.chance=(float)asnChanceObj.Value/100.0f;
            p.ber_objIden1.maxBits=(uint)asnBitsObj.Value;
            
            p.ber_length.chance=(float)asnChanceLength.Value/100.0f;
            p.ber_length.maxBits=(uint)asnBitsLength.Value;

            p.ber_eoc.chance=(float)asnChanceEoc.Value/100.0f;
            p.ber_eoc.maxBits=(uint)asnBitsEoc.Value;

            p.ber_booll.chance=(float)asnChanceBool.Value/100.0f;
            p.ber_booll.maxBits=(uint)asnBitsBool.Value;

            p.ber_u32.chance=(float)asnChanceU32.Value/100.0f;
            p.ber_u32.maxBits=(uint)asnBitsU32.Value;
            
            p.cer_genTime.chance=(float)asnChanceGenTime.Value/100.0f;
            p.cer_genTime.maxBits=(uint)asnBitsGenTime.Value;

            unsafe { AuthClientBase.DLL_SetAsnFuzzParams(&p); }
        }

        //Updates the kerberos request fuzz params into kerbclient
        private void UpdateKerbReqFuzz(Object sender, EventArgs e)
        {
            AuthClientBase.SRequestFuzzParams p;

            p.misc.chance=(float)reqChanceMisc.Value/100.0f;
            p.misc.maxBits=(uint)reqBitsMisc.Value;

            p.keys.chance=(float)reqChanceKeys.Value/100.0f;
            p.keys.maxBits=(uint)reqBitsKeys.Value;          

            p.cert.chance=(float)reqChanceCert.Value/100.0f;
            p.cert.maxBits=(uint)reqBitsCert.Value;

            p.user.chance=(float)reqChanceUser.Value/100.0f;
            p.user.maxBits=(uint)reqBitsUser.Value;

            p.strings.chance=(float)reqChanceStrings.Value/100.0f;
            p.strings.maxBits=(uint)reqBitsStrings.Value;

            p.service.chance=(float)reqChanceSC.Value/100.0f;
            p.service.maxBits=(uint)reqBitsSC.Value;
            
            p.tgt.chance=(float)reqChanceTGT.Value/100.0f;
            p.tgt.maxBits=(uint)reqBitsTGT.Value;
            
            p.title.chance=(float)reqChanceTitle.Value/100.0f;
            p.title.maxBits=(uint)reqBitsTitle.Value;           
            
            p.ticket.chance=(float)reqChanceTicket.Value/100.0f;
            p.ticket.maxBits=(uint)reqBitsTicket.Value;

            
            p.kcl_BuildAsWithPassportRequest=(uint/*goshdernevilc#*/)(reqEnableAsPassport.Checked?1:0);
            p.kcl_BuildPcMachineRequest=(uint)(reqEnablePcMachine.Checked?1:0);
            p.kcl_BuildXenonTgsRequest=(uint)(reqEnableXeTGS.Checked?1:0);
            p.kcl_BuildXenonMachineRequest=(uint)(reqEnableXeMachine.Checked?1:0);
            p.XkerbBuildAsRequest=(uint)(reqEnableAS.Checked?1:0);

            unsafe { AuthClientBase.DLL_SetKerbRequestFuzzParams(&p); }
        }

        private void allSetNice_Click(object sender,EventArgs e) //really off .. vs gui editor naming bug
        {
            SetAllAsnParams((Decimal)0.0f,0);
            SetAllKerbReqParams((Decimal)0.0f,0,false);

            FuzzIterations=0;
            packetFuzzChance.Value=(Decimal)0.0f;
        }

        private void allSetNice_Click_1(object sender,EventArgs e) //nice
        {
            SetAllAsnParams((Decimal)0.00005f,2);
            asnChanceInt32.Value=(Decimal)0.002f;
            asnChanceTag.Value=(Decimal)0.002f;
            asnChanceLength.Value=(Decimal)0.002f;

            SetAllKerbReqParams((Decimal)0.004f,2,true);

            FuzzIterations=1;
            packetFuzzChance.Value=(Decimal)0.3;
        }

        private void allSetNaughty_Click(object sender,EventArgs e)
        {
            SetAllAsnParams((Decimal)0.002f,4);
            asnChanceInt32.Value=(Decimal)0.05f;
            asnChanceTag.Value=(Decimal)0.05f;
            asnChanceLength.Value=(Decimal)0.05f;
            UpdateAsnFuzz(null,null);

            SetAllKerbReqParams((Decimal)0.08f,4,true);

            FuzzIterations=3;
            packetFuzzChance.Value=(Decimal)5;
        }

        private void allSetDoom_Click(object sender,EventArgs e)
        {
            SetAllAsnParams((Decimal)0.05f,8);
            asnChanceInt32.Value=(Decimal)1;
            asnChanceTag.Value=(Decimal)1;
            asnChanceLength.Value=(Decimal)1;
            UpdateAsnFuzz(null,null);

            SetAllKerbReqParams((Decimal)0.2f,16,true);

            FuzzIterations=10;
            packetFuzzChance.Value=(Decimal)20;
        }        

        //set all asn fuzz params to a specific value
        private void SetAllAsnParams(Decimal chance, uint maxBits)
        {
            chance*=100;

            asnChanceCharStr.Value=chance;
            asnBitsCharStr.Value=maxBits;

            asnChanceOctStr.Value=chance;
            asnBitsOctStr.Value=maxBits;

            asnChanceInt32.Value=chance;
            asnBitsInt32.Value=maxBits;

            asnChanceTag.Value=chance;
            asnBitsTag.Value=maxBits;

            asnChanceBitStr.Value=chance;
            asnBitsBitStr.Value=maxBits;

            asnChanceOpen.Value=chance;
            asnBitsOpen.Value=maxBits;

            asnChanceObj.Value=chance;
            asnBitsObj.Value=maxBits;
            
            asnChanceLength.Value=chance;
            asnBitsLength.Value=maxBits;

            asnChanceEoc.Value=chance;
            asnBitsEoc.Value=maxBits;

            asnChanceBool.Value=chance;
            asnBitsBool.Value=maxBits;

            asnChanceU32.Value=chance;
            asnBitsU32.Value=maxBits;
            
            asnChanceGenTime.Value=chance;
            asnBitsGenTime.Value=maxBits;

            UpdateAsnFuzz(null,null);
        }

        //sets all kerbrequest fuzz params to a specific value
        private void SetAllKerbReqParams(Decimal chance, uint maxBits, bool enable)
        {
            chance*=100;

            reqChanceMisc.Value=chance;
            reqBitsMisc.Value=maxBits;

            reqChanceKeys.Value=chance;
            reqBitsKeys.Value=maxBits;          

            reqChanceCert.Value=chance;
            reqBitsCert.Value=maxBits;

            reqChanceUser.Value=chance;
            reqBitsUser.Value=maxBits;

            reqChanceStrings.Value=chance;
            reqBitsStrings.Value=maxBits;

            reqChanceSC.Value=chance;
            reqBitsSC.Value=maxBits;
            
            reqChanceTGT.Value=chance;
            reqBitsTGT.Value=maxBits;
            
            reqChanceTitle.Value=chance;
            reqBitsTitle.Value=maxBits;           
            
            reqChanceTicket.Value=chance;
            reqBitsTicket.Value=maxBits;
            
            reqEnableAsPassport.Checked=enable;
            reqEnablePcMachine.Checked=enable;
            reqEnableXeTGS.Checked=enable;
            reqEnableXeMachine.Checked=enable;
            reqEnableAS.Checked=enable;

            UpdateKerbReqFuzz(null,null);
        }

        private void reqBitsTGT_ValueChanged(object sender,EventArgs e)
        {

        }
    }


    public class StressFormThread : ThreadBase
    {
        KdcStressForm form;

        public StressFormThread(KdcStressForm f)
        {
            form = f;
        }

        protected override void ThreadBody()
        {
            try
            {
                //System.Threading.Thread.CurrentThread.Priority = System.Threading.ThreadPriority.AboveNormal;
                form.ShowDialog();
            }
            catch (Exception e)
            {
                Global.RO.Warn("StressFormThread got exception: {0}", e.Message);
            }
        }
    }

    //gui plugin
    public class KerbFuzz: STFGui.Plugins.IPluginGui
    {
        public TabPage GetNewTabPage()
        {
            KdcStressForm fuzzForm=new KdcStressForm();
            return fuzzForm.FuzzTabPage;
        }

        #region IPluginGui Members

        public STFGui.Plugins.MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public MenuItem GetNewMenu ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\StressFuzz.cs ===
using System;
using System.Threading;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;

#pragma warning disable 420 //a reference to a volatile field will not be treated as volatile

namespace XkdcTest
{
    [TestGroup]
    public class StressFuzz: TestNode
    {
        //async test specifically for xkdc xenon, as that's our biggest load
        [StressTest, Description("Async tests for the xkdc.")]
        [CompoundCase("Xenon",                      AuthContext.ClientTypes.Xenon)]
        public class AsyncXkdc: AsyncStressTestNode
        {
            static TimedQueue<KdcClient> readyCache;
            static TimedQueue<KdcClientTracker> usedCache;

            static int ReceiveThreadCount=System.Environment.ProcessorCount/2;
            const int MaxInProgress=10000;
            volatile static int threadsRunning=0;
            volatile static bool isRunning=false;

            class KdcClientTracker
            {
                public System.DateTime RequestTime;
                public AsyncStressTestNode Test;
                public KdcClient Client;
                public AsyncStressTracking Tracker;
            };

            static AsyncXkdc()
            {
                readyCache=new TimedQueue<KdcClient>();
                readyCache.MinimumReuseTime=new TimeSpan(0,0,0,1*4,25); //1s (60 in 60sec = tempban), eyeballing at up to 4 requests per use
                usedCache=new TimedQueue<KdcClientTracker>();
                usedCache.MinimumReuseTime=new TimeSpan(0,0,0,0,0);
            }

            public override void PreRun()
            {
                //create threads
                isRunning=true;
                threadsRunning=ReceiveThreadCount;
                Global.RO.Debug("Creating "+ReceiveThreadCount+" threads for xkdc fuzz async receiving stress.");
                for (int i=0; i<ReceiveThreadCount; ++i)
                {
                    ThreadMaker.CreateThread(ReceiveThreadProc).Start();
                }
            }

            public override void PostRun()
            {
                //tell threads to end, then wait for them to end
                isRunning=false;

                Global.RO.Debug("Waiting on xkdc fuzz async receiving stress threads to end...");
                while (threadsRunning>0)
                {
                    System.Threading.Thread.Sleep(10);
                }
                Global.RO.Debug("All xkdc fuzz async receiving stress threads ended.");
            }

            public override void Begin(AsyncStressTracking tracker)
            {
                if (usedCache.Count>MaxInProgress)
                {
                    End(new DidNotExecuteException("Exceeded max in progress"), tracker);
                    return;
                }

                //get a client ready to do an xkdc request
                KdcClient kdc=readyCache.PopFront();
                if (kdc==null)
                {
                    kdc=new KdcClient((AuthContext.ClientTypes)MyValues[0]);

                    //do up through askdc
                    kdc.ExecuteAskdc(true);
                }

                //now send off the xkdc request
                kdc.ResetSocket();
                kdc.ClearXkdc();
                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.GeneratePreauths();
                kdc.XkdcRequest.SetRequest();
                kdc.XkdcRequest.ConstructRequest();
                //TODO: duplicate inputs (including ticket) so that we fuzz the duplicate rather than the original
                AsnFuzzing.Fuzz(kdc.XkdcRequest);
                byte []packet=kdc.XkdcRequest.GetBytes();
                if (KdcClient.VerboseOutput)
                {
                    Global.RO.Debug("Xkdc Fuzz Request:\n"+kdc.XkdcRequest);
                }
                kdc.SendPacket(packet);

                //save the nonce
                kdc.XkdcNOnces[kdc.XkdcNOncesUsed++]=kdc.XkdcRequest.Input.NOnce;

                //put it into the queue of sent items
                KdcClientTracker t=new KdcClientTracker();
                t.Test=this;
                t.Client=kdc;
                t.Tracker=tracker;
                t.RequestTime=System.DateTime.UtcNow;
                usedCache.PushBack(t);
            }

            static void ReceiveThreadProc()
            {
                while (isRunning || usedCache.Count>0)
                {
                    KdcClientTracker t=usedCache.PopFront();
                    if (t==null)
                    {
                        System.Threading.Thread.Sleep(100);
                        continue;
                    }

                    bool used=true;
                    System.Exception err=ReceiveThreadProc_ProcessClient(t, ref used);

                    if (used)
                    {
                        if (err==null)
                        {
                            t.Test.End(null, t.Tracker);
                        }
                        else
                        {
                            t.Test.End(err, t.Tracker);
                        }

                        if (err==null || StressCommon.AlwaysRetainContext)
                        {
                            readyCache.PushBack(t.Client);
                        }
                    }
                    else
                    {
                        if (err==null)
                        {
                            usedCache.PushBack(t);
                        }
                        else
                        {
                            Global.RO.Warn("Async Fuzz Xkdc: Unused client processing returned an error: "+err);
                        }
                    }
                }

                System.Threading.Interlocked.Decrement(ref threadsRunning);
            }

            static System.Exception ReceiveThreadProc_ProcessClient(KdcClientTracker t, ref bool used)
            {
                try
                {
                    byte []packet=t.Client.ReceivePacket(0);
                    if (packet==null) //no response yet
                    {
                        if ((System.DateTime.UtcNow-t.RequestTime)>new System.TimeSpan(0, 0, 0, 2, 0)) //2s timeout
                        {
                            return new ServerTestFramework.Utilities.TimeoutException("Async Fuzz Xkdc: request timed out.");
                        }
                        else //nothing yet but it still has time
                        {
                            used=false;
                        }
                    }
                    else //got a reply
                    {
                        long replyBytesUsed;
                        AsnValueBase asn=Compound.AsnValueParser.Parse(packet, 0, packet.Length, out replyBytesUsed);
                        t.Client.SetXkdcReply(asn);
                    }
                }
                catch (System.Exception err)
                {
                    return err;
                }

                return null;
            }
        };
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\StressCommon.cs ===
using System;
using System.Threading;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;

#pragma warning disable 420 //a reference to a volatile field will not be treated as volatile

namespace XkdcTest
{
    public class StressCommon
    {
        //Settings
        public static bool EmulateClientBehavior=true;
        public static bool AlwaysRetainContext=false;
        public static bool SkipStressSetup=true;

        //sign in helper functions for each client type
        public static void SignInXmacs(AuthContext ctx, bool manualSetup)
        {
            XmacsClient xmacs=new XmacsClient(ctx);
            xmacs.isManualSetup=manualSetup;
            xmacs.EmulateClientBehavior=EmulateClientBehavior;
            xmacs.SignInXmacs();
        }
        public static string SignInAskdc(AuthContext ctx, bool autoSetup1User, bool autoUserIsSilver, bool hackOnExtraTicketLife)
        {
            string userUsed=null;

            if (autoSetup1User)
            {
                if (ctx.ClientType!=AuthContext.ClientTypes.Panorama) //most clients use bulk users
                {
                    if (!autoUserIsSilver) //bulk users are all gold by default
                    {
                        uint buInd=GetNextBulkUserIndex();
                        string gamertag=Global.GetUserSet("xenon").IndexToGamertag(buInd);
                        byte[] key=STFLiveGlobal.GetUserSet("xenon").IndexToXenonKey2(buInd);
                        ctx.Users[0]=AuthContext.MakeUser(gamertag, key);
                        userUsed=gamertag;
                    }
                    else //have to make our own silver if we want that
                    {
                        ctx.SetNewUser(0, !autoUserIsSilver);
                    }
                }
                else //panorama needs a real passport user though
                {
                    ctx.SetNewPassportUser(0, !autoUserIsSilver);
                }
            }

            if (!ctx.IsSignedInXmacs)
            {
                SignInXmacs(ctx, false);
                if (EmulateClientBehavior) //use delay that the client uses
                {
                    System.Threading.Thread.Sleep(AuthClientBase.WAIT_AFTER_MACHINE_ACCOUNT_CREATION_IN_MS);
                }
                else //our old default
                {
                    //PPA cache is gone, no longer needed:
                    //System.Threading.Thread.Sleep(1000);
                }
            }

            AskdcClient askdc=new AskdcClient(ctx);
            ctx.ClearAskdc();
            askdc.EmulateClientBehavior=EmulateClientBehavior;

            askdc.SignInAskdc();

            if (hackOnExtraTicketLife) //add a week to life of ticket
            {
                askdc.AddToTicketTimeRemaining(60*60*24*7);
            }

            return userUsed;
        }
        public static void SignInXkdc(AuthContext ctx)
        {
            SignInXkdc(ctx, true);
        }
        public static void SignInXkdc(AuthContext ctx, bool autodiscoverIfAble)
        {
            if (!ctx.IsSignedInAskdc)
            {
                SignInAskdc(ctx, true, true, true);
            }

            XkdcClient xkdc=new XkdcClient(ctx);
            xkdc.EmulateClientBehavior=EmulateClientBehavior;
            ctx.ClearXkdc();

            //we don't want to generate a flow token for every request (it causes a line to the report area potentially), so try to mimic a rough estimate of how real clients will cause them
            const float flokenGeneratePercent=0.25f;
            if ((float)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextDouble()<flokenGeneratePercent)
            {
                ctx.FlowToken=0;
            }
            else
            {
                ctx.FlowToken=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
            }

            if (ctx.ClientType==AuthContext.ClientTypes.Xbox) //xbox1 doesn't support autodiscover, so set some services
            {
                //copy part of halo2's request
                ctx.SetTitle(0x4d530064, 1, 1);
                xkdc.SetRequest(new uint[] {4, 6, 7, 8, 9, 13, 14, 15, 16, 18, 19, 20});
            }
            else
            {
                if (!autodiscoverIfAble)
                {
                    xkdc.SetRequest(new uint[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 25, 26, 27, 28, 29, 32});
                }
            }

            //do the request and verify the response
            xkdc.SignInXkdc();
        }

        //retrieves a bulk user index to use that has not been used before
        private static int lastBulkIndex=0;
        public static uint GetNextBulkUserIndex()
        {
            int ind=System.Threading.Interlocked.Increment(ref lastBulkIndex);
            if (lastBulkIndex>=Global.GetUserSet("xenon").Count)
            {
                Global.RO.Error("BulkUserSet index is wrapping back to the start.  Maybe you should set a larger number of bulk users.");
                System.Threading.Interlocked.CompareExchange(ref lastBulkIndex, (int)(lastBulkIndex%Global.GetUserSet("xenon").Count), lastBulkIndex);
            }
            return (uint)(ind%Global.GetUserSet("xenon").Count);
        }
    };

    //gui plugin for KDC stress
    public class KdcStressGui: STFGui.Plugins.IPluginGui
    {
        public System.Windows.Forms.MenuItem GetNewMenu()
        {
            System.Windows.Forms.MenuItem baseMenu=new System.Windows.Forms.MenuItem("KDC Stress");

            System.Windows.Forms.MenuItem miAlwaysRetainContexts=new System.Windows.Forms.MenuItem("Always Retain AuthContext Cache", MenuChoice_RetainContext);
            miAlwaysRetainContexts.Checked=StressCommon.AlwaysRetainContext;
            baseMenu.MenuItems.Add(miAlwaysRetainContexts);

            System.Windows.Forms.MenuItem miEmuClient=new System.Windows.Forms.MenuItem("Emulate Client Retry Behavior", MenuChoice_EmulateClient);
            miEmuClient.Checked=StressCommon.EmulateClientBehavior;
            baseMenu.MenuItems.Add(miEmuClient);

            System.Windows.Forms.MenuItem miSkipSetup=new System.Windows.Forms.MenuItem("Skip Setup", MenuChoice_SkipSetup);
            miSkipSetup.Checked=StressCommon.SkipStressSetup;
            baseMenu.MenuItems.Add(miSkipSetup);

            return baseMenu;
        }

        private void MenuChoice_RetainContext(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            StressCommon.AlwaysRetainContext=mi.Checked;
            Global.RO.Info("AlwaysRetainContext="+StressCommon.AlwaysRetainContext);
        }

        private void MenuChoice_EmulateClient(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            StressCommon.EmulateClientBehavior=mi.Checked;
            Global.RO.Info("EmulateClientBehavior="+StressCommon.EmulateClientBehavior);
        }

        private void MenuChoice_SkipSetup(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            StressCommon.SkipStressSetup=mi.Checked;
            Global.RO.Info("SkipStressSetup="+StressCommon.SkipStressSetup);
        }

        #region IPluginGui Members

        public STFGui.Plugins.MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public System.Windows.Forms.TabPage GetNewTabPage ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\TestBase_KdcClient.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    /// <summary> A test base class which provides an easy way for a test to use KdcClient object to validate a large number of things.  This may only be used inside of a XkdcTestBaseGroup group. Validation currently only fully handles xbox360 and pc clients; xbox1 is only partially complete. </summary>
    public class TestBase_KdcClient: TestNode
    {
        //expectations for xmacs
        public uint ExpectedXmacsKerbError=0;

        //expectations for askdc
        //todo

        //expectations for xkdc
        public bool       ExpectXkdcTimeout=false;
        public uint       ExpectedXkdcKerbError=0;
        public uint       ExpectedOverallHR=0;

        public uint     []ExpectedUserHRs;
        public BitArray []ExpectedUserPrivileges;
        public uint     []ExpectedUserGuestNumber;
        public uint     []ExpectedUserCountryId;
        public uint     []ExpectedUserTier;

        public BitArray   ExpectedMachinePrivileges;
        public XkdcGenericReplyOutput.ServiceResult []ExpectedServices; //if null, this will be computed automatically for a normal machine with the set of users

        public Kerberos.XboxServiceAlternateTitleID []ExpectedAltTitleIDs;

        private uint? _ExpectedAuthDataVersion = null;
        public uint ExpectedAuthDataVersion
        {
            get
            {
                // XCS bug 145652 introduced a "mitigation" feature where PreAuthV4 (old) 
                // can only get AuthdataV3 (old). PreAuthV5 (new) can get any version of 
                // Authdata, including AuthdataV4 (new).

                if (_ExpectedAuthDataVersion == null)
                {
                    return (DefaultXkdcXenonPreauthVersion < 5) ? (uint)3 : (uint)4;
                }
                else
                {
                    // In case test wanted to override the default
                    return (uint)_ExpectedAuthDataVersion;
                }

            }
            set
            {
                _ExpectedAuthDataVersion = value;
            }
        }

        //users
        private KdcUser []users;

        private void SetUser(int slot, UserInfo ui, KdcUser user)
        {
            users[slot]=user;

            ExpectedUserHRs[slot]=0;

            uint []defaultPrivileges=GetNamedUserPrivileges(ui);
            ExpectedUserPrivileges[slot].SetAll(false);
            foreach (uint priv in defaultPrivileges)
            {
                ExpectedUserPrivileges[slot].Set((int)priv, true);
            }

            ExpectedUserGuestNumber[slot]=0;
            ExpectedUserCountryId[slot]=(uint)ui.CountryCode;
            ExpectedUserTier[slot]=Expectations.k_IdxToTierId[ui.Tier-1];
        }

        public void SetUser(int slot, KdcUser user)
        {
            UserInfo ui=new UserInfo(user.Gamertag);
            SetUser(slot, ui, user);
        }

        public void SetUser(int slot, UserInfo ui)
        {
            KdcUser user=new KdcUser();
            user.UseExisting(ui.Name);
            SetUser(slot, ui, user);
        }

        public void SetUser(int slot, string gamertag)
        {
            UserInfo ui=new UserInfo(gamertag);
            SetUser(slot, ui);
        }

        public KdcUser GetUser(int slot)
        {
            return users[slot];
        }

        //kdc client
        private KdcClient client;
        public KdcClient Client
        {
            get { return client; }
        }

        //helpers pulling infromation from the group
        public virtual int DefaultXkdcXenonPreauthVersion
        {
            get
            {
                TestNode cur=Parent;
                while (cur!=null)
                {
                    if (cur is XkdcTestBaseGroup)
                    {
                        return ((XkdcTestBaseGroup)cur).DefaultXkdcXenonPreauthVersion;
                    }

                    cur=cur.Parent;
                }

                Global.RO.Warn("Could not find a XkdcTestBaseGroup parent node.  Using platform default for XkdcXenonPreauthVersion.");
                return 0;
            }
        }

        public AuthContext.ClientTypes ClientType
        {
            get
            {
                TestNode cur=Parent;
                while (cur!=null)
                {
                    if (cur is XkdcTestBaseGroup)
                    {
                        return ((XkdcTestBaseGroup)cur).ParentClientType;
                    }

                    cur=cur.Parent;
                }

                throw new System.Exception("Could not find a XkdcTestBaseGroup parent node, so unable to determine client type");
            }
        }

        public uint[] GetNamedUserPrivileges(UserInfo ui)
        {
            if (ClientType==AuthContext.ClientTypes.Panorama) //PC gets cross platform multiplayer privilege also
            {
                uint []privs=new uint[ui.ExpectedPrivileges.Length+1];
                System.Array.Copy(ui.ExpectedPrivileges, 0, privs, 0, ui.ExpectedPrivileges.Length);
                privs[privs.Length-1]=241;
                return privs;
            }
            else
            {
                return ui.ExpectedPrivileges;
            }
        }

        public uint[] GetNamedUserPrivileges(string name)
        {
            UserInfo ui=new UserInfo(name);
            return GetNamedUserPrivileges(ui);
        }

        public XkdcGenericReplyOutput.ServiceResult[] GetCurrentDefaultServiceExpectations()
        {
            return GetCurrentDefaultServiceExpectations(0);
        }

        public XkdcGenericReplyOutput.ServiceResult[] GetCurrentDefaultServiceExpectations(uint titleId)
        {
            if (ExpectedOverallHR!=0) //if the overall request is fail, we should get no services back
            {
                return new XkdcGenericReplyOutput.ServiceResult[0];
            }

            System.Collections.Generic.List<uint> expectedIDs=new System.Collections.Generic.List<uint>();
            System.Collections.Generic.List<uint> expectedHRs=new System.Collections.Generic.List<uint>();
            System.Collections.Generic.List<ushort> expectedPorts=new System.Collections.Generic.List<ushort>();

            //figure out the tier to pull expectations from
            int tier=-1; //default to machine services
            foreach (KdcUser u in users)
            {
                if (u!=null)
                {
                    UserInfo ui=new UserInfo(u.Gamertag, 0, titleId);
                    if (tier==-1) //replace machine services since we have a user
                    {
                        tier=ui.Tier;
                    }
                    else if (ui.Tier<tier) //downgrade if we have a lower tiered user
                    {
                        tier=ui.Tier;
                    }
                }
            }

            //add user services to expectations
            if (tier!=-1)
            {
                expectedIDs.AddRange(Expectations.k_DefaultExpectedServices[tier-1]);
                expectedHRs.AddRange(Expectations.k_DefaultExpectedHRs[tier-1]);
                //expectedPorts=Expectations.k_DefaultExpectedPorts[tier-1]; //todo: add to xml
            }

            //add special services (todo: handle multi-user scenario where some users don't have these)
            foreach (KdcUser u in users)
            {
                if (u!=null)
                {
                    UserInfo ui=new UserInfo(u.Gamertag, 0, titleId);
                    foreach (uint extraService in ui.AdditionalServices)
                    {
                        if (!expectedIDs.Contains(extraService))
                        {
                            expectedIDs.Add(extraService);
                            expectedHRs.Add(0);
                            //expectedPorts.Add((ushort)extraService); //todo: temp until other parts fill in the port
                        }
                    }
                }
            }

            //add machine services to expectations
            for (int i=0; i<Expectations.k_DefaultExpectedMachineServices.Length; ++i)
            {
                if (!expectedIDs.Contains(Expectations.k_DefaultExpectedMachineServices[i]))
                {
                    expectedIDs.Add(Expectations.k_DefaultExpectedMachineServices[i]);
                    expectedHRs.Add(Expectations.k_DefaultExpectedMachineHRs[i]);
                    //expectedPorts.Add(Expectations.k_DefaultExpectedMachineServicePorts[i]); //todo: add to xml
                }
            }

            //temp until xml has ports: set to match service id
            for (int i=0; i<expectedIDs.Count; ++i)
            {
                if (expectedHRs[i]==0)
                {
                    expectedPorts.Add((ushort)expectedIDs[i]);
                }
                else
                {
                    expectedPorts.Add(0);
                }
            }

            //
            XkdcGenericReplyOutput.ServiceResult []knownResults=new XkdcGenericReplyOutput.ServiceResult[expectedIDs.Count];
            for (int i=0; i<expectedIDs.Count; ++i)
            {
                knownResults[i].Service=expectedIDs[i];
                knownResults[i].Hr=expectedHRs[i];
                knownResults[i].Port=expectedPorts[i];
            }

            //if they did not do an autodiscover, then we need to take the known expectations and apply it to the exact set of services that were requested, otherwise we have the exact set that should come back already
            if (Client.XkdcRequest.Input.AutoDiscoverServices!=0)
            {
                HackUpArbitrationPort(knownResults);
                return knownResults;
            }

            System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult> results=new System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult>();
            if (Client.XkdcRequest.Input.Services!=null)
            {
                foreach (uint service in Client.XkdcRequest.Input.Services)
                {
                    //find the expectation that matches this service
                    XkdcGenericReplyOutput.ServiceResult ?expectation=null;
                    foreach (XkdcGenericReplyOutput.ServiceResult knownResult in knownResults)
                    {
                        if (knownResult.Service==service)
                        {
                            expectation=knownResult;
                            break;
                        }
                    }

                    if (expectation!=null)
                    {
                        results.Add((XkdcGenericReplyOutput.ServiceResult)expectation);
                    }
                    else //service will not be granted
                    {
                        XkdcGenericReplyOutput.ServiceResult unauthorized=new XkdcGenericReplyOutput.ServiceResult();
                        unauthorized.Service=service;
                        unauthorized.Port=0;
                        unauthorized.Hr=HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                        results.Add(unauthorized);
                    }
                }
            }

            XkdcGenericReplyOutput.ServiceResult []resultsArray=results.ToArray();
            HackUpArbitrationPort(resultsArray);
            return resultsArray;
        }

        //hackhack: Due to "running out of time" for the 2010 June XSR the client has a hack in it to force arbitration to use port 1000 rather than the new implicit port 16, since they don't want to change the SG for that release.  We need to mimic that hack so all our tests don't fail horribly.
        public void HackUpArbitrationPort(XkdcGenericReplyOutput.ServiceResult []services)
        {
            for (int i=0; i<services.Length; ++i)
            {
                if (services[i].Service==16) //arb
                {
                    services[i].Port=1000;
                }
            }
        }

        //Creates a client of the type for this group.
        public KdcClient CreateClient()
        {
            KdcClient c=new KdcClient(ClientType);
            c.XkdcThrowOnOverallHRFailure=false;

            if (ExpectXkdcTimeout) //give them longer to time out but do not retry
            {
                c.XkdcTimeoutTimeInMs=5000;
                c.RetryLostPackets=false;
            }

            return c;
        }

        private void SetDefaults()
        {
            client=CreateClient();
        }

        public virtual void SetXmacsDefaults()
        {
            if (client==null)
            {
                SetDefaults();
            }

            client.CreateXmacsRequest();
        }

        /*public virtual void SetAskdcDefaults()
        {
            if (client==null)
            {
                SetDefaults();
            }

            if (client.XmacsOutput==null)
            {
                SetXmacsDefaults();
                ExecuteXmacs(true);
            }

            //askdc is a series of requests, not 1 request...
        }*/

        public virtual void SetXkdcDefaults()
        {
            if (client==null)
            {
                SetDefaults();
            }

            if (client.AskdcOutput==null)
            {
                //SetAskdcDefaults(); //but it's not 1 request... hrm
                ExecuteAskdcSeries();
            }

            client.CreateXkdcRequest();

            uint requestVersion = (uint)DefaultXkdcXenonPreauthVersion;

            if (requestVersion == 5 || requestVersion == 6)
            {
                client.XkdcRequest.Input.XenonPreauthVersion = 5;
                if (requestVersion == 6)
                {
                    client.XkdcRequest.Input.ServiceRequestVersion = 6;
                }
            }
            else
            {
                client.XkdcRequest.Input.XenonPreauthVersion = requestVersion;
            }

            //explicitely set the slots in the xkdc request to match the local array
            client.XkdcRequest.Input.UserIDs=new ulong[4];
            for (int u=0; u<4; ++u)
            {
                if (users[u]!=null)
                {
                    client.XkdcRequest.Input.UserIDs[u]=users[u].UserID;
                }
            }
        }

        public void ExecuteXmacs(bool prepareRequest)
        {
            if (client==null || client.XmacsRequest==null)
            {
                SetXmacsDefaults();
            }

            try
            {
                client.ExecuteXmacs(prepareRequest);

                if (ExpectedXmacsKerbError!=0)
                {
                    throw new UnexpectedTestResultException("Expected a kerberos error.");
                }
            }
            catch (KerberosErrorException kee)
            {
                if (ExpectedXmacsKerbError==0)
                {
                    throw;
                }
                else
                {
                    ValueCheck.Test("Expected Kerberos Error", ExpectedXmacsKerbError, kee.Error.ErrorCode.Int64);
                    return; //nothing to validate
                }
            }

            ValidateKerberosReply(client.XmacsReply);
            ValidateXmacs();
        }

        public void ExecuteAskdcSeries()
        {
            if (client==null || Client.AskdcRequest==null)
            {
                //SetAskdcDefaults(); //but it's not 1 request... hrm
                SetXmacsDefaults();
                ExecuteXmacs(true);
            }

            //for pc users using the old passport preauth, we must do the machine last, else we'll now default to doing the machine first.
            bool machineFirst=true;
            if (users.Length>0 && client.CurrentClientType==AuthContext.ClientTypes.Panorama)
            {
                if (users[0]!=null && ((users[0].Passport==null) || (users[0].Passport!=null && !users[0].Passport.EncryptForPanoramaByDefault)))
                {
                    machineFirst=false;
                }
            }

            if (machineFirst)
            {
                client.CreateAskdcMachineRequest();
                client.ExecuteAskdc(true);
            }

            foreach (KdcUser user in users)
            {
                if (user!=null)
                {
                    client.CreateAskdcUserRequest(user);
                    client.ExecuteAskdc(true);
                }
            }

            if (!machineFirst)
            {
                client.CreateAskdcMachineRequest();
                client.ExecuteAskdc(true);
            }

            ValidateKerberosReply(client.AskdcReply);
            //ValidateAskdc(); //todo
        }

        public void ExecuteXkdc(bool prepareRequest)
        {
            if (client==null || client.XkdcRequest==null)
            {
                SetXkdcDefaults();
            }

            try
            {
                client.ExecuteXkdc(prepareRequest);

                if (ExpectXkdcTimeout)
                {
                    throw new UnexpectedTestResultException("Expected request to time out.");
                }

                if (ExpectedXkdcKerbError!=0)
                {
                    throw new UnexpectedTestResultException("Expected a kerberos error.");
                }
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                if (!ExpectXkdcTimeout)
                {
                    throw;
                }
                else //we expected to time out
                {
                    return; //nothing to validate
                }
            }
            catch (KerberosErrorException kee)
            {
                if (ExpectedXkdcKerbError==0)
                {
                    throw;
                }
                else
                {
                    ValueCheck.Test("Expected Kerberos Error", ExpectedXkdcKerbError, kee.Error.ErrorCode.Int64);
                    return; //nothing to validate
                }
            }

            HackUpArbitrationPort(client.XkdcOutput.ServiceResults);

            ValidateKerberosReply(client.XkdcReply);
            ValidateXkdc();
        }

        public void ValidateKerberosReply(KerberosReply reply)
        {
            //the plaintext part is already validated automatically.  validate the encrypted part.
            if (reply.Body==null)
            {
                Global.RO.Warn("Can't validate Kerberos Reply because the body has not been decrypted.");
                return;
            }

            //make sure the required fields are there
            ValueCheck.TestNonZero("Kerberos EncryptedReply Key is not an optional field", reply.Body.Key);
            ValueCheck.TestNonZero("Kerberos EncryptedReply LastRequest is not an optional field", reply.Body.LastRequest);
            ValueCheck.TestNonZero("Kerberos EncryptedReply NOnce is not an optional field", reply.Body.NOnce);
            ValueCheck.TestNonZero("Kerberos EncryptedReply TicketFlags is not an optional field", reply.Body.TicketFlags);
            ValueCheck.TestNonZero("Kerberos EncryptedReply AuthTime is not an optional field", reply.Body.AuthTime);
            ValueCheck.TestNonZero("Kerberos EncryptedReply EndTime is not an optional field", reply.Body.EndTime);
            ValueCheck.TestNonZero("Kerberos EncryptedReply ServerRealm is not an optional field", reply.Body.ServerRealm);
            ValueCheck.TestNonZero("Kerberos EncryptedReply ServerName is not an optional field", reply.Body.ServerName);

            //make sure the key isn't just a bunch of 0's
            if (reply.Body.Key.Key.Bytes.Length==0)
            {
                throw new UnexpectedTestResultException("Kerberos EncryptedReply Key must not be 0 length.");
            }

            bool keyIsAllZero=true;
            foreach (byte b in reply.Body.Key.Key.Bytes)
            {
                if (b!=0)
                {
                    keyIsAllZero=false;
                    break;
                }
            }

            if (keyIsAllZero)
            {
                throw new UnexpectedTestResultException("Kerberos EncryptedReply Key may not be all 0's.");
            }
        }

        public void ValidateXmacs()
        {
            //TODO: More extensive validation

            //Verify that the ticket does not contain any authdata
            if (client.XmacsReply.Ticket!=null && client.XmacsReply.Ticket.EncryptedBody!=null && client.XmacsReply.Ticket.EncryptedBody.AuthorizationData!=null)
            {
                throw new UnexpectedTestResultException("Did not expect to find any authdata in the xmacs ticket.  Found: "+client.XkdcOutput.Ticket.EncryptedBody.AuthorizationData);
            }
        }

        public void ValidateXkdc()
        {
            //verify that the service request preauth we sent matches the service address preauth we got back
            ValueCheck.Test("Number of preauths in the xkdc reply", 1, Client.XkdcReply.Preauths.Length);
            foreach (Kerberos.Preauth pa in Client.XkdcRequest.Preauths)
            {
                if (pa!=null)
                {
                    if (pa.Type.Int64==(new Kerberos.PreauthXboxServiceRequest1()).GetPreauthNumber())
                    {
                        ValueCheck.Test("Service Address preauth", (new Kerberos.PreauthXboxServiceAddress1()).GetPreauthNumber(), Client.XkdcReply.Preauths[0].Type.Int64);
                    }
                    else if (pa.Type.Int64==(new Kerberos.PreauthXenonServiceRequest2()).GetPreauthNumber())
                    {
                        ValueCheck.Test("Service Address preauth", (new Kerberos.PreauthXenonServiceAddress2()).GetPreauthNumber(), Client.XkdcReply.Preauths[0].Type.Int64);
                    }
                    else if (pa.Type.Int64==(new Kerberos.PreauthXenonServiceRequest3()).GetPreauthNumber())
                    {
                        long gotPA=Client.XkdcReply.Preauths[0].Type.Int64;
                        long expectPA0=new Kerberos.PreauthXenonServiceAddress3().GetPreauthNumber();
                        long expectPA1=new Kerberos.PreauthXenonServiceAddressFailure().GetPreauthNumber();
                        if (!(gotPA==expectPA0 || gotPA==expectPA1))
                        {
                            throw new UnexpectedTestResultException("Service Address preauth.  Expected either "+expectPA0+" or "+expectPA1+", but got "+gotPA);
                        }
                    }
                }
            }

            //validate expectations against the service address (part of which is summarized in the xkdc output)
            ValueCheck.Test("Overall HR", ExpectedOverallHR, client.XkdcOutput.Hr);

            if (client.XkdcOutput.Hr==0 && client.XkdcOutput.SiteIP=="0.0.0.0")
            {
                throw new UnexpectedTestResultException("Possibly uninitialized IP address returned in Service Address preauth.");
            }

            ValidateXkdcMachine();
            ValidateXkdcUsers();
            ValidateXkdcServices();
            ValidateXkdcFlowToken();
            ValidateXkdcTitle();

            //verify the authdata in the ticket matches the service address preauth in the reply
            ValidateXkdcAuthData();
        }

        public void ValidateXkdcMachine()
        {
            //verify the client name (in the kerberos reply itself)
            ValueCheck.Test("ClientName Type in XkdcReply", 2, client.XkdcReply.ClientName.Type.Int64);
            ValueCheck.Test("ClientName Count in XkdcReply", 2, client.XkdcReply.ClientName.Names.Length);
            string expectedConsoleName=client.XmacsOutput.ConsoleId;
            int expectedConsoleNameXboxComIndex=expectedConsoleName.IndexOf("@XBOX.COM");
            if (expectedConsoleNameXboxComIndex!=-1) //strip this off for the PC case
            {
                expectedConsoleName=expectedConsoleName.Substring(0, expectedConsoleNameXboxComIndex);
            }
            //ValueCheck.Test("ClientName[0] in XkdcReply", expectedConsoleName, client.XkdcReply.ClientName.Names[0].Value.String); //TODO: TFS bug 73327.  When authenticating machine first, xkdc has the wrong thing here.  But xkdc doesn't readily have the right thing available, so fix is non-trivial.  Sg still accepts the ticket, so for now just removing this check.
            ValueCheck.Test("ClientName[1] in XkdcReply", "PASSPORT.NET", client.XkdcReply.ClientName.Names[1].Value.String);

            //machine privileges
            if (!(ClientType==AuthContext.ClientTypes.Xbox || ClientType==AuthContext.ClientTypes.XenonBackCompat))
            {
                string mismatchedPrivileges="";
                for (int p=128; p<160; ++p)
                {
                    if (ExpectedMachinePrivileges[p]!=client.XkdcOutput.GetMachinePrivilegeBit(p))
                    {
                        if (ExpectedMachinePrivileges[p])
                        {
                            mismatchedPrivileges+="Expected "+p+"  ";
                        }
                        else
                        {
                            mismatchedPrivileges+="Did NOT Expect "+p+"  ";
                        }
                    }
                }

                if (mismatchedPrivileges.Length>0)
                {
                    throw new UnexpectedTestResultException("Machine "+expectedConsoleName+" privileges mismatched: "+mismatchedPrivileges);
                }
            }
        }

        public void ValidateXkdcUsers()
        {
            for (int u=0; u<4; ++u)
            {
                ValueCheck.Test("User"+u+" HR", ExpectedUserHRs[u], client.XkdcOutput.HrUser[u]);

                //user priviliges
                if (!Client.XkdcReply.ReplyWasServiceAddressFailure) //struct has no priviliges
                {
                    string mismatchedPrivileges="";
                    for (int p=160; p<256; ++p)
                    {
                        if (ExpectedUserPrivileges[u][p]!=client.XkdcOutput.GetUserPrivilegeBit(u, p))
                        {
                            if (ExpectedUserPrivileges[u][p])
                            {
                                mismatchedPrivileges+="Expected "+p+"  ";
                            }
                            else
                            {
                                //this is a horrible hack, but I don't see any other sensible way to make it work in all cases.
                                //as of 2011 febuary, the xbox360 dash title id grants privilege 221.  detect this case and ignore the mismatch.
                                if (p==221 && client!=null && client.XkdcRequest!=null && client.XkdcRequest.Input!=null && client.XkdcRequest.Input.TitleID==0xfffe07d1)
                                {
                                    //allow this through
                                }
                                else
                                {
                                    mismatchedPrivileges+="Did NOT Expect "+p+"  ";
                                }
                            }
                        }
                    }

                    if (mismatchedPrivileges.Length>0)
                    {
                        throw new UnexpectedTestResultException("User "+users[u].Gamertag+" privileges mismatched: "+mismatchedPrivileges);
                    }
                }

                //user flags (see TestBase_Xkdc.cs VerifyUserFlags() for details)
                if (!Client.XkdcReply.ReplyWasServiceAddressFailure) //struct has no flags
                {
                    uint actualTier=UserFlagsUtil.UserTierId(client.XkdcOutput.UserFlags[u]);
                    if (actualTier!=ExpectedUserTier[u])
                    {
                        throw new UnexpectedTestResultException("User flags tier for user "+users[u].Gamertag+", expected "+ExpectedUserTier[u]+" but got "+actualTier);
                    }

                    uint actualCountry=UserFlagsUtil.UserCountryId(client.XkdcOutput.UserFlags[u]);
                    if (actualCountry!=ExpectedUserCountryId[u])
                    {
                        throw new UnexpectedTestResultException("User flags country id for user "+users[u].Gamertag+", expected "+ExpectedUserCountryId[u]+" but got "+actualCountry);
                    }

                    /*uint actualLanguage=UserFlagsUtil.UserLanguageId(client.XkdcOutput.UserFlags[u]);
                    if (actualLanguage!=ExpectedUserLanguageId[u])
                    {
                        throw new UnexpectedTestResultException("User flags language id for user "+users[u].Gamertag+", expected "+ExpectedUserLanguageId[u]+" but got "+actualLanguage);
                    }*/

                    uint actualGuest=UserFlagsUtil.UserGuestNumber(client.XkdcOutput.UserFlags[u]);
                    if (actualGuest!=ExpectedUserGuestNumber[u])
                    {
                        throw new UnexpectedTestResultException("User flags guest number for user "+users[u].Gamertag+", expected "+ExpectedUserGuestNumber[u]+" but got "+actualGuest);
                    }
                }
            }
        }

        public void ValidateXkdcServices()
        {
            if (Client.XkdcReply.ReplyWasServiceAddressFailure) //struct has no services
            {
                return;
            }

            //validate that the set of services matches expectations
            XkdcGenericReplyOutput.ServiceResult []expectedServices=ExpectedServices;
            if (expectedServices==null)
            {
                uint titleId=0;
                if (client!=null && client.XkdcRequest!=null && client.XkdcRequest.Input!=null)
                {
                    titleId=client.XkdcRequest.Input.TitleID;
                }
                expectedServices=GetCurrentDefaultServiceExpectations(titleId);
            }

            System.Collections.Generic.LinkedList<uint> servicesExpectedButNotFound=new System.Collections.Generic.LinkedList<uint>();
            System.Collections.Generic.LinkedList<uint> servicesFoundButNotExpected=new System.Collections.Generic.LinkedList<uint>();

            foreach (XkdcGenericReplyOutput.ServiceResult s in expectedServices)
            {
                servicesExpectedButNotFound.AddLast(s.Service);
            }

            foreach (XkdcGenericReplyOutput.ServiceResult s in client.XkdcOutput.ServiceResults)
            {
                servicesFoundButNotExpected.AddLast(s.Service);
            }

            foreach (XkdcGenericReplyOutput.ServiceResult s in expectedServices)
            {
                servicesFoundButNotExpected.Remove(s.Service);
            }

            foreach (XkdcGenericReplyOutput.ServiceResult s in client.XkdcOutput.ServiceResults)
            {
                servicesExpectedButNotFound.Remove(s.Service);
            }

            string servicesMismatchedError="";
            foreach (uint s in servicesExpectedButNotFound)
            {
                servicesMismatchedError+="Expected result for service "+s+" but got none.  ";
            }

            foreach (uint s in servicesFoundButNotExpected)
            {
                servicesMismatchedError+="Expected no result for service "+s+" but got one.  ";
            }

            if (servicesMismatchedError!="")
            {
                if (servicesExpectedButNotFound.Count == 1 && servicesExpectedButNotFound.First.Value == 0)
                {
                    throw new KnownBugException(135407, "Xbox 360 Console Software");
                }

                throw new UnexpectedTestResultException(servicesMismatchedError);
            }

            //validate that the hr and port for each service is what we expect
            servicesMismatchedError="";
            foreach (XkdcGenericReplyOutput.ServiceResult sExpect in expectedServices)
            {
                foreach (XkdcGenericReplyOutput.ServiceResult sGot in client.XkdcOutput.ServiceResults)
                {
                    if (sExpect.Service==sGot.Service)
                    {
                        if (sExpect.Hr!=sGot.Hr)
                        {
                            if (!(sExpect.Hr==HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED && sGot.Hr==2)) //2 means not authorized in v5, so accept it
                            {
                                servicesMismatchedError+=string.Format("Service {0} Expected HR=0x{1:X} Got HR=0x{2:X}.  ", sGot.Service, sExpect.Hr, sGot.Hr);
                            }
                        }

                        if (sExpect.Port!=sGot.Port)
                        {
                            servicesMismatchedError+=string.Format("Service {0} Expected Port={1} Got Port={2}.  ", sGot.Service, sExpect.Port, sGot.Port);
                        }

                        break;
                    }
                }
            }

            if (servicesMismatchedError!="")
            {
                throw new UnexpectedTestResultException(servicesMismatchedError);
            }

            if (ClientType==AuthContext.ClientTypes.Xbox || ClientType==AuthContext.ClientTypes.XenonBackCompat)
            {
                //todo: for now we'll stop xbox1 checks here, eventually we should implement a path for verifying authdata against their service request/address though
                return;
            }

            //verify that the 4 dword slots line up between the request and the response
            Kerberos.PreauthXenonServiceAddressBase sa=FindServiceAddressPreauth();
            Kerberos.PreauthXenonServiceRequestBase sr=FindServiceRequestPreauth();

            for (int dw=0; dw<4 && sr.AutoDiscoverServices==0; ++dw)
            {
                ValueCheck.Test("Dword service ID matches request in slot "+dw, sr.DwordServiceIDs[dw], sa.DwordServiceResult[dw].ServiceID);
            }
        }

        public void ValidateXkdcAuthData()
        {
            if (Client.XkdcReply.ReplyWasServiceAddressFailure) //struct has no authdata
            {
                return;
            }

            //grab the authdata from the ticket
            if (client.XkdcOutput.Ticket.EncryptedBody.AuthorizationData==null)
            {
                throw new UnexpectedTestResultException("Cannot verify AuthData because the ticket has not been decrypted.");
            }

            XboxAuthDataBase adXbox=null;
            foreach (Kerberos.CommonTypeDataSequence ctds in client.XkdcOutput.Ticket.EncryptedBody.AuthorizationData.List.Values)
            {
                if (adXbox==null && ctds is XboxAuthDataBase)
                {
                    adXbox=(XboxAuthDataBase)ctds;
                }
                else
                {
                    throw new UnexpectedTestResultException("Unexpected AuthData found in Xkdc ticket:\n"+ctds);
                }
            }

            if (adXbox==null)
            {
                throw new UnexpectedTestResultException("Ticket does not contain any xbox AuthData.");
            }

            if (ClientType==AuthContext.ClientTypes.Xbox || ClientType==AuthContext.ClientTypes.XenonBackCompat)
            {
                //todo: for now we'll stop xbox1 checks here, eventually we should implement a path for verifying authdata against their service request/address though
                return;
            }

            //grab the relevent preauths to compare against
            Kerberos.PreauthXenonServiceAddressBase sa=FindServiceAddressPreauth();
            Kerberos.PreauthXenonServiceRequestBase sr=FindServiceRequestPreauth();

            //validate all fields of the xbox authdata and compare it to the data in the service address/request
            ValueCheck.Test("Authdata version", ExpectedAuthDataVersion, adXbox.AuthDataVersion);
            ValueCheck.Test("Authdata ClientMajorVersion", sr.ClientVersionMajor, adXbox.ClientMajorVersion);
            ValueCheck.Test("Authdata ClientMinorVersion", sr.ClientVersionMinor, adXbox.ClientMinorVersion);
            ValueCheck.Test("Authdata ClientVersionBuild", sr.ClientVersionBuild, adXbox.ClientBuildNumber);
            ValueCheck.Test("Authdata ClientVersionQFE",   sr.ClientVersionQFE,   adXbox.ClientQFENumber);
            ValueCheck.Test("Authdata XboxID", client.XmacsOutput.MachineId, adXbox.XboxID);
            ValueCheck.Test("Authdata TitleID", sr.TitleID, adXbox.TitleID);
            ValueCheck.Test("Authdata TitleVersion", sr.TitleVersion, adXbox.TitleVersion);
            ValueCheck.Test("Authdata TitleRegion", sr.TitleRegion, adXbox.TitleRegion);

            bool keyIsAllZeros=true;
            foreach (byte b in adXbox.Key)
            {
                if (b!=0)
                {
                    keyIsAllZeros=false;
                    break;
                }
            }

            if (keyIsAllZeros)
            {
                throw new UnexpectedTestResultException("Authdata Key is all 0's");
            }

            //todo: console trust factor

            for (int u=0; u<4; ++u)
            {
                ValueCheck.Test("Authdata User"+u+" puid", sr.UserIDs[u], adXbox.GetUser((uint)u).UserID);
                ValueCheck.Test("Authdata User"+u+" flags", sa.UserFlags[u], adXbox.GetUser((uint)u).UserFlags);
            }

            if (adXbox is XenonAuthDataBase)
            {
                XenonAuthDataBase adXenon=(XenonAuthDataBase)adXbox;

                ValueCheck.Test("Authdata ConsoleRegion", sr.ConsoleRegion, adXenon.ConsoleRegion);
                ValueCheck.Test("Authdata MediaID", sr.MediaID, adXenon.MediaId);
                ValueCheck.Test("Authdata LanguageID", sr.LanguageID, adXenon.LanguageId);
                //todo: AuthDataFlags

                string serviceBitsWrong="";
                for (int s=0; s<128; ++s)
                {
                    bool saServiceGranted=(sa.GetByteServiceResult(s)==0);
                    if (saServiceGranted!=adXenon.HasService((uint)s))
                    {
                        if (saServiceGranted)
                        {
                            serviceBitsWrong+="Expected "+s+"  ";
                        }
                        else
                        {
                            serviceBitsWrong+="Did Not Expect "+s+"  ";
                        }
                    }
                }
                if (serviceBitsWrong.Length>0)
                {
                    throw new UnexpectedTestResultException("Authdata byte services mismatch: "+serviceBitsWrong);
                }

                System.Collections.Generic.List<uint> expectedDwordServices=new System.Collections.Generic.List<uint>();
                foreach (Kerberos.XenonServiceResult xsr in sa.DwordServiceResult)
                {
                    if (xsr.Result==0 && xsr.ServiceID!=0)
                    {
                        expectedDwordServices.Add(xsr.ServiceID);
                    }
                }

                System.Collections.Generic.List<uint> gotDwordServices=new System.Collections.Generic.List<uint>();
                foreach (uint dws in adXenon.GetDwordServicesArray())
                {
                    if (dws!=0)
                    {
                        gotDwordServices.Add(dws);
                    }
                }

                ValueCheck.TestAllUnordered("Authdata dword services", expectedDwordServices, gotDwordServices);

                if (adXenon is XenonXkdcAuthData)
                {
                    //figure out the expected privilege bits
                    BitArray expectedPrivileges=new BitArray(256);
                    expectedPrivileges.SetAll(false);
                    bool firstUserProcessed=false;

                    for (int u=0; u<4; ++u)
                    {
                        if (sr.UserIDs[u]!=0 && sa.HrUser[u]==0)
                        {
                            BitArray expectedUserBits=new BitArray(256);
                            expectedUserBits.SetAll(false);
                            if (sa is Kerberos.PreauthXenonServiceAddress2)
                            {
                                for (int p=128; p<160; ++p)
                                {
                                    if (sa.GetUserPrivilegeBit(u, p))
                                    {
                                        expectedUserBits.Set(p, true);
                                    }
                                }
                            }
                            else //PreauthXenonServiceAddress3
                            {
                                for (int p=128; p<160; ++p)
                                {
                                    if (((Kerberos.PreauthXenonServiceAddress3)sa).GetMachinePrivilegeBit(p))
                                    {
                                        expectedUserBits.Set(p, true);
                                    }
                                }
                            }

                            for (int p=160; p<256; ++p)
                            {
                                if (sa.GetUserPrivilegeBit(u, p))
                                {
                                    expectedUserBits.Set(p, true);
                                }
                            }

                            if (!firstUserProcessed)
                            {
                                expectedPrivileges.Or(expectedUserBits);
                            }
                            else
                            {
                                expectedPrivileges.And(expectedUserBits);
                            }

                            firstUserProcessed=true;
                        }
                    }

                    //compare to what's in the authdata
                    string mismatchedPrivileges="";
                    for (int p=128; p<256; ++p)
                    {
                        if (expectedPrivileges[p]!=adXenon.HasPrivilege((uint)p))
                        {
                            if (expectedPrivileges[p])
                            {
                                mismatchedPrivileges+="Expected "+p+"  ";
                            }
                            else
                            {
                                //this is a horrible hack, but I don't see any other sensible way to make it work in all cases.
                                //as of 2011 febuary, the xbox360 dash title id grants privilege 221.  detect this case and ignore the mismatch.
                                if (p==221 && adXenon.TitleID==0xfffe07d1)
                                {
                                    //allow this through
                                }
                                else
                                {
                                    mismatchedPrivileges+="Did Not Expect "+p+"  ";
                                }
                            }
                        }
                    }
                    if (mismatchedPrivileges.Length>0)
                    {
                        throw new UnexpectedTestResultException("Authdata privileges mismatch: "+mismatchedPrivileges);
                    }
                }
                else if (adXenon is Xenon2XkdcAuthData)
                {
                    //user privileges
                    for (int u=0; u<4; ++u)
                    {
                        BitArray expected=new BitArray(256);
                        expected.SetAll(false);
                        BitArray got=new BitArray(256);
                        got.SetAll(false);

                        for (int p=160; p<256; ++p)
                        {
                            if (sa.GetUserPrivilegeBit(u, p))
                            {
                                expected.Set(p, true);
                            }

                            if (adXenon.HasPrivilege((uint)p, (uint)u))
                            {
                                got.Set(p, true);
                            }
                        }

                        string mismatchedPrivileges="";
                        for (int p=160; p<256; ++p)
                        {
                            if (expected[p]!=got[p])
                            {
                                if (expected[p])
                                {
                                    mismatchedPrivileges+="Expected "+p+"  ";
                                }
                                else
                                {
                                    mismatchedPrivileges+="Did Not Expect "+p+"  ";
                                }
                            }
                        }
                        if (mismatchedPrivileges.Length>0)
                        {
                            throw new UnexpectedTestResultException("Authdata user"+u+"("+users[u].Gamertag+") privileges mismatch: "+mismatchedPrivileges);
                        }
                    }

                    //machine privileges
                    BitArray expectedMachinePrivileges=new BitArray(256);
                    expectedMachinePrivileges.SetAll(false);

                    if (sa is Kerberos.PreauthXenonServiceAddress2)
                    {
                        for (int u=0; u<4; ++u)
                        {
                            if (sr.UserIDs[u]!=0 && sa.HrUser[u]==0)
                            {
                                for (int p=128; p<160; ++p)
                                {
                                    if (sa.GetUserPrivilegeBit(u, p))
                                    {
                                        expectedMachinePrivileges.Set(p, true);
                                    }
                                }
                                break;
                            }
                        }
                    }
                    else //PreauthXenonServiceAddress3
                    {
                        for (int p=128; p<160; ++p)
                        {
                            if (((Kerberos.PreauthXenonServiceAddress3)sa).GetMachinePrivilegeBit(p))
                            {
                                expectedMachinePrivileges.Set(p, true);
                            }
                        }
                    }

                    {
                        string mismatchedPrivileges="";
                        for (int p=128; p<160; ++p)
                        {
                            if (expectedMachinePrivileges[p]!=((Xenon2XkdcAuthData)adXenon).HasPrivilege((uint)p))
                            {
                                if (expectedMachinePrivileges[p])
                                {
                                    mismatchedPrivileges+="Expected "+p+"  ";
                                }
                                else
                                {
                                    //this is a horrible hack, but I don't see any other sensible way to make it work in all cases.
                                    //as of 2011 febuary, the xbox360 dash title id grants privilege 221.  detect this case and ignore the mismatch.
                                    if (p==221 && adXenon.TitleID==0xfffe07d1)
                                    {
                                        //allow this through
                                    }
                                    else
                                    {
                                        mismatchedPrivileges+="Did Not Expect "+p+"  ";
                                    }
                                }
                            }
                        }
                        if (mismatchedPrivileges.Length>0)
                        {
                            throw new UnexpectedTestResultException("Authdata machine privileges mismatch: "+mismatchedPrivileges);
                        }
                    }

                    //console trust factor
                    if (((Xenon2XkdcAuthData)adXenon).ConsoleTrustFactor != 0.0f)
                    {
                        throw new UnexpectedTestResultException("Unexpected console trust factor. Currently should always be 0. Value:" + ((Xenon2XkdcAuthData)adXenon).ConsoleTrustFactor);
                    }
                }
                else
                {
                    Global.RO.Warn("Unhandled authdata type in TestBase_KdcClient.ValidateXkdcAuthData()");
                }

                //alt title IDs
                System.Collections.Generic.List<uint> expectedAltTitleIDs=new System.Collections.Generic.List<uint>();
                foreach (Kerberos.XboxServiceAlternateTitleID xsatid in sa.AltLiveTitleIds)
                {
                    if (xsatid.AltTitleID!=0)
                    {
                        expectedAltTitleIDs.Add(xsatid.AltTitleID);
                    }
                }

                expectedAltTitleIDs.Add(sa.LiveTitleId); //add the requested title ID to the expected also.  There is some weird historical reason/hack that the server is putting it in the authdata.  todo: what happens if there are 4 real alt title IDs?

                System.Collections.Generic.List<uint> gotAltTitleIDs=new System.Collections.Generic.List<uint>();
                for (int bam=0; bam<4; ++bam)
                {
                    if (adXenon.GetAltTitleId((uint)bam)!=0)
                    {
                        gotAltTitleIDs.Add(adXenon.GetAltTitleId((uint)bam));
                    }
                }

                ValueCheck.TestAllUnordered("Authdata Alt Title IDs", expectedAltTitleIDs, gotAltTitleIDs);                

                //todo: user trust factors
            }
        }

        public void ValidateXkdcFlowToken()
        {
            if (Client.XkdcReply.ReplyWasServiceAddressFailure) //struct has no flow token
            {
                return;
            }

            if (ClientType==AuthContext.ClientTypes.Xbox || ClientType==AuthContext.ClientTypes.XenonBackCompat)
            {
                //todo: for now we'll stop xbox1 checks here, eventually we should validate authdata somehow though.
                return;
            }

            //find the authdata and service request/address of the appropriate version if we can
            Xenon2XkdcAuthData ad4=Client.XkdcOutput.XboxAuthData as Xenon2XkdcAuthData;
            Kerberos.PreauthXenonServiceRequest3 sr3=FindServiceRequestPreauth() as Kerberos.PreauthXenonServiceRequest3;
            Kerberos.PreauthXenonServiceAddress3 sa3=FindServiceAddressPreauth() as Kerberos.PreauthXenonServiceAddress3;

            //verify that the request matches the reply unless the request was 0
            if (sr3!=null)
            {
                if (sa3.FlowToken==0) //should never get 0 back
                {
                    throw new UnexpectedTestResultException("Flow token in the XenonServiceAddress3 Preauth is 0.");
                }

                if (sr3.FlowToken!=0) //should match request if request was not 0
                {
                    ValueCheck.Test("Flow token in the XenonServiceAddress3 Preauth", sr3.FlowToken, sa3.FlowToken);
                }
            }

            if (ad4!=null)
            {
                if (ad4.FlowToken==0) //should never get 0 back
                {
                    throw new UnexpectedTestResultException("Flow token in AuthDataV4 is 0.");
                }

                if (sa3!=null) //should match the service address
                {
                    ValueCheck.Test("Flow token the AuthDataV4", sa3.FlowToken, ad4.FlowToken);
                }
            }
        }

        public void ValidateXkdcTitle()
        {
            if (Client.XkdcReply.ReplyWasServiceAddressFailure) //struct has no title
            {
                return;
            }

            if (ClientType==AuthContext.ClientTypes.Xbox || ClientType==AuthContext.ClientTypes.XenonBackCompat)
            {
                //todo: for now we'll stop xbox1 checks here, eventually we should validate authdata somehow though.
                return;
            }

            Kerberos.PreauthXenonServiceAddressBase sa=FindServiceAddressPreauth();
            Kerberos.PreauthXenonServiceRequestBase sr=FindServiceRequestPreauth();
            ValueCheck.Test("Service Address preauth LiveTitleId", sr.TitleID, sa.LiveTitleId);

            ValueCheck.TestAllUnordered("Service Address Alt title IDs", ExpectedAltTitleIDs, sa.AltLiveTitleIds);
        }

        public Kerberos.PreauthXenonServiceAddressBase FindServiceAddressPreauth()
        {
            foreach (Kerberos.Preauth pa in Client.XkdcReply.Preauths)
            {
                if (pa!=null && pa.Data is Kerberos.PreauthXenonServiceAddressBase)
                {
                    return (Kerberos.PreauthXenonServiceAddressBase)pa.Data;
                }
            }

            throw new UnexpectedTestResultException("XenonServiceAddress Preauth not found.");
        }

        public Kerberos.PreauthXenonServiceRequestBase FindServiceRequestPreauth()
        {
            foreach (Kerberos.Preauth pa in Client.XkdcRequest.Preauths)
            {
                if (pa!=null && pa.Data is Kerberos.PreauthXenonServiceRequestBase)
                {
                    return (Kerberos.PreauthXenonServiceRequestBase)pa.Data;
                }
            }

            throw new UnexpectedTestResultException("XenonServiceRequest Preauth not found in request??");
        }

        //clear out any old stuff before we start
        public override void PreRun()
        {
            client=null;
            SetDefaults();

            ExpectedMachinePrivileges=new BitArray(256);
            foreach (uint priv in Expectations.k_DefaultExpectedMachinePrivileges)
            {
                ExpectedMachinePrivileges.Set((int)priv, true);
            }

            ExpectedUserPrivileges=new BitArray[4]{new BitArray(256), new BitArray(256), new BitArray(256), new BitArray(256)};
            ExpectedUserHRs=new uint[4]{0, 0, 0, 0};
            ExpectedUserGuestNumber=new uint[4]{0, 0, 0, 0};
            ExpectedUserCountryId=new uint[4]{0, 0, 0, 0};
            ExpectedUserTier=new uint[4]{0, 0, 0, 0};

            users=new KdcUser[4];

            ExpectedServices=null;

            ExpectedAltTitleIDs=new Kerberos.XboxServiceAlternateTitleID[4];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\StressNegative.cs ===
using System;
using System.Threading;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    [TestGroup]
    public class StressNegative: TestNode
    {
        //xmacs stress tests
        //silent failure counter is so low (0.01tps) it's not worth writing.
        //time skew is handled by the global stress case to cause them

        //askdc stress tests
        [StressTest]
        [CompoundCase("Bad Principal", false, 1, false, 0)]
        [CompoundCase("Replay",        true,  1, true,  1)]
        //[time skew] - run the global stress case to cause them
        public class Askdc: TestNode
        {
            TimedQueue<AuthContext> authContextCache;

            //each instance type gets its own cache
            public override void OneTimeSetup()
            {
                authContextCache=new TimedQueue<AuthContext>();
                authContextCache.MinimumReuseTime=new TimeSpan(0,0,0,1,25); //1s (2 in 1sec = ignore request)
            }

            //run
            public override void Run()
            {
                bool shouldSucceed=(bool)MyValues[0]; //(at initial request)
                int numUsers=(int)MyValues[1];
                bool validPrincipal=(bool)MyValues[2];
                int replayCount=(int)MyValues[3];
                bool newPassports=false;

                //get or set up a context to use
                AuthContext ctx=authContextCache.PopFront();
                if (ctx==null)
                {
                    ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                    StressCommon.SignInAskdc(ctx, false, true, false); //get up the machine account part

                    //set users
                    for (int i=0; i<numUsers; ++i)
                    {
                        if (!newPassports) //bulk users
                        {
                            uint buInd=StressCommon.GetNextBulkUserIndex();
                            string gamertag=STFLiveGlobal.GetUserSet("xenon").IndexToGamertag(buInd);
                            byte[] key=STFLiveGlobal.GetUserSet("xenon").IndexToXenonKey2(buInd);
                            ctx.Users[i]=AuthContext.MakeUser(gamertag, key);
                        }
                        else //new users with passports
                        {
                            ctx.SetNewPassportUser(i, false);
                        }

                        if (!validPrincipal)
                        {
                            ctx.Users[i].Gamertag[0]=(byte)'b';
                            ctx.Users[i].Gamertag[1]=(byte)'a';
                            ctx.Users[i].Gamertag[2]=(byte)'d';
                        }
                    }
                }

                //do request
                bool passed=false;
                try
                {
                    AskdcClient askdc=new AskdcClient(ctx);
                    ctx.ClearAskdc();
                    askdc.EmulateClientBehavior=StressCommon.EmulateClientBehavior;
                    try
                    {
                        askdc.SignInAskdc();
                        if (shouldSucceed)
                        {
                            passed=true;
                        }
                        else
                        {
                            Global.RO.Error("Did not expect to succeed");
                        }
                    }
                    catch (Exception e)
                    {
                        if (shouldSucceed)
                        {
                            Global.RO.Error("Did not expect to fail: "+e);
                        }
                        else
                        {
                            passed=true;
                        }
                    }

                    for (int i=0; i<replayCount; ++i)
                    {
                        askdc.ResendLastPacket();
                    }
                }
                finally
                {
                    //return context to cache (unless it's a limited token that is out of uses)
                    if (passed || StressCommon.AlwaysRetainContext)
                    {
                        authContextCache.PushBack(ctx);
                    }
                }

                if (!passed)
                {
                    throw new UnexpectedTestResultException();
                }
            }
        };

        //xkdc negative cases
        [StressTest]
        [CompoundCase("Replay 1",  1,  true)]
        [CompoundCase("Replay 10", 10, true)]
        [CompoundCase("Bad Title", 0,  false)]
        public class Xkdc: TestNode
        {
            TimedQueue<AuthContext> authContextCache;

            //each instance type gets its own cache
            public override void OneTimeSetup()
            {
                authContextCache=new TimedQueue<AuthContext>();
                authContextCache.MinimumReuseTime=new TimeSpan(0,0,0,1*4,25); //1s (60 in 60sec = tempban), eyeballing at up to 4 requests per use
            }

            //run
            public override void Run()
            {
                int replayCount=(int)MyValues[0];
                bool validTitle=(bool)MyValues[1];

                //get or set up a context to use
                AuthContext ctx=authContextCache.PopFront();
                if (ctx==null)
                {
                    ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                    StressCommon.SignInAskdc(ctx, false, true, true);

                    if (!validTitle) //set bad title
                    {
                        ctx.SetTitle(0xbad7171e, 7, 0);
                    }
                }

                //do request
                bool passed=true;
                try
                {
                    //do normal request
                    XkdcClient xkdc=new XkdcClient(ctx);
                    xkdc.EmulateClientBehavior=StressCommon.EmulateClientBehavior;
                    xkdc.SignInXkdc();

                    //replay it
                    for (int i=0; i<replayCount; ++i)
                    {
                        xkdc.ResendLastPacket();
                    }
                }
                finally
                {
                    if (passed || StressCommon.AlwaysRetainContext)
                    {
                        authContextCache.PushBack(ctx);
                    }
                }
            }
        };

        //change the global time skew for all request for 1ms, then turn it back off
        //Run this at a non-harmonic speed related to the other tests (for example: 11.12345 tps)
        [StressTest]
        public void SetTimeSkewFor1ms()
        {
            if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<50)
                AuthClientBase.DLL_SetTimeSkew(1000);
            else
                AuthClientBase.DLL_SetTimeSkew(-1000);

            System.Threading.Thread.Sleep(1);

            AuthClientBase.DLL_SetTimeSkew(0);
        }

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\StressNew.cs ===
using System;
using System.Threading;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;

#pragma warning disable 420 //a reference to a volatile field will not be treated as volatile

namespace XkdcTest
{
    #region Stress Tests
    [TestGroup]
    public class StressNew: TestNode
    {
        //setup
        public override void PreRun()
        {
            if (!StressCommon.SkipStressSetup)
            {
                StressSetup.RunSetup(this);
            }
        }

        //xmacs stress tests
        [StressTest, Description("Machine account creation and reset tests")]
        //                                        type                              clear  limited usetestkey usePc2Preauth
        [CompoundCase("Create Xenon",             AuthContext.ClientTypes.Xenon,    true,  false,  false,     false)]
        [CompoundCase("Create Xenon TestKey",     AuthContext.ClientTypes.Xenon,    true,  false,  true,      false)]
        [CompoundCase("Create Panorama",          AuthContext.ClientTypes.Panorama, true,  false,  false,     false)]
        [CompoundCase("Create PanoramaLimited",   AuthContext.ClientTypes.Panorama, true,  true,   false,     false)]
        [CompoundCase("Create Panorama2 TestKey", AuthContext.ClientTypes.Panorama, true,  false,  true,      true)]
        [CompoundCase("Create Panorama2",         AuthContext.ClientTypes.Panorama, true,  false,  false,     true)]
        [CompoundCase("Reset Xenon",              AuthContext.ClientTypes.Xenon,    false, false,  false,     false)]
        [CompoundCase("Reset Panorama",           AuthContext.ClientTypes.Panorama, false, false,  false,     false)]
        [CompoundCase("Reset PanoramaLimited",    AuthContext.ClientTypes.Panorama, false, true,   false,     false)]
        [CompoundCase("Reset Panorama2",          AuthContext.ClientTypes.Panorama, false, false,  false,     true)]
        public class Xmacs: TestNode
        {
            TimedQueue<AuthContext> authContextCache; //note that each compound instance has a separate copy of this

            //each instance type gets its own cache
            public override void OneTimeSetup()
            {
                authContextCache=new TimedQueue<AuthContext>();
                authContextCache.MinimumReuseTime=new TimeSpan(0,0,0,3,25); //3s (20 in 60sec = tempban)
            }

            //run
            public override void Run()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)MyValues[0];
                bool clearXmacs=(bool)MyValues[1];
                bool isLimitedPc=(bool)MyValues[2];
                bool useTestKey=(bool)MyValues[3];
                bool useNewPcPreauth=(bool)MyValues[4];

                //get or set up a context to use
                AuthContext ctx=authContextCache.PopFront();
                if (ctx==null)
                {
                    ctx=new AuthContext((AuthContext.ClientTypes)clientType);

                    ctx.UseXmacsTestKey=useTestKey;

                    if (isLimitedPc) //limited pc machine
                    {
                        ctx.SponsorToken=PanoramaLimited.c_LimitedToken;
                        ctx.IsPCLimited=true;
                    }

                    if (useNewPcPreauth)
                    {
                        ctx.DefaultPcXmacsPreauth=2;
                    }
                }

                //do request
                bool passed=false;
                try
                {
                    if (clearXmacs)
                    {
                        ctx.ClearXmacs();
                    }

                    StressCommon.SignInXmacs(ctx, false);
                    passed=true;
                }
                finally
                {
                    //return context to cache (unless it's a limited token that is out of uses)
                    if ((passed || StressCommon.AlwaysRetainContext) && !(ctx.IsPCLimited && ctx.LimitedMacsLeft==0))
                    {
                        authContextCache.PushBack(ctx);
                    }
                }
            }
        };

        //askdc stress tests
        [StressTest, Description("Askdc tests")]
        //                                          type                              bulk   usercount forcenewuser encpassport
        [CompoundCase("Xenon MachineOnly",          AuthContext.ClientTypes.Xenon,    true,  0,        false,       false)]
        [CompoundCase("Xenon 1User",                AuthContext.ClientTypes.Xenon,    true,  1,        false,       false)]
        [CompoundCase("Xenon 1User EncPassport",    AuthContext.ClientTypes.Xenon,    false, 1,        false,       true)]
        [CompoundCase("Xenon 4User",                AuthContext.ClientTypes.Xenon,    true,  4,        false,       false)]
        [CompoundCase("Xenon NewRealUser",          AuthContext.ClientTypes.Xenon,    false, 1,        true,        false)]
        [CompoundCase("Panorama MachineOnly",       AuthContext.ClientTypes.Panorama, true,  0,        false,       false)]
        [CompoundCase("Panorama 1User",             AuthContext.ClientTypes.Panorama, false, 1,        false,       false)]
        [CompoundCase("Panorama 1User EncPassport", AuthContext.ClientTypes.Panorama, false, 1,        false,       true)]
        public class Askdc: TestNode
        {
            TimedQueue<AuthContext> authContextCache; //note that each compound instance has a separate copy of this

            //each instance type gets its own cache
            public override void OneTimeSetup()
            {
                authContextCache=new TimedQueue<AuthContext>();
                authContextCache.MinimumReuseTime=new TimeSpan(0,0,0,1,25); //1s (2 in 1sec = ignore request)
            }

            //run
            public override void Run()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)MyValues[0];

                //get or set up a context to use
                AuthContext ctx=authContextCache.PopFront();
                if (ctx==null)
                {
                    ctx=new AuthContext(clientType);

                    //set users
                    int numUsers=(int)MyValues[2];
                    for (int i=0; i<numUsers; ++i)
                    {
                        if ((bool)MyValues[1]) //bulk users
                        {
                            uint buInd=StressCommon.GetNextBulkUserIndex();
                            string gamertag=STFLiveGlobal.GetUserSet("xenon").IndexToGamertag(buInd);
                            byte[] key=STFLiveGlobal.GetUserSet("xenon").IndexToXenonKey2(buInd);
                            ctx.Users[i]=AuthContext.MakeUser(gamertag, key);
                        }
                        else //new users with passports
                        {
                            ctx.SetNewPassportUser(i, false);
 
                            if ((bool)MyValues[4]) //EncPassport
                            {
                                ctx.IncludeEncryptedPassportByDefault=true;
                                if (clientType==AuthContext.ClientTypes.Panorama)
                                {
                                    ctx.PassportAuthenticate("MBI", AuthClientBase.PassportSite.KdcPanorama);
                                }
                                else
                                {
                                    ctx.PassportAuthenticate("MBI", AuthClientBase.PassportSite.KdcXenon);
                                }
                            }
                        }
                    }
                }
                else if ((bool)MyValues[3]) //force new user every time
                {
                    try
                    {
                        ctx.SetNewPassportUser(0, false);
                    }
                    catch (Exception e)
                    {
                        throw new DidNotExecuteException("Exception trying to create a new real user: "+e.Message);
                    }
                }

                //do request
                bool passed=false;
                try
                {
                    StressCommon.SignInAskdc(ctx, false, false, false);
                    passed=true;
                }
                finally
                {
                    //return context to cache (unless it's a limited token that is out of uses)
                    if (passed || StressCommon.AlwaysRetainContext)
                    {
                        authContextCache.PushBack(ctx);
                    }
                }
            }
        };

        //xkdc stress tests
        [StressTest, Description("Xkdc tests")]
        //                                          type                              user   limitedpc  chanceExtraRequest usenewpreauth autodiscoverfirst silveruser trustedmachinecount
        [CompoundCase("Xenon V4",                   AuthContext.ClientTypes.Xenon,    true,  false,     0.2f,              4,            true,             false,     1)]
        [CompoundCase("Xenon MachineOnly V4",       AuthContext.ClientTypes.Xenon,    false, false,     0.0f,              4,            true,             false,     1)]
        [CompoundCase("Xenon V5 Gold",              AuthContext.ClientTypes.Xenon,    true,  false,     0.2f,              5,            true,             false,     1)]
        [CompoundCase("Xenon V5 Silver",            AuthContext.ClientTypes.Xenon,    true,  false,     0.2f,              5,            true,             true,      1)]
        [CompoundCase("Xenon V5 NonAutoDiscover",   AuthContext.ClientTypes.Xenon,    true,  false,     0.1f,              5,            false,            false,     1)]
        [CompoundCase("Xenon MachineOnly V5",       AuthContext.ClientTypes.Xenon,    false, false,     0.0f,              5,            true,             false,     1)]
        [CompoundCase("Xenon V6 Gold",              AuthContext.ClientTypes.Xenon,    true,  false,     0.2f,              6,            true,             false,     1)]
        [CompoundCase("Xenon V6 Gold 20Trusted",    AuthContext.ClientTypes.Xenon,    true,  false,     0.2f,              6,            true,             false,     20)]
        [CompoundCase("Panorama",                   AuthContext.ClientTypes.Panorama, true,  false,     0.1f,              null,         true,             false,     1)]
        [CompoundCase("Panoama MachineOnly",        AuthContext.ClientTypes.Panorama, false, false,     0.0f,              null,         true,             false,     1)]
        [CompoundCase("PanoramaLimited Gold",       AuthContext.ClientTypes.Panorama, true,  true,      0.0f,              null,         true,             false,     1)]
        [CompoundCase("PanoramaLimited Silver",     AuthContext.ClientTypes.Panorama, true,  true,      0.0f,              null,         true,             true,      1)]
        [CompoundCase("PanoamaLimited MachineOnly", AuthContext.ClientTypes.Panorama, false, true,      0.0f,              null,         true,             false,     1)]
        public class Xkdc: TestNode
        {
            TimedQueue<AuthContext> authContextCache; //note that each compound instance has a separate copy of this

            //each instance type gets its own cache
            public override void OneTimeSetup()
            {
                authContextCache=new TimedQueue<AuthContext>();
                authContextCache.MinimumReuseTime=new TimeSpan(0,0,0,1*4,25); //1s (60 in 60sec = tempban), eyeballing at up to 4 requests per use

                //hook us into the data update test
                if ((AuthContext.ClientTypes)MyValues[0]==AuthContext.ClientTypes.Xenon && (bool)MyValues[1]==true)
                {
                    DataUpdates.ClearFlashVersion_XenonXkdc.XenonXkdcCache=authContextCache;
                }
            }

            //run
            public override void Run()
            {
                //get or set up a context to use
                AuthContext ctx=authContextCache.PopFront();
                if (ctx==null)
                {
                    ctx=new AuthContext((AuthContext.ClientTypes)MyValues[0]);
                    if ((bool)MyValues[2])
                    {
                        ctx.SponsorToken=PanoramaLimited.c_LimitedToken;
                        ctx.IsPCLimited=true;
                    }

                    string gamertag=StressCommon.SignInAskdc(ctx, (bool)MyValues[1], (bool)MyValues[6], true);

                    //add trusted machines
                    if (gamertag!=null)
                    {
                        ulong userPuid=UserEditor.FromGamerTag(gamertag).Puid;

                        int trustedMachineCount=(int)MyValues[7];
                        for (int m=0; m<trustedMachineCount; ++m)
                        {
                            ulong machinePuid=MachineEditor.CreateNew().Id;
                            UserMachineHistoryEditor umhe=UserMachineHistoryEditor.CreateOrUseExisting(userPuid, machinePuid);
                            umhe.LastSignout=System.DateTime.UtcNow-new System.TimeSpan(m+1, 0, 0);
                        }
                    }
                }

                bool passed=false;
                try
                {
                    //pick the preauth to use
                    if (MyValues[4]==null)
                    {
                        ctx.XenonPreauthVersion=0;
                    }
                    else
                    {
                        if ((int)MyValues[4]==5)
                        {
                            ctx.XenonPreauthVersion=5;
                        }
                        else if ((int)MyValues[4]==6)
                        {
                            ctx.XenonPreauthVersion=5;
                            ctx.TitleInfo.OverrideDefaultServiceRequest = 1;
                            ctx.TitleInfo.OverrideDefaultServiceRequestVersion = 6;
                        }
                        else
                        {
                            ctx.XenonPreauthVersion=4;
                        }
                    }

                    //do request
                    StressCommon.SignInXkdc(ctx, (bool)MyValues[5]);

                    //there's a chance we may do another non-autodiscover request to hit the cache again
                    float extraCacheHitChance=(float)MyValues[3];
                    if (extraCacheHitChance>0.0f && (float)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextDouble() < extraCacheHitChance)
                    {
                        XkdcClient xkdc=new XkdcClient(ctx);
                        xkdc.EmulateClientBehavior=StressCommon.EmulateClientBehavior;
                        xkdc.SetRequest(new uint[] {20}); //nat detect
                        xkdc.SignInXkdc();
                    }

                    //sanity check
                    if (ctx.GetXkdcResult().ServiceHR!=0)
                    {
                        throw new UnexpectedTestResultException("Got unexpected serviceHR in xkdc response: "+ctx.GetXkdcResult().ServiceHR);
                    }
                    passed=true;
                }
                finally
                {
                    if (passed || StressCommon.AlwaysRetainContext)
                    {
                        authContextCache.PushBack(ctx);
                    }
                }
            }
        };

        //async test specifically for xkdc xenon, as that's our biggest load
        [StressTest, Description("Async tests for the xkdc.")]
        [CompoundCase("Xenon",                      AuthContext.ClientTypes.Xenon)]
        public class AsyncXkdc: AsyncStressTestNode
        {
            static TimedQueue<KdcClient> readyCache;
            static TimedQueue<KdcClientTracker> usedCache;

            static int ReceiveThreadCount=System.Environment.ProcessorCount/2;
            const int MaxInProgress=10000;
            volatile static int threadsRunning=0;
            volatile static bool isRunning=false;

            class KdcClientTracker
            {
                public System.DateTime RequestTime;
                public AsyncStressTestNode Test;
                public KdcClient Client;
                public AsyncStressTracking Tracker;
            };

            static AsyncXkdc()
            {
                readyCache=new TimedQueue<KdcClient>();
                readyCache.MinimumReuseTime=new TimeSpan(0,0,0,1*4,25); //1s (60 in 60sec = tempban), eyeballing at up to 4 requests per use
                usedCache=new TimedQueue<KdcClientTracker>();
                usedCache.MinimumReuseTime=new TimeSpan(0,0,0,0,0);
            }

            public override void PreRun()
            {
                //create threads
                isRunning=true;
                threadsRunning=ReceiveThreadCount;
                Global.RO.Debug("Creating "+ReceiveThreadCount+" threads for xkdc async receiving stress.");
                for (int i=0; i<ReceiveThreadCount; ++i)
                {
                    ThreadMaker.CreateThread(ReceiveThreadProc).Start();
                }
            }

            public override void PostRun()
            {
                //tell threads to end, then wait for them to end
                isRunning=false;

                Global.RO.Debug("Waiting on xkdc async receiving stress threads to end...");
                while (threadsRunning>0)
                {
                    System.Threading.Thread.Sleep(10);
                }
                Global.RO.Debug("All xkdc async receiving stress threads ended.");
            }

            public override void Begin(AsyncStressTracking tracker)
            {
                if (usedCache.Count>MaxInProgress)
                {
                    End(new DidNotExecuteException("Exceeded max allowed in progress"), tracker);
                    return;
                }

                //get a client ready to do an xkdc request
                KdcClient kdc=readyCache.PopFront();
                if (kdc==null)
                {
                    kdc=new KdcClient((AuthContext.ClientTypes)MyValues[0]);

                    //do up through askdc
                    kdc.ExecuteAskdc(true);

                    //now turn off stuff we don't need
                    kdc.DecryptTickets=false;
                }

                //now send off the xkdc request
                kdc.ResetSocket();
                kdc.ClearXkdc();
                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.GeneratePreauths();
                kdc.XkdcRequest.SetRequest();
                kdc.XkdcRequest.ConstructRequest();
                byte []packet=kdc.XkdcRequest.GetBytes();
                if (KdcClient.VerboseOutput)
                {
                    Global.RO.Debug("Xkdc Request:\n"+kdc.XkdcRequest);
                }
                kdc.SendPacket(packet);

                //save the nonce
                kdc.XkdcNOnces[kdc.XkdcNOncesUsed++]=kdc.XkdcRequest.Input.NOnce;

                //put it into the queue of sent items
                KdcClientTracker t=new KdcClientTracker();
                t.Test=this;
                t.Client=kdc;
                t.Tracker=tracker;
                t.RequestTime=System.DateTime.UtcNow;
                usedCache.PushBack(t);
            }

            static void ReceiveThreadProc()
            {
                while (isRunning || usedCache.Count>0)
                {
                    KdcClientTracker t=usedCache.PopFront();
                    if (t==null)
                    {
                        System.Threading.Thread.Sleep(100);
                        continue;
                    }

                    bool used=true;
                    System.Exception err=ReceiveThreadProc_ProcessClient(t, ref used);

                    if (used)
                    {
                        if (err==null)
                        {
                            t.Test.End(null, t.Tracker);
                        }
                        else
                        {
                            t.Test.End(err, t.Tracker);
                        }

                        if (err==null || StressCommon.AlwaysRetainContext)
                        {
                            readyCache.PushBack(t.Client);
                        }
                    }
                    else
                    {
                        if (err==null)
                        {
                            usedCache.PushBack(t);
                        }
                        else
                        {
                            Global.RO.Warn("Async Xkdc: Unused client processing returned an error: "+err);
                        }
                    }
                }

                System.Threading.Interlocked.Decrement(ref threadsRunning);
            }

            static System.Exception ReceiveThreadProc_ProcessClient(KdcClientTracker t, ref bool used)
            {
                try
                {
                    byte []packet=t.Client.ReceivePacket(0);
                    if (packet==null) //no response yet
                    {
                        if ((System.DateTime.UtcNow-t.RequestTime)>new System.TimeSpan(0, 0, 0, 2, 0)) //2s timeout
                        {
                            return new ServerTestFramework.Utilities.TimeoutException("Async Xkdc: request timed out.");
                        }
                        else //nothing yet but it still has time
                        {
                            used=false;
                        }
                    }
                    else //got a reply
                    {
                        long replyBytesUsed;
                        AsnValueBase asn=Compound.AsnValueParser.Parse(packet, 0, packet.Length, out replyBytesUsed);
                        t.Client.SetXkdcReply(asn);
                    }
                }
                catch (System.Exception err)
                {
                    return err;
                }

                return null;
            }
        }

        //stress using dbposter users, which have a much wider variety of properties than bulk stress users.
        //this caches machine accounts, but makes both askdc+xkdc requests.
        [StressTest, Description("askdc+xkdc stress using dbposter users, which have a wide variety of interesting properties")]
        //                                          type
        [CompoundCase("Xenon",                      AuthContext.ClientTypes.Xenon)]
        [CompoundCase("Xbox1",                      AuthContext.ClientTypes.Xbox)]
        public class DBPosterUsers: TestNode
        {
            TimedQueue<AuthContext> authContextCache; //separate for each instance
            TimedQueue<string> userQueue=new TimedQueue<string>(); //shared by all instances

            public override void OneTimeSetup()
            {
                //set up queues
                authContextCache=new TimedQueue<AuthContext>();
                authContextCache.MinimumReuseTime=new TimeSpan(0,0,0,1*4,25); //1s (60 in 60sec = tempban), eyeballing at up to 4 requests per use
                userQueue.MinimumReuseTime=new TimeSpan(0,0,0,1,25); //1s (2 in 1sec = ignore request)

                //add dbposter users to the queue
                if (userQueue.Count==0)
                {
                    foreach (string s in _Setup.DBPUsers)
                    {
                        if (!(s.StartsWith("SN.") || s.StartsWith("XE."))) // || s.Contains("nobase") || s.Contains("subnone"))
                        {
                            userQueue.PushBack(s);
                        }
                    }
                }
            }

            //run
            public override void Run()
            {
                //get or set up a context to use, and a user
                string username=userQueue.PopFront();
                try
                {
                    if (username==null) //if we have no user, nothing to do but skip
                    {
                        throw new DidNotExecuteException("No user");
                    }

                    AuthContext ctx=authContextCache.PopFront();
                    if (ctx==null)
                    {
                        ctx=new AuthContext((AuthContext.ClientTypes)MyValues[0]);
                    }

                    //do request with the user
                    ctx.ClearAskdc();

                    XonlinepUser user=AuthContext.MakeUser(username);
                    ctx.SetUser(user, 0);

                    StressCommon.SignInAskdc(ctx, false, false, false);
                    StressCommon.SignInXkdc(ctx);

                    authContextCache.PushBack(ctx);
                }
                finally //always put the user back
                {
                    userQueue.PushBack(username);
                }
            }
        }
    };
    #endregion

    #region Data updating tests

    [TestGroup]
    public class DataUpdates
    {
        [StressTest, Description("Pulls a machine out of the xkdc xenon queue and clears its flash version in UODB")]
        public class ClearFlashVersion_XenonXkdc: TestNode
        {
            public static TimedQueue<AuthContext> XenonXkdcCache;

            public override void Run()
            {
                //get a context to use
                if (XenonXkdcCache==null)
                {
                    throw new DidNotExecuteException("Context cache doesn't exist yet");
                }

                AuthContext ctx=XenonXkdcCache.PopFront();
                if (ctx==null) //nothing is ready, so nothing to do
                {
                    throw new DidNotExecuteException("No available contexts");
                }

                //update data for this machine
                try
                {
                    ServerTestFramework.Database.MachineEditor machine=ServerTestFramework.Database.MachineEditor.FromId(ctx.UsersMachine.xuid.qwUserID);
                    machine.ClientFlashVersion="";
                }
                finally //always put the context back
                {
                    XenonXkdcCache.PushBack(ctx);
                }
            }
        };
    };

    #endregion

    #region Management and Monitoring Tests

    //xmgmt reload.  normally this should be very very low pri...
    [StressTest]
    public class Xmgmt_Reload: TestNode
    {
        public override void Run()
        {
            if (Suite.ReloadKDCs())
            {
            }
            else
            {
                throw new UnexpectedTestResultException("xmgmt reload failed");
            }
        }
    }

    //watches the eventlog for a crash event
    //Fails ONLY if the .NET crash line shows up in the event log.
    [StressTest]
    public class WatchForCrash: TestNode
    {
        private static object emLock=new object();
        private static EventMonitor monitor=null;

        public override void Run()
        {
            lock (emLock)
            {
                if (monitor==null)
                {
                    monitor=new EventMonitor(
                        Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.kdcsvc), //kdc servers
                        new string[]{""}, //any event
                        ".NET Runtime 2.0 Error Reporting", //in this source
                        "_kdc_stress_events.txt"); //log to here
                }
            }

            string []res=monitor.Poll();
            if (res==null)
            {
            }
            else
            {
                throw new UnexpectedTestResultException("!-!-! Crash detected in eventlog !-!-!");
            }
        }
    }

    //watches the eventlog for events that shouldn't happen
    //Fails ONLY if event is detected
    [StressTest]
    public class WatchForBadEvents: TestNode
    {
        private static object emLock=new object();
        private static EventMonitor monitor=null;

        public override void Run()
        {
            lock (emLock)
            {
                if (monitor==null)
                {
                    monitor=new EventMonitor(
                        Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.kdcsvc), //kdc servers
                        new string[]{"GetMachineAuthorization failed. This is not expected", "this is fatal"}, //these events
                        null, //any source
                        "_kdc_stress_events.txt"); //log to here
                }
            }

            string []res=monitor.Poll();
            if (res==null)
            {
            }
            else
            {
                foreach (string s in res)
                {
                    Global.RO.Error("Bad event detected: "+s);
                }
                throw new UnexpectedTestResultException("Bad events detected");
            }
        }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\StressSetup.cs ===
using ServerTestFramework;
using ServerTestFramework.Runner;

namespace XkdcTest
{
    public static class StressSetup
    {
        //This is sort of a hack, as we're running an instance of the functional scheduler, which could cause problems if another instince (such as in STFGui's functional plugin) is also running at the same time.  But it accomplishes the goal of some people wanting PreRun for stress to do all setup for the environment (which in this case means running the functional _Setup group), even though it actually only needs done once after deployment and not every time.  At least we can disable PreRun for stress now now as an option to the runners, so when developing tests, you can turn this annoyance off.
        public static void RunSetup(TestNode anyNodeInTree)
        {
            //Walk up our tree till we find the root
            TestNode []root=new TestNode[1]{anyNodeInTree};
            while (root[0].Parent!=null)
            {
                root[0]=root[0].Parent;
            }

            //instantiate a functional scheduler for our tree
            FunctionalSchedulerSettings settings=new FunctionalSchedulerSettings();
            FuncScheduler scheduler=new FuncScheduler();
            scheduler.Initialize(settings, null, root);

            //select only the _Setup group, then deselect the cleanup stuff as it's not actually needed unless something was put into a bad state
            root[0].FunctionalData.Enabled=false;
            SetEnabledNodeInTree(root[0], "_Setup", true);
            SetEnabledNodeInTree(root[0], "CleanDBMachines", false);
            SetEnabledNodeInTree(root[0], "CleanDBUsers", false);

            //now run it and verify that nothing failed
            scheduler.Run();

            TEST_RESULTS result=root[0].FunctionalData.SchedulerData.RunResult;
            if (result!=TEST_RESULTS.PASSED)
            {
                throw new System.Exception("_Setup group did not pass.  Result="+result);
            }
        }

        private static void SetEnabledNodeInTree(TestNode node, string name, bool enabled)
        {
            if (node.Name==name && node.FunctionalData!=null)
            {
                node.FunctionalData.Enabled=enabled;
            }

            foreach (TestNode child in node.Children)
            {
                SetEnabledNodeInTree(child, name, enabled);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\TestBase_XboxOld.cs ===
using System;
using System.Text;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;


namespace XkdcTest
{
    abstract public class TestBase_XboxOld : TestBase_Xkdc
    {
        private static readonly uint[] XboxTitleIds = new uint[]
            {
                0xFFC0FE00,
                0xFFBEEF00,
                0xFFBEEF01,
                0xFFBEEF02,
                0xFFBEEF03,
                0xFFBEEF04,
                0xFFBEEF05,
                0xFFBEEF06,
                0xFFBEEF07,
                0xFFBEEF08,
                0xFFBEEF09,
                0xFFBEEF0A,
                0xFFBEEF0B,
                0xFFBEEF0C,
                0xFFBEEF0D,
                0xFFBEEF0E,
                0xFFBEEF0F,
                0xFFBEEF20,
                0xFFBEEF21,
                0xFFBDEF01,
                0xbaad00
            };

        // Xenon title ids all fall into the range:
        // 0xXXXX07D1 to 0xXXXX0BB8
        private static readonly uint[] XenonTitleIds = new uint[]
            {
                0xC0FE0800,
                0x3EEF0800,
                0x3EEF0801,
                0x3EEF0802,
                0x3EEF0803,
                0x3EEF0804,
                0x3EEF0805,
                0x3EEF0806,
                0x3EEF0807,
                0x3EEF0808,
                0x3EEF0809,
                0x3EEF080A,
                0x3EEF080B,
                0x3EEF080C,
                0x3EEF080D,
                0x3EEF080E,
                0x3EEF080F,
                0x3EEF0820,
                0x3EEF0821,
                0x3DEF0801,
                0xbaad0801
            };

        private static Hashtable hashXboxToXenonTitles = new Hashtable(50);

        /// <summary>
        /// static ctor
        /// </summary>
        static TestBase_XboxOld()
        {
            //build mapping from xbox title IDs to xenon titleIDs
            hashXboxToXenonTitles.Clear();
            for (int i = 0; i < XboxTitleIds.Length; i++)
            {
                hashXboxToXenonTitles.Add((int)XboxTitleIds[i], (int)XenonTitleIds[i]);
            }
        }

        /// <summary>
        /// Set defaults for any members that might need resetting between tests
        /// </summary>
        public override void SetDefaults()
        {
            base.SetDefaults();

            // Turn off most of the checks
            bVerifyServices = false;
            bVerifyHRs = false;
            bVerifyUserFlags = false;
            bVerifyPrivileges = false;
        }

        static public bool VerifyHRArray(uint[] ResultArray, uint[] ExpectedArray)
        {
            int minLength = Math.Min(ResultArray.Length, ExpectedArray.Length);
            return VerifyHRArray(ResultArray, ExpectedArray, (uint)minLength);
        }

        static public bool VerifyHRArray(uint[] ResultArray, uint[] ExpectedArray, uint count)
        {
            // We only check for up to 12 services and neither array
            // should contain more than count services
            if (count > ResultArray.Length ||
                count > ExpectedArray.Length)
                //ResultArray.Length > 12 ||
                //count > 12)
            {
                return false;

            }
            // Check each service result,
            // return true only of all results are S_OK
            for(uint i = 0; i < count; i++)
            {
                if(ResultArray[i] != ExpectedArray[i])
                    return false;
            }
            return true;
        }

        static string ErrToString(uint hr)
        {
            string msg = "";
            if (hr == HResult.S_OK)
                msg = "OK";
            else if (hr == HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)
                msg = "UPDATE REQUIRED";
            else
                msg = "UNKNOWN";
            return String.Format("[0x{0:X} {1}]", hr, msg);
        }


        public TitleInfo ConvertToXenonTitle(TitleInfo ti)
        {
            TitleInfo returnTi = new TitleInfo((uint)ti.TitleId, (uint)ti.Version, (uint)ti.Region);
            if (!hashXboxToXenonTitles.ContainsKey((int)ti.TitleId))
            {
                bool isInXenonList=false;
                foreach (uint xt in XenonTitleIds)
                {
                    if (xt==ti.TitleId)
                    {
                        isInXenonList=true;
                        break;
                    }
                }

                if (isInXenonList)
                {
                    ro.Debug("Title id 0x{0:X} is already a Xenon title, so no conversion needed.", ti.TitleId);
                }
                else
                {
                    ro.Warn("Can't find Xbox title id 0x{0:X} in Xenon title id hash, this shouldn't happen", ti.TitleId);
                }
            }
            else
            {
                unchecked
                {
                    object o = hashXboxToXenonTitles[(int)ti.TitleId];
                    returnTi.TitleId = (int)o;
                }
            }
            return returnTi;
        }

        public void Common(String user, uint[] uiServices, TitleInfo TI, uint[] ExpectedHRs, uint ExpectedHR, char VerifyType)
        {
            ResultCode = TEST_RESULTS.PASSED;

            // Set user
            SetUser(user, 0);

            // Set services to sign in with
            this.ExpectedServices = uiServices;

            // Set title info
            if (TI != null)
            {
                if (authContext.IsXenonTitle)
                    authContext.TitleInfo.SetTitleInfo(ConvertToXenonTitle(TI));
                else
                    authContext.TitleInfo.SetTitleInfo(TI);
            }
            else
            {
                if (authContext.IsXenonTitle)
                    authContext.TitleInfo.TitleId = 0xC0FE0800;     // This is a Xenon-only title id
                else
                    authContext.TitleInfo.TitleId = 0xFFC0FE00;     // This is an Xbox-only title id
            }

            // Set expected result code
            this.ExpectedHR = ExpectedHR;

            // Set verification type and data
            if (VerifyType == 's')
            {
                bVerifyServices = true;
                // Many of the old tests create a 12 item array of ExpectedHRs but only request a couple
                // of services.  Our tests require the length ExpectedHRs and ExpectedServices to match,
                // so let's trim the HRs.
                if (ExpectedHRs.Length > ExpectedServices.Length)
                {
                    this.ExpectedHRs = new uint[ExpectedServices.Length];
                    Array.Copy(ExpectedHRs, 0, this.ExpectedHRs, 0, ExpectedServices.Length);
                }
                else
                {
                    this.ExpectedHRs = ExpectedHRs;
                }
            }
            else if (VerifyType == 'u')
            {
                bVerifyUserHRs = true;
                this.ExpectedUserHRs = ExpectedHRs;
            }
            else if (VerifyType == 'f')
            {
                // do nothing, will be manually verified
                // well, maybe we should set the expected HRs
//                if (ExpectedHRs.Length > ExpectedServices.Length)
//                {
//                    this.ExpectedHRs = new uint[ExpectedServices.Length];
//                    Array.Copy(ExpectedHRs, 0, this.ExpectedHRs, 0, ExpectedServices.Length);
//                }
//                else
//                {
//                    this.ExpectedHRs = ExpectedHRs;
//                }            
            }

        }


        #region XboxUserServiceTicket
        /// <summary>
        /// Get user Service Result (ST? huh?) with site
        /// </summary>


        public TEST_RESULTS GetUserSTwithSite(String user, uint[] uiServices, TitleInfo TI, uint[] ExpectedHRs, uint ExpectedHR, char VerifyType, uint uSite)
        {
            Common(user, uiServices, TI, ExpectedHRs, ExpectedHR, VerifyType);

            SignInXkdc(false);

            ASCIIEncoding AE = new ASCIIEncoding();
            byte[] ticket = (authContext.ServiceCtxXe != null) ? authContext.ServiceCtxXe.Ticket : authContext.ServiceCtxXbox.Ticket;
            String siteID = AE.GetString(ticket, 44, 8);    // The site ID is always here
            if(siteID != "site" + uSite)
            {
                Fail("SiteID seems to be wrong, got {0}, expected {1} (this may be because your request failed, service {2} got HR {3})",
                    siteID,
                    "site" + uSite,
                    result.ServiceIDs[0],
                    result.ServiceHRs[0]);
            }
            return ResultCode;
        }

        // Get a User Ticket specifying services and a custom TitleInfo
        public TEST_RESULTS GetUserST(String user, uint[] uiServices, TitleInfo TI, uint[] ExpectedHRs, uint ExpectedHR, char VerifyType)
        {
            Common(user, uiServices, TI, ExpectedHRs, ExpectedHR, VerifyType);

            SignInXkdc(false);

            return ResultCode;
        }

        // Get a User Ticket and check the extra auth data
        public TEST_RESULTS GetUserSTCheckAuth(String user, uint[] uiServices, TitleInfo TI, uint[] ExpectedHRs, uint ExpectedHR, char VerifyType)
        {
            Common(user, uiServices, TI, ExpectedHRs, ExpectedHR, VerifyType);

            // Sign in once and save result
            SignInXkdc(false);
            XkdcResult sr = base.result;

            // And do it again with the same machine account and save it
            authContext.ClearXkdc();
            SignInXkdc(false);
            XkdcResult sr2 = base.result;

            // Make sure the two keys match, but only if this call succeeded
            if (sr.ServiceHR == 0 && sr2.ServiceHR == 0)
            {
                if (sr.authData == null || sr2.authData == null)
                {
                    Global.RO.Warn("Missing authdata.");
                    return TEST_RESULTS.FAILED;
                }

                byte[] key1=sr.authData.Key;
                byte[] key2=sr2.authData.Key;

                for (uint i = 0; i < key1.Length; i++)
                {
                    if (key1[i] != key2[i])
                    {
                        Global.RO.Warn("Keys don't match.");
                        ResultCode = TEST_RESULTS.FAILED;
                        break;
                    }
                }
            }

            return ResultCode;
        }

        // Get a User Ticket specifying only services (default TitleInfo)
        public TEST_RESULTS GetUserSTwithFlags(String user, uint[] uiServices, TitleInfo TI, uint[] ExpectedServiceHRs, uint ExpectedHR, short[] UserFlags, char flag)
        {
            Common(user, uiServices, TI, ExpectedServiceHRs, ExpectedHR, 'f');

            SignInXkdc(false);
            XkdcResult sr = base.result;

            // We need an indicator to treat the flags as a country code or not
            uint i = 0;
            uint mask = 0;
            short bitShift;
            switch(flag)
            {
                case 'f':    // Treat as user flags
                    bitShift = 16;
                    // We need to filter out high byte, it's being used now by language stuff
                    // --kgoodier  (was 0xFF0F)
                    mask = 0x000F;
                    foreach(short UF in UserFlags)
                    {
                        // C# does not know how to handle shorts.  -241=0xFF0F, but
                        // C# insists on calling this UF (a short) 0xFFFFFF0F.  Grumble.
                        if(!( ((sr.UserFlags[i] >> bitShift) & mask) == (UF & mask) ))
                            Fail("For user #{0}, expected UserFlags (case 'f') {1}, got {2}",
                                i,
                                UF & mask,
                                (sr.UserFlags[i] >> bitShift) & mask);
                        i++;
                    }
                    break;
                case 'c':    // Treat as a country code
                    foreach(short UF in UserFlags)
                    {
                        if(!( UserFlagsUtil.UserCountryId(sr.UserFlags[i]) == UF ))
                            Fail("For user #{0}, expected CountryId {1}, got {2}",
                                i,
                                UF,
                                UserFlagsUtil.UserCountryId(sr.UserFlags[i]));
                        i++;
                    }
                    break;
                case 'd':    // Treat as a disconnect flag
                    foreach(short UF in UserFlags)
                    {
                        if(!( UserFlagsUtil.UserDisconnectRating(sr.UserFlags[i]) == UF ))
                            Fail("For user #{0}, expected UserDisconnectRating {1}, got {2}",
                                i,
                                UF,
                                UserFlagsUtil.UserDisconnectRating(sr.UserFlags[i]));
                        i++;
                    }
                    break;
                case 'n':    // Treat as a no show flag
                    foreach(short UF in UserFlags)
                    {
                        if(!( UserFlagsUtil.UserNoShowRating(sr.UserFlags[i]) == UF ))
                            Fail("For user #{0}, expected UserNoShowRating {1}, got {2}",
                                i,
                                UF,
                                UserFlagsUtil.UserNoShowRating(sr.UserFlags[i]));
                        i++;
                    }
                    break;
                default:
                    Global.RO.Warn("Unhandled character.");
                    return TEST_RESULTS.FAILED;
            }

            return ResultCode;
        }

        #endregion

        #region XboxMachineServiceTicket
        // Get a machine ticket specifying only services (default TitleInfo)
        public TEST_RESULTS GetMachineSTwithFlags(uint[] uiServices, TitleInfo TI, uint[] ExpectedServiceHRs, uint ExpectedHR, short[] UserFlags, char flag)
        {
            Common(null, uiServices, TI, ExpectedServiceHRs, ExpectedHR, 's');

            short bitShift;
            uint mask;

            // We need an indicator to treat the flags as a country code or not
            switch(flag)
            {
                case 'f':    // Treat as user flags
                    bitShift = 16;
                    mask = 0xFF0F;
                    break;
                case 'c':    // Treat as a country code
                    bitShift = 8;
                    mask = 0xFF;
                    break;
                default:
                    return TEST_RESULTS.FAILED;
            }

            SignInXkdc(false);
            XkdcResult sr = base.result;

            uint i = 0;
            foreach(short UF in UserFlags)
            {
                if(!( ((sr.UserFlags[i] >> bitShift) & mask) == UF ))
                    ResultCode = TEST_RESULTS.FAILED;
                i++;
            }

            return ResultCode;
        }

        // Get a machine ticket specifying only services (default TitleInfo)
        public TEST_RESULTS GetMachineSTwithSite(uint[] uiServices, uint[] ExpectedServiceHRs, uint ExpectedHR, uint uSite)
        {
            Common(null, uiServices, null, ExpectedServiceHRs, ExpectedHR, 's');

            SignInXkdc(false);

            ASCIIEncoding AE = new ASCIIEncoding();
            byte[] ticket = (authContext.ServiceCtxXe != null) ? authContext.ServiceCtxXe.Ticket : authContext.ServiceCtxXbox.Ticket;
            String siteID = AE.GetString(ticket, 44, 8);    // The site ID is always here
            if(siteID != "site" + uSite)
            {
                Fail("SiteID seems to be wrong, got {0}, expected {1}",
                    siteID,
                    "site" + uSite);
            }

            return ResultCode;
        }

        // Get a machine ticket specifying services and a custom TitleInfo
        public TEST_RESULTS GetMachineST(uint[] uiServices, TitleInfo TI, uint[] ExpectedServiceHRs, uint ExpectedHR)
        {
            Common(null, uiServices, TI, ExpectedServiceHRs, ExpectedHR, 's');

            SignInXkdc(false);

            return ResultCode;
        }

        #endregion

        //verifies that no user privileges are present
        public void VerifyNoUserPrivileges()
        {
            XkdcResult sr=base.result;
            for (int u=0; u<4; ++u)
            {
                for (int p=160; p<256; ++p)
                {
                    ValueCheck.Test("User "+u+" privilege bit "+p, false, sr.HasPrivilege(u, p));
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\UserInfo.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

using System.Collections;

namespace XkdcTest
{

    /// <summary>
    /// Represents a user for when signing and especially verifying.  Handles different tiers, privilege
    /// grants and restrictions, and makes it easy to use them.
    /// </summary>
    public class UserInfo
    {
        // All the rest
        public uint[]   ExpectedPrivileges          = null;
        public uint     Title                       = 0; //default to no title-specific logic
        public int      Tier                        = 2;
        public int      CountryCode                 = 103;
        public string   SubType                     = null;
        public uint[]   RestrictedPrivileges        = null;
        public uint[]   GrantedPrivileges           = null;
        public uint[]   AlwaysGrantedPrivileges     = null;  // always grant even if not in user's tier
        public bool     bIsXenon                    = false;
        public bool     bIsXbox                     = true;
        public string   RawXboxKey                  = "";
        public string   RawXenonKey                 = "";
        public BitArray ExpectedPrivilegesBitArray  = new BitArray(256);
        public uint[]   AdditionalServices          = new uint[0]; //extra services the user should be granted

        //Changing the name recalculates the raw keys
        public string Name
        {
            get
            {
                return name_;
            }

            set
            {
                name_=value;
                RawXboxKey=Hexer.tohex(AuthContext.CalculateKeyFromGamertag(name_, false));
                RawXenonKey=Hexer.tohex(AuthContext.CalculateKeyFromGamertag(name_, true));
            }
        }

        private string name_;

        public UserInfo()
        {
            Name="xktusert2a";
        }

        public UserInfo(string name): this(name, 2, 0) {}
        public UserInfo(string name, int DefaultTier, uint Title): this()
        {
            if (DefaultTier==0) //0 isn't valid default to 2
            {
                DefaultTier=2;
            }

            this.Tier = DefaultTier;
            this.Title = Title;
            this.Name = name.ToLower();

            ParseName(this.Name);
            SetPrivileges();
        }

        protected void ParseName(string name)
        {
            // Step 0.  Special cases.  If found, abort rest of processing.
            if (name == "xktrestrictedt2")
            {
                Tier = 2;
                RestrictedPrivileges = Expectations.k_DefaultAllPrivileges;
                return;
            }
            else if (name == "xktgrantedt2")
            {
                // This should be AllPrivileges but I don't want to change it and break existing tests.
                Tier = 2;
                XkdcUtilities.AddToArray(ref AlwaysGrantedPrivileges, new uint[] { 192 });  // from offer
                XkdcUtilities.AddToArray(ref GrantedPrivileges, new uint[] { 193 }); // from t_user_privilege_grants
                return;
            }
            else if (name == "xktsub1")
            {
                Tier = 2;
                XkdcUtilities.AddToArray(ref AlwaysGrantedPrivileges, new uint[] { 192 });
                return;
            }
            else if (name == "xktsub3" || name == "xktsub123")
            {
                Tier = 2;
                return;
            }
            else if (name == "xktofferprivres")
            {
                Tier = 2;
                //t_offer_privilege_restrictions
                XkdcUtilities.AddToArray(ref RestrictedPrivileges, new uint[] { 255, 254, 245, 244, 192 });
                return;
            }
            else if (name == "xktbanned") //user account banned
            {
                Tier = 2;
                return;
            }
            else if (name.StartsWith("xktxxx"))
            {
                return;
            }
            else if (name.StartsWith("xktxna")) //xna-like subscription
            {
                Tier = 2;
                if (Title==0xC0FE1005) //XNA title only gets the extra stuff
                {
                    XkdcUtilities.AddToArray(ref AlwaysGrantedPrivileges, new uint[] { 222 });
                    //AdditionalServices=new uint[]{8105}; //We DO expect to get it, but not on site 1
                }
                return;
            }
            else if (name=="xktsubgame0")
            {
                Tier = 2;
                if (Title==0xC0FE1006 || Title==0xC0FE1008)
                {
                    XkdcUtilities.AddToArray(ref AlwaysGrantedPrivileges, new uint[] { 218 });
                }
                return;
            }
            else if (name=="xktsubgame1")
            {
                Tier = 2;
                if (Title==0xC0FE1007 || Title==0xC0FE1008)
                {
                    XkdcUtilities.AddToArray(ref AlwaysGrantedPrivileges, new uint[] { 218 });
                }
                return;
            }
            else if (name=="xktsubgame2")
            {
                Tier = 2;
                if (Title==0xC0FE1006 || Title==0xC0FE1007 || Title==0xC0FE1008)
                {
                    XkdcUtilities.AddToArray(ref AlwaysGrantedPrivileges, new uint[] { 218 });
                }
                return;
            }

            // Step 1.  Always begins with "xkt". Swallow it.
            if (!name.StartsWith("xkt"))
                return;
            name = name.Substring(3);

            // Step 2.  Optional 2 letter identifier.
            if (name.StartsWith("xe"))
            {
                bIsXenon = true;
                bIsXbox = false;
                name = name.Substring(2);
            }
            else if (name.StartsWith("xb"))
            {
                bIsXenon = false;
                bIsXbox = true;
                name = name.Substring(2);
            }
            else if (name.StartsWith("du"))
            {
                bIsXenon = true;
                bIsXbox = true;
                name = name.Substring(2);
            }

            // Step 3.  Some special cases, or else always contains "user". Swallow it.
            if (name.StartsWith("cntry"))
            {
                // We now have a 1 to 3 character country code. Find it.
                name = name.Substring(5);
                int cntryEnd = name.IndexOf("t");
                if (cntryEnd < 1 || cntryEnd > 3)
                    return;
                CountryCode = Int32.Parse(name.Substring(0, cntryEnd));
                name = name.Substring(cntryEnd);

                if (CountryCode==254) //new testland has additional services
                {
                    AdditionalServices=new uint[40];
                    for (int s=0; s<40; ++s)
                    {
                        AdditionalServices[s]=(uint)(80+s);
                    }

                    XkdcUtilities.AddToArray(ref AlwaysGrantedPrivileges, new uint[] { 232, 233, 235 }); //todo: why is this user getting these privileges?
                }
            }
            else if (name.StartsWith("user"))
            {
                name = name.Substring(4);
            }
            else if (name.StartsWith("pcg1"))
            {
                bIsXenon = true;
                // Part of Parental Control Group 1 (medium restrictions)
                // Privileges 242,245,252 restricted
                // And now also 244,247,249,255
                // And now also 237
                XkdcUtilities.AddToArray(ref RestrictedPrivileges, new uint[] { TestBase_Xkdc.XPRIVILEGE_VIDEO_COMMUNICATIONS, 230, 237, 242, 244, 245, 247, 249, 252, 255 });
                name = name.Substring(4);
            }
            else if (name.StartsWith("diff"))
            {
                RawXenonKey=RawXboxKey;
                name = name.Substring(4);
            }
            else if (name.StartsWith("sub"))
            {
                // Some old Xbox XKDC tests have names like "xktsub5", but some of the 
                // newer users have meaningful names like "xktsubexp...".  We want to 
                // ignore the old ones but parse the new ones.
                name = name.Substring(3);
                if (name.Length > 3)
                {
                    // Next 3 characters will be:
                    //   exp (expired)
                    //   mix (1 expired, 1 valid)
                    //   lsp (1 expired lsp sub, 1 valid)
                    //   48h (valid 48 hour sub)
                    //   48e (expired 48 hour sub)
                    SubType = name.Substring(0,3);
                    name = name.Substring(3);
                }
            }
            else if (name.StartsWith("chil"))
            {
                if (bIsXenon)
                {
                    //user graduation
                    AddGrant(new uint[] {225});
                }
            }
            else
            {
                // Must contain one of these
                return;
            }

            // Step 4.  Always contains "t" followed by a number for the tier.  Tiers are 1, 2, or 3,
            // even if this isn't what is reflected in the database.  1=lowest, 3=highest.
            if (name.StartsWith("t"))
            {
                Tier = name[1] - '0';
                name = name.Substring(2);

                // Override based on certain subscription types
                if (SubType == "48h")
                {
                    // Silver (1) user with a valid gold (2) sub
                    // Still treated like silver but with the 
                    // XPRIVILEGE_MULTIPLAYER_SESSIONS privilege (254) granted
                    Tier = 1;
                    AddGrant(new uint[] { 254 });

                    //it looks like "primetime" and "premium video" are now also included
                    AddGrant(new uint[]{223, 224});
                }
                else if (SubType == "48e")
                {
                    Tier = 1;  // Silver (1) user with an expired gold (2) sub
                }
                else if (SubType == "mix")
                {
                    Tier = 1;  // expired gold and valid silver sub
                }
                else if (SubType == "exp")
                {
                    // No valid subscriptions, thus no privileges at all
                    // This changed... now they get silver level
                    AddRestriction(new uint[] { Expectations.k_Xbox1LiveAccess, 231 });
                    AddRestriction(Expectations.k_DefaultAllPrivileges);
                    XkdcUtilities.AddToArray(ref GrantedPrivileges, Expectations.k_DefaultExpectedPrivileges[0]); //add tier 1 privs
                }
            }

            // Step 5.  A single letter indicating special grants and restrictions.
            if (name.Length >= 1)
            {
                // "a" is nothing, no grants, no restrictions, just normal
                if (name.StartsWith("b"))
                {
                    XkdcUtilities.AddToArray(ref RestrictedPrivileges, Expectations.k_DefaultRestrictedPrivileges);
                }
                else if (name.StartsWith("c"))
                {
                    XkdcUtilities.AddToArray(ref GrantedPrivileges, Expectations.k_DefaultGrantedPrivileges);
                }
                else if (name.StartsWith("d"))
                {
                    XkdcUtilities.AddToArray(ref RestrictedPrivileges, Expectations.k_DefaultRestrictedPrivileges);
                    XkdcUtilities.AddToArray(ref GrantedPrivileges, Expectations.k_DefaultGrantedPrivileges);
                }
                else if (name.StartsWith("e"))
                {
                    XkdcUtilities.AddToArray(ref RestrictedPrivileges, Expectations.k_DefaultAllPrivileges);
                }
                else if (name.StartsWith("f"))
                {
                    XkdcUtilities.AddToArray(ref GrantedPrivileges, Expectations.k_DefaultAllPrivileges);
                }
                name = name.Substring(1);
            }

            // Step 6. Optional suffix.
            if (name.Length >= 1)
            {
                // If name ends with "r" then user is restricted from Xbox1
                if (name.StartsWith("r"))
                {
                    // This is a special privilege, make sure it isn't granted whatsoever
                    XkdcUtilities.RemoveFromArray(ref GrantedPrivileges, new uint[] { TestBase_Xkdc.XPRIVILEGE_XBOX1_LIVE_ACCESS });
                    AddRestriction(new uint[] { TestBase_Xkdc.XPRIVILEGE_XBOX1_LIVE_ACCESS });
                }
                name = name.Substring(1);
            }
        }

        public void AddRestriction(uint[] Restrict)
        {
            XkdcUtilities.AddToArray(ref RestrictedPrivileges, Restrict);
            SetPrivileges();
        }

        public void AddGrant(uint[] Grant)
        {
            XkdcUtilities.AddToArray(ref AlwaysGrantedPrivileges, Grant);
            SetPrivileges();
        }

        public void RemoveGrant(uint[] Grant)
        {
            XkdcUtilities.RemoveFromArray(ref AlwaysGrantedPrivileges, Grant);
            SetPrivileges();
        }

//        public void SetPrivileges(uint[] RestrictedPrivileges, uint[] GrantedPrivileges)
//        {
//            this.RestrictedPrivileges = RestrictedPrivileges;
//            this.GrantedPrivileges = GrantedPrivileges;
//            SetPrivileges();
//        }

        public void SetPrivileges()
        {
            if (Tier >= 1 && Tier <= 3 && ExpectedPrivileges == null)
            {
                this.ExpectedPrivileges = Expectations.k_DefaultExpectedPrivileges[Tier - 1];
            }
            else if (ExpectedPrivileges == null)
            {
                throw new UnexpectedTestResultException("Cannot set expected privileges for "+Name+".  Tier="+Tier);
            }

            // Restrict first.
            if (RestrictedPrivileges != null)
            {
                XkdcUtilities.RemoveFromArray(ref ExpectedPrivileges, this.RestrictedPrivileges);
            }
            
            // Grant second.  This is how the KDC is supposed to do it.
            // Note that we shouldn't be able to grant privileges that don't belong to this user's tier.
            if (GrantedPrivileges != null)
            {
                // Remove any granted privileges that aren't in this user's tier
                uint[] grantedInTier = XkdcUtilities.ArrayIntersection(GrantedPrivileges, Expectations.k_DefaultExpectedPrivileges[Tier - 1]);

                // Add remaining privileges to the expected list
                XkdcUtilities.AddToArray(ref ExpectedPrivileges, grantedInTier);
            }

            if (AlwaysGrantedPrivileges != null)
            {
                // Add the always granted privileges
                XkdcUtilities.AddToArray(ref ExpectedPrivileges, AlwaysGrantedPrivileges);
            }   

            // Build mask for bits
            ExpectedPrivilegesBitArray.SetAll(false);
            foreach (uint priv in ExpectedPrivileges)
            {
                ExpectedPrivilegesBitArray.Set((int)priv,true);
            }
        }

        public bool IsRestricted(uint privilege)
        {
            if (RestrictedPrivileges == null)
                return false;

            for (int i = 0; i < RestrictedPrivileges.Length; i++)
            {
                if (RestrictedPrivileges[i] == privilege)
                    return true;
            }
            return false;
        }

        public byte[] GetKey(AuthContext.ClientTypes ctype)
        {
            if (ctype == AuthContext.ClientTypes.Xbox)
                return Hexer.unhex(this.RawXboxKey);
            else
                return Hexer.unhex(this.RawXenonKey);
        }

    }

    /// <summary>
    /// Doles out access to the shared user pool, guarenteeing that the same user is not reused more than once every 3 seconds.
    /// This lets us set the tests to run in paralell without getting failures due to anti-dos.
    /// </summary>
    public class UserTimer
    {
        static System.Collections.Generic.Dictionary<string, System.DateTime> userUse=new System.Collections.Generic.Dictionary<string,DateTime>();

        /// <summary>
        /// This blocks if less than 3 seconds has passed since a user was last used.
        /// </summary>
        public static string AccessSharedUser(string name)
        {
            if (!XkdcTestBaseGroup.settingAskdcDOSEnabled && !XkdcTestBaseGroup.settingAskdcDOS2Enabled && !XkdcTestBaseGroup.settingXkdcDOSEnabled && !XkdcTestBaseGroup.settingXkdcDOS2Enabled)
            {
                return name;
            }

            //anti-dos is enabled, so we might need to delay the request
            while (true)
            {
                //return immediately if we can
                System.DateTime lastUse=System.DateTime.MinValue;
                lock (userUse)
                {
                    if (userUse.ContainsKey(name))
                    {
                        lastUse=userUse[name];
                    }

                    if ((System.DateTime.UtcNow-lastUse).TotalMilliseconds>3000)
                    {
                        userUse[name]=System.DateTime.UtcNow;
                        return name;
                    }
                }

                //we need to wait then try again
                int sleepMS=3000-(int)(System.DateTime.UtcNow-lastUse).TotalMilliseconds+1;
                if (sleepMS<0) sleepMS=0;

                System.Threading.Thread.Sleep(sleepMS);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\TestBase_Xmacs.cs ===
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;


namespace XkdcTest
{

    abstract public class TestBase_Xmacs : TestBase
    {
        // Use this for all output
        public Report ro = new Report("Xmacs");

        //static public AuthContext.ClientTypes   ClientType      = AuthContext.ClientTypes.Xenon;
        //static public bool                      IsXenonClient   = false;

        private AuthContext.ClientTypes     _ClientType;
        public bool                         ClientTypeInitialized = false;

        public bool                         DisableRetryBehaviour=false;

        public AuthContext.ClientTypes ClientType
        {
            get { return _ClientType; }
            set { _ClientType = value; ClientTypeInitialized = true; }
        }
        public bool IsXenonClient
        {
            get 
            {
                return ClientType == AuthContext.ClientTypes.Xenon;
            }
        }
        public bool IsPanoramaClient
        {
            get { return ClientType == AuthContext.ClientTypes.Panorama; }
        }

        public AuthContext.ClientTypes ParentClientType
        {
            get
            {
                TestNode cur=Parent;
                while (cur!=null)
                {
                    if (cur is XkdcTestBaseGroup)
                    {
                        return ((XkdcTestBaseGroup)cur).ParentClientType;
                    }

                    cur=cur.Parent;
                }

                throw new System.Exception("Could not find a XkdcTestBaseGroup parent node, so unable to determine client type");
            }
        }

        // Exceptions
        static protected ServerTestFramework.Utilities.TimeoutException E_NoResponse = new ServerTestFramework.Utilities.TimeoutException();
        static protected KerbErrException E_PrincipalUnknown = new KerbErrException(0x6);
        static protected KerbErrException E_PreauthFailed = new KerbErrException(0x18);
        static protected KerbErrException E_PreauthRequired = new KerbErrException(0x19);
        static protected KerbErrException E_WrongRealm = new KerbErrException(0x44);
        static protected KerbErrException E_TimeSkew = new KerbErrException(0x25);
        static protected KerbErrException E_TokenInvalid = new KerbErrException(0x1000);
        static protected KerbErrException E_TokenBanned = new KerbErrException(0x1001);
        static protected KerbErrException E_TokenUsageExceeded = new KerbErrException(0x1002);
        static protected KerbErrException E_ServiceUnavailable = new KerbErrException(0x1d);  // KDC_ERR_SVC_UNAVAILABLE
        static protected KerbErrException E_TokenInUse = new KerbErrException(0x1003);  // KDC_ERR_XBOX_TOKEN_IN_USE
       
        //static readonly protected ConsoleCertificate k_DefaultConsoleCert = new ConsoleCertificate();

        // Override the following members in your test
        //

        // Only applies for Xenon signins
        protected ConsoleCertificate consoleCert = new ConsoleCertificate();
        public bool UseXenonMacRequest2=true;

        // Should Xenon XMACS requests use the test key or the real key?
        private bool _bUseXmacsTestKey = false;
        protected bool bUseXmacsTestKeyUpdated = false;
        protected bool bUseXmacsTestKey
        {
            get
            {
                if (bUseXmacsTestKeyUpdated)
                    return _bUseXmacsTestKey;
                else
                    return XmacsClient.UseXmacsTestKey();
            }
            set
            {
                _bUseXmacsTestKey = value;
                bUseXmacsTestKeyUpdated = true;
            }
        }
        
        // If an exception is thrown, usually because of a test case with the wrong expected exception,
        // should we throw it up or swallow it?  For debugging test cases, swallowing it is useful.
        protected bool bContinueOnException = true;

        // Verbose output?  Useful for debugging tests and seeing what is going on.
        protected bool bVerbose = false;

        // List of created accounts, to allow us to verify them (by signing in to the ASKDC)
        // at a later point, and all at once.
        protected ArrayList createdAccounts = new ArrayList();

        //override default timeout value
        protected int OverrideTimeout=-1;

        protected void Fail(string format, params object[] args)
        {
            ro.Warn(format, args);
            ResultCode = TEST_RESULTS.FAILED;
        }

        protected XmacsClient DoRequest(XonlinepUser inputMachine)
        {
            return DoRequest(inputMachine, null, true);
        }

        protected XmacsClient DoRequest(XonlinepUser inputMachine, Exception expected)
        {
            return DoRequest(inputMachine, expected, true);
        }

        protected XmacsClient DoRequest(XonlinepUser inputMachine, Exception expected, bool bVerify)
        {
            if (!ClientTypeInitialized)
            {
                ClientType = ParentClientType;
            }
            AuthContext ctx = new AuthContext(ClientType);
            ctx.ConsoleCert = consoleCert;

            if (inputMachine == null)
            {
                // Set defaults for MachineUser in AuthContext
                XmacsClient.SetDefaults(ctx);
            }
            else
            {
                // Copy user, don't want to set just the pointer
                ctx.MachineUser = (XonlinepUser)inputMachine.Clone();
            }

            return DoRequest(ctx, expected, bVerify);
        }

        protected XmacsClient DoRequest(AuthContext ctx, Exception expected, bool bVerify)
        {
            if (ResultCode != TEST_RESULTS.FAILED)
                ResultCode = TEST_RESULTS.PASSED;

            // Set flag only if the test overrode it
            if (bUseXmacsTestKeyUpdated)
                ctx.UseXmacsTestKey = this.bUseXmacsTestKey;

            if (ctx.IsXenonConsole) //set serial number if desired
            {
                ctx.UseXenonMac2=UseXenonMacRequest2;
            }

            // We want manual setup
            XmacsClient xmacs = new XmacsClient(ctx, consoleCert, null, true);
            if (DisableRetryBehaviour) xmacs.EmulateClientBehavior=false;
            xmacs.TimeoutInMs = 2000;
            if (OverrideTimeout!=-1)
            {
                xmacs.TimeoutInMs=OverrideTimeout;
            }

            try
            {
                // Here we go

                if (bVerbose)
                {
                    if (ctx.IsPanorama)
                    {
                        ro.Debug("DoRequest for Realm={0}, Token={1}, PcId=0x{2}",
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            ctx.SponsorToken,
                            Hexer.tohex(ctx.PcId));
                    }
                    else
                    {
                        ro.Debug("DoRequest for Gamertag={0}, Key=0x{1}, Realm={2}",
                                 AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                                 Hexer.tohex(ctx.MachineUser.Key),
                                 AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm));
                    }
                }
                
                // Sign in
                xmacs.SignInXmacs();

                if (expected != null)
                {
                    if (ctx.IsXenonConsole)
                    {
                        ro.Warn("Unexpectedly succeeded for Gamertag={0}, Key=0x{1}, Realm={2}, CID=[{3:X},{4:X},{5:X},{6:X},{7:X}], Expected {8}",
                            AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                            Hexer.tohex(ctx.MachineUser.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            consoleCert.ConsoleId[0], consoleCert.ConsoleId[1], consoleCert.ConsoleId[2],
                            consoleCert.ConsoleId[3], consoleCert.ConsoleId[4],
                            expected == null ? "<none>" : expected.Message);
                    }
                    else if (ctx.IsPanorama)
                    {
                        // MachineUser has nothing for Panorama. Since this succeeded, we 
                        // can use UsersMachine (the output) for the gamertag and key
                        ro.Warn("Unexpectedly succeeded for Gamertag={0}, Key=0x{1}, Realm={2}, Token={3}, PcId=0x{4}, Expected {5}",
                            AuthClientBase.BytesToString(ctx.UsersMachine.Gamertag),
                            Hexer.tohex(ctx.UsersMachine.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            ctx.SponsorToken,
                            Hexer.tohex(ctx.PcId),
                            expected == null ? "<none>" : expected.Message);
                    }
                    else
                    {
                        ro.Warn("Unexpectedly succeeded for Gamertag={0}, Key=0x{1}, Realm={2}, Expected {3}",
                            AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                            Hexer.tohex(ctx.MachineUser.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            expected == null ? "<none>" : expected.Message);
                    }
                    if (!bContinueOnException)
                        throw new UnexpectedTestResultException("Test unexpectedly succeeded.");
                    else
                        ResultCode = TEST_RESULTS.FAILED;
                    return xmacs;
                }

                // Verify puid, gamertag, etc of (input machine, created machine)
                if (bVerify)
                {
                    VerifyMachine(ctx.MachineUser, ctx.UsersMachine);
                    if (ctx.IsPanorama)
                    {
                        ValueCheck.IsTrue(ctx.PassportTicket != null && ctx.PassportTicket.Length > 0, "passport ticket length");
                    }
                        
                }

                return xmacs;
            }
            catch(KerbErrException actual)
            {
                if (!(expected is KerbErrException) || (expected as KerbErrException != actual))
                {
                    if (ctx.IsXenonConsole)
                    {
                        ro.Warn("Got KerbErr {0} for Gamertag={1}, Key=0x{2}, Realm={3}, CID=[{4:X},{5:X},{6:X},{7:X},{8:X}], Expected {9}",
                            actual.KerbErr,
                            AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                            Hexer.tohex(ctx.MachineUser.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            consoleCert.ConsoleId[0], consoleCert.ConsoleId[1], consoleCert.ConsoleId[2],
                            consoleCert.ConsoleId[3], consoleCert.ConsoleId[4],
                            expected == null ? "<none>" : expected.Message);
                    }
                    else if (ctx.IsPanorama)
                    {
                        ro.Warn("Got KerbErr {0} for Gamertag={1}, Key=0x{2}, Realm={3}, Token={4}, PcId=0x{5}, Expected {6}",
                            actual.KerbErr,
                            AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                            Hexer.tohex(ctx.MachineUser.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            ctx.SponsorToken,
                            Hexer.tohex(ctx.PcId),
                            expected == null ? "<none>" : expected.Message);
                    }
                    else
                    {
                        ro.Warn("Got KerbErr {0} for Gamertag={1}, Key=0x{2}, Realm={3}, Expected {4}",
                            actual.KerbErr,
                            AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                            Hexer.tohex(ctx.MachineUser.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            expected == null ? "<none>" : expected.Message);
                    }
                    if (!bContinueOnException)
                        throw new UnexpectedTestResultException("KerbErr not expected.", actual);
                    else
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
            catch(ServerTestFramework.Utilities.TimeoutException actual)
            {
                if (!(expected is ServerTestFramework.Utilities.TimeoutException))
                {
                    if (ctx.IsXenonConsole)
                    {
                        ro.Warn("Timed out for Gamertag={0}, Key=0x{1}, Realm={2}, CID=[{3:X},{4:X},{5:X},{6:X},{7:X}], ConsoleType=0x{8:X}",
                            AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                            Hexer.tohex(ctx.MachineUser.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            consoleCert.ConsoleId[0], consoleCert.ConsoleId[1], consoleCert.ConsoleId[2],
                            consoleCert.ConsoleId[3], consoleCert.ConsoleId[4],
                            consoleCert.ConsoleType);
                    }
                    else if (ctx.IsPanorama)
                    {
                        ro.Warn("Timed out for Gamertag={0}, Key=0x{1}, Realm={2}, Token={3}, PcId=0x{4}",
                            AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                            Hexer.tohex(ctx.MachineUser.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm),
                            ctx.SponsorToken,
                            Hexer.tohex(ctx.PcId));

                    }
                    else
                    {
                        ro.Warn("Timed out for Gamertag={0}, Key=0x{1}, Realm={2}",
                            AuthClientBase.BytesToString(ctx.MachineUser.Gamertag),
                            Hexer.tohex(ctx.MachineUser.Key),
                            AuthClientBase.BytesToString(ctx.MachineUser.KerberosRealm));
                    }

                    if (!bContinueOnException)
                        throw new UnexpectedTestResultException("Timeout not expected.", actual);
                    else
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
            catch(PassportException actual)
            {
                if (expected is PassportException)
                {
                    ro.Debug("[OK] " + actual.Message);
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    ro.Error("[ERR] " + actual.Message);
                    if (!bContinueOnException)
                        throw new UnexpectedTestResultException("Passport error not expected", actual);
                }
            }

            return xmacs;
        }

        /// <summary>
        /// Create machine, store results so we can verify later
        /// </summary>
        /// <param name="inputMachine"></param>
        /// <returns></returns>
        protected XmacsClient CreateToBeVerified(XonlinepUser inputMachine)
        {
            // Create account with XMACS
            XmacsClient xmacs = DoRequest(inputMachine);
            // Add to arraylist
            createdAccounts.Add(xmacs.Context);
            return xmacs;
        }

        /// <summary>
        /// Create machine, verify by signing in to ASKDC
        /// </summary>
        /// <param name="inputMachine"></param>
        /// <returns></returns>
        protected XmacsClient DoRequestVerify(XonlinepUser inputMachine)
        {
            // Create account with XMACS
            XmacsClient xmacs = DoRequest(inputMachine);

            Verify(xmacs.Context);
            return xmacs;
        }

        /// <summary>
        /// Create machine, verify result with a different input machine account, and sign in to ASKDC
        /// </summary>
        /// <param name="verifyMachine"></param>
        /// <param name="inputMachine"></param>
        /// <returns></returns>
        protected XmacsClient DoRequestVerify(XonlinepUser verifyMachine, XonlinepUser inputMachine)
        {
            // Create account with XMACS
            XmacsClient xmacs = DoRequest(inputMachine, null, false);

            VerifyMachine(verifyMachine, xmacs.Context.UsersMachine);
            Verify(xmacs.Context);
            return xmacs;
        }

        /// <summary>
        /// Verifies the created machine with the machine account info used to create it
        /// </summary>
        /// <param name="inputUser"></param>
        /// <param name="createdMachine"></param>
        protected void VerifyMachine(XonlinepUser inputUser, XonlinepUser createdMachine)
        {
            // Verify puid
            if (createdMachine==null || createdMachine.xuid==null)
            {
                throw new UnexpectedTestResultException("Failed to created machine.");
            }

            ValueCheck.IsTrue(createdMachine.xuid.qwUserID > 0, "createdMachine puid not zero");
            string inputName = AuthClientBase.BytesToString(inputUser.Gamertag);
            string createdName = AuthClientBase.BytesToString(createdMachine.Gamertag);

            if (IsXenonClient)
            {
                // Check Xenon gamertag
                ValueCheck.Test("inputUser.Gamertag and createdMachine.Gamertag", inputName, createdName);
                ValueCheck.IsTrue((createdMachine.xuid.qwUserID & 0xFA00000000000000) == 0xFA00000000000000, "createdMachine puid is xenon");
            }
            else if(IsPanoramaClient)
            {
                ValueCheck.IsTrue((createdMachine.xuid.qwUserID & 0xFB00000000000000) == 0xFB00000000000000, "createdMachine puid is pc");
            }
            else
            {
                // Check Xbox gamertag, begins with "SN."
                ValueCheck.Test("createdMachine.Gamertag and inputMachine.Gamertag", createdName, "SN." + inputName);
                ValueCheck.IsTrue((createdMachine.xuid.qwUserID & 0x0009000000000000) == 0x0009000000000000, "createdMachine puid is xbox");
            }

        }

        /// <summary>
        /// Verify all created accounts by signing into ASKDC
        /// </summary>
        protected void Verify()
        {
            foreach (AuthContext ctx in createdAccounts)
            {
                Verify(ctx);
            }
        }

        /// <summary>
        /// Verify created machine by signing into ASKDC
        /// </summary>
        /// <param name="ctx"></param>
        protected void Verify(AuthContext ctx)
        {
            // Sign in to ASKDC with this machine
            ro.Debug("Signing in to ASKDC...");
            try
            {
                AskdcClient askdc = new AskdcClient(ctx);
                if (DisableRetryBehaviour) askdc.EmulateClientBehavior=false;
                askdc.SignInAskdc();
            }
            catch (Exception e)
            {
                ro.Debug("ASKDC threw exception: " + e.Message);
                throw e;
            }
        }

        /// <summary>
        /// Compare 2 machines created by XMACS. Verify they are different, or the same.
        /// </summary>
        /// <param name="m1">Machine 1</param>
        /// <param name="m2">Machine 2</param>
        /// <param name="bMachinesEqual">Should the machines be equal (via a Reset call) 
        /// or different (via a Create call)?</param>
        protected void CompareMachines(XonlinepUser m1, XonlinepUser m2, bool bMachinesEqual)
        {
            if (m1 == null || m2 == null)
            {
                Fail("One of the machines being compared is null, this is unexpected and indicates a failed XMACS request");
                return;
            }

            // Check gamertag and key and puid
            bool bGt = ArrayEx.Compare(m1.Gamertag, m2.Gamertag);
            bool bKey = ArrayEx.Compare(m1.Key, m2.Key);
            bool bPuid = (m1.xuid.qwUserID == m2.xuid.qwUserID);

            if (bMachinesEqual && !bGt)
            {
                Fail("Machine gamertags don't match: m1=\"{0}\", m2=\"{1}\"", 
                     AuthClientBase.BytesToString(m1.Gamertag),
                     AuthClientBase.BytesToString(m2.Gamertag));
            }
            else if (!bMachinesEqual && bGt)
            {
                Fail("Machine gamertags match: m1=\"{0}\", m2=\"{1}\"", 
                     AuthClientBase.BytesToString(m1.Gamertag),
                     AuthClientBase.BytesToString(m2.Gamertag));
            }

            if (bMachinesEqual && !bPuid)
            {
                Fail("Machine puids don't match: m1=0x{0:X}, m2=0x{1:X}", 
                     m1.xuid.qwUserID,
                     m2.xuid.qwUserID);
            }
            else if (!bMachinesEqual && bPuid)
            {
                Fail("Machine puids match: m1=0x{0:X}, m2=0x{1:X}", 
                     m1.xuid.qwUserID,
                     m2.xuid.qwUserID);
            }            
            
            if (bKey)
            {
                Fail("Machine keys match, they should be different for both a Create and a Reset call");
            }
        }

        protected void VerifyDatabase(XmacsClient xmacs)
        {
            if (xmacs == null || xmacs.Context == null || xmacs.Context.UsersMachine == null)
            {
                Fail("Sign-in failed, unable to verify database");
                return;
            }

            XonlinepUser machine = xmacs.Context.UsersMachine;

            // Get row from uodb
            UodbTable dbtable = new UodbTable("t_machines", "bi_machine_puid");
            dbtable.SetConstraint("bi_machine_puid", machine.xuid.qwUserID);
            int count = UodbWS.ExecuteSQLSelect(dbtable);

            ro.Debug(dbtable.ToString());

            string gamertag = AuthClientBase.BytesToString(machine.Gamertag);
            int consoleType = 0;
            byte[] consolePartNum = new byte[11];
            if (xmacs.Context.IsXenonConsole)
            {
                consoleType = (int)ConsoleCertificate.BYTESWAP32(xmacs.Context.ConsoleCert.ConsoleType);
                consolePartNum = xmacs.Context.ConsoleCert.ConsolePartNumber;
            }
            if (xmacs.Context.ClientType == AuthContext.ClientTypes.Xbox)
            {
                // Our gamertag looks like "SN.000000000000" but it is stored without the 
                // "SN." prefix in the database.
                gamertag = gamertag.Substring(3);
            }

            if (count != 1)
                Fail("[VerifyDatabase] expected 1 row returned, got {0}", count);

            if ((long)machine.xuid.qwUserID != (long)dbtable.GetProperty("bi_machine_puid"))
                Fail("[VerifyDatabase] machine puid expected 0x{0:X}, got 0x{1:X}", 
                     machine.xuid.qwUserID, 
                     (ulong)dbtable.GetProperty("bi_machine_puid"));

            if (gamertag != (string)dbtable.GetProperty("vc_serial_num"))
                Fail("[VerifyDatabase] machine gamertag expected \"{0}\", got \"{1}\"", 
                     gamertag, 
                     (string)dbtable.GetProperty("vc_serial_num"));

            try
            {
                if (consoleType != (int)dbtable.GetProperty("i_cert_console_type"))
                    Fail("[VerifyDatabase] console type expected 0x{0:X}, got 0x{1:X}", 
                         consoleType, 
                         (int)dbtable.GetProperty("i_cert_console_type"));

                ValueCheck.TestAll("cert console part number", 
                                   consolePartNum,
                                   (byte[])dbtable.GetProperty("bin_cert_part_number"));
            }
            catch (KeyNotFoundException)
            {
                Fail("t_machines has not been updated to include the i_cert_console_type and bin_cert_part_number columns");
            }
        }


        // Setting override stuff
        //

        private Dictionary<string, SettingState> _ActiveSettings = null;

        protected void OverrideSetting(string settingName, string settingValue)
        {
            // Override it
            SettingState ss = Global.XEnv.OverrideSetting(
                "kdcsvc",                               // component (or ALL)
                "ALL",                                  // server (or ALL)
                settingName, 
                settingValue);

            // Store old value for later
            if (_ActiveSettings == null)
                _ActiveSettings = new Dictionary<string, SettingState>();
            _ActiveSettings[settingName] = ss;

            // Force the server to swallow setting
            System.Threading.Thread.Sleep(2000); //TODO: why does this sometimes fix the problem of the setting not being picked up?
            Suite.RefreshKDCsConfig();

            try
            {
                ConfigInfo ci = Global.XEnv.GetSettingFromServerProcess(
                    "kdcsvc",
                    Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.kdcsvc)[0],
                    settingName,
                    true);
                if (ci.settingvalue != settingValue)
                {
                    ro.Warn("Unable to override setting {0} to {1}:\n{2}", settingName, settingValue, ci.ToString());
                }
            }
            catch (Exception e)
            {
                ro.Warn("Got non-fatal exception while trying to verify the server's config cache setting. Exception: \n{0}", e.ToString());
            }
        }

        protected void RevertSettingOverrides()
        {
            if (_ActiveSettings == null)
                return;
            foreach (KeyValuePair<string, SettingState> kvp in _ActiveSettings)
            {
                string settingName = kvp.Key;
                string oldValue = kvp.Value.oldvalue;
                bool wasOverridden = kvp.Value.wasoverriden;

                if (wasOverridden)
                {
                    Global.XEnv.OverrideSetting(
                        "kdcsvc",
                        "ALL",
                        settingName,
                        oldValue);
                }
                else
                {
                    Global.XEnv.DeleteOverrideSetting(
                        "kdcsvc",
                        "ALL",
                        settingName);
                }

                // Force server to swallow setting
                System.Threading.Thread.Sleep(1000); //TODO: why does this sometimes fix the problem of the setting not being picked up?
                Suite.RefreshKDCsConfig();
            }
        }


    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\TestBase_Panorama.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    abstract public class TestBase_Panorama : TestBase_Xkdc
    {
        protected static PassportException E_Passport = new PassportException();

        // Re-usable cached machine accounts, automagically delays subsequent uses of them 
        // by over 1 second (DoS cache time).
        protected static KerbStoreGeneric cachedMachineContexts = new KerbStoreGeneric(1100, 100); 

        //override and return false to use a new machine account rather than a cached one
        public virtual bool UseCachedMachineAccount()
        {
            return true;
        }

        public TestBase_Panorama()
        {
            ClientType = AuthContext.ClientTypes.Panorama;
        }

        public override void PreRun()
        {
            authContext=null;
        }

        public static void ClearMachineCache()
        {
            object o=cachedMachineContexts.Pop();
            while (o!=null)
            {
                o=cachedMachineContexts.Pop();
            }
        }

        protected AuthContext GetPanoramaMachineAccount()
        {
            object o = cachedMachineContexts.Get();
            if (o != null)
            {
                return o as AuthContext;
            }
            // Need to create one
            ro.Info("Creating a cached machine account");
            AuthContext cachedMachineCtx = new AuthContext(AuthContext.ClientTypes.Panorama);
            XmacsClient xmacs = new XmacsClient(cachedMachineCtx, null, null, true);
            if (DisableRetryBehaviour) xmacs.EmulateClientBehavior=false;

            // Create a new passport user for this cached machine account
            XmacsClient.SetDefaults(cachedMachineCtx);
            cachedMachineCtx.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            xmacs.SignInXmacs();
            cachedMachineContexts.Add(cachedMachineCtx);
            return cachedMachineCtx;
        }

        override public void SetDefaults()
        {
            base.SetDefaults();
            if (ClientType == AuthContext.ClientTypes.Panorama &&
                authContext.UsersMachine == null &&
                UseCachedMachineAccount())
            {
                // Fill authContext with the cached machine account info
                AuthContext cachedMachineCtx = GetPanoramaMachineAccount();
                authContext.PassportMemberName = (string)cachedMachineCtx.PassportMemberName.Clone();
                authContext.PassportPassword = (string)cachedMachineCtx.PassportPassword.Clone();
                authContext.PcId = (byte[])cachedMachineCtx.PcId.Clone();
                authContext.SponsorToken = (string)cachedMachineCtx.SponsorToken.Clone();
                authContext.MachineUser = (XonlinepUser)cachedMachineCtx.MachineUser.Clone();
                authContext.UsersMachine = (XonlinepUser)cachedMachineCtx.UsersMachine.Clone();
            }

            AskdcClient.SetDefaults(authContext);

        }

        protected bool SignInAskdc()
        {
            return SignInAskdc(null);
        }

        protected bool SignInAskdc(Exception expected)
        {
            AskdcClient askdc = new AskdcClient(authContext, null, true);
            if (DisableRetryBehaviour) askdc.EmulateClientBehavior=false;

            try
            {
                if (authContext.PassportTicket == null)
                {
                    if (authContext.IncludeEncryptedPassportByDefault)
                    {
                        authContext.PassportAuthenticate("MBI", AuthClientBase.PassportSite.KdcPanorama);
                    }
                    else
                    {
                        authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                    }
                }
                ro.Debug("Signing in machine {0}, user1 {1}{2}", 
                         authContext.UsersMachine == null 
                            ? "<none>" 
                            : AuthClientBase.BytesToString(authContext.UsersMachine.Gamertag),
                         authContext.NumUsers > 0 ? authContext.PassportMemberName : "<none>",
                         authContext.NumUsers > 1 
                            ? " (user2 " + AuthClientBase.BytesToString(authContext.Users[1].Gamertag) + ")" 
                            : "");
                askdc.SignInAskdc();
                if (expected != null)
                {
                    Fail("Unexpectedly succeeded at SignInAskdc(), expected exception {0}", expected.GetType());
                }
            }
            catch (Exception e)
            {
                if (expected == null)
                {
                    throw;
                }
                if (e.GetType() != expected.GetType())
                {
                    throw;
                }
                return true;
            }
            finally
            {
                LastSignInTime = DateTime.Now;
            }

            return VerifyAskdc();
        }

        protected bool VerifyAskdc()
        {
            // Not much to do...
            if (authContext.CombinedTgt == null)
            {
                Fail("Missing TGT from ASKDC");
                return false;
            }

            return true;
        }

        protected static KdcUser CreateUserWithRetries(bool gold)
        {
            for (int i=0; i<3; ++i)
            {
                Global.RO.Debug("Creating "+(gold?"gold":"silver")+" user..."+(i>0?" (retry)":""));
                try
                {
                    return AuthContext.MakeNewGenericUser(true, gold);
                }
                catch (System.Exception e)
                {
                    if (i<3-1)
                    {
                        Global.RO.Warn("CreateUser failed (will retry): "+e.Message);
                    }
                    else
                    {
                        throw;
                    }
                    System.Threading.Thread.Sleep(i*5000);
                }
            }

            throw new System.Exception("Failed to create user.");
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\TestBase_Xkdc.cs ===
using System;
using System.Text;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace XkdcTest
{
    abstract public class TestBase_Xkdc : TestBase
    {
        // Use this for all output
        public Report ro = new Report("Xkdc");

        private AuthContext.ClientTypes     _ClientType;
        public bool                         ClientTypeInitialized = false;

        public bool                         DisableRetryBehaviour=false;

        public AuthContext.ClientTypes ClientType
        {
            get { return _ClientType; }
            set { _ClientType = value; ClientTypeInitialized = true; }
        }
        public bool IsXenonClient
        {
            get { return ClientType == AuthContext.ClientTypes.Xenon; }
        }

        public int DefaultXkdcXenonPreauthVersion
        {
            get
            {
                TestNode cur=Parent;
                while (cur!=null)
                {
                    if (cur is XkdcTestBaseGroup)
                    {
                        return ((XkdcTestBaseGroup)cur).DefaultXkdcXenonPreauthVersion;
                    }

                    cur=cur.Parent;
                }

                ro.Warn("Could not find a XkdcTestBaseGroup parent node.  Using platform default for XkdcXenonPreauthVersion.");
                return 0;
            }
        }

        public AuthContext.ClientTypes ParentClientType
        {
            get
            {
                TestNode cur=Parent;
                while (cur!=null)
                {
                    if (cur is XkdcTestBaseGroup)
                    {
                        return ((XkdcTestBaseGroup)cur).ParentClientType;
                    }

                    cur=cur.Parent;
                }

                throw new System.Exception("Could not find a XkdcTestBaseGroup parent node, so unable to determine client type");
            }
        }

        // Exceptions
        static protected ServerTestFramework.Utilities.TimeoutException E_NoResponse = new ServerTestFramework.Utilities.TimeoutException();
        static protected KerbErrException E_PrincipalUnknown = new KerbErrException(0x06);
        static protected KerbErrException E_PreauthFailed = new KerbErrException(0x18);
        static protected KerbErrException E_WrongRealm = new KerbErrException(0x44);
        static protected KerbErrException E_TimeSkew = new KerbErrException(0x25);
        static protected KerbErrException E_ServiceUnavailable = new KerbErrException(0x1d);  // KDC_ERR_SVC_UNAVAILABLE

        // Used for throttling
        static protected DateTime LastSignInTime = DateTime.Now;

        // Array of XKDC test users; this is not complete, but includes "interesting"
        // ones for comprehensive tests.
        public static string[] k_AllTestUsers = new string[]
            {
                "xktusert1a",
                "xktusert1b",
                "xktusert1c",
                "xktusert1d",
                "xktusert1e",
                "xktusert1f",
                "xktusert2a",
                "xktusert2b",
                "xktusert2c",
                "xktusert2d",
                "xktusert2e",
                "xktusert2f",
                "xktduusert2ar"
            };

        // The index at which tier 2 users being in the above array
        public int k_UsersStartIdxTier2 = 6;

        // The real "meat" of this class
        public AuthContext  authContext         = null;
        public XkdcClient   xkdc                = null;
        public XkdcResult   result              = null; // set after Verify()

        // Constants, representing data loaded into UODB

        // "Privilege" for Xbox1 live access
        public const uint XPRIVILEGE_XBOX1_LIVE_ACCESS = 242;

        // "Privilege" for normal video communication
        public const uint XPRIVILEGE_VIDEO_COMMUNICATIONS = 235;

        // Set these in the tests as needed
        public uint[] ExpectedServices          = null;  // k_DefaultExpectedServices[1];
        public uint[] ExpectedHRs               = null;  // k_DefaultExpectedHRs[1];
        public uint[] RequestedServices         = null;  // if left null, will be set to ExpectedServices.  otherwise this set is used to build the request.
        public uint ExpectedHR                  = HResult.S_OK;
        public uint[] ExpectedUserHRs           = null;

        private uint? _ExpectedADVersion        = null;
        public uint ExpectedADVersion
        {
            get
            {
                // XCS bug 145652 introduced a "mitigation" feature where PreAuthV4 (old) 
                // can only get AuthdataV3 (old). PreAuthV5 (new) can get any version of 
                // Authdata, including AuthdataV4 (new).

                if (_ExpectedADVersion == null)
                {
                    return (DefaultXkdcXenonPreauthVersion < 5) ? (uint)3 : (uint)4;
                }
                else
                {
                    // In case test wanted to override the default
                    return (uint)_ExpectedADVersion;
                }

            }
            set
            {
                _ExpectedADVersion = value;
            }
        }

        private uint[] requestedServicesToUse   = null; //this is reset every run, based on RequestedServices.

        // Users to log in with, or leave as all nulls for a machine logon. This is useful
        // as the UserInfo class encodes additional information about the users, but 
        // remember we still need to set the XonlinepUser array in AuthContext for the
        // actual sign-in information.
        private UserInfo[] Users                 = new UserInfo[4] { null, null, null, null };

        // Title to log in with. OK to leave as null, you'll get the default one
        //public TitleInfo TI                     = new TitleInfo(0xFFC0FE00, 0, 0);

        // Controls the verification behavior, enable or disable certain checks depending on what you want
        public bool bVerifyServices             = true;
        public bool bVerifyHRs                  = true;
        public bool bVerifyPrivileges           = true;
        public bool bVerifyAuthdata             = false;    // This is fairly rigourous and not something that affects the client, so off by default
        public bool bVerifyUserFlags            = true;
        public bool bVerifyUserHRs              = false;
        public bool bTooManyServicesOk          = true;     // Getting back too many services from auto-discovery is ok/not ok
        public bool bVerboseCheck               = true;     // Continuing verifying even if errors found, or stop immediately
        public bool bExpectNoReply              = false;    // Expect no reply from XKDC?
        public bool bSetDefaults                = true;     // SetDefaults() called before test runs

        // Values set by Verify()
        private BitArray   ExpectedAD3PrivilegesBitArray       = new BitArray(256); //bitwise AND of the per-user privileges. only the last 96 bits are used
        private BitArray   ExpectedMachinePrivilegesBitArray   = new BitArray(256); //only bits 128-160 are used
        private BitArray   ExpectedServicesBitArray            = new BitArray(256); //only the first 128 bits are used

        // Internal state items

        // Set if privilege bits don't match expected in the service result. Used to
        // prevent a similar warning in the authdata privilege bits check.
        private bool bPrivBitsNoMatch           = false;
        private bool bRetVal                    = true;

        /// <summary>
        /// Constructor, called for each test case
        /// </summary>
        override protected void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;
            ExpectedServices = null;
            RequestedServices = null;
            ExpectedHRs = null;
            ExpectedHR = HResult.S_OK;
            if (bSetDefaults)
            {
                SetDefaults();
            }

            RunTest();
        }

        /// <summary>
        /// Set defaults for any members that might need resetting between tests
        /// </summary>
        public virtual void SetDefaults()
        {
            ClearUsers();

            // If this hasn't been created already, create it
            if (authContext == null)
            {
                if (!ClientTypeInitialized)
                {
                    ClientType = ParentClientType;
                }
                authContext = new AuthContext(ClientType);
            }
            else
            {
                authContext.ClearXkdc();
            }

            XkdcClient.SetDefaults(authContext);
            SetRequestVersion(authContext, DefaultXkdcXenonPreauthVersion);

            this.result = null;

            ExpectedServices = null;
            RequestedServices = null;
            ExpectedHRs = null;
            ExpectedHR = HResult.S_OK;

        }

        /// <summary>
        /// Sets the request version into the given context.
        /// </summary>
        public static void SetRequestVersion (AuthContext context, int requestVersion)
        {
            if (requestVersion == 5 || requestVersion == 6)
            {
                context.XenonPreauthVersion = 5;
                if (requestVersion == 6)
                {
                    context.TitleInfo.OverrideDefaultServiceRequest = 1;
                    context.TitleInfo.OverrideDefaultServiceRequestVersion = 6;
                }
            }
            else
            {
                context.XenonPreauthVersion = requestVersion;
            }
        }

        /// <summary>
        /// Override this to actually execute the test
        /// </summary>
        abstract protected void RunTest();

        /// <summary>
        /// Throttling, to get around the DoS stuff on the server
        /// </summary>
        public void Throttle()
        {
            Throttle(1200);
        }

        /// <summary>
        /// Throttling, to get around DoS stuff on the server
        /// </summary>
        public void Throttle(int timeInMs)
        {
            if (XkdcTestBaseGroup.settingAskdcDOSEnabled || XkdcTestBaseGroup.settingXmacsDOSEnabled)
            {
                TimeSpan span = DateTime.Now - LastSignInTime;
                while (span.TotalMilliseconds < timeInMs)
                {
                    System.Threading.Thread.Sleep((int)(timeInMs - span.TotalMilliseconds));
                    span = DateTime.Now - LastSignInTime;
                }
            }
        }

        /// <summary>
        /// Super uber entry point function for most tests. Just do it.
        /// </summary>
        /// <returns></returns>
        public bool SignInXkdc(bool bAutoDisc)
        {
            return SignInXkdc(bAutoDisc, null, null);
        }
        public bool SignInXkdc(bool bAutoDisc, uint[] ExtraServices, uint[] ExtraHRs)
        {
            return SignInXkdc(bAutoDisc, ExtraServices, ExtraHRs, true);
        }
        public bool SignInXkdc(bool bAutoDisc, uint[] ExtraServices, uint[] ExtraHRs, bool allowThrottle)
        {
            //make sure we preserve the original ExpectedServices and ExpectedHRs, since some things we do
            uint []origExpectedServices=ExpectedServices;
            uint []origExpectedServiceHRs=ExpectedHRs;

            if (ExpectedServices!=null)
            {
                ExpectedServices=(uint[])ExpectedServices.Clone();
            }

            if (ExpectedHRs!=null)
            {
                ExpectedHRs=(uint[])ExpectedHRs.Clone();
            }

            try
            {
                // Create new XKDC client. Necessary every time?
                xkdc = new XkdcClient(authContext, null, true);
                if (DisableRetryBehaviour) xkdc.EmulateClientRetryAndTimingBehavior=false;

                requestedServicesToUse=null;
                this.AddToExpectedServices(ExtraServices, ExtraHRs);

                BuildExpectations(bAutoDisc, ExtraServices);

                if (authContext.IsXenonTitle || authContext.IsPanorama)
                {
                    // Xenon request
                    if (bAutoDisc)
                        xkdc.SetRequest(requestedServicesToUse, true);
                    else
                        xkdc.SetRequest(requestedServicesToUse, false);
                }
                else
                {
                    // Xbox request
                    xkdc.SetRequest(requestedServicesToUse);
                }

                if (allowThrottle)
                {
                    Throttle(1300);
                }

                try
                {
                    this.xkdc.SignInXkdc();
                }
                finally
                {
                    LastSignInTime = DateTime.Now;
                }
                this.result = authContext.GetXkdcResult();
                return Verify(this.result);
            }
            finally
            {
                //restore original expectation arrays
                ExpectedServices=origExpectedServices;
                ExpectedHRs=origExpectedServiceHRs;
            }
        }

        public bool SignInXkdc()
        {
            // If ExpectedServices was set by the test, then we don't use autodiscover; otherwise we do.
            bool bAutoDisc = (this.ExpectedServices == null);
            return SignInXkdc(bAutoDisc);
        }

        public bool SignInXkdc_NoReply()
        {
            bExpectNoReply = true;
            bool success = SignInXkdc();
            if (result != null)
            {
                Fail("Expected no reply from the XKDC, instead we got a response");
            }
            return success;
        }


        /// <summary>
        /// Based on the requested services, or based on what we know about the data in the database for auto-discover
        /// requests, we expect certain privileges and services to be returned.  Build those expectations here.
        /// </summary>
        public void BuildExpectations(bool bExpectDefaultServices, uint[] ExtraServices)
        {
            ExpectedAD3PrivilegesBitArray.SetAll(false);
            ExpectedMachinePrivilegesBitArray.SetAll(false);
            ExpectedServicesBitArray.SetAll(false);

            int lastTier = 0;
            // Loop through users
            for (int userNum = 0; userNum < Users.Length; userNum++)
            {
                if (Users[userNum] == null)
                    continue;

                if (bExpectDefaultServices)
                {
                    int tierIdx = Users[userNum].Tier - 1;
                    if (userNum == 0)
                        lastTier = Users[userNum].Tier;
                    if (tierIdx >= 0 && tierIdx < Expectations.k_DefaultExpectedServices.Length)
                    {
                        // Tiers are same, only set for the first occurrence
                        if (userNum == 0)
                        {
                            AddToExpectedServices(Expectations.k_DefaultExpectedServices[tierIdx], Expectations.k_DefaultExpectedHRs[tierIdx]);
                            lastTier = Users[userNum].Tier;
                        }
                        // Hard-coded to check for tier 1 and tier 2 sign-ins only
                        // Are the tiers different?
                        else if (lastTier != Users[userNum].Tier)
                        {
                            ExpectedServices = (uint[])Expectations.k_DefaultExpectedServicesTier12.Clone();
                            ExpectedHRs = (uint[])Expectations.k_DefaultExpectedHRsTier12.Clone();
                            lastTier = Users[userNum].Tier;
                        }
                    }

                    //additional services for certain users (todo: handle multi-user scenario where some users don't have these)
                    if (Users[userNum].AdditionalServices.Length>0)
                    {
                        AddToExpectedServices(Users[userNum].AdditionalServices, new uint[Users[userNum].AdditionalServices.Length]);
                    }
                }

                if (userNum == 0)
                    ExpectedAD3PrivilegesBitArray = (BitArray)Users[userNum].ExpectedPrivilegesBitArray.Clone();
                else
                    ExpectedAD3PrivilegesBitArray = ExpectedAD3PrivilegesBitArray.And(Users[userNum].ExpectedPrivilegesBitArray);
            }

            // Do union of machine services
            if (bExpectDefaultServices)
            {
                AddToExpectedServices(Expectations.k_DefaultExpectedMachineServices, Expectations.k_DefaultExpectedMachineHRs);
            }

            //if we are xbox1 and doing the default thing, we can't ever request more than 12 services, so warn and crop off the front
            if (ExpectedServices.Length>12 && bExpectDefaultServices && (authContext.ClientType==AuthContext.ClientTypes.Xbox || authContext.ClientType==AuthContext.ClientTypes.XenonBackCompat))
            {
                ro.Warn("There are more default expected services("+ExpectedServices.Length+") than xbox1 supports, so cropping the default expectations down to 12");
                uint []tmpServices=new uint[12];
                uint []tmpHR=new uint[12];
                for (int i=0; i<12; ++i)
                {
                    tmpServices[i]=ExpectedServices[ExpectedServices.Length-12+i];
                    tmpHR[i]=ExpectedHRs[ExpectedHRs.Length-12+i];
                }
                ExpectedServices=tmpServices;
                ExpectedHRs=tmpHR;
            }

            //figure out the services to actually request if needed
            if (RequestedServices==null)
            {
                if (authContext.IsXenonTitle || authContext.IsPanorama)
                {
                    if (bExpectDefaultServices) //bExpectDefaultServices should be set to bAutoDisc
                        requestedServicesToUse=ExtraServices;
                    else
                        requestedServicesToUse=ExpectedServices;
                }
                else
                {
                    requestedServicesToUse=ExpectedServices;
                }
            }
            else
            {
                requestedServicesToUse=RequestedServices;
            }

            //if the overall HR is fail, then we should always expect no services back
            if (ExpectedHR!=0)
            {
                ExpectedServices=new uint[0];
                ExpectedHRs=new uint[0];
            }

            //set bits
            ExpectedServicesBitArray.SetAll(false);
            if (ExpectedHRs != null && bVerifyHRs)
            {
                for (int i=0; i<ExpectedServices.Length; ++i)
                {
                    // Bits are only set for services that succeed with HResult of 0
                    if (i<ExpectedHRs.Length && ExpectedHRs[i] == 0)
                    {
                        if (ExpectedServices[i]<128)
                        {
                            ExpectedServicesBitArray.Set((int)ExpectedServices[i],true);
                        }
                    }
                }
            }

            //machine privileges
            foreach (uint p in Expectations.k_DefaultExpectedMachinePrivileges)
            {
                ExpectedMachinePrivilegesBitArray.Set((int)p, true);
            }
        }

        private void AddToExpectedServices(uint[] services, uint[] hrs)
        {
            int[] indices;
            indices = XkdcUtilities.AddToArray(ref ExpectedServices, services);
            XkdcUtilities.AddToArrayNonunique(ref ExpectedHRs, hrs, indices);
        }

        protected void Fail(string format, params object[] args)
        {
            if (format != null)
                ro.Warn(format, args);
            ResultCode = TEST_RESULTS.FAILED;
            bRetVal = false;
            if (!this.bVerboseCheck)
                throw new UnexpectedTestResultException(string.Format(format, args));
        }

        /// <summary>
        /// The uber-verify function for validating result of XKDC sign in.  Please
        /// set the bVerify* members as appropriate to control what gets verified. 
        /// This will work for both Xbox and Xenon TGS requests.  Also note this
        /// used to be called ServiceResult, hence the 'sr' name.
        /// You are free to override this to provide your own verification routine.
        /// </summary>
        /// <param name="sr"></param>
        /// <returns></returns>
        public virtual bool Verify(XkdcResult sr)
        {
            bRetVal = true;

            // If call failed (XKDC timed out, etc), sr will be null
            if (sr == null)
            {
                if (!bExpectNoReply)
                    Fail("Expected to get a reply from the XKDC but instead got nothing");
                // Have to abort early, there's no result
                return bRetVal;
            }
            else if (bExpectNoReply)
            {
                Fail("Expected no reply from the XKDC but instead got one");
                return bRetVal;
            }

            // Overall request what we expected?
            if (sr.ServiceHR != ExpectedHR)
            {
                Fail("Overall request HResult failed, expected 0x{0:X} got 0x{1:X} for TitleId=0x{2:X}, Ver={3}, Region={4}", 
                    ExpectedHR, 
                    sr.ServiceHR,
                    authContext.TitleInfo.TitleId,
                    authContext.TitleInfo.TitleVersion,
                    authContext.TitleInfo.TitleGameRegion);
            }

            //verify the request and address preauths match (only check this if it was explicitely set for now; need to find a better way to handle the default 0 case in the future)
            if (authContext.IsXenonTitle && authContext.XenonPreauthVersion!=0)
            {
                if (authContext.TitleInfo.OverrideDefaultServiceRequest!=0 && authContext.TitleInfo.OverrideDefaultServiceRequestVersion==6) //could be 5 or 6
                {
                    if (!(sr.ServiceAddressPreauthVersion==5 || sr.ServiceAddressPreauthVersion==6))
                    {
                        throw new UnexpectedTestResultException("Expected ServiceAddress3 or ServiceAddressFailed back in response to ServiceRequest3V6.  ServiceAddressPreauthVersion="+sr.ServiceAddressPreauthVersion);
                    }
                }
                else
                {
                    ValueCheck.Test("Service Address Preauth version returned", authContext.XenonPreauthVersion, sr.ServiceAddressPreauthVersion);
                }
            }

            // Verify services and HResults in service result
            if (bVerifyServices)
            {
                VerifyServices(sr, ExpectedServices, ExpectedHRs);

                if (sr.NumServices != ExpectedServices.Length)
                {
                    bool spewServiceLists=true;
                    if (sr.NumServices < ExpectedServices.Length)
                    {
                        Fail("Too few services returned, expected {0}, got {1}", ExpectedServices.Length, sr.NumServices);
                    }
                    else if (sr.NumServices > ExpectedServices.Length && bTooManyServicesOk)
                    {
                        ro.Debug("Too many services returned, expected {0}, got {1} [OK]", ExpectedServices.Length, sr.NumServices);
                        spewServiceLists=false;
                    }
                    else
                    {
                        Fail("Too many services returned, expected {0}, got {1} [Not OK]", ExpectedServices.Length, sr.NumServices);
                    }

                    if (spewServiceLists)
                    {
                        System.Collections.Generic.List<uint> expectedList=new System.Collections.Generic.List<uint>();
                        System.Collections.Generic.List<uint> gotList=new System.Collections.Generic.List<uint>();
                        foreach (uint s in ExpectedServices)
                        {
                            if (s!=0)
                            {
                                expectedList.Add(s);
                            }
                        }

                        foreach (uint s in sr.ServiceIDs)
                        {
                            if (s!=0)
                            {
                                gotList.Add(s);
                            }
                        }

                        expectedList.Sort();
                        gotList.Sort();

                        ro.Warn("Expected services: "+StringUtils.MakeCommaSeparatedList(expectedList));
                        ro.Warn("Got services:      "+StringUtils.MakeCommaSeparatedList(gotList));
                    }
                }
            }

            // Loop through all users
            for (int userNum = 0; userNum < Users.Length; userNum++)
            {
                if (Users[userNum] == null)
                    continue;

                // Verify services in privilege array. Only Xenon TGS gets privilege array.
                if (bVerifyServices && bVerifyHRs && authContext.IsXenonTitle)
                {
                    if (sr.ServiceAddressPreauthVersion==4) //only XenonServiceAddress2 has service bits set in the user privileges
                    {
                        // The bit mask has been built in VerifyServices().  The following flags must be true for this to happen:
                        //   bVerifyServices
                        //   bVerifyHRs
                        VerifyServicePrivileges(sr, ExpectedServicesBitArray, userNum);
                    }
                }

                // Verify user privileges in privilege array. Only Xenon TGS gets privilege array.
                if (bVerifyPrivileges && authContext.IsXenonTitle)
                {
                    VerifyUserPrivileges(sr, Users[userNum].ExpectedPrivileges, userNum);
                }
            }

            // Verify machine privileges in privilege array. Only Xenon TGS gets privilege array.
            if (bVerifyPrivileges && authContext.IsXenonTitle)
            {
                VerifyMachinePrivileges(sr, ExpectedMachinePrivilegesBitArray);
            }

            // Verify authdata
            if (bVerifyAuthdata)
            {
                VerifyAuthdata(sr, authContext.TitleInfo);
            }

            // Verify user flags (membership tier)
            if (bVerifyUserFlags)
            {
                VerifyUserFlags(sr, this.Users);
            }

            // Verify user HRs
            if (bVerifyUserHRs)
            {
                VerifyUserHRs(sr, ExpectedUserHRs);
            }

            // Check may have failed but we supressed the exception
            return bRetVal;
        }

        private void VerifyServices(XkdcResult sr, uint[] ExpectedServices, uint[] ExpectedHRs)
        {
            // Verify services and service results
            // Loop through declared expected
            for (int j = 0; j < ExpectedServices.Length; j++)
            {
                bool bNotFound = true;
                // Loop through actual ones returned
                for (int i = 0; i < sr.ServiceIDs.Length; i++)
                {
                    if (sr.ServiceIDs[i] == 0)
                        continue;

                    // ServiceID
                    if (sr.ServiceIDs[i] == ExpectedServices[j])
                    {
                        // HResult
                        if (ExpectedHRs != null && bVerifyHRs && sr.ServiceHRs[i] != ExpectedHRs[j])
                        {
                            bool isEquivilent=false;
                            if ((sr.ServiceHRs[i]==2 && ExpectedHRs[j]==HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED) || (ExpectedHRs[j]==2 && sr.ServiceHRs[i]==HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED)) //2 in v5 is the same as E_LOGON_SERVICE_NOT_AUTHORIZED in v4
                            {
                                isEquivilent=true;
                            }

                            if (!isEquivilent)
                            {
                                Fail("Service {0}, got HR 0x{1:X}, expected 0x{2:X}", ExpectedServices[j], sr.ServiceHRs[i], ExpectedHRs[j]);
                            }
                        }
                        // If expecting this service but it didn't succeed, it won't be set in the services bit array.
                        // We need to remove it from our mask.
                        //if (ExpectedHRs != null && bVerifyHRs && sr.ServiceHRs[i] != 0
                        // Found the service, stop the inner loop
                        bNotFound = false;
                        break;
                    }
                }
                if (bNotFound)
                {
                    Fail("Expected to find service {0}", ExpectedServices[j]);
                }
            }

            //first result should never be 1.  the client checks this to prevent a possible infinite loop.
            //kerbclient mixes up the order right now, so we can't really check this
            /*if (sr.ServiceHRs.Length>=1 && sr.ServiceHRs[0]==1)
            {
                Fail("First service returned was hr=1.  This should NEVER happen.");
            }*/
        }

        private bool VerifyServicePrivilegesBits(BitArray ExpectedBitArray, uint []Gotten8DWords)
        {
            //for services, check 0-127
            bool ok=true;
            for (int serv=0; serv<128; ++serv)
            {
                int dword=serv/32;
                int bitNumber=serv%32;
                bool userBit=(Gotten8DWords[dword]&(1<<bitNumber))!=0;

                if (ExpectedBitArray.Get(serv)!=userBit)
                {
                    ok=false;
                    if (userBit)
                        Fail("Service bit "+serv+" was set but was not expected to.");
                    else
                        Fail("Service bit "+serv+" was NOT set but was expected to.");
                }
            }

            return ok;
        }

        private void VerifyServicePrivileges(XkdcResult sr, BitArray ExpectedBitArray, int UserNumber)
        {
            uint []userBits=new uint[8]; //evil C# doesn't let us pass one subarray of a 2D array, so copy it out
            for (int i=0; i<8; ++i)
                userBits[i]=sr.Privileges[UserNumber,i];

            if (!VerifyServicePrivilegesBits(ExpectedBitArray,userBits))
            {
                Fail("User "+this.Users[UserNumber].Name+" had service bit mismatched.");
            }
        }

        private bool VerifyPrivilegeBits(BitArray ExpectedBitArray, uint []Gotten8DWords)
        {
            //for privileges check 128-255
            bool ok=true;
            for (int priv=128; priv<256; ++priv)
            {
                int dword=priv/32;
                int bitNumber=priv%32;
                bool userBit=(Gotten8DWords[dword]&(1<<bitNumber))!=0;

                if (ExpectedBitArray.Get(priv)!=userBit)
                {
                    ok=false;
                    if (userBit)
                        Fail("Privilege bit "+priv+" was set but was not expected to be.");
                    else
                        Fail("Privilege bit "+priv+" was NOT set but was expected to.");
                }
            }

            return ok;
        }

        private void VerifyUserPrivileges(XkdcResult sr, uint[] ExpectedPrivileges, int UserNumber)
        {
            BitArray expectedBitArray=new BitArray(256);
            foreach (uint priv in ExpectedPrivileges)
            {
                expectedBitArray.Set((int)priv,true);
            }

            int startDword=0;
            if (sr.ServiceAddressPreauthVersion==5) //v5 only uses 3 dwords for this
            {
                startDword=5;
            }

            uint []userBits=new uint[8]; //evil C# doesn't let us pass one subarray of a 2D array, so copy it out
            for (int i=startDword; i<8; ++i)
                userBits[i]=sr.Privileges[UserNumber,i];

            if (!VerifyPrivilegeBits(expectedBitArray,userBits))
            {
                bPrivBitsNoMatch = true;

                Fail("User "+this.Users[UserNumber].Name+" had mismatched privilege bits");
            }
        }

        private void VerifyMachinePrivileges(XkdcResult sr, BitArray ExpectedPrivileges)
        {
            //machine privileges are duplicated to all users in the kerbclient service context, so just grab the dword from the first user
            uint []machineBits=new uint[8];
            machineBits[4]=sr.Privileges[0,4];
            if (!VerifyPrivilegeBits(ExpectedPrivileges, machineBits))
            {
                bPrivBitsNoMatch = true;

                Fail("Machine "+string.Format("0x{0:X}",sr.MachinePuid)+" had mismatched privilege bits");
            }
        }

        private void VerifyUserFlags(XkdcResult sr, UserInfo[] users)
        {
            // dwUserFlags (tier bits)
            // When a user logs on to the XKDC, there is a dwUserFlags field (4 bytes) returned for each user.  It contains the following:
            //
            //Byte 0:
            //Bits 0-1: guest number                        { as calculated by XKDC }
            //Bits 2-4: no show rating                      { as calculated by XKDC }
            //Bits 5-7: disconnect rating                   { as calculated by XKDC }
            //
            //Byte 1:
            //Bits 8-15: country id                         { from country field in t_users }
            //
            //Byte 2:
            //Bit 16: user voice not allowed flag           { as calculated by XKDC }
            //Bit 17: user purchase not allowed flag        { from si_ticket_flags in t_users }
            //Bit 18: user nickname not allowed flag        { from si_ticket_flags in t_users }
            //Bit 19: user shared content not allowed flag  { from si_ticket_flags in t_users }
            //Bits 20-23: user's tier id                    { as calculated by XKDC, this is new }
            //
            //Byte 3:
            //Bit 24: Account has parent-child relationship { calculated by XKDC, owner puid different in t_users }
            //Bits 25-31: unknown                           { from si_ticket_flags in t_users }
            //

            // We are going to verify the user's tier id only...... for now
            //

            for (int i = 0; i < users.Length; i++)
            {
                if (users[i] == null)
                    continue;

                uint tier = UserFlagsUtil.UserTierId(sr.UserFlags[i]);
                if (authContext.IsXenonTitle)
                {
                    if (users[i].Tier==0)
                    {
                        if (tier!=0)
                        {
                            Fail("UserFlags[{0}] for user {1} says tier is {2}, should be real tier 0)",
                                i,
                                users[i].Name,
                                tier);
                        }
                    }
                    else if (tier != Expectations.k_IdxToTierId[users[i].Tier - 1])
                    {
                        Fail("UserFlags[{0}] for user {1} says tier is {2}, should be real tier {3} (user tier {4})",
                            i,
                            users[i].Name,
                            tier,
                            Expectations.k_IdxToTierId[users[i].Tier - 1],
                            users[i].Tier);
                    }
                }
            }
        }

        private void VerifyUserHRs(XkdcResult sr, uint[] ExpectedUserHRs)
        {
            if (ExpectedUserHRs == null)
            {
                throw new UnexpectedTestResultException("You should probably provide a non-null ExpectedUserHRs if you want to verify them");
            }
            for (int i = 0; i < ExpectedUserHRs.Length; i++)
            {
                if (i >= sr.UserHRs.Length)
                    break;
                if (sr.UserHRs[i] != ExpectedUserHRs[i])
                {
                    Fail("UserHRs[{0}] for user {1} is 0x{2:X}, expected 0x{3:X}",
                        i,
                        (Users==null?"(no users)":(Users[i]==null?"(null user)":Users[i].Name)),
                        sr.UserHRs[i],
                        ExpectedUserHRs[i]);
                }
            }
        }

        private void VerifyAuthdata(XkdcResult sr, XeTitleInfo ti)
        {
            // Common fields
            uint                    dwTitleID = 0;
            uint                    dwTitleVersion = 0;
            uint                    dwTitleRegion = 0;
            ulong                   qwXboxID = 0;
            XUserID[]               users;

            // Version
            if (ExpectedADVersion == 2 && !(sr.authData is Authdata_Xbox2) ||
                ExpectedADVersion == 3 && !(sr.authData is Authdata_Xenon) ||
                ExpectedADVersion == 4 && !(sr.authData is Authdata_Xenon2))
            {
                Fail("Got wrong authdata version, expected {0}. DefaultPreAuthVer={1}", ExpectedADVersion, DefaultXkdcXenonPreauthVersion);
            }

            if (sr.authData == null)
            {
                throw new Exception("No authdata present in service result, can't verify");
            }

            //
            // Authdata4 stuff
            //
            if (typeof(Authdata_Xenon2) == sr.authData.GetType())
            {
                if (sr.authData.wAuthDataVersion != 4)
                {
                    Fail("Authdata4: wAuthDataVersion is {0}", sr.authData.wAuthDataVersion);
                }

                Authdata_Xenon2 ad = (Authdata_Xenon2)sr.authData;

                // A console can be either devkit or retail kit
                // Plus it can be either testkit or regular
                // A xenon console may be backcompat
                // Console type is based on machine puid, not authdataflags, except for 
                // the above checks.
                uint expectedFlags = 0;
                ulong expectedBasePuid = 0;

                // Build expected dwAuthDataFlags field
                if (authContext.IsXenonConsole)
                {
                    expectedFlags |= Authdata_Xenon.FLAGS_ISXENON;  // legacy, not required
                    if (authContext.ConsoleCert.IsDev)
                        expectedFlags |= Authdata_Xenon.FLAGS_ISDEVKIT;
                    if (authContext.ConsoleCert.IsTestkit)
                        expectedFlags |= Authdata_Xenon.FLAGS_ISTESTKIT;
                }
                if (authContext.ClientType == AuthContext.ClientTypes.XenonBackCompat)
                    expectedFlags |= Authdata_Xenon.FLAGS_ISXENONBACKCOMPAT;

                if (authContext.IsPCLimited) //panorama limited machine account
                    expectedFlags |= Authdata_Xenon.FLAGS_ISLIMITEDMACHINE;

                // Check dwAuthDataFlags 
                if (ad.dwAuthDataFlags != expectedFlags)
                {
                    string consType;
                    if (authContext.IsPanorama) consType="PC";
                    else if (authContext.IsXenonConsole) consType=string.Format("0x3:X",authContext.ConsoleCert.ConsoleType);
                    else consType="???";

                    Fail("Authdata4: dwAuthDataFlags expected 0x{0:X}, got 0x{1:X} for client type {2}, console type {3}",
                         expectedFlags,
                         ad.dwAuthDataFlags,
                         authContext.ClientType,
                         consType);
                }

                // Set expected machine puids based on client type
                if (authContext.ClientType == AuthContext.ClientTypes.Xbox)
                    expectedBasePuid = 0x0009000000000000;
                if (authContext.ClientType == AuthContext.ClientTypes.Xenon)
                    expectedBasePuid = 0xFA00000000000000;
                if (authContext.ClientType == AuthContext.ClientTypes.XenonBackCompat)
                    expectedBasePuid = 0xFA00000000000000;
                if (authContext.ClientType == AuthContext.ClientTypes.Panorama)
                    expectedBasePuid = 0xFB00000000000000;

                // Check machine puid
                if ((ad.qwXboxID & 0xFFFF000000000000) != expectedBasePuid)
                {
                    Fail("Authdata4: qwXboxID base puid expected 0x{0:X}, got puid 0x{1:X} for client type {2}",
                         expectedBasePuid,
                         ad.qwXboxID,
                         authContext.ClientType);
                }

                // Privilege bits what we expect?  This is only set for Xenon clients
                if (authContext.IsXenonTitle)
                {
                    // Suppress if we already displayed a similar error
                    if (!bPrivBitsNoMatch && bVerifyPrivileges)
                    {
                        //user privileges
                        for (int user=0; user<4; ++user)
                        {
                            if (Users[user]!=null)
                            {
                                if (!VerifyPrivilegeBits(Users[user].ExpectedPrivilegesBitArray, ad.GetPrivileges((uint)user)))
                                {
                                    Fail("Authdata4 privileges bits don't match for user "+user+".");
                                }
                            }
                            else //should be all 0 for no user
                            {
                                if (!VerifyPrivilegeBits(new System.Collections.BitArray(256, false), ad.GetPrivileges((uint)user)))
                                {
                                    Fail("Authdata4 privileges bits don't match for empty user "+user+".");
                                }
                            }
                        }

                        //machine privileges
                        if (!VerifyPrivilegeBits(ExpectedMachinePrivilegesBitArray, ad.GetMachinePrivileges()))
                        {
                            Fail("Authdata4 privileges bits don't match for the machine.");
                        }
                    }
                }

                // Service bits what we expect?
                if (bVerifyServices && !VerifyServicePrivilegesBits(ExpectedServicesBitArray, ad.GetServices()))
                {
                    Fail("Authdata4: service bits don't match");
                }
                else if (bVerifyServices)
                {
                    // DWORD services what we epect?
                    // First build list of DWORD services from input
                    uint[] dwordServices = new uint[4];
                    int numDwordServices = 0;
                    for (int i = 0; i < this.ExpectedServices.Length; i++)
                    {
                        if (this.ExpectedServices[i] >= 256 && this.ExpectedHRs[i] == 0)
                            dwordServices[numDwordServices++] = this.ExpectedServices[i];
                    }
                    // Then compare
                    if ((int)ad.wNumExtendedServices != numDwordServices)
                    {
                        Fail("Authdata4: number of dword services doesn't match, expected {0}, got {1}", numDwordServices, ad.wNumExtendedServices);
                    }
                    else
                    {
                        // Check each service
                        int i, j;
                        for (i = 0; i < numDwordServices; i++)
                        {
                            for (j = 0; j < ad.wNumExtendedServices; j++)
                            {
                                if (ad.dwExtendedServices[j] == dwordServices[i])
                                    break;
                            }
                            if (j == ad.wNumExtendedServices)
                            {
                                Fail("Authdata4: failed to find expected dword service id {0} in authdata", dwordServices[i]);
                            }
                        }
                    }
                }

                // Pull out common stuff
                dwTitleID = ad.dwTitleID;
                dwTitleVersion = ad.dwTitleVersion;
                dwTitleRegion = ad.dwTitleRegion;
                qwXboxID = ad.qwXboxID;
                users = ad.users;
            }

            //
            // Authdata3 stuff
            //
            else if (typeof(Authdata_Xenon) == sr.authData.GetType())
            {
                if (sr.authData.wAuthDataVersion != 3)
                {
                    Fail("Authdata3: wAuthDataVersion is {0}", sr.authData.wAuthDataVersion);
                }

                Authdata_Xenon ad = (Authdata_Xenon)sr.authData;

                // A console can be either devkit or retail kit
                // Plus it can be either testkit or regular
                // A xenon console may be backcompat
                // Console type is based on machine puid, not authdataflags, except for 
                // the above checks.
                uint expectedFlags = 0;
                ulong expectedBasePuid = 0;

                // Build expected dwAuthDataFlags field
                if (authContext.IsXenonConsole)
                {
                    expectedFlags |= Authdata_Xenon.FLAGS_ISXENON;  // legacy, not required
                    if (authContext.ConsoleCert.IsDev)
                        expectedFlags |= Authdata_Xenon.FLAGS_ISDEVKIT;
                    if (authContext.ConsoleCert.IsTestkit)
                        expectedFlags |= Authdata_Xenon.FLAGS_ISTESTKIT;
                }
                if (authContext.ClientType == AuthContext.ClientTypes.XenonBackCompat)
                    expectedFlags |= Authdata_Xenon.FLAGS_ISXENONBACKCOMPAT;

                if (authContext.IsPCLimited) //panorama limited machine account
                    expectedFlags |= Authdata_Xenon.FLAGS_ISLIMITEDMACHINE;

                // Check dwAuthDataFlags 
                if (ad.dwAuthDataFlags != expectedFlags)
                {
                    string consType;
                    if (authContext.IsPanorama) consType="PC";
                    else if (authContext.IsXenonConsole) consType=string.Format("0x3:X",authContext.ConsoleCert.ConsoleType);
                    else consType="???";

                    Fail("Authdata3: dwAuthDataFlags expected 0x{0:X}, got 0x{1:X} for client type {2}, console type {3}",
                         expectedFlags,
                         ad.dwAuthDataFlags,
                         authContext.ClientType,
                         consType);
                }

                // Set expected machine puids based on client type
                if (authContext.ClientType == AuthContext.ClientTypes.Xbox)
                    expectedBasePuid = 0x0009000000000000;
                if (authContext.ClientType == AuthContext.ClientTypes.Xenon)
                    expectedBasePuid = 0xFA00000000000000;
                if (authContext.ClientType == AuthContext.ClientTypes.XenonBackCompat)
                    expectedBasePuid = 0xFA00000000000000;
                if (authContext.ClientType == AuthContext.ClientTypes.Panorama)
                    expectedBasePuid = 0xFB00000000000000;

                // Check machine puid
                if ((ad.qwXboxID & 0xFFFF000000000000) != expectedBasePuid)
                {
                    Fail("Authdata3: qwXboxID base puid expected 0x{0:X}, got puid 0x{1:X} for client type {2}",
                         expectedBasePuid,
                         ad.qwXboxID,
                         authContext.ClientType);
                }

                // Privilege bits what we expect?  This is only set for Xenon clients
                if (authContext.IsXenonTitle)
                {
                    // Suppress if we already displayed a similar error
                    if (!bPrivBitsNoMatch && bVerifyPrivileges)
                    {
                        if (!VerifyPrivilegeBits(ExpectedAD3PrivilegesBitArray, ad.dwPrivileges))
                        {
                            Fail("Authdata3 privileges bits don't match.");
                        }
                    }
                }

                // Service bits what we expect?
                if (bVerifyServices && !VerifyServicePrivilegesBits(ExpectedServicesBitArray, ad.dwPrivileges))
                {
                    Fail("Authdata3: service bits don't match");
                }
                else if (bVerifyServices)
                {
                    // DWORD services what we epect?
                    // First build list of DWORD services from input
                    uint[] dwordServices = new uint[4];
                    int numDwordServices = 0;
                    for (int i = 0; i < this.ExpectedServices.Length; i++)
                    {
                        if (this.ExpectedServices[i] >= 128 && this.ExpectedHRs[i] == 0)
                            dwordServices[numDwordServices++] = this.ExpectedServices[i];
                    }
                    // Then compare
                    if ((int)ad.wNumDwordServices != numDwordServices)
                    {
                        Fail("Authdata3: number of dword services doesn't match, expected {0}, got {1}", numDwordServices, ad.wNumDwordServices);
                    }
                    else
                    {
                        // Check each service
                        int i, j;
                        for (i = 0; i < numDwordServices; i++)
                        {
                            for (j = 0; j < ad.wNumDwordServices; j++)
                            {
                                if (ad.dwServiceID[j] == dwordServices[i])
                                    break;
                            }
                            if (j == ad.wNumDwordServices)
                            {
                                Fail("Authdata3: failed to find expected dword service id {0} in authdata", dwordServices[i]);
                            }
                        }
                    }
                }

                // Pull out common stuff
                dwTitleID = ad.dwTitleID;
                dwTitleVersion = ad.dwTitleVersion;
                dwTitleRegion = ad.dwTitleRegion;
                qwXboxID = ad.qwXboxID;
                users = ad.users;
            }

            //
            // Authdata2 stuff
            //
            else if (typeof(Authdata_Xbox2) == sr.authData.GetType())
            {
                if (sr.authData.wAuthDataVersion != 2)
                {
                    Fail("Authdata2: wAuthDataVersion is {0}", sr.authData.wAuthDataVersion);
                }
                Authdata_Xbox2 ad = (Authdata_Xbox2)sr.authData;

                // Verify services
                if (bVerifyServices)
                {
                    if (ad.dwNumServices != sr.NumValidServices)
                    {
                        Fail("Authdata2: Number of services mismatched, authdata says {0} but service result says {1}", ad.dwNumServices, sr.NumServices);
                    }
                    else if (ad.dwNumServices > 12 || sr.NumServices > 12)
                    {
                        Fail("Authdata2: Max number of services is 12, but authdata says {0} and service result says {1}", ad.dwNumServices, sr.NumServices);
                    }
                    else
                    {
                        int i, j;
                        for (i = 0; i < sr.NumServices; i++)
                        {
                            // We only want to look for successfully granted services in 
                            // the authdata; if the service wasn't granted, then just 
                            // continue on.
                            if (sr.ServiceHRs[i] != 0)
                                continue;

                            for (j = 0; j < ad.dwNumServices; j++)
                            {
                                if (ad.dwServiceID[j] == sr.ServiceIDs[i])
                                    break;
                            }
                            if (j == ad.dwNumServices)
                            {
                                Fail("Authdata2: failed to find expected service id {0} in authdata", sr.ServiceIDs[i]);
                            }
                        }
                    }
                }

                // Pull out common stuff
                dwTitleID = ad.dwTitleID;
                dwTitleVersion = ad.dwTitleVersion;
                dwTitleRegion = ad.dwTitleRegion;
                qwXboxID = ad.qwXboxID;
                users = ad.users;
            }

            //
            // Common stuff
            //
            if (sr.authData != null)
            {
                // Title stuff
                if (ti.TitleId != dwTitleID ||
                    ti.TitleVersion != dwTitleVersion ||
                    ti.TitleGameRegion != dwTitleRegion)
                {
                    Fail("Authdata: title doesn't match, id=0x{0:X}, version={1}, region={2}, expected (0x{3:X},{4},{5})",
                        dwTitleID, dwTitleVersion, dwTitleRegion,
                        ti.TitleId, ti.TitleVersion, ti.TitleGameRegion);
                }
                // Machine puid 
                ulong requestPuid = authContext.UsersMachine.xuid.qwUserID;
                if ( requestPuid != qwXboxID)
                {
                    Fail("Authdata: machine puid, got 0x{0:X}, expected 0x{1:X}", qwXboxID, requestPuid);
                }

                // TODO: can we verify the user PUIDS?
            }

            if (!bRetVal)
            {
                ro.Debug(sr.ToString(true));
            }

        }

        public void ClearUsers()
        {
            for (int i = 0; i < Users.Length; i++)
            {
                Users[i] = null;
            }
            if (authContext != null)
            {
                authContext.ClearUsers();
            }
        }

        /// <summary>
        /// Add a user with given name
        /// </summary>
        /// <param name="username"></param>
        /// <returns></returns>
        public UserInfo SetUser(string username) { return SetUser(username, 0); }
        public UserInfo SetUser(string username, int slot)
        {
            if (slot < 0 || slot >= 4)
                return null;
            if (username == null)
                Users[slot] = null;
            else
                Users[slot] = new UserInfo(username);
            authContext.SetUser(username, slot);
            if (username != null)
                authContext.Users[slot].Key = Users[slot].GetKey(authContext.ClientType);
            return Users[slot];
        }

        public UserInfo SetUser(UserInfo user, int slot)
        {
            if (slot < 0 || slot >= 4)
                return null;
            Users[slot] = user;
            authContext.SetUser(user.Name, slot);
            if (user != null)
                authContext.Users[slot].Key = Users[slot].GetKey(authContext.ClientType);
            return Users[slot];
        }

        /// <summary>
        /// Adapt a UACS user to one of our KDC test users
        /// </summary>
        public UserInfo SetUser(ServerTestFramework.LiveService.UserAccount.XeUser user, int slot)
        {
            if (slot < 0 || slot >= 4)
                return null;
            Users[slot] = new UserInfo(
                user.Gamertag, 
                (user.IsSilverTier) ? 1 : 2, // 1=silver, 2=gold
                0); //no default title
            Users[slot].RawXboxKey = Hexer.tohex(user.m_response.XboxKey);
            Users[slot].RawXenonKey = Hexer.tohex(user.m_response.XenonKey);

            // By using the XeUser object, AuthContext will set the key for us
            authContext.SetUser(user, slot);
            return Users[slot];
        }

        /// <summary>
        /// Adapt a newer KDC user to one of our KDC test users
        /// </summary>
        public UserInfo SetUser(KdcUser user, int slot)
        {
            if (slot < 0 || slot >= 4)
                return null;
            Users[slot] = new UserInfo(
                user.Gamertag, 
                2, // 1=silver, 2=gold //TODO: get this from somewhere real... for now just saying gold 
                0); //no default title
            Users[slot].RawXboxKey = Hexer.tohex(user.XboxKey);
            Users[slot].RawXenonKey = Hexer.tohex(user.XenonKey);

            // By using the KdcUser object, AuthContext will set the key for us
            authContext.SetUser(user, slot);
            return Users[slot];
        }

        /// <summary>
        /// checks if we were given specific service result
        /// </summary>
        public bool WasServiceOffered(uint serviceNum, out uint status)
        {
            status=0xffffffff; //invalid

            for (uint i=0; i<result.ServiceIDs.Length; ++i)
            {
                if (result.ServiceIDs[i]==serviceNum)
                {
                    status=result.ServiceHRs[i];
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// checks if we were given a specific privilege
        /// </summary>
        public bool WasPrivelegeOffered(uint privilege, uint userSlot)
        {
            uint whichDword=privilege/32;
            uint whichBit=privilege%32;
            return (result.Privileges[userSlot, whichDword] & (1<<(int)whichBit)) != 0;
        }

        public uint[] GetUserPrivileges(uint slot)
        {
            System.Collections.Generic.List<uint> privs=new System.Collections.Generic.List<uint>();
            for (int i=128; i<256; ++i)
            {
                if (WasPrivelegeOffered((uint)i, slot))
                {
                    privs.Add((uint)i);
                }
            }

            return privs.ToArray();
        }

        protected void PrintPrivileges()
        {
            for (int u=0; u<4; ++u)
            {
                if (Users[u]!=null)
                {
                    uint []privs=GetUserPrivileges((uint)u);
                    Global.RO.Debug("Privileges in slot "+u+"("+Users[u].Name+"): "+StringUtils.MakeCommaSeparatedList(privs));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonAuthdata.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace XkdcTest
{
    /// <summary>
    /// Xenon-specific tests go here.  Remember, all previous test cases will also be run as Xenon clients.
    /// Test various site-related cases, especially services behind legacy sites.
    /// </summary>

    // Extend base class to set defaults for entire test group
    abstract public class TestBase_Xenon_AuthData : TestBase_Xkdc
    {
        public override void SetDefaults()
        {
            base.SetDefaults();
            // This title is tied to the offer for services 8006,8007,8008,8009,8010,8011,
            // which include some services we need for this test.  See t_title_offers
            authContext.SetTitle(0x3EEF0821, 1, 1);
            bVerifyAuthdata = true;
        }

        protected void Go_AuthDataFlags(uint consoleType, AuthContext.ClientTypes clientType)
        {
            ClientType = clientType;
            SetDefaults();
            XmacsClient.SetDefaults(authContext);
            authContext.ConsoleCert.SetConsoleType(consoleType);
            SetUser("xktduusert2a", 0);
            SignInXkdc(true);
        }
    }

    [TestGroup]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XenonAuthdata : XkdcTestBaseGroup
    {
        public XenonAuthdata()
            : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }

        [TestCase, Description("Basic AuthData4 version test, as Xenon with autodiscover")]
        class AuthdataVersion4AsXenon : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyServices = false;  // in case auto-discover finds something new and problematic
                bVerifyPrivileges = false;
                ExpectedADVersion = (uint)(DefaultXkdcXenonPreauthVersion>=5?4:3); //old preauth will get old authdata still
                SetUser("xktuser7a", 0);
                SignInXkdc();
                ro.Debug(this.result.ToString(true));
            }
        }


        [TestCase, Description("Basic AuthData3 version test, as Xenon with autodiscover")]
        class AuthdataVersion3AsXenon : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyServices = false;  // in case auto-discover finds something new and problematic
                bVerifyPrivileges = false;
                ExpectedServices = new uint[] { 8001 };
                ExpectedHRs = new uint[] { 0 };
                ExpectedADVersion = 3; //this site is configured for v3 always
                SetUser("xktuser7a", 0);
                SignInXkdc();
                ro.Debug(this.result.ToString(true));
            }
        }

        [TestCase, Description("AuthData2 version test, for services behind legacy sites, as Xenon")]
        class AuthdataVersion2AsXenon : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 8010 };
                ExpectedHRs = new uint[] { 0 };
                bVerifyPrivileges = false;
                ExpectedADVersion = 2;
                SetUser("xktsuball", 0);
                SignInXkdc();
                ro.Debug(this.result.ToString(true));
            }
        }

        [TestCase, Description("AuthData version test: 1 service behind site with authdata3, 1 behind authdata2 site")]
        class AuthdataVersionMixedAsXenon_V3 : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyPrivileges = false;
                SetUser("xktsuball", 0);

                ExpectedServices = new uint[] { 8008, 8010 };
                ExpectedHRs = new uint[] { 0, 1 };
                ExpectedADVersion = 3;
                authContext.ClearXkdc();
                SignInXkdc();
            }
        }

        [TestCase, Description("AuthData version test: 1 service behind site with authdata3, 1 behind authdata2 site")]
        class AuthdataVersionMixedAsXenon_V3Inverse : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyPrivileges = false;
                SetUser("xktsuball", 0);

                ExpectedServices = new uint[] { 8010, 8008 };
                ExpectedHRs = new uint[] { 1, 0 };
                ExpectedADVersion = 3;
                authContext.ClearXkdc();
                SignInXkdc();
            }
        }

        [TestCase, Description("AuthData version test: 1 service behind site with authdata3, 1 behind authdata2 site")]
        class AuthdataVersionMixedAsXenon_V2 : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyPrivileges = false;
                SetUser("xktsuball", 0);

                ExpectedServices = new uint[] { 8010, 8011 };
                ExpectedHRs = new uint[] { 0, 1 };
                ExpectedADVersion = 2;
                authContext.ClearXkdc();
                SignInXkdc();
            }
        }

        [TestCase, Description("AuthData version test: 1 service behind site with authdata3, 1 behind authdata2 site")]
        class AuthdataVersionMixedAsXenon_V2Inverse : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyPrivileges = false;
                SetUser("xktsuball", 0);

                ExpectedServices = new uint[] { 8011, 8010 };
                ExpectedHRs = new uint[] { 1, 0 };
                ExpectedADVersion = 2;
                authContext.ClearXkdc();
                SignInXkdc();
            }
        }

        [TestCase, Description("AuthData fields test: consoleRegion, mediaID, languageID")]
        class AuthdataXenonFields : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                uint console = 1;
                uint media = 2;
                ushort language = 3;
                authContext.ServiceCtxXe.dwConsoleRegion = console;
                authContext.ServiceCtxXe.dwMediaID = media;
                authContext.ServiceCtxXe.wLanguageID = language;
                SetUser("xktusert2a", 0);
                SignInXkdc();

                if (result.authData!=null)
                {
                    Authdata_Base ad = result.authData;
                    if (ad.ConsoleRegion != console ||
                        ad.MediaID != media ||
                        ad.LanguageID != language)
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Warn("AuthData3: consoleRegion={0}, mediaID={1}, languageID={2}, expected ({3},{4},{5})",
                            ad.ConsoleRegion,
                            ad.MediaID,
                            ad.LanguageID,
                            console,
                            media,
                            language);
                    }
                }
            }
        }

        // This depends on service 129 being propped to the UODB, currently it is not
        [TestCase, Ignore, Description("Verify service id > 32 and < 256 works")]
        class Authdata_ServiceId129 : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyServices = true;
                ExpectedServices = new uint[] { 129 };
                ExpectedHRs = new uint[] { 0 };
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase(BugID = 42192, BugDatabase = "Xenon")]
        class Authdata_Authdata3Site_VerifySessionKeyNotZero : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyServices = true;

                // Use auto-discover
                SetUser("xktduusert2a", 0);
                ExpectedServices = new uint[] { 8001 };
                ExpectedHRs = new uint[] { 0 };
                ExpectedADVersion = 3;
                SignInXkdc(false);
                Authdata_Base site1ad = authContext.Authdata;

                // Check the key
                int zerocount = 0;
                for (int i = 0; i < site1ad.Key.Length; i++)
                {
                    if (site1ad.Key[i] == 0)
                    {
                        zerocount++;
                    }
                }
                if (zerocount == site1ad.Key.Length)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase]
        class Authdata_Authdata4Site_VerifySessionKeyNotZero : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyServices = true;
                ExpectedADVersion = (uint)(DefaultXkdcXenonPreauthVersion>=5?4:3); //old preauth will get old authdata still;

                // Use auto-discover
                SetUser("xktduusert2a", 0);
                SignInXkdc(true);
                Authdata_Base site1ad = authContext.Authdata;

                // Check the key
                int zerocount = 0;
                for (int i = 0; i < site1ad.Key.Length; i++)
                {
                    if (site1ad.Key[i] == 0)
                    {
                        zerocount++;
                    }
                }
                if (zerocount == site1ad.Key.Length)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Ticket should have the same key for titleid/titleversion/machinepuid combination")]
        class Authdata_DualSite_VerifySessionKey : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                bVerifyServices = true;

                // Use auto-discover
                SetUser("xktduusert2a", 0);
                SignInXkdc(true);
                Authdata_Base site1ad = authContext.Authdata;

                // Specifically request a service from site2.  We should probably automate
                // this.. hard-coded for now.  Leave user TGT, just clear XKDC results.
                authContext.ClearXkdc();
                XkdcClient.SetDefaults(authContext);
                ExpectedServices = new uint[] { 15 }; //BUGCHECK: This isn't currently on site2... is this test still valid?
                ExpectedHRs = new uint[] { 0 };
                SignInXkdc(false);
                Authdata_Base site2ad = authContext.Authdata;

                ro.Debug("Site1: machinepuid=0x{0:X}, dwTitleId=0x{1:X}, key=0x{2}",
                    site1ad.XboxID,
                    site1ad.TitleId,
                    Hexer.tohex(site1ad.Key));
                ro.Debug("Site2: machinepuid=0x{0:X}, dwTitleId=0x{1:X}, key=0x{2}",
                    site2ad.XboxID,
                    site2ad.TitleId,
                    Hexer.tohex(site2ad.Key));

                // Compare the keys
                for (int i = 0; i < site1ad.Key.Length; i++)
                {
                    if (site1ad.Key[i] != site2ad.Key[i])
                    {
                        ro.Warn("Site1 key 0x{0} and Site2 key 0x{1} don't match.",
                            Hexer.tohex(site1ad.Key),
                            Hexer.tohex(site2ad.Key));
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        [TestCase(BugID = 67883, BugDatabase = "Xenon"), Description("dwAuthdataFlags: Devkit")]
        class AuthdataFlags_Dev : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                Go_AuthDataFlags(ConsoleCertificate.CONSOLE_TYPE_DEV, AuthContext.ClientTypes.Xenon);
            }
        }

        [TestCase, Description("dwAuthdataFlags: Retail kit")]
        class AuthdataFlags_Retail : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                Go_AuthDataFlags(ConsoleCertificate.CONSOLE_TYPE_RETAIL, AuthContext.ClientTypes.Xenon);
            }
        }

        [TestCase(BugID = 67883, BugDatabase = "Xenon"), Description("dwAuthdataFlags: Testkit as dev")]
        class AuthdataFlags_TestkitDev : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                Go_AuthDataFlags(ConsoleCertificate.CONSOLE_TYPE_DEV | ConsoleCertificate.CONSOLE_TYPE_TESTKIT, AuthContext.ClientTypes.Xenon);
            }
        }

        [TestCase, Description("dwAuthdataFlags: Testkit as retail")]
        class AuthdataFlags_TestkitRetail : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                Go_AuthDataFlags(ConsoleCertificate.CONSOLE_TYPE_RETAIL | ConsoleCertificate.CONSOLE_TYPE_TESTKIT, AuthContext.ClientTypes.Xenon);
            }
        }

        [TestCase(BugID = 67883, BugDatabase = "Xenon"), Description("dwAuthdataFlags: Devkit")]
        class AuthdataFlags_Dev_Fusion : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                Go_AuthDataFlags(ConsoleCertificate.CONSOLE_TYPE_DEV, AuthContext.ClientTypes.XenonBackCompat);
            }
        }

        [TestCase, Description("dwAuthdataFlags: Retail kit")]
        class AuthdataFlags_Retail_Fusion : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                Go_AuthDataFlags(ConsoleCertificate.CONSOLE_TYPE_RETAIL, AuthContext.ClientTypes.XenonBackCompat);
            }
        }

        [TestCase(BugID = 67883, BugDatabase = "Xenon"), Description("dwAuthdataFlags: Testkit as dev")]
        class AuthdataFlags_TestkitDev_Fusion : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                Go_AuthDataFlags(ConsoleCertificate.CONSOLE_TYPE_DEV | ConsoleCertificate.CONSOLE_TYPE_TESTKIT, AuthContext.ClientTypes.XenonBackCompat);
            }
        }

        [TestCase, Description("dwAuthdataFlags: Testkit as retail")]
        class AuthdataFlags_TestkitRetail_Fusion : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                Go_AuthDataFlags(ConsoleCertificate.CONSOLE_TYPE_RETAIL | ConsoleCertificate.CONSOLE_TYPE_TESTKIT, AuthContext.ClientTypes.XenonBackCompat);
            }
        }

        // Beta bit in auth data
        [TestCase, Description("Machine is in a system beta.  The bit currently just indicates whether the machine is in a group or not.")]
        class Authdata_BetaBit_SystemBeta : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                AuthContext ctx = new AuthContext(AuthContext.ClientTypes.Xenon);
                XmacsClient xmacs = new XmacsClient(ctx, null, null, true);
                XmacsClient.SetDefaults(ctx);
                xmacs.SignInXmacs();

                BetaGroupEditor bgeFlash0=BetaGroupEditor.FromId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000000"));
                bgeFlash0.AddMachine(xmacs.MachinePuid);

                XkdcClient xkdc = new XkdcClient(ctx, null, true);
                XkdcClient.SetDefaults(ctx);

                // Test system mask
                ctx.SetTitle(0xc0fe0800, 1, 1); //specifically pick the non-dash, as it should be set even if we're not on the dash
                xkdc.SignInXkdc();
                if ((ctx.GetXkdcResult().authData.AuthDataFlags & Authdata_Xenon.FLAGS_ISBETAMACHINE) == 0)
                {
                    throw new System.Exception("Beta bit is not present in auth data");
                }
            }
        }

        [TestCase, Description("Machine is in a title beta.  The bit currently just indicates whether the machine is in a group or not.")]
        class Authdata_BetaBit_Title : TestBase_Xenon_AuthData
        {
            override protected void RunTest()
            {
                AuthContext ctx = new AuthContext(AuthContext.ClientTypes.Xenon);
                XmacsClient xmacs = new XmacsClient(ctx, null, null, true);
                XmacsClient.SetDefaults(ctx);
                xmacs.SignInXmacs();

                BetaGroupEditor bgeTitle0=BetaGroupEditor.FromId(new System.Guid("BE7ABE7A-7E57-C0DE-F00D-000000000010"));
                bgeTitle0.AddMachine(xmacs.MachinePuid);

                XkdcClient xkdc = new XkdcClient(ctx, null, true);
                XkdcClient.SetDefaults(ctx);

                // Test matching title
                ctx.SetTitle(0x1337FF00, 40, 1);
                xkdc.SignInXkdc();
                if ((ctx.GetXkdcResult().authData.AuthDataFlags & Authdata_Xenon.FLAGS_ISBETAMACHINE) == 0)
                {
                    throw new System.Exception("Beta bit is not present in auth data");
                }

                // Test nonmatching title
                ctx.SetTitle(0x3EEF0800, 1, 1);
                xkdc.SignInXkdc();
                if ((ctx.GetXkdcResult().authData.AuthDataFlags & Authdata_Xenon.FLAGS_ISBETAMACHINE) == 0)
                {
                    throw new System.Exception("Beta bit is not present in auth data");
                }
            }
        }
    }


    //todo: we will revisit these when we decide to seriously finish implementing AuthData V4
    /*[TestGroup, Owner("BenRan"), TestFrequency("Daily")]
    public class Xenon2AuthData : TestNode
    {
        [TestCase, Description("Simple BVT test to see if we get the correct authdata version back with a single user and client"), TestCasePriority(1)]
        public class BVT : TestBase_KdcClient
        {
            public override void Run()
            {
                CreateClient();
                CreateUser("xktad4a");

                SignInAll();
                AuthenticateXkdc();

                ValueCheck.TestNotNull("Xenon2AuthData", Client.XkdcReply.XenonAuthData);
                ValueCheck.Test("AuthDataVersion", (ushort)4, Client.XkdcReply.XenonAuthData.AuthDataVersion);

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates a machine requesting a single machine only service"), TestCasePriority(1)]
        public class MachineOnly_SingleService : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { (uint)XOService.Auto_Update });
                ExpectedResults = new uint[] { 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Ignore("Machine Only DWORD services don't exist"), Description("Validates a machine requesting a single dword service"), TestCasePriority(2)]
        public class MachineOnly_DwordService : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.TitleID = 0xFFFE0004;
                Input.SetServices(new uint[] { 9104 });
                ExpectedResults = new uint[] { 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates a machine requesting multiple byte services"), TestCasePriority(1)]
        public class MachineOnly_MultipleServices : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { (uint)XOService.Auto_Update, (uint)XOService.Tou, (uint)XOService.Liveinfo });
                ExpectedResults = new uint[] { 0, 0, 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates a user and machine requesting a single byte service"), TestCasePriority(1)]
        public class SingleUser_SingleService : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { (uint)XOService.User_Account });
                ExpectedResults = new uint[] { 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates a user and machine requesting a single dword service"), TestCasePriority(1)]
        public class SingleUser_DwordService : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.TitleID = 0xFFFE0004;
                Input.SetServices(new uint[] { 9004 });
                ExpectedResults = new uint[] { 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates a user and machine requesting multiple byte services"), TestCasePriority(2)]
        public class SingleUser_MultiService : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { (uint)XOService.User_Account, (uint)XOService.PresNotification, (uint)XOService.MessagingService });
                ExpectedResults = new uint[] { 0, 0, 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates a user and machine requesting autodiscovered services"), TestCasePriority(1)]
        public class SingleUser_AutoDiscover : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4d");

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;

                AuthenticateXkdc();
                //ValidateXkdcResponse();
                // Autodiscover should just get its sites from the default site (1)
                // Let's just validate the result was S_OK, and the site was 1
                ValueCheck.Test("XkdcResultHr", 0, Client.XkdcOutput.Hr);
                // The first service name is 'sg'
                ValueCheck.Test("XkdrResultServiceName", "site1", Client.XkdcOutput.ServiceName[1]);

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates two users and machine requesting multiple services"), TestCasePriority(2)]
        public class TwoUsers : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");
                CreateUser("xktad4b");

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { (uint)XOService.User_Account });
                ExpectedResults = new uint[] { 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates three users and machine requesting multiple services"), TestCasePriority(2)]
        public class ThreeUsers : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");
                CreateUser("xktad4b");
                CreateUser("xktad4c");

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { (uint)XOService.User_Account });
                ExpectedResults = new uint[] { 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Validates four users and machine requesting multiple services"), TestCasePriority(2)]
        public class FourUsers : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");
                CreateUser("xktad4b");
                CreateUser("xktad4c");
                CreateUser("xktad4d");

                SignInAll();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { (uint)XOService.User_Account });
                ExpectedResults = new uint[] { 0 };

                AuthenticateXkdc();
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase(BugID = 48050, BugDatabase = "Xbox 360 Console Software"), Description("Validates that a byte service with an ID > 127 && < 160 doesn't get set as a machine privilege"), TestCasePriority(2)]
        public class InvalidBaseService_MachineSpace : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");
                SignInAll();

                Input.TitleID = 0xFFFE0004;
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { 130 });

                AuthenticateXkdc();

                XenonAuthDataBase authdata = Client.XkdcReply.XenonAuthData;
                ValueCheck.TestNotNull("Xkdc AuthData", authdata);

                // If we were given the service, it will be in the privilege bit 130
                ValueCheck.IsFalse(authdata.HasPrivilege(130), "Has Authdata Privilege 130");

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase(BugID = 48050, BugDatabase = "Xbox 360 Console Software"), Description("Validates that a byte service with an ID > 159 && < 256 doesn't get set as a user privilege"), TestCasePriority(2)]
        public class InvalidBaseService_UserSpace : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");
                SignInAll();

                Input.TitleID = 0xFFFE0004;
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { 168 });

                AuthenticateXkdc();

                XenonAuthDataBase authdata = Client.XkdcReply.XenonAuthData;
                ValueCheck.TestNotNull("Xkdc AuthData", authdata);

                // If we were given the service, it will be in the privilege bit 168
                ValueCheck.IsFalse(authdata.HasPrivilege(168), "Has Authdata Privilege 168");

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase(BugID = 49063, BugDatabase = "Xbox 360 Console Software"), Description("Validates that a service with an ID 256 gets set as a DWORD service"), TestCasePriority(1)]
        public class SingleServiceWithSvcId256 : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");
                SignInAll();

                Input.TitleID = 0xFFFE0004;
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { 256 });

                AuthenticateXkdc();

                XenonAuthDataBase authdata = Client.XkdcReply.XenonAuthData;
                ValueCheck.TestNotNull("Xkdc AuthData", authdata);

                // The bit for service id 256 would exist as the first bit, in the 
                // set of user privileges for the second user.
                // | Base Svcs | Machine | User  0 | User  1 | ...
                // |  0 - 127  | 128-159 | 160-255 | 256-351 | ...
                // This is a bit of an odd overflow case that could stomp on some 
                // other data in the struct

                // Privilege bit 160 for user 2, is bit 256 in the whole thing
                ValueCheck.IsFalse(authdata.HasPrivilege(160, 1), "Has Service ID 256 in User[2].Privileges");

                // We also validate the response to make sure the service got added as a DWORD service
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase(BugID = 49063, BugDatabase = "Xbox 360 Console Software"), Description("Validates that a service with an ID 256 gets set as a DWORD service"), TestCasePriority(2)]
        public class MultipleServicesWithSvcId256 : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4a");
                SignInAll();

                Input.TitleID = 0xFFFE0004;
            }

            public override void Run()
            {
                ExpectedAuthDataVersion = 4;
                Input.SetServices(new uint[] { 256, 9004, 9104 });

                AuthenticateXkdc();

                XenonAuthDataBase authdata = Client.XkdcReply.XenonAuthData;
                ValueCheck.TestNotNull("Xkdc AuthData", authdata);

                // The bit for service id 256 would exist as the first bit, in the 
                // set of user privileges for the second user.
                // | Base Svcs | Machine | User  0 | User  1 | ...
                // |  0 - 127  | 128-159 | 160-255 | 256-351 | ...
                // This is a bit of an odd overflow case that could stomp on some 
                // other data in the struct

                // Validate the response to make sure the service got added as a
                // DWORD service
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Verifies that valid byte sized services (0-127) passed as DWORD services are handled correctly"), TestCasePriority(2)]
        public class ValidByteServiceAsDword : TestBase_KdcClient<KdcClientXbox360>
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4b");

                SignInAll();
            }

            public override void Run()
            {
                // Since a byte service can theoretically range from 0-255, the service request class
                // will basically accept anything in that range.  Authdata4 only accepts byte services
                // in the range 0-127, so we need to make sure that byte services passed as DWORDs are
                // properly marshaled

                // This is the service we want to use
                uint byteService = (uint)XOService.Matchmaking;

                // Generate the default preauths with whatever the basic input
                Client.XkdcRequest.Input.GeneratePreauths();
                // Now add our service manually to the dword services in the preauth input
                ServerTestFramework.LiveService.Auth.Asn.Kerberos.PreauthXenonServiceRequest2 preauth =
                    Client.XkdcRequest.Input.PreauthXenonServiceRequest2.Data;
                preauth.DwordServiceIDs[preauth.NumDwordServices++] = byteService;
                // And then re-encrypt it all again
                preauth.EncryptionKey=Client.XkdcRequest.Input.Key;
                preauth.EncryptionNOnce=Client.XkdcRequest.Input.NOnce;
                preauth.Encrypt();

                // Apply all the values from the input to the appropriate ASN fields
                Client.XkdcRequest.SetRequest();
                // And create the ASN encoded byte stream
                Client.XkdcRequest.ConstructRequest();

                // We validate against what's in the input, so add the service we're expecting
                Input.SetServices(new uint[] { byteService });
                // Then send the request, without automatically creating it
                AuthenticateXkdc(false);
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase(BugID=49233, BugDatabase="Xbox 360 Console Software"), Description("Verifies that invalid byte sized services (128-255) passed as DWORD services are handled correctly"), TestCasePriority(2)]
        public class InvalidByteServiceAsDword : TestBase_KdcClient<KdcClientXbox360>
        {
            public override void PreRun()
            {
                base.PreRun();

                CreateClient();
                CreateUser("xktad4b");
                SignInAll();

                // Using test service so need to use test title
                Input.TitleID = 0xFFFE0004;
            }

            public override void Run()
            {
                // Since a byte service can theoretically range from 0-255, the service request class
                // will basically accept anything in that range.  Authdata4 only accepts byte services
                // in the range 0-127, so we need to make sure that byte services passed as DWORDs are
                // properly marshaled

                // This is the service we want to use
                uint byteService = 168;

                // Generate the default preauths with whatever input we have
                Client.XkdcRequest.Input.GeneratePreauths();
                // Now add our service manually to the dword services in the preauth input
                ServerTestFramework.LiveService.Auth.Asn.Kerberos.PreauthXenonServiceRequest2 preauth =
                    Client.XkdcRequest.Input.PreauthXenonServiceRequest2.Data;
                preauth.DwordServiceIDs[preauth.NumDwordServices++] = byteService;
                // And then re-encrypt it all again
                preauth.EncryptionKey=Client.XkdcRequest.Input.Key;
                preauth.EncryptionNOnce=Client.XkdcRequest.Input.NOnce;
                preauth.Encrypt();

                // Apply all the values from the input to the appropriate ASN fields
                Client.XkdcRequest.SetRequest();
                // And create the ASN encoded byte stream
                Client.XkdcRequest.ConstructRequest();

                // We validate against what's in the input, so add the service we're expecting
                Input.SetServices(new uint[] { byteService });
                // Then send the request, without automatically creating it
                AuthenticateXkdc(false);
                ValidateXkdcResponse();

                return TEST_RESULTS.PASSED;
            }
        }
    }*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonAskdc.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XkdcTest
{
    abstract public class TestBase_Xenon_Askdc : TestBase_Xkdc //used only by a single anti-dos test now
    {
        protected static BulkUserSet userSet;
        protected AskdcClient askdc;

        public TestBase_Xenon_Askdc()
        {
            ClientType=AuthContext.ClientTypes.Xenon;
        }

        public override void SetDefaults()
        {
            base.SetDefaults();

            // Clear it each time, to be safe
            askdc = new AskdcClient(authContext);
        }

        protected void Create(uint count)
        {
            UodbWS.ReserveName_KEK = ServiceKeys.GetServiceKey(ServiceKeys.Key_KEK);

            //UodbWS.CreateBulkUsers("xk", count, out userSet); //temp replaced until bulkusers uses gamertag by default for key calc:
            UodbWS.CreateBulkUsers("xk", count, 0xFFFE000080000008, 103, false, out userSet, true);
        }

        protected void SignIn(int index, bool bVerbose)
        {
            try
            {
                string gamertag = userSet.IndexToGamertag((uint)index);
                byte[] key = userSet.IndexToXenonKey2((uint)index);

                if (bVerbose)
                    ro.Debug("Signing in #{0} with {1}, key 0x{2}", index, gamertag, Hexer.tohex(key));

                SetDefaults();
                UserInfo user = SetUser(gamertag, 0);
                authContext.Users[0].Key = key;
                if (DisableRetryBehaviour) askdc.EmulateClientBehavior=false;
                askdc.SignInAskdc();
            }
            catch (ArgumentException e)
            {
                ro.Debug("out of range exception, index={0}", index);
                throw e;
            }
        }

        protected void SignInXbox(int index, bool bVerbose)
        {
            string gamertag = userSet.IndexToGamertag((uint)index);
            byte[] key = userSet.IndexToXboxKey2((uint)index);

            if (bVerbose)
                ro.Debug("Signing in #{0} with {1}, key 0x{2}", index, gamertag, Hexer.tohex(key));

            SetDefaults();
            UserInfo user = SetUser(gamertag, 0);
            authContext.Users[0].Key = key;
            if (DisableRetryBehaviour) askdc.EmulateClientBehavior=false;
            askdc.SignInAskdc();
        }


    }

    [TestGroup]
    public class XenonAskdc: XkdcTestBaseGroup
    {
        public XenonAskdc() : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }

        //note: bin_key in uodb is actually encrypted with the kek.  the key we set here is the unencrypted key.  this should never pass as a result.
        [TestCase]
        class UserZeroBinKey: TestNode
        {
            public override void Run()
            {
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                AskdcClient askdc=new AskdcClient(ctx);

                ctx.SetUser("xktzerokeys", 0);
                ctx.Users[0].Key=new byte[16];

                try
                {
                    askdc.SignInAskdc();
                }
                catch (ServerTestFramework.LiveService.Auth.KerbErrException kee)
                {
                    if (kee.KerbErr.ErrorCode==(uint)KerbErrCode.KDC_ERR_PREAUTH_FAILED)
                    {
                        Global.RO.Debug("Got expected Preauth Failure");
                        return;
                    }
                    throw;
                }
            }
        }

        //both ppa rows are 0, so they should never get loaded into the ppa cache
        [TestCase]
        class UserZeroPPAs_SignIn: TestNode
        {
            public override void Run()
            {
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                AskdcClient askdc=new AskdcClient(ctx);

                ctx.SetUser("xktzeroppas", 0);
                ctx.Users[0].Key=new byte[16];

                try
                {
                    askdc.SignInAskdc();
                }
                catch (ServerTestFramework.LiveService.Auth.KerbErrException kee)
                {
                    if (kee.KerbErr.ErrorCode==(uint)KerbErrCode.KDC_ERR_PREAUTH_FAILED)
                    {
                        Global.RO.Debug("Got expected Preauth Failure");
                        return;
                    }
                    throw;
                }
            }
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException), BugID=38118, BugDatabase="Xbox360 Console Software")]
        public void TooLongName()
        {
            KdcUser user=new KdcUser();
            user.CreateOrUseExisting("XenonAskdcLongx", false); //15 char name is the max length gamertag you can make

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.ConsoleOrUserName+="Here is some more stuff.  This is a really long name that is totally invalid.";
            kdc.ExecuteAskdc(true);
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException), BugID=38118, BugDatabase="Xbox360 Console Software")]
        public void NullTerminatorInUserName()
        {
            KdcUser user=new KdcUser();
            user.CreateOrUseExisting("XAskdcNull0", false);

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.ConsoleOrUserName+="\0Bad";
            kdc.ExecuteAskdc(true);
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException), BugID=38118, BugDatabase="Xbox360 Console Software")]
        public void NullTerminatorInUserNameAndTooLongName()
        {
            KdcUser user=new KdcUser();
            user.CreateOrUseExisting("XAskdcNull1", false);

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcUserRequest(user);
            kdc.AskdcRequest.Input.ConsoleOrUserName+="\0";
            for (int i=0; i<45; ++i)
            {
                kdc.AskdcRequest.Input.ConsoleOrUserName+="Long Text After Null.";
            }
            kdc.ExecuteAskdc(true);
        }

        [TestCase]
        public void NameEmpty()
        {
            KdcUser user=new KdcUser();
            user.SetFakeUser("", false);

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateAskdcUserRequest(user);

            try
            {
                kdc.ExecuteAskdc(true);
            }
            catch (KerberosErrorException err)
            {
                if (err.Error.ErrorCode.Int64!=6) //KDC_ERR_C_PRINCIPAL_UNKNOWN
                {
                    throw;
                }
            }
        }

        [TestCase]
        public void NameSingleNull()
        {
            KdcUser user=new KdcUser();
            user.SetFakeUser("\0", false);

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateAskdcUserRequest(user);

            try
            {
                kdc.ExecuteAskdc(true);
            }
            catch (KerberosErrorException err)
            {
                if (err.Error.ErrorCode.Int64!=6) //KDC_ERR_C_PRINCIPAL_UNKNOWN
                {
                    throw;
                }
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                //this is not the exact bug number, there is no bug opened specifically for this, but that bug covers related issues our KDC has.
                throw new KnownBugException(38118, "Xbox 360 Console Software", "Got TimeoutException, but expected a KDC_ERR_C_PRINCIPAL_UNKNOWN kerberos error.");
            }
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException))]
        public void BadServiceName0()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames[0]="krbwtf";
            kdc.ExecuteAskdc(true);
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException))]
        public void BadRealmName()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.Realm="BADDPORT.NET";
            kdc.ExecuteAskdc(true);
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException), BugID=38118, BugDatabase="Xbox360 Console Software")]
        public void RealmNameWithNull()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.Realm="PASSPORT.NET\0.HOTMAIL.COM";
            kdc.ExecuteAskdc(true);
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException))]
        public void LongServiceName0()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames[0]="krbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgt";
            kdc.ExecuteAskdc(true);
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException), BugID=38118, BugDatabase="Xbox360 Console Software")]
        public void LongServiceName0WithNull()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames[0]="krbtgt\0krbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgtkrbtgt";
            kdc.ExecuteAskdc(true);
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException), BugID=38118, BugDatabase="Xbox360 Console Software")]
        public void ServiceName0WithNull()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames[0]="krbtgt\0sg";
            kdc.ExecuteAskdc(true);
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException))]
        public void BadServiceName1()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames[1]="ZBOX.COM";
            kdc.ExecuteAskdc(true);
        }

        [TestCase]
        public void BadServiceNameExtra()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames=new string[3]{"krbtgt", "XBOX.COM", "XBOX.COM"};

            try
            {
                kdc.ExecuteAskdc(true);
            }
            catch (KerberosErrorException err)
            {
                if (err.Error.ErrorCode.Int64!=7) //KDC_ERR_S_PRINCIPAL_UNKNOWN
                {
                    throw;
                }
            }
        }

        [TestCase]
        public void ServiceName0Only()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames=new string[1]{"krbtgt"};

            try
            {
                kdc.ExecuteAskdc(true);
            }
            catch (KerberosErrorException err)
            {
                if (err.Error.ErrorCode.Int64!=7) //KDC_ERR_S_PRINCIPAL_UNKNOWN
                {
                    throw;
                }
            }
        }

        [TestCase(typeof(ServerTestFramework.Utilities.TimeoutException))]
        public void ServiceName0Blank()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.RetryLostPackets=false;
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames[0]="";
            kdc.ExecuteAskdc(true);
        }

        [TestCase]
        public void ZeroServiceNames()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcRequest.Input.ServerNames=new string[0];

            try
            {
                kdc.ExecuteAskdc(true);
            }
            catch (KerberosErrorException err)
            {
                if (err.Error.ErrorCode.Int64!=60) //KRB_ERR_GENERIC
                {
                    throw;
                }
            }
        }

        //See bug: Xbox360 Console Software 38181
        [TestCase, Description("Attempt to athenticate more than 4 users.")]
        [CompoundCase("MachineFirst", true)]
        [CompoundCase("NoMachine", false)]
        public void TooManyUsers(TestNode self)
        {
            bool machineFirst=(bool)self.MyValues[0];

            KdcClientXbox360 kdc=new KdcClientXbox360();

            if (machineFirst)
            {
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);
            }

            for (int u=0; u<4; ++u)
            {
                kdc.CreateAskdcUserRequest(null);
                kdc.ExecuteAskdc(true);
            }

            try
            {
                kdc.CreateAskdcUserRequest(new KdcUser());
                kdc.ExecuteAskdc(true);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Got Exception: "+e); //TODO: filter for more specific one
                return;
            }

            throw new UnexpectedTestResultException("Did not expect the 5th user request to succeed.");
        }

        [TestCase, Description("Authenticate machines and users in different orders.")]
        [CompoundCase("No Users, Same Machine",      0, false)]
        [CompoundCase("No Users, Different Machine", 0, true)]
        [CompoundCase("1 User Same Machine",         1, false)]
        [CompoundCase("4 Users Same Machine",        4, false)]
        [CompoundCase("4 Users Different Machine",   4, true)]
        public void TooManyMachines(TestNode self)
        {
            int numberOfUsers=(int)self.MyValues[0];
            bool useOtherMachine=(bool)self.MyValues[1];

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.ExecuteXmacs(true);

            Global.RO.Debug("Authenticating machine...");
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            KdcUser []users=new KdcUser[numberOfUsers];
            for (int u=0; u<numberOfUsers; ++u)
            {
                users[u]=new KdcUser();
                users[u].CreateUser(false);
            }

            for (int u=0; u<numberOfUsers; ++u)
            {
                Global.RO.Debug("Authenticating user...");
                kdc.CreateAskdcUserRequest(users[u]);
                kdc.ExecuteAskdc(true);
            }

            if (useOtherMachine)
            {
                KdcClientXbox360 tempOtherMachine=new KdcClientXbox360();
                tempOtherMachine.ExecuteXmacs(true);
                kdc.XmacsOutput=tempOtherMachine.XmacsOutput;
            }

            try
            {
                Global.RO.Debug("Authenticating machine...");
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Got Exception: "+e); //TODO: filter for more specific one
                return;
            }

            throw new UnexpectedTestResultException("Did not expect the 2nd machine request to succeed.");
        }

        [TestCase, Description("Bucharest builds of the client have a bug where they send the new XENON_PPA preauth along with user requests.  Askdc didn't handle that correctly (bug 188506).  This is a test for this case.")]
        public void XenonPPAWithUserRequest()
        {
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateAskdcUserRequest(new KdcUser());
            kdc.AskdcRequest.Input.ConsoleCert=new ConsoleCertificate(); //doesn't matter what machine it is for, this will cause the preauth to be included
            kdc.ExecuteAskdc(true);
        }

        [TestCase, Description("Pass xenon PPA with a mixed set of sizes for the hash data.  Note that if the size does not exactly match we ignore the preauth and fall back to the legacy behaviour, which will work if th key matches still.")]
        [CompoundCase("0 Good Key",   0,   true,  true)]
        [CompoundCase("1 Good Key",   1,   true,  true)]
        [CompoundCase("19 Good Key",  19,  true,  true)]
        [CompoundCase("20 Good Key",  20,  true,  true)]
        [CompoundCase("21 Good Key",  21,  true,  true)]
        [CompoundCase("999 Good Key", 999, true,  true)]
        [CompoundCase("0 Bad Key",    0,   false, false)]
        [CompoundCase("1 Bad Key",    1,   false, false)]
        [CompoundCase("19 Bad Key",   19,  false, false)]
        [CompoundCase("20 Bad Key",   20,  false, false)]
        [CompoundCase("21 Bad Key",   21,  false, false)]
        [CompoundCase("999 Bad Key",  999, false, false)]
        public void XenonPPALengths(TestNode me)
        {
            int preauthSize=(int)me.MyValues[0];
            bool useCorrectKey=(bool)me.MyValues[1];
            bool expectedSuccess=(bool)me.MyValues[2];

            KdcClientXbox360 client=new KdcClientXbox360();
            client.CreateAskdcMachineRequest();

            if (!useCorrectKey)
            {
                client.AskdcRequest.Input.IndividualKey[15]=(byte)~client.AskdcRequest.Input.IndividualKey[15];
            }

            client.AskdcRequest.Input.ConsoleCert=client.XmacsRequest.Input.FindConsoleCertificateInPreauths();
            client.AskdcRequest.Input.GeneratePreauths();
            System.Array.Resize(ref client.AskdcRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonPPA>>().Data.CertificateHash, preauthSize);

            client.AskdcRequest.SetRequest();
            client.AskdcRequest.ConstructRequest();

            if (expectedSuccess)
            {
                client.ExecuteAskdc(false);
            }
            else
            {
                client.AskdcThrowOnKerberosError=false;
                client.ExecuteAskdc(false);
                if (client.AskdcError==null)
                {
                    throw new UnexpectedTestResultException("Expected a kerberos error from askdc but got a valid response.");
                }

                if ((int)client.AskdcError.ErrorCode.Int64!=(int)KerbErrCode.KDC_ERR_PREAUTH_FAILED)
                {
                    throw new KerberosErrorException(client.AskdcError, "Askdc reply was expected to be error "+KerbErrCode.KDC_ERR_PREAUTH_FAILED+" but was "+(KerbErrCode)client.AskdcError.ErrorCode.Int64);
                }
            }
        }

        [TestCase, Description("Authenticate machines and users in different orders.")]
        //                                           number of users, machine order index
        [CompoundCase("1 user, 1 machine",           1,               1)]
        [CompoundCase("1 machine, 1 user",           1,               0)]
        [CompoundCase("4 users, 1 machine",          4,               4)]
        [CompoundCase("1 machine, 4 users",          4,               0)]
        [CompoundCase("1 user, 1 machine, 1 user",   2,               1)]
        [CompoundCase("2 users, 1 machine, 2 users", 4,               2)]
        public void AuthenticationOrder(TestNode self)
        {
            //prepare
            int numberOfUsers=(int)self.MyValues[0];
            int machineIndex=(int)self.MyValues[1];

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.ExecuteXmacs(true);

            KdcUser []users=new KdcUser[numberOfUsers];
            for (int u=0; u<numberOfUsers; ++u)
            {
                users[u]=new KdcUser();
                users[u].CreateUser(false);
            }

            //zoom
            for (int u=0; u<numberOfUsers; ++u)
            {
                if (u==machineIndex)
                {
                    Global.RO.Debug("Authenticating machine...");
                    kdc.CreateAskdcMachineRequest();
                    kdc.ExecuteAskdc(true);
                }

                Global.RO.Debug("Authenticating user...");
                kdc.CreateAskdcUserRequest(users[u]);
                kdc.ExecuteAskdc(true);
            }

            if (machineIndex>=numberOfUsers)
            {
                Global.RO.Debug("Authenticating machine...");
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);
            }

            //verify authdata
            ValueCheck.Test("MachinePuid in AuthData", kdc.XmacsOutput.MachineId, kdc.AskdcReply.AuthData.XboxIdentity.MachineId);
            ValueCheck.Test("MachineCredentialType in AuthData", WindowsPacAuthData.CT_RandomKey, kdc.AskdcReply.AuthData.XboxIdentity.MachineIdCredential);

            for (int u=0; u<numberOfUsers; ++u)
            {
                ValueCheck.Test("User"+u+"Puid in AuthData", users[u].UserID, kdc.AskdcReply.AuthData.XboxIdentity.UserId[u]);
                ValueCheck.Test("User"+u+"CredentialType in AuthData", WindowsPacAuthData.CT_RandomKey, kdc.AskdcReply.AuthData.XboxIdentity.UserIdCredential[u]);
            }

            for (int u=numberOfUsers; u<4; ++u)
            {
                ValueCheck.Test("User"+u+"Puid in AuthData", 0, kdc.AskdcReply.AuthData.XboxIdentity.UserId[u]);
                ValueCheck.Test("User"+u+"CredentialType in AuthData", 0, kdc.AskdcReply.AuthData.XboxIdentity.UserIdCredential[u]);
            }
        }

        [TestCase, Description("Sent a request to askdc with a previous ticket contaning the old Identity and/or CompoundIdentity in the pac authdata.  Askdc will reject it with KDC_ERR_PREAUTH_FAILED.  This should only happen to consoles that are in the middle of an askdc request chain during upgrade from pre-2011-september KDCs to post-2011-september KDCs.  After failing the user will try again and be good.")]
        [CompoundCase("Identity User",    true,  false)]
        [CompoundCase("Identity Machine", false, false)]
        [CompoundCase("Compound User",    true,  true)]
        [CompoundCase("Compound Machine", false, true)]
        public void OldPacAuthdata(TestNode self)
        {
            bool isUserRequest=(bool)self.MyValues[0];
            bool isCompound=(bool)self.MyValues[1];

            KdcClientXbox360 kdc=new KdcClientXbox360();

            int u=0;
            ulong []expectedUsersInPac=new ulong[4];
            ulong expectedMachineInPac=0;

            //synthenize a ticket for one or more users
            for (int userCount=0; userCount<(isCompound?(isUserRequest?3:4):1); ++userCount)
            {
                KdcUser faker=new KdcUser();
                faker.CreateUser(false);
                Global.RO.Debug("Adding user puid="+faker.UserID+" gamertag="+faker.Gamertag);

                kdc.CreateAskdcUserRequest(faker);
                kdc.AskdcOutput=new AskdcGenericReplyOutput();
                kdc.AskdcOutput.PopulateFromInput(kdc.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.CompoundIdentity);

                expectedUsersInPac[u++]=faker.UserID;
            }

            //do the real askdc request now, providing this synthesized ticket
            if (isUserRequest)
            {
                KdcUser user=new KdcUser();
                user.CreateUser(false);
                Global.RO.Debug("Doing request for user puid="+user.UserID+" gamertag="+user.Gamertag);

                kdc.CreateAskdcUserRequest(user);

                expectedUsersInPac[u++]=user.UserID;
            }
            else
            {
                kdc.ExecuteXmacs(true);
                Global.RO.Debug("Doing request for machine puid="+kdc.XmacsOutput.MachineId+" consoleid="+kdc.XmacsOutput.ConsoleId);

                expectedMachineInPac=kdc.XmacsOutput.MachineId;

                kdc.CreateAskdcMachineRequest();
            }

            kdc.AskdcThrowOnKerberosError=false;
            kdc.ExecuteAskdc(true);

            ValueCheck.Test("Got KerberosError as a response", true, kdc.AskdcError!=null);
            ValueCheck.Test("Kerberos Error Code", KerbErrCode.KDC_ERR_PREAUTH_FAILED, kdc.AskdcError.ErrorCode.Int64);
        }

        [TestCase, Description("Sent a request to askdc with a previous ticket contaning the new XboxIdentity pac authdata.  This is primarily to test how the old KDC handles the new authdata.")]
        [CompoundCase("User",    true)]
        [CompoundCase("Machine", false)]
        public void NewPacAuthdata(TestNode self)
        {
            bool isUserRequest=(bool)self.MyValues[0];

            KdcClientXbox360 kdc=new KdcClientXbox360();

            int u=0;
            ulong []expectedUsersInPac=new ulong[4];
            ulong expectedMachineInPac=0;

            //synthenize a ticket for one or more users
            for (int userCount=0; userCount<(isUserRequest?3:4); ++userCount)
            {
                KdcUser faker=new KdcUser();
                faker.CreateUser(false);
                Global.RO.Debug("Adding user puid="+faker.UserID+" gamertag="+faker.Gamertag);

                kdc.CreateAskdcUserRequest(faker);
                kdc.AskdcOutput=new AskdcGenericReplyOutput();
                kdc.AskdcOutput.PopulateFromInput(kdc.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.XboxIdentity);

                expectedUsersInPac[u++]=faker.UserID;
            }

            //do the real askdc request now, providing this synthesized ticket
            if (isUserRequest)
            {
                KdcUser user=new KdcUser();
                user.CreateUser(false);
                Global.RO.Debug("Doing request for user puid="+user.UserID+" gamertag="+user.Gamertag);

                kdc.CreateAskdcUserRequest(user);

                expectedUsersInPac[u++]=user.UserID;
            }
            else
            {
                kdc.CreateXmacsRequest();
                kdc.XmacsRequest.Input.ConsoleSerialNumber=null;
                kdc.ExecuteXmacs(true);
                Global.RO.Debug("Doing request for machine puid="+kdc.XmacsOutput.MachineId+" consoleid="+kdc.XmacsOutput.ConsoleId);

                expectedMachineInPac=kdc.XmacsOutput.MachineId;

                kdc.CreateAskdcMachineRequest();
            }

            kdc.AskdcRequest.Input.PreauthsToGenerate=kdc.AskdcRequest.Input.GetDefaultPreauthsToGenerate();
            kdc.AskdcRequest.Input.PreauthsToGenerate.AddLast(131); //add back in the preauths we cut to save space, the old kdc still requires them
            kdc.AskdcRequest.Input.PreauthsToGenerate.AddLast(204);

            kdc.ExecuteAskdc(true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonBasic.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    /// <summary>
    /// Xenon-specific tests go here.  Remember, all previous test cases will also be run as Xenon
    /// clients.
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(250), AsyncThreadCount(10)]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XenonBasic: XkdcTestBaseGroup
    {
        public XenonBasic() : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }

        #region BasicXenonV1Logon

        [TestCase, Description("Xenon machine logon test: auto-discover")]
            class XenonBasicMachineLogon : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                SignInXkdc();
                ro.Debug(result.ToString());
            }
        }

        [TestCase, Description("Xenon machine logon test: auto-discover")]
            class XenonBasicMachineLogon_Title3EEF0800 : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0x3EEF0800, 1, 1);
                SignInXkdc();
                ro.Debug(result.ToString());
            }
        }


        [TestCase, Description("Xenon basic user logon test: auto-discover")]
            class XenonBasicUserT2 : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                SetUser(UserTimer.AccessSharedUser("xktduusert2a"), 0);
                SignInXkdc();
                ro.Debug(result.ToString());
            }
        }

        [TestCase, Description("Xenon basic user logon test: auto-discover")]
            class XenonBasicUserT2_Title3EEF0800 : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0x3EEF0800, 1, 1);
                SetUser(UserTimer.AccessSharedUser("xktduusert2a"), 0);
                SignInXkdc();
                ro.Debug(result.ToString());
            }
        }

        [TestCase, Description("Xenon user logon test")]
            class XenonBasicUserLogon_Tier1 : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                string[] usernames = new string[] 
                {
                    "xktusert1a",
                    "xktxeusert1a",
                    "xktduusert1a",
                };
                foreach (string user in usernames)
                {
                    SetDefaults();
                    SetUser(user, 0);
                    UserTimer.AccessSharedUser(user);
                    if (!SignInXkdc(true))
                    {
                        ro.Warn("Test failed for user {0}", user);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        [TestCase, Description("Xenon user logon test")]
            class XenonBasicUserLogon_Tier2 : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                string[] usernames = new string[] 
                {
                    "xktusert2a",
                    "xktxeusert2a",
                    "xktduusert2a",
                    "xktxeusert2ar",
                    "xktduusert2ar",
                    "xktsuball"
                };
                foreach (string user in usernames)
                {
                    SetDefaults();
                    SetUser(user, 0);
                    UserTimer.AccessSharedUser(user);
                    if (!SignInXkdc(true))
                    {
                        ro.Warn("Test failed for user {0}", user);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        [TestCase]
            class XenonBasicSingleUserLogon_DiffKey : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                SetUser(UserTimer.AccessSharedUser("xktdudifft2a"), 0);

                //Since the xbox1 decommision, xbox1 user keys no longer work, so this request should fail
                try
                {
                    SignInXkdc();
                }
                catch (KerbErrException kee)
                {
                    if (kee.KerbErr==KerbErrCode.KDC_ERR_PREAUTH_FAILED)
                    {
                        return;
                    }

                    throw;
                }

                throw new UnexpectedTestResultException("Request unexpectedly succeeded.");
            }
        }


        [TestCase, AsyncGroup(0)] //previously there were also tests that had variations of "DiffKey" similar to this, which used the xbox1 key on an xbox360.  With the xbox1 decom that no longer works and those tests were deleted.
            class XenonBasicMultiUserLogon_SameKey_SameKey : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                SetUser(UserTimer.AccessSharedUser("xktduusert2a"), 0);
                SetUser(UserTimer.AccessSharedUser("xktusert2a"), 1);
                SignInXkdc();
            }
        }

        #endregion

        [TestCase, Description("Xenon machine logon test: auto-update <no auto discover>")]
            class XenonBasicMachineLogon_NoAutodiscover : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] {(uint)XOService.Auto_Update
                                              };
                ExpectedHRs  = new uint[] { 0 };
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user logon test: useraccount, base, presence <no auto discover>")]
        class XenonBasicUserLogon_NoAutodiscover : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] {(uint)XOService.User_Account,
                                               (uint)XOService.Base_Subscription,
                                               (uint)XOService.PresNotification};
                ExpectedHRs  = new uint[] { 0, 0, 0 };
                SetUser(UserTimer.AccessSharedUser("xktusert2a"));
                SignInXkdc();
            }
        }

        [TestCase, AsyncGroup(0), Description("Verify Parental Controlled bit in UserFlags")]
            class UserFlag_ParentalControls_DiffOwnerPuid_Set : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                // Child account, Passport PUID != Owner Passport PUID
                SetUser(UserTimer.AccessSharedUser("xktduchilt2a"), 0);
                SignInXkdc();
                if (!UserFlagsUtil.IsUserParentalControlled(result.UserFlags[0]))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                SetDefaults();
                SetUser(UserTimer.AccessSharedUser("xktusert2a"), 0);
                SetUser(UserTimer.AccessSharedUser("xktduchilt2a"), 1);
                SignInXkdc();
                if (!UserFlagsUtil.IsUserParentalControlled(result.UserFlags[1]) ||
                     UserFlagsUtil.IsUserParentalControlled(result.UserFlags[0]))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Verify Parental Controlled bit in UserFlags")]
            class UserFlag_ParentalControls_SameOwnerPuid_NotSet : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                // Not child account, Passport PUID == Owner Passport PUID
                // This is a sanity check
                SetUser(UserTimer.AccessSharedUser("xktduusert2a"));
                SignInXkdc();

                // Verify bit in UserFlags
                if (UserFlagsUtil.IsUserParentalControlled(result.UserFlags[0]))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, AsyncGroup(0)]
            class UserFlag_LanguageId : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                // We're re-using some users in this test that get free trial offers,
                // which may end up granting extra services and privileges. We don't 
                // really care about them in this test anyway..
                bVerifyServices = false;
                bVerifyPrivileges = false;

                string[] users = new string[]
                {
                    "xktcntry16t1",
                    "xktcntry24t1",
                    "xktcntry44t1",
                    "xktcntry25t1",
                    "xktcntry75t1"
                };

                for (int i = 0; i < users.Length; i++)
                {
                    // Expected user language is 1, 2, 3, or 4, respectively
                    int ExpectedLanguage = i + 1;

                    //except for xktcntry75t1, which is 15 in t_cultures
                    if (users[i]=="xktcntry75t1") ExpectedLanguage=15;

                    // Single user logon
                    SetDefaults();
                    SetUser(users[i], 0);
                    UserTimer.AccessSharedUser(users[i]);
                    SignInXkdc();
                    if (UserFlagsUtil.UserLanguageId(result.UserFlags[0]) != ExpectedLanguage)
                    {
                        Fail("For user {0}, expected language id {1}, got: {2}",
                            users[i],
                            ExpectedLanguage,
                            UserFlagsUtil.UserLanguageId(result.UserFlags[0]));
                    }

                    // Multi user logon
                    SetDefaults();
                    SetUser(UserTimer.AccessSharedUser("xktusert2a"), 0);
                    SetUser(users[i], 1);
                    SignInXkdc();
                    if (UserFlagsUtil.UserLanguageId(result.UserFlags[1]) != ExpectedLanguage ||
                        UserFlagsUtil.UserLanguageId(result.UserFlags[0]) != 1)
                    {
                        Fail("For users {0} and {1}, expected language id {2}, got: {3}",
                            "xktusert2a",
                            users[i],
                            ExpectedLanguage,
                            UserFlagsUtil.UserLanguageId(result.UserFlags[0]));
                    }

                }

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonBackCompat.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    /// <summary>
    /// Xenon-specific tests go here.  Remember, all previous test cases will also be run as Xenon
    /// clients.
    /// </summary>

    [TestGroup]
    public class XenonBackCompat : XkdcTestBaseGroup
    {

        public XenonBackCompat()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
            Name = GetType().Name;

            // Add new tests here.  This is SO much simpler than creating a new class
            // for each test.

            //xbox1 and fusion are gone now:
            /*
            // Xbox case
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.Xbox, "xktduusert1a", null, TestBase_BackCompat.Notallow));
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.Xbox, "xktxbusert2a", null, TestBase_BackCompat.Yes));
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.Xbox, "xktduusert2a", null, TestBase_BackCompat.Yes));
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.Xbox, "xktduusert2ar", null, TestBase_BackCompat.Notallow));

            // Invalid case of a Xenon game running on an Xbox console
            // too difficult to check, low risk, so we're going to ignore this case
            //AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.XboxConsoleXenonTitle, "xktduusert1a", null, TestBase_BackCompat.Err));
            //AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.XboxConsoleXenonTitle, "xktxbusert2a", null, TestBase_BackCompat.Err));
            //AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.XboxConsoleXenonTitle, "xktduusert2a", null, TestBase_BackCompat.Err));
            //AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.XboxConsoleXenonTitle, "xktduusert2ar", null, TestBase_BackCompat.Err));

            // Backcompat case
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.XenonBackCompat, "xktduusert1a", null, TestBase_BackCompat.Unauth));
            // dcaiafa says this is exceedingly difficult to check for in the XKDC/ASKDC without protocol changes.
            //AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.XenonBackCompat, "xktxbusert2a", null, TestBase_BackCompat.Err));
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.XenonBackCompat, "xktduusert2a", null, TestBase_BackCompat.Yesbc));
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.XenonBackCompat, "xktduusert2ar", null, TestBase_BackCompat.Notallow));
            */

            // Xenon case
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.Xenon, "xktduusert1a", null, TestBase_BackCompat.Unauth));
            // dcaiafa says this is exceedingly difficult to check for in the XKDC/ASKDC without protocol changes.
            //AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.Xenon, "xktxbusert2a", null, TestBase_BackCompat.Err));
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.Xenon, "xktduusert2a", null, TestBase_BackCompat.Yes));
            AddChild(new TestBase_BackCompat(AuthContext.ClientTypes.Xenon, "xktduusert2ar", null, TestBase_BackCompat.Yes));
        }
    }

    public class TestBase_BackCompat : TestBase_Xkdc
    {
        public static bool bAlwaysLog = true;

        private AuthContext.ClientTypes clienttype;
        private string user1;
        private string user2;
        private uint expected;
        private UserInfo User1;
        private UserInfo User2;

        public TestBase_BackCompat(AuthContext.ClientTypes clienttype, string user1, string user2, uint expected)
        {
            this.clienttype = clienttype;
            this.user1 = user1;
            this.user2 = user2;
            this.expected = expected;

            // Change name
            SetName();
        }

        public void SetName()
        {
            bool isXenonConsole = 
                clienttype == AuthContext.ClientTypes.Xenon || 
                clienttype == AuthContext.ClientTypes.XenonBackCompat;
            bool isXenonTitle = 
                clienttype == AuthContext.ClientTypes.Xenon;
            string A = isXenonConsole ? "XenonMachine" : "XboxMachine";
            string B = isXenonTitle ? "XenonTGS" : "XboxTGS";
            string C = (user2 == null) ? user1 : user1 + "_" + user2;
            this.Name = A + "_" + B + "_" + C;
        }

        override protected void RunTest()
        {
            Go(clienttype, user1, user2, expected);
        }

        public override void SetDefaults()
        {
            bVerifyPrivileges = false;
            ClientType = AuthContext.ClientTypes.Xenon;
            base.SetDefaults();
        }

        protected class  VerifyValuesParams
        {
            public uint ServiceHR;
            public uint[] ServiceHRs;
            public uint[] UserHRs;
            public bool fXenon;
            public bool fBackCompat;
            public bool fXbox1LiveAccess;

            public VerifyValuesParams(uint servicehr, uint[] servicehrs, uint[] userhrs,
                bool fxenon, bool fbackcompat, bool fxbox1liveaccess)
            {
                ServiceHR = servicehr;
                ServiceHRs = servicehrs;
                UserHRs = userhrs;
                fXenon = fxenon;
                fBackCompat = fbackcompat;
                fXbox1LiveAccess = fxbox1liveaccess;
            }

            public VerifyValuesParams()
            {
                UserHRs = new uint[4];
            }
        }

        // bcExpected values
        public const uint    Unk         = 0;        // Unknown what to expect (debugging)
        public const uint    Yes         = 1;        // Login ok, BackCompat flag not set
        public const uint    Yesbc       = 2;        // Login ok, BackCompat flag set
        public const uint    Notallow    = 1000;     // Not allowed (banned error) (UserHR[])
        public const uint    Err         = 1001;     // Error
        public const uint    Unauth      = 1002;     // No Services authorized (ServiceHRs[])

        protected static string[] bcUsers = new string[] 
        {
            //"xktxeusert1a",     // Xenon-only user, tier 1
            "xktduusert1a",     // Xenon and Xbox user, tier 1
            "xktxbusert2a",     // Xbox-only user, tier 2
            //"xktxeusert2a",     // Xenon-only user, tier 2
            "xktduusert2a",     // Xenon and Xbox user, tier 2
            //"xktxeusert2ar",    // Xenon-only user, tier 2, restricted from Live1
            "xktduusert2ar"     // Xenon and Xbox user, tier 2, restricted from Live1
        };

        protected static XeTitleInfo[] bcTitles = new XeTitleInfo[]
        {
            new XeTitleInfo(0xFFC0FE00, 1, 1),    // Xbox title
            new XeTitleInfo(0xC0FE0800, 1, 1)     // Xenon title
        };

        protected static uint[] bcXboxServices = new uint[]
        {
            1, 5, 6, 7
        };

        protected static uint[] bcXboxServiceHRsGood =new uint[]
        { 
            0, 0, 0, 0 
        };

        protected static uint[] bcXboxServiceHRsBad = new uint[] 
        {
            HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED,
            0,
            HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED,
            0
        };

        protected VerifyValuesParams BuildBackCompatExpectations(uint expected)
        {
            VerifyValuesParams p = new VerifyValuesParams();

            // 1. fXenon
            p.fXenon = authContext.IsXenonTitle;

            // 2. fXbox1LiveAccess
            if (authContext.IsXenonTitle)
            {
                // Xenon titles should get this bit unless user is restricted. All tiers get it.
                p.fXbox1LiveAccess = true;
            }
            else
            {
                // Xbox titles never get this bit because they know nothing about privileges.
                // TODO: is this correct?
                p.fXbox1LiveAccess = false;
            }
            // If user is restricted, they never get this privilege, regardless of Xenon/Xbox title
            // Tier 1 (silver) users also do not get this privilege, but I wouldn't stake my life on that
            if (User1.Name.EndsWith("r") || User1.Tier == 1)
            {
                p.fXbox1LiveAccess = false;
            }

            // 3. fBackCompat
            p.fBackCompat = 
                (expected == Yesbc) || 
                (authContext.IsXenonConsole && !authContext.IsXenonTitle && expected == Unauth);

            // 4. ServiceHR (overall)
            p.ServiceHR = HResult.S_OK;

            // "Real" one
            ExpectedHR = p.ServiceHR;

            // 5. ServiceHRs (per service)
            // 5.5 ExpectedServices
            // Xbox title
            if (!authContext.IsXenonTitle)
            {
                if (expected == Notallow || expected == Unauth)
                {
                    p.ServiceHRs = bcXboxServiceHRsBad;
                }
                else
                {
                    p.ServiceHRs = bcXboxServiceHRsGood;
                }

                // "Real" one
                ExpectedServices = bcXboxServices;
                ExpectedHRs = p.ServiceHRs;
            }
            // Xenon title
            else
            {
                if (expected == Notallow || expected == Unauth)
                {
                    p.ServiceHRs = Expectations.k_DefaultExpectedMachineHRs;
                    // "Real" one
                    ExpectedServices = Expectations.k_DefaultExpectedMachineServices;
                }
                else
                {
                    // TODO: make multi-user
                    p.ServiceHRs = Expectations.k_DefaultExpectedHRs[User1.Tier - 1];
                    // "Real" one
                    ExpectedServices = Expectations.k_DefaultExpectedServices[User1.Tier - 1];
                }
                // "Real" one
                ExpectedHRs = p.ServiceHRs;
            }

            // 6. UserHRs (per user)
            if (expected == Notallow)
            {
                if (User1 != null)
                    p.UserHRs[0] = 0x80151200;
                if (User2 != null)
                    p.UserHRs[1] = 0x80151200;
            }

            //restricted users are treated as banned for xbox1 and hence no longer get stats
            if (!authContext.IsXenonTitle)
            {
                if (User1!=null && User1.Name.EndsWith("r"))
                {
                    //dupe the array; we don't want to alter it in place (which alters the original expecteds for everything)
                    ExpectedServices=(uint[])ExpectedServices.Clone();
                    ExpectedHRs=(uint[])ExpectedHRs.Clone();

                    for (int i=0; i<ExpectedServices.Length; ++i)
                    {
                        if (ExpectedServices[i]==7) //stats
                        {
                            ExpectedHRs[i]=HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                        }
                    }
                }
            }

            // Done.
            return p;
        }

        protected void Go(
            AuthContext.ClientTypes clienttype,
            string user1,
            string user2,
            uint expected)
        {
            authContext = new AuthContext(clienttype);
            SetDefaults();
            User1 = SetUser(user1, 0);
            User2 = SetUser(user2, 1);
            Exception actualException = null;

            // Set title info based on whether we're making a Xenon or Xbox TGS request
            if (authContext.IsXenonTitle)
                authContext.TitleInfo = bcTitles[1];
            else
                authContext.TitleInfo = bcTitles[0];

            // Build expectations
            VerifyValuesParams verifyParams = BuildBackCompatExpectations(expected);

            try
            {
                if (authContext.IsXenonTitle)
                {
                    SignInXkdc();
                }
                else
                {
                    // Usernames that end in "r" are not allowed to sign in on Xbox1
                    if (user1 != null && user1.EndsWith("r"))
                    {
                        User1.AddRestriction(new uint[] { TestBase_Xkdc.XPRIVILEGE_XBOX1_LIVE_ACCESS});
                    }
                    if (user2 != null && user2.EndsWith("r"))
                    {
                        User2.AddRestriction(new uint[] { TestBase_Xkdc.XPRIVILEGE_XBOX1_LIVE_ACCESS});
                    }
                    SignInXkdc();
                }
            }
            catch (Exception e)
            {
                if (!(expected == Err && e is ServerTestFramework.Utilities.TimeoutException))
                    throw e;
                actualException = e;
            }

            bool bVerified = false;
            if (expected == Err)
            {
                if (result == null || actualException is ServerTestFramework.Utilities.TimeoutException)
                {
                    bVerified = true;
                    return;
                }
                else
                {
                    Global.RO.Warn("Expected Err (no response), but ServiceResult wasn't null");
                }
            }
            if (expected != Unk && expected != Err)
            {
                bVerified = VerifyValues(result, verifyParams);
            }
            if (!bVerified)
            {
                this.ResultCode = TEST_RESULTS.FAILED;
            }

            // Do our own verification
            if (expected == Unk || expected == Err || bAlwaysLog)
            {
                Authdata_Base ad = result.authData;
                uint []combinedPrivileges=ad.GetCombinedPrivileges();
                uint priv242 = (combinedPrivileges[7] & (1 << (242 - 224)));
                priv242 = (uint)((priv242 > 0) ? 1 : 0);
                Global.RO.Debug("U={0} HR=0x{1:X} ServicesHR[0,1,2]=0x{2:X},0x{3:X},0x{11:X} UserHRs[0]=0x{4:X} MachPUID=0x{5:X} IsXenonTGS={6} bcExpected={7} dwAuthDataFlags={8} Xbox1LiveAccess={9} TI=0x{10:X}",
                    User1.Name,
                    result.ServiceHR, 
                    result.ServiceHRs[0], 
                    result.ServiceHRs[1], 
                    result.UserHRs[0], 
                    authContext.UsersMachine.xuid.qwUserID,
                    authContext.IsXenonTitle ? "yes" : "no",
                    expected,
                    (ad != null) ? ad.AuthDataFlags.ToString() : "n/a/",
                    priv242,
                    authContext.TitleInfo.TitleId,
                    result.ServiceHRs[2]);
            }

        }

        protected bool VerifyValues(XkdcResult sr, VerifyValuesParams p)
        {
            bool bRetVal = true;
            int i;

            Authdata_Base ad = null;
            if (sr != null && sr.authData != null)
                ad = (Authdata_Base)sr.authData;

            // ServiceHR
            if (sr.ServiceHR != p.ServiceHR)
            {
                Global.RO.Warn("ServiceHR: expected 0x{0:X}, got 0x{1:X}",
                    p.ServiceHR,
                    sr.ServiceHR);
                bRetVal = false;
            }

            // Services HRs
            // Broken for Xenon titles, as the order of service HRs depends on the order
            // of ServiceIDs returned. TestBase_Xenon.Verify() should take care of this 
            // verification.
#if flase
            if (p.ServiceHRs != null)
            {
                for (i = 0; i < p.ServiceHRs.Length; i++)
                {
                    if (p.ServiceHRs[i] != sr.ServiceHRs[i])
                    {
                        Global.RO.Warn("ServiceHRs[{0}]: expected 0x{1:X}, got 0x{2:X}",
                            i,
                            p.ServiceHRs[i],
                            sr.ServiceHRs[i]);
                        bRetVal = false;
                    }
                }
            }
#endif

            // User HRs
            if (p.UserHRs != null)
            {
                bool bReturnEarly = false;
                for (i = 0; i < p.UserHRs.Length; i++)
                {
                    if (p.UserHRs[i] != sr.UserHRs[i])
                    {
                        Global.RO.Warn("UserHRs[{0}]: expected 0x{1:X}, got 0x{2:X}",
                            i,
                            p.UserHRs[i],
                            sr.UserHRs[i]);
                        bRetVal = false;
                    }
                    // If expected anything but success for a user, return after this check
                    if (p.UserHRs[i] != HResult.S_OK)
                        bReturnEarly = true;
                }
                if (bReturnEarly)
                    return bRetVal;
            }

            // AuthDataFlags: XenonBackCompat
            bool fBackCompat = (ad.AuthDataFlags & Authdata_Xenon.FLAGS_ISXENONBACKCOMPAT) == Authdata_Xenon.FLAGS_ISXENONBACKCOMPAT;
            if (p.fBackCompat != fBackCompat)
            {
                Global.RO.Warn("dwAuthDataFlags: got {0}, expected fBackCompat flag {1}",
                    ad.AuthDataFlags,
                    p.fBackCompat);
                bRetVal = false;
            }

            // AuthDataFlags: Xenon
            bool fXenon = (ad.AuthDataFlags & Authdata_Xenon.FLAGS_ISXENON) == Authdata_Xenon.FLAGS_ISXENON;
            if (p.fXenon != fXenon)
            {
                Global.RO.Warn("dwAuthDataFlags: got {0}, expected Xenon flag {1}",
                    ad.AuthDataFlags,
                    Authdata_Xenon.FLAGS_ISXENON);
                bRetVal = false;
            }

            // Xbox1 Live Access
            uint priv242 = (ad.GetCombinedPrivileges()[7] & (1 << (242 - 224)));
            bool fXbox1LiveAccess = (priv242 > 0);
            if (p.fXbox1LiveAccess != fXbox1LiveAccess)
            {
                Global.RO.Warn("Xbox1LiveAccess privilege: got {0}, expected {1}",
                    fXbox1LiveAccess,
                    p.fXbox1LiveAccess);
                bRetVal = false;
            }

            return bRetVal;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonFreeTrials.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{

    class TestBase_FreeTrials : TestBase_Xkdc
    {
        override protected void RunTest()
        {
            bVerifyPrivileges = true;
            bVerifyUserHRs = true;

            ExpectedUserHRs = new uint[] { 0 };
        }

    }

    /// <summary>
    /// Xenon-specific tests go here.  Remember, all previous test cases will also be run as Xenon clients.
    /// (Note that there are also non-xenon test in this group, though)
    /// </summary>
    [TestGroup]
    public class XenonFreeTrials : XkdcTestBaseGroup
    {
        public XenonFreeTrials() : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }


        [TestCase, Description("Free Trial test")]
            class FreeTrial_Current_1Priv : TestBase_FreeTrials
        {
            override protected void RunTest()
            {
                UserInfo u = SetUser("xktcntry16t1", 0);
                // get priv 254
                u.AddGrant(new uint[] { 254 });
                SignInXkdc(true);
            }
        }

        [TestCase, Description("Free Trial test")]
            class FreeTrial_Expired_1Priv : TestBase_FreeTrials
        {
            override protected void RunTest()
            {
                UserInfo u = SetUser("xktcntry24t1", 0);
                // don't get priv 254
                SignInXkdc(true);
            }
        }

        [TestCase, Description("Free Trial test")]
            class FreeTrial_Current_2Priv : TestBase_FreeTrials
        {
            override protected void RunTest()
            {
                UserInfo u = SetUser("xktcntry44t1", 0);
                // get priv 254 and 253
                u.AddGrant(new uint[] { 253, 254 });
                ExpectedServices = Expectations.k_DefaultExpectedServices[u.Tier - 1];
                ExpectedHRs = Expectations.k_DefaultExpectedHRs[u.Tier - 1];
                SignInXkdc(true);
            }
        }

        [TestCase, Description("Free Trial test")]
            class FreeTrial_Current_NoAuto : TestBase_FreeTrials
        {
            override protected void RunTest()
            {
                UserInfo u = SetUser("xktcntry25t1", 0);
                ExpectedServices = new uint[] { 8002 };
                ExpectedHRs = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SignInXkdc(false);
            }
        }

        [TestCase, Description("Free Trial test")]
            class FreeTrial_Current_Auto : TestBase_FreeTrials
        {
            override protected void RunTest()
            {
                UserInfo u = SetUser("xktcntry25t1", 0);
                ExpectedServices = Expectations.k_DefaultExpectedServices[u.Tier - 1];
                ExpectedHRs = Expectations.k_DefaultExpectedHRs[u.Tier - 1];
                SignInXkdc(true);
            }
        }

        [TestCase, Description("Free Trial test for silver user in Xbox360")]
            class FreeTrial_Silver_Xenon : TestBase_FreeTrials
        {
            public FreeTrial_Silver_Xenon()
            {
                ClientType = AuthContext.ClientTypes.Xenon;
                bTooManyServicesOk = false;


            }
            override protected void RunTest()
            {
                Global.RO.Debug("With auto discover...");

                UserInfo u = SetUser("xktcntry46t1", 0);
                u.AddGrant(new uint[] { 254 });
                SignInXkdc(true);

                //

                Global.RO.Debug("Without auto discover...");

                ExpectedServices = new uint[] { 8002 };
                ExpectedHRs = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SignInXkdc(false);
            }
        }

        [TestCase, Description("Free Trial test for gold user in Xbox360, no expected impact")]
            class FreeTrial_Gold_Xenon_Auto : TestBase_FreeTrials
        {
            public FreeTrial_Gold_Xenon_Auto()
            {
                ClientType = AuthContext.ClientTypes.Xenon;
            }
            override protected void RunTest()
            {
                UserInfo u = SetUser("xktcntry46t2", 0);
                SignInXkdc(true);
            }
        }

        //more internal work needed for this still
        [TestCase, Ignore, Description("Free Trial test for gold user in PC, no expected impact")]
            class FreeTrial_Gold_PC_Auto : TestBase_FreeTrials
        {
            public FreeTrial_Gold_PC_Auto()
            {
                ClientType = AuthContext.ClientTypes.Panorama;
            }
            override protected void RunTest()
            {
                UserInfo u = SetUser("xktcntry46t2", 0);
                SignInXkdc(true);
            }
        }

        [TestCase, Description("xbox1-only trial, xbox360 silver user playing an xbox360 title (should be unaffected)")]
        class Xbox1Trial_SilverXenon : TestBase_FreeTrials
        {
            public Xbox1Trial_SilverXenon()
            {
                ClientType = AuthContext.ClientTypes.Xenon;
                bTooManyServicesOk = false;
            }
            override protected void RunTest()
            {
                UserInfo u = SetUser("xktxecntry91t1", 0);

                //autodiscover
                Global.RO.Debug("With auto discover...");
                SignInXkdc(true);

                //the service granted by that xbox1-only free trial
                Global.RO.Debug("8002...");
                ExpectedServices = new uint[] { 8002 };
                ExpectedHRs = new uint[]      { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SignInXkdc(false);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonServiceRequest.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Core.Utilities;
using ServerTestFramework.Database;

namespace XkdcTest
{
    [TestGroup, Description("Testing different combinations of pre-auths in a request using KDCClient for XenonServiceRequest2/3"), AsyncGroup(1, 0), AsyncThreadDelay(250), AsyncThreadCount(50)]
    [Owner("LukeL"), TestFrequency("Daily")]
    public class XenonServiceRequest: XkdcTestBaseGroup
    {
        public XenonServiceRequest()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon; //default to xbox360
            DefaultXkdcXenonPreauthVersion=5; //use the new preauth for these by default
        }

        [TestCase, Description("Sign in using default preauths, including XenonServiceRequest2")]
        [TestCasePriority(1), Owner("BenRan")]
        public class XenonDefault_ServiceRequest2 : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                SetUser(0, "xktad4a");
                SetXkdcDefaults();

                ExpectedAuthDataVersion = 3;
                Client.XkdcRequest.Input.XenonPreauthVersion=4; //use the old one
            }

            public override void Run()
            {
                ExecuteXkdc(true);
            }
        };

        [TestCase, Description("Sign in using default preauths, including XenonServiceRequest3")]
        [TestCasePriority(1), Owner("BenRan")]
        public class XenonDefault_ServiceRequest3 : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                SetUser(0, "xktad4a");
                SetXkdcDefaults();
            }

            public override void Run()
            {
                ExecuteXkdc(true);
            }
        };

        [TestCase, Description("Sign in using a XenonServiceRequest2 labeled as a XenonServiceRequest3")]
        [TestCasePriority(3), Owner("BenRan")]
        public class Xenon_ServiceRequest2as3 : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                ExpectXkdcTimeout=true;
                SetUser(0, "xktad4a");
                SetXkdcDefaults();

                Client.XkdcRequest.Input.XenonPreauthVersion=4; //use the old one
            }

            public override void Run()
            {
                // Generate the V4 preauth
                Client.XkdcRequest.Input.GeneratePreauths();

                // Then relabel the V4 preauth as a V5
                Client.XkdcRequest.Input.Preauths[0].Type.Int64 = 214;

                Client.XkdcRequest.SetRequest();
                Client.XkdcRequest.ConstructRequest();

                ExecuteXkdc(false);
            }
        };

        [TestCase, Description("Sign in using a XenonServiceRequest3 labeled as a XenonServiceRequest2")]
        [TestCasePriority(3), Owner("BenRan")]
        public class Xenon_ServiceRequest3as2 : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                ExpectXkdcTimeout=true;
                SetUser(0, "xktad4a");
                SetXkdcDefaults();
            }

            public override void Run()
            {
                // Generate the V5 preauth
                Client.XkdcRequest.Input.GeneratePreauths();

                // Then relabel the V5 preauth as a V4
                //Input.Preauths[1].Type.Int64 = ServerTestFramework.LiveService.Auth.Asn.Kerberos.PreauthXenonServiceRequest2.
                Client.XkdcRequest.Input.Preauths[1].Type.Int64 = 210;

                Client.XkdcRequest.SetRequest();
                Client.XkdcRequest.ConstructRequest();

                ExecuteXkdc(false);
            }
        };

        [TestCase, Description("Make a request using a XenonServiceRequest3 with the wrong version"), TestCasePriority(2)]
        public class Xenon_ServiceRequest3_WrongVersion: TestBase_KdcClient
        {
            public override void Run()
            {
                ExpectXkdcTimeout=true;
                SetXkdcDefaults();

                // Generate the V5 preauth and alter it
                Client.XkdcRequest.Input.GeneratePreauths();
                Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest3> pasr3=Client.XkdcRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest3>>();
                pasr3.Data.RequestVersion=4; //0-4 are invalid for SR3
                pasr3.Data.Encrypt();

                Client.XkdcRequest.SetRequest();
                Client.XkdcRequest.ConstructRequest();

                ExecuteXkdc(false);
            }
        };

        [TestCase, Description("Make a request using a XenonServiceRequest3 with the max value version"), TestCasePriority(2)]
        public class Xenon_ServiceRequest3_High: TestBase_KdcClient
        {
            public override void Run()
            {
                ExpectXkdcTimeout=false;
                SetXkdcDefaults();

                // Generate the V5 preauth and alter it
                Client.XkdcRequest.Input.GeneratePreauths();
                Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest3> pasr3=Client.XkdcRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest3>>();
                pasr3.Data.RequestVersion=0xffff; //5-65535 is valid for SR3
                pasr3.Data.Encrypt();

                Client.XkdcRequest.SetRequest();
                Client.XkdcRequest.ConstructRequest();

                ExecuteXkdc(false);
            }
        };

        [TestCase, Description("Make a request using a XenonServiceRequest2 with the wrong version"), TestCasePriority(2)]
        public class Xenon_ServiceRequest2_WrongVersion_Low: TestBase_KdcClient
        {
            public override void Run()
            {
                ExpectXkdcTimeout=true;
                SetXkdcDefaults();

                // Generate the V4 preauth and alter it
                Client.XkdcRequest.Input.XenonPreauthVersion=4;
                Client.XkdcRequest.Input.GeneratePreauths();
                Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest2> pasr2=Client.XkdcRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest2>>();
                pasr2.Data.RequestVersion=3; //only 4 is valid
                pasr2.Data.Encrypt();

                Client.XkdcRequest.SetRequest();
                Client.XkdcRequest.ConstructRequest();

                ExecuteXkdc(false);
            }
        };

        [TestCase, Description("Make a request using a XenonServiceRequest2 with the wrong version"), TestCasePriority(2)]
        public class Xenon_ServiceRequest2_WrongVersion_High: TestBase_KdcClient
        {
            public override void Run()
            {
                ExpectXkdcTimeout=true;
                SetXkdcDefaults();

                // Generate the V4 preauth and alter it
                Client.XkdcRequest.Input.XenonPreauthVersion=4;
                Client.XkdcRequest.Input.GeneratePreauths();
                Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest2> pasr2=Client.XkdcRequest.Input.FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest2>>();
                pasr2.Data.RequestVersion=5; //only 4 is valid
                pasr2.Data.Encrypt();

                Client.XkdcRequest.SetRequest();
                Client.XkdcRequest.ConstructRequest();

                ExecuteXkdc(false);
            }
        };

        public class PreauthXenonServiceRequest2Resizer: Kerberos.PreauthXenonServiceRequest2
        {
            public int SizeToAdd=0;

            public override byte[] GetInnerBytes()
            {
                byte []blob=(byte[])base.GetInnerBytes().Clone();
                System.Array.Resize(ref blob, blob.Length+SizeToAdd);
                return blob;
            }
        }

        public class PreauthXenonServiceRequest3Resizer: Kerberos.PreauthXenonServiceRequest3
        {
            public int SizeToAdd=0;

            public override byte[] GetInnerBytes()
            {
                byte []blob=(byte[])base.GetInnerBytes().Clone();
                System.Array.Resize(ref blob, blob.Length+SizeToAdd);
                return blob;
            }
        }

        [TestCase, AsyncGroup(2), Description("Make a request using a XenonServiceRequest with the correct fields set but th preauth structure itself being the wrong size")]
        [TestCasePriority(2)]
        [CompoundCase("V4, 1 Too Small",   4, -1)]
        [CompoundCase("V4, 100 Too Small", 4, -100)]
        [CompoundCase("V4, 1 Too Big",     4, 1)]
        [CompoundCase("V4, 100 Too Big",   4, 100)]
        [CompoundCase("V5, 1 Too Small",   5, -1)]
        [CompoundCase("V5, 100 Too Small", 5, -100)]
        [CompoundCase("V5, 1 Too Big",     5, 1)]
        [CompoundCase("V5, 100 Too Big",   5, 100)]
        public class Xenon_ServiceRequest2_StructWrongSize: TestBase_KdcClient
        {
            public override void Run()
            {
                int preauthVersion=(int)MyValues[0];
                int resizeDelta=(int)MyValues[1];

                ExpectXkdcTimeout=true;
                SetXkdcDefaults();

                // Generate the V4 preauth and alter it
                Client.XkdcRequest.Input.XenonPreauthVersion=(uint)preauthVersion;
                Client.XkdcRequest.Input.GeneratePreauths();

                if (preauthVersion==4)
                {
                    Kerberos.Preauth<PreauthXenonServiceRequest2Resizer> pa=new Kerberos.Preauth<PreauthXenonServiceRequest2Resizer>();
                    pa.Data.SizeToAdd=resizeDelta;
                    ((XkdcXbox360RequestInput)(Client.XkdcRequest.Input)).PopulateServiceRequest(pa.Data);
                    pa.Data.EncryptionKey=Client.XkdcRequest.Input.Key;
                    pa.Data.EncryptionNOnce=Client.XkdcRequest.Input.NOnce;
                    pa.Data.Encrypt();

                    Client.XkdcRequest.Input.Preauths[0]=pa;
                }
                else if (preauthVersion==5)
                {
                    Kerberos.Preauth<PreauthXenonServiceRequest3Resizer> pa=new Kerberos.Preauth<PreauthXenonServiceRequest3Resizer>();
                    pa.Data.SizeToAdd=resizeDelta;
                    ((XkdcXbox360RequestInput)(Client.XkdcRequest.Input)).PopulateServiceRequest(pa.Data);
                    pa.Data.EncryptionKey=Client.XkdcRequest.Input.Key;
                    pa.Data.EncryptionNOnce=Client.XkdcRequest.Input.NOnce;
                    pa.Data.Encrypt();

                    Client.XkdcRequest.Input.Preauths[1]=pa;
                }
                else
                {
                    throw new System.Exception("preauth should only be 4 or 5");
                }

                Client.XkdcRequest.SetRequest();
                Client.XkdcRequest.ConstructRequest();

                ExecuteXkdc(false);
            }
        };
    }//class PreAuthXkdc_Managed
}; //namespace XkdcTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonMachineLogon.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    /// <summary>
    /// Xenon-specific tests go here.  Remember, all previous test cases will also be run as Xenon
    /// clients.
    /// </summary>

    // Extend base class to set defaults for entire test group
    abstract public class TestBase_Xenon_MachineLogon : TestBase_Xkdc
    {
        public override void SetDefaults()
        {
            base.SetDefaults ();
            bVerifyPrivileges = false;
            bVerifyAuthdata = true;
        }
    }


    [TestGroup]
    public class XenonMachineLogon : XkdcTestBaseGroup
    {
        public XenonMachineLogon() : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }

        #region MachineLogonServices

        [TestCase, Description("Xenon machine logon test: <auto discover>")]
            class Machine_Auto : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 0 service , 4 dword services<no auto discover>")]
            class Machine_0Service4Dword : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 8001,8004,8005,8010 };
                ExpectedHRs      = new uint[] {    0,   1,   1,   1 };
                ExpectedADVersion=3;
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 0 service , 3 dword services<no auto discover>")]
        class Machine_0Service3Dword : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                bVerifyAuthdata = false;
                ExpectedServices = new uint[] { 8004, 8005, 8010 };
                ExpectedHRs = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 1, 1 };
                ExpectedADVersion=3;
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 1 service <no auto discover>")]
            class Machine_1Service0Dword : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 2 };
                ExpectedHRs      = new uint[] { 0 };
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 1 service, 4 dword services <no auto discover>")]
            class Machine_1Service4Dword : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 2,8001,8004,8005,8010 };
                ExpectedHRs      = new uint[] { 0,   1,   1,   HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED,   1 };
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 8 service , 4 dword services<no auto discover>")]
            class Machine_8Service2Dword : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 2,3,4,5,11,12,18,8001,8004 };
                ExpectedHRs      = new uint[] { 0,0,0,0, 0, 0, 0,   1,   1 };
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 1 user service <no auto discover>")]
            class Machine_1UserService0Dword : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                bVerifyAuthdata = false;  // we won't get a valid ticket back
                ExpectedServices = new uint[] { 1 };
                ExpectedHRs      = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                ClearUsers();
                SignInXkdc();
            }
        }


        [TestCase, Description("Xenon machine logon test: 8 service , 2 dword services<no auto discover>")]
            class Machine_2Service2Dword_Site2 : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 12,18,8001,8004 };
                ExpectedHRs      = new uint[] {  0, 0,   1,   1 };
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 1 user service, 1 machine service <no auto discover>")]
            class Machine_2Service0Dword_UserMix : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 1, 2 };
                ExpectedHRs      = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 0 };
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 1 user service, 1 machine dword service <no auto discover>")]
            class Machine_1Service1Dword_UserMix : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                bVerifyAuthdata = false;  // we won't get a valid ticket back
                ExpectedServices = new uint[] { 1, 8001 };
                ExpectedHRs      = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 1 };
                ClearUsers();
                SignInXkdc();
            }
        }
 
        [TestCase, Description("Xenon machine logon test: 1 user service, 1 machine service same site, 1 machine dword service <no auto discover>")]
            class Machine_2Service1Dword_UserMix : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 1, 2, 8001 };
                ExpectedHRs      = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 0, 1 };
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 2 machine dword service (user and machine) <no auto discover>")]
            class Machine_0Service2Dword_UserMix : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 8001, 8005 };
                ExpectedHRs      = new uint[] { 0, 1 };
                ExpectedADVersion=3;
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 17 base services, 0 dword services, mixed <no auto discover>")]
            class Machine_17Service0Dword_UserMix : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices    = new uint[] { 1,                                             2,3,4,5,6,                                             7,8,                                              9, 11,12,13,                                             14,                                             15,                                             16,                                             18,19 };
                ExpectedHRs         = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED,0,0,0,0,HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED,0,HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 0, 0, 0, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 0, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                ClearUsers();
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon machine logon test: 17 base services, 4 dword services, mixed <no auto discover>")]
            class Machine_17Service4Dword_UserMix : TestBase_Xenon_MachineLogon
        {
            override protected void RunTest()
            {
                ExpectedServices    = new uint[] { 1,                                             2,3,4,5,6,                                             7,8,                                              9, 11,12,13,                                             14,                                             15,                                             16,                                             18,19,                                             8001, 8002, 8004, 8010 };
                ExpectedHRs         = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED,0,0,0,0,HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED,0,HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 0, 0, 0, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 0, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 1,    1,    1,    1};
                ClearUsers();
                SignInXkdc();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonPrivileges.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    /// <summary>
    /// Xenon-specific tests go here.  Remember, all previous test cases will also be run as Xenon
    /// clients.
    /// </summary>

    // Extend base class to set defaults for entire test group
    abstract public class TestBase_Xenon_Privileges : TestBase_Xkdc
    {
        protected XonlinepUser CachedMachineAccount = null;
        protected ConsoleCertificate CachedConsoleCert = null;

        public override void SetDefaults()
        {
            base.SetDefaults();
            this.bVerifyAuthdata = true;
            this.bVerifyPrivileges = true;
        }

        protected void DoUsers(string user1, string user2, string user3, string user4)
        {
            // Clear stuff
            authContext = new AuthContext();
            if (CachedMachineAccount == null)
            {
                XmacsClient xmacs = new XmacsClient(authContext);
                xmacs.SignInXmacs();
                CachedMachineAccount = authContext.UsersMachine;
                CachedConsoleCert = authContext.ConsoleCert;
            }
            else
            {
                authContext.UsersMachine = CachedMachineAccount;
                authContext.ConsoleCert = CachedConsoleCert;
            }
            SetDefaults();


            // If we clear these, they will get built automatically based on the users we are 
            // signing in with.
            //this.ExpectedServices = null;
            //this.ExpectedHRs = null;

            // SetUser creates a UserInfo object, which encodes a lot of information
            // about the users.  It should know about all of the users used by these
            // tests.
            SetUser(user1, 0);
            SetUser(user2, 1);
            SetUser(user3, 2);
            SetUser(user4, 3);
            try
            {
                if (!SignInXkdc())
                {
                    Global.RO.Info("Unexpected test result for [{0},{1},{2},{3}]", 
                        user1 == null ? "0" : user1,
                        user2 == null ? "0" : user2,
                        user3 == null ? "0" : user3,
                        user4 == null ? "0" : user4);
                }
            }
            catch (System.Runtime.InteropServices.COMException e)
            {
                ro.Error("Got exception for user1={0}, user2={1}",
                    user1,
                    user2);
                throw e;
            }
            catch (KerbErrException e)
            {
                Fail("Got Kerb exception for user1={0}, user2={1}: {2}",
                    user1,
                    user2,
                    e.KerbErr.ToString());
            }

            PrintPrivileges();
        }
    }

    [TestGroup]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XenonPrivileges : XkdcTestBaseGroup
    {
        public XenonPrivileges() : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }

        #region SingleUserLogon

        // Logon with users in tier 1 with users who have none, some, and all grants 
        // and restrictions.  Phew.
        [TestCase, Description("Xenon single user logon test privilege combos: auto-discover")]
            class SingleUserLogon_AllCombos_Tier1 : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                for (int idx = 0; idx < k_UsersStartIdxTier2; idx++)
                {
                    DoUsers(k_AllTestUsers[idx], null, null, null);
                }
            }
        }

        // Logon with users in tier 2 with users who have none, some, and all grants 
        // and restrictions.  Phew.
        [TestCase, Description("Xenon single user logon test privilege combos: auto-discover")]
            class SingleUserLogon_AllCombos_Tier2 : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                for (int idx = k_UsersStartIdxTier2; idx < k_AllTestUsers.Length; idx++)
                {
                    DoUsers(k_AllTestUsers[idx], null, null, null);
                }
            }
        }

        // Logon with users who belong to medium or restricted parental control groups
        [TestCase, Description("Xenon single user logon test privilege combos: auto-discover")]
            class SingleUserLogon_ParentalControlGroups : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                DoUsers("xktdupcg1t2a", null, null, null);
                DoUsers("xktdupcg1t2ar", null, null, null);
                DoUsers("xktdupcg1t2d", null, null, null);
            }
        }

        #endregion

        #region Multi2UserLogon

        [TestCase, Description("Xenon user logon test multi: all 2-way combos of users")]
            class Multi2UserLogon_AllCombos_Tier1 : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                // Tier 1
                for (int idx1 = 0; idx1 < k_UsersStartIdxTier2; idx1++)
                {
                    // What happens if the same user logs in on two ports at once?
                    //   [user1, user1]
                    // That's not tested here.
                    // We will test symmetric logins, i.e.
                    //   [user1, user2] and [user2, user1]

                    // Tier 1
                    for (int idx2 = 0; idx2 < k_UsersStartIdxTier2; idx2++)
                    {
                        if (idx1 == idx2)
                            continue;
                        DoUsers(k_AllTestUsers[idx1], k_AllTestUsers[idx2], null, null);
                        System.Threading.Thread.Sleep(100);
                    }
                }
            }
        }

        [TestCase, Description("Xenon user logon test multi: all 2-way combos of users")]
            class Multi2UserLogon_AllCombos_Tier2 : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                // Tier 2
                for (int idx1 = k_UsersStartIdxTier2; idx1 < k_AllTestUsers.Length; idx1++)
                {
                    // Tier 2
                    for (int idx2 = k_UsersStartIdxTier2; idx2 < k_AllTestUsers.Length; idx2++)
                    {
                        if (idx1 == idx2)
                            continue;
                        DoUsers(k_AllTestUsers[idx1], k_AllTestUsers[idx2], null, null);
                    }
                }
            }
        }

        [TestCase, Description("Xenon user logon test multi: all 2-way combos of users")]
            class Multi2UserLogon_AllCombos_CrossTier : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                // Tier 1
                for (int idx1 = 0; idx1 < k_UsersStartIdxTier2; idx1++)
                {
                    // Tier 2
                    for (int idx2 = k_UsersStartIdxTier2; idx2 < k_AllTestUsers.Length; idx2++)
                    {
                        if (idx1 == idx2)
                            continue;
                        DoUsers(k_AllTestUsers[idx1], k_AllTestUsers[idx2], null, null);
                        System.Threading.Thread.Sleep(100);
                    }
                }
            }
        }

        // Logon special user with all other users
        [TestCase, Description("Xenon user logon test multi: all 2-way combos of users")]
            class Multi2UserLogon_AllUsers_ParentalControlGroup : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                string[] users = new string[] 
                {
                    "xktdupcg1t2a",
                    "xktdupcg1t2ar",
                    "xktdupcg1t2d"
                };

                foreach (string u in users)
                {
                    DoUsers(u, "xktusert1a", null, null);
                    DoUsers(u, "xktusert2a", null, null);
                    DoUsers(u, "xktusert2d", null, null);
                    DoUsers(u, "xktusert2e", null, null);
                    DoUsers(u, "xktduusert2ar", null, null);
                    DoUsers("xktusert1a", u, null, null);
                    DoUsers("xktusert2a", u, null, null);
                    DoUsers("xktusert2d", u, null, null);
                    DoUsers("xktusert2e", u, null, null);
                    DoUsers("xktduusert2ar", u, null, null);
                }
            }
        }

        #endregion

        #region Multi3UserLogon

        [TestCase, Description("Xenon user logon test multi: user 2a and 2b and 2d, result 2b")]
            class Multi3Logon_1 : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                SetUser("xktusert2a", 0);
                SetUser("xktusert2b", 1);
                SetUser("xktusert2d", 2);
                SignInXkdc();
                PrintPrivileges();
            }
        }

        [TestCase, Description("Xenon user logon test multi: user 2a and 2b and 2c and 2d, result 2b")]
            class Multi4Logon_1 : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                SetUser("xktusert2a", 0);
                SetUser("xktusert2b", 1);
                SetUser("xktusert2c", 2);
                SetUser("xktusert2d", 3);
                SignInXkdc();
                PrintPrivileges();
            }
        }

        #endregion

        #region TitleAndOfferGrant

        [TestCase, Description("Xenon user logon: regular user, with grant from offer")]
            class OfferGrant : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                // Offer grants privilege 192.

                // UserWithOfferGrant
                // A regular user whose offer grants an extra privilege.
                authContext.ClearXkdc();
                SetUser("xktsub1", 0);
                SignInXkdc();
                PrintPrivileges();

                // UserRestrictedWithOfferGrant
                // Even though this user's offer grants a privilege, he is explicitly denied it. 
                // Should not be granted the privilege.
                authContext.ClearXkdc();
                SetUser("xktrestrictedt2", 0);
                SignInXkdc();
                PrintPrivileges();

                // UserGrantedwithOfferGrant
                // User with explicitly granted privilege also has offer that grants the privilege.
                // Should get the privilege.
                authContext.ClearXkdc();
                SetUser("xktgrantedt2", 0);
                SignInXkdc();
                PrintPrivileges();
            }
        }

        [TestCase, Description("Xenon user logon: regular user, with restriction from offer")]
            class OfferRestrict : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                // Offer restricts privilege 192, 255,254, 245,244.
                authContext.ClearXkdc();
                SetUser("xktofferprivres", 0);
                SignInXkdc();
                PrintPrivileges();

                if (!XkdcTestBaseGroup.settingXkdcSubscriptionBackCompat && ResultCode!=TEST_RESULTS.PASSED)
                {
                    Global.RO.Info("Privilege restrictions are no longer supported, so ignoring this failure.");
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        // Title 0x3DEF0802 grants privileges
        [TestCase, Description("Xenon user logon: title grants privilege")]
        class TitleGrant : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                UserInfo user;
                authContext.SetTitle(0x3DEF0802, 1, 1); // Title grants privilege 193

                for (int idx = 0; idx < k_AllTestUsers.Length; ++idx)
                {
                    SetDefaults();
                    user = SetUser(k_AllTestUsers[idx]);
                    if (user.Name[9]!='e')
                        user.AddGrant(new uint[] { 193 });
                    if (!SignInXkdc())
                        ro.Warn("TitleGrant failed for user {0}\n", user.Name);

                    PrintPrivileges();
                }
            }
        }

        // Title 0x3DEF0803 grants privileges to gold tier
        [TestCase, Description("Xenon user logon: title grants privilege to gold tier")]
        class TitleGrantByTier : TestBase_Xenon_Privileges
        {
            override protected void RunTest ()
            {
                UserInfo user;
                authContext.SetTitle(0x3DEF0803, 1, 1); // Title grants privilege 193

                for (int idx = 0; idx < k_AllTestUsers.Length; ++idx)
                {
                    SetDefaults();
                    user = SetUser(k_AllTestUsers[idx]);
                    if (user.Tier == 2 && user.Name[9] != 'e')
                        user.AddGrant(new uint[] { 193 });
                    if (!SignInXkdc())
                        ro.Warn("TitleGrant failed for user {0}\n", user.Name);

                    PrintPrivileges();
                }
            }
        }

        //
        [TestCase, Description("Xenon user logon: title not granting the privelege")]
            class TitleNoGrant : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                UserInfo user;
                authContext.SetTitle(0xC0FE0800, 1, 1); // Title does not grant privilege 193

                for (int idx = 0; idx < k_AllTestUsers.Length; ++idx)
                {
                    SetDefaults();
                    user = SetUser(k_AllTestUsers[idx]);
                    if (user.Name[9]=='f') continue; //f is just bad for this case due to how uodb table grants work
                    user.RemoveGrant(new uint[] { 193 });

                    if (!SignInXkdc())
                        ro.Warn("TitleNoGrant failed for user {0}\n", user.Name);

                    if (WasPrivelegeOffered(193,0))
                        Fail("User {0} got privilege 193", user.Name);
                    else
                        ro.Debug("User {0} did not get privelege 193 (good)", user.Name);

                    PrintPrivileges();
                }
            }
        }

        [TestCase, Description("Xenon user logon: title and offer grant privileges")]
            class TitleAndOfferGrant : TestBase_Xenon_Privileges
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0x3DEF0802, 1, 1);
                UserInfo user;

                // Combine TitleGrant with OfferGrant

                // Title grants 193
                // Offer grants 192
                // User restricted from both
                user = SetUser("xktrestrictedt2");
                if (!SignInXkdc())
                    ro.Warn("TitleAndOfferGrant1 failed for user {0}\n", user.Name);

                // Title grants 193
                // Offer grants 192
                // User granted both.
                user = SetUser("xktgrantedt2");
                user.AddGrant(new uint[] { 193 });  // from title
                if (!SignInXkdc())
                    ro.Warn("TitleAndOfferGrant2 failed for user {0}\n", user.Name);

                // Title grants 193
                // Offer grants 192
                // User has no grants, no restrictions
                user = SetUser("xktsuball");
                user.AddGrant(new uint[] { 193 });
                if (!SignInXkdc())
                    ro.Warn("TitleAndOfferGrant3 failed for user {0}\n", user.Name);

                PrintPrivileges();
            }
        }

        [TestCase, Description("Xenon multi-user logon: title and offer grant privileges")]
            class TitleAndOfferGrant_Multi : TestBase_Xenon_Privileges
        {
            protected TEST_RESULTS Go(XeTitleInfo ti)
            {
                TEST_RESULTS returnVal = TEST_RESULTS.PASSED;

                uint[] privTI = new uint[] { 193 };

                UserInfo[] user1 = new UserInfo[]
                    {
                        new UserInfo("xktsuball"),
                        new UserInfo("xktsuball"),
                        new UserInfo("xktgrantedt2"),
                        new UserInfo("xktrestrictedt2"),
                        new UserInfo("xktsuball"),
                        new UserInfo("xktgrantedt2"),
                        new UserInfo("xktgrantedt2"),
                        new UserInfo("xktsub1"),
                        new UserInfo("xktsub1")
                    };
                UserInfo[] user2 = new UserInfo[]
                    {
                        new UserInfo("xktusert2a"),
                        new UserInfo("xktusert2d"),
                        new UserInfo("xktusert2a"),
                        new UserInfo("xktusert2a"),
                        new UserInfo("xktusert1a"),
                        new UserInfo("xktusert1b"),
                        new UserInfo("xktrestrictedt2"),
                        new UserInfo("xktusert2a"),
                        new UserInfo("xktrestrictedt2")
                    };

                // Combine TitleGrant with OfferGrant
                authContext.TitleInfo = ti;
                for (int idxUser = 0; idxUser < user1.Length; idxUser++)
                {
                    SetDefaults();
                    UserInfo u1 = SetUser(user1[idxUser], 0);
                    UserInfo u2 = SetUser(user2[idxUser], 1);

                    // Title grants 193?
                    if ((uint)ti.TitleId == 0x3DEF0802)
                    {
                        // Title grants 193, but only if not already restricted by the user
                        if (!user1[idxUser].IsRestricted(privTI[0]))
                            u1.AddGrant(privTI);
                        if (!user2[idxUser].IsRestricted(privTI[0]))
                            u2.AddGrant(privTI);
                    }
                    else
                    {
                        // Title does not grant 193
                        u1.AddRestriction(privTI);
                        u2.AddRestriction(privTI);
                    }

                    if (!SignInXkdc())
                    {
                        Global.RO.Warn("TitleAndOfferGrant_Multi failed for TI=0x{0:X}, users {1}, {2}", 
                            ti.TitleId, u1.Name, u2.Name);
                        returnVal = TEST_RESULTS.FAILED;
                    }

                    PrintPrivileges();
                }
                return returnVal;
            }

            override protected void RunTest()
            {
                // We can only sign in with 1 title at a time, of course, but we can use various
                // combinations of users.  1 user will have a base offer that grants a privilege,
                // and the other will not.  Try this combination with a title that grants a privilege
                // and a title that does not.

                ResultCode = TEST_RESULTS.PASSED;
                if (ResultCode == TEST_RESULTS.PASSED)
                    ResultCode = Go(new XeTitleInfo(0xC0FE0800, 1, 1));     // no grant
                if (ResultCode == TEST_RESULTS.PASSED)
                    ResultCode = Go(new XeTitleInfo(0x3DEF0802, 1, 1));     // grant
            }
        }
        #endregion


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonTitles.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{

    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(100), AsyncThreadCount(8)]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XenonTitles : XkdcTestBaseGroup
    {
        public XenonTitles()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
            Name = GetType().Name;

            // Add new tests here
            //

            // Machine logons
            AddThem(null, null);

            // 1 user logons
            // Do we REALLY need to sign in with all of these users?
            // I'm thinking no. This generates a hella lot of test cases.
            // Let's be smart and trim it down some.
            AddThem("xktusert1a", null);
            AddThem("xktusert2a", null);

//            for (int i = 0; i < TestBase_Xenon2.k_AllTestUsers.Length; i++)
//            {
//                AddThem(TestBase_Xenon2.k_AllTestUsers[i], null);
//            }

            // Add a handful of cases to verify the dwAltTitleId hack in the Authdata
            Add(new XeTitles(null, null, 0x3EEF0800, 0, 0, 0, 0x3EEF0800, 0, 0), true);
            Add(new XeTitles(null, null, 0x3EEF0833, 0, 1, 1, 0x33feebff, 3, 0x3EEF0833), true);
            Add(new XeTitles("xktusert2a", null, 0x3EEF0800, 0, 0, 0, 0x3EEF0800, 0, 0), true);
            Add(new XeTitles("xktusert2a", null, 0x3EEF0830, 1, 0, 0, 0x03feebff, 0, 0), true);
            Add(new XeTitles("xktusert2a", null, 0x3EEF0832, 1, 0, 0, 0x3EEF0832, 3, 0x23feebff), true);
            Add(new XeTitles("xktusert2a", null, 0x3EEF0833, 0, 1, 1, 0x33feebff, 3, 0x3EEF0833), true);
            Add(new XeTitles("xktusert1a", null, 0x3EEF0833, 0, 1, 1, 0x33feebff, 3, 0x3EEF0833), true);

        }

        protected void Add(XeTitles test, bool bVerifyTitleAuthdata)
        {
            test.bVerifyTitleAuthdata = true;
            test.Name += "_VerifyAuthdata";
            AddChild(test);
        }

        protected void AddThem(string u1, string u2)
        {
            // The database looks like this:
            //0x3EEF0830	0	0	0x03FEEBFF	0	0	0	0	0	0	0	0	0	0	0	0	$now
            //0x3EEF0831	0	0	0x03FEEBFE	0	0	0	0	0	0	0	0	0	0	0	0	$now
            //0x3EEF0831	1	0	0x13FEEBFF	0	0	0	0	0	0	0	0	0	0	0	0	$now
            //0x3EEF0831	0	1	0x13FEEBFE	0	0	0	0	0	0	0	0	0	0	0	0	$now
            //0x3EEF0831	1	1	0x13FEEBFD	0	0	0	0	0	0	0	0	0	0	0	0	$now
            //0x3EEF0832	0	0	0x3EEF0832	0	0	0	0	3	0x23feebff	0	0	0	0	0	0	$now
            //0x3EEF0832	1	0	0x3EEF0832	0	0	0	0	3	0x23feebff	0	0	0	0	0	0	$now
            //0x3EEF0832	1	2	0x3EEF0830	0	0	0	0	3	0x3EEF0831	0	0	0	0	0	0	$now
            //0x3EEF0833	1	1	0x33FEEBFF	0	0	0	0	3	0x3EEF0833	0	0	0	0	0	0	$now

            // Titles with no entry in t_alternate_titleids should get their own
            // title returned in dwLiveTitleId
            //
            //               U1  U2  TitleId     V  R  M  LiveTId     S  T

            // Mainline, no entry
            AddChild(new XeTitles(u1, u2, 0x3EEF0800, 0, 0, 0, 0x3EEF0800, 0, 0));
            AddChild(new XeTitles(u1, u2, 0x3EEF0830, 0, 1, 1, 0x03feebff, 0, 0));

            // Mainline Xenon dash title
            AddChild(new XeTitles(u1, u2, 0xFFFE07D1, 1, 1, 0, 0xFFFE07D1, 0, 0));

            // See uodb-xkdctest.ini [t_alternate_titleids] for what's going on here.
            //               U1  U2  TitleId     V  R  M  LiveTId     S  T
            AddChild(new XeTitles(u1, u2, 0x3EEF0830, 1, 0, 0, 0x03feebff, 0, 0));
            AddChild(new XeTitles(u1, u2, 0x3EEF0830, 2, 0, 0, 0x03feebff, 0, 0));
            AddChild(new XeTitles(u1, u2, 0x3EEF0831, 1, 0, 0, 0x03feebfe, 0, 0));
            AddChild(new XeTitles(u1, u2, 0x3EEF0831, 1, 1, 0, 0x13feebff, 0, 0));
            AddChild(new XeTitles(u1, u2, 0x3EEF0831, 1, 0, 1, 0x13feebfe, 0, 0));
            AddChild(new XeTitles(u1, u2, 0x3EEF0831, 1, 2, 2, 0x03feebfe, 0, 0));
            AddChild(new XeTitles(u1, u2, 0x3EEF0831, 2, 0, 0, 0x03feebfe, 0, 0));
            AddChild(new XeTitles(u1, u2, 0x3EEF0832, 1, 0, 0, 0x3EEF0832, 3, 0x23feebff));
            AddChild(new XeTitles(u1, u2, 0x3EEF0832, 1, 1, 0, 0x3EEF0832, 3, 0x23feebff));
            AddChild(new XeTitles(u1, u2, 0x3EEF0832, 1, 1, 2, 0x3EEF0830, 3, 0x3EEF0831));
            AddChild(new XeTitles(u1, u2, 0x3EEF0833, 0, 1, 1, 0x33feebff, 3, 0x3EEF0833));
            AddChild(new XeTitles(u1, u2, 0x3EEF0833, 0, 2, 1, 0x33feebff, 3, 0x3EEF0833));
            AddChild(new XeTitles(u1, u2, 0x3EEF0833, 1, 1, 1, 0x33feebff, 3, 0x3EEF0833));
        }
    }


    // Extend base class to set defaults for entire test group
    public class XeTitles : TestBase_Xkdc
    {
        string User1;
        string User2;
        uint TitleId;
        uint TitleVersion;
        uint Region; 
        uint MediaId; 
        uint ExpectedLiveTitleId; 
        uint ExpectedAltSvcId; 
        uint ExpectedAltSvcTitleId;

        public bool bVerifyTitleAuthdata = false;

        public XeTitles(
            string User1,
            string User2,
            uint TitleId, 
            uint TitleVersion,
            uint Region, 
            uint MediaId, 
            uint ExpectedLiveTitleId, 
            uint ExpectedAltSvcId, 
            uint ExpectedAltSvcTitleId)
        {
            // Save parameters
            this.User1 = User1;
            this.User2 = User2;
            this.TitleId = TitleId;
            this.TitleVersion = TitleVersion;
            this.Region = Region;
            this.MediaId = MediaId;
            this.ExpectedLiveTitleId = ExpectedLiveTitleId;
            this.ExpectedAltSvcId = ExpectedAltSvcId;
            this.ExpectedAltSvcTitleId = ExpectedAltSvcTitleId;

            // Change name of test
            SetName();
        }

        public void SetName()
        {
            // Name of test will be:
            //   "AltTitles"
            //   [Last byte of Title ID]_[Version]_[Region]_[MediaId]
            //   "Machine" or [User1] or [User1]_[User2]
            string prefix = "AltTitles";
            if (ExpectedLiveTitleId == TitleId && ExpectedAltSvcTitleId == 0)
            {
                prefix = "AltTitlesNoEntry";
            }
            uint a = TitleId & 0x000000FF;
            string middle = String.Format("T{0:X}_V{1:X}_R{2:X}_M{3:X}", a, TitleVersion, Region, MediaId);
            string user = (User2 == null) ? User1 : User1 + "_" + User2;
            if (user == null)
                user = "Machine";
            this.Name = prefix + "_" + middle + "_" + user;
        }

        override protected void RunTest()
        {
            Go();
        }


        static XonlinepUser CachedMachineAccount = null;

        public void Go()
        {
            // Clear stuff, reset things
            // already done by Execute()
            //SetDefaults();

            // We're going to cache and re-use the machine account to speed this thing up
            if (CachedMachineAccount == null)
            {
                XmacsClient xmacs = new XmacsClient(this.authContext);
                xmacs.SignInXmacs();
                CachedMachineAccount = authContext.UsersMachine;
            }

            // These may be null
            SetUser(User1, 0);
            SetUser(User2, 0);

            authContext.SetTitle(TitleId, TitleVersion, Region);
            authContext.ServiceCtxXe.dwMediaID = MediaId;

            if (!SignInXkdc())
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
            else
            {
                bool bVerify = true;

                // Verify pre-auth fields (in ServiceContext)
                ServiceContextXe ctx = authContext.ServiceCtxXe;
                bVerify = (
                    ctx.dwLiveTitleId == ExpectedLiveTitleId &&
                    ctx.bAltServiceIds[0] == ExpectedAltSvcId &&
                    ctx.dwAltServiceTitleIds[0] == ExpectedAltSvcTitleId);
                if (!bVerify)
                {
                    Global.RO.Debug("Failed ServiceContext check for TitleId 0x{0:X}, dwLiveTitleId=0x{1:X} [exp 0x{4:X}], ServiceId1={2} [exp {5}], ServiceTitleId=0x{3:X} [exp 0x{6:X}]",
                        TitleId,
                        ctx.dwLiveTitleId,
                        ctx.bAltServiceIds[0],
                        ctx.dwAltServiceTitleIds[0],
                        ExpectedLiveTitleId,
                        ExpectedAltSvcId,
                        ExpectedAltSvcTitleId);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                if (bVerifyTitleAuthdata)
                {
                    // Verify authdata. The way this is set in the Authdata v3 is a giant hack,
                    // since we didn't get the proper changes into Authdata_Xenon in time to 
                    // support LiveTitleId and LiveAlternateTitleIds. 
                    // 
                    // ad.dwTitleId             will be the LiveTitleId (usually same as TitleId, unless alternate specified)
                    // ad.dwAltTitleID[0]       will be the TitleId (original)
                    // ad.dwAltTitleID[1..3]    will be the up to 3 LiveAlternateTitleIds with no matching services.
                    //
                    Authdata_Base ad = result.authData;
                    bVerify = (
                        ad.TitleId == ExpectedLiveTitleId &&
                        ad.AltTitleIDs[0] == TitleId &&
                        ad.AltTitleIDs[1] == ExpectedAltSvcTitleId);
                    if (!bVerify)
                    {
                        Global.RO.Debug("Failed AuthData check for TitleId 0x{0:X}, dwTitleId=0x{1:X} [exp 0x{4:X}], dwAltTitleId[0]=0x{2:X} [exp 0x{5:X}], dwAltTitleId[1]=0x{3:X} [exp 0x{6:X}]",
                            TitleId,
                            ad.TitleId,
                            ad.AltTitleIDs[0],
                            ad.AltTitleIDs[1],
                            ExpectedLiveTitleId,
                            TitleId,
                            ExpectedAltSvcTitleId);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonServices.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    /// <summary>
    /// Xenon-specific tests go here.  Remember, all previous test cases will also be run as Xenon
    /// clients.
    /// </summary>
    /// 

    // Extend base class to set defaults for entire test group
    abstract public class TestBase_Xenon_Services : TestBase_Xkdc
    {
        public override void SetDefaults()
        {
            base.SetDefaults ();
            bVerifyPrivileges = false;
            bVerifyServices = true;
            bTooManyServicesOk = false;
        }

        protected bool Go_TitleServices(
            uint TitleId,
            uint TitleVersion,
            string user1, 
            string user2,
            uint[] ExtraServices,
            uint[] ExtraHRs)
        {
            bTooManyServicesOk = false;
            SetUser(user1, 0);
            SetUser(user2, 1);
            authContext.SetTitle(TitleId, TitleVersion, 0);

            // We need to build expectations first, before adding to ExpectedServices, otherwise
            // BuildExpectations won't add its default services to ExpectedServices
//            BuildExpectations();
//
//            if (ExtraServices != null && ExtraHRs != null)
//            {
//                AddToExpectedServices(ExtraServices, ExtraHRs);
//            }

            // Since we are using auto-discover, BuildExpectations will start with these extra services,
            // then add the default expected ones.
            ExpectedServices = ExtraServices;
            ExpectedHRs = ExtraHRs;

            try
            {
                return SignInXkdc(true);
            }
            catch (KerbErrException e)
            {
                if (e.KerbErr.ErrorCode == 0x1D)
                {
                    Global.RO.Error("XKDC returned KerbErr KDC_ERR_SVC_UNAVAILABLE");
                    ResultCode = TEST_RESULTS.FAILED;
                    return false;
                }
            }
            return false;
        }


    }


    [TestGroup]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XenonServices : XkdcTestBaseGroup
    {
        public XenonServices() : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }

        [TestCase, Description("Xenon logon: service 8005, which is not in region_services but user is subscribed to")]
            class NoAuto_1SubscribedService : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // This fails now because services granted by an offer must also be tied to a title.
                // See bug 30702 for details. Currently an offer can only be tied to one title,
                // which makes implementing this test difficult to impossible.
                ExpectedServices = new uint[] { 8005 };
                //ExpectedHRs      = new uint[] { 0 };
                ExpectedHRs      = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SetUser("xktusert2a", 0);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
            }
        }

        #region UserLogonServices
        [TestCase, Description("Xenon logon: service 8004 <no auto discover>, not authorized")]
            class NoAuto_1NonSubscribedService : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 8004 };
                ExpectedHRs  = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SetUser("xktusert2a", 0);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon logon: service 8004, 8005 <no auto discover>, [not auth, 1]")]
            class NoAuto_1Sub1NonSub : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 8004, 8005 };
                ExpectedHRs  = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED, 1 };
                SetUser("xktusert2a", 0);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon logon: service 8004, 8005 <no auto discover>, [0, 1]")]
            class NoAuto_2Sub_DiffSites : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // This fails now because services granted by an offer must also be tied to a title.
                // See bug 30702 for details. Currently an offer can only be tied to one title,
                // which makes implementing this test difficult to impossible.

                //ExpectedServices = new uint[] { 8004, 8005 };
                //ExpectedHRs  = new uint[] { 0, 1 };

                // This title is tied to the offer for services 8006,8007,8008,8009,8010,8011,
                // which include some services we need for this test.  See t_title_offers
                authContext.SetTitle(0x3EEF0821, 1, 1);
                ExpectedServices = new uint[] { 8010, 8011 };
                ExpectedHRs  = new uint[] { 0, 1 };

                SetUser("xktsuball", 0);
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon logon: service 1, 8004 (not sub), 8005 <not auth>, [0, 1, 0]")]
            class NoAuto_2Sub1NonSub_DiffSites : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { 1, 8004, 8005 };
                ExpectedHRs  = new uint[] { 0, 1, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SetUser("xktusert2a", 0);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user tier 2 logon test: no services")]
            class NoAuto_0Services0Dword : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                DisableRetryBehaviour=true;

                try
                {
                    ExpectedServices = new uint[] { };
                    ExpectedHRs  = new uint[] { };
                    SetUser("xktusert2a", 0);
                    SignInXkdc();
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Xenon user logon: 0 base services, 4 DWORD services")]
            class NoAuto_0Services4Dwords : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // This fails now because services granted by an offer must also be tied to a title.
                // See bug 30702 for details. Currently an offer can only be tied to one title,
                // which makes implementing this test difficult to impossible.
                
                authContext.SetTitle(0x3EEF0821, 1, 1);
                ExpectedServices = new uint[] { 8001, 8002, 8004, 8010 };
                //ExpectedHRs  = new uint[] { 0, 0, 1, 1 };
                ExpectedHRs  = new uint[] { 0, 0, 1, 1};
                SetUser("xktsuball", 0);
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user tier 2 logon test: base <no auto discover>")]
        class NoAuto_1Service0Dword : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { (uint)XOService.PresNotification };
                ExpectedHRs  = new uint[] { 0 };
                SetUser("xktusert2a", 0);
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user tier 2 logon test: base <no auto discover>")]
            class NoAuto_1Service4Dword : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices = new uint[] { (uint)XOService.PresNotification, 8001, 8002, 8004, 8010 };
                ExpectedHRs  = new uint[] { 0,    1,    1,    1,    1  };
                SetUser("xktusert2a", 0);
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user logon test: 17 services <no auto discover>")]
        class NoAuto_17Services0Dword : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices    = new uint[] { 1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,18,19 };
                ExpectedHRs         = new uint[] { 0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0 };
                SetUser("xktusert2a", 0);
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected 17 services, got {0}", result.NumServices);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Xenon user logon test: 17 services, 4 Dwords services <no auto discover>")]
            class NoAuto_17Services4Dwords : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices    = new uint[] { 1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,18,19, 8001, 8002, 8004, 8010 };
                ExpectedHRs         = new uint[] { 0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0,    1,    1,    1,    1 };
                SetUser("xktusert2a", 0);
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected {0} services, got {0}", result.NumServices, ExpectedServices.Length);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Xenon user logon test: max services (19 base, 4 dword) <no auto discover>")]
        class NoAuto_MaxServices : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices    = new uint[] { 1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,18,19,20,21,8001,8002,8004,8010 };
                ExpectedHRs         = new uint[] { 0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,   1,   1,   1,   1 };
                SetUser("xktusert2a", 0);
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected {0} services, got {0}", result.NumServices, ExpectedServices.Length);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase(BugID=64740, BugDatabase="Xenon"), Description("Xenon user logon test: 19 base services, 3 dword to repro a prod bug <no auto discover>")]
        class NoAuto_19services3Dwords : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices    = new uint[] { 2,3,4,5,7,9,11,12,18,20,21,1,6,8,13,14,15,16,19,8001,8002,8004 };
                ExpectedHRs         = new uint[] { 0,0,0,0,0,0, 0, 0, 0, 1, 0,0,0,0, 0, 0, 0, 0, 0,   1,   1,   1 };
                SetUser("xktusert2a", 0);
                try
                {
                    SignInXkdc();
                }
                catch (KerbErrException e)
                {
                    if (e.KerbErr.ErrorCode == 0x1D)
                    {
                        Fail("Got KerbError 0x1D (KDC_ERR_SVC_UNAVAILABLE). This is exactly what we don't want to get.");
                        return;
                    }
                    else
                    {
                        throw;
                    }
                }
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected {0} services, got {0}", result.NumServices, ExpectedServices.Length);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        // argh!!
        [TestCase, Ignore, Description("Xenon user logon: auto-discover plus 1 extended service explicitly requested")]
            class MixedAuto_AutoPlus1Extended : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // This fails now because services granted by an offer must also be tied to a title.
                // See bug 30702 for details. Currently an offer can only be tied to one title,
                // which makes implementing this test difficult to impossible.

                SetUser("xktusert2a");
                authContext.SetTitle(0x3EEF0821, 1, 1);
                //SignInXkdc(true, new uint[] { 8005 }, new uint[] { 0 });
                SignInXkdc(true, new uint[] { 8002 }, new uint[] { 1 });
            }
        }

        [TestCase, Description("Verify that a title mismatch for a service from an offer doesn't give the service")]
        class OfferService_TitleMismatch : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0xC0FE0800, 0, 0);
                ExpectedServices    = new uint[] { 8004 };
                ExpectedHRs         = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SetUser("xktusert2a", 0);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected "+ExpectedServices.Length+" services, got {0}", result.NumServices);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Sanity pre-check for multi-user cases")]
        class SingleUser_Sub7 : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0xC0FE0801, 0, 0);
                ExpectedServices    = new uint[] { 8015 };
                ExpectedHRs         = new uint[] { 0 };
                SetUser("xktnewsub7one", 0);
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected "+ExpectedServices.Length+" services, got {0}", result.NumServices);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        #endregion

        #region Auto_TitleServices

        // xktdulsput2a
        // Dual Xenon/Xbox user, lsp user "lspu", tier 2, no grants or restrictions "a"
        // This user's subscription #2 gets services 8002, 8012, 8013. Other one, the main one, gets 8005.
        // Title 0x3EEF0840 grants services 8012, 8013
        // Title 0x3EEF0841 grants service 8002
        // Service 8002 is open to all titles
        // Service 8012 is restricted to title 0x3EEF0840  version 0
        // Service 8013 is restricted to title 0x3EEF0840  version 1

        [TestCase, Description("Xenon user logon: auto-discover services granted by a title")]
            class Auto_TitleServices_Simple: TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // Title grants a service
                Go_TitleServices(0x3EEF0841, 0, "xktdulsput2a", null, 
                    new uint[] { 8002 }, new uint[] { 1 });
            }
        }

        [TestCase, Description("Xenon user logon: auto-discover services granted by a title")]
            class Auto_TitleServices_SimpleControl : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // Basic title
                Go_TitleServices(0x3EEF0800, 0, "xktdulsput2a", null, 
                    null, null);
            }
        }

        [TestCase, Description("Xenon user logon: auto-discover services granted by a title")]
            class Auto_TitleServices_DualUsers: TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // One user's subscription grants access to the auto-discovered LSP title,
                // the other user's does not
                Go_TitleServices(0x3EEF0841, 0, "xktdulsput2a", "xktduusert2a", 
                     new uint[] { 8002 }, new uint[] { 1 });

                // In the Xenon world, the fact that a title or tier grants a service
                // means you should get said service.                
                SetDefaults();
                SetUser("xktdulsput2a", 0);
                SetUser("xktduusert2a", 1);
                ExpectedServices = new uint[] { 8002 };
                ExpectedHRs = new uint[] { 0 };
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user logon: auto-discover services granted by a title")]
            class Auto_TitleServices_RestrictedVer0: TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                Go_TitleServices(0x3EEF0840, 0, "xktdulsput2a", null, 
                    new uint[] { 8012, 8013 }, 
                    new uint[] { 1, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED });

                // Verify correct permissions for these 2 services
                SetDefaults();
                SetUser("xktdulsput2a", 0);
                ExpectedServices = new uint[] { 8012, 8013 };
                ExpectedHRs = new uint[] { 0, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user logon: auto-discover services granted by a title")]
            class Auto_TitleServices_RestrictedVer0_NoSubscription: TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                // User's offer does not provide access to services granted by this title
                Go_TitleServices(0x3EEF0840, 0, "xktduusert2a", null, 
                    new uint[] { 8012, 8013 }, 
                    new uint[] { 1, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED });

                // Verify correct permissions for these 2 services
                SetDefaults();
                SetUser("xktduusert2a", 0);
                ExpectedServices = new uint[] { 8012, 8013 };
                ExpectedHRs = new uint[] { 0, HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user logon: auto-discover services granted by a title")]
            class Auto_TitleServices_RestrictedVer1: TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                Go_TitleServices(0x3EEF0840, 1, "xktdulsput2a", null, 
                    new uint[] { 8012, 8013 }, 
                    new uint[] { 1, 1 });

                // Verify correct permissions for these 2 services
                SetDefaults();
                SetUser("xktdulsput2a", 0);
                ExpectedServices = new uint[] { 8012, 8013 };
                ExpectedHRs = new uint[] { 0, 0 };
                SignInXkdc();
            }
        }

        [TestCase, Description("Xenon user logon: auto-discover services granted by a title")]
            class Auto_TitleServices_RestrictedVer1_DualUsers: TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // One user's subscription grants access to the auto-discovered LSP title,
                // the other user's does not
                Go_TitleServices(0x3EEF0840, 1, "xktdulsput2a", "xktduusert2a", 
                    new uint[] { 8012, 8013 }, 
                    new uint[] { 1, 1 });

                // Verify correct permissions for these 2 services
                SetDefaults();
                SetUser("xktdulsput2a", 0);
                SetUser("xktduusert2a", 1);
                ExpectedServices = new uint[] { 8012, 8013 };
                ExpectedHRs = new uint[] { 0, 0 };
                SignInXkdc();
            }
        }

        [TestCase, Description(""), Ignore] //I believe changes were made to how this title is propped, so this test no longer works.  It should be covered by other cases though.
            class Auto_TitleServices_LSPTestTitleFFFF0072 : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                Go_TitleServices(0xFFFF0072, 0, "xktdulsput2a", null, 
                    new uint[] { 0xFFFF0072 }, new uint[] { 1 });
            }
        }


        #endregion

        #region Auto_Subscriptions

        // xktxesubexpt2 - gold sub (expired)
        // xktxesubexpt1 - silver sub (expired)
        // xktxesubmixt2 - gold sub (expired), silver sub (valid)
        // xktxesublspt2 - gold sub (valid), lsp subscription (#2, expired)
        // xktxesub48ht1 - silver sub (valid), 48 hour gameplay sub (valid)
        // xktxesub48et1 - silver sub (valid), 48 hour gameplay sub (expired)
        // Users with expired subscriptions. 
        // The LSP user's subscription #2 gets services 8002, 8012, 8013.
        // Title 0x3EEF0840 grants services 8012, 8013
        // Title 0x3EEF0841 grants service 8002
        // Service 8002 is open to all titles
        // Service 8012 is restricted to title 0x3EEF0840  version 0
        // Service 8013 is restricted to title 0x3EEF0840  version 1

        [TestCase(BugID=35582, BugDatabase="Xenon"), Description("Xenon user logon: expired subscriptions")]
            class Sub_GoldExpired : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                bVerifyPrivileges = true;
                // I'm seeing 0x1d (KDC_ERR_SVC_UNAVAILABLE) 
                // This is the old, bad thing to expect
                // We expect to see:
                //   User services in site 1 as unauthorized
                //   Machine services in site 1 as 0
                //   User & machine services in other sites as 1
                SetUser("xktxesubexpt2", 0);
                try
                {
                    // Not really extra, but this is the cleanest way of specifying them
                    //NOTE: If new services are added, this may need updated with them
                    uint[] exServices = new uint[] { 1,          6,          8,          13,         14,         15,         16,         19,         27,         29,         30,         31};
                    uint[] exHRs = new uint[] {      0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101};
                    SignInXkdc(true, exServices, exHRs);
                }
                catch (KerbErrException e)
                {
                    if (e.KerbErr.ErrorCode == 0x1D)
                    {
                        Fail("Got KDC_ERR_SVC_UNAVAILABLE, which is precisely what we DON'T want to see.");
                    }
                    else
                    {
                        throw e;
                    }
                }
            }
        }

        [TestCase(BugID=35582, BugDatabase="Xenon"), Description("Xenon user logon: expired subscriptions")]
            class Sub_SilverExpired : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                bVerifyPrivileges = true;
                // We expect to see:
                //   User services in site 1 as unauthorized
                //   Machine services in site 1 as 0
                //   User & machine services in other sites as 1
                SetUser("xktxesubexpt1", 0);
                try
                {
                    // Not really extra, but this is the cleanest way of specifying them
                    //NOTE: If new services are added, this may need updated with them
                    uint[] exServices = new uint[] { 1,          6,          8,          13,         14,         15,         16,         19,         27,         29,         30,         31};
                    uint[] exHRs = new uint[] {      0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101, 0x80151101};
                    SignInXkdc(true, exServices, exHRs);
                }
                catch (KerbErrException e)
                {
                    if (e.KerbErr.ErrorCode == 0x1D)
                    {
                        Fail("Got KDC_ERR_SVC_UNAVAILABLE, which is precisely what we DON'T want to see.");
                    }
                    else
                    {
                        throw e;
                    }
                }
            }
        }

        [TestCase(BugID=35582, BugDatabase="Xenon"), Description("Xenon user logon: expired subscriptions")]
            class Sub_GoldExpired_SilverValid : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                bVerifyPrivileges = true;
                // This use should be verified like a tier 1 (silver) user.
                SetUser("xktxesubmixt1", 0);
                SignInXkdc(true);
            }
        }

        [TestCase(BugID=35582, BugDatabase="Xenon"), Description("Xenon user logon: expired subscriptions")]
            class Sub_GoldValid_LspExpired : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                bVerifyPrivileges = true;
                // This user should be verified like a regular tier 2 (gold) user.
                SetUser("xktxesublspt2", 0);
                SignInXkdc(true);
            }
        }

        [TestCase(BugID=39202, BugDatabase="Xenon"), Description("Xenon silver user with valid 48 hour gameplay")]
            class Sub_SilverValid_48hourValid_Xenon : TestBase_Xenon_Services
        {
            public Sub_SilverValid_48hourValid_Xenon()
            {
                ClientType = AuthContext.ClientTypes.Xenon;
            }
            override protected void RunTest()
            {
                bVerifyPrivileges = true;
                // This should be verified like a tier 2 (gold) user
                SetUser("xktxesub48ht1", 0);
                ExpectedServices = Expectations.k_DefaultExpectedServices[1];
                ExpectedHRs = Expectations.k_DefaultExpectedHRs[1];
                try
                {
                    SignInXkdc(true);
                }
                finally
                {
                    if (result != null)
                        ro.Debug(result.ToString(true));
                }
            }
        }

        [TestCase(BugID=39202, BugDatabase="Xenon"), Description("Xenon silver user with expired 48 hour gameplay")]
            class Sub_SilverValid_48hourExpired_Xenon : TestBase_Xenon_Services
        {
            public Sub_SilverValid_48hourExpired_Xenon()
            {
                ClientType = AuthContext.ClientTypes.Xenon;
            }
            override protected void RunTest()
            {
                bVerifyPrivileges = true;
                // This should be verified like a tier 1 (silver) user
                SetUser("xktxesub48et1", 0);
                ExpectedServices = Expectations.k_DefaultExpectedServices[1];
                ExpectedHRs = Expectations.k_DefaultExpectedHRs[1];
                // Silver users on Xenon get all services.. they just lack some privileges
                try
                {
                    SignInXkdc(true);
                }
                finally
                {
                    if (result != null)
                        ro.Debug(result.ToString(true));
                }
            }
        }

        #endregion

        #region LSP Services for Xbox/Xenon

        // LSP services for Xenon are granted by t_title_services during auto-discovery.
        // Xbox1 LSP services are granted by t_offer_services, which is also a table consulted
        // for auto-discovery.  Bug 46428 fixes this by ignoring offers from t_offer_services that
        // also exist in t_base_offers, which is where base Xenon offers go (to relate them to a 
        // tier).
        //
        // Gold base offer 0xFFFE07D18000000A is in t_offer_services for service 8004.

        [TestCase(BugID=46428, BugDatabase="Xenon"), Description("Sign in a Xenon user to a Xenon title, no LSP service given")]
        class LSP_XenonUser_XenonSignin : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                // Base offer for this user, and all gold users, grants a service

                bTooManyServicesOk = false;
                SetUser("xktduusert2a", 0);
                authContext.SetTitle(0xC0FE0800, 0, 0);
                //ExpectedServices = null;
                //ExpectedHRs = null;
                SignInXkdc(true);
            }
        }

        [TestCase(BugID=94481, BugDatabase="Xenon"), Description("Set autodiscover to a value besides 0 or 1")]
        [CompoundCase("Machine_2", false, 2)]
        [CompoundCase("Machine_FFFF", false, 0xffff)]
        [CompoundCase("User_2", true, 2)]
        [CompoundCase("User_FFFF", true, 0xffff)]
        class AutoDiscoverUnusualValue: TestBase
        {
            override protected void Execute()
            {
                //setup event tracking
                Events evt=new Events(Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.kdcsvc));
                evt.Init();

                //setup context
                bool user=(bool)MyValues[0];
                ushort autoValue;
                unchecked{autoValue=(ushort)(short)(int)MyValues[1];}

                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                AskdcClient askdc=new AskdcClient(ctx);
                XkdcClient xkdc=new XkdcClient(ctx);
                xkdc.EmulateClientRetryAndTimingBehavior=false;
                AskdcClient.SetDefaults(ctx);
                XkdcClient.SetDefaults(ctx);

                //do through askdc
                if (user) ctx.SetUser("xktusert2a", 0);
                askdc.SignInAskdc();

                //do xkdc
                Global.RO.Debug("Doing xkdc request...");
                xkdc.isManualSetup=true;
                xkdc.SetRequest(null,autoValue);

                try
                {
                    xkdc.SignInXkdc();
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                }
                catch (Exception)
                {
                    throw new UnexpectedTestResultException("Expected XKDC to block request, instead it succeeded");
                }

                //check events
                Global.RO.Debug("Verifying eventlog...");
                System.Threading.Thread.Sleep(1000);

                if (!evt.TestForChange("wAutoDiscoverServices was"))
                {
                    throw new UnexpectedTestResultException("Did not find 'wAutoDiscoverServices was' in eventlog");
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        #endregion

        #region MultiUser

        [TestCase, Description("two users, both have access to a service")]
        class MultiUser_Both7 : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0xC0FE0801, 0, 0);
                ExpectedServices    = new uint[] { 8015 };
                ExpectedHRs         = new uint[] { 0 };
                SetUser("xktnewsub7one", 0);
                SetUser("xktnewsub7two", 1);
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected "+ExpectedServices.Length+" services, got {0}", result.NumServices);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("two users, one has access to a service and the other does not")]
        class MultiUser_u0Sub7_u1None : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0xC0FE0801, 0, 0);
                ExpectedServices    = new uint[] { 8015 };
                ExpectedHRs         = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SetUser("xktnewsub7one", 0);
                SetUser("xktusert2a", 1);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected "+ExpectedServices.Length+" services, got {0}", result.NumServices);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("two users, one has access to a service and the other does not")]
        class MultiUser_u0None_u1Sub7 : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0xC0FE0801, 0, 0);
                ExpectedServices    = new uint[] { 8015 };
                ExpectedHRs         = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED };
                SetUser("xktusert2a", 0);
                SetUser("xktnewsub7one", 1);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected "+ExpectedServices.Length+" services, got {0}", result.NumServices);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("two users, both have access to a service, but one is expired")]
        class MultiUser_u0Sub7_u1Expired : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0xC0FE0801, 0, 0);
                ExpectedServices    = new uint[] { 8015 };
                ExpectedHRs         = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED};
                SetUser("xktnewsub7one", 0);
                SetUser("xktnewsub7exp", 1);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected "+ExpectedServices.Length+" services, got {0}", result.NumServices);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("two users, both have access to a service, but one is expired")]
        class MultiUser_u0Expired_u1Sub7 : TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                authContext.SetTitle(0xC0FE0801, 0, 0);
                ExpectedServices    = new uint[] { 8015 };
                ExpectedHRs         = new uint[] { HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED};
                SetUser("xktnewsub7exp", 0);
                SetUser("xktnewsub7one", 1);
                authContext.ExpectXkdcServiceAddressFailed=false; //Need a real service address to tell the caller which services that they requested were rejected
                SignInXkdc();
                if (result.NumServices != ExpectedServices.Length)
                {
                    Global.RO.Warn("Expected "+ExpectedServices.Length+" services, got {0}", result.NumServices);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        #endregion

        [TestCase(BugID=116203, BugDatabase="Xenon"), Description("Regular request with a banned user.  We should get machine-only services except stats.")]
        class UserBanned: TestBase_Xenon_Services
        {
            override protected void RunTest()
            {
                ExpectedServices = (uint[])Expectations.k_DefaultExpectedMachineServices.Clone();
                ExpectedHRs = (uint[])Expectations.k_DefaultExpectedMachineHRs.Clone();

                bool foundStats=false;
                for (int i=0; i<ExpectedServices.Length; ++i)
                {
                    if (ExpectedServices[i]==7)
                    {
                        foundStats=true;
                        ExpectedHRs[i]=HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
                    }
                }

                if (!foundStats)
                {
                    throw new System.Exception("test error: Stats was not in the expected list to change exceptation.");
                }

                if (DefaultXkdcXenonPreauthVersion>=6)
                {
                    bVerifyServices=false; //service address failed doesn't have services
                    bVerifyUserFlags=false; //service address failed has no user flags
                }

                SetUser("xktbanned", 0);
                SignInXkdc();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonTwinSeparation.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;

namespace XkdcTest
{
    [TestGroup, Description("Tests for detecting and separating xenon consoles that were mis-manufactered such that two consoles share the same console ID.")]
    public class XenonTwinSeparation: TestNode
    {
        //Sets up an xmacs request for a machine with random console ID and a random key pair
        public static KdcClientXbox360 GenerateRandomXmacsRequest()
        {
            KdcClientXbox360 client=new KdcClientXbox360();
            client.CreateXmacsRequest();

            client.XmacsRequest.Input.ConsoleCert=new ConsoleCertificate();
            client.XmacsRequest.Input.ConsoleCert.SetConsoleIdFromGamertag(client.XmacsRequest.Input.ConsoleId);
            client.XmacsRequest.Input.ConsoleCert.ConsolePublicKey.GenerateRandomKey();
            client.XmacsRequest.Input.ConsoleCert.Sign();

            return client;
        }

        //Sets up an xmacs request for a machine with specific console ID and a random key pair
        public static KdcClientXbox360 GenerateRandomXmacsRequest(string consoleId)
        {
            KdcClientXbox360 client=new KdcClientXbox360();
            client.CreateXmacsRequest();

            client.XmacsRequest.Input.ConsoleId=consoleId;
            client.XmacsRequest.Input.ConsoleCert=new ConsoleCertificate();
            client.XmacsRequest.Input.ConsoleCert.SetConsoleIdFromGamertag(client.XmacsRequest.Input.ConsoleId);
            client.XmacsRequest.Input.ConsoleCert.ConsolePublicKey.GenerateRandomKey();
            client.XmacsRequest.Input.ConsoleCert.Sign();

            return client;
        }

        // --

        [TestGroup, Description("Xmacs has no protocol changes.  We use the console certificate to differentiate them.")]
        public class Xmacs: TestNode
        {
            [TestCase, Description("Make two xmacs requests for the same console ID but different certificates.  They should receieve different machine IDs back from xmacs.")]
            public void SimpleCreate()
            {
                //create 2 machines with the same console ID but different certificates
                KdcClientXbox360 clientA=GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);

                KdcClientXbox360 clientB=GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientB.ExecuteXmacs(true);

                Global.RO.Debug("Client A: ConsoleID="+clientA.XmacsOutput.ConsoleId+" MachinePuid="+string.Format("0x{0:X}", clientA.XmacsOutput.MachineId));
                Global.RO.Debug("Client B: ConsoleID="+clientB.XmacsOutput.ConsoleId+" MachinePuid="+string.Format("0x{0:X}", clientB.XmacsOutput.MachineId));

                //verify they have different machine puids
                ValueCheck.Test("Console IDs used", clientA.XmacsOutput.ConsoleId, clientB.XmacsOutput.ConsoleId);
                ValueCheck.TestDifferent("MachineIds assigned", clientA.XmacsOutput.MachineId, clientB.XmacsOutput.MachineId);

                //TODO: Verify keys are different
            }

            [TestCase, Description("Make two xmacs requests for the same console ID but different certificates.  Then make another request (will reset session key) on those machines and verify that each received the same machine Id as they originally did.")]
            public void SimpleReset()
            {
                //create 2 machines with the same console ID but different certificates
                KdcClientXbox360 clientA=GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);
                ulong clientAOriginalId=clientA.XmacsOutput.MachineId;

                KdcClientXbox360 clientB=GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientB.ExecuteXmacs(true);
                ulong clientBOriginalId=clientB.XmacsOutput.MachineId;

                Global.RO.Debug("Original create:");
                Global.RO.Debug("Client A: ConsoleID="+clientA.XmacsOutput.ConsoleId+" MachinePuid="+string.Format("0x{0:X}", clientA.XmacsOutput.MachineId));
                Global.RO.Debug("Client B: ConsoleID="+clientB.XmacsOutput.ConsoleId+" MachinePuid="+string.Format("0x{0:X}", clientB.XmacsOutput.MachineId));

                //now reset them
                clientA.ExecuteXmacs(true);
                clientB.ExecuteXmacs(true);

                Global.RO.Debug("After reset:");
                Global.RO.Debug("Client A: ConsoleID="+clientA.XmacsOutput.ConsoleId+" MachinePuid="+string.Format("0x{0:X}", clientA.XmacsOutput.MachineId));
                Global.RO.Debug("Client B: ConsoleID="+clientB.XmacsOutput.ConsoleId+" MachinePuid="+string.Format("0x{0:X}", clientB.XmacsOutput.MachineId));

                //verify each console got back the same machine id as they originally did
                ValueCheck.Test("MachineId for client A", clientAOriginalId, clientA.XmacsOutput.MachineId);
                ValueCheck.Test("MachineId for client B", clientBOriginalId, clientB.XmacsOutput.MachineId);

                ValueCheck.TestDifferent("MachineIds assigned", clientA.XmacsOutput.MachineId, clientB.XmacsOutput.MachineId);

                //TODO: Verify keys at each step
            }

            [TestCase, Description("Create an xbox360 machine in the old tables then do an xmacs request to migrate them to the new tables.")]
            public void SimpleMigrate()
            {
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();
                Global.RO.Debug("Created legacy Xbox360: 0x{0:X}", mach.Id);

                //validate that the machine is only in the old tables and not in the new tables, just in case
                ValueCheck.Test("Legacy Machine Exists in t_machines",           true,  1==(int)UodbWS.ExecuteSQLScalar("select count(*) from t_machines where bi_machine_puid="+(long)mach.Id, mach.Id));
                ValueCheck.Test("Legacy Machine Exists in t_user_names",         true,  1==(int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_names where vc_gamertag='"+mach.ConsoleId+"'", mach.ConsoleId));
                ValueCheck.Test("Legacy Machine Exists in t_user_keys",          true,  1==(int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_keys where vc_gamertag='"+mach.ConsoleId+"'", mach.ConsoleId));
                ValueCheck.Test("Legacy Machine Exists in t_machine_xenon_keys", false, 0!=(int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+mach.ConsoleId+"'", mach.ConsoleId));

                //do an xmacs reset on the machine
                Global.RO.Debug("Migrating machine (xmacs reset)");
                KdcClientXbox360 client=GenerateRandomXmacsRequest(mach.ConsoleId);
                client.ExecuteXmacs(true);

                //verify that the entries in the old tables are gone and that entries exist in the new tables
                ValueCheck.Test("Migrated Machine Exists in t_machines",           true,  1==(int)UodbWS.ExecuteSQLScalar("select count(*) from t_machines where bi_machine_puid="+(long)mach.Id, mach.Id));
                ValueCheck.Test("Migrated Machine Exists in t_user_names",         false, 0!=(int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_names where vc_gamertag='"+mach.ConsoleId+"'", mach.ConsoleId));
                ValueCheck.Test("Migrated Machine Exists in t_user_keys",          false, 0!=(int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_keys where vc_gamertag='"+mach.ConsoleId+"'", mach.ConsoleId));
                ValueCheck.Test("Migrated Machine Exists in t_machine_xenon_keys", true,  1==(int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+mach.ConsoleId+"'", mach.ConsoleId));
            }

            [TestCase, Description("Randomly create or reset 5 console IDs each with 4 different certificates until all 20 have been reset at least once.  We decrypt and verify the key for every machine from the db after each reset.")]
            public void MixedCreatesAndResets()
            {
                int maxConsoleIDs=5;
                int maxCerts=4;

                //generate console IDs and certs
                string []consoleIDs=new string[maxConsoleIDs];
                for (int i=0; i<maxConsoleIDs; ++i)
                {
                    consoleIDs[i]=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                }

                ConsoleCertificate []consoleCerts=new ConsoleCertificate[maxConsoleIDs*maxCerts];
                for (int i=0; i<maxConsoleIDs; ++i)
                {
                    for (int c=0; c<maxCerts; ++c)
                    {
                        consoleCerts[i*maxCerts+c]=new ConsoleCertificate();
                        consoleCerts[i*maxCerts+c].SetConsoleIdFromGamertag(consoleIDs[i]);
                        consoleCerts[i*maxCerts+c].ConsolePublicKey.GenerateRandomKey();
                        consoleCerts[i*maxCerts+c].Sign();
                    }
                }

                //all start out as neither created nor reset
                byte [][]consoleKey=new byte[maxConsoleIDs*maxCerts][];
                int []resetCount=new int[maxConsoleIDs*maxCerts];

                for (int a=0; a<maxConsoleIDs*maxCerts; ++a)
                {
                    consoleKey[a]=null;
                    resetCount[a]=0;
                }

                //
                bool allReset=false;
                while (!allReset)
                {
                    //pick a random console to either create or reset
                    int indexToUse=((int)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next())%(maxConsoleIDs*maxCerts);

                    if (resetCount[indexToUse]>=3) //don't do more than 3 resets per index (which is 16 requests total per console id), to avoid hitting anti-dos code which is based only on console id
                    {
                        continue;
                    }

                    KdcClientXbox360 client=new KdcClientXbox360();
                    client.CreateXmacsRequest();
                    client.XmacsRequest.Input.ConsoleId=consoleIDs[indexToUse/maxCerts];
                    client.XmacsRequest.Input.ConsoleCert=consoleCerts[indexToUse];

                    Global.RO.Debug("Running index "+indexToUse+": ConsoleID="+client.XmacsRequest.Input.ConsoleId+" Hash=0x"+ServerTestFramework.Utilities.Hexer.tohex(client.XmacsRequest.Input.ConsoleCert.ComputeHash()));
                    client.ExecuteXmacs(true);

                    if (consoleKey[indexToUse]!=null) //it was a reset
                    {
                        ++resetCount[indexToUse];
                    }
                    consoleKey[indexToUse]=client.XmacsOutput.MachineKey;

                    //validate DB for all machines
                    for (int a=0; a<maxConsoleIDs*maxCerts; ++a)
                    {
                        if (consoleKey[a]!=null)
                        {
                            byte []keyInDb=(byte[])UodbWS.ExecuteSQLScalar("select bin_key from t_machine_xenon_keys where vc_console_id='"+consoleIDs[a/maxCerts]+"' and bin_cert_hash=0x"+ServerTestFramework.Utilities.Hexer.tohex(consoleCerts[a].ComputeHash()), consoleIDs[a/maxCerts]);
                            byte []ivInDb=(byte[])UodbWS.ExecuteSQLScalar("select bin_iv from t_machine_xenon_keys where vc_console_id='"+consoleIDs[a/maxCerts]+"' and bin_cert_hash=0x"+ServerTestFramework.Utilities.Hexer.tohex(consoleCerts[a].ComputeHash()), consoleIDs[a/maxCerts]);
                            byte []rawKeyFromDb=MachineEditor.DecryptKey(ivInDb, keyInDb);
                            ValueCheck.TestAll("Key for index "+a, consoleKey[a], rawKeyFromDb);
                        }
                    }

                    //if all have been reset, we are done
                    allReset=true;
                    for (int a=0; a<maxConsoleIDs*maxCerts; ++a)
                    {
                        if (resetCount[a]==0)
                        {
                            allReset=false;
                        }
                    }
                }
            }

            [TestCase, Description("Create a legacy machine, migrate them with an xmacs reset, then create another machine with the same console ID but different certificate.")] //This test is a little redundant, but fast so harmless
            public void MigrateLegacyThenDuplicate()
            {
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();
                Global.RO.Debug("Created legacy Xbox360: 0x{0:X}", mach.Id);

                //do an xmacs reset on the machine to migrate it
                Global.RO.Debug("Migrating machine (xmacs reset)");
                KdcClientXbox360 clientA=GenerateRandomXmacsRequest(mach.ConsoleId);
                clientA.ExecuteXmacs(true);

                //now do a request with the same console ID but different certificate
                KdcClientXbox360 clientB=GenerateRandomXmacsRequest(mach.ConsoleId);
                clientB.ExecuteXmacs(true);

                //verify there are two key rows
                ValueCheck.Test("Number of rows in t_machine_xenon_keys for console ID", 2, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+mach.ConsoleId+"'", mach.ConsoleId));
            }

            [TestCase, Description("Both the old and new machine tables are populated for a machine.  Reset the console that we have a hash for.  This is unexpected but we should handle it gracefully.")]
            [CompoundCase("Reset Existing", true)]
            [CompoundCase("Reset Other", false)]
            public void OldAndNewTablesPopulated(TestNode me)
            {
                bool resetExistingMachine=(bool)me.MyValues[0];

                //create two machines, one in the old tables and one in the new and both in t_machines
                Global.RO.Debug("Creating machines...");
                MachineEditor machOld=MachineEditor.CreateLegacyXbox360();

                ConsoleCertificate newCert=new ConsoleCertificate();
                newCert.SetConsoleIdFromGamertag(machOld.ConsoleId);
                newCert.ConsolePublicKey.GenerateRandomKey();
                newCert.Sign();
                MachineEditor machNew=MachineEditor.CreateOrUseExistingName(machOld.ConsoleId, newCert.ComputeHash());

                Global.RO.Debug("Created legacy Xbox360: 0x{0:X}", machOld.Id);
                Global.RO.Debug("Created new Xbox360: 0x{0:X}", machNew.Id);

                //as a sanity check, verify the counts in each table before we start
                Global.RO.Debug("Sanity checking DB...");
                ValueCheck.Test("Rows in t_machines for old",           1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machines where bi_machine_puid="+(long)machOld.Id, machOld.Id));
                ValueCheck.Test("Rows in t_machines for new",           1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machines where bi_machine_puid="+(long)machNew.Id, machNew.Id));
                ValueCheck.Test("Rows in t_user_names",                 1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_names where vc_gamertag='"+machOld.ConsoleId+"'", machOld.ConsoleId));
                ValueCheck.Test("Rows in t_user_keys",                  1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_keys where vc_gamertag='"+machOld.ConsoleId+"'", machOld.ConsoleId));
                ValueCheck.Test("Rows in t_machine_xenon_keys for old", 0, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+machOld.ConsoleId+"' and bi_machine_puid="+(long)machOld.Id, machOld.ConsoleId));
                ValueCheck.Test("Rows in t_machine_xenon_keys for new", 1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+machNew.ConsoleId+"' and bi_machine_puid="+(long)machNew.Id, machNew.ConsoleId));

                //do an xmacs reset
                Global.RO.Debug("Xmacs reset...");
                KdcClientXbox360 client=new KdcClientXbox360();
                client.CreateXmacsRequest();
                client.XmacsRequest.Input.ConsoleId=machNew.ConsoleId;
                if (resetExistingMachine)
                {
                    client.XmacsRequest.Input.ConsoleCert=newCert;
                }
                else
                {
                    ConsoleCertificate otherCert=new ConsoleCertificate();
                    otherCert.SetConsoleIdFromGamertag(machOld.ConsoleId);
                    otherCert.ConsolePublicKey.GenerateRandomKey();
                    otherCert.Sign();
                    client.XmacsRequest.Input.ConsoleCert=otherCert;
                }

                client.ExecuteXmacs(true);

                //Note that if the new tables are populated, we totally ignore the old tables only if there was an exact match.  If there's not a matching hash we'll re-migrate the old row to the new machine
                Global.RO.Debug("Verify DB...");
                ValueCheck.Test("Rows in t_machines for old",                1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machines where bi_machine_puid="+(long)machOld.Id, machOld.Id));
                ValueCheck.Test("Rows in t_machines for new",                1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machines where bi_machine_puid="+(long)machNew.Id, machNew.Id));
                ValueCheck.Test("Rows in t_user_names", resetExistingMachine?1:0, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_names where vc_gamertag='"+machOld.ConsoleId+"'", machOld.ConsoleId));
                ValueCheck.Test("Rows in t_user_keys",  resetExistingMachine?1:0, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_keys where vc_gamertag='"+machOld.ConsoleId+"'", machOld.ConsoleId));
                ValueCheck.Test("Rows in t_machine_xenon_keys for old", resetExistingMachine?0:1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+machOld.ConsoleId+"' and bi_machine_puid="+(long)machOld.Id, machOld.ConsoleId));
                ValueCheck.Test("Rows in t_machine_xenon_keys for new",                      1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+machNew.ConsoleId+"' and bi_machine_puid="+(long)machNew.Id, machNew.ConsoleId));
            }
        }; //class Xmacs

        [TestGroup, Description("Askdc has a new preauth that the client computes from the console certificate and sends up in the machine authentication request.")]
        public class Askdc: TestNode
        {
            private static void ExecuteAskdcExpectingFailure(KdcClientXbox360 client, KerbErrCode expectedError)
            {
                client.AskdcThrowOnKerberosError=false;
                client.ExecuteAskdc(true);
                if (client.AskdcError==null)
                {
                    throw new UnexpectedTestResultException("Expected a kerberos error from askdc but got a valid response.");
                }

                if ((int)client.AskdcError.ErrorCode.Int64!=(int)expectedError)
                {
                    throw new KerberosErrorException(client.AskdcError, "Askdc reply was expected to be error "+expectedError+" but was "+(KerbErrCode)client.AskdcError.ErrorCode.Int64);
                }
            }

            [TestCase, Description("Make an askdc request using two machines that have the same console ID but different certs, including the new preauth.  Verify authdata has different machine IDs.")]
            public void SimpleWithXenonPPA()
            {
                //create 2 machines with the same console ID but different certificates and go through xmacs with them
                KdcClientXbox360 clientA=GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);

                KdcClientXbox360 clientB=GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientB.ExecuteXmacs(true);

                //Now do an askdc request for each one including the new preauth
                clientA.CreateAskdcMachineRequest();
                clientA.AskdcRequest.Input.ConsoleCert=clientA.XmacsRequest.Input.ConsoleCert;
                clientA.ExecuteAskdc(true);

                clientB.CreateAskdcMachineRequest();
                clientB.AskdcRequest.Input.ConsoleCert=clientB.XmacsRequest.Input.ConsoleCert;
                clientB.ExecuteAskdc(true);

                //verify that the authdata in each one has a different machine id
                ValueCheck.TestDifferent("MachineIds in authdata from askdc for each client", clientA.AskdcOutput.MachineId, clientB.AskdcOutput.MachineId);
            }

            [TestCase, Description("Make an askdc request using two machines that have the same console ID but different certs, NOT including the new preauth.  Verify that only the most recent one to hit xmacs works (only their key will work).")]
            public void SimpleNoXenonPPA()
            {
                //create 2 machines with the same console ID but different certificates and go through xmacs with them
                KdcClientXbox360 clientA=GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);

                KdcClientXbox360 clientB=GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientB.ExecuteXmacs(true);

                //Now do an askdc request for each one, NOT including the new preauth
                clientA.CreateAskdcMachineRequest();
                clientA.AskdcRequest.Input.ConsoleCert=null;
                ExecuteAskdcExpectingFailure(clientA, KerbErrCode.KDC_ERR_PREAUTH_FAILED);

                clientB.CreateAskdcMachineRequest();
                clientB.AskdcRequest.Input.ConsoleCert=null;
                clientB.ExecuteAskdc(true);

                //verify that the authdata has the puid for client B
                ValueCheck.Test("MachineId in authdata for client B", clientB.XmacsOutput.MachineId, clientB.AskdcOutput.MachineId);
            }

            [TestCase, Description("A machine has legacy rows in uodb and no rows in the new machine tables, and does not provide the new preauth.  Askdc will tell it Principal Unknown so that it will fall back to xmacs to migrate.")]
            public void LegacyMachine_NoXenonPPA()
            {
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();
                Global.RO.Debug("Created legacy Xbox360: 0x{0:X} ConsoleID="+mach.ConsoleId, mach.Id);

                KdcClientXbox360 client=new KdcClientXbox360();
                client.ClearAskdc();
                client.AskdcRequest=new AskdcXbox360Request();
                client.AskdcRequest.Input.SetDefaults(mach.ConsoleId, mach.CalculateKey());
                client.AskdcRequest.Input.ConsoleCert=null;

                ExecuteAskdcExpectingFailure(client, KerbErrCode.KDC_ERR_C_PRINCIPAL_UNKNOWN);
            }

            [TestCase, Description("A machine has legacy rows in uodb and no rows in the new machine tables, and does provide the new preauth.  Askdc will tell it Principal Unknown so that it will fall back to xmacs to migrate.")]
            public void LegacyMachine_WithXenonPPA()
            {
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();
                Global.RO.Debug("Created legacy Xbox360: 0x{0:X} ConsoleID="+mach.ConsoleId, mach.Id);

                ConsoleCertificate cert=new ConsoleCertificate();
                cert.SetConsoleIdFromGamertag(mach.ConsoleId);
                cert.ConsolePublicKey.GenerateRandomKey();
                cert.Sign();

                KdcClientXbox360 client=new KdcClientXbox360();
                client.ClearAskdc();
                client.AskdcRequest=new AskdcXbox360Request();
                client.AskdcRequest.Input.SetDefaults(mach.ConsoleId, mach.CalculateKey());
                client.AskdcRequest.Input.ConsoleCert=cert;

                ExecuteAskdcExpectingFailure(client, KerbErrCode.KDC_ERR_C_PRINCIPAL_UNKNOWN);
            }

            [TestCase, Description("Request to askdc with a ppa preauth for a console ID that exists but for which there is no matching certificate hash.")]
            public void CertNotInDb()
            {
                //create a random machine with xmacs
                KdcClientXbox360 clientA=GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);

                //Now generate a different cert for that same machine but don't take it through xmacs, instead make an askdc request using that cert
                KdcClientXbox360 clientB=GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientA.CreateAskdcMachineRequest();
                clientA.AskdcRequest.Input.ConsoleCert=clientB.XmacsRequest.Input.ConsoleCert;
                ExecuteAskdcExpectingFailure(clientA, KerbErrCode.KDC_ERR_C_PRINCIPAL_UNKNOWN);
            }

            [TestCase, Description("Two clients that share a console ID provide the xenon ppa preauth but try to use each other's keys.  Both should fail.")]
            public void KeyMismatch()
            {
                //create 2 machines with the same console ID but different certificates and go through xmacs with them
                KdcClientXbox360 clientA=GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);

                KdcClientXbox360 clientB=GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientB.ExecuteXmacs(true);

                //set up an askdc request for each one including the new preauth but swap their keys
                clientA.CreateAskdcMachineRequest();
                clientA.AskdcRequest.Input.ConsoleCert=clientA.XmacsRequest.Input.ConsoleCert;
                clientB.CreateAskdcMachineRequest();
                clientB.AskdcRequest.Input.ConsoleCert=clientB.XmacsRequest.Input.ConsoleCert;

                byte []keyForA=clientA.AskdcRequest.Input.IndividualKey;
                clientA.AskdcRequest.Input.IndividualKey=clientB.AskdcRequest.Input.IndividualKey;
                clientB.AskdcRequest.Input.IndividualKey=keyForA;

                //both clients should fail their askdc request
                ExecuteAskdcExpectingFailure(clientA, KerbErrCode.KDC_ERR_PREAUTH_FAILED);
                ExecuteAskdcExpectingFailure(clientB, KerbErrCode.KDC_ERR_PREAUTH_FAILED);
            }

            [TestCase, Description("Both the old and new machine tables are populated for a machine.  Make an askdc request..")]
            [CompoundCase("Request Old", false)]
            [CompoundCase("Request New", true)]
            public void OldAndNewTablesPopulated(TestNode me)
            {
                bool requestNewTableMachine=(bool)me.MyValues[0];

                //create two machines, one in the old tables and one in the new and both in t_machines
                //note that our direct machine editor uses keys computed from console ID, so we need to use real xmacs for one so that it will have a different key
                Global.RO.Debug("Creating machines...");
                KdcClientXbox360 clientNewMachine=new KdcClientXbox360();
                clientNewMachine.ExecuteXmacs(true);

                MachineEditor machOld=MachineEditor.CreateLegacyXbox360(clientNewMachine.XmacsOutput.ConsoleId);

                Global.RO.Debug("Created legacy Xbox360: 0x{0:X}", machOld.Id);
                Global.RO.Debug("Created new Xbox360: 0x{0:X}", clientNewMachine.XmacsOutput.MachineId);

                //as a sanity check, verify the counts in each table before we start
                Global.RO.Debug("Sanity checking DB...");
                ValueCheck.Test("Rows in t_machines for old",           1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machines where bi_machine_puid="+(long)machOld.Id, machOld.Id));
                ValueCheck.Test("Rows in t_machines for new",           1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machines where bi_machine_puid="+(long)clientNewMachine.XmacsOutput.MachineId, clientNewMachine.XmacsOutput.MachineId));
                ValueCheck.Test("Rows in t_user_names",                 1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_names where vc_gamertag='"+machOld.ConsoleId+"'", machOld.ConsoleId));
                ValueCheck.Test("Rows in t_user_keys",                  1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_keys where vc_gamertag='"+machOld.ConsoleId+"'", machOld.ConsoleId));
                ValueCheck.Test("Rows in t_machine_xenon_keys for old", 0, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+machOld.ConsoleId+"' and bi_machine_puid="+(long)machOld.Id, machOld.ConsoleId));
                ValueCheck.Test("Rows in t_machine_xenon_keys for new", 1, (int)UodbWS.ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+clientNewMachine.XmacsOutput.ConsoleId+"' and bi_machine_puid="+(long)clientNewMachine.XmacsOutput.MachineId, clientNewMachine.XmacsOutput.ConsoleId));

                //do an askdc reset
                Global.RO.Debug("Askdc request...");
                KdcClientXbox360 client=new KdcClientXbox360();
                client.ClearAskdc();
                client.AskdcRequest=new AskdcXbox360Request();
                if (requestNewTableMachine)
                {
                    client.AskdcRequest.Input.SetDefaults(clientNewMachine.XmacsOutput.ConsoleId, clientNewMachine.XmacsOutput.MachineKey);
                    client.AskdcRequest.Input.ConsoleCert=clientNewMachine.XmacsRequest.Input.ConsoleCert;

                    client.ExecuteAskdc(true); //should work since we check only the new tables and have a matching hash
                }
                else
                {
                    client.AskdcRequest.Input.SetDefaults(machOld.ConsoleId, machOld.CalculateKey());
                    client.AskdcRequest.Input.ConsoleCert=null;

                    ExecuteAskdcExpectingFailure(client, KerbErrCode.KDC_ERR_PREAUTH_FAILED); //should fail since if an entry exists in the new tables we don't check the old tables, so the key doesn't match.  The client will fall back to xmacs after this and fix itself.
                }
            }
        }; //class Askdc
    }; //class XenonTwinSeparation
} //namespace XkdcTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonTitlesAutoUpdate.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace XkdcTest
{

    // Request:
    //   title
    //   user
    //   flash version
    //   expected HR

    abstract public class Testbase_XenonTitlesAutoU : TestBase_Xkdc
    {
        protected string        machineName = null;
        protected XonlinepUser  cachedUsersMachine = null;
        protected bool          bBanMachine = false;

        protected void Go(uint titleId, uint titleVer, string user1, uint flashVersion, uint expectedHR)
        {
            ResultCode = TEST_RESULTS.FAILED;

            SetDefaults();
            bVerifyUserFlags = false;
            bVerifyServices = false;
            bVerifyPrivileges = false; 

            // Set title fields
            authContext.SetTitle(titleId, titleVer, 1);
            authContext.TitleInfo.FlashVersion = flashVersion;

            // May be null for machine signin
            SetUser(user1, 0);

            // Set expected overall HR
            ExpectedHR = expectedHR;

            // If machine provided, sign in XMACS with that
            if (machineName != null)
            {
                if (cachedUsersMachine == null || 
                    machineName != AuthClientBase.BytesToString(cachedUsersMachine.Gamertag))
                {
                    authContext.UsersMachine = CreateMachine(bBanMachine);
                }
                else
                {
                    authContext.UsersMachine = (XonlinepUser)cachedUsersMachine.Clone();
                }
            }
            else
            {
                authContext.UsersMachine = CreateMachine(bBanMachine);
            }

            // Sign in with auto-discover
            if (SignInXkdc(true))
            {
                // Explicitly request auto-update service (3)
                //SetDefaults();

                authContext.ClearXkdc();
                XkdcClient.SetDefaults(authContext);
                this.result = null;

                if (!bBanMachine)
                {
                    ExpectedServices = new uint[] { 3 };
                    ExpectedHRs = new uint[] { 0 };
                    ExpectedHR = HResult.S_OK;
                    bVerifyServices = true;
                }
                else
                {
                    ExpectedServices = new uint[] { 3 };
                    ExpectedHRs = new uint[] { 1 }; //we don't actually expect 1 back, but have to put something here
                    ExpectedHR = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                    bVerifyServices = false; //we check ourself below
                }

                if (SignInXkdc(false))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }

                if (bBanMachine) //banned machines sholud have no services returned
                {
                    ValueCheck.Test("Number of services returned", 0, result.NumValidServices);
                }
            }
        }

        protected XonlinepUser CreateMachine(bool bBanMachine)
        {
            if (machineName == null)
            {
                authContext.ConsoleCert = new ConsoleCertificate();
                XmacsClient.SetDefaults(authContext);
            }
            else
            {
                authContext.MachineUser = new XonlinepUser();

                // Set gamertag and defaults
                AuthClientBase.StringToBytes(authContext.MachineUser.Gamertag, machineName);
                XmacsClient.SetDefaults(authContext.MachineUser);

                // Make sure console cert gamertag matches
                authContext.ConsoleCert = new ConsoleCertificate();
                authContext.ConsoleCert.SetConsoleIdFromGamertag(machineName);
            }

            XmacsClient xmacs = new XmacsClient(authContext, authContext.ConsoleCert, null, true);
            xmacs.SignInXmacs();

            if (bBanMachine)
            {
                ulong puid=xmacs.GetMachinePuid();
                MachineEditor machEd=MachineEditor.FromId(puid);
                machEd.BanMachine();
            }

            cachedUsersMachine = (XonlinepUser)authContext.UsersMachine.Clone();
            return authContext.UsersMachine;

        }

    }

    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(10), AsyncThreadCount(2), Description("Title update tests... mostly for xenon... but there are non-xenon cases here also")]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class XenonTitlesAutoUpdate : XkdcTestBaseGroup
    {
        public XenonTitlesAutoUpdate() : base()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon;
        }



        [TestCase]
            class TitleAutoU_TitleYes_Flash1No_Machine : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                Go(0x3EEF0801, 1, null, 1, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
            }
        }

        [TestCase]
            class TitleAutoU_TitleYes_Flash1No_UserT1 : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                Go(0x3EEF0801, 1, "xktduusert1a", 1, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
            }
        }

        [TestCase]
            class TitleAutoU_TitleYes_Flash1No_UserT2 : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                Go(0x3EEF0801, 1, "xktduusert2a", 1, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash0No_All : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                uint tid = 0xC0FE0800;
                uint hr = HResult.S_OK;
                Go(tid, 1, null, 0, hr);
                Go(tid, 1, "xktduusert1a", 0, hr);
                Go(tid, 1, "xktduusert2a", 0, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash1No_All : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                uint tid = 0xC0FE0800;
                uint hr = HResult.S_OK;
                Go(tid, 1, null, 1, hr);
                Go(tid, 1, "xktduusert1a", 1, hr);
                Go(tid, 1, "xktduusert2a", 1, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash22Yes_All : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                uint tid = 0xC0FE0800;
                uint hr = HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED;
                Go(tid, 1, null, 22, hr);
                Go(tid, 1, "xktduusert1a", 22, hr);
                Go(tid, 1, "xktduusert2a", 22, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash23No_All : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                uint tid = 0xC0FE0800;
                uint hr = HResult.S_OK;
                Go(tid, 1, null, 23, hr);
                Go(tid, 1, "xktduusert1a", 23, hr);
                Go(tid, 1, "xktduusert2a", 23, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash24Yes_All : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                uint tid = 0xC0FE0800;
                uint hr = HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED;
                Go(tid, 1, null, 24, hr);
                Go(tid, 1, "xktduusert1a", 24, hr);
                Go(tid, 1, "xktduusert2a", 24, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleYes_Flash22Yes_All : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                // If title AND flash require an update, we get LOGON_FLASH_UPDATE_REQUIRED
                uint tid = 0x3EEF0801;
                uint hr = HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED;
                Go(tid, 1, null, 22, hr);
                Go(tid, 1, "xktduusert1a", 22, hr);
                Go(tid, 1, "xktduusert2a", 22, hr);
            }
        }

        [TestCase]
            class XenonDashTitleId_SimpleSignin : TestBase_Xkdc
        {
            override protected void RunTest()
            {
                bVerifyUserFlags = false;
                bVerifyServices = false;
                bVerifyPrivileges = false;
                authContext.SetTitle(0xFFFE07D1, 0, 0);
                SetUser("xktduusert2a", 0);
                SignInXkdc();
            }
        }


        // Banned machine tests


        [TestCase]
            class TitleAutoU_TitleYes_Flash1No_Machine_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                Go(0x3EEF0801, 1, null, 1, HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED);
            }
        }

        [TestCase]
            class TitleAutoU_TitleYes_Flash1No_UserT1_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                Go(0x3EEF0801, 1, "xktduusert1a", 1, HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED);
            }
        }

        [TestCase]
            class TitleAutoU_TitleYes_Flash1No_UserT2_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                Go(0x3EEF0801, 1, "xktduusert2a", 1, HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash0No_All_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                uint tid = 0xC0FE0800;
                uint hr = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                Go(tid, 1, null, 0, hr);
                Go(tid, 1, "xktduusert1a", 0, hr);
                Go(tid, 1, "xktduusert2a", 0, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash1No_All_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                uint tid = 0xC0FE0800;
                uint hr = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                Go(tid, 1, null, 1, hr);
                Go(tid, 1, "xktduusert1a", 1, hr);
                Go(tid, 1, "xktduusert2a", 1, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash22Yes_All_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                uint tid = 0xC0FE0800;
                uint hr = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                Go(tid, 1, null, 22, hr);
                Go(tid, 1, "xktduusert1a", 22, hr);
                Go(tid, 1, "xktduusert2a", 22, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash23No_All_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                uint tid = 0xC0FE0800;
                uint hr = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                Go(tid, 1, null, 23, hr);
                Go(tid, 1, "xktduusert1a", 23, hr);
                Go(tid, 1, "xktduusert2a", 23, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleNo_Flash24Yes_All_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                uint tid = 0xC0FE0800;
                uint hr = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                Go(tid, 1, null, 24, hr);
                Go(tid, 1, "xktduusert1a", 24, hr);
                Go(tid, 1, "xktduusert2a", 24, hr);
            }
        }

        [TestCase]
            class TitleAutoU_TitleYes_Flash22Yes_All_Banned : Testbase_XenonTitlesAutoU
        {
            override protected void RunTest()
            {
                bBanMachine = true;
                uint tid = 0x3EEF0801;
                uint hr = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                Go(tid, 1, null, 22, hr);
                Go(tid, 1, "xktduusert1a", 22, hr);
                Go(tid, 1, "xktduusert2a", 22, hr);
            }
        }

        //
        [TestCase(BugID=98068, BugDatabase="Xenon"), AsyncGroup(0), Description("Autodiscover, add a newer title version, then manually request services.")]
        //                              use normal svcs, include auto svc, include drm svc, include livehive svc, expect autoupdate
        [CompoundCase("NormalAndAll",   true,            true,             true,            true,                 true)]
        [CompoundCase("NormalAuto",     true,            true,             false,           false,                true)]
        [CompoundCase("NormalOnly",     true,            false,            false,           false,                true)]
        [CompoundCase("AutoDrm",        false,           true,             true,            false,                false)]
        [CompoundCase("AutoOnly",       false,           true,             false,           false,                false)]
        [CompoundCase("DrmOnly",        false,           false,            true,            false,                true)]
        [CompoundCase("LiveHiveOnly",   false,           false,            false,           true,                 true)]
        [CompoundCase("AutoLiveHive",   false,           true,             false,           true,                 false)]
        class UpdateAutoThenManual: TestNode
        {
            public override void Run()
            {
                bool serviceNormal=(bool)MyValues[0];
                bool serviceAuto=(bool)MyValues[1];
                bool serviceDrm=(bool)MyValues[2];
                bool serviceHive=(bool)MyValues[3];
                bool expectUpdate=(bool)MyValues[4];

                //remove newer version first if present
                Global.RO.Debug("Setting initial title version...");
                TitleEditor title=TitleEditor.FromId(0xffbeef30);
                title.RemoveAllVersions();
                title.AddVersion(1, 1, 1, 2);
                Suite.ReloadKDCs();

                //do autodiscover request
                Global.RO.Debug("Doing initial autodiscover request...");
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                TestBase_Xkdc.SetRequestVersion(ctx, ((XkdcTestBaseGroup)(Parent.Parent)).DefaultXkdcXenonPreauthVersion);
                XkdcClient xkdc=new XkdcClient(ctx);
                ctx.SetTitle(0xFFBEEF30,1,1);
                ctx.SetUser(ServerTestFramework.Database.UserEditor.CreateNew(), 0);

                xkdc.SetRequest(null,true);
                xkdc.SignInXkdc();

                XkdcResult res=ctx.GetXkdcResult();
                if (res.ServiceHR!=0) throw new UnexpectedTestResultException("First request to xkdc did not succeed: "+res.ServiceHR);

                //add a newer version of the title
                Global.RO.Debug("Setting updated title version...");
                title.RemoveAllVersions();
                title.AddVersion(1, 2, 2, 2);
                Suite.ReloadKDCs();

                //decide what services to request and do non-autodiscover request
                Global.RO.Debug("Doing non-autodiscover request...");
                LinkedList<uint> serviceList=new LinkedList<uint>();

                if (serviceNormal)
                {
                    for (int i=0; i<res.ServiceIDs.Length; ++i)
                    {
                        if (res.ServiceHRs[i]==0) //only bother with services we successfully got
                        {
                            serviceList.AddLast(res.ServiceIDs[i]);
                        }
                    }

                    //sanity check... if we don't have at least 3 by now, something is fishy
                    if (serviceList.Count<3) throw new Exception("Sanity check failed: we don't have at least 3 services to request.");
                }

                if (serviceAuto)
                {
                    if (!serviceList.Contains((uint)XOService.Auto_Update))
                    {
                        serviceList.AddLast((uint)XOService.Auto_Update);
                    }
                }
                else
                {
                    serviceList.Remove((uint)XOService.Auto_Update);
                }

                if (serviceDrm)
                {
                    if (!serviceList.Contains((uint)XOService.DRM))
                    {
                        serviceList.AddLast((uint)XOService.DRM);
                    }
                }
                else
                {
                    serviceList.Remove((uint)XOService.DRM);
                }

                if (serviceHive)
                {
                    if (!serviceList.Contains((uint)XOService.Liveinfo))
                    {
                        serviceList.AddLast((uint)XOService.Liveinfo);
                    }
                }
                else
                {
                    serviceList.Remove((uint)XOService.Liveinfo);
                }

                uint []services=new uint[serviceList.Count];
                int ind=0;
                foreach (uint s in serviceList)
                {
                    services[ind++]=s;
                }

                xkdc.SetRequest(services, false);
                xkdc.SignInXkdc();

                //verify response
                res=ctx.GetXkdcResult();
                Global.RO.Info("ServiceHR is "+res.ServiceHR);
                if (expectUpdate)
                {
                    ValueCheck.Test("serviceHR",HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,res.ServiceHR);
                }
                else
                {
                    ValueCheck.Test("serviceHR",HResult.S_OK,res.ServiceHR);
                }
            }
        }

        //
        [TestCase, Description("Verify that a 2 hop system update works."), AsyncGroup(0)]
        public void TwoHopSystemUpdate()
        {
            //set up the test hop dash versions
            TitleEditor title=TitleEditor.FromId(0xfffe07d1); //xenon dash
            title.AddVersion(0x9997, 0x9998, 0x9998, 2);
            title.AddVersion(0x9998, 0x9999, 0x9999, 2);
            title.AddVersion(0x9999, 0x9999, 0x9999, 2);

            Suite.ReloadKDCs();

            //Do the first hop request
            Global.RO.Debug("Doing the first hop...");
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            TestBase_Xkdc.SetRequestVersion(ctx, DefaultXkdcXenonPreauthVersion);
            ctx.SetTitle(0xfffe07d1, 0x9997, 1);
            ctx.TitleInfo.FlashVersion=0x9997;

            XkdcClient xkdc=new XkdcClient(ctx);
            xkdc.SignInXkdc();
            ValueCheck.Test("ServiceHR", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED, ctx.GetXkdcResult().ServiceHR);

            //Do the second hop request
            Global.RO.Debug("Doing the second hop...");
            ctx.SetTitle(0xfffe07d1, 0x9998, 1);
            ctx.TitleInfo.FlashVersion=0x9998;

            xkdc.SignInXkdc();
            ValueCheck.Test("ServiceHR", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED, ctx.GetXkdcResult().ServiceHR);

            //Verify that we're good now
            Global.RO.Debug("Doing request on the final version...");
            ctx.SetTitle(0xfffe07d1, 0x9999, 1);
            ctx.TitleInfo.FlashVersion=0x9999;

            xkdc.SignInXkdc();
            ValueCheck.Test("ServiceHR", HResult.S_OK, ctx.GetXkdcResult().ServiceHR);
        }

        //
        [TestCase, AsyncGroup(1), AsyncThreadDelay(100), AsyncThreadCount(2)]
        public class ServiceCombinations: TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                //do all platforms
                AuthContext.ClientTypes []clientTypes=new AuthContext.ClientTypes[]{ AuthContext.ClientTypes.Xenon, AuthContext.ClientTypes.Panorama };
                foreach (AuthContext.ClientTypes clientType in clientTypes)
                {
                    bool isXb1=(clientType==AuthContext.ClientTypes.Xbox || clientType==AuthContext.ClientTypes.XenonBackCompat);

                    //figure out the basic services allowable for autoupdate normally
                    uint []allowedServices;
                    if (isXb1)
                    {
                        allowedServices=new uint[]{ (uint)XOService.Auto_Update, (uint)XOService.StringService };
                    }
                    else
                    {
                        allowedServices=new uint[]{ (uint)XOService.Auto_Update, (uint)XOService.DRM, (uint)XOService.Liveinfo };
                    }

                    //title id that has an autoupdate
                    uint titleID=0x3EEF0801; //xenon
                    if (isXb1)
                    {
                        titleID=0xFFBEEF01;
                    }
                    else if (clientType==AuthContext.ClientTypes.Panorama)
                    {
                        titleID=0x7EEF0801;
                    }

                    //add the cases
                    instances.Add(new CompoundCaseAttribute(clientType.ToString()+" MatchOnly", clientType, new uint[]{ (uint)XOService.Matchmaking }, (uint)HResult.XONLINE_E_LOGON_UPDATE_REQUIRED, titleID));

                    instances.Add(new CompoundCaseAttribute(clientType.ToString()+" UpdateOnly", clientType, new uint[]{ (uint)XOService.Auto_Update }, (uint)0, titleID));
                    instances.Add(new CompoundCaseAttribute(clientType.ToString()+" UpdateAndAllowed", clientType, allowedServices, (uint)0, titleID));

                    List<uint> extraList=new List<uint>();
                    extraList.AddRange(allowedServices);
                    extraList.Add((uint)XOService.Matchmaking);
                    extraList.Add((uint)XOService.Stats);
                    extraList.Add((uint)XOService.PresNotification);
                    if (isXb1)
                    {
                        instances.Add(new CompoundCaseAttribute(clientType.ToString()+" UpdateAndNonallowed", clientType, extraList.ToArray(), (uint)0, titleID));
                    }
                    else
                    {
                        instances.Add(new CompoundCaseAttribute(clientType.ToString()+" UpdateAndNonallowed", clientType, extraList.ToArray(), (uint)HResult.XONLINE_E_LOGON_UPDATE_REQUIRED, titleID));
                    }
                }
            }

            public override void Run()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)MyValues[0];
                uint []services=(uint[])MyValues[1];
                uint expectedResult=(uint)MyValues[2];
                uint titleID=(uint)MyValues[3];

                AuthContext ctx=new AuthContext(clientType);
                TestBase_Xkdc.SetRequestVersion(ctx, ((XkdcTestBaseGroup)(Parent.Parent)).DefaultXkdcXenonPreauthVersion);
                ctx.SetTitle(titleID, 1, 1);
                XkdcClient xkdc=new XkdcClient(ctx);
                xkdc.SetRequest(services);
                xkdc.SignInXkdc();
                uint result=ctx.GetXkdcResult().ServiceHR;

                Global.RO.Debug("For "+StringUtils.MakeCommaSeparatedList(services)+" got 0x"+string.Format("{0:X}", result));
                ValueCheck.Test("ServiceHR", expectedResult, result);
            }
        };

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XenonXkdc.cs ===
using System;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace XkdcTest.XenonXkdc
{
    [TestGroup, Owner("LukeL"), TestFrequency("Daily"), Description("Verifies that Xenon Xkdc functionality is working as expected for xbox360 and pc")]
    public class XenonXkdc: XkdcTestBaseGroup
    {
        public XenonXkdc()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon; //default to xbox360
            DefaultXkdcXenonPreauthVersion=5; //use the new preauth for these by default
        }

        //tests
        [TestCase, TestCasePriority(1)]
        public class BasicAutodiscover_MachineOnly: TestBase_KdcClient
        {
            public override void Run()
            {
                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(1)]
        public class BasicAutodiscover_1User: TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktusert2a");
                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(2)]
        public class RequestAllServices_MachineOnly: TestBase_KdcClient
        {
            public override void Run()
            {
                SetXkdcDefaults();

                uint []services=new uint[128+4];
                for (int i=0; i<128; ++i)
                {
                    services[i]=(uint)i;
                }
                services[128+0]=8001;
                services[128+1]=8002;
                services[128+2]=8003;
                services[128+3]=8004;
                Client.XkdcRequest.Input.SetServices(services);

                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(2)]
        public class RequestAllServices_4Users: TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktusert2a");
                SetUser(1, "xktxeusert1a");
                SetUser(2, "xktxeusert2a");
                SetUser(3, "xktuser7a");

                SetXkdcDefaults();

                uint []services=new uint[128+4];
                for (int i=0; i<128; ++i)
                {
                    services[i]=(uint)i;
                }
                services[128+0]=8001;
                services[128+1]=8002;
                services[128+2]=8003;
                services[128+3]=8004;
                Client.XkdcRequest.Input.SetServices(services);

                ExecuteXkdc(true);
            }
        }

        [TestCase, Description("Sign in to an Authdata3 site using a V5 xenon service request")]
        [TestCasePriority(1)]
        public class AuthData3Site_ServiceRequest5: TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktsubx2");
                SetXkdcDefaults();

                Client.XkdcRequest.Input.SetServices(new uint[]{8001});
                ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(8001, 0, 8001)};
                ExpectedAuthDataVersion=3;

                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(1), Description("Autodiscover request that grants more than 36 services.")]
        public class AutodiscoverMoreThan36_1User: TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktcntry254t2");
                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(1), Description("Autodiscover request that grants more than 36 services.")]
        public class AutodiscoverMoreThan36_4User: TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktcntry254t2");
                SetUser(1, "xktcntry254t1");
                SetUser(2, "xktcntry254t2a");
                SetUser(3, "xktcntry254t2a2");
                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(1), Description("Request and be granted more than 36 services.")]
        public class RequestMoreThan36_1User: TestBase_KdcClient
        {
            public override void Run()
            {
                SetUser(0, "xktcntry254t2");
                SetXkdcDefaults();

                uint []servicesToRequest=new uint[40];
                for (int i=0; i<40; ++i)
                {
                    servicesToRequest[i]=(uint)(80+i);
                }
                Client.XkdcRequest.Input.SetServices(servicesToRequest);

                ExecuteXkdc(true);
            }
        }

        [TestCase, TestCasePriority(1), Description("Autodiscover request that grants more than 36 services.  Preauth V4 can't handle this, so the KDC should return an error.")]
        public class AutodiscoverMoreThan36_PreauthV4: TestBase_KdcClient
        {
            public override void Run()
            {
                ExpectedXkdcKerbError=(uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE;
                SetUser(0, "xktcntry254t2");
                SetXkdcDefaults();
                Client.XkdcRequest.Input.XenonPreauthVersion=4;

                ExecuteXkdc(true);
            }
        }

        [TestCase, Description("Validate flowtokens with different combinations of authdata and servicerequest versions."), Owner("wisgt"), TestFrequency("Daily")]
        [TestCasePriority(1)]
        //Name,                                                     User count, Authdata version, Preauth version, Extra site, Floken Provided
        [CompoundCase("Authdata3_ServiceRequest3",                  1,          3,                5,               false,      true)]
        [CompoundCase("Authdata4_ServiceRequest3",                  1,          4,                5,               false,      true)]
        [CompoundCase("Authdata4_ServiceRequest3_NoFloken",         1,          4,                5,               false,      false)]
        [CompoundCase("Authdata4_ServiceRequest2",                  1,          4,                4,               false,      true)]
        [CompoundCase("Authdata4_ServiceRequest2_MultipleUsers",    3,          4,                4,               false,      true)]
        [CompoundCase("Authdata4_ServiceRequest3_MultipleUsers",    4,          4,                5,               false,      true)]
        [CompoundCase("Authdata3_ServiceRequest3_MultipleUsers",    2,          3,                5,               false,      true)]
        [CompoundCase("Authdata4_ServiceRequest3_MultipleSites",    1,          4,                5,               true,       true)]
        [CompoundCase("Authdata3_ServiceRequest3_MultipleSites",    1,          3,                5,               true,       true)]
        [CompoundCase("Authdata3_ServiceRequest3_V6",               1,          3,                6,               false,      true)]
        [CompoundCase("Authdata4_ServiceRequest3_V6",               1,          4,                6,               false,      true)]
        [CompoundCase("Authdata4_ServiceRequest3_V6_NoFloken",      1,          4,                6,               false,      false)]
        [CompoundCase("Authdata4_ServiceRequest3_V6_MultipleUsers", 4,          4,                6,               false,      true)]
        [CompoundCase("Authdata3_ServiceRequest3_V6_MultipleUsers", 2,          3,                6,               false,      true)]
        [CompoundCase("Authdata4_ServiceRequest3_V6_MultipleSites", 1,          4,                6,               true,       true)]
        [CompoundCase("Authdata3_ServiceRequest3_V6_MultipleSites", 1,          3,                6,               true,       true)]
        public class Flowtoken : TestBase_KdcClient
        {
            int userCount;
            int authdataVersion;
            int requestVersion;
            bool extraSite;
            XkdcListener xkdcListener;
            bool flokenProvided;

            public override void PreRun()
            {
                base.PreRun();

                xkdcListener = new XkdcListener();

                xkdcListener.StartXkdcListener();

                String[] userNames = new String[] { "xktad4a", "xktad4b", "xktad4c", "xktad4d" };

                userCount = (int)MyValues[0];
                authdataVersion = (int)MyValues[1];
                requestVersion = (int)MyValues[2];
                extraSite = (bool)MyValues[3];
                flokenProvided = (bool)MyValues[4];

                Array.Resize(ref userNames, userCount); //Truncate to specified users.

                for (int slot=0; slot<userNames.Length; ++slot)
                {
                    SetUser(slot, userNames[slot]);
                }

                SetXkdcDefaults();

                if (authdataVersion == 3)
                {
                    Client.XkdcRequest.Input.SetServices(new UInt32[] { 8001 }); //V3 site
                    ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(8001, 0, 8001)};
                }

                if (extraSite)
                {
                    if (authdataVersion == 3)
                    {
                        Client.XkdcRequest.Input.SetServices(new UInt32[] { 8001, 8004 }); //V3 sites
                        ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(8001, 0, 8001), new XkdcGenericReplyOutput.ServiceResult(8004, 1, 0)};
                    }
                    else
                    {
                        Client.XkdcRequest.Input.SetServices(new UInt32[] { 20, 21 }); //V4 sites
                        ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(20, 0, 20), new XkdcGenericReplyOutput.ServiceResult(21, 1, 0)};
                    }
                }

                if (requestVersion >= 5)
                {
                    Client.XkdcRequest.Input.XenonPreauthVersion = 5;

                    if (requestVersion == 6)
                    {
                        Client.XkdcRequest.Input.ServiceRequestVersion = 6;
                    }
                }

                foreach (string user in userNames)
                {
                    UserMachineHistoryEditor history = UserMachineHistoryEditor.CreateOrUseExisting(ServerTestFramework.Database.UserEditor.FromGamerTag(user).Puid, Client.XmacsOutput.MachineId);
                }

                Global.RO.Info(String.Format("User count:{0} Authdata version:{1} Request version:{2}, Multiple Sites:{3}", userCount, authdataVersion, requestVersion, extraSite ));
            }

            public override void PostRun()
            {
                xkdcListener.StopXkdcListener();
            }

            public override void Run()
            {
                ExpectedAuthDataVersion=(uint)authdataVersion;
                ExecuteXkdc(true);

                ulong ftVal = Client.XkdcOutput.FlowToken;

                if (Client.XkdcOutput.XboxAuthData is Xenon2XkdcAuthData)
                    ftVal = ((Xenon2XkdcAuthData)Client.XkdcOutput.XboxAuthData).FlowToken;

                xkdcListener.ValidatePresent(ftVal);
                XkdcListener.FlushXomLogCache();

                if (flokenProvided)
                {
                    Client.XkdcRequest.Input.FlowToken = (ulong)System.DateTime.Now.Ticks;
                }

                Global.RO.Debug(String.Format("Set flowtoken to {0}", Client.XkdcRequest.Input.FlowToken));

                Client.XkdcRequest.Input.PrepareForResend(); //need to use a new nonce for the request
                ExecuteXkdc(true);

                Global.RO.Debug(String.Format("Got flowtoken {0} back", Client.XkdcOutput.FlowToken));
            }
        }

        [TestGroup, Description("Tests for tiers other than 3 or 6.")]
        public class HigherTiers: TestNode
        {
            [TestCase, Description("User with a tier = 9")]
            public void UserTier9()
            {
                KdcUser user=new KdcUser();
                user.UseExisting("xktxxxT9");

                SimpleKdcClient kdc=new SimpleKdcClient(AuthContext.ClientTypes.Xenon);
                kdc.Users=new KdcUser[]{user};
                kdc.Execute();

                //verify user tier flags in the first ticket
                uint tierFromFlags=(kdc.XkdcOutputs[0].UserFlags[0]>>20)&0x0f;
                ValueCheck.Test("User tier in flags in preauth reply", 9, tierFromFlags);
            }

            [TestCase, Description("User with a tier = 15")]
            public void UserTier15()
            {
                KdcUser user=new KdcUser();
                user.UseExisting("xktxxxT15");

                SimpleKdcClient kdc=new SimpleKdcClient(AuthContext.ClientTypes.Xenon);
                kdc.Users=new KdcUser[]{user};
                kdc.Execute();

                //verify user tier flags in the first ticket
                uint tierFromFlags=(kdc.XkdcOutputs[0].UserFlags[0]>>20)&0x0f;
                ValueCheck.Test("User tier in flags in preauth reply", 15, tierFromFlags);
            }

            [TestCase, Description("User with a tier = 0xf9abcde8, which the KDC protocol cannot currently represent")]
            public void UserTier0xf9abcde8()
            {
                KdcUser user=new KdcUser();
                user.UseExisting("xktxxxTf9abcde8");

                SimpleKdcClient kdc=new SimpleKdcClient(AuthContext.ClientTypes.Xenon);
                kdc.Users=new KdcUser[]{user};

                try
                {
                    kdc.Execute();
                    throw new UnexpectedTestResultException("Request unexpectedly suceeded.");
                }
                catch (KerberosErrorException kee)
                {
                    //we expect this to fail now with KDC_SVC_UNAVAILABLE, as it should never happen
                    ValueCheck.Test("Expected kerberos error", (int)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE, (int)kee.Error.ErrorCode.Int64);
                }
            }
        }

        [TestCase, Description("Verifies that TGT revocation due to user password reset works")]
        public void RevokedTGT_UserPasswordReset()
        {
            //get a tgt
            KdcUser user=new KdcUser();
            user.CreateUser();

            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateAskdcUserRequest(user);
            kdc.ExecuteAskdc(true);
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //update the password reset date by an hour
            UserEditor ue=UserEditor.FromPuid(user.UserID);
            ue.ResetDate=ue.ResetDate+new System.TimeSpan(0, 1, 0, 0);

            //try to get a tgs
            try
            {
                kdc.ExecuteXkdc(true);
            }
            catch (KerberosErrorException kerr)
            {
                ValueCheck.Test("Expected Kerberos Error", KerbErrCode.KDC_ERR_TGT_REVOKED, kerr.Error.ErrorCode.Int64);
                return;
            }

            throw new UnexpectedTestResultException("Did not expect request to succeed.");
        }

        [TestCase, Description("Verifies that TGT revocation due to machine password reset works")]
        public void RevokedTGT_MachinePasswordReset()
        {
            //get a tgt
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //update the password reset date by an hour
            MachineEditor me=MachineEditor.FromName(kdc.AskdcOutput.ConsoleOrUserName);
            me.ResetDate=me.ResetDate+new System.TimeSpan(0, 1, 0, 0);

            //try to get a tgs
            try
            {
                kdc.ExecuteXkdc(true);
            }
            catch (KerberosErrorException kerr)
            {
                ValueCheck.Test("Expected Kerberos Error", KerbErrCode.KDC_ERR_TGT_REVOKED, kerr.Error.ErrorCode.Int64);
                return;
            }

            throw new UnexpectedTestResultException("Did not expect request to succeed.");
        }

        [TestGroup]
        public class CrossPlatformTitleVersions: TestNode
        {
            const uint TITLE_ID0=0xFFFF7FF0;
            const uint TITLE_ID1=0xFFFF7FF1;

            public override void PreRun()
            {
                TitleEditor title0=TitleEditor.CreateOrUseExistingId(TITLE_ID0);
                title0.RemoveAllVersions();
                title0.AddVersion(1, 1, 1, 2);
                title0.AddVersion(0, 0, 0, 4);
                title0.AddVersion(1, 1, 1, 4);

                TitleEditor title1=TitleEditor.CreateOrUseExistingId(TITLE_ID1);
                title1.RemoveAllVersions();
                title1.AddVersion(0, 0, 0, 2);
                title1.AddVersion(0, 0, 0, 4);

                TitleEditor flashXbox360=TitleEditor.CreateOrUseExistingId(0xfffe07d1);
                flashXbox360.AddVersion(0xffff7F00, 0xffff7F00, 0xffff7F00, 2);

                TitleEditor flashPC=TitleEditor.CreateOrUseExistingId(0x585207D1);
                flashPC.AddVersion(0xffff7F00, 0xffff7F00, 0xffff7F00, 4);

                Suite.ReloadKDCs();
            }

            [TestGroup]
            [CompoundCase("Allowed",    1)]
            [CompoundCase("Disallowed", 0)]
            public class UnknownVersions: TestNode
            {
                SettingState origSetting=null;

                public override void PreRun()
                {
                    int settingValue=(int)MyValues[0];
                    CreateContextData();
                    SetContextData("UnknownVersionsAllowed", (settingValue!=0?true:false));

                    origSetting=Global.XEnv.GetOverrideSettingState("kdcsvc", "ALL", "kdcsvc_xkdc_allowUnknownVersion", 1);
                    Global.XEnv.OverrideSetting("kdcsvc", "ALL", "kdcsvc_xkdc_allowUnknownVersion", settingValue.ToString(), 1);
                    Suite.RefreshKDCsConfig();
                    Suite.ReloadKDCs();
                }

                public override void PostRun()
                {
                    if (origSetting!=null)
                    {
                        Global.XEnv.RestoreOverrideSettingState(origSetting);
                        Suite.RefreshKDCsConfig();
                    }
                    origSetting=null;
                }

                [TestCase]
                [CompoundCase("{1:X} Xbox360 Version {2}", AuthContext.ClientTypes.Xenon,    TITLE_ID0, 1, true,  true)]
                [CompoundCase("{1:X} Xbox360 Version {2}", AuthContext.ClientTypes.Xenon,    TITLE_ID0, 2, true,  false)] //a 0 row for any platform opens it up for all all versions all platforms
                [CompoundCase("{1:X} PC Version {2}",      AuthContext.ClientTypes.Panorama, TITLE_ID0, 1, true,  true)]
                [CompoundCase("{1:X} PC Version {2}",      AuthContext.ClientTypes.Panorama, TITLE_ID0, 2, true,  false)]
                [CompoundCase("{1:X} Xbox360 Version {2}", AuthContext.ClientTypes.Xenon,    TITLE_ID1, 1, true,  false)]
                [CompoundCase("{1:X} Xbox360 Version {2}", AuthContext.ClientTypes.Xenon,    TITLE_ID1, 2, true,  false)]
                [CompoundCase("{1:X} PC Version {2}",      AuthContext.ClientTypes.Panorama, TITLE_ID1, 1, true,  false)]
                [CompoundCase("{1:X} PC Version {2}",      AuthContext.ClientTypes.Panorama, TITLE_ID1, 2, true,  false)]
                public void Check(TestNode self)
                {
                    AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)self.MyValues[0];
                    uint titleToUse=(uint)self.MyValues[1];
                    uint versionToUse=(uint)(int)self.MyValues[2];
                    bool expectSuccessOnUnknownVersionsAllowed=(bool)self.MyValues[3];
                    bool expectSuccessOnUnknownVersionsDisallowed=(bool)self.MyValues[4];

                    bool expectSuccess=((bool)GetContextData("UnknownVersionsAllowed")?expectSuccessOnUnknownVersionsAllowed:expectSuccessOnUnknownVersionsDisallowed);

                    KdcClient client=new KdcClient(clientType);
                    client.CreateXkdcRequest();
                    client.XkdcRequest.Input.TitleID=titleToUse;
                    client.XkdcRequest.Input.TitleVersion=versionToUse;
                    client.XkdcRequest.Input.FlashVersion=0xffff7F00;
                    client.XkdcRequest.Input.ClientMajorVersion=0x0f;
                    client.XkdcRequest.Input.ClientMinorVersion=0x0f;
                    client.XkdcRequest.Input.ClientBuildVersion=0xff7F;
                    client.XkdcRequest.Input.ClientQFEVersion=0x00;

                    client.XkdcThrowOnOverallHRFailure=false;
                    client.ExecuteXkdc(true);
                    Global.RO.Debug("Xkdc Result for title 0x{0:X} version {1}: 0x{2:X}", client.XkdcRequest.Input.TitleID, client.XkdcRequest.Input.TitleVersion, client.XkdcOutput.Hr);
                    ValueCheck.Test("Expected Xkdc overall HR", (expectSuccess?0:0x80151912), client.XkdcOutput.Hr);
                }
            }
        };

        [TestGroup, Description("Specific scenarios with specific offer configurations we want to verify.")]
        public class OfferScenarios: TestNode
        {
            [TestGroup, Description("Tests for a subscription set up similar to the XNA Creators Club subscription.")]
            public class XNA: TestNode
            {
                [TestCase, Description("User gets normal services and privileges but also privilege 222 and service 8105.")]
                public class SameTitle: TestBase_KdcClient
                {
                    public override void Run()
                    {
                        UserInfo userInfo=new UserInfo("xktxna0", 0, 0xC0FE1005);
                        SetUser(0, userInfo);
                        SetXkdcDefaults();

                        //first request is for site 1, XNA service will be marked as on another site and not granted here
                        System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult> expectedServices=new System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult>(GetCurrentDefaultServiceExpectations(0xC0FE1005));
                        expectedServices.Add(new XkdcGenericReplyOutput.ServiceResult(8105, 1, 0));
                        ExpectedServices=expectedServices.ToArray();

                        Client.XkdcRequest.Input.TitleID=0xC0FE1005;
                        ExecuteXkdc(true);

                        //second request will be specifically for the XNA service, it should be granted
                        Client.XkdcRequest.Input.AutoDiscoverServices=0;
                        Client.XkdcRequest.Input.Services=new uint[]{8105};
                        ExpectedServices=new XkdcGenericReplyOutput.ServiceResult[]{new XkdcGenericReplyOutput.ServiceResult(8105, 0, 3074)};
                        ExecuteXkdc(true);
                    }
                }

                [TestCase, Description("User doesn't get either privilege 222 or service 8105.")]
                public class DifferentTitle: TestBase_KdcClient
                {
                    public override void Run()
                    {
                        UserInfo userInfo=new UserInfo("xktxna0", 0, 0xFFC0FE00);

                        SetUser(0, userInfo);
                        SetXkdcDefaults();
                        Client.XkdcRequest.Input.TitleID=0xFFC0FE00;

                        ExecuteXkdc(true);
                    }
                }

                [TestCase, Description("User doesn't get either privilege 222 or service 8105.")]
                public class SameTitleUserWithoutSubscription: TestBase_KdcClient
                {
                    public override void Run()
                    {
                        UserInfo userInfo=new UserInfo("xktusert1a", 0, 0xC0FE1005);

                        SetUser(0, userInfo);
                        SetXkdcDefaults();
                        Client.XkdcRequest.Input.TitleID=0xC0FE1005;

                        ExecuteXkdc(true);
                    }
                }
            }; //class XNA

            [TestCase]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame0", 0xC0FE1006)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame0", 0xC0FE1007)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame0", 0xC0FE1008)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame1", 0xC0FE1006)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame1", 0xC0FE1007)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame1", 0xC0FE1008)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame2", 0xC0FE1006)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame2", 0xC0FE1007)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame2", 0xC0FE1008)]

            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame0", 0xFFC0FE00)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame1", 0xFFC0FE00)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktsubgame2", 0xFFC0FE00)]

            [CompoundCase("User={0} Title=0x{1:X}", "xktusert1a", 0xC0FE1006)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktusert1a", 0xC0FE1007)]
            [CompoundCase("User={0} Title=0x{1:X}", "xktusert1a", 0xC0FE1008)]
            public class GameSubscriptionPrivilege: TestBase_KdcClient
            {
                public override void Run()
                {
                    string gamertag=(string)MyValues[0];
                    uint title=(uint)MyValues[1];

                    UserInfo userInfo=new UserInfo(gamertag, 0, title);

                    SetUser(0, userInfo);
                    SetXkdcDefaults();
                    Client.XkdcRequest.Input.TitleID=title;

                    ExecuteXkdc(true);
                }
            }; //class GameSubscriptionPrivilege

        }; //class OfferScenarios

        [TestCase, Description("Authenticate a user but no machine then do an xkdc request.")]
        public class NoMachine: TestBase_KdcClient
        {
            public override void Run()
            {
                UserInfo userInfo=new UserInfo("xktusert1a", 0, 0xC0FE1005);
                SetUser(0, userInfo);
                Client.CreateAskdcUserRequest(GetUser(0));
                Client.ExecuteAskdc(true);

                ExpectXkdcTimeout=true;
                SetXkdcDefaults();
                ExecuteXkdc(true);
            }
        }

        [TestCase, Description("Present a ticket containing the old identity and/or compound identity in the pac authdata to the xkdc.")]
        [CompoundCase("Machine Only", 0)]
        [CompoundCase("1 User",       1)]
        [CompoundCase("4 Users",      4)]
        public void OldPacAuthdata(TestNode self)
        {
            int userCount=(int)self.MyValues[0];

            KdcClientXbox360 kdc=new KdcClientXbox360();

            //synthenize a ticket that contains the users and machine
            ulong []puids=new ulong[userCount];
            for (int u=0; u<userCount; ++u)
            {
                KdcUser user=new KdcUser();
                user.CreateUser(false);
                Global.RO.Debug("Adding user puid="+user.UserID+" gamertag="+user.Gamertag);

                kdc.CreateAskdcUserRequest(user);
                kdc.AskdcOutput=new AskdcGenericReplyOutput();
                kdc.AskdcOutput.PopulateFromInput(kdc.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.CompoundIdentity);

                puids[u]=user.UserID;
            }

            kdc.ExecuteXmacs(true);
            Global.RO.Debug("Adding machine puid="+kdc.XmacsOutput.MachineId+" consoleid="+kdc.XmacsOutput.ConsoleId);
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcOutput=new AskdcGenericReplyOutput();
            kdc.AskdcOutput.PopulateFromInput(kdc.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.CompoundIdentity);

            //hit xkdc and verify
            kdc.CreateXkdcRequest();
            kdc.XkdcRequest.Input.UserIDs=puids;
            kdc.ExecuteXkdc(true);

            for (int u=0; u<userCount; ++u)
            {
                ValueCheck.Test("User"+u+" HR in SA", 0, kdc.XkdcOutput.HrUser[u]);
                ValueCheck.TestDifferent("User"+u+" Flags in SA", 0, kdc.XkdcOutput.UserFlags[u]);

                ValueCheck.Test("User"+u+" Puid in AuthData", puids[u], kdc.XkdcOutput.XboxAuthData.GetUser((uint)u).UserID);
                ValueCheck.Test("User"+u+" Flags in AuthData", kdc.XkdcOutput.UserFlags[u], kdc.XkdcOutput.XboxAuthData.GetUser((uint)u).UserFlags);
            }

            for (int u=userCount; u<4; ++u)
            {
                ValueCheck.Test("User"+u+" HR", 0, kdc.XkdcOutput.HrUser[u]);
                ValueCheck.Test("User"+u+" Flags", 0, kdc.XkdcOutput.UserFlags[u]);

                ValueCheck.Test("User"+u+" Puid in AuthData", 0, kdc.XkdcOutput.XboxAuthData.GetUser((uint)u).UserID);
                ValueCheck.Test("User"+u+" Flags in AuthData", 0, kdc.XkdcOutput.XboxAuthData.GetUser((uint)u).UserFlags);
            }
        }

        [TestCase, Description("Present a ticket containing the new XboxIdentity in the pac authdata to the xkdc.  This is primarily to test how the old KDC handles the new authdata.")]
        [CompoundCase("Machine Only", 0)]
        [CompoundCase("1 User",       1)]
        [CompoundCase("4 Users",      4)]
        public void NewPacAuthdata(TestNode self)
        {
            int userCount=(int)self.MyValues[0];

            KdcClientXbox360 kdc=new KdcClientXbox360();

            //synthenize a ticket that contains the users and machine
            ulong []puids=new ulong[userCount];
            for (int u=0; u<userCount; ++u)
            {
                KdcUser user=new KdcUser();
                user.CreateUser(false);
                Global.RO.Debug("Adding user puid="+user.UserID+" gamertag="+user.Gamertag);

                kdc.CreateAskdcUserRequest(user);
                kdc.AskdcOutput=new AskdcGenericReplyOutput();
                kdc.AskdcOutput.PopulateFromInput(kdc.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.XboxIdentity);

                puids[u]=user.UserID;
            }

            kdc.CreateXmacsRequest();
            kdc.XmacsRequest.Input.ConsoleSerialNumber=null;
            kdc.ExecuteXmacs(true);
            Global.RO.Debug("Adding machine puid="+kdc.XmacsOutput.MachineId+" consoleid="+kdc.XmacsOutput.ConsoleId);
            kdc.CreateAskdcMachineRequest();
            kdc.AskdcOutput=new AskdcGenericReplyOutput();
            kdc.AskdcOutput.PopulateFromInput(kdc.AskdcRequest.Input, AskdcGenericReplyOutput.AuthDataToSynthesize.XboxIdentity);

            //hit xkdc and verify
            kdc.CreateXkdcRequest();
            kdc.XkdcRequest.Input.UserIDs=puids;

            kdc.XkdcRequest.Input.PreauthsToGenerate=kdc.XkdcRequest.Input.GetDefaultPreauthsToGenerate();
            kdc.XkdcRequest.Input.PreauthsToGenerate.AddLast(131); //add back in the preauths we cut to save space, the old kdc still requires them

            kdc.ExecuteXkdc(true);

            for (int u=0; u<userCount; ++u)
            {
                ValueCheck.Test("User"+u+" HR in SA", 0, kdc.XkdcOutput.HrUser[u]);
                ValueCheck.TestDifferent("User"+u+" Flags in SA", 0, kdc.XkdcOutput.UserFlags[u]);

                ValueCheck.Test("User"+u+" Puid in AuthData", puids[u], kdc.XkdcOutput.XboxAuthData.GetUser((uint)u).UserID);
                ValueCheck.Test("User"+u+" Flags in AuthData", kdc.XkdcOutput.UserFlags[u], kdc.XkdcOutput.XboxAuthData.GetUser((uint)u).UserFlags);
            }

            for (int u=userCount; u<4; ++u)
            {
                ValueCheck.Test("User"+u+" HR", 0, kdc.XkdcOutput.HrUser[u]);
                ValueCheck.Test("User"+u+" Flags", 0, kdc.XkdcOutput.UserFlags[u]);

                ValueCheck.Test("User"+u+" Puid in AuthData", 0, kdc.XkdcOutput.XboxAuthData.GetUser((uint)u).UserID);
                ValueCheck.Test("User"+u+" Flags in AuthData", 0, kdc.XkdcOutput.XboxAuthData.GetUser((uint)u).UserFlags);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XkdcCurfew.cs ===
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;

namespace XkdcTest.XenonXkdc
{
    //Helper base class for setting privilege expectations and setting up users
    public class XkdcCurfewTestBase: TestBase_KdcClient
    {
        public void CreateUser(int slot, byte ?country, bool needsPassport)
        {
            KdcUser user=new KdcUser();
            user.CreateUser(needsPassport);

            UserEditor userEdit=UserEditor.FromPuid(user.UserID);
            if (country!=null)
            {
                userEdit.CountryId=(byte)country;
                userEdit.LanguageId=1;
            }

            SetUser(slot, user);

            if (country==XkdcCurfew.NewCurfewLandCountry)
            {
                //TODO: This new country has the same problem New TestLand has, in that all users there get these extra privileges.  Need to investigate why someday, but it's not related to this feature.
                ExpectedUserPrivileges[slot].Set(232, true);
                ExpectedUserPrivileges[slot].Set(233, true);
                ExpectedUserPrivileges[slot].Set(235, true);
            }

            if (country!=null)
            {
                ExpectedUserCountryId[slot]=(byte)country;
            }
        }

        public void StripCurfewExpectedPrivileges(int slot)
        {
            ExpectedUserPrivileges[slot].Set(254, false);
            ExpectedUserPrivileges[slot].Set(241, false);
        }

        public UserEditor EditUser(int slot)
        {
            return UserEditor.FromPuid(GetUser(slot).UserID);
        }

        public void VerifyXkdcTicketLifeRemainingInSeconds(int expectedSeconds)
        {
            System.DateTime ticketEndTime=Client.XkdcOutput.Ticket.EncryptedBody.EndTime.DateTime;
            int gotSeconds=(int)(ticketEndTime-System.DateTime.UtcNow).TotalSeconds;

            //allow a 30 second variance to account for potential machine clock skew
            int diff=System.Math.Abs(expectedSeconds-gotSeconds);
            if (diff>30)
            {
                throw new UnexpectedTestResultException("Expected xkdc ticket to expire in "+expectedSeconds+"(+-30) seconds, but actual expire is in "+gotSeconds+" seconds");
            }

            Global.RO.Debug("Xkdc EXPECTED ticket life left in seconds: "+expectedSeconds);
            Global.RO.Debug("Xkdc ticket life left in seconds: "+gotSeconds);
        }
    }

    //

    [TestGroup, Owner("LukeL"), TestFrequency("Daily"), Description("Verifies Xkdc curwfew functionality.")]
    public class XkdcCurfew: XkdcTestBaseGroup
    {
        public XkdcCurfew()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon; //default to xbox360
            DefaultXkdcXenonPreauthVersion=6; //use the new preauth for these by default
        }

        public const byte NewCurfewLandCountry=253;
        public static int DefaultXkdcTicketLifeInSeconds=1800; //production is 4 hours, but test environments are 30 minutes to increase random coverage of ticket refresh on the client side

        public override void PreRun()
        {
            base.PreRun();

            CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
            curfew.PrivilegeSetId=2000; //korean cinderella set

            DefaultXkdcTicketLifeInSeconds=(int)StaticNpdb.ExecuteScalar("select i_ticket_lifetime_secs from t_service_keys where vc_environment='"+Global.XEnv.GetEnv()+"' and i_key_type=6 and i_site_id=1");
        }

        // -- helpers

        public static System.TimeSpan OffsetCurrentTimeByMinutes(int minutes)
        {
            System.DateTime now=System.DateTime.UtcNow+new System.TimeSpan(0, minutes, 0);
            return new System.TimeSpan(now.Hour, now.Minute, now.Second);
        }

        //sleeps between 23:53-00:07 utc
        public static void EnsureTimeIsNotNearUtcRollover()
        {
            int minutesToWait=0;

            System.DateTime now=System.DateTime.UtcNow;
            if (now.Hour==23 && now.Minute>=53)
            {
                minutesToWait=7+(60-now.Minute);
            }
            else if (now.Hour==00 && now.Minute<=6)
            {
                minutesToWait=7-now.Minute;
            }

            if (minutesToWait>0)
            {
                Global.RO.Warn("Time is too close to 00:00 UTC for this test to reliably run right now, so sleeping for "+minutesToWait+" minutes before we run.");
                System.Threading.Thread.Sleep(minutesToWait*60*1000);
            }
        }

        // -- tests

        [TestCase, Description("A curfew applied to an one country doesn't affect users in another country")]
        public class UnaffectedCountry: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=1000;
                curfew.StartTime=OffsetCurrentTimeByMinutes(-8*60);
                curfew.DurationInMinutes=16*60;

                CreateUser(0, null, false);
            }

            public override void Run()
            {
                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(DefaultXkdcTicketLifeInSeconds);
            }
        }

        [TestCase, Description("Simple case of a curfew being applied.")]
        [CompoundCase("Autodiscover", true)]
        [CompoundCase("Manual", false)]
        public class SimpleCurfewApplied: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=1000;
                curfew.StartTime=OffsetCurrentTimeByMinutes(-8*60);
                curfew.DurationInMinutes=16*60;

                CreateUser(0, NewCurfewLandCountry, false);
                StripCurfewExpectedPrivileges(0);
            }

            public override void Run()
            {
                bool autodiscover=(bool)MyValues[0];
                if (!autodiscover)
                {
                    SetXkdcDefaults();
                    Client.XkdcRequest.Input.AutoDiscoverServices=0;
                    Client.XkdcRequest.Input.Services=new uint[]{25, 33}; //arbitrary services picked at random
                }

                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(DefaultXkdcTicketLifeInSeconds);
            }
        }

        [TestCase, Description("Variations on user age in a country and time when the curfew applies when under 16 years of age.")]
        //                   ageyears, agedays, expectcurfew
        [CompoundCase("7",         7,  0,       true)]
        [CompoundCase("15",        15, 0,       true)]
        [CompoundCase("almost 16", 16, -1,      true)]  //will be 16 in 1 day
        [CompoundCase("barely 16", 16, 1,       false)] //has been 16 for 1 day
        [CompoundCase("50",        50, 0,       false)]
        public class UserAge: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=16;
                curfew.StartTime=OffsetCurrentTimeByMinutes(-8*60);
                curfew.DurationInMinutes=16*60;

                CreateUser(0, NewCurfewLandCountry, false);

                int userAgeInYears=(int)MyValues[0];
                int daysToAddToUserAge=(int)MyValues[1];
                bool expectCurfewStripping=(bool)MyValues[2];

                System.DateTime now=System.DateTime.UtcNow;
                System.DateTime userBirthDate=now.AddYears(-userAgeInYears).AddDays(-daysToAddToUserAge);
                EditUser(0).Birthdate=userBirthDate;

                if (expectCurfewStripping)
                {
                    StripCurfewExpectedPrivileges(0);
                }
            }

            public override void Run()
            {
                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(DefaultXkdcTicketLifeInSeconds);
            }
        }

        [TestCase, Description("Variations of where the current time lands within the curfew window for a user with curfew applied.  Using an 8 hour window here.")]
        //                                minutesfromstart, curfew, ticketminutes, blackout
        [CompoundCase("5 hours before start",    -5*60,     false,  null,          false)]
        [CompoundCase("20 minutes before start", -20,       false,  20,            false)] //ticket life shortened but not capped yet
        [CompoundCase("12 minutes before start", -12,       false,  12,            false)] //ticket life shortened but not capped yet
        [CompoundCase("7 minutes before start",  -7,        false,  7,             false)] //ticket life hits min cap, but still good
        [CompoundCase("2 minutes before start",  -2,        false,  null,          true)]  //blackout time
        [CompoundCase("2 minutes after start",   2,         true,   null,          false)] //curfew started
        [CompoundCase("3 hours after start",     3*60,      true,   null,          false)]
        [CompoundCase("20 minutes before end",   8*60-20,   true,   20,            false)] //ticket life shortened
        [CompoundCase("7 minutes before end",    8*60-7,    true,   7,             false)] //ticket life shortened but not capped yet
        [CompoundCase("2 minutes before end",    8*60-2,    true,   5,             false)] //ticket life hits min cap
        [CompoundCase("2 minutes after end",     8*60+2,    false,  null,          false)] //curfew ended
        [CompoundCase("5 hours after end",       8*60+5*60, false,  null,          false)]
        public class TimeWithinCurfewWindow: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                base.PreRun();

                int nowIsMinutesFromStartOfCurfew=(int)MyValues[0];
                bool expectCurfewStripping=(bool)MyValues[1];
                bool expectBlackout=(bool)MyValues[3];

                if (expectBlackout)
                {
                    ExpectedOverallHR=HResult.XONLINE_E_LOGON_BLOCKED_BY_CURFEW;
                }

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=1000;
                curfew.StartTime=OffsetCurrentTimeByMinutes(-nowIsMinutesFromStartOfCurfew);
                curfew.DurationInMinutes=8*60;

                CreateUser(0, NewCurfewLandCountry, false);

                if (expectCurfewStripping)
                {
                    StripCurfewExpectedPrivileges(0);
                }
            }

            public override void Run()
            {
                int expectedTicketLifeInSeconds=DefaultXkdcTicketLifeInSeconds;
                if (MyValues[2]!=null)
                {
                    expectedTicketLifeInSeconds=(int)MyValues[2]*60;
                }

                ExecuteXkdc(true);
                Global.RO.Debug("Xkdc Overall HR: 0x"+string.Format("{0:X}", Client.XkdcOutput.Hr));

                if (Client.XkdcOutput.Hr==0)
                {
                    VerifyXkdcTicketLifeRemainingInSeconds(expectedTicketLifeInSeconds);
                }
            }
        }

        [TestCase, Description("Verifies that an adult in a curfewied country during a blackout period is not affected.")]
        public class AdultNotBlackedOut: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=18;
                curfew.StartTime=OffsetCurrentTimeByMinutes(2);
                curfew.DurationInMinutes=6*60;

                CreateUser(0, NewCurfewLandCountry, false);

                EditUser(0).Birthdate=System.DateTime.UtcNow.AddYears(-24);
            }

            public override void Run()
            {
                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(DefaultXkdcTicketLifeInSeconds);
            }
        }

        [TestCase, Description("Curfew whose window does not contain the time of 00:00 UTC.")]
        public class CurfewActive_DoesNotSpanUtcRollover: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                EnsureTimeIsNotNearUtcRollover();
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=16;
                curfew.StartTime=OffsetCurrentTimeByMinutes(-6);
                curfew.DurationInMinutes=12;

                CreateUser(0, NewCurfewLandCountry, false);
                StripCurfewExpectedPrivileges(0);

                EditUser(0).Birthdate=System.DateTime.UtcNow.AddYears(-13);
            }

            public override void Run()
            {
                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(6*60);
            }
        }

        [TestCase, Description("Curfew whose window contains the time of 00:00 UTC.")]
        public class CurfewActive_SpansUtcRollover: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                EnsureTimeIsNotNearUtcRollover();
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=16;
                curfew.StartTime=OffsetCurrentTimeByMinutes(6); //started 6 minutes less than 24 hours ago
                curfew.DurationInMinutes=23*60+(60-3); //ends in 3 minutes

                CreateUser(0, NewCurfewLandCountry, false);
                StripCurfewExpectedPrivileges(0);

                EditUser(0).Birthdate=System.DateTime.UtcNow.AddYears(-13);
            }

            public override void Run()
            {
                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(5*60); //end is in 3 minutes, so we shoud hit the 5 minute cap
            }
        }

        [TestCase, Description("Curfew whose window does not contain the time of 00:00 UTC, start started and ended before now within the current 24 hour utc period.")]
        public class CurfewNotActive_DoesNotSpanUtcRollover_BeforeNow: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                EnsureTimeIsNotNearUtcRollover();
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=16;
                curfew.StartTime=OffsetCurrentTimeByMinutes(-6);
                curfew.DurationInMinutes=3;

                CreateUser(0, NewCurfewLandCountry, false);

                EditUser(0).Birthdate=System.DateTime.UtcNow.AddYears(-13);
            }

            public override void Run()
            {
                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(DefaultXkdcTicketLifeInSeconds);
            }
        }

        [TestCase, Description("Curfew whose window does not contain the time of 00:00 UTC, start started and ended after now within the current 24 hour utc period.")]
        public class CurfewNotActive_DoesNotSpanUtcRollover_AfterNow: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                EnsureTimeIsNotNearUtcRollover();
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=16;
                curfew.StartTime=OffsetCurrentTimeByMinutes(6);
                curfew.DurationInMinutes=1;

                CreateUser(0, NewCurfewLandCountry, false);

                EditUser(0).Birthdate=System.DateTime.UtcNow.AddYears(-13);
            }

            public override void Run()
            {
                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(6*60);
            }
        }

        [TestCase, Description("Curfew whose window contains the time of 00:00 UTC, but does not contain the current time.")]
        public class CurfewNotActive_SpansUtcRollover: XkdcCurfewTestBase
        {
            public override void PreRun()
            {
                EnsureTimeIsNotNearUtcRollover();
                base.PreRun();

                CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                curfew.AgeLimit=16;
                curfew.StartTime=OffsetCurrentTimeByMinutes(6); //starts in 6 minutes
                curfew.DurationInMinutes=23*60+(60-12); //ends the next day 6 minutes prior to the current time

                CreateUser(0, NewCurfewLandCountry, false);

                EditUser(0).Birthdate=System.DateTime.UtcNow.AddYears(-13);
            }

            public override void Run()
            {
                ExecuteXkdc(true);
                VerifyXkdcTicketLifeRemainingInSeconds(6*60);
            }
        }

        [TestGroup]
        public class PC: XkdcTestBaseGroup
        {
            public PC()
            {
                ParentClientType=AuthContext.ClientTypes.Panorama;
                DefaultXkdcXenonPreauthVersion=4; //panorama is still using the old preauth
            }

            [TestCase, Description("Simple case of a curfew being applied on a PC machine.")]
            public class SimpleCurfewApplied: XkdcCurfewTestBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    CurfewEditor curfew=CurfewEditor.CreateOrUseExistingId(NewCurfewLandCountry);
                    curfew.AgeLimit=1000;
                    curfew.StartTime=OffsetCurrentTimeByMinutes(-8*60);
                    curfew.DurationInMinutes=16*60;

                    CreateUser(0, NewCurfewLandCountry, true);
                    StripCurfewExpectedPrivileges(0);
                }

                public override void Run()
                {
                    ExecuteXkdc(true);
                    VerifyXkdcTicketLifeRemainingInSeconds(DefaultXkdcTicketLifeInSeconds);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XkdcPins.cs ===
using ServerTestFramework;
using ServerTestFramework.Database;
using System;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

namespace XkdcTest.XenonXkdc
{
    [TestGroup, Owner("BenRan"), TestFrequency("Daily"), Description("Verifies that Xenon Xkdc functionality is working as expected for xbox360 and pc for pin codes")]
    [Ignore("The pin feature is incomplete and may never ship.  Disabling these tests for now.")]
    public class XkdcPins: XkdcTestBaseGroup
    {
        public XkdcPins()
        {
            ParentClientType=AuthContext.ClientTypes.Xenon; //default to xbox360
            DefaultXkdcXenonPreauthVersion=5; //use the new preauth for these by default
        }

        //todo: Most of the PIN tests aren't working, but since we're not shipping the feature, for now I'm just removing them.  We can revive them when we get back to the feature.
        /*[TestCase, Description("Validate privileges for various pin combinations")]
        [TestCasePriority(1)]
        // Values are               DBPin,  RequestPin,      PinExpiry, ExpectPinPrivilege
        [CompoundCase("IncorrectPin", 123456, 654321, null, false)]
        [CompoundCase("NoPinProvided", 123456, 0, null, false)]
        [CompoundCase("ZeroPinInDb", 0, 0, null, false)]
        [CompoundCase("MinimumPin", 1, 1, null, true)]
        [CompoundCase("MaximumPin", 999999, 999999, null, true)]
        [CompoundCase("SevenDigit", 123456, 1000000, null, false)]
        [CompoundCase("UInt32MaxValue", 112233, UInt32.MaxValue, null, false)]
        public class PinCodeVarieties: TestBase_KdcClient
        {
            bool? ExpectPrivilege;

            public override void PreRun()
            {
                base.PreRun();

                uint DbPin = (uint)Convert.ChangeType(MyValues[0], typeof(UInt32)); // The pin to set in the database
                uint ReqPin = (uint)Convert.ChangeType(MyValues[1], typeof(UInt32)); // The pin to set in the request
                DateTime? PinExpiry = (DateTime?)MyValues[2]; // The pin expirey to set
                ExpectPrivilege = (bool?)MyValues[3]; // Whether or not to expect the pin privilege

                //setup the request
                SetUser(0, "xktad4a");
                SetXkdcDefaults();

                Client.XkdcRequest.Input.UserPINs = new uint[] { ReqPin };

                // Create a UserMachine history for this user.
                UserMachineHistoryEditor history = UserMachineHistoryEditor.CreateOrUseExisting(ServerTestFramework.Database.UserEditor.FromGamerTag("xktad4a").Puid, Client.XmacsOutput.MachineId);
                history.UserPin = DbPin;

                if (PinExpiry.HasValue)
                {
                    history.UserPinExpiration = PinExpiry.Value;
                }
            }

            public override void Run()
            {
                if (ExpectPrivilege.HasValue)
                {
                    ExpectedUserPrivileges[0].Set(219, true); //set that the pin priviliges is expected
                }

                ExecuteXkdc(true);

                return TEST_RESULTS.PASSED;
            }
        };

        [TestCase, Description("Sign in and provide a valid pin that's already expired")]
        [TestCasePriority(2)]
        public class ExpiredPin : TestBase_KdcClient
        {
            public uint ReqPin = 123456;

            public override void PreRun()
            {
                base.PreRun();

                SetUser(0, "xktad4a");
                SetXkdcDefaults();
                Client.XkdcRequest.Input.UserPINs = new uint[] { ReqPin };

                // Create a UserMachine history for this user.
                UserMachineHistoryEditor history = UserMachineHistoryEditor.CreateOrUseExisting(ServerTestFramework.Database.UserEditor.FromGamerTag("xktad4a").Puid, Client.XmacsOutput.MachineId);
                history.UserPinExpiration = DateTime.UtcNow - TimeSpan.FromHours(1);
            }

            public override void Run()
            {
                ExpectedUserPrivileges[0].Set(219, true);
                ExecuteXkdc(true);

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Sign in and with a user with no UserMachineHistory")]
        [TestCasePriority(1)]
        public class NoUserMachineHistory : TestBase_KdcClient
        {
            public uint ReqPin = 123456;

            public override void PreRun()
            {
                base.PreRun();

                SetUser(0, "xktad4a");
                SetXkdcDefaults();
                Client.XkdcRequest.Input.UserPINs = new uint[] { ReqPin };

                // Create a UserMachine history for this user.
                UserMachineHistoryEditor history = UserMachineHistoryEditor.FromId(ServerTestFramework.Database.UserEditor.FromGamerTag("xktad4a").Puid, Client.XmacsOutput.MachineId);

                if (history.Exists)
                {
                    throw new UnexpectedTestResultException("UserMachineHistoryAlreadyExists");
                    //history.Delete();
                }
            }

            public override void Run()
            {
                //run
                ExpectedUserPrivileges[0].Set(219, true);
                ExecuteXkdc(true);

                return TEST_RESULTS.PASSED;
            }
        }*/

        [TestCase, Description("Validate PIN privileges for multiple users")]
        [TestCasePriority(2)]
        [CompoundCase("Two users wo/Pins", new String[] { "xktad4a", "xktad4b" }, new UInt32[] { 0, 0 })]
        [CompoundCase("Two users w/Pins", new String[] { "xktad4a", "xktad4b" }, new UInt32[] { 123456, 123456 })]
        [CompoundCase("Three users w/Pins", new String[] { "xktad4a", "xktad4b", "xktad4c" }, new UInt32[] { 123456, 123456, 123456 })]
        [CompoundCase("Four users w/Pins", new String[] { "xktad4a", "xktad4b", "xktad4c", "xktad4d" }, new UInt32[] { 123456, 123456, 123456, 123456 })]
        [CompoundCase("Three w/ One wo/Pin", new String[] { "xktad4a", "xktad4b", "xktad4c", "xktad4d" }, new UInt32[] { 0, 0, 0, 123456 })]
        [CompoundCase("Two w/ Two wo/Pin", new String[] { "xktad4a", "xktad4b", "xktad4c", "xktad4d" }, new UInt32[] { 123456, 0, 0, 123456 })]
        [CompoundCase("One user, Four Pins", new String[] { "xktad4a" }, new UInt32[] { 123456, 123456, 123456, 123456 })]
        public class MultipleUsers : TestBase_KdcClient
        {
            String[] userNames;

            public override void PreRun()
            {
                base.PreRun();

                userNames = (String[])MyValues[0];
                for (int slot=0; slot<userNames.Length; ++slot)
                {
                    SetUser(slot, userNames[slot]);
                }

                SetXkdcDefaults();
                for (int slot=0; slot<userNames.Length; ++slot)
                {
                    UserMachineHistoryEditor history = UserMachineHistoryEditor.CreateOrUseExisting(ServerTestFramework.Database.UserEditor.FromGamerTag(userNames[slot]).Puid, Client.XmacsOutput.MachineId);
                }

                Client.XkdcRequest.Input.UserPINs = (UInt32[])MyValues[1];
            }

            public override void Run()
            {
                for (int slot=0; slot<userNames.Length; ++slot)
                {
                    ExpectedUserPrivileges[slot].Set(219,  Client.XkdcRequest.Input.UserPINs[slot]!=0);
                }

                ExecuteXkdc(true);
            }
        }

        /*[TestCase, Description("Validates two users on with a valid pin, and one without.")]
        [TestCasePriority(2)]
        public class MultipleUsers_WithInvalidPin : TestBase_KdcClient
        {
            public override void PreRun()
            {
                base.PreRun();

                //TODO: it is unlikely that this test is doing what it was intended to... using the same user in 2 slots...
                SetUser(0, "xktad4");
                SetUser(1, "xktad4");
                SetXkdcDefaults();

                UserMachineHistoryEditor history = null;
                history = UserMachineHistoryEditor.CreateOrUseExisting(ServerTestFramework.Database.UserEditor.FromGamerTag("xktad4").Puid, Client.XmacsOutput.MachineId);
                history = UserMachineHistoryEditor.CreateOrUseExisting(ServerTestFramework.Database.UserEditor.FromGamerTag("xktad4").Puid, Client.XmacsOutput.MachineId);

                Client.XkdcRequest.Input.UserPINs = new UInt32[] { 654321, 123456 };
            }

            public override void Run()
            {
                ExpectedUserPrivileges[0].Set(219, false);
                ExpectedUserPrivileges[1].Set(219, true);
                ExecuteXkdc(true);

                return TEST_RESULTS.PASSED;
            }
        }*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XkdcSiteBalancer.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using System.Collections.Generic;
using System.Data.SqlClient;

namespace XkdcTest
{
    [TestGroup, TestCasePriority(3)]
    public class XkdcSiteBalancer: TestNode
    {
        //util
        [TestCase, Description("More of a test utility and less of a test.  Does an xkdc request on a new machine and spits out the IP and machine ID.")]
        public void DoRequestAndPrintIP()
        {
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            XkdcClient xkdc=new XkdcClient(ctx);
            xkdc.SignInXkdc();

            ServiceContextXe result=ctx.ServiceCtxXe;

            Global.RO.Info("Machine: "+string.Format("{0:X}", result.MachineID));
            Global.RO.Info("Site IP: "+result.siteIPAddress.GetIPEndPoint().Address.ToString());
        }

        //tests for different ip balance configurations
        [CompoundCase("Two balanced",   2,   true)]
        [CompoundCase("Two imbalanced", 2,   false)]
        [CompoundCase("Single",         1,   true)]
        [CompoundCase("Hundred",        100, true)]
        [CompoundCase("None",           0,   true)]
        [TestGroup]
        public class Configuration: TestNode
        {
            private void ReplaceIPBalanceList(string []ipList)
            {
                ServerTestFramework.Database.Npdb npdb=new ServerTestFramework.Database.Npdb();
                npdb.ConnectToServer();

                Global.RO.Debug("Changing Xkdc site balancer IP list to:");
                foreach (string ip in ipList)
                {
                    Global.RO.Debug(ip);
                }

                //save the original config before we mess with anything
                if (!hasOriginalConfigStored)
                {
                    List<string> curIpList=new List<string>();
                    SqlDataReader reader;
                    npdb.ReadData("select vc_value from t_multisettings where vc_multisetting='kdcsvc_xkdc_sgSite1Ips'", out reader);
                    while (reader.Read())
                    {
                        curIpList.Add((string)reader[0]);
                    }
                    reader.Close();
                    originalConfig=curIpList.ToArray();
                    hasOriginalConfigStored=true;
                }

                //replace the old multisettings
                npdb.IssueCommand("delete from t_multisettings where vc_multisetting='kdcsvc_xkdc_sgSite1Ips'");
                foreach (string ip in ipList)
                {
                    npdb.IssueCommand("insert into t_multisettings (vc_multisetting, vc_value) values ('kdcsvc_xkdc_sgSite1Ips', '"+ip.Replace("'","''")+"')");
                }

                npdb.Close();

                Suite.RefreshKDCsConfig();
            }

            private void RestoreIPBalanceList()
            {
                if (hasOriginalConfigStored)
                {
                    ReplaceIPBalanceList(originalConfig);
                    hasOriginalConfigStored=false;
                    originalConfig=new string[0];
                }
            }

            bool hasOriginalConfigStored=false;
            string []originalConfig=new string[0];

            //configure environment to new site ip setup
            public override void PreRun()
            {
                //store settings for this branch
                CreateContextData();
                int sgIpCount=(int)MyValues[0];
                bool sgIpBalanced=(bool)MyValues[1];
                SetContextData("sgIpBalanced", sgIpBalanced);
                Global.RO.Info("Configuring site1 for "+sgIpCount+" different IPs ("+(sgIpBalanced?"balanced":"imbalanced")+")");

                //decide on which IPs to use, using real SG ips until we run out.  we store more than one copy of an IP to add weight.
                List<string> sgIpList=new List<string>();

                System.Net.IPEndPoint []sgEps=Global.XEnv.GetInterface("sgsvc");
                if (sgEps.Length<sgIpCount)
                {
                    Global.RO.Warn("Not enough real SGs in this environment to use for settings in the xkdc site load balancer, so adding fake IPs.");
                }

                for (int i=0; i<sgIpCount; ++i)
                {
                    if (i<sgEps.Length)
                    {
                        sgIpList.Add(sgEps[i].Address.ToString());
                    }
                    else
                    {
                        sgIpList.Add("127.0.1."+(i+100));
                    }
                }

                SetContextData("sgIpList", sgIpList.ToArray()); //store it before we add the imbalancing duplicate

                if (!sgIpBalanced && sgIpList.Count>0)
                {
                    sgIpList.Add(sgIpList[0]);
                }

                //Now change the setting
                ReplaceIPBalanceList(sgIpList.ToArray());
            }

            //restore configuration
            public override void PostRun()
            {
                Global.RO.Info("Restoring site1 config");
                RestoreIPBalanceList();
            }

            //tests for different platform types
            [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
            [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
            [TestGroup]
            public class Platform: TestNode
            {
                protected override void PostProcessBranchConstruction()
                {
                    //trim PC out of all but the "two balanced" group since it should behave just like xbox360
                    if (!FullName.Contains("Two balanced"))
                    {
                        foreach (TestNode child in Children)
                        {
                            if (child.Name!="Xbox360")
                            {
                                RemoveChild(child);
                                break;
                            }
                        }
                    }
                }

                //verifies that load is distributed as expected
                [CompoundCase("MachineRequest", false)]
                [CompoundCase("UserRequest", true)]
                [TestCase, Description("Verfies that load is distributed correctly.")]
                public class Distribution: TestNode
                {
                    public override void Run()
                    {
                        //grab paramaters into locals
                        bool useUser=(bool)MyValues[0];
                        AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)Parent.Parent.MyValues[0];
                        bool sgIpBalanced=(bool)GetContextData("sgIpBalanced");
                        string []sgIpList=(string[])GetContextData("sgIpList");

                        if (sgIpList.Length==0) //if empty, we expect it to be the vip value
                        {
                            sgIpList=new string[1];
                            sgIpList[0]=(string)StaticNpdb.ExecuteScalar("select vc_ip from t_site_virtual_interface_ips where vc_virtual_interface='sgsvc' and i_site_id=1 and vc_environment='"+Global.XEnv.GetEnv()+"'");
                        }

                        //create 100 machines
                        const int machineCount=100;
                        Global.RO.Debug("Creating "+machineCount+" machines...");
                        AuthContext []clients=new AuthContext[machineCount];
                        for (int i=0; i<machineCount; ++i)
                        {
                            clients[i]=new AuthContext(clientType);

                            MachineType machineType;
                            if (clientType==AuthContext.ClientTypes.Xbox) machineType=MachineType.Xbox1;
                            else if (clientType==AuthContext.ClientTypes.Xenon) machineType=MachineType.Xbox360;
                            else if (clientType==AuthContext.ClientTypes.Panorama) machineType=MachineType.PC;
                            else throw new System.Exception("Unhandled client type.");

                            MachineEditor mach=MachineEditor.CreateNew(machineType);
                            clients[i].SetMachine(mach);
                        }

                        //optionally create users for each machine
                        ulong userPassportPuid=0;
                        if (useUser)
                        {
                            Global.RO.Debug("Creating "+machineCount+" users for the machines...");
                            for (int i=0; i<machineCount; ++i)
                            {
                                UserEditor user=UserEditor.CreateNew();

                                if (clientType==AuthContext.ClientTypes.Panorama) //for PC we need passport info
                                {
                                    userPassportPuid=MachineEditor.GetCachedPassportId();
                                    MachineEditor.GetCachedPassportLoginInfo(out clients[i].PassportMemberName, out clients[i].PassportPassword);
                                    MachineEditor.GetCachedPassportTicket(out clients[i].PassportTicket, out clients[i].PassportSessionKey);
                                }

                                clients[i].SetUser(user, 0);
                            }
                        }

                        //sign them all into the askdc
                        Global.RO.Debug("Doing askdc requests for all "+machineCount+" clients...");
                        for (int i=0; i<machineCount; ++i)
                        {
                            AskdcClient askdc=new AskdcClient(clients[i]);
                            askdc.EmulateClientBehavior=true;

                            if (useUser && clientType==AuthContext.ClientTypes.Panorama) //for PC we need to associate passport info with the user - but only 1 user can use that at a time
                            {
                                UserEditor user=UserEditor.FromPuid(clients[i].Users[0].xuid.qwUserID);
                                clients[i].Users[0].Key=user.XenonKey;

                                try
                                {
                                    user.LinkPassport(userPassportPuid);
                                    askdc.SignInAskdc();
                                }
                                finally
                                {
                                    user.UnlinkAllPassports(); //release it so another user can use it
                                }
                            }
                            else
                            {
                                askdc.SignInAskdc();
                            }
                        }

                        //do 100 requests and count IP buckets
                        Global.RO.Debug("Doing xkdc requests for all "+machineCount+" clients to collect IP addresses...");
                        Dictionary<string, int> ipHits=new Dictionary<string, int>();

                        for (int i=0; i<machineCount; ++i)
                        {
                            XkdcClient xkdc=new XkdcClient(clients[i]);
                            xkdc.EmulateClientRetryAndTimingBehavior=true;
                            xkdc.SignInXkdc();
                            if (clients[i].GetXkdcResult().ServiceHR!=0)
                            {
                                throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", clients[i].GetXkdcResult().ServiceHR));
                            }

                            string ip;
                            if (clients[i].ServiceCtxXe!=null)
                            {
                                ip=clients[i].ServiceCtxXe.siteIPAddress.GetIPEndPoint().Address.ToString();
                            }
                            else
                            {
                                ip=clients[i].ServiceCtxXbox.siteIPAddress.GetIPEndPoint().Address.ToString();
                            }

                            if (ipHits.ContainsKey(ip))
                            {
                                ++ipHits[ip];
                            }
                            else
                            {
                                ipHits[ip]=1;
                            }
                        }

                        //validate the hits against the weights we set
                        Global.RO.Debug("Distribution from xkdc tickets:");
                        foreach (KeyValuePair<string, int> kvp in ipHits)
                        {
                            Global.RO.Debug(kvp.Key+": "+kvp.Value);
                        }

                        foreach (KeyValuePair<string, int> kvp in ipHits)
                        {
                            bool isIpOk=false;
                            foreach (string goodIp in sgIpList)
                            {
                                if (kvp.Key==goodIp)
                                {
                                    isIpOk=true;
                                }
                            }

                            if (!isIpOk)
                            {
                                throw new UnexpectedTestResultException("Unexpected IP returned from the xkdc: "+kvp.Key);
                            }
                        }

                        int totalBuckets=sgIpList.Length + (sgIpBalanced?0:1);
                        int varianceAllowed=4; //how much leeway (number per bucket) we allow

                        Global.RO.Debug("Expected distribution ("+varianceAllowed+" variance allowed):");
                        foreach (KeyValuePair<string, int> kvp in ipHits)
                        {
                            int expectedHits;
                            if (!sgIpBalanced && kvp.Key==sgIpList[0]) //double weight expected
                            {
                                expectedHits=(10*2*100/totalBuckets+5)/10;
                            }
                            else //normal weight expected
                            {
                                expectedHits=(10*100/totalBuckets+5)/10;
                            }
                            Global.RO.Debug(kvp.Key+": "+expectedHits);

                            if (kvp.Value<expectedHits-varianceAllowed || kvp.Value>expectedHits+varianceAllowed)
                            {
                                throw new UnexpectedTestResultException("The number of hits for "+kvp.Key+" is outside the expected range.");
                            }
                        }
                    }
                };

                [TestCase, Description("Verfies that the same machine always gets the same IP, including over different titles.")]
                public class MachineTitlePersistance: TestNode
                {
                    public override void Run()
                    {
                        AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)Parent.MyValues[0];

                        uint []titleList;
                        if (clientType==AuthContext.ClientTypes.Xbox) titleList=new uint[]{0xFFC0FE00, 0xFFBEEF0D, 0xFFBEEF0E};
                        else if (clientType==AuthContext.ClientTypes.Xenon) titleList=new uint[]{0xC0FE0800, 0x3EEF080D, 0x3EEF080E};
                        else if (clientType==AuthContext.ClientTypes.Panorama) titleList=new uint[]{0xC0FE0900, 0x3EEF0900, 0x3EEF0950};
                        else throw new System.Exception("Unhandled client type.");

                        //create machines
                        const int machineCount=50;
                        Global.RO.Debug("Creating "+machineCount+" machines...");
                        AuthContext []clients=new AuthContext[machineCount];
                        for (int i=0; i<machineCount; ++i)
                        {
                            clients[i]=new AuthContext(clientType);

                            MachineType machineType;
                            if (clientType==AuthContext.ClientTypes.Xbox) machineType=MachineType.Xbox1;
                            else if (clientType==AuthContext.ClientTypes.Xenon) machineType=MachineType.Xbox360;
                            else if (clientType==AuthContext.ClientTypes.Panorama) machineType=MachineType.PC;
                            else throw new System.Exception("Unhandled client type.");

                            MachineEditor mach=MachineEditor.CreateNew(machineType);
                            clients[i].SetMachine(mach);
                        }

                        //sign them all into the askdc
                        Global.RO.Debug("Doing askdc requests for all "+machineCount+" clients...");
                        for (int i=0; i<machineCount; ++i)
                        {
                            AskdcClient askdc=new AskdcClient(clients[i]);
                            askdc.EmulateClientBehavior=true;
                            askdc.SignInAskdc();
                        }

                        //now do 50 xkdc requests each and verify that each machine always gets the same ip back


                        Global.RO.Debug("Doing 50 requests on each machine over "+titleList.Length+" titles to verify ip persistance.");
                        Dictionary<ulong, string> ipMap=new Dictionary<ulong, string>();
                        for (int reqNum=0; reqNum<50; ++reqNum)
                        {
                            for (int i=0; i<machineCount; ++i)
                            {
                                clients[i].ClearXkdc();
                                clients[i].SetTitle(titleList[i%titleList.Length], 1, 1);
                                XkdcClient xkdc=new XkdcClient(clients[i]);
                                xkdc.EmulateClientRetryAndTimingBehavior=true;
                                xkdc.SignInXkdc();
                                if (clients[i].GetXkdcResult().ServiceHR!=0)
                                {
                                    throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", clients[i].GetXkdcResult().ServiceHR));
                                }

                                string ip;
                                if (clients[i].ServiceCtxXe!=null)
                                {
                                    ip=clients[i].ServiceCtxXe.siteIPAddress.GetIPEndPoint().Address.ToString();
                                }
                                else
                                {
                                    ip=clients[i].ServiceCtxXbox.siteIPAddress.GetIPEndPoint().Address.ToString();
                                }

                                ulong machine=clients[i].UsersMachine.xuid.qwUserID;
                                if (!ipMap.ContainsKey(machine))
                                {
                                    ipMap[machine]=ip;
                                }
                                else
                                {
                                    if (ipMap[machine]!=ip)
                                    {
                                        throw new UnexpectedTestResultException("Before machine "+string.Format("{0:X}",machine)+" got ip "+ipMap[machine]+" but this time it got "+ip);
                                    }
                                }
                            }
                        }
                    }
                };
            };
        };

        //stress case, to verify a set of machines over a long period of time
        [StressTest, Description("Verifies the IP persistance of a machine over a long period of time.  ONLY fails if the IP changed.  It must run for a very long time before anything will start to pass.")]
        public class StressPersist: TestNode
        {
            const int MACHINE_RETEST_MINUTES=2*60; //minimum of 2 hours between when we first do a request for a machine and when we re-test that machine

            TimedQueue<KeyValuePair<AuthContext,string>> authContextCache;

            public StressPersist()
            {
                authContextCache=new TimedQueue<KeyValuePair<AuthContext,string>>();
                authContextCache.MinimumReuseTime=new System.TimeSpan(0,0,MACHINE_RETEST_MINUTES,0,0);
            }

            public override void Run()
            {
                //get a context to use.  for the first MACHINE_RETEST_MINUTES, we will always be making new machines and always return not executed here
                KeyValuePair<AuthContext,string> pair=authContextCache.PopFront();
                AuthContext ctx=pair.Key;
                string ip=pair.Value;
                if (ctx==null)
                {
                    ctx=new AuthContext(AuthContext.ClientTypes.Xenon);

                    //sign in with 1 user, and save the initial result
                    try
                    {
                        //set a user and sign into the askdc
                        StressCommon.SignInAskdc(ctx, true, true, true);

                        //get a ticket
                        XkdcClient xkdc=new XkdcClient(ctx);
                        xkdc.EmulateClientRetryAndTimingBehavior=StressCommon.EmulateClientBehavior;
                        xkdc.SignInXkdc();
                        if (ctx.GetXkdcResult().ServiceHR!=0)
                        {
                            throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
                        }

                        //save off the result
                        ip=ctx.ServiceCtxXe.siteIPAddress.GetIPEndPoint().Address.ToString();
                        authContextCache.PushBack(new KeyValuePair<AuthContext,string>(ctx,ip));
                        throw new DidNotExecuteException("New context prepared");
                    }
                    catch (System.Exception e)
                    {
                        throw new DidNotExecuteException(Name+" failed to set up a new client: "+e);
                    }
                }

                //do an xkdc request and verify the ip is just like we originally saw
                string newIp=null;
                bool fail=false;
                try
                {
                    ctx.ClearXkdc();
                    XkdcClient xkdc=new XkdcClient(ctx);
                    xkdc.EmulateClientRetryAndTimingBehavior=StressCommon.EmulateClientBehavior;
                    xkdc.SignInXkdc();
                    if (ctx.GetXkdcResult().ServiceHR!=0)
                    {
                        throw new UnexpectedTestResultException("Xkdc request failed: HR=0x"+string.Format("{0:X}", ctx.GetXkdcResult().ServiceHR));
                    }

                    newIp=ctx.ServiceCtxXe.siteIPAddress.GetIPEndPoint().Address.ToString();
                }
                catch (System.Exception e)
                {
                    fail=true;
                    throw new DidNotExecuteException(Name+" got exception getting a ticket for a previously-good client: "+e);
                }
                finally
                {
                    if (!fail || StressCommon.AlwaysRetainContext)
                    {
                        authContextCache.PushBack(pair);
                    }
                }

                //verify IP is the same
                if (ip!=newIp)
                {
                    throw new UnexpectedTestResultException("Got a different IP than what we originally got!  Machine="+string.Format("{0:X}",ctx.UsersMachine.xuid.qwUserID)+" originalIp="+ip+" newIp="+newIp);
                }
            }
        };
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XkdcTest.cs ===
using System;
using System.Diagnostics;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.STFTools;

using xonline.common.sql.webstore;
using xonline.common.config;

[assembly: RootNode(typeof(XkdcTest.Suite))]

namespace XkdcTest
{
    [Owner("LukeL"), TestFrequency("Daily"), FeatureArea("LiveFoundation"), TestCasePriority(1)]
    public class Suite: TestNode
    {
        public static bool DisableAskdcDos2OnStartup=true;
        public static bool DisableUserMachineTrustOnStartup=true;

        public Suite()
        {
        }

        //checks if a title is propped
        public static bool CheckTitle(uint title, uint version, AuthContext.ClientTypes platform)
        {
            if (!LiveTitle.CheckIfTitleIsPropped(title, version))
            {
                Global.RO.Warn("Title 0x{0:X8} version "+version+" is NOT propped.", title);
                return false;
            }

            return true;
        }

        //Changes the askdc ip-based anti-dos setting
        public static void AlterAskdcIPAntiDos(bool newSetting)
        {
            if (!XkdcTestBaseGroup.NpdbConnectionAvailable)
            {
                Global.RO.Debug("No npdb, so ignoring request to set askdc dos2 to "+newSetting);
                return;
            }

            //if we don't know the original/current value, look it up
            if (askdcIPDosOriginallyEnabled==null)
            {
                askdcIPDosOriginallyEnabled=Config.GetBoolSetting(Setting.kdcsvc_askdc_DoS2_enabled);
            }

            if (askdcIPDosCurrentlyEnabled==null)
            {
                askdcIPDosCurrentlyEnabled=askdcIPDosOriginallyEnabled;
            }

            //if the setting is different, or if they want to wait and we never waited long enough after a previous change
            DateTime now=DateTime.UtcNow;
            if (newSetting!=askdcIPDosCurrentlyEnabled)
            {
                Global.RO.Debug("Updating askdc DoS2 setting to: "+newSetting);

                long waitMs=(long)((now-askdcIPDosLastChange).TotalMilliseconds*1000);
                if (waitMs>XkdcTestBaseGroup.settingConfigRefreshTime)
                {
                    waitMs=XkdcTestBaseGroup.settingConfigRefreshTime;
                }
                if (waitMs<0)
                {
                    waitMs=0;
                }

                //do the update
                Npdb npdb=null;
                try
                {
                    npdb=new Npdb();
                    npdb.ConnectToServer();

                    string sqlquery = "update [t_settings] set vc_value='"+(newSetting?1:0)+"' where vc_setting='kdcsvc_askdc_DoS2_enabled'";

                    if (npdb.IssueCommand(sqlquery)<1)
                    {
                        throw new Exception("failed to update setting with query: "+sqlquery);
                    }
                }
                finally
                {
                    if (npdb!=null)
                    {
                        npdb.Close();
                    }
                }

                askdcIPDosCurrentlyEnabled=newSetting;
                XkdcTestBaseGroup.settingAskdcDOS2Enabled=newSetting;
                askdcIPDosLastChange=DateTime.UtcNow;

                //force config refresh
                RefreshKDCsConfig();
            }
        }

        //Restores the askdc ip-based anti-dos setting to it's original state (does not wait)
        public static void RestoreAskdcIPAntiDos()
        {
            if (askdcIPDosCurrentlyEnabled!=null)
            {
                AlterAskdcIPAntiDos((bool)askdcIPDosOriginallyEnabled);
            }

            //reset state to knowing nothing
            askdcIPDosOriginallyEnabled=null;
            askdcIPDosCurrentlyEnabled=null;
            askdcIPDosLastChange=DateTime.MinValue;
        }

        private static Nullable<bool> askdcIPDosOriginallyEnabled=null;
        private static Nullable<bool> askdcIPDosCurrentlyEnabled=null;
        private static DateTime askdcIPDosLastChange=DateTime.MinValue;
        static public bool IsAskdcIPAntiDosEnabled
        {
            get { return askdcIPDosCurrentlyEnabled==null?XkdcTestBaseGroup.settingAskdcDOS2Enabled:(bool)askdcIPDosCurrentlyEnabled; }
        }

        //gets a real (non-vip) internal IP for every kdc
        public static string[] GetKdcIPs()
        {
            System.Net.IPEndPoint []eps=ManagementListener.GetXmgmtEndPoints(xonline.common.config.Interface.kdcsvc);
            if (eps.Length==0)
            {
                throw new System.Exception("GetXmgmtEndPoints returned 0 entries for "+xonline.common.config.Interface.kdcsvc);
            }

            string []ips=new string[eps.Length];
            for (int i=0; i<eps.Length; ++i)
            {
                ips[i]=eps[i].Address.ToString();
            }

            return ips;
        }

        //does an xmgmt reload on all KDCs
        //returns true on success
        public static bool ReloadKDCs()
        {
            Global.RO.Debug("Doing a reload on each kdc...");
            bool good=true;

            string []serverIPs=GetKdcIPs();
            if (serverIPs==null)
            {
                return false;
            }

            if (serverIPs.Length==0)
            {
                Global.RO.Error("Could not find any KDC to run a reload against");
                return false;
            }
            else
            {
                //run on each kdc
                for (uint i=0; i<(uint)serverIPs.Length; ++i)
                {
                    if (serverIPs[i]==null) continue;

                    try
                    {
                        string []components={"xkdc","askdc","xmacs"};
                        foreach (string component in components)
                        {
                            string result;
                            bool worked=ManagementConsole.Execute(serverIPs[i], "e :"+component+" reload", out result);
                            if (result.Contains("not found")) worked=false;
                            string kdcName="(" + serverIPs[i] + ")";
                            if (worked)
                            {
                                Global.RO.Debug(kdcName + " "+component+" reloaded");
                            }
                            else
                            {
                                good=false;
                                Global.RO.Error("Error reloading "+component+" on " + kdcName + ": " + result);
                            }
                        }
                    }
                    catch
                    {
                        Global.RO.Error("xmgmt reload failed on server: " + "(" + serverIPs[i] + ").  One of the KDCs may be down?");
                        good=false;
                    }
                }
            }

            return good;
        }

        //does an xmgmt configcacherefresh on all KDCs
        //returns true on success
        public static bool RefreshKDCsConfig()
        {
            Global.RO.Debug("Doing a configcacherefresh on each kdc...");
            bool good=true;

            string []serverIPs=GetKdcIPs();
            if (serverIPs==null)
            {
                return false;
            }

            if (serverIPs.Length==0)
            {
                Global.RO.Error("Could not find any KDC to run a reload against");
                return false;
            }
            else
            {
                //run on each kdc
                for (uint i=0; i<(uint)serverIPs.Length; ++i)
                {
                    if (serverIPs[i]==null) continue;

                    string result;
                    bool worked=ManagementConsole.Execute(serverIPs[i], "e kdcsvc:XblConfig configcacherefresh", out result);
                    if (result.Contains("not found")) worked=false;
                    string kdcName="(" + serverIPs[i] + ")";
                    if (worked)
                    {
                        Global.RO.Debug(kdcName + "'s config refreshed");
                    }
                    else
                    {
                        good=false;
                        Global.RO.Error("Error refreshing config on " + kdcName + ": " + result);
                    }
                }
                string ret = String.Empty;

                if (!ManagementConsole.ExecuteOnAll("kdcsvc", "e :kdcmanagedproxy configcacherefresh", out ret))
                {
                    Global.RO.Error("configcacherefresh failed on the kdcmanagedproxy.");
                    good=false;
                }
            }

            return good;
        }

        //setup any global stuff
        SettingState orig_kdcsvc_xkdc_enableUserMachineTrust=null;

        private static bool isOneTimeInited=false;
        public override void PreRun()
        {
            // Build settings from ConfigDB (if available), otherwise set to default values.
            XkdcTestBaseGroup.GetSettings();

            // Disable askdc ip-based anti-dos, so that we can run more than a few tests
            if (DisableAskdcDos2OnStartup)
            {
                AlterAskdcIPAntiDos(false);
            }

            // Disable machine trust checks, as a majority of existing tests aren't set up in a way to handle it.
            if (DisableUserMachineTrustOnStartup)
            {
                Global.RO.Debug("Disabling xkdc user-machine trust.");
                orig_kdcsvc_xkdc_enableUserMachineTrust=Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_xkdc_enableUserMachineTrust, "2");
                Suite.RefreshKDCsConfig();
            }

            // -- one-time init stuff
            if (isOneTimeInited)
            {
                return;
            }

            //init kerbclient and  idcrl
            AuthClientBase.InitializeKerbClient();
            AuthClientBase.InitializePassportIDCRL();

            isOneTimeInited=true;

            // Build expectations from UODB (if available) and/or XML file
            Expectations.Import("SuitesData\\XKdc\\XkdcTest_Expectations.xml");

            // Save compile-time defaults to XML file
            Expectations.Export("SuitesData\\XKdc\\XkdcTest_Expectations_FromUodb.xml");
        }

        public override void PostRun()
        {
            // Restore settings
            RestoreAskdcIPAntiDos();

            if (orig_kdcsvc_xkdc_enableUserMachineTrust!=null)
            {
                Global.RO.Debug("Restoring xkdc user-machine trust.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_xkdc_enableUserMachineTrust);
                orig_kdcsvc_xkdc_enableUserMachineTrust=null;
                Suite.RefreshKDCsConfig();
            }
        }
    }

    /// <summary>
    /// Custom base class to allow dynamic generation of Xenon test cases based on previous Xbox client
    /// tests.
    /// </summary>
    public class XkdcTestBaseGroup : TestNode
    {
        static public bool                      NpdbConnectionAvailable = false;

        public AuthContext.ClientTypes          ParentClientType = AuthContext.ClientTypes.Xenon; //xenon unless changed
        //run using service request 2 (v4) unless specifically set to run using another version
        public int                              DefaultDefaultXkdcXenonPreauthVersion = 4;
        public int                              _DefaultXkdcXenonPreauthVersion = -1;

        public int DefaultXkdcXenonPreauthVersion
        {
            get
            {
                if (_DefaultXkdcXenonPreauthVersion == -1)
                {
                    if (MyValues != null && MyValues.Length != 0 && MyValues[0] is int)
                    {
                        _DefaultXkdcXenonPreauthVersion = (int)MyValues[0];
                    }
                    else
                    {
                        _DefaultXkdcXenonPreauthVersion = DefaultDefaultXkdcXenonPreauthVersion;
                    }
                }

                return _DefaultXkdcXenonPreauthVersion;
            }
            set
            {
                _DefaultXkdcXenonPreauthVersion = value;
            }
        }

        public override void PreRun ()
        {
            Global.RO.Info("Running group as {0} client", ParentClientType.ToString());
            Global.RO.Debug("Default XkdcXenonPreauthVersion="+DefaultXkdcXenonPreauthVersion);
        }

        // Global settings, pulled from NPDB if available.  Used to alter behavior of certain tests.
        static public bool  settingXmacsDOSEnabled          = true;
        static public bool  settingXmacsDOS2Enabled         = true;
        static public bool  settingAllowUnknownVersions     = true;
        static public int   settingXmacsTimeSkew            = 300;
        static public bool  settingAskdcDOSEnabled          = true;
        static public bool  settingAskdcDOS2Enabled         = true;
        static public bool  settingXkdcDOSEnabled           = true;
        static public bool  settingXkdcDOS2Enabled          = true;
        static public bool  settingEchoEnabled              = true;
        static public int   settingConfigRefreshTime        = 300*1000;
        static public bool  settingXkdcSubscriptionBackCompat = true;

        public static void GetSettings()
        {
            // Quickly grab NPDB settings
            //

            Config.NpdbConnectionTimeout = 5;  // in seconds
            if (Global.IsEnvironmentInternal)
            {
                string npdbIp=Global.CurrentEnvironment.NpdbIp;
                Global.RO.Info("Attempting to get settings from Npdb...");
                try
                {
                    // This should timeout faster than CommonConfig
                    IPHostEntry hostInfo = System.Net.Dns.GetHostEntry(npdbIp);
                    if (hostInfo.AddressList.Length <= 0)
                    {
                        return;
                    }

                    settingXmacsDOSEnabled = !Config.GetBoolSetting(Setting.kdcsvc_xmacs_disableDOS);
                    settingXmacsDOS2Enabled = Config.GetBoolSetting(Setting.kdcsvc_xmacs_DoS2_enabled);
                    settingAllowUnknownVersions = Config.GetBoolSetting(Setting.kdcsvc_xkdc_allowUnknownVersion);
                    settingXmacsTimeSkew = Config.GetIntSetting(Setting.kdcsvc_xmacs_timeSkewSeconds);
                    settingAskdcDOSEnabled = Config.GetBoolSetting(Setting.kdcsvc_askdc_checkForDos);
                    settingAskdcDOS2Enabled = Config.GetBoolSetting(Setting.kdcsvc_askdc_DoS2_enabled); //You probably want to use Suite.IsAskdcIPAntiDosEnabled instead of this
                    settingEchoEnabled = Config.GetBoolSetting(Setting.kdcsvc_askdc_echo_enabled);
                    settingXkdcDOSEnabled = Config.GetBoolSetting(Setting.kdcsvc_xkdc_DoS_checkForDos);
                    settingXkdcDOS2Enabled = Config.GetBoolSetting(Setting.kdcsvc_xkdc_DoS2_enabled);
                    settingConfigRefreshTime = Config.GetIntSetting(Setting.config_cacheRefreshInterval);
                    settingXkdcSubscriptionBackCompat = Config.GetBoolSetting(Setting.kdcsvc_xkdc_userAuthorizationBackwardsCompatibility);

                    NpdbConnectionAvailable = true;
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Error connecting to {0}, got exception: {1}", npdbIp, e.Message);
                }
            }
            else
            {
                Global.RO.Debug("Assuming defaults for npdb settings.");
            }

            Global.RO.Debug("[Settings] XmacsDOSEnabled={0}", settingXmacsDOSEnabled);
            Global.RO.Debug("[Settings] AllowUnknownVersions={0}", settingAllowUnknownVersions);
            Global.RO.Debug("[Settings] XmacsTimeSkew={0}", settingXmacsTimeSkew);
            Global.RO.Debug("[Settings] AskdcDOSEnabled={0}", settingAskdcDOSEnabled);
            Global.RO.Debug("[Settings] AskdcDOS2Enabled={0}", settingAskdcDOS2Enabled);
            Global.RO.Debug("[Settings] XkdcDOSEnabled={0}", settingXkdcDOSEnabled);
            Global.RO.Debug("[Settings] XkdcDOS2Enabled={0}", settingXkdcDOS2Enabled);
            Global.RO.Debug("[Settings] EchoEnabled={0}", settingEchoEnabled);
            Global.RO.Debug("[Settings] ConfigRefreshTime={0}", settingConfigRefreshTime);
            Global.RO.Debug("[Settings] XkdcSubscriptionBackCompat={0}", settingXkdcSubscriptionBackCompat);
        }
    }

    // -- gui options
    #region Gui Controls

    public class KdcSettingsGui: ServerTestFramework.Plugins.IPluginSetup, STFGui.Plugins.IPluginGui
    {
        private static System.Windows.Forms.MenuItem miKCOff, miKCWarn, miKCFull;
        private static System.Windows.Forms.MenuItem miXmacsTestKey;

        static KdcSettingsGui()
        {
            Global.Singleton.EnvironmentChangedSuccessEvent+=EnvironmentChangedCallback;
        }

        private static void EnvironmentChangedCallback(string name)
        {
            if (miXmacsTestKey!=null)
            {
                miXmacsTestKey.Checked=XmacsClient.UseXmacsTestKey();
            }
        }

        public System.Windows.Forms.MenuItem GetNewMenu()
        {
            System.Windows.Forms.MenuItem baseMenu=new System.Windows.Forms.MenuItem("KDC Setup");

            //default test/real key use
            miXmacsTestKey=new System.Windows.Forms.MenuItem("Xmacs: Use Test Key by default", MenuChoice_XmacsTestKey);
            miXmacsTestKey.Checked=XmacsClient.UseXmacsTestKey();
            baseMenu.MenuItems.Add(miXmacsTestKey);

            //askdc ip-based anti-dos toggling
            System.Windows.Forms.MenuItem miDisableAskdcIPDos=new System.Windows.Forms.MenuItem("Askdc: Disable IP-based anti-dos during run", MenuChoice_AskdcDos);
            miDisableAskdcIPDos.Checked=Suite.DisableAskdcDos2OnStartup;
            baseMenu.MenuItems.Add(miDisableAskdcIPDos);

            //xkdc user machine trust disable toggling
            System.Windows.Forms.MenuItem miDisableXkdcUMTrust=new System.Windows.Forms.MenuItem("Xkdc: Disable User-Machine Trust Check during run", MenuChoice_XkdcUMTrust);
            miDisableXkdcUMTrust.Checked=Suite.DisableUserMachineTrustOnStartup;
            baseMenu.MenuItems.Add(miDisableXkdcUMTrust);

            System.Windows.Forms.MenuItem miSep=new System.Windows.Forms.MenuItem("-", (System.EventHandler)null);
            baseMenu.MenuItems.Add(miSep);

            //verbose XkdcClient spew
            System.Windows.Forms.MenuItem miXkdcClientVerbose=new System.Windows.Forms.MenuItem("NativeXkdc: Verbose output", MenuChoice_XkdcClientVerbose);
            miXkdcClientVerbose.Checked=XkdcClient.EnableOverlyVerboseOutput;
            baseMenu.MenuItems.Add(miXkdcClientVerbose);

            //verbose AsdcClient spew
            System.Windows.Forms.MenuItem miAskdcClientVerbose=new System.Windows.Forms.MenuItem("NativeAskdc: Verbose output", MenuChoice_AskdcClientVerbose);
            miAskdcClientVerbose.Checked=AskdcClient.EnableOverlyVerboseOutput;
            baseMenu.MenuItems.Add(miAskdcClientVerbose);

            //verbose Managed KDC Client spew
            System.Windows.Forms.MenuItem miKdcClientVerbose=new System.Windows.Forms.MenuItem("KdcClient: Verbose output", MenuChoice_KdcClientVerbose);
            miKdcClientVerbose.Checked=KdcClient.VerboseOutput;
            baseMenu.MenuItems.Add(miKdcClientVerbose);

            miSep=new System.Windows.Forms.MenuItem("-", (System.EventHandler)null);
            baseMenu.MenuItems.Add(miSep);

            //KerbClient verbosity control
            miKCOff=new System.Windows.Forms.MenuItem("KerbClient verbosity: Off", MenuChoice_KerbClientVerbose);
            miKCWarn=new System.Windows.Forms.MenuItem("KerbClient verbosity: Warn", MenuChoice_KerbClientVerbose);
            miKCFull=new System.Windows.Forms.MenuItem("KerbClient verbosity: Full", MenuChoice_KerbClientVerbose);
            if (AuthClientBase.KerbClientDebugSpew==AuthClientBase.KerbClientDebugLevel.Off) miKCOff.Checked=true;
            if (AuthClientBase.KerbClientDebugSpew==AuthClientBase.KerbClientDebugLevel.Warn) miKCWarn.Checked=true;
            if (AuthClientBase.KerbClientDebugSpew==AuthClientBase.KerbClientDebugLevel.All) miKCFull.Checked=true;
            baseMenu.MenuItems.Add(miKCOff);
            baseMenu.MenuItems.Add(miKCWarn);
            baseMenu.MenuItems.Add(miKCFull);

            return baseMenu;
        }

        private void MenuChoice_XmacsTestKey(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            XmacsClient.GlobalOverrideUsingXmacsTestKey=(mi.Checked?1:0);
            Global.RO.Info("UseXmacsTestKey="+XmacsClient.UseXmacsTestKey());
        }

        private void MenuChoice_AskdcDos(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            Suite.DisableAskdcDos2OnStartup=mi.Checked;
            Global.RO.Info("DisableAskdcDos2OnStartup="+Suite.DisableAskdcDos2OnStartup);
        }

        private void MenuChoice_XkdcUMTrust(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            Suite.DisableUserMachineTrustOnStartup=mi.Checked;
            Global.RO.Info("DisableXkdcUMTrust="+Suite.DisableUserMachineTrustOnStartup);
        }

        private void MenuChoice_XkdcClientVerbose(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            XkdcClient.EnableOverlyVerboseOutput=mi.Checked;
            Global.RO.Info("XkdcClientVerboseOutput="+XkdcClient.EnableOverlyVerboseOutput);
        }

        private void MenuChoice_AskdcClientVerbose(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            AskdcClient.EnableOverlyVerboseOutput=mi.Checked;
            Global.RO.Info("AskdcClientVerboseOutput="+AskdcClient.EnableOverlyVerboseOutput);
        }

        private void MenuChoice_KdcClientVerbose(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            KdcClient.VerboseOutput=mi.Checked;
            Global.RO.Info("KdcClient.VerboseOutput="+KdcClient.VerboseOutput);
        }

        private void MenuChoice_KerbClientVerbose(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            if (mi==miKCOff)
            {
                AuthClientBase.KerbClientDebugSpew=AuthClientBase.KerbClientDebugLevel.Off;
                miKCOff.Checked=true;
                miKCWarn.Checked=false;
                miKCFull.Checked=false;
            }
            else if (mi==miKCWarn)
            {
                AuthClientBase.KerbClientDebugSpew=AuthClientBase.KerbClientDebugLevel.Warn;
                miKCOff.Checked=false;
                miKCWarn.Checked=true;
                miKCFull.Checked=false;
            }
            else if (mi==miKCFull)
            {
                AuthClientBase.KerbClientDebugSpew=AuthClientBase.KerbClientDebugLevel.All;
                miKCOff.Checked=false;
                miKCWarn.Checked=false;
                miKCFull.Checked=true;
            }
            else
            {
                Global.RO.Warn("Bad menu item passed to event...???");
            }

            Global.RO.Info("KerbClientVerbose="+AuthClientBase.KerbClientDebugSpew);
        }

        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            foreach (string s in commandlineParameters)
            {
                if (s.StartsWith("UseTestKey="))
                {
                    bool option;
                    if (bool.TryParse(s.Substring(11), out option))
                    {
                        Global.RO.Info("KdcSettingsGui: Picked up commandline option, UseTestKey="+option);
                        XmacsClient.GlobalOverrideUsingXmacsTestKey=(option?1:0);
                    }
                    else
                    {
                        Global.RO.Warn("Failed to parse value for the UseTestKey parameter.");
                    }
                }
                else
                {
                    Global.RO.Warn("Unknown option passed to KdcSettingsGui: "+s);
                }
            }
        }

        public void Shutdown(XmlNode pluginSettings)
        {
        }

        #region IPluginGui Members

        public STFGui.Plugins.MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public System.Windows.Forms.TabPage GetNewTabPage ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XkdcUserMachineTrust.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;

namespace XkdcTest
{
    [TestGroup, Description("Tests for xkdc user machine trust (part of roaming profiles).")]
    [CompoundCase("Default", 0)]
    [CompoundCase("Enabled", 1)]
    [CompoundCase("Disabled", 2)]
    public class XkdcUserMachineTrust: TestNode
    {
        SettingState orig_kdcsvc_xkdc_enableUserMachineTrust=null;

        public override void PreRun()
        {
            //save the original trust setting state
            orig_kdcsvc_xkdc_enableUserMachineTrust=Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_xkdc_enableUserMachineTrust, 1);

            //override the setting
            int settingValue=(int)MyValues[0];
            CreateContextData();
            SetContextData("UMTrustLevel", settingValue);

            Global.RO.Debug("Setting xkdc user-machine trust level to: "+settingValue);
            Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_xkdc_enableUserMachineTrust, settingValue.ToString());
            Suite.RefreshKDCsConfig();
        }

        public override void PostRun()
        {
            if (orig_kdcsvc_xkdc_enableUserMachineTrust!=null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring xkdc user-machine trust.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_xkdc_enableUserMachineTrust);
                orig_kdcsvc_xkdc_enableUserMachineTrust=null;
                Suite.RefreshKDCsConfig();
            }
        }

        //we keep a cache of 4+ users that we rotate through so that a single test can pull up to 4 different users for multi-user cases
        //we also limit their time-between-reuse to avoid triggering kdc anti-dos code
        private static TimedQueue<KdcUser> cachedUsers=null;

        public static KdcUser GetCachedUser(bool needsPassport)
        {
            if (cachedUsers==null)
            {
                cachedUsers=new TimedQueue<KdcUser>();
                cachedUsers.MinimumReuseTime=new System.TimeSpan(0, 0, 0, 5);
                cachedUsers.MinimumQueueSize=4;
            }

            KdcUser user=cachedUsers.PopFront();

            if (user==null)
            {
                user=new KdcUser();
                user.CreateUser(false);
            }

            if (needsPassport)
            {
                if (user.Passport==null)
                {
                    user.LinkPassport(null);
                }

                user.Passport.EncryptForPanoramaByDefault=false; //reset field to default
            }

            UserMachineHistoryEditor.ObliterateUserHistory(user.UserID);

            cachedUsers.PushBack(user);
            return user;
        }

        // --

        public enum UMTrust
        {
            NonexistentTrust, //no entry in t_user_machine_history
            TrustedValid, //entry in t_user_machine_history is trusted, and last signout date is in the future
            TrustedExpired, //entry in t_user_machine_history is trusted, and last signout date is in the past
            UntrustedValid, //entry in t_user_machine_history is untrusted, and last signout date is in the future
            UntrustedExpired, //entry in t_user_machine_history is untrusted, and last signout date is in the past
            UntrustedUnknown, //entry in t_user_machine_history is untrusted, and last signout date is null
            UnknownValid, //entry in t_user_machine_history is unknown, and last signout date is in the future
            UnknownExpired, //entry in t_user_machine_history is unknown, and last signout date is in the past
            UnknownUnknown //entry in t_user_machine_history is unknown, and last signout date is null
        };

        public static string GetShortNameForAuthType(uint type)
        {
            if (type==WindowsPacAuthData.CT_RandomKey)
            {
                return "Key";
            }
            else if (type==WindowsPacAuthData.CT_RawPassport)
            {
                return "RawPassport";
            }
            else if (type==WindowsPacAuthData.CT_EncryptedPassport)
            {
                return "EncPassport";
            }
            else
            {
                throw new System.Exception("Unhandled AuthType: "+type);
            }
        }

        public static string GetShortNameForClientType(AuthContext.ClientTypes type)
        {
            if (type==AuthContext.ClientTypes.Xenon)
            {
                return "Xbox360";
            }
            else if (type==AuthContext.ClientTypes.Panorama)
            {
                return "PC";
            }
            else
            {
                throw new System.Exception("Unhandled ClientType: "+type);
            }
        }

        public static void SetTrustForMachine(ulong user, ulong machine, UMTrust trust)
        {
            if (trust==UMTrust.NonexistentTrust)
            {
                return;
            }

            UserMachineHistoryEditor umTrustEditor=UserMachineHistoryEditor.CreateOrUseExisting(user, machine);

            if (trust==UMTrust.TrustedValid)
            {
                umTrustEditor.TrustLevel=1;
                umTrustEditor.LastSignout=System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0);
            }
            else if (trust==UMTrust.TrustedExpired)
            {
                umTrustEditor.TrustLevel=1;
                umTrustEditor.LastSignout=System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0);
            }
            else if (trust==UMTrust.UntrustedValid)
            {
                umTrustEditor.TrustLevel=0;
                umTrustEditor.LastSignout=System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0);
            }
            else if (trust==UMTrust.UntrustedExpired)
            {
                umTrustEditor.TrustLevel=0;
                umTrustEditor.LastSignout=System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0);
            }
            else if (trust==UMTrust.UntrustedUnknown)
            {
                umTrustEditor.TrustLevel=0;
                umTrustEditor.LastSignout=null;
            }
            else if (trust==UMTrust.UnknownValid)
            {
                umTrustEditor.TrustLevel=-1;
                umTrustEditor.LastSignout=System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0);
            }
            else if (trust==UMTrust.UnknownExpired)
            {
                umTrustEditor.TrustLevel=-1;
                umTrustEditor.LastSignout=System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0);
            }
            else if (trust==UMTrust.UnknownUnknown)
            {
                umTrustEditor.TrustLevel=-1;
                umTrustEditor.LastSignout=null;
            }
            else
            {
                throw new System.Exception("Unhandled trust: "+trust);
            }
        }

        public static void AuthUserWithAskdc(KdcClient client, KdcUser user, uint authType)
        {
            if (authType==WindowsPacAuthData.CT_RandomKey) //use xbox360 always, transplant result in
            {
                KdcClientXbox360 tempKdc=new KdcClientXbox360();

                ((KdcClient)tempKdc).AskdcOutput=client.AskdcOutput;

                tempKdc.CreateAskdcUserRequest(user);
                tempKdc.AskdcRequest.Input.PlainPassport=null;
                tempKdc.AskdcRequest.Input.EncryptedPassport=null;
                tempKdc.ExecuteAskdc(true);

                client.CreateAskdcUserRequest(user);
                client.AskdcReply=tempKdc.AskdcReply;
                client.AskdcOutput=tempKdc.AskdcOutput;
            }
            else if (authType==WindowsPacAuthData.CT_RawPassport) //use pc always, transplant result in
            {
                KdcClientPC tempKdc=new KdcClientPC();

                ((KdcClient)tempKdc).AskdcOutput=client.AskdcOutput;

                tempKdc.CreateAskdcUserRequest(user);
                tempKdc.AskdcRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                tempKdc.AskdcRequest.Input.EncryptedPassport=null;
                tempKdc.ExecuteAskdc(true);

                client.CreateAskdcUserRequest(user);
                client.AskdcReply=tempKdc.AskdcReply;
                client.AskdcOutput=tempKdc.AskdcOutput;
            }
            else if (authType==WindowsPacAuthData.CT_EncryptedPassport) //ok for all
            {
                client.CreateAskdcUserRequest(user);
                client.AskdcRequest.Input.PlainPassport=null;
                if (client.CurrentClientType==AuthContext.ClientTypes.Xenon)
                {
                    client.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcXenon);
                }
                else
                {
                    client.AskdcRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);
                }
                client.ExecuteAskdc(true);
            }
            else
            {
                throw new System.Exception("Unhandled authType: "+authType);
            }
        }

        public static void ExecuteXkdcAndVerifyEverything(KdcClient client, int settingLevel, int srPreauthVersion)
        {
            //get information from xmacs and askdc replies
            ulong machine=client.XmacsOutput.MachineId;

            uint []userAuthType=new uint[4];
            for (int u=0; u<4 && u<client.AskdcOutput.UserIds.Length; ++u)
            {
                if (client.AskdcOutput.UserIds[u]!=0)
                {
                    userAuthType[u]=client.AskdcReply.AuthData.FindPuidCredentialType(client.AskdcOutput.UserIds[u]);
                }
            }

            //prepare xkdc request
            if (client.XkdcRequest==null)
            {
                client.CreateXkdcRequest();
            }

            client.XkdcRequest.Input.XenonPreauthVersion=(ushort)(srPreauthVersion>=5?5:4);
            client.XkdcRequest.Input.ServiceRequestVersion=(ushort)srPreauthVersion;
            client.XkdcThrowOnOverallHRFailure=false;

            //see if we are expecting tgt revoked due to an askdc enc-passport-auth ticket being issued prior to the last sign out
            int maxUsers=client.XkdcRequest.Input.UserIDs.Length;
            bool enforceOnCurrentVersion=(settingLevel==1 || (settingLevel==0 && srPreauthVersion>=6));

            bool expectTgtRevoked=false;

            for (int u=0; u<4 && u<maxUsers; ++u)
            {
                if (userAuthType[u]==WindowsPacAuthData.CT_RawPassport) //raw passport should never work on xbox360
                {
                    if (client.CurrentClientType==AuthContext.ClientTypes.Xenon)
                    {
                        expectTgtRevoked=true;
                    }
                }
            }

            if (expectTgtRevoked)
            {
                client.XkdcThrowOnKerberosError=false;
            }

            //make the request
            client.ExecuteXkdc(true);

            //debug spew out the HRs
            Global.RO.Debug("Machine="+string.Format("0x{0:X}", machine)+string.Format(" User0=0x{0:X}", (0<maxUsers)?client.XkdcRequest.Input.UserIDs[0]:0)+string.Format(" User1=0x{0:X}", (1<maxUsers)?client.XkdcRequest.Input.UserIDs[1]:0)+string.Format(" User2=0x{0:X}", (2<maxUsers)?client.XkdcRequest.Input.UserIDs[2]:0)+string.Format(" User3=0x{0:X}", (3<maxUsers)?client.XkdcRequest.Input.UserIDs[3]:0));
            if (client.XkdcOutput!=null)
            {
                Global.RO.Debug("OverallHR=0x"+string.Format("{0:X}", client.XkdcOutput.Hr)+" User0HR=0x"+string.Format("{0:X}", client.XkdcOutput.HrUser[0])+" User1HR=0x"+string.Format("{0:X}", client.XkdcOutput.HrUser[1])+" User2HR=0x"+string.Format("{0:X}", client.XkdcOutput.HrUser[2])+" User3HR=0x"+string.Format("{0:X}", client.XkdcOutput.HrUser[3]));
            }

            //check for machine-level issues (banned, requires update, etc)
            bool expectOverallHrSuccess=true;
            MachineEditor machineEdit=MachineEditor.FromId(machine);
            if (machineEdit.GetAllMachineBans().Length>0) //our tests here don't use any expired bans so this works
            {
                expectOverallHrSuccess=false;
                ValueCheck.Test("Got a ServiceAddress back", true, client.XkdcOutput!=null);
                ValueCheck.Test("OverallHR", 0x8015190D, client.XkdcOutput.Hr); //XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED
            }

            if (client.XkdcRequest.Input.TitleID==0x3EEF0801 && client.XkdcRequest.Input.TitleVersion==1) //has an update to version 3
            {
                expectOverallHrSuccess=false;
                ValueCheck.Test("Got a ServiceAddress back", true, client.XkdcOutput!=null);

                if (client.XkdcRequest.Input.AutoDiscoverServices==1)
                {
                    ValueCheck.Test("OverallHR", 0x80151002, client.XkdcOutput.Hr); //XONLINE_E_LOGON_UPDATE_REQUIRED
                }
                else //the only specific-service test here requests autoupdate, which will succeed
                {
                    ValueCheck.Test("OverallHR", 0, client.XkdcOutput.Hr);
                }
            }

            if (client.XkdcRequest.Input.FlashVersion==27) //has an update to version 28
            {
                expectOverallHrSuccess=false;
                ValueCheck.Test("Got a ServiceAddress back", true, client.XkdcOutput!=null);
                ValueCheck.Test("OverallHR", 0x80151007, client.XkdcOutput.Hr); //XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED
            }

            if (client.XkdcRequest.Input.TitleID==0x3E761248) //does not exist
            {
                expectOverallHrSuccess=false;
                ValueCheck.Test("Got a ServiceAddress back", true, client.XkdcOutput!=null);
                ValueCheck.Test("OverallHR", 0x80151912, client.XkdcOutput.Hr); //XONLINE_E_LOGON_UNKNOWN_TITLE
            }

            //verify tgt revocation if the machine was ok
            if (expectTgtRevoked && expectOverallHrSuccess)
            {
                if (client.XkdcError==null)
                {
                    throw new UnexpectedTestResultException("Expected a kerberos error (KDC_ERR_TGT_REVOKED) but got a kerberos reply.");
                }

                ValueCheck.Test("Kerberos Error", 0x14, (int)client.XkdcError.ErrorCode.Int64); //KDC_ERR_TGT_REVOKED
                return;
            }

            if (expectOverallHrSuccess)
            {
                ValueCheck.Test("OverallHR", 0, client.XkdcOutput.Hr);
            }
            else
            {
                //Our kdc seperates user and machine policy checks into different phases.  If the request fails machine-level checks then user-level checks are never performed.  So if the overall HR is failed, we simply expect user HRs to be 0 in the response and the authdata to have no puid for the user.  It's not completely intuitive but it's how our KDC works.
                if (client.XkdcOutput!=null && client.XkdcOutput.XboxAuthData!=null)
                {
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User"+u+"Puid in AuthData", 0, client.XkdcOutput.XboxAuthData.GetUser((uint)u).UserID);
                        ValueCheck.Test("User"+u+"HR in ServiceAddress", 0, client.XkdcOutput.HrUser[u]);
                    }
                }

                return;
            }

            //
            bool anyUserHasHrThatForcesFailed=false;
            if (srPreauthVersion>=6)
            {
                for (int u=0; u<4; ++u)
                {
                    if (u<maxUsers && client.XkdcRequest.Input.UserIDs[u]!=0) //valid slot
                    {
                        if (client.XkdcOutput.HrUser[u]!=0)
                        {
                            if (!(client.XkdcOutput.HrUser[u]==0x80151200 || client.XkdcOutput.HrUser[u]==0x80151013)) //XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT or XONLINE_E_LOGON_USER_UNKNOWN_TRUST
                            {
                                anyUserHasHrThatForcesFailed=true;
                            }
                        }
                    }
                }
            }

            //check user-specific trust
            bool expectValidTicket=true;
            for (int u=0; u<4; ++u)
            {
                if (u<maxUsers && client.XkdcRequest.Input.UserIDs[u]!=0) //valid slot
                {
                    ulong user=client.XkdcRequest.Input.UserIDs[u];

                    //find the last signout date on any machine
                    System.DateTime ?lastSignout=null;

                    foreach (UserMachineHistoryEditor umhe in UserMachineHistoryEditor.FromUserId(user))
                    {
                        if (umhe.LastSignout!=null)
                        {
                            if (lastSignout==null || lastSignout<umhe.LastSignout)
                            {
                                lastSignout=umhe.LastSignout;
                            }
                        }
                    }

                    UserMachineHistoryEditor umTrustEditor=UserMachineHistoryEditor.FromId(user, machine);
                    UserEditor userEdit=UserEditor.FromPuid(user);

                    //figure out user expected trust
                    bool expectRpsExpired=false;
                    bool expectUserIsTrusted=false;
                    bool expectUserPrivileges=false;

                    if (enforceOnCurrentVersion && userAuthType[u]==WindowsPacAuthData.CT_EncryptedPassport && lastSignout!=null && lastSignout>client.AskdcOutput.Ticket.EncryptedBody.StartTime.DateTime && (!umTrustEditor.Exists || (umTrustEditor.Exists && umTrustEditor.TrustLevel!=1)))
                    {
                        expectRpsExpired=true;
                        expectValidTicket=false;
                    }

                    if (userAuthType[u]==WindowsPacAuthData.CT_RawPassport) //using a raw passport is currently always trusted
                    {
                        expectUserIsTrusted=true;
                        expectUserPrivileges=true;
                    }
                    else if (userAuthType[u]==WindowsPacAuthData.CT_EncryptedPassport) //using an encrypted passport is always trusted (if it's not revoked as above)
                    {
                        expectUserIsTrusted=true;
                        expectUserPrivileges=true;
                    }
                    else //using a key is sometimes trusted depending on user-machine history
                    {
                        if (enforceOnCurrentVersion)
                        {
                            if (!umTrustEditor.Exists) //does not exist, do not trust
                            {
                                expectUserIsTrusted=false;
                                expectUserPrivileges=false;
                                expectValidTicket=false;
                            }
                            else if (umTrustEditor.TrustLevel==0 || umTrustEditor.TrustLevel==-1) //not trusted
                            {
                                expectUserIsTrusted=false;
                                expectUserPrivileges=false;
                                expectValidTicket=false;
                            }
                            else if (umTrustEditor.TrustLevel==1) //trusted
                            {
                                expectUserIsTrusted=true;
                                expectUserPrivileges=true;
                            }
                        }
                        else //not enforcing on this version
                        {
                            expectUserIsTrusted=true;
                            expectUserPrivileges=true;
                        }
                    }

                    //verify it
                    if (expectRpsExpired)
                    {
                        expectUserPrivileges=false;
                        ValueCheck.Test("Xkdc User"+u+" HR", 0x80151010, client.XkdcOutput.HrUser[u]); //XONLINE_E_LOGON_USER_RPS_EXPIRED
                    }
                    else if (expectUserIsTrusted)
                    {
                        //check banned
                        if (userEdit.BannedUntilDate>=System.DateTime.UtcNow)
                        {
                            expectUserPrivileges=false;

                            if (srPreauthVersion<=5) //old clients get "require managament"
                            {
                                ValueCheck.Test("Xkdc User"+u+" HR", 0x80151200, client.XkdcOutput.HrUser[u]); //XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
                            }
                            else //new clients get "account banned"
                            {
                                ValueCheck.Test("Xkdc User"+u+" HR", 0x80154005, client.XkdcOutput.HrUser[u]); //XONLINE_E_ACCOUNTS_ACCOUNT_BANNED
                                expectValidTicket=false;
                            }
                        }
                        else
                        {
                            //check other states
                            bool nameChangeRequired=userEdit.NameChangeRequired!=0;

                            if (nameChangeRequired && !anyUserHasHrThatForcesFailed)
                            {
                                expectUserPrivileges=false;
                                ValueCheck.Test("Xkdc User"+u+" HR", 0x80151200, client.XkdcOutput.HrUser[u]); //XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
                            }
                            else
                            {
                                ValueCheck.Test("Xkdc User"+u+" HR", 0, client.XkdcOutput.HrUser[u]); //we strip out requires management for the multi-user case where the other user forced service-address-failed
                            }

                            if (!client.XkdcReply.ReplyWasServiceAddressFailure) //ignore flags if they are not present
                            {
                                ValueCheck.TestDifferent("Xkdc User"+u+" Flags", 0, client.XkdcOutput.UserFlags[u]);
                            }
                        }
                    }
                    else //user not trusted
                    {
                        ValueCheck.Test("Xkdc User"+u+" HR", 0x8015100F, client.XkdcOutput.HrUser[u]); //XONLINE_E_LOGON_USER_NOT_TRUSTED
                    }

                    if (!client.XkdcReply.ReplyWasServiceAddressFailure) //ignore privileges if they are not present
                    {
                        bool userHasPrivileges=false;
                        for (int p=160; p<256; ++p)
                        {
                            if (client.XkdcOutput.GetUserPrivilegeBit(u, p))
                            {
                                userHasPrivileges=true;
                            }
                        }

                        ValueCheck.Test("User has privileges", expectUserPrivileges, userHasPrivileges);
                    }
                }
                else //not a real user, verify it's blank
                {
                    ValueCheck.Test("Xkdc User"+u+" HR", 0, client.XkdcOutput.HrUser[u]);
                    ValueCheck.Test("Xkdc User"+u+" Flags", 0, client.XkdcOutput.UserFlags[u]);
                }
            }

            bool gotValidTicket=(client.XkdcOutput.ServiceName[1].ToLower()!="site0");
            ValueCheck.Test("Got a valid ticket from xkdc", expectValidTicket, gotValidTicket);
        }

        // --

        [TestGroup]
        [CompoundCase("V{0}", 4)]
        [CompoundCase("V{0}", 5)]
        [CompoundCase("V{0}", 6)]
        public class SRPreauthVersion: TestNode
        {
            public override void PreRun()
            {
                int srVersion=(int)MyValues[0];
                CreateContextData();
                SetContextData("SRVersion", srVersion);
            }

            protected override void PostProcessBranchConstruction()
            {
                System.Collections.Generic.List<TestNode> nodesToCut=new System.Collections.Generic.List<TestNode>();

                //Trim all of V4 except for SimpleOneUser.
                if (Name=="V4")
                {
                    foreach (TestNode n in Children)
                    {
                        if (n.Name!="SimpleOneUser")
                        {
                            if (!nodesToCut.Contains(n))
                            {
                                nodesToCut.Add(n);
                            }
                        }
                    }
                }

                //For setting level 0(default) and 2(disable), trim all except SimpleOneUse
                if (Parent.Parent.Name=="Disabled" || Parent.Parent.Name=="Default")
                {
                    foreach (TestNode n in Children)
                    {
                        if (!(n.Name=="SimpleOneUser"))
                        {
                            if (!nodesToCut.Contains(n))
                            {
                                nodesToCut.Add(n);
                            }
                        }
                    }
                }

                //
                foreach (TestNode n in nodesToCut)
                {
                    RemoveChild(n);
                }
            }

            // --

            [TestCase]
            public class SimpleOneUser: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    foreach (UMTrust trust in new UMTrust[]{UMTrust.NonexistentTrust, UMTrust.TrustedValid, UMTrust.TrustedExpired, UMTrust.UntrustedValid, UMTrust.UntrustedExpired, UMTrust.UnknownValid, UMTrust.UnknownExpired})
                    {
                        foreach (uint authType in new uint[]{WindowsPacAuthData.CT_RandomKey, WindowsPacAuthData.CT_RawPassport, WindowsPacAuthData.CT_EncryptedPassport})
                        {
                            foreach (AuthContext.ClientTypes clientType in new AuthContext.ClientTypes[]{AuthContext.ClientTypes.Xenon, AuthContext.ClientTypes.Panorama})
                            {
                                //trim some tests down, we have way too many
                                if (authType==WindowsPacAuthData.CT_RawPassport && clientType!=AuthContext.ClientTypes.Panorama && trust!=UMTrust.UntrustedValid)
                                {
                                    continue;
                                }

                                if (trust==UMTrust.TrustedExpired && authType!=WindowsPacAuthData.CT_EncryptedPassport && clientType!=AuthContext.ClientTypes.Xenon)
                                {
                                    continue;
                                }

                                //add the instance
                                string name=trust.ToString()+" "+GetShortNameForAuthType(authType)+" "+GetShortNameForClientType(clientType);
                                CompoundCaseAttribute cca=new CompoundCaseAttribute(name, trust, authType, clientType);
                                instances.Add(cca);
                            }
                        }
                    }
                }

                public override void Run()
                {
                    UMTrust trustForMachine=(UMTrust)MyValues[0];
                    uint authType=(uint)MyValues[1];
                    AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)MyValues[2];
                    int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                    int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                    //prepare the user and machine
                    bool needPassport=(authType!=WindowsPacAuthData.CT_RandomKey) || (clientType==AuthContext.ClientTypes.Panorama);
                    KdcUser user=GetCachedUser(needPassport);
                    KdcClient kdc=new KdcClient(clientType);
                    kdc.CreateXmacsRequest();
                    if (needPassport)
                    {
                        user.Passport.EncryptForPanoramaByDefault=(authType==WindowsPacAuthData.CT_EncryptedPassport);
                        kdc.XmacsRequest.Input.PlainPassport=user.Passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                    }

                    kdc.ExecuteXmacs(true);

                    SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, trustForMachine);

                    //hit the askdc for the machine if not using a raw passport
                    if (authType!=WindowsPacAuthData.CT_RawPassport)
                    {
                        kdc.CreateAskdcMachineRequest();
                        kdc.ExecuteAskdc(true);
                    }

                    //hit askdc for the user
                    AuthUserWithAskdc(kdc, user, authType);

                    //hit the askdc for the machine if using a raw passport
                    if (authType==WindowsPacAuthData.CT_RawPassport)
                    {
                        kdc.CreateAskdcMachineRequest();
                        kdc.ExecuteAskdc(true);
                    }

                    //verify result
                    ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
                }
            }

            [TestCase, Description("User's last signout date is null.  Use an encrypted RPS ticket for auth.")]
            [CompoundCase("UnknownTrust", UMTrust.UnknownUnknown)]
            [CompoundCase("NotTrusted", UMTrust.UntrustedUnknown)]
            public void LastSignoutNull(TestNode self)
            {
                UMTrust trustForMachine=(UMTrust)self.MyValues[0];
                int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                //prepare the users and machine
                KdcUser user=GetCachedUser(true);

                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.ExecuteXmacs(true);

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, trustForMachine);

                //hit the askdc for the machine
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                //hit askdc for the users
                AuthUserWithAskdc(kdc, user, WindowsPacAuthData.CT_EncryptedPassport);

                //verify result
                ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
            }

            [TestCase, Description("Two users in the same request authenticated different ways.")]
            public class TwoUsersOneMachine: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    foreach (UMTrust trust0 in new UMTrust[]{UMTrust.TrustedExpired, UMTrust.UntrustedExpired, UMTrust.UnknownExpired})
                    {
                        foreach (uint authType0 in new uint[]{WindowsPacAuthData.CT_RandomKey, WindowsPacAuthData.CT_EncryptedPassport})
                        {
                            foreach (UMTrust trust1 in new UMTrust[]{UMTrust.NonexistentTrust, UMTrust.TrustedValid, UMTrust.UntrustedValid, UMTrust.UnknownValid})
                            {
                                foreach (uint authType1 in new uint[]{WindowsPacAuthData.CT_RandomKey, WindowsPacAuthData.CT_EncryptedPassport})
                                {
                                    if (trust0==trust1 || authType0==authType1)
                                    {
                                        continue;
                                    }

                                    string name=trust0.ToString()+" "+GetShortNameForAuthType(authType0)+" + "+trust1.ToString()+" "+GetShortNameForAuthType(authType1);
                                    CompoundCaseAttribute cca=new CompoundCaseAttribute(name, trust0, authType0, trust1, authType1);
                                    instances.Add(cca);
                                }
                            }
                        }
                    }
                }

                public override void Run()
                {
                    UMTrust trustForMachine0=(UMTrust)MyValues[0];
                    uint authType0=(uint)MyValues[1];
                    UMTrust trustForMachine1=(UMTrust)MyValues[2];
                    uint authType1=(uint)MyValues[3];
                    int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                    int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                    //prepare the users and machine
                    KdcUser user0=GetCachedUser(authType0!=WindowsPacAuthData.CT_RandomKey);

                    KdcUser user1=GetCachedUser(authType1!=WindowsPacAuthData.CT_RandomKey);

                    KdcClientXbox360 kdc=new KdcClientXbox360();
                    kdc.ExecuteXmacs(true);

                    SetTrustForMachine(user0.UserID, kdc.XmacsOutput.MachineId, trustForMachine0);
                    SetTrustForMachine(user1.UserID, kdc.XmacsOutput.MachineId, trustForMachine1);

                    //hit the askdc for the machine
                    kdc.CreateAskdcMachineRequest();
                    kdc.ExecuteAskdc(true);

                    //hit askdc for the users
                    AuthUserWithAskdc(kdc, user0, authType0);
                    AuthUserWithAskdc(kdc, user1, authType1);

                    //verify result
                    ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
                }
            }

            [TestCase]
            public class FourUsersOneMachine: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    foreach (UMTrust trust in new UMTrust[]{UMTrust.NonexistentTrust, UMTrust.TrustedValid, UMTrust.UntrustedValid, UMTrust.UnknownValid})
                    {
                        foreach (uint authType in new uint[]{WindowsPacAuthData.CT_RandomKey, WindowsPacAuthData.CT_EncryptedPassport})
                        {
                            string name=trust.ToString()+" "+GetShortNameForAuthType(authType);
                            CompoundCaseAttribute cca=new CompoundCaseAttribute(name, trust, authType);
                            instances.Add(cca);
                        }
                    }
                }

                public override void Run()
                {
                    UMTrust trustForMachine=(UMTrust)MyValues[0];
                    uint authType=(uint)MyValues[1];
                    int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                    int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                    //prepare the users and machine
                    KdcUser []users=new KdcUser[4];
                    for (int u=0; u<4; ++u)
                    {
                        users[u]=GetCachedUser(authType!=WindowsPacAuthData.CT_RandomKey);
                    }

                    KdcClientXbox360 kdc=new KdcClientXbox360();
                    kdc.ExecuteXmacs(true);

                    for (int u=0; u<4; ++u)
                    {
                        SetTrustForMachine(users[u].UserID, kdc.XmacsOutput.MachineId, trustForMachine);
                    }

                    //hit the askdc for the machine
                    kdc.CreateAskdcMachineRequest();
                    kdc.ExecuteAskdc(true);

                    //hit askdc for the users
                    for (int u=0; u<4; ++u)
                    {
                        AuthUserWithAskdc(kdc, users[u], authType);
                    }

                    //verify result
                    ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
                }
            }

            [TestCase, Description("One users has different trust for different machines.")]
            public class OneUserTwoMachines: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    foreach (UMTrust trust0 in new UMTrust[]{UMTrust.TrustedValid, UMTrust.TrustedExpired, UMTrust.UntrustedExpired, UMTrust.UnknownExpired})
                    {
                        foreach (UMTrust trust1 in new UMTrust[]{UMTrust.NonexistentTrust, UMTrust.TrustedValid, UMTrust.UntrustedValid, UMTrust.UnknownValid})
                        {
                            foreach (uint authType in new uint[]{WindowsPacAuthData.CT_RandomKey, WindowsPacAuthData.CT_EncryptedPassport})
                            {

                                string name=trust0.ToString()+" "+trust1.ToString()+" "+GetShortNameForAuthType(authType);
                                CompoundCaseAttribute cca=new CompoundCaseAttribute(name, trust0, trust1, authType);
                                instances.Add(cca);
                            }
                        }
                    }
                }

                public override void Run()
                {
                    UMTrust trustForMachine0=(UMTrust)MyValues[0];
                    UMTrust trustForMachine1=(UMTrust)MyValues[1];
                    uint authType=(uint)MyValues[2];
                    int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                    int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                    //prepare the users and machine
                    KdcUser user=GetCachedUser(authType!=WindowsPacAuthData.CT_RandomKey);

                    KdcClientXbox360 kdc0=new KdcClientXbox360();
                    kdc0.ExecuteXmacs(true);

                    KdcClientXbox360 kdc1=new KdcClientXbox360();
                    kdc1.ExecuteXmacs(true);

                    SetTrustForMachine(user.UserID, kdc0.XmacsOutput.MachineId, trustForMachine0);
                    SetTrustForMachine(user.UserID, kdc1.XmacsOutput.MachineId, trustForMachine1);

                    //hit the askdc for the machine
                    kdc0.CreateAskdcMachineRequest();
                    kdc0.ExecuteAskdc(true);

                    kdc1.CreateAskdcMachineRequest();
                    kdc1.ExecuteAskdc(true);

                    //hit askdc for the users
                    AuthUserWithAskdc(kdc0, user, authType);
                    AuthUserWithAskdc(kdc1, user, authType);

                    //verify result
                    Global.RO.Debug("First machine...");
                    ExecuteXkdcAndVerifyEverything(kdc0, trustSettingLevel, preauthServiceRequestVersion);
                    Global.RO.Debug("Second machine...");
                    ExecuteXkdcAndVerifyEverything(kdc1, trustSettingLevel, preauthServiceRequestVersion);
                }
            }

            [TestCase, Description("One users has different trust for different machines.")]
            [CompoundCase("TrustedExpired Key",           UMTrust.TrustedExpired,   WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("UntrustedValid Key",           UMTrust.UntrustedValid,   WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("UnknownValid Key",             UMTrust.UnknownValid,     WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("TrustedValid EncPassport",     UMTrust.TrustedValid,     WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("UntrustedValid EncPassport",   UMTrust.UntrustedValid,   WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("UntrustedExpired EncPassport", UMTrust.UntrustedExpired, WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("UnknownExpired EncPassport",   UMTrust.UnknownExpired,   WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("UnknownValid EncPassport",     UMTrust.UnknownValid,     WindowsPacAuthData.CT_EncryptedPassport)]
            public class OneUserHundredMachines: TestNode
            {
                public override void Run()
                {
                    UMTrust trustForMachines=(UMTrust)MyValues[0];
                    uint authType=(uint)MyValues[1];
                    int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                    int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                    //prepare the users and machine
                    KdcUser user=GetCachedUser(authType!=WindowsPacAuthData.CT_RandomKey);

                    KdcClientXbox360 []clients=new KdcClientXbox360[100];
                    for (int i=0; i<100; ++i)
                    {
                        clients[i]=new KdcClientXbox360();
                        clients[i].ExecuteXmacs(true);

                        SetTrustForMachine(user.UserID, clients[i].XmacsOutput.MachineId, trustForMachines);
                    }

                    //hit the askdc for the three of the machines along with that user then hit xkdc and verify
                    for (int i=0; i<100; i+=49)
                    {
                        clients[i].CreateAskdcMachineRequest();
                        clients[i].ExecuteAskdc(true);

                        AuthUserWithAskdc(clients[i], user, authType);

                        ExecuteXkdcAndVerifyEverything(clients[i], trustSettingLevel, preauthServiceRequestVersion);

                        if (i<97)
                        {
                            System.Threading.Thread.Sleep(1100); //avoid anti-dos for the user
                        }
                    }
                }
            }

            [TestCase, Description("Verify xkdc cache results are correct in trust-related scenarios")]
            [CompoundCase("{0} Key",         UMTrust.NonexistentTrust, WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("{0} Key",         UMTrust.TrustedValid,     WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("{0} Key",         UMTrust.UntrustedValid,   WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("{0} Key",         UMTrust.UntrustedExpired, WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("{0} Key",         UMTrust.UnknownValid,     WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("{0} Key",         UMTrust.UnknownExpired,   WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("{0} EncPassport", UMTrust.NonexistentTrust, WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("{0} EncPassport", UMTrust.TrustedValid,     WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("{0} EncPassport", UMTrust.UntrustedValid,   WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("{0} EncPassport", UMTrust.UntrustedExpired, WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("{0} EncPassport", UMTrust.UnknownValid,     WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("{0} EncPassport", UMTrust.UnknownExpired,   WindowsPacAuthData.CT_EncryptedPassport)]
            public void CacheTest(TestNode self)
            {
                UMTrust trustForMachine=(UMTrust)self.MyValues[0];
                uint authType=(uint)self.MyValues[1];
                int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                //prepare the user and machine
                KdcUser user=GetCachedUser(true);
                KdcClientXbox360 kdc=new KdcClientXbox360();

                kdc.CreateXmacsRequest();
                kdc.ExecuteXmacs(true);

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, trustForMachine);

                //hit the askdc for the machine
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                //hit askdc for the user
                AuthUserWithAskdc(kdc, user, authType);

                //hit xkdc - first two are autodiscover, last one is not
                for (int i=0; i<3; ++i)
                {
                    kdc.CreateXkdcRequest();

                    if (i>=2) //don't autodiscover the final time
                    {
                        kdc.XkdcRequest.Input.AutoDiscoverServices=0;
                        kdc.XkdcRequest.Input.Services=new uint[]{25}; //livehive
                    }

                    ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
                }
            }

            [TestCase, Description("Bans should take priority over trust checks.")]
            [CompoundCase("Key",         WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("EncPassport", WindowsPacAuthData.CT_EncryptedPassport)]
            public void UserBannedAndNotTrusted(TestNode self)
            {
                uint authType=(uint)self.MyValues[0];
                int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                KdcUser user=new KdcUser();
                user.CreateUser(authType!=WindowsPacAuthData.CT_RandomKey);

                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                UserEditor userEdit=UserEditor.FromPuid(user.UserID);
                userEdit.BannedUntilDate=System.DateTime.MaxValue;

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, UMTrust.UntrustedValid);
                AuthUserWithAskdc(kdc, user, authType);

                ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
            }

            [TestCase, Description("Bans should take priority over trust checks.")]
            [CompoundCase("UntrustedValid Key",           UMTrust.UntrustedValid,   WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("UntrustedValid EncPassport",   UMTrust.UntrustedValid,   WindowsPacAuthData.CT_EncryptedPassport)]
            [CompoundCase("UntrustedExpired EncPassport", UMTrust.UntrustedExpired, WindowsPacAuthData.CT_EncryptedPassport)]
            public void MachineBannedUserNotTrusted(TestNode self)
            {
                UMTrust trustForMachine=(UMTrust)self.MyValues[0];
                uint authType=(uint)self.MyValues[1];
                int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                KdcUser user=GetCachedUser(true);

                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                MachineEditor machineEdit=MachineEditor.FromId(kdc.XmacsOutput.MachineId);
                machineEdit.BanMachine();

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, trustForMachine);
                AuthUserWithAskdc(kdc, user, authType);

                ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
            }

            [TestCase, Description("User not trusted takes priority over user requiring managament.")]
            [CompoundCase("Key",         WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("EncPassport", WindowsPacAuthData.CT_EncryptedPassport)]
            public void UserNameChangeRequiredAndNotTrusted(TestNode self)
            {
                uint authType=(uint)self.MyValues[0];
                int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                KdcUser user=new KdcUser();
                user.CreateUser(authType!=WindowsPacAuthData.CT_RandomKey);

                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                UserEditor userEdit=UserEditor.FromPuid(user.UserID);
                userEdit.NameChangeRequired=1;

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, UMTrust.UntrustedValid);
                AuthUserWithAskdc(kdc, user, authType);

                ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
            }

            [TestCase, Description("Title update should take priority over trust checks.")]
            [CompoundCase("Key AutoDiscover",         WindowsPacAuthData.CT_RandomKey,         true)]
            [CompoundCase("Key AutoUpdate",           WindowsPacAuthData.CT_RandomKey,         false)]
            [CompoundCase("EncPassport AutoDiscover", WindowsPacAuthData.CT_EncryptedPassport, true)]
            [CompoundCase("EncPassport AutoUpdate",   WindowsPacAuthData.CT_EncryptedPassport, false)]
            public void TitleUpdateUserNotTrusted(TestNode self)
            {
                uint authType=(uint)self.MyValues[0];
                bool autodiscover=(bool)self.MyValues[1];
                int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                KdcUser user=GetCachedUser(true);

                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, UMTrust.UntrustedValid);
                AuthUserWithAskdc(kdc, user, authType);

                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.TitleID=0x3EEF0801;
                kdc.XkdcRequest.Input.TitleVersion=1; //has an update to version 3

                if (autodiscover)
                {
                    kdc.XkdcRequest.Input.AutoDiscoverServices=1;
                }
                else
                {
                    kdc.XkdcRequest.Input.AutoDiscoverServices=0;
                    kdc.XkdcRequest.Input.Services=new uint[]{3}; //AutoUpdate
                }

                ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
            }

            [TestCase, Description("System update should take priority over trust checks.")]
            [CompoundCase("Key",         WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("EncPassport", WindowsPacAuthData.CT_EncryptedPassport)]
            public void SystemUpdateUserNotTrusted(TestNode self)
            {
                uint authType=(uint)self.MyValues[0];
                int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                KdcUser user=GetCachedUser(true);

                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, UMTrust.UntrustedValid);
                AuthUserWithAskdc(kdc, user, authType);

                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.FlashVersion=27; //has an update to version 28

                ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
            }

            [TestCase, Description("Title update should take priority over trust checks.")]
            [CompoundCase("Key",         WindowsPacAuthData.CT_RandomKey)]
            [CompoundCase("EncPassport", WindowsPacAuthData.CT_EncryptedPassport)]
            public void InvalidTitleUserNotTrusted(TestNode self)
            {
                uint authType=(uint)self.MyValues[0];
                int preauthServiceRequestVersion=(int)GetContextData("SRVersion");
                int trustSettingLevel=(int)GetContextData("UMTrustLevel");

                KdcUser user=GetCachedUser(true);

                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, UMTrust.UntrustedValid);
                AuthUserWithAskdc(kdc, user, authType);

                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.TitleID=0x3E761248;

                ExecuteXkdcAndVerifyEverything(kdc, trustSettingLevel, preauthServiceRequestVersion);
            }

            [TestCase, Description("User is not trusted and has an invalid WLID.  In this case the KDC has to grant a machine-only ticket and returned 'requires managament' so that the user can be fixed.")]
            [CompoundCase("Untrusted", UMTrust.UntrustedValid)]
            [CompoundCase("UnknownTrust", UMTrust.UnknownValid)]
            [CompoundCase("NonexistentTrust", UMTrust.NonexistentTrust)]
            public void InvalidWLID(TestNode self)
            {
                UMTrust trustForMachine=(UMTrust)self.MyValues[0];

                KdcUser user=new KdcUser();
                user.CreateUser(false);

                UserEditor userEdit=UserEditor.FromGamerTag(user.Gamertag);
                userEdit.UserWLIDInvalid=1;

                KdcClientXbox360 kdc=new KdcClientXbox360();
                kdc.CreateAskdcMachineRequest();
                kdc.ExecuteAskdc(true);

                SetTrustForMachine(user.UserID, kdc.XmacsOutput.MachineId, trustForMachine);
                AuthUserWithAskdc(kdc, user, WindowsPacAuthData.CT_RandomKey);

                kdc.XkdcThrowOnOverallHRFailure=false;
                kdc.ExecuteXkdc(true);

                bool gotValidTicket=(kdc.XkdcOutput.ServiceName[1].ToLower()!="site0");

                ValueCheck.Test("Xkdc OverallHR", 0, kdc.XkdcOutput.Hr);
                ValueCheck.Test("Xkdc User0HR", 0x8015100F, kdc.XkdcOutput.HrUser[0]); //XONLINE_E_LOGON_USER_NOT_TRUSTED
                ValueCheck.Test("Got a valid ticket from xkdc", false, gotValidTicket);
            }
        }
    }; //class XkdcUserMachineTrust
} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XkdcBetaGroups.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;

namespace XkdcTest
{
    [TestGroup, Description("Tests for beta group flash and title updates.  This also has a lot of \"General\" title version tests.")]
    public class XkdcBetaGroups: TestNode
    {
        private static void MakeRequestAndVerify(KdcClient client, uint flashVersion, uint titleId, uint titleVersion, uint expectedHr, uint expectedKerbErr, bool expectedBetaBit)
        {
            if (client.XkdcRequest==null)
            {
                client.CreateXkdcRequest();
            }

            client.XkdcRequest.Input.FlashVersion=flashVersion;
            client.XkdcRequest.Input.ClientMajorVersion=(ushort)((flashVersion&0xf0000000)>>28);
            client.XkdcRequest.Input.ClientMinorVersion=(ushort)((flashVersion&0x0f000000)>>24);
            client.XkdcRequest.Input.ClientBuildVersion=(ushort)((flashVersion&0x00ffff00)>>8);
            client.XkdcRequest.Input.ClientQFEVersion=(ushort)(flashVersion&0x000000ff);

            client.XkdcRequest.Input.TitleID=titleId;
            client.XkdcRequest.Input.TitleVersion=titleVersion;
            Global.RO.Debug("Doing request on machine "+client.AskdcOutput.ConsoleOrUserName+", flash version "+flashVersion+", title "+string.Format("0x{0:X}", titleId)+", title version "+titleVersion);

            uint gottenKerbErr=0;
            try
            {
                client.XkdcThrowOnOverallHRFailure=false;
                client.ExecuteXkdc(true);
            }
            catch (KerberosErrorException kee)
            {
                if (expectedKerbErr==0)
                {
                    throw;
                }

                gottenKerbErr=(uint)kee.Error.ErrorCode.Int64;
                Global.RO.Debug("Got Kerberos Error 0x"+string.Format("{0:X}", gottenKerbErr));
            }

            ValueCheck.Test("Kerberos Error Response", (uint)expectedKerbErr, gottenKerbErr);

            if (gottenKerbErr==0)
            {
                Global.RO.Debug("Xkdc Response HR: "+string.Format("0x{0:X}", client.XkdcOutput.Hr));
                ValueCheck.Test("Xkdc Response HR", expectedHr, client.XkdcOutput.Hr);

                if (client.XkdcOutput.Hr==0)
                {
                    XenonAuthDataBase ad=(XenonAuthDataBase)client.XkdcOutput.XboxAuthData;
                    bool betaBit=0!=(ad.AuthDataFlags&Authdata_Xenon.FLAGS_ISBETAMACHINE);
                    Global.RO.Debug("Xkdc Authdata beta bit: "+betaBit);
                    ValueCheck.Test("Xkdc Authdata beta bit", expectedBetaBit, betaBit);
                }
            }
        }

        private static void MakeRequestAndVerify(MachineEditor machine, AuthContext.ClientTypes clientType, uint flashVersion, uint titleId, uint titleVersion, uint expectedHr, uint expectedKerbErr, bool expectedBetaBit)
        {
            KdcClient client=PrepareKdcClient(machine, clientType);
            MakeRequestAndVerify(client, flashVersion, titleId, titleVersion, expectedHr, expectedKerbErr, expectedBetaBit);
        }

        private static void MakeRequestAndVerify(MachineEditor machine, uint flashVersion, uint titleId, uint titleVersion, uint expectedHr, uint expectedKerbErr, bool expectedBetaBit)
        {
            KdcClient client=PrepareKdcClient(machine);
            MakeRequestAndVerify(client, flashVersion, titleId, titleVersion, expectedHr, expectedKerbErr, expectedBetaBit);
        }

        private static KdcClient PrepareKdcClient(MachineEditor machine, AuthContext.ClientTypes clientType)
        {
            //pretend we've already done the xmacs request for our machine and do the askdc request
            KdcClient client=new KdcClient(clientType);
            client.XmacsOutput=new XmacsGenericReplyOutput();
            client.XmacsOutput.PopulateFromDatabase(machine);
            client.ExecuteAskdc(true);
            client.CreateXkdcRequest();
            return client;
        }

        private static KdcClient PrepareKdcClient(MachineEditor machine)
        {
            AuthContext.ClientTypes clientType=AuthContext.ClientTypes.Xenon;
            if ((machine.Id&0xffff000000000000)==0x0009000000000000) clientType=AuthContext.ClientTypes.Xbox;
            else if ((machine.Id&0xffff000000000000)==0xfb00000000000000) clientType=AuthContext.ClientTypes.Panorama;

            return PrepareKdcClient(machine, clientType);
        }

        // -- flash only tests

        [TestGroup, Description("Our test environments allow requests for non-configured versions.")]
        public class AllowUnknownVersions: TestNode
        {
            //update settings to match our assumptions

            SettingState orig_kdcsvc_xkdc_allowUnknownVersion=null;
            SettingState orig_kdcsvc_xkdc_enforceClientVersion=null;

            public override void PreRun()
            {
                Global.RO.Debug("Updating settings...");
                orig_kdcsvc_xkdc_allowUnknownVersion=Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_xkdc_allowUnknownVersion, "1");
                orig_kdcsvc_xkdc_enforceClientVersion=Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_xkdc_enforceClientVersion, "0");

                Suite.ReloadKDCs();
            }

            public override void PostRun()
            {
                Global.RO.Debug("Reverting settings...");
                if (orig_kdcsvc_xkdc_allowUnknownVersion!=null)
                {
                    Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_xkdc_allowUnknownVersion);
                }

                if (orig_kdcsvc_xkdc_enforceClientVersion!=null)
                {
                    Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_xkdc_enforceClientVersion);
                }

                Suite.ReloadKDCs();
            }

            //tests

            [TestGroup, Description("Tests around situations where clients are give the flash update required message.")]
            public class Flash: TestNode
            {
                [CompoundCase("Version 30", 30)]
                [CompoundCase("Version 31", 31)]
                [CompoundCase("Version 32", 32)]
                [CompoundCase("Version 33", 33)]
                [CompoundCase("Version 34", 34)]
                [CompoundCase("Version 35", 35)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("A machine not in any beta groups.")]
                public class MachineNothing: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700000004"), flashVersion, 0xfffe07ff, 1, 0, 0, false);
                    }
                }

                //                                                  ver autodisc autoupd result
                [CompoundCase("Version 30 AutoDisc",                30, true,    false, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Version 30 NoAutoDisc NoAutoUpdate", 30, false,   false, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Version 30 NoAutoDisc AutoUpdate",   30, false,   true,  (uint)0)]
                [CompoundCase("Version 31 AutoDisc",                31, true,    false, (uint)0)]
                [CompoundCase("Version 31 NoAutoDisc NoAutoUpdate", 31, false,   false, (uint)0)]
                [CompoundCase("Version 31 NoAutoDisc AutoUpdate",   31, false,   true,  (uint)0)]
                [CompoundCase("Version 32 AutoDisc",                32, true,    false, (uint)0)]
                [CompoundCase("Version 35 AutoDisc",                35, true,    false, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("A machine in flash beta group 0.")]
                public class MachineF0: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        bool doAutoDiscover=(bool)MyValues[1];
                        bool reqAutoUpdate=(bool)MyValues[2]; //only used if doAutoDiscover=false
                        uint expectedHr=(uint)MyValues[3];
                        bool expectedBetaBit=(expectedHr==0);
                        KdcClient client=PrepareKdcClient(MachineEditor.FromName("XE.133700000105"));
                        if (!doAutoDiscover)
                        {
                            if (reqAutoUpdate)
                            {
                                client.XkdcRequest.Input.SetServices(new uint[]{3}); //autoupdate
                            }
                            else
                            {
                                client.XkdcRequest.Input.SetServices(new uint[]{11}); //tou
                            }
                        }
                        MakeRequestAndVerify(client, flashVersion, 0xfffe07ff, 1, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 30", 30, (uint)0)]
                [CompoundCase("Version 31", 31, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Version 32", 32, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("A machine in flash beta group 1.")]
                public class MachineF1: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700000206"), flashVersion, 0xfffe07ff, 1, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 30", 30, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Version 31", 31, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Version 32", 32, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Version 33", 33, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("A machine in flash beta groups 0 and 1."), Ignore("For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.")]
                public class MachineF0F1: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700000307"), flashVersion, 0xfffe07ff, 1, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 30", 30, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED, false)]
                [CompoundCase("Version 31", 31, (uint)0,                                       true)] //version conflict, we treat them like they're in no group (but still set their betabit)
                [CompoundCase("Version 32", 32, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED, false)]
                [CompoundCase("Version 33", 33, (uint)0,                                       true)]
                [CompoundCase("Version 34", 34, (uint)0,                                       true)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("A machine in flash beta groups 0, 1, and 2."), Ignore("For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.")]
                public class MachineF0F1F2: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(bool)MyValues[2];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700000701"), flashVersion, 0xfffe07ff, 1, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 30", 30, (uint)0)]
                [CompoundCase("Version 40", 40, (uint)0)]
                [CompoundCase("Version 41", 41, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Flash update that ends in the past.")]
                public class MachineF6: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700006404"), flashVersion, 0xfffe07ff, 1, expectedHr, 0, true);
                    }
                }

                [CompoundCase("Version 30", 30, (uint)0)]
                [CompoundCase("Version 40", 40, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Flash update that starts in the future.")]
                public class MachineF7: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133800000184"), flashVersion, 0xfffe07ff, 1, expectedHr, 0, true);
                    }
                }

                [CompoundCase("Machine None", "XE.133700000004", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 0",    "XE.133700000105", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 4",    "XE.133700001601", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 5",    "XE.133700003205", (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Version 37 updates everyone to 38, group 4 to 39, and group 5 is not updated.")]
                public class BaseVersion37: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), 37, 0x1337FF00, 1, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Machine 4", "XE.133700001601", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 5", "XE.133700003205", (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Version 38 has no update for everyone, and updates group 4 to 37.")]
                public class BaseVersion38: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), 38, 0x1337FF00, 1, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Machine 0",   "XE.133700000105", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 1",   "XE.133700000206", HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                //[CompoundCase("Machine 0+1", "XE.133700000307", (uint)0)] //multiple rows for same base version, but no conflict since they're both to the same new version.  however we will treat it as a conflict to simplify the implementation. //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Version 43 has no update for everyone, and updates to the same version for groups 1, 2, and 3 to 44.")]
                public class BaseVersion43: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), 43, 0x1337FF00, 1, expectedHr, 0, true);
                    }
                }

                [CompoundCase("Version 30", 30, (uint)0)]
                [CompoundCase("Version 32", 32, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [TestTag("Platform=PC")]
                [TestCase, Description("Basic test for PCs in a beta group.")]
                public class PCF3: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName("PC.133700000813"), flashVersion, 0x585207d1, 1, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 30", 30, (uint)0)]
                [CompoundCase("Version 32", 32, (uint)0)] //xenon flash update that we should not get
                [TestTag("Platform=PC")]
                [TestCase, Description("Verify that PCs don't get xenon updates for beta groups.")]
                public class PCF1: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("PC.133700000217"), flashVersion, 0x585207d1, 1, expectedHr, 0, true);
                    }
                }

                [TestCase, Description("Verify the old beta mask columns have no effect.")]
                public void VerifyOldMaskDoesNothing()
                {
                    MakeRequestAndVerify(MachineEditor.FromName("XE.133900000028"), AuthContext.ClientTypes.Xenon, 34, 0xfffe07d1, 34, 0, 0, false);
                }
            }

                [CompoundCase("Version 30", 30, (uint)0)]
                [CompoundCase("Version 50", 50, HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Single machine is in lots of beta groups."), Ignore("For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.")]
                public class MachineLots: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133900000017"), flashVersion, 0xfffe07ff, 1, expectedHr, 0, expectedBetaBit);
                    }
                }

            // -- title only tests

            [TestGroup, Description("Tests around situations where clients are given the title update required message.")]
            public class Title: TestNode
            {
                [CompoundCase("Version 130", 130)]
                [CompoundCase("Version 131", 131)]
                [CompoundCase("Version 132", 132)]
                [CompoundCase("Version 133", 133)]
                [CompoundCase("Version 134", 134)]
                [CompoundCase("Version 135", 135)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("A machine not in any beta groups.")]
                public class MachineNothing: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700000004"), 1, 0x1337FF00, titleVersion, 0, 0, false);
                    }
                }

                //                                                   ver  autodisc autoupd result
                [CompoundCase("Version 130 AutoDisc",                130, true,    false,  HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Version 130 NoAutoDisc NoAutoUpdate", 130, false,   false,  HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Version 130 NoAutoDisc AutoUpdate",   130, false,   true,   (uint)0)]
                [CompoundCase("Version 131 AutoDisc",                131, true,    false,  (uint)0)]
                [CompoundCase("Version 131 NoAutoDisc NoAutoUpdate", 131, false,   false,  (uint)0)]
                [CompoundCase("Version 131 NoAutoDisc AutoUpdate",   131, false,   true,   (uint)0)]
                [CompoundCase("Version 132 AutoDisc",                132, true,    false,  (uint)0)]
                [CompoundCase("Version 135 AutoDisc",                135, true,    false,  (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Tests for a machine on title 1337FF00 in title beta group 0")]
                public class Machine_0T0: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        bool doAutoDiscover=(bool)MyValues[1];
                        bool reqAutoUpdate=(bool)MyValues[2]; //only used if doAutoDiscover=false
                        uint expectedHr=(uint)MyValues[3];
                        bool expectedBetaBit=(expectedHr==0);
                        KdcClient client=PrepareKdcClient(MachineEditor.FromName("XE.133700010005"));
                        if (!doAutoDiscover)
                        {
                            if (reqAutoUpdate)
                            {
                                client.XkdcRequest.Input.SetServices(new uint[]{3}); //autoupdate
                            }
                            else
                            {
                                client.XkdcRequest.Input.SetServices(new uint[]{11}); //tou
                            }
                        }
                        MakeRequestAndVerify(client, 1, 0x1337FF00, titleVersion, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 130", 130, (uint)0)]
                [CompoundCase("Version 131", 131, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Version 132", 132, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Tests for a machine on title 1337FF00 in title beta group 1")]
                public class Machine_0T1: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700020006"), 1, 0x1337FF00, titleVersion, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 130", 130, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Version 131", 131, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Version 132", 132, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Version 133", 133, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Tests for a machine on title 1337FF00 in title beta groups 0 and 1"), Ignore("For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.")]
                public class Machine_0T0T1: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700030007"), 1, 0x1337FF00, titleVersion, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 130", 130, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED, false)]
                [CompoundCase("Version 131", 131, (uint)0,                                 true)] //version conflict, we treat them like they're in no beta (but still set their betabit)
                [CompoundCase("Version 132", 132, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED, false)]
                [CompoundCase("Version 133", 133, (uint)0,                                 true)]
                [CompoundCase("Version 134", 134, (uint)0,                                 true)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Tests for a machine on title 1337FF00 in title beta groups 0, 1, and 2"), Ignore("For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.")]
                public class Machine_0T0T1T2: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(bool)MyValues[2];

                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700070001"), 1, 0x1337FF00, titleVersion, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 130", 130, (uint)0)]
                [CompoundCase("Version 140", 140, (uint)0)]
                [CompoundCase("Version 141", 141, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Title beta group that ends in the past.")]
                public class Machine_0T6: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700640004"), 1, 0x1337FF00, titleVersion, expectedHr, 0, true);
                    }
                }

                [CompoundCase("Version 130", 130, (uint)0)]
                [CompoundCase("Version 140", 140, (uint)0)]
                [CompoundCase("Version 141", 141, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Title beta group that starts in the future.")]
                public class Machine_0T7: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700960009"), 1, 0x1337FF00, titleVersion, expectedHr, 0, true);
                    }
                }

                [CompoundCase("Machine None", "XE.133700000004", HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine 0",    "XE.133700010005", HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine 4",    "XE.133700160001", HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine 5",    "XE.133700320005", (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Version 137 updates everyone to 138, group 4 to 139, and group 5 is not updated")]
                public class BaseVersion137: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), 1, 0x1337FF00, 137, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Machine 4", "XE.133700160001", HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine 5", "XE.133700320005", (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Version 138 doesn't update everyone, and updates group 4 to 137.")]
                public class BaseVersion138: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), 1, 0x1337FF00, 138, expectedHr, 0, expectedBetaBit);
                    }
                }

                [CompoundCase("Machine 0",   "XE.133700010005", HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine 1",   "XE.133700020006", HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                //[CompoundCase("Machine 0+1", "XE.133700030007", (uint)0)] //multiple rows for same base version, but no conflict since they're both to the same new version.  however we will treat it as a conflict to simplify the implementation.  //For the 2010 March XSR we have a unique key constraint to handle these cases, so this is temporarily disabled.
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Version 143 doesn't update everyone, and updates groups 1, 2, 3 to version 144.")]
                public class BaseVersion143: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), 1, 0x1337FF00, 143, expectedHr, 0, true);
                    }
                }

                [CompoundCase("Version 130", 130, (uint)0)]
                [CompoundCase("Version 132", 132, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [TestTag("Platform=PC")]
                [TestCase, Description("Basic test that title update beta groups work for PC.")]
                public class PC_2T3: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName("PC.133700080013"), 1, 0x1337FF02, titleVersion, expectedHr, 0, expectedBetaBit);
                    }
                }
            }

            // -- mixed flash and title tests

            [TestGroup, Description("Tests around mixed title update and flash update situations.  Flash updates take priority.")]
            public class Mixed: TestNode
            {
                //                                              mach               flash title result                                         betabit
                [CompoundCase("Machine None Flash99 Title100",  "XE.133700000004", 99,   100,  (uint)0,                                       false)]
                [CompoundCase("Machine None Flash100 Title99",  "XE.133700000004", 100,  99,   (uint)0,                                       false)]
                [CompoundCase("Machine None Flash100 Title100", "XE.133700000004", 100,  100,  (uint)0,                                       false)]
                [CompoundCase("Machine 0 Flash99 Title100",     "XE.133701000005", 99,   100,  HResult.XONLINE_E_LOGON_UPDATE_REQUIRED,       false)]
                [CompoundCase("Machine 0 Flash100 Title99",     "XE.133701000005", 100,  99,   HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED, false)]
                [CompoundCase("Machine 0 Flash100 Title100",    "XE.133701000005", 100,  100,  HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED, false)]
                [CompoundCase("Machine 1 Flash99 Title100",     "XE.133702000006", 99,   100,  (uint)0,                                       true)]
                [CompoundCase("Machine 1 Flash100 Title99",     "XE.133702000006", 100,  99,   (uint)0,                                       true)]
                [CompoundCase("Machine 1 Flash100 Title100",    "XE.133702000006", 100,  100,  (uint)0,                                       true)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Flash version 100 does not update everyone and updates group 0 to 120.\nTitle version 100 does not update everyone and updtes group 0 to 120.")]
                public class Version100: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint flashVersion=(uint)(int)MyValues[1];
                        uint titleVersion=(uint)(int)MyValues[2];
                        uint expectedHr=(uint)MyValues[3];
                        bool expectedBetaBit=(bool)MyValues[4];
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), flashVersion, 0x1337FF10, titleVersion, expectedHr, 0, expectedBetaBit);
                    }
                }

                //                                              mach               flash title result
                [CompoundCase("Machine None Flash99 Title101",  "XE.133700000004", 99,   101,  HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine None Flash101 Title99",  "XE.133700000004", 101,  99,   HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine None Flash101 Title101", "XE.133700000004", 101,  101,  HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 0 Flash99 Title101",     "XE.133701000005", 99,   101,  (uint)0)]
                [CompoundCase("Machine 0 Flash101 Title99",     "XE.133701000005", 101,  99,   (uint)0)]
                [CompoundCase("Machine 0 Flash101 Title101",    "XE.133701000005", 101,  101,  (uint)0)]
                [CompoundCase("Machine 1 Flash99 Title101",     "XE.133702000006", 99,   101,  HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine 1 Flash101 Title99",     "XE.133702000006", 101,  99,   HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 1 Flash101 Title101",    "XE.133702000006", 101,  101,  HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Flash version 101 updates everyone to 120, but does not update group 0.\nTitle version 101 updates everyone to 120, but does not update group 0.")]
                public class Version101: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint flashVersion=(uint)(int)MyValues[1];
                        uint titleVersion=(uint)(int)MyValues[2];
                        uint expectedHr=(uint)MyValues[3];
                        bool expectedBetaBit=(expectedHr==0);
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), flashVersion, 0x1337FF10, titleVersion, expectedHr, 0, expectedBetaBit);
                    }
                }

                //                                              mach               flash title result
                [CompoundCase("Machine None Flash99 Title102",  "XE.133700000004", 99,   102,  (uint)0)]
                [CompoundCase("Machine None Flash102 Title99",  "XE.133700000004", 102,  99,   (uint)0)]
                [CompoundCase("Machine None Flash102 Title102", "XE.133700000004", 102,  102,  (uint)0)]
                [CompoundCase("Machine 0 Flash99 Title102",     "XE.133701000005", 99,   102,  HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine 0 Flash102 Title99",     "XE.133701000005", 102,  99,   HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 0 Flash102 Title102",    "XE.133701000005", 102,  102,  HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 1 Flash99 Title102",     "XE.133702000006", 99,   102,  HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Machine 1 Flash102 Title99",     "XE.133702000006", 102,  99,   HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Machine 1 Flash102 Title102",    "XE.133702000006", 102,  102,  HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Title and flash version 102 does not exist for everyone.  Group 0 updates both to 101.  Group 1 updates both to 120.")]
                public class Version102: TestNode
                {
                    public override void Run()
                    {
                        string machineName=(string)MyValues[0];
                        uint flashVersion=(uint)(int)MyValues[1];
                        uint titleVersion=(uint)(int)MyValues[2];
                        uint expectedHr=(uint)MyValues[3];
                        MakeRequestAndVerify(MachineEditor.FromName(machineName), flashVersion, 0x1337FF10, titleVersion, expectedHr, 0, false);
                    }
                }
            };
        }; //AllowUnknownVersions

        [TestGroup, Description("Our production environments do NOT allow requests for non-configured versions.")]
        public class DisallowUnknownVersions: TestNode
        {
            //update settings to match our assumptions

            SettingState orig_kdcsvc_xkdc_allowUnknownVersion=null;
            SettingState orig_kdcsvc_xkdc_enforceClientVersion=null;

            public override void PreRun()
            {
                Global.RO.Debug("Updating settings...");
                orig_kdcsvc_xkdc_allowUnknownVersion=Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_xkdc_allowUnknownVersion, "0");
                orig_kdcsvc_xkdc_enforceClientVersion=Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_xkdc_enforceClientVersion, "1");

                Suite.RefreshKDCsConfig();
            }

            public override void PostRun()
            {
                Global.RO.Debug("Reverting settings...");
                if (orig_kdcsvc_xkdc_allowUnknownVersion!=null)
                {
                    Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_xkdc_allowUnknownVersion);
                }

                if (orig_kdcsvc_xkdc_enforceClientVersion!=null)
                {
                    Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_xkdc_enforceClientVersion);
                }

                Suite.RefreshKDCsConfig();
            }

            //tests

            [TestGroup, Description("Tests around situations where clients are give the flash update required message.")]
            public class Flash: TestNode
            {
                [CompoundCase("Version 30", 30, (uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE)]
                [CompoundCase("Version 34", 34, (uint)0)]
                [CompoundCase("Version 99", 99, (uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("A machine not in any beta groups on title 1337FF00.")]
                public class MachineNothing: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedKerberosError=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700000004"), flashVersion, 0x1337FF00, 134, 0, expectedKerberosError, false);
                    }
                }

                [CompoundCase("Version 30", 30, (uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE, (uint)0)] //different group
                [CompoundCase("Version 31", 31, (uint)0,                                   HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Version 32", 32, (uint)0,                                   HResult.XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED)]
                [CompoundCase("Version 35", 35, (uint)0,                                   (uint)0)]
                [CompoundCase("Version 99", 99, (uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE, (uint)0)] //not configured
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Tests for a machine in beta group 1 on title 1337FF00.")]
                public class MachineF1: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedKerberosError=(uint)MyValues[1];
                        uint expectedHr=(uint)MyValues[2];
                        bool expectedBetaBit=(expectedHr==0);

                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700000206"), flashVersion, 0x1337FF00, 134, expectedHr, expectedKerberosError, expectedBetaBit);
                    }
                }

                [CompoundCase("Version 30", 30, (uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE)]
                [CompoundCase("Version 40", 40, (uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE)]
                [CompoundCase("Version 41", 41, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Flash update in the past.")]
                public class MachineF6: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedKerberosError=(uint)MyValues[1];

                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700006404"), flashVersion, 0x1337FF00, 134, 0, expectedKerberosError, true);
                    }
                }

                [CompoundCase("Version 30", 30, (uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE)]
                [CompoundCase("Version 40", 40, (uint)KerbErrCode.KDC_ERR_SVC_UNAVAILABLE)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Flash update that starts in the future.")]
                public class MachineF7: TestNode
                {
                    public override void Run()
                    {
                        uint flashVersion=(uint)(int)MyValues[0];
                        uint expectedKerberosError=(uint)MyValues[1];

                        MakeRequestAndVerify(MachineEditor.FromName("XE.133800000184"), flashVersion, 0x1337FF00, 134, 0, expectedKerberosError, true);
                    }
                }
            };

            [TestGroup, Description("Tests around situations where clients are given the title update required message.")]
            public class Title: TestNode
            {
                [CompoundCase("Version 130", 130, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE)]
                [CompoundCase("Version 134", 134, (uint)0)]
                [CompoundCase("Version 199", 199, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Machine not in any title beta groups.")]
                public class MachineNothing: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700000004"), 34, 0x1337FF00, titleVersion, expectedHr, 0, false);
                    }
                }

                [CompoundCase("Version 130", 130, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE)]
                [CompoundCase("Version 131", 131, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Version 132", 132, HResult.XONLINE_E_LOGON_UPDATE_REQUIRED)]
                [CompoundCase("Version 135", 135, (uint)0)]
                [CompoundCase("Version 199", 199, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Tests for a machine on title 1337FF00 in title beta group 1")]
                public class Machine_0T1: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700020006"), 34, 0x1337FF00, titleVersion, expectedHr, 0, true);
                    }
                }

                [CompoundCase("Version 130", 130, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE)]
                [CompoundCase("Version 140", 140, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE)]
                [CompoundCase("Version 141", 141, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Title beta group that ends in the past.")]
                public class Machine_0T6: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700640004"), 34, 0x1337FF00, titleVersion, expectedHr, 0, true);
               