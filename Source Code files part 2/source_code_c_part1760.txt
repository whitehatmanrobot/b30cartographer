 segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            USHORT      ns_niter;       /* number of iterations */
            USHORT      ns_nbytes;      /* number of bytes */
            CHAR        ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            CHAR        ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    USHORT      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    CHAR        nr_stype;       /* Source type */
    CHAR        nr_flags;       /* Flag byte */
    USHORT      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            CHAR        nr_segno;       /* Target segment number */
            CHAR        nr_res;         /* Reserved */
            USHORT nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            USHORT nr_mod;      /* Index into Module Reference Table */
            USHORT nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */


/* Resource type or name string */
struct rsrc_string
    {
    CHAR rs_len;            /* number of bytes in string */
    CHAR rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    USHORT rt_id;
    USHORT rt_nres;
    LONG   rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    USHORT rn_offset;   /* file offset to resource data */
    USHORT rn_length;   /* length of resource data */
    USHORT rn_flags;    /* resource flags */
    USHORT rn_id;       /* resource name id */
    USHORT rn_handle;   /* If loaded, then global handle */
    USHORT rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

/* Resource table */
struct new_rsrc
    {
    USHORT rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\inc\rc.h ===
#include <stdio.h>
#include <windef.h>

#define	wcsdigit(w) (w >= 0x0030 && w <= 0x0039)

#define TRUE	1
#define FALSE	0

/* The ResType field of NewHeader identifies the resource type */
#define  ICONTYPE      1
#define  CURSORTYPE    2

/* Identifies the menu item template version number */
#define  MENUITEMTEMPLATEVERISONNUMBER 0
#define  MENUITEMTEMPLATEBYTESINHEADER 0

#define DIFFERENCE	11

/* Predefined resource types */
#define RT_NAMETABLE	MAKEINTRESOURCE((DWORD)15)
#define RT_NEWRESOURCE	0x2000
#define RT_ERROR	0x7fff
#define RT_NEWBITMAP	MAKEINTRESOURCE((DWORD)RT_BITMAP+DIFFERENCE)

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

/* Translater flag bits */
#define fVIRTKEY    1
#define fNOINVERT   2
#define fSHIFT      4
#define fCONTROL    8
#define fALT        16

/* menu flag bits */

#define OPGRAYED          0x0001
#define OPINACTIVE        0x0002
#define OPBITMAP          0x0004
#define OPOWNERDRAW       0x0100
#define OPUSECHECKBITMAPS 0x0200
#define OPCHECKED         0x0008
#define OPPOPUP           0x0010
#define OPBREAKWBAR       0x0020
#define OPBREAK           0x0040
#define OPENDMENU         0x0080
#define OPHELP            0x4000
#define OPSEPARATOR       0x0800
/*#define OPPOPHELP         0x0004*/

/*
** dialog & menu template tokens (these start at 40)
*/

/* buttons */
#define TKRADIOBUTTON   40
#define TKCHECKBOX      41
#define TKPUSHBUTTON    42
#define TKDEFPUSHBUTTON 43
#define TKAUTOCHECKBOX	44
#define TK3STATE	45
#define TKAUTO3STATE	46
#define TKUSERBUTTON	47
#define TKAUTORADIOBUTTON	48
#define TKOWNERDRAW	50
#define TKGROUPBOX      51

/* static/edit */
#define TKEDITTEXT      60
#define TKLTEXT         61
#define TKRTEXT         62
#define TKCTEXT         63
#define TKEDIT          64
#define TKSTATIC        65
#define TKICON          66
#define TKBITMAP        67

/* menu stuff */
#define TKMENU          70
#define TKMENUITEM      71
#define TKSEPARATOR     72
#define TKCHECKED       73
#define TKGRAYED        74
#define TKINACTIVE      75
#define TKBREAKWBAR     76
#define TKBREAK         77
#define TKPOPUP         78
#define TKHELP          79

/* other controls */
#define TKLISTBOX       90
#define TKCOMBOBOX      91
#define TKRCDATA        92
#define TKSCROLLBAR	93
#define TKFONT		94
#define TKBUTTON        95
#define TKMESSAGETABLE  96

/* math expression tokens */
#define TKCLASS         100
#define TKPLUS          101
#define TKMINUS         102
#define TKNOINVERT      103
#define TKNOT           104
#define TKKANJI         105
#define TKSHIFT         106

/* Accel table */
#define TKALT           110
#define TKASCII         111
#define TKVIRTKEY       112
#define TKVALUE         113
#define TKBLOCK         114

/* verison */
#define TKFILEVERSION   120
#define TKPRODUCTVERSION	121
#define TKFILEFLAGSMASK 122
#define TKFILEFLAGS     123
#define TKFILEOS        124
#define TKFILETYPE      125
#define TKFILESUBTYPE   126

/* misc */
#define	TKCHARACTERISTICS	130
#define	TKLANGUAGE	131
#define	TKVERSION	132
#define TKSTYLE         133
#define TKCONTROL       134
#define TKCAPTION       135
#define TKDLGINCLUDE    136
#define TKLSTR	        137
#define	TKEXSTYLE	0xfff7	/* so as not to conflict with x-coordinate */

/* memory and load flags */
#define TKFIXED         0xfff0
#define TKMOVEABLE      0xfff1
#define TKDISCARD       0xfff2
#define TKLOADONCALL    0xfff3
#define TKPRELOAD       0xfff4
#define TKPURE          0xfff5
#define TKIMPURE        0xfff6

/* special tokens */
#define CHCARRIAGE	'\r'
#define CHSPACE		' '
#define CHNEWLINE	'\n'
#define CHTAB		9
#define CHDIRECTIVE	'#'
#define CHQUOTE		'"'
#define CHEXTENSION	'.'
#define CHCSOURCE	'c'
#define CHCHEADER	'h'

#define DEBUGLEX    1
#define DEBUGPAR    2
#define DEBUGGEN    4

/* The following switches, when defined enable various options
**  #define DEBUG enables debugging output.  Use one or more of the
**  values defined above to enable debugging output for different modules */

/* Version number.  VERSION and REVISION are used to set the API number
** in an RCed file.  SIGNON_* are used just to print the signon banner.
** Changing VERSION and REVISION means that applications RCed with this
** version will not run with earlier versions of Windows.  */

#define VERSION  2
#define REVISION 03
#define SIGNON_VER 3
#define SIGNON_REV 20

/* GetToken() flags */
#define TOKEN_NOEXPRESSION 0x8000

/* Current token structure */
#define MAXSTR (4096+1)
#define MAXTOKSTR (256+1)

#pragma pack(2)
typedef struct tok {
    LONG	longval;
    int		row;			/* line number of current token */
    int		col;			/* column number of current token */
    BOOL	flongval;		/* is parsed number a long? */
    USHORT	val;
    UCHAR	type;
} TOKEN;

typedef struct _fontdir {
    USHORT	ordinal;
    USHORT	nbyFont;
    struct _fontdir	*next;
} FONTDIR;

typedef struct _OBJLST {
    struct _OBJLST	*next;
    DWORD       nObj;         /* objecty number */
    DWORD       cb;           /* number of bytes used */
    DWORD       cpg;          /* number of pages used */
    DWORD       flags;        /* object memory flags */
} OBJLST, *POBJLST;

typedef struct Control {
    /* don't re-order the first items! */
    LONG	style;
    LONG	exstyle;
    SHORT	x,y,cx,cy;
    SHORT	id;
    /* end of don't re-order */
    WCHAR	fOrdinalText;
    WCHAR	class[ MAXTOKSTR ];
    WCHAR	text[ MAXTOKSTR ];
} CNTRL;

struct DialogHeader {
    /* don't re-order the first items! */
    LONG	style;
    LONG	exstyle;
    WORD	bNumberOfItems;
    SHORT	x,y,cx,cy;
    /* end of don't re-order */
    WCHAR	MenuName [ MAXTOKSTR ];
    WCHAR	Class[ MAXTOKSTR ];
    WCHAR	Title[ MAXTOKSTR ];
    USHORT	pointsize;
    WCHAR	Font[ MAXTOKSTR ];
    UCHAR	fOrdinalMenu, fClassOrdinal;
};

typedef struct mnHeader {
    USHORT   menuTemplateVersionNumber;
    USHORT   menuTemplateBytesInHeader;
} MNHEADER;


typedef struct mnStruc {
    SHORT	id;
    WCHAR	szText[ MAXTOKSTR ];
    UCHAR	OptFlags;
    UCHAR	PopFlag;
}  MNSTRUC;

/* End of file character/token */
#define EOFMARK 127

/* single character keywords that we ignore */
#define LPAREN   1      /* ( */
#define RPAREN   2      /* ) */

/* multiple character keywords */
#define FIRSTKWD 11             /* for adding to table indices */

#define OR       FIRSTKWD+1
#define BEGIN    FIRSTKWD+2
#define END      FIRSTKWD+3
#define COMMA    FIRSTKWD+4
#define TILDE    FIRSTKWD+5
#define AND      FIRSTKWD+6
#define EQUAL    FIRSTKWD+7
#define LASTKWD  FIRSTKWD+8  /* 19 */

/* Token types */
#define NUMLIT     LASTKWD+1  /* 20 */
#define STRLIT     LASTKWD+2
#define CHARLIT    LASTKWD+3
#define LSTRLIT    LASTKWD+4

#define BLOCKSIZE 16
struct StringEntry {
    struct StringEntry *next;
    DWORD       version;
    DWORD       characteristics;
    USHORT	hibits;
    SHORT       flags;
    WORD	language;
    WCHAR	*rgsz[ BLOCKSIZE ];
};

struct AccEntry {
    WORD	flags;
    WCHAR	ascii;
    USHORT	id;
    USHORT	unused;
};

typedef struct resinfo {
    DWORD       version;
    DWORD       characteristics;
    LONG	exstyleT;
    LONG	BinOffset;
    LONG	size;
    struct resinfo *next;
    DWORD       poffset;
    WCHAR	*name;
    POBJLST	pObjLst;
    WORD	language;
    SHORT	flags;
    USHORT	nameord;
    USHORT	cLang;
} RESINFO;

typedef struct typinfo {
    struct typinfo *next;
    struct resinfo *pres;
    WCHAR	*type;
    USHORT	typeord;
    USHORT	cTypeStr;
    USHORT	cNameStr;
    SHORT	nres;
} TYPINFO;

int	ResCount;   /* number of resources */
TYPINFO	*pTypInfo;

typedef struct tagResAdditional {
    DWORD       DataSize;               // size of data without header
    DWORD       HeaderSize;     // Length of the header
    // [Ordinal or Name TYPE]
    // [Ordinal or Name NAME]
    DWORD       DataVersion;    // version of data struct
    WORD	MemoryFlags;	// state of the resource
    WORD	LanguageId;	// Unicode support for NLS
    DWORD	Version;  	// Version of the resource data
    DWORD	Characteristics;	// Characteristics of the data
} RESADDITIONAL;

#pragma pack()


/* Global variables */
extern	SHORT	nFontsRead;
extern	FONTDIR	*pFontList;
extern	FONTDIR	*pFontLast;
extern	FILE	*errfh;
extern	FILE	*outfh;
extern	TOKEN	token;
extern	int	errorCount;
extern	CHAR	tokenbuf[ MAXSTR ];
extern	WCHAR	unicodebuf[ MAXSTR ];
extern	UCHAR	separators[EOFMARK+1];
extern	UCHAR	exename[_MAX_PATH], fullname[_MAX_PATH];
extern	UCHAR	curFile[_MAX_PATH];
extern	WORD	language;
extern	LONG	version;
extern	LONG	characteristics;

extern	struct	DialogHeader *pLocDlg;
extern	int	mnEndFlagLoc;	/* patch location for end of a menu. */
				/* we set the high order bit there    */

extern	BOOL	fFoundBinFile;	/* is there a .res file to read?	*/
extern	BOOL	fVerbose;	/* verbose mode (-v) */
extern	BOOL	fKanjiMode;
extern	SHORT	k1,k2,k3,k4;
extern	RESINFO*pResString;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\component.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    Component.h
//
//  Abstract:
//
//    This file contains the Component object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _COMPONENT_H_
#define _COMPONENT_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class Component
{
public:
    Component(LPSTR name, LPSTR folderName, LPSTR infName, LPSTR sectionName)
    {
        sprintf(m_Name,"%s",name);
        sprintf(m_FolderName,"%s",folderName);
        sprintf(m_InfName,"%s",infName);
        sprintf(m_InfInstallSectionName,"%s",sectionName);
        m_Next = NULL;
        m_Previous = NULL;
    };

    LPSTR getName() { return (m_Name);};
    LPSTR getFolderName() { return (m_FolderName); };
    LPSTR getInfName() { return (m_InfName); };
    LPSTR getInfInstallSectionName() { return (m_InfInstallSectionName); };
    Component* getNext() { return (m_Next); };
    Component* getPrevious() { return (m_Previous); };
    void setNext(Component *next) { m_Next = next; };
    void setPrevious(Component *previous) { m_Previous = previous; };

private:
    CHAR m_Name[MAX_PATH];
    CHAR m_FolderName[MAX_PATH];
    CHAR m_InfName[MAX_PATH];
    CHAR m_InfInstallSectionName[MAX_PATH];
    Component *m_Next;
    Component *m_Previous;
};

#endif //_COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\componentlist.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    ComponentList.h
//
//  Abstract:
//
//    This file contains the Component List object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _COMPONENTLIST_H_
#define _COMPONENTLIST_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"
#include "Component.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class ComponentList
{
public:
    ComponentList()
    {
        m_Head = NULL;
        m_Tail = NULL;
        m_Entries = 0;
    };

    ~ComponentList()
    {
        Component* temp;

        while ((temp = getFirst()) != NULL)
        {
            remove(temp);
        }
    };

    DWORD getComponentNumber() { return (m_Entries); };
    Component* getFirst() { return (m_Head); };

    void add(Component* item)
    {
        if ((m_Tail == NULL) && (m_Head == NULL))
        {
            m_Tail = item;
            m_Head = item;
        }
        else
        {
            item->setPrevious(m_Tail);
            m_Tail->setNext(item);
            m_Tail = item;
        }
        m_Entries++;
    };
    void remove(Component* item)
    {
        if ((m_Tail == m_Head) && (m_Tail == item))
        {
            m_Tail = NULL;
            m_Head = NULL;
        }
        else
        {
            if (m_Head = item)
            {
                m_Head = item->getNext();
                (item->getNext())->setPrevious(NULL);
            }
            else if (m_Tail = item)
            {
                m_Tail = item->getPrevious();
                (item->getPrevious())->setNext(NULL);
            }
            else
            {
                (item->getPrevious())->setNext(item->getNext());
                (item->getNext())->setPrevious(item->getPrevious());
            }
        }

        delete item;
        item = NULL;
        m_Entries--;
    };

private:
    Component *m_Head;
    Component *m_Tail;
    DWORD m_Entries;
};

#endif //_COMPONENTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\inc\rcunicod.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.h

Abstract:

    This is the header file for rc 16-bit unicode support.  It contains
	the translatation table for codepage 1252.  This was taken from the
	nls1252.txt file.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/

#ifndef __RCUNICOD

#define __RCUNICOD


#define IN
#define OUT

#define DFT_TEST_SIZE			10	// The number of words to test to get
									// an accurate determination of file type.

//
// The following may be retruned from DetermineFileType ().
//

#define DFT_FILE_IS_UNKNOWN		0	// File type not yet determined.
#define DFT_FILE_IS_8_BIT		1	// File is an 8-bit ascii file.
#define DFT_FILE_IS_16_BIT		2	// File is standard 16-bit unicode file.
#define DFT_FILE_IS_16_BIT_REV	3	// File is reversed 16-bit unicode file.

//
// The following may be returned from DetermnineSysEndianType ().
//

#define DSE_SYS_LITTLE_ENDIAN	1	// Return values from determine system
#define DSE_SYS_BIG_ENDIAN		2	// endian type.

//
// This is all the translation we currently need.
//

INT
A_fwrite (
	IN		CHAR	*pchMBString,
    IN		INT		nSizeOfItem,
    IN		INT		nCountToWrite,
    IN      FILE	*fpOutputFile
    );

INT
U_fwrite (
	IN		WCHAR	*pwchUnicodeString,
    IN		INT		nSizeOfItem,
    IN		INT		nCountToWrite,
    IN      FILE	*fpOutputFile
    );

INT
A_fputc (
    IN		CHAR	chCharToWrite,
    IN      FILE	*fpOutputFile
    );

INT
U_fputc (
    IN		WCHAR	wcCharToWrite,
    IN      FILE	*fpOutputFile
    );

BOOL
UnicodeFromMBString (
    OUT		WCHAR	*pwchUnicodeString,
    IN		CHAR	*pchMBString,
	IN		INT		nCountStrLength
    );

BOOL
MBStringFromUnicode (
    OUT		CHAR	*pchMBString,
    IN		WCHAR	*pwchUnicodeString,
	IN		INT		nCountStrLength
    );

#ifdef DBCS
BOOL
UnicodeFromMBStringN (
    OUT		WCHAR	*pwchUnicodeString,
    IN		CHAR	*pchMBString,
    IN		INT	nCountStrLength,
    IN          UINT    uiCodePage
    );

BOOL
MBStringFromUnicodeN (
    OUT		CHAR	*pchMBString,
    IN		WCHAR	*pwchUnicodeString,
    IN		INT	nCountStrLength,
    IN          UINT    uiCodePage
    );
#endif // DBCS

INT
Char1252FromUnicode (
    IN		WCHAR	wchUnicodeChar
    );

//
// This function can be used to determine the format of a disk file.
//
INT
DetermineFileType (
    IN      FILE	*fpInputFile
    );

//
// This function will return the endian type of the current system.
//
INT
DetermineSysEndianType (
	VOID
    );

#endif  // __RCUNICOD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\file.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    file.h
//
//  Abstract:
//
//    This file contains the File layout object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _FILE_H_
#define _FILE_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class File
{
public:
    File(LPSTR destDir, LPSTR name, LPSTR srcDir, LPSTR srcName, INT dirId)
    {
        // Compute and copy destination directory.
        switch(dirId)
        {
        case(10):
            {
                sprintf(m_DestinationDir,"%s",destDir);
                m_WindowsDir = TRUE;
                break;
            }
        case(11):
            {
                sprintf(m_DestinationDir,"System32\\%s",destDir);
                m_WindowsDir = TRUE;
                break;
            }
        case(17):
            {
                sprintf(m_DestinationDir,"Inf\\%s",destDir);
                m_WindowsDir = TRUE;
                break;
            }
        case(18):
            {
                sprintf(m_DestinationDir,"Help\\%s",destDir);
                m_WindowsDir = TRUE;
                break;
            }
        case(24):
            {
                LPSTR index;
                index = strchr(destDir, '\\');
                sprintf(m_DestinationDir,"%s",index + 1);
                m_WindowsDir = FALSE;
                break;
            }
        case(25):
            {
                sprintf(m_DestinationDir,"%s",destDir);
                m_WindowsDir = TRUE;
                break;
            }
        default:
            {
                sprintf(m_DestinationDir,"%s", destDir);
                m_WindowsDir = FALSE;
                break;
            }
        }

        //
        //  Verify that the last character of the destination dir is not '\'
        //
        if (m_DestinationDir[strlen(m_DestinationDir)-1] == '\\')
        {
            m_DestinationDir[strlen(m_DestinationDir)-1] = '\0';
        }

        // Copy destination file name.
        sprintf(m_DestinationName,"%s",name);

        // Copy source directory.
        sprintf(m_SourceDir,"%s",srcDir);

        // Copy and correct source name.
        sprintf(m_SourceName,"%s",srcName);
        if( m_SourceName[_tcslen(m_SourceName)-1] == '_')
        {
            m_SourceName[_tcslen(m_SourceName)-1] = 'I';
        }

        // Initialize linked-list pointers.
        m_Next = NULL;
        m_Previous = NULL;
    };

    LPSTR getDirectoryDestination() { return(m_DestinationDir); };
    LPSTR getName() { return (m_DestinationName); };
    LPSTR getSrcDir() { return (m_SourceDir); };
    LPSTR getSrcName() { return (m_SourceName); };
    BOOL  isWindowsDir() { return (m_WindowsDir);}
    File* getNext() { return (m_Next); };
    File* getPrevious() { return (m_Previous); };
    void setNext(File *next) { m_Next = next; };
    void setPrevious(File *previous) { m_Previous = previous; };

private:
    CHAR  m_DestinationName[MAX_PATH];
    CHAR  m_DestinationDir[MAX_PATH];
    CHAR  m_SourceName[MAX_PATH];
    CHAR  m_SourceDir[MAX_PATH];
    BOOL  m_WindowsDir;
    File *m_Next;
    File *m_Previous;
};

#endif //_FILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\filelist.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    FileList.h
//
//  Abstract:
//
//    This file contains the File List object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _FILELIST_H_
#define _FILELIST_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"
#include "File.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class FileList
{
public:
    FileList()
    {
        m_Head = NULL;
        m_Tail = NULL;
        m_Entries = 0;
    };

    ~FileList()
    {
        free();
    };

    DWORD getFileNumber() { return (m_Entries); };
    File* getFirst() { return (m_Head); };

    void add(File* item)
    {
        if ((m_Tail == NULL) && (m_Head == NULL))
        {
            m_Tail = item;
            m_Head = item;
        }
        else
        {
            item->setPrevious(m_Tail);
            m_Tail->setNext(item);
            m_Tail = item;
        }
        m_Entries++;
    };
    void remove(File* item)
    {
        if ((m_Tail == m_Head) && (m_Tail == item))
        {
            m_Tail = NULL;
            m_Head = NULL;
        }
        else
        {
            if (m_Head == item)
            {
                m_Head = item->getNext();
                (item->getNext())->setPrevious(NULL);
            }
            else if (m_Tail == item)
            {
                m_Tail = item->getPrevious();
                (item->getPrevious())->setNext(NULL);
            }
            else
            {
                (item->getPrevious())->setNext(item->getNext());
                (item->getNext())->setPrevious(item->getPrevious());
            }
        }

        delete item;
        item = NULL;
        m_Entries--;
    };
    BOOL isDirId(BOOL bWindowsDir)
    {
        File* index;

        index = getFirst();
        while (index != NULL)
        {
            if (index->isWindowsDir() == bWindowsDir)
            {
                return (TRUE);
            }
        }
        return (FALSE);
    };
    File* search(File* refNode, LPSTR dirBase)
    {
        File* index;
        LPSTR dirNamePtr;

        index = getFirst();
        while (index != NULL)
        {
            if (index != refNode)
            {
                //
                //  Try a match
                //
                dirNamePtr = index->getDirectoryDestination();
                if (_stricmp(dirNamePtr, dirBase) == 0)
                {
                    return (index);
                }
            }

            //
            //  Continue the loop.
            //
            index = index->getNext();
        }

        return (NULL);
    };
    void free()
    {
        File* temp;

        while ((temp = getFirst()) != NULL)
        {
            remove(temp);
        }
    }

private:
    File *m_Head;
    File *m_Tail;
    DWORD m_Entries;
};

#endif //_FILELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\filelayout.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    filelayout.h
//
//  Abstract:
//
//    This file contains the File layout object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _FILELAYOUT_H_
#define _FILELAYOUT_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class FileLayout
{
public:
    FileLayout(LPSTR originFilename, LPSTR destFilename, DWORD flavorMask)
    {
        sprintf(m_OriginFilename,"%s",originFilename);
        sprintf(m_DestFilename,"%s",destFilename);
        m_Flavor = flavorMask;
        m_Next = NULL;
        m_Previous = NULL;
    };

    BOOL isFlavor(DWORD dwFlavor){ return (dwFlavor & m_Flavor); };
    LPSTR getOriginFileName() { return (m_OriginFilename); };
    LPSTR getDestFileName() { return (m_DestFilename); };
    FileLayout* getNext() { return (m_Next); };
    FileLayout* getPrevious() { return (m_Previous); };
    void setNext(FileLayout *next) { m_Next = next; };
    void setPrevious(FileLayout *previous) { m_Previous = previous; };

private:
    CHAR  m_OriginFilename[MAX_PATH];
    CHAR  m_DestFilename[MAX_PATH];
    DWORD m_Flavor;
    FileLayout *m_Next;
    FileLayout *m_Previous;
};

#endif //_FILELAYOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	infparser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8D69AD93_DBBC_4FB2_ADA1_4F5028797EDC__INCLUDED_)
#define AFX_STDAFX_H__8D69AD93_DBBC_4FB2_ADA1_4F5028797EDC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
	#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8D69AD93_DBBC_4FB2_ADA1_4F5028797EDC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\filelayoutexceptionlist.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    FileLayoutExceptionList.h
//
//  Abstract:
//
//    This file contains the File Layout Exception List object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _FILELAYOUTEXCEPTIONLIST_H_
#define _FILELAYOUTEXCEPTIONLIST_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"
#include "FileLayout.h"

///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class FileLayoutExceptionList
{
public:
    FileLayoutExceptionList()
    {
        m_Head = NULL;
        m_Tail = NULL;
        m_Entries = 0;
    };

    ~FileLayoutExceptionList()
    {
        FileLayout* temp;

        while ((temp = getFirst()) != NULL)
        {
            remove(temp);
        }
    };

    DWORD getExceptionsNumber() { return (m_Entries); };
    FileLayout* getFirst() { return (m_Head); };

    void insert(FileLayout* item)
    {
        if ((m_Tail == NULL) && (m_Head == NULL))
        {
            m_Tail = item;
            m_Head = item;
        }
        else
        {
            item->setPrevious(m_Tail);
            m_Tail->setNext(item);
            m_Tail = item;
        }
        m_Entries++;
    };
    void remove(FileLayout* item)
    {
        if ((m_Tail == m_Head) && (m_Tail == item))
        {
            m_Tail = NULL;
            m_Head = NULL;
        }
        else
        {
            if (m_Head = item)
            {
                m_Head = item->getNext();
                (item->getNext())->setPrevious(NULL);
            }
            else if (m_Tail = item)
            {
                m_Tail = item->getPrevious();
                (item->getPrevious())->setNext(NULL);
            }
            else
            {
                (item->getPrevious())->setNext(item->getNext());
                (item->getNext())->setPrevious(item->getPrevious());
            }
        }

        delete item;
        item = NULL;
        m_Entries--;
    };
    FileLayout* search(LPSTR srcName)
    {
        FileLayout* item;

        item = getFirst();
        while (item != NULL)
        {
            if( _tcsicmp(srcName, item->getOriginFileName()) == 0)
            {
                return item;
            }

            item = item->getNext();
        }

        return NULL;
    }

private:
    FileLayout *m_Head;
    FileLayout *m_Tail;
    DWORD m_Entries;
};

#endif //_FILELAYOUTEXCEPTIONLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\infparser.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    infparser.h
//
//  Abstract:
//
//    This file contains global definition for the infparser.exe utility.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _INFPARSER_H_
#define _INFPARSER_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <setupapi.h>
#include <rpc.h>
#include <tchar.h>
#include "Component.h"
#include "ComponentList.h"
#include "FileLayout.h"
#include "FileLayoutExceptionList.h"
#include "File.h"
#include "FileList.h"
#include "Uuid.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Enumeration
//
///////////////////////////////////////////////////////////////////////////////
enum flavorList
{
    FLV_UNDEFINED    = 0x0000,
    FLV_CORE         = 0x0001,
    FLV_PERSONAL     = 0x0002,
    FLV_PROFESSIONAL = 0x0004,
    FLV_SERVER       = 0x0008,
    FLV_ADVSERVER    = 0x0010,
    FLV_ENTERPRISE   = 0x0020,
    FLV_DATACENTER   = 0x0040
};

enum argumentToken
{
    ARG_UNDEFINED = 0x0000,
    ARG_BINARY    = 0x0001,
    ARG_LANG      = 0x0002,
    ARG_FLAVOR    = 0x0004,
    ARG_DIR       = 0x0008,
    ARG_OUT       = 0x0010,
    ARG_SILENT    = 0x0020
};

enum binaryType
{
    BIN_UNDEFINED = 0x0000,
    BIN_32        = 0x0001,
    BIN_64        = 0x0002,
};


///////////////////////////////////////////////////////////////////////////////
//
//  Global
//
///////////////////////////////////////////////////////////////////////////////
extern BOOL bSilence;
extern DWORD dwComponentCounter;
extern DWORD dwDirectoryCounter;
extern WORD  gBuildNumber;

#endif //_INFPARSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\infparser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    infparser.cpp
//
//  Abstract:
//
//    This file contains the entry point of the infparser.exe utility.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "infparser.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Global variable.
//
///////////////////////////////////////////////////////////////////////////////
BOOL bSilence = TRUE;
DWORD dwComponentCounter = 0;
DWORD dwDirectoryCounter = 1;
WORD  gBuildNumber = 0;


///////////////////////////////////////////////////////////////////////////////
//
//  Prototypes.
//
///////////////////////////////////////////////////////////////////////////////
BOOL DirectoryExist(LPSTR dirPath);
BOOL ValidateLanguage(LPSTR dirPath, LPSTR langName, DWORD binType);
WORD ConvertLanguage(LPSTR dirPath, LPSTR langName);
int ListContents(LPSTR filename, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType);
int ListComponents(FileList *dirList, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType);
int ListMuiFiles(FileList *dirList, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType);
void PrintFileList(FileList* list, HANDLE hFile, BOOL compressed, BOOL bWinDir);
BOOL PrintLine(HANDLE hFile, LPCSTR lpLine);
HANDLE CreateOutputFile(LPSTR filename);
VOID removeSpace(LPSTR src, LPSTR dest);
DWORD TransNum(LPTSTR lpsz);
void Usage();


///////////////////////////////////////////////////////////////////////////////
//
//  Main entry point.
//
///////////////////////////////////////////////////////////////////////////////
int __cdecl main(int argc, char* argv[])
{
    LPSTR  sLangName = NULL;
    LPSTR  sDirPath = NULL;
    DWORD  dwFlavor = FLV_UNDEFINED;
    DWORD  dwBinType = BIN_UNDEFINED;
    DWORD  dwArg = ARG_UNDEFINED;
    WORD   wLangID = 0;
    HANDLE hFile;
    int    argIndex = 1;
    LPSTR lpFileName = NULL;


    //
    //  Check if we have the minimal number of arguments.
    //
    if (argc < 6)
    {
        Usage();
        return (-1);
    }

    //
    //  Parse the command line.
    //
    while (argIndex < argc)
    {
        if (*argv[argIndex] == '/')
        {
            switch(*(argv[argIndex]+1))
            {
            case('b'):
            case('B'):
                {
                    //
                    //  Binairy i386 or ia64
                    //
                    if ((*(argv[argIndex]+3) == '3') && (*(argv[argIndex]+4) == '2'))
                    {
                        dwBinType = BIN_32;
                    }
                    else if ((*(argv[argIndex]+3) == '6') && (*(argv[argIndex]+4) == '4'))
                    {
                        dwBinType = BIN_64;
                    }
                    else
                    {
                        return (argIndex);
                    }

                    dwArg |= ARG_BINARY;
                    break;
                }
            case('l'):
            case('L'):
                {
                    //
                    //  Language
                    //
                    sLangName = (argv[argIndex]+3);
                    dwArg |= ARG_LANG;
                    break;
                }
            case('f'):
            case('F'):
                {
                    //
                    //  Flavor requested
                    //
                    switch(*(argv[argIndex]+3))
                    {
                    case('c'):
                    case('C'):
                        { 
                            dwFlavor = FLV_CORE;
                            break;
                        }
                    case('p'):
                    case('P'):
                        { 
                            dwFlavor = FLV_PROFESSIONAL;
                            break;
                        }
                    case('s'):
                    case('S'):
                        {
                            dwFlavor = FLV_SERVER;
                            break;
                        }
                    case('a'):
                    case('A'):
                        {
                            dwFlavor = FLV_ADVSERVER;
                            break;
                        }
                    case('d'):
                    case('D'):
                        {
                            dwFlavor = FLV_DATACENTER;
                            break;
                        }
                    default:
                        {
                            return (argIndex);
                        }
                    }

                    dwArg |= ARG_FLAVOR;
                    break;
                }
            case('s'):
            case('S'):
                {
                    //
                    //  Binairy location
                    //
                    sDirPath = (argv[argIndex]+3);
                    dwArg |= ARG_DIR;
                    break;
                }
            case('o'):
            case('O'):
                {
                    //
                    //  Output filename
                    //
                    /*
                    if ((hFile = CreateOutputFile(argv[argIndex]+3)) == INVALID_HANDLE_VALUE)
                    {
                        return (argIndex);
                    }
                    */

                    lpFileName = argv[argIndex]+3;

                    dwArg |= ARG_OUT;
                    break;
                }
            case('v'):
            case('V'):
                {
                    //
                    //  Verbose mode
                    //
                    bSilence = FALSE;
                    dwArg |= ARG_SILENT;
                    break;
                }
            default:
                {
                    Usage();
                    return (argIndex);
                }
            }
        }
        else
        {
            Usage();
            return (-1);
        }

        //
        //  Next argument
        //
        argIndex++;
    }

    //
    // Validate arguments passed. Should have all five basic argument in order
    // to continue.
    //
    if ((dwArg == ARG_UNDEFINED) ||
        !((dwArg & ARG_BINARY) &&
          (dwArg & ARG_LANG) &&
          (dwArg & ARG_DIR) &&
          (dwArg & ARG_OUT) &&
          (dwArg & ARG_FLAVOR)))
    {
        Usage();
        return (-1);
    }

    //
    // Validate Source directory
    //
    if (!DirectoryExist(sDirPath))
    {
        return (-2);
    }

    //
    // Validate Language
    //
    if (!ValidateLanguage(sDirPath, sLangName, dwBinType))
    {
        return (-3);
    }

    //
    //  Get LANGID from the language
    //
    if ( (gBuildNumber = ConvertLanguage(sDirPath, sLangName)) == 0x0000)
    {
        return (-4);
    }

    //
    //  Generate the file list
    //
    if ((dwArg & ARG_OUT) && lpFileName)
   	{
    	return ListContents(lpFileName, sDirPath, sLangName, dwFlavor, dwBinType);
   	}
}


///////////////////////////////////////////////////////////////////////////////
//
//  ListContents()
//
//  Generate the file list contents.
//
///////////////////////////////////////////////////////////////////////////////
int ListContents(LPSTR filename, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType)
{
    int iRet = 0;
    Uuid* uuid;
    CHAR schemaPath[MAX_PATH] = {0};
    CHAR outputString[4096] = {0};
    FileList fileList;
    HANDLE outputFile = CreateOutputFile(filename);

    if (outputFile == INVALID_HANDLE_VALUE)
  	{
  		iRet = -1;
    	goto ListContents_EXIT;
    }

    //
    //  Create a UUID for this module and the schema path
    //
    uuid = new Uuid();
    sprintf(schemaPath, "%s\\control\\MmSchema.xml", dirPath);

    //
    //  Print module header.
    //
    PrintLine(outputFile, "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>");
    sprintf(outputString, "<Module Name=\"MUI MSI File Content\" Id=\"%s\" Language=\"0\" Version=\"1.0\" xmlns=\"%s\">", uuid->getString(), schemaPath);
    PrintLine(outputFile, outputString);
    delete uuid;
    uuid = new Uuid();
    sprintf(outputString, "  <Package Id=\"%s\"", uuid->getString());
    PrintLine(outputFile, outputString);
    delete uuid;
    PrintLine(outputFile, "   Description=\"Content module\"");
    PrintLine(outputFile, "   Platforms=\"Intel\"");
    PrintLine(outputFile, "   Languages=\"0\"");
    PrintLine(outputFile, "   InstallerVersion=\"100\"");
    PrintLine(outputFile, "   Manufacturer=\"Microsoft Corporation\"");
    PrintLine(outputFile, "   Keywords=\"MergeModule, MSI, Database\"");
    PrintLine(outputFile, "   Comments=\"This merge module contains all the MUI file content\"");
    PrintLine(outputFile, "   ShortNames=\"yes\" Compressed=\"yes\"");
    PrintLine(outputFile, "/>");

    //
    //  Generate components file list
    //
    if ( (iRet = ListComponents(&fileList, dirPath, lang, flavor, binType)) != 0)
    {
        goto ListContents_EXIT;
    }

    //
    //  Generate Mui file list
    //
    if ((iRet =ListMuiFiles(&fileList, dirPath, lang, flavor, binType)) != 0)
    {
        goto ListContents_EXIT;
    }

    //
    //  Print compressed directory structure.
    //
    PrintLine(outputFile, "<Directory Name=\"SOURCEDIR\">TARGETDIR");
    if (fileList.isDirId(TRUE))
    {
        PrintLine(outputFile, " <Directory Name=\"Windows\">WindowsFolder");
        PrintFileList(&fileList, outputFile, TRUE, TRUE);
        PrintLine(outputFile, " </Directory>");
    }
    if (fileList.isDirId(FALSE))
    {
        PrintLine(outputFile, " <Directory Name=\"ProgramFilesFolder\">ProgramFilesFolder");
        PrintFileList(&fileList, outputFile, TRUE, FALSE);
        PrintLine(outputFile, " </Directory>");
    }
    PrintLine(outputFile, "</Directory>");

    //
    //  Print module footer.
    //
    PrintLine(outputFile, "</Module>");
    
ListContents_EXIT:
    if (outputFile)
    	CloseHandle(outputFile);

    return (iRet);
}

///////////////////////////////////////////////////////////////////////////////
//
//  ListComponents()
//
//  Generate the file list of each components.
//
///////////////////////////////////////////////////////////////////////////////
int ListComponents(FileList *dirList, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType)
{
    HINF hFile;
    CHAR muiFilePath[MAX_PATH];
    UINT lineCount, lineNum;
    INFCONTEXT context;
    ComponentList componentList;
    Component* component;

    //
    //  Used only in core flavor
    //
    if (flavor != FLV_CORE)
    {
        return (0);
    }

    //
    //  Create the path to open the mui.inf file
    //
    sprintf(muiFilePath, "%s\\mui.inf", dirPath);

    //
    //  Open the MUI.INF file.
    //
    hFile = SetupOpenInfFile(muiFilePath, NULL, INF_STYLE_WIN4, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return (-1);
    }

    //
    //  Get the number of component.
    //
    lineCount = (UINT)SetupGetLineCount(hFile, TEXT("Components"));
    if (lineCount > 0)
    {
        //
        //  Go through all component of the list.
        //
        CHAR componentName[MAX_PATH];
        CHAR componentFolder[MAX_PATH];
        CHAR componentInf[MAX_PATH];
        CHAR componentInst[MAX_PATH];
        for (lineNum = 0; lineNum < lineCount; lineNum++)
        {
            if (SetupGetLineByIndex(hFile, TEXT("Components"), lineNum, &context) &&
                SetupGetStringField(&context, 0, componentName, MAX_PATH, NULL) &&
                SetupGetStringField(&context, 1, componentFolder, MAX_PATH, NULL) &&
                SetupGetStringField(&context, 2, componentInf, MAX_PATH, NULL) &&
                SetupGetStringField(&context, 3, componentInst, MAX_PATH, NULL))
            {
                //
                //  Create the components
                //
                if( (component = new Component( componentName,
                                                componentFolder,
                                                componentInf,
                                                componentInst)) != NULL)
                {
                    componentList.add(component);
                }
            }
        }
    }

    //
    //  Close inf handle
    //
    SetupCloseInfFile(hFile);

    //
    //  Output component information
    //
    component = componentList.getFirst();
    while (component != NULL)
    {
        CHAR componentInfPath[MAX_PATH];
        CHAR componentPath[MAX_PATH];
        int fieldCount, fieldCount2;
        INFCONTEXT context2;
        INFCONTEXT context3;
        File* file;

        //
        //  Compute the component inf path.
        //
        if (binType == BIN_32)
        {
            sprintf( componentInfPath,
                     "%s\\%s\\i386.uncomp\\%s\\%s",
                     dirPath,
                     lang,
                     component->getFolderName(),
                     component->getInfName());
            sprintf( componentPath,
                     "%s\\%s\\i386.uncomp\\%s",
                     dirPath,
                     lang,
                     component->getFolderName());
        }
        else
        {
            sprintf( componentInfPath,
                     "%s\\%s\\ia64.uncomp\\%s\\%s",
                     dirPath,
                     lang,
                     component->getFolderName(),
                     component->getInfName());
            sprintf( componentPath,
                     "%s\\%s\\ai64.uncomp\\%s",
                     dirPath,
                     lang,
                     component->getFolderName());
        }

        //
        //  Open the component inf file.
        //
        hFile = SetupOpenInfFile(componentInfPath, NULL, INF_STYLE_WIN4, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            return (-1);
        }

        //
        //  Search for the CopyFiles section
        //
        if (SetupFindFirstLine( hFile,
                                component->getInfInstallSectionName(),
                                "CopyFiles",
                                &context ) &&
            (fieldCount = SetupGetFieldCount(&context)))
        {
            CHAR instSectionName[MAX_PATH];
            INT  destDirId;
            CHAR destDirSubFolder[MAX_PATH];
            CHAR destFileName[MAX_PATH];
            CHAR srcFileName[MAX_PATH];

            for (int fieldIdx = 1; fieldIdx <= fieldCount; fieldIdx++)
            {
                //
                //  Get the install section Names and search for the 
                //  corresponding DestinationDirs.
                //
                if (SetupGetStringField(&context, fieldIdx, instSectionName, MAX_PATH, NULL) &&
                    SetupFindFirstLine(hFile, "DestinationDirs", instSectionName, &context2))
                {
                    //
                    //  Get the destination directory information for this
                    //  installation section
                    //
                    if (SetupGetIntField(&context2, 1, &destDirId))
                    {
                        //
                        //  Possible that no sub directory
                        //
                        if(!SetupGetStringField(&context2, 2, destDirSubFolder, MAX_PATH, NULL))
                        {
                            destDirSubFolder[0] = '\0';
                        }

                        //
                        //  Scan the section for file
                        //
                        if ((lineCount = (UINT)SetupGetLineCount(hFile, instSectionName)) > 0)
                        {
                            for (lineNum = 0; lineNum < lineCount; lineNum++)
                            {
                                if (SetupGetLineByIndex(hFile, instSectionName, lineNum, &context3) &&
                                    (fieldCount2 = SetupGetFieldCount(&context3)))
                                {
                                    if (fieldCount2 > 1)
                                    {
                                        if (SetupGetStringField(&context3, 1, destFileName, MAX_PATH, NULL)  &&
                                            SetupGetStringField(&context3, 2, srcFileName, MAX_PATH, NULL))
                                        {
                                            //
                                            //  Create the components
                                            //
                                            if ((file = new File(destDirSubFolder,
                                                                 destFileName,
                                                                 componentPath,
                                                                 srcFileName,
                                                                 destDirId)) != NULL)
                                            {
                                                dirList->add(file);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if( SetupGetStringField(&context3, 0, destFileName, MAX_PATH, NULL))
                                        {
                                            //
                                            //  Create the components
                                            //
                                            if( (file = new File(destDirSubFolder,
                                                                 destFileName,
                                                                 componentPath,
                                                                 destFileName,
                                                                 destDirId)) != NULL)
                                            {
                                                dirList->add(file);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                }
            }
        }
        //
        // Next Component
        //
        component = component->getNext();

    }

    return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  ListMuiFiles()
//
//  Generate the file list for MUI.
//
///////////////////////////////////////////////////////////////////////////////
int ListMuiFiles(FileList *dirList, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType)
{
    HINF hFile;
    CHAR muiFilePath[MAX_PATH];
    CHAR muiFileSearchPath[MAX_PATH];
    int lineCount, lineNum, fieldCount;
    INFCONTEXT context;
    FileLayoutExceptionList exceptionList;
    WIN32_FIND_DATA findData;
    HANDLE fileHandle;
    File* file;

    //
    //  Create the path to open the mui.inf file
    //
    sprintf(muiFilePath, "%s\\mui.inf", dirPath);

    //
    //  Open the MUI.INF file.
    //
    hFile = SetupOpenInfFile(muiFilePath, NULL, INF_STYLE_WIN4, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return (-1);
    }

    //
    //  Get the number of file exception.
    //
    lineCount = (UINT)SetupGetLineCount(hFile, TEXT("File_Layout"));
    if (lineCount > 0)
    {
        //
        //  Go through all file exception of the list.
        //
        CHAR originFilename[MAX_PATH];
        CHAR destFilename[MAX_PATH];
        CHAR fileFlavor[30];
        DWORD dwFlavor;
        for (lineNum = 0; lineNum < lineCount; lineNum++)
        {
            if (SetupGetLineByIndex(hFile, TEXT("File_Layout"), lineNum, &context) &&
                (fieldCount = SetupGetFieldCount(&context)))
            {
                if (SetupGetStringField(&context, 0, originFilename, MAX_PATH, NULL) &&
                    SetupGetStringField(&context, 1, destFilename, MAX_PATH, NULL))
                {
                    FileLayout* fileException;

                    dwFlavor = 0;
                    for(int fieldId = 2; fieldId <= fieldCount; fieldId++)
                    {
                        if(SetupGetStringField(&context, fieldId, fileFlavor, MAX_PATH, NULL))
                        {
                            switch(*fileFlavor)
                            {
                            case('p'):
                            case('P'):
                                { 
                                    dwFlavor |= FLV_PROFESSIONAL;
                                    break;
                                }
                            case('s'):
                            case('S'):
                                {
                                    dwFlavor |= FLV_SERVER;
                                    break;
                                }
                            case('d'):
                            case('D'):
                                {
                                    dwFlavor |= FLV_DATACENTER;
                                    break;
                                }
                            case('a'):
                            case('A'):
                                {
                                    dwFlavor |= FLV_ENTERPRISE;
                                    break;
                                }
                            }

                        }
                    }

                    //
                    //  Add only information needed for this specific flavor.
                    //
                    fileException = new FileLayout(originFilename, destFilename, dwFlavor);
                    exceptionList.insert(fileException);
                }
            }
        }
    }

    //
    //  Close inf handle
    //
    SetupCloseInfFile(hFile);

    //
    //  Compute the binary source path.
    //
    if (binType == BIN_32)
    {
        sprintf( muiFileSearchPath, "%s\\%s\\i386.uncomp", dirPath, lang);
        sprintf( muiFilePath, "%s\\%s\\i386.uncomp\\*.*", dirPath, lang);
    }
    else
    {
        sprintf( muiFileSearchPath, "%s\\%s\\ia64.uncomp", dirPath, lang);
        sprintf( muiFilePath, "%s\\%s\\ia64.uncomp\\*.*", dirPath, lang);
    }

    //
    //  Scan uncomp source directory for file information
    //
    if ((fileHandle = FindFirstFile(muiFilePath, &findData)) != INVALID_HANDLE_VALUE)
    {
        //
        //  Look for files
        //
        do
        {
            LPSTR extensionPtr;
            INT dirIdentifier = 0;
            CHAR destDirectory[MAX_PATH] = {0};
            CHAR destName[MAX_PATH] = {0};
            FileLayout* fileException = NULL;

            //
            //  Scan only files at this level.
            //
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                continue;
            }

            //
            // Search the extension to determine the destination location and possibly
            // exclude file destined for Personal.
            //
            if ((extensionPtr = strrchr(findData.cFileName, '.')) != NULL)
            {
                if( (_tcsicmp(extensionPtr, TEXT(".chm")) == 0) ||
                    (_tcsicmp(extensionPtr, TEXT(".chq")) == 0) ||
                    (_tcsicmp(extensionPtr, TEXT(".cnt")) == 0) ||
                    (_tcsicmp(extensionPtr, TEXT(".hlp")) == 0))
                {
                    dirIdentifier = 18;
                    sprintf(destDirectory, "MUI\\%04x", gBuildNumber);
                }
                else if (_tcsicmp(extensionPtr, TEXT(".mfl")) == 0)
                {
                    dirIdentifier = 11;
                    sprintf(destDirectory, "wbem\\MUI\\%04x", gBuildNumber);
                }
                else if (_tcsicmp(findData.cFileName, TEXT("hhctrlui.dll")) == 0)
                {
                    dirIdentifier = 11;
                    sprintf(destDirectory, "MUI\\%04x", gBuildNumber);
                }
                else
                {
                    dirIdentifier = 10;
                    sprintf(destDirectory, "MUI\\FALLBACK\\%04x", gBuildNumber);
                }
            }

            //
            //  Search for different destination name in the exception list.
            //
            if ((fileException = exceptionList.search(findData.cFileName)) != NULL )
            {
                //
                //  Verify it's the needed flavor
                //
                if (fileException->isFlavor(flavor))
                {
                    sprintf(destName, "%s", fileException->getDestFileName());
                }
                else
                {
                    //
                    //  Skip the file. Not need in this flavor.
                    //
                    continue;
                }
            }
            else
            {
                if (((extensionPtr = strrchr(findData.cFileName, '.')) != NULL) &&
                    ((*(extensionPtr-1) == 'P') || (*(extensionPtr-1) == 'p')))
                {
                    continue;
                }
                else if (flavor != FLV_CORE)
                {
                    continue;
                }
                else
                {
                    sprintf(destName, "%s", findData.cFileName);
                }
            }

            //
            //  Create a file 
            //
            if (file = new File(destDirectory,
                                destName,
                                muiFileSearchPath,
                                findData.cFileName,
                                dirIdentifier))
            {
                dirList->add(file);
            }
        }
        while (FindNextFile(fileHandle, &findData));

        FindClose(fileHandle);
    }

    //
    //  Add Specific MuiSetup files.
    //
    file = new File( TEXT("MUI"),
                     TEXT("Muisetup.exe"),
                     dirPath,
                     TEXT("Muisetup.exe"),
                     10);
    dirList->add(file);
    file = new File( TEXT("MUI"),
                     TEXT("Muisetup.hlp"),
                     dirPath,
                     TEXT("Muisetup.hlp"),
                     10);
    dirList->add(file);
    file = new File( TEXT("MUI"),
                     TEXT("Eula.txt"),
                     dirPath,
                     TEXT("Eula.txt"),
                     10);
    dirList->add(file);
    file = new File( TEXT("MUI"),
                     TEXT("Relnotes.txt"),
                     dirPath,
                     TEXT("Relnotes.txt"),
                     10);
    dirList->add(file);
    file = new File( TEXT("MUI"),
                     TEXT("Readme.txt"),
                     dirPath,
                     TEXT("Readme.txt"),
                     10);
    dirList->add(file);
    file = new File( TEXT("MUI"),
                     TEXT("Mui.inf"),
                     dirPath,
                     TEXT("Mui.inf"),
                     10);
    dirList->add(file);

    return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  ValidateLanguage()
//
//  Verify if the language given is valid and checks is the files are 
//  available.
//
///////////////////////////////////////////////////////////////////////////////
BOOL ValidateLanguage(LPSTR dirPath, LPSTR langName, DWORD binType)
{
    CHAR langPath[MAX_PATH] = {0};

    //
    //  Check if the binary type in order to determine the right path.
    //
    if (binType == BIN_32)
    {
        sprintf(langPath, "%s\\%s\\i386.uncomp", dirPath, langName);
    }
    else
    {
        sprintf(langPath, "%s\\%s\\ia64.uncomp", dirPath, langName);
    }

    return (DirectoryExist(langPath));
}


///////////////////////////////////////////////////////////////////////////////
//
//  DirectoryExist()
//
//  Verify if the given directory exists and contains files.
//
///////////////////////////////////////////////////////////////////////////////
BOOL DirectoryExist(LPSTR dirPath)
{
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    //  Sanity check.
    //
    if (dirPath == NULL)
    {
        return FALSE;
    }

    //
    //  See if the language group directory exists.
    //
    FindHandle = FindFirstFile(dirPath, &FindData);
    if (FindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(FindHandle);
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            //
            //  Return success.
            //
            return (TRUE);
        }
    }

    //
    //  Return failure.
    //
    if (!bSilence)
    {
        printf("ERR[%s]: No files found in the directory.\n", dirPath);
    }

    return (FALSE);
}


///////////////////////////////////////////////////////////////////////////////
//
//  ConvertLanguage()
//
//  Look into mui.inf file for the corresponding language identifier.
//
///////////////////////////////////////////////////////////////////////////////
WORD ConvertLanguage(LPSTR dirPath, LPSTR langName)
{
    HINF hFile;
    CHAR muiFilePath[MAX_PATH];
    CHAR muiLang[30];
    UINT lineCount, lineNum;
    INFCONTEXT context;
    DWORD langId = 0x00000000;

    //
    //  Create the path to open the mui.inf file
    //
    sprintf(muiFilePath, "%s\\mui.inf", dirPath);
    sprintf(muiLang, "%s.MUI", langName);

    //
    //  Open the MUI.INF file.
    //
    hFile = SetupOpenInfFile(muiFilePath, NULL, INF_STYLE_WIN4, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return (0x0000);
    }

    //
    //  Get the number of Language.
    //
    lineCount = (UINT)SetupGetLineCount(hFile, TEXT("Languages"));
    if (lineCount > 0)
    {
        //
        //  Go through all language of the list to find a .
        //
        CHAR langID[MAX_PATH];
        CHAR name[MAX_PATH];
        for (lineNum = 0; lineNum < lineCount; lineNum++)
        {
            if (SetupGetLineByIndex(hFile, TEXT("Languages"), lineNum, &context) &&
                SetupGetStringField(&context, 0, langID, MAX_PATH, NULL) &&
                SetupGetStringField(&context, 1, name, MAX_PATH, NULL))
            {
                if ( _tcsicmp(name, muiLang) == 0)
                {
                    langId = TransNum(langID);
                    SetupCloseInfFile(hFile);
                    return (WORD)(langId);
                }
            }
        }
    }

    //
    //  Close inf handle
    //
    SetupCloseInfFile(hFile);

    return (0x0000);

}


////////////////////////////////////////////////////////////////////////////
//
//  PrintFileList
//
//  Print a file list in XML format.
//
////////////////////////////////////////////////////////////////////////////
void PrintFileList(FileList* list, HANDLE hFile, BOOL compressed, BOOL bWinDir)
{
    if (compressed)
    {
        File* item;
        CHAR  itemDescription[4096];
        CHAR  spaces[30];
        int j;
    
        item = list->getFirst();
        while (item != NULL)
        {
            LPSTR refDirPtr = NULL;
            LPSTR dirPtr = NULL;
            CHAR dirName[MAX_PATH];
            CHAR dirName2[MAX_PATH];
            LPSTR dirPtr2 = NULL;
            LPSTR dirLvlPtr = NULL;
            INT dirLvlCnt = 0;
            BOOL componentInit = FALSE;
            BOOL directoryInit = FALSE;
            Uuid* uuid;
            File* toBeRemoved;
            CHAR fileObjectName[MAX_PATH];
            UINT matchCount; 


            //
            //  Check destination directory.
            //
            if (item->isWindowsDir() != bWinDir)
            {
                item = item->getNext();
                continue;
            }

            //
            //  Check is the destination is base dir
            //
            if (*(item->getDirectoryDestination()) == '\0')
            {
                //
                //  Component
                //
                uuid = new Uuid();
                for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                sprintf( itemDescription, "%s<Component Id='%s'>Content%i", spaces, uuid->getString(), dwComponentCounter);
                delete uuid;
                PrintLine(hFile, itemDescription);

                //
                //  File
                //
                for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                removeSpace(item->getName(), fileObjectName);
                sprintf( itemDescription,
                         "%s<File Name=\"%s\" LongName=\"%s\" Compressed='yes' src=\"%s\\%s\">%s.%i</File>",
                         spaces,
                         item->getName(),
                         item->getName(),
                         item->getSrcDir(),
                         item->getSrcName(),
                         fileObjectName,
                         dwComponentCounter);
                PrintLine(hFile, itemDescription);

                //
                // </Component>
                //
                for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                sprintf( itemDescription, "%s</Component>", spaces);
                PrintLine(hFile, itemDescription);
                dwComponentCounter++;

                toBeRemoved = item;
                item = item->getNext();
                list->remove(toBeRemoved);
                continue;
            }

            //
            // Print directory
            //
            sprintf(dirName, "%s",item->getDirectoryDestination());
            dirPtr = dirName;
            refDirPtr = dirPtr;
            while (dirPtr != NULL)
            {
                dirLvlPtr = strchr(dirPtr, '\\');
                if (dirLvlPtr != NULL)
                {
                    *dirLvlPtr = '\0';
                    for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    sprintf( itemDescription, "%s<Directory Name=\"%s\">%s%i", spaces, dirPtr, dirPtr, dwDirectoryCounter);
                    dwDirectoryCounter++;
                    PrintLine(hFile, itemDescription);
                    dirPtr = dirLvlPtr + 1;
                    dirLvlCnt++;

                    //
                    // Print all file under this specific directory
                    //
                    sprintf( dirName2, "%s", item->getDirectoryDestination());
                    dirName2[dirLvlPtr-refDirPtr] = '\0';
                    File* sameLvlItem = NULL;
                    matchCount = 0;
                    while((sameLvlItem = list->search(item, dirName2)) != NULL)
                    {
/*                        //
                        //  Directory
                        //
                        if (!directoryInit)
                        {
                            for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                            sprintf( itemDescription, "%s<Directory Name=\"%s\">%s%i", spaces, dirPtr, dirPtr, dwDirectoryCounter);
                            dwDirectoryCounter++;
                            PrintLine(hFile, itemDescription);
                            dirLvlCnt++;
                            directoryInit = TRUE;
                        }
*/
                        //
                        //  Component
                        //
                        if (!componentInit)
                        {
                            uuid = new Uuid();
                            for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                            sprintf( itemDescription, "%s<Component Id='%s'>Content%i", spaces, uuid->getString(), dwComponentCounter);
                            delete uuid;
                            PrintLine(hFile, itemDescription);
                            dwComponentCounter++;
                            componentInit = TRUE;
                        }

                        //
                        //  File
                        //
                        matchCount++;
                        for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        removeSpace(sameLvlItem->getName(), fileObjectName);
                        sprintf( itemDescription,
                                 "%s<File Name=\"%s\" LongName=\"%s\" Compressed='yes' src=\"%s\\%s\">%s.%i</File>",
                                 spaces,
                                 sameLvlItem->getName(),
                                 sameLvlItem->getName(),
                                 sameLvlItem->getSrcDir(),
                                 sameLvlItem->getSrcName(),
                                 fileObjectName,
                                 dwComponentCounter);
                        PrintLine(hFile, itemDescription);

                        list->remove(sameLvlItem);
                    }

                    if (matchCount)
                    {
                        //
                        //  File
                        //
                        for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        removeSpace(item->getName(), fileObjectName);
                        sprintf( itemDescription,
                                 "%s<File Name=\"%s\" LongName=\"%s\" Compressed='yes' src=\"%s\\%s\">%s.%i</File>",
                                 spaces,
                                 item->getName(),
                                 item->getName(),
                                 item->getSrcDir(),
                                 item->getSrcName(),
                                 fileObjectName,
                                 dwComponentCounter);
                        PrintLine(hFile, itemDescription);
                        dirPtr = NULL;
                    }

                    //
                    //  Close component
                    //
                    if (componentInit)
                    {
                        for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        sprintf( itemDescription, "%s</Component>", spaces);
                        PrintLine(hFile, itemDescription);
                        componentInit = FALSE;
                    }

                    //
                    //  Close directory
                    //
                    if (directoryInit)
                    {
                        dirLvlCnt--;
                        for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        sprintf( itemDescription, "%s</Directory>", spaces);
                        PrintLine(hFile, itemDescription);
                        directoryInit = FALSE;
                    }
                }
                else
                {
                    if (!directoryInit)
                    {
                        for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        sprintf( itemDescription, "%s<Directory Name=\"%s\">%s%i", spaces, dirPtr, dirPtr, dwDirectoryCounter);
                        dwDirectoryCounter++;
                        PrintLine(hFile, itemDescription);
                        dirLvlCnt++;
                        directoryInit = TRUE;
                    }

                    //
                    //  Component
                    //
                    if (!componentInit)
                    {
                        uuid = new Uuid();
                        for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        sprintf( itemDescription, "%s<Component Id='%s'>Content%i", spaces, uuid->getString(), dwComponentCounter);
                        delete uuid;
                        PrintLine(hFile, itemDescription);
                        componentInit = TRUE;
                    }

                    //
                    // Print all file under this specific directory
                    //
                    File* sameLvlItem;
                    while((sameLvlItem = list->search(item, item->getDirectoryDestination())) != NULL)
                    {
                        //
                        //  File
                        //
                        for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        removeSpace(sameLvlItem->getName(), fileObjectName);
                        sprintf( itemDescription,
                                 "%s<File Name=\"%s\" LongName=\"%s\" Compressed='yes' src=\"%s\\%s\">%s.%i</File>",
                                 spaces,
                                 sameLvlItem->getName(),
                                 sameLvlItem->getName(),
                                 sameLvlItem->getSrcDir(),
                                 sameLvlItem->getSrcName(),
                                 fileObjectName,
                                 dwComponentCounter);
                        PrintLine(hFile, itemDescription);

                        list->remove(sameLvlItem);
                    }

                    //
                    //  File
                    //
                    for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    removeSpace(item->getName(), fileObjectName);
                    sprintf( itemDescription,
                             "%s<File Name=\"%s\" LongName=\"%s\" Compressed='yes' src=\"%s\\%s\">%s.%i</File>",
                             spaces,
                             item->getName(),
                             item->getName(),
                             item->getSrcDir(),
                             item->getSrcName(),
                             fileObjectName,
                             dwComponentCounter);
                    PrintLine(hFile, itemDescription);
                    dwComponentCounter++;
                    dirPtr = NULL;

                    //
                    //  Close component
                    //
                    if (componentInit)
                    {
                        for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        sprintf( itemDescription, "%s</Component>", spaces);
                        PrintLine(hFile, itemDescription);
                        componentInit = FALSE;
                    }

                    //
                    //  Close directory
                    //
                    if (directoryInit)
                    {
                        dirLvlCnt--;
                        for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        sprintf( itemDescription, "%s</Directory>", spaces);
                        PrintLine(hFile, itemDescription);
                        directoryInit = FALSE;
                    }
                }
            }

            for (int i = dirLvlCnt; i > 0; i--)
            {
                spaces[i] = '\0';
                sprintf( itemDescription, "%s</Directory>", spaces);
                PrintLine(hFile, itemDescription);
            }

            if (list->getFileNumber() > 1)
            {
                if (item->getNext() != NULL)
                {
                    item = item->getNext();
                    list->remove(item->getPrevious());
                }
                else
                {
                    list->remove(item);
                    item = NULL;
                }
            }
            else
            {
                list->remove(item);
                item = NULL;
            }
        }
    }
    else
    {
        File* item;
        CHAR  itemDescription[4096];
        CHAR  spaces[30];
        int j;
    
        item = list->getFirst();
        while (item != NULL)
        {
            LPSTR dirPtr = NULL;
            LPSTR dirLvlPtr = NULL;
            INT dirLvlCnt = 0;

            //
            // Print directory
            //
            dirPtr = item->getDirectoryDestination();
            while (dirPtr != NULL)
            {
                dirLvlPtr = strchr(dirPtr, '\\');
                if (dirLvlPtr != NULL)
                {
                    *dirLvlPtr = '\0';
                    for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    sprintf( itemDescription, "%s<Directory Name=\"%s\">%s%i", spaces, dirPtr, dirPtr, dwDirectoryCounter);
                    dwDirectoryCounter++;
                    PrintLine(hFile, itemDescription);
                    dirPtr = dirLvlPtr + 1;
                    dirLvlCnt++;
                }
                else
                {
                    Uuid* uuid = new Uuid();

                    for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    sprintf( itemDescription, "%s<Directory Name=\"%s\">%s%i", spaces, dirPtr, dirPtr, dwDirectoryCounter);
                    dwDirectoryCounter++;
                    PrintLine(hFile, itemDescription);
                    dirLvlCnt++;

                    //
                    //  Component
                    //
                    for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    sprintf( itemDescription, "%s<Component Id='%s'>Content%i", spaces, uuid->getString(), dwComponentCounter);
                    delete uuid;
                    PrintLine(hFile, itemDescription);

                    //
                    //  File
                    //
                    for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    sprintf( itemDescription,
                             "%s<File Name=\"%s\" LongName=\"%s\" Compressed='yes' src=\"%s\\%s\">%s.%i</File>",
                             spaces,
                             item->getName(),
                             item->getName(),
                             item->getSrcDir(),
                             item->getSrcName(),
                             item->getName(),
                             dwComponentCounter);
                    PrintLine(hFile, itemDescription);
                    dwComponentCounter++;
                    dirPtr = NULL;
                }
            }

            for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
            sprintf( itemDescription, "%s</Component>", spaces);
            PrintLine(hFile, itemDescription);
            for (int i = dirLvlCnt; i > 0; i--)
            {
                spaces[i] = '\0';
                sprintf( itemDescription, "%s</Directory>", spaces);
                PrintLine(hFile, itemDescription);
            }

            item = item->getNext();
        }
    }
/****************** DEBUG ******************
    File* item;
    CHAR  itemDescription[4096];

    item = list->getFirst();
    while (item != NULL)
    {
        //
        //  Item description
        //
        sprintf(itemDescription,
                "  Source: %s\\%s",
                item->getSrcDir(),
                item->getSrcName());
        PrintLine(hFile, itemDescription);
        sprintf(itemDescription,
                "  Destination: %s\\%s",
                item->getDirectoryDestination(),
                item->getName());
        PrintLine(hFile, itemDescription);
        PrintLine(hFile, "");

        item = item->getNext();
    }
****************** DEBUG ******************/
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintLine
//
//  Add a line at the end of the file.
//
////////////////////////////////////////////////////////////////////////////
BOOL PrintLine(HANDLE hFile, LPCSTR lpLine)
{
    DWORD dwBytesWritten;

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile( hFile,
               lpLine,
               _tcslen(lpLine) * sizeof(TCHAR),
               &dwBytesWritten,
               NULL );

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile( hFile,
               TEXT("\r\n"),
               _tcslen(TEXT("\r\n")) * sizeof(TCHAR),
               &dwBytesWritten,
               NULL );

    return (TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
//  CreateOutputFile()
//
//  Create the file that would received the package file contents.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE CreateOutputFile(LPSTR filename)
{
    SECURITY_ATTRIBUTES SecurityAttributes;

    //
    //  Sanity check.
    //
    if (filename == NULL)
    {
        return INVALID_HANDLE_VALUE;
    }

    //
    //  Create a security descriptor the output file.
    //
    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.bInheritHandle = FALSE;

    //
    //  Create the file.
    //
    return CreateFile( filename,
                       GENERIC_WRITE,
                       0,
                       &SecurityAttributes,
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );
}


////////////////////////////////////////////////////////////////////////////
//
//  removeSpace
//
//  Remove all space from a string.
//
////////////////////////////////////////////////////////////////////////////
VOID removeSpace(LPSTR src, LPSTR dest)
{
    LPSTR strSrcPtr = src;
    LPSTR strDestPtr = dest;

    while (*strSrcPtr != '\0')
    {
        if (*strSrcPtr != ' ')
        {
            *strDestPtr = *strSrcPtr;
            strDestPtr++;
        }
        strSrcPtr++;
    }
    *strDestPtr = '\0';
}


////////////////////////////////////////////////////////////////////////////
//
//  TransNum
//
//  Converts a number string to a dword value (in hex).
//
////////////////////////////////////////////////////////////////////////////
DWORD TransNum(LPTSTR lpsz)
{
    DWORD dw = 0L;
    TCHAR c;

    while (*lpsz)
    {
        c = *lpsz++;

        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return (dw);
}


///////////////////////////////////////////////////////////////////////////////
//
//  Usage
//
//  Print the fonction usage.
//
///////////////////////////////////////////////////////////////////////////////
void Usage()
{
    printf("Create filecontents_CORE.wxm, filecontents_PRO.wxm and filecontents_SRV.wxm\n");
    printf("Usage: infparser /b:[32|64] /l:<lang> /f:[p|s|a|d] /s:<dir> /o:<file> /v\n");
    printf("   where\n");
    printf("     /b means the binary.\n");
    printf("         32: i386\n");
    printf("         64: ia64\n");
    printf("     /l means the language flag.\n");
    printf("         <lang>: is the target language\n");
    printf("     /f means the flavor.\n");
    printf("         p: Professional\n");
    printf("         s: Server\n");
    printf("         a: Advanced Server\n");
    printf("         d: Data Center\n");
    printf("     /s means the location of the binairy data.\n");
    printf("         <dir>: Fully qualified path\n");
    printf("     /o means the xml file contents of specific flavor.\n");
    printf("         <file>: Fully qualified path\n");
    printf("     /v means the verbose mode [optional].\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\infparser\uuid.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    Uuid.h
//
//  Abstract:
//
//    This Uuid contains the Uuid object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __UUID_H_
#define __UUID_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Uuids.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class Uuid
{
public:
    Uuid()
    {
        RPC_STATUS     Result;
        unsigned char* UuidPtr;

        //
        //  Create the UUID.
        //
        Result = UuidCreate(&m_Uuid);
        if ((Result == RPC_S_UUID_LOCAL_ONLY) ||
            (Result == RPC_S_OK))
        {
            //
            //  Convert UUID into a string
            //
            if ((Result = UuidToString(&m_Uuid, &UuidPtr)) == RPC_S_OK)
            {
                //
                //  Copy string
                //
                sprintf(m_UuidString, "%s", UuidPtr);

                //
                //  Free the RpcString
                //
                RpcStringFree(&UuidPtr);

                //
                //  Upper case the string
                //
                _strupr(m_UuidString);
            }
        }
    };

    LPSTR getString() { return(m_UuidString); };
    UUID getId() { return(m_Uuid); };
    Uuid* getNext() { return (m_Next); };
    Uuid* getPrevious() { return (m_Previous); };
    void setNext(Uuid *next) { m_Next = next; };
    void setPrevious(Uuid *previous) { m_Previous = previous; };

private:
    UUID  m_Uuid;
    CHAR  m_UuidString[MAX_PATH];
    Uuid *m_Next;
    Uuid *m_Previous;
};

#endif //__UUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\ritables.inc ===
'<script language='VBScript'>
' ritables.inc - Redist information table definitions
'
'  2001/05/04 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Database table schema
Dim   RedistInfoTable(4)         : RedistInfoTable(0)                      = "`redist_Info`"
Const RedistInfo_DummyPk = 1 : RedistInfoTable(RedistInfo_DummyPk)      = "`DummyPk` CHAR(15) NOT NULL PRIMARY KEY"  ' dummy primary key to make Windows Installer happy
Const RedistInfo_Description = 2 : RedistInfoTable(RedistInfo_Description)      = "`Description` CHAR(0) LOCALIZABLE"
Const RedistInfo_Distribution = 3 : RedistInfoTable(RedistInfo_Distribution)      = "`Distribution` SHORT"   ' 0 == internal, 1 == external
Const RedistInfo_Type = 4 : RedistInfoTable(RedistInfo_Type)      = "`Type` SHORT"   ' 0 == debug, 1 == ship

'Dim   RedistKeywordsTable(1)         : RedistKeywordsTable(0)                      = "`redist_Keywords`"
'Const RedistKeywords_Keyword = 1 : RedistKeywordsTable(RedistKeywords_Keyword)      = "`Keyword` CHAR(255) NOT NULL LOCALIZABLE PRIMARY KEY"

Dim   RedistContactsTable(1)         : RedistContactsTable(0)                      = "`redist_Contacts`"
Const RedistContacts_Contact = 1 : RedistContactsTable(RedistContacts_Contact)      = "`Contact` CHAR(255) NOT NULL PRIMARY KEY"

Dim   RedistPermissionsTable(2)         : RedistPermissionsTable(0)                      = "`redist_Permissions`"
Const RedistPermissions_Domain = 1 : RedistPermissionsTable(RedistPermissions_Domain)      = "`Domain` CHAR(255) NOT NULL PRIMARY KEY"
Const RedistPermissions_Alias = 2 : RedistPermissionsTable(RedistPermissions_Alias)      = "`Alias` CHAR(255) NOT NULL PRIMARY KEY"

Dim   RedistOsTable(6)         : RedistOsTable(0)                      = "`redist_Os`"
Const RedistOs_DummyPk = 1 : RedistOsTable(RedistOs_DummyPk)      = "`DummyPk` SHORT NOT NULL PRIMARY KEY"  ' dummy primary key to make Windows Installer happy
Const RedistOs_Type = 2 : RedistOsTable(RedistOs_Type)      = "`Type` CHAR(16) NOT NULL"  ' "Windows9x", "Windows32", "Windows64"
Const RedistOs_Flavor = 3 : RedistOsTable(RedistOs_Flavor)      = "`Flavor` CHAR(20)"   ' "workstation", "server","terminalserver","professional",etc.
Const RedistOs_Language = 4 : RedistOsTable(RedistOs_Language)      = "`Language` CHAR(255)"
Const RedistOs_MinVersion = 5 : RedistOsTable(RedistOs_MinVersion)      = "`MinVersion` CHAR(20)"
Const RedistOs_MaxVersion = 6 : RedistOsTable(RedistOs_MaxVersion)      = "`MaxVersion` CHAR(20)"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\vbsconst.inc ===
'<script language='VBScript'>
' wiconsts.inc - VBScript constants
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'

' FileSystemObject constants
Const OverwriteIfExist = -1
Const OpenAsASCII      =  0 
Const ForReading       =  1
Const FailIfNotExist   =  0
Const OpenAsDefault    = -2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\widir.inc ===
'<script language='VBScript'>
' wiconsts.inc - VBScript constants
'
'  2000/06/12 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    ResolveFileSourcePath
'    ResolveDirectorySourcePath
'
'    GetDefaultDir

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResolveFileSourcePath
Function ResolveFileSourcePath(db, sKey, fLong)
   Dim sDir, sFile
   Dim vw, rec

   Set vw = db.OpenView("SELECT `Directory_`, `FileName` FROM `Component`, `File` WHERE `Component`.`Component`=`File`.`Component_` AND `File`.`File`='" & sKey & "'")
   vw.Execute
   Set rec = vw.Fetch
   If rec Is Nothing Then
      ResolveFileSourcePath = Empty
   Else
      sDir = ResolveDirectorySourcePath(db, rec.StringData(1), fLong)
      sFile = GetDefaultDir(rec.StringData(2), True, fLong)

      ResolveFileSourcePath = sDir & sFile
   End If
End Function   ' ResolveFileSourcePath


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResolveFileTargetPath
Function ResolveFileTargetPath(db, sKey, fLong)
   Dim sDir, sFile
   Dim vw, rec

   Set vw = db.OpenView("SELECT `Directory_`, `FileName` FROM `Component`, `File` WHERE `Component`.`Component`=`File`.`Component_` AND `File`.`File`='" & sKey & "'")
   vw.Execute
   Set rec = vw.Fetch
   If rec Is Nothing Then
      ResolveFileTargetPath = Empty
   Else
      sDir = ResolveDirectoryTargetPath(db, rec.StringData(1), fLong)
      sFile = GetDefaultDir(rec.StringData(2), False, fLong)

      ResolveFileTargetPath = sDir & sFile
   End If
End Function   ' ResolveFileTargetPath


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResolveDirectorySourcePath
Function ResolveDirectorySourcePath(db, sKey, fLong)
   Dim vw, rec

   Set vw = db.OpenView("SELECT Directory_Parent, DefaultDir FROM Directory WHERE Directory=?")
   Set rec = installer.CreateRecord(1)
   rec.StringData(1) = sKey
   ResolveDirectorySourcePath = widir_ResolveDirectory(vw, rec, True, fLong)
End Function   ' ResolveDirectorySourcePath


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResolveDirectoryTargetPath
Function ResolveDirectoryTargetPath(db, sKey, fLong)
   Dim vw, rec

   Set vw = db.OpenView("SELECT Directory_Parent, DefaultDir FROM Directory WHERE Directory=?")
   Set rec = installer.CreateRecord(1)
   rec.StringData(1) = sKey
   ResolveDirectoryTargetPath = widir_ResolveDirectory(vw, rec, False, fLong)
End Function   ' ResolveDirectoryTargetPath


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' widir_ResolveDirectory
Function widir_ResolveDirectory(vw, rec, fSource, fLong)
   Dim sDir, sPath, sTemp

   sPath = Empty
   Do
      sDir = rec.StringData(1)

      vw.Execute rec
      Set rec = vw.Fetch

      If rec Is Nothing Then Exit Do

      If Not fSource Then
         Select Case rec.StringData(1)
         Case "ProgramFilesFolder" : sPath = "PFILES\" & sPath : Exit Do
         Case "WindowsFolder" : sPath = "WIN\" & sPath : Exit Do
         Case "SystemFolder" : sPath = "SYS\" & sPath : Exit Do
         Case "System16Folder" : sPath = "Sys16\" & sPath : Exit Do
         End Select
      End If

      sTemp = GetDefaultDir(rec.StringData(2), fSource, fLong)
      If 0 <  Len(sTemp) And "." <> sTemp Then sPath = sTemp & "\" & sPath
   Loop While (0 < Len(rec.StringData(1)))

   widir_ResolveDirectory = sPath
End Function   ' widir_ResolveDirectory


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' GetDefaultDir
Function GetDefaultDir(ByVal s, fSource, fLong)
   Dim a
   a = Split(s, ":")
   If fSource And 1 = UBound(a) Then s = Split(a(1), "|") Else s = Split(a(0), "|")
   If fLong And 1 = UBound(s) Then GetDefaultDir = s(1) Else GetDefaultDir = s(0)
End Function   ' GetDefaultDir
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muibld\muibld.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <io.h>
#include <md5.h>
#include "muibld.h"


typedef struct 
{
    BOOL bContainResource;
    MD5_CTX ChecksumContext;
} CHECKSUM_ENUM_DATA;

void ExitFromOutOfMemory();
void DumpResourceDirectory
(
    PIMAGE_RESOURCE_DIRECTORY resDir,
    DWORD resourceBase,
    DWORD level,
    DWORD resourceType
);

int g_bVerbose = FALSE;     // Global flag to contorl verbose output.
WORD wChecksumLangId; 

// The predefined resource types
char *SzResourceTypes[] = {
"???_0", "CURSOR", "BITMAP", "ICON", "MENU", "DIALOG", "STRING", "FONTDIR",
"FONT", "ACCELERATORS", "RCDATA", "MESSAGETABLE", "GROUP_CURSOR",
"???_13", "GROUP_ICON", "???_15", "VERSION"
};

void PrintError()
{
    LPTSTR lpMsgBuf;
    
    if (FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
    ))
    {
        printf("GetLastError():\n   %s", lpMsgBuf);
        LocalFree( lpMsgBuf );            
    }
    return;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  ChecksumEnumNamesFunc
//
//  The callback funciton for enumerating the resource names in the specified module and
//  type.
//  The side effect is that MD5 checksum context (contained in CHECKSUM_ENUM_DATA
//  pointed by lParam) will be updated.
//
//  Return:
//      Always return TRUE so that we can finish all resource enumeration.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK ChecksumEnumNamesFunc(HMODULE hModule, LPCTSTR lpType, LPTSTR lpName, LONG_PTR lParam){

    HRSRC hRsrc;
    HGLOBAL hRes;
    const unsigned char* pv;
    LONG ResSize=0L;
    WORD IdFlag=0xFFFF;

    DWORD dwHeaderSize=0L;
    CHECKSUM_ENUM_DATA* pChecksumEnumData = (CHECKSUM_ENUM_DATA*)lParam;   

    if(!(hRsrc=FindResourceEx(hModule, lpType, lpName, wChecksumLangId ? wChecksumLangId : 0x409)))
    {
        //
        // If US English resource is not found for the specified type and name, we 
        // will continue the resource enumeration.
        //
        return (TRUE);
    }
    pChecksumEnumData->bContainResource = TRUE;

    if (!(ResSize=SizeofResource(hModule, hRsrc)))
    {
        printf("WARNING: Can not get resource size when generating resource checksum.\n");
        return (TRUE);
    }

    if (!(hRes=LoadResource(hModule, hRsrc)))
    {
        printf("WARNING: Can not load resource when generating resource checksum.\n");
        return (TRUE);
    }
    pv=(unsigned char*)LockResource(hRes);

    //
    // Update MD5 context using the binary data of this particular resource.
    //
    MD5Update(&(pChecksumEnumData->ChecksumContext), pv, ResSize);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  ChecksumEnumTypesFunc
//
//  The callback function for enumerating the resource types in the specified module.
//  This function will call EnumResourceNames() to enumerate all resource names of
//  the specified resource type.
//
//  Return:
//      TRUE if EnumResourceName() succeeds.  Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK ChecksumEnumTypesFunc(HMODULE hModule, LPSTR lpType, LONG_PTR lParam)
{
    CHECKSUM_ENUM_DATA* pChecksumEnumData = (CHECKSUM_ENUM_DATA*)lParam;
    //
    // Skip the version resource type, so that version is not included in the resource checksum.
    //
    if (lpType == RT_VERSION)
    {
        return (TRUE);
    }    
    
    if(!EnumResourceNames(hModule, (LPCSTR)lpType, ChecksumEnumNamesFunc, (LONG_PTR)lParam))
    {
        return (FALSE);
    }
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  GenerateResourceChecksum
//
//  Generate the resource checksum for the US English resource in the specified file.
//
//  Parameters:
//      pszSourceFileName   The file used to generate resource checksum.
//      pResourceChecksum   Pointer to a 16 bytes (128 bits) buffer for storing
//                          the calcuated MD5 checksum.
//  Return:
//      TURE if resource checksum is generated from the given file.  Otherwise FALSE.
//  
//  The following situation may return FALSE:
//      * The specified file does not contain resource.
//      * If the specified file contains resource, but the resource is not US English.
//      * The specified file only contains US English version resource.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL GenerateResourceChecksum(LPCSTR pszSourceFileName, unsigned char* pResourceChecksum)
{
    HMODULE hModule;
    ULONG i;

    DWORD dwResultLen;
    BOOL  bRet = FALSE;

    //
    // The stucture to be passed into the resource enumeration functions.
    //
    CHECKSUM_ENUM_DATA checksumEnumData;

    checksumEnumData.bContainResource = FALSE;

    //
    // Start MD5 checksum calculation by initializing MD5 context.
    //
    MD5Init(&(checksumEnumData.ChecksumContext));
    
    if (g_bVerbose)
    {
        printf("Generate resource checksum for [%s]\n", pszSourceFileName);
    }
    
    if(!(hModule = LoadLibraryEx(pszSourceFileName, NULL, DONT_RESOLVE_DLL_REFERENCES|LOAD_LIBRARY_AS_DATAFILE)))
    {
        if (g_bVerbose)
        {
            printf("\nERROR: Error in opening resource checksum module [%s]\n", pszSourceFileName);
        }
        PrintError();
        goto GR_EXIT;
    }

    if (g_bVerbose)
    {
        printf("\nLoad checksum file: %s\n", pszSourceFileName);
    }


    //
    // we check language id of Version resource if it has wChecksumLangId when wChecksumLangId has value
    //
    
    if (wChecksumLangId && wChecksumLangId != 0x409)
    {
        if(!FindResourceEx(hModule, MAKEINTRESOURCE(16), MAKEINTRESOURCE(1), wChecksumLangId))
        {   //
            // It does not has specifed language id in version resource, we supposed that this binary does not
            // have any language id specified at all, so we set it as 0 in order to use English instead.
            //
            wChecksumLangId = 0;
        }
    }

    //
    //  Enumerate all resources in the specified module.
    //  During the enumeration, the MD5 context will be updated.
    //
    if (!EnumResourceTypes(hModule, ChecksumEnumTypesFunc, (LONG_PTR)&checksumEnumData))
    {
        if (g_bVerbose)
        {
            printf("\nWARNING: Unable to generate resource checksum from resource checksum module [%s]\n", pszSourceFileName);
        }
        goto GR_EXIT;
    }    

    if (checksumEnumData.bContainResource)
    {
        //
        // If the enumeration succeeds, and the specified file contains US English
        // resource, get the MD5 checksum from the accumulated MD5 context.
        //
        MD5Final(&checksumEnumData.ChecksumContext);
        memcpy(pResourceChecksum, checksumEnumData.ChecksumContext.digest, 16);

        if (g_bVerbose)
        {
            printf("Generated checksum: [");
            for (i = 0; i < MD5_CHECKSUM_SIZE; i++)
            {
                printf("%02x ", pResourceChecksum[i]);
            }
            printf("]\n");    
        }
        bRet = TRUE;
    }

GR_EXIT:
    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return (bRet);
}

int __cdecl main(int argc, char *argv[]){

    struct CommandLineInfo Info;
    HMODULE hModule=0;
    char pszBuffer[400];
    DWORD dwError;
    DWORD dwOffset;
    BOOL bEnumTypesReturn;    

    if(argc==1){
        Usage();
        return 0;
    }

    g_bVerbose=FALSE;
    wChecksumLangId=0;

    Info.pszIncResType=0;
    Info.wLanguage=0;
    Info.hFile=0;
    Info.pszSource=0;
    Info.pszTarget=0;
    Info.bContainsOnlyVersion=TRUE;
    Info.bContainsResources=FALSE;
    Info.bLanguageFound=FALSE;
    Info.bIncDependent=FALSE;
    Info.bIncludeFlag=FALSE;  
    

    Info.pszChecksumFile=NULL;
    Info.bIsResChecksumGenerated = FALSE;

    if(ParseCommandLine(argc, argv, &Info)==FALSE){

        //...If help was the only command line argument, exit
        if(strcmp(argv[1], "-h")==0 && argc==2)
            return 0;

        dwError=ERROR_TOO_FEW_ARGUMENTS;
        dwOffset=0;
        goto Error_Exit;
    }

    //...Open resource module
    if(Info.pszSource){
        if(!(hModule = LoadLibraryEx (Info.pszSource, NULL, DONT_RESOLVE_DLL_REFERENCES|LOAD_LIBRARY_AS_DATAFILE)))
        {
            PrintError();
            if (g_bVerbose)
            {
                printf("\nERROR: Error in opening source module [%s]\n", Info.pszSource);
            }            
            dwError=GetLastError();
            dwOffset=ERROR_OFFSET;
            goto Error_Exit;
        }
    }
    else {
        Usage();
        dwError=ERROR_NO_SOURCE;
        dwOffset=0;
        goto Error_Exit;
    }

    if (Info.pszChecksumFile)
    {
        if (GenerateResourceChecksum(Info.pszChecksumFile, Info.pResourceChecksum))
        {
            Info.bIsResChecksumGenerated = TRUE;
        }        
    }
    
    //...Create target file
    if(Info.pszTarget){
        if((Info.hFile=CreateFile(Info.pszTarget, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
        {
            if (g_bVerbose)
            {
                printf("\nERROR: Error in creating target module [%s]\n", Info.pszSource);
            }
            dwError=GetLastError();
            dwOffset=ERROR_OFFSET;
            goto Error_Exit;
        }
    }
    else{
        if (g_bVerbose)
        {
            printf("\nERROR: There is no target file name.");
        }
        Usage();
        dwError=ERROR_NO_TARGET;
        dwOffset=0;
        goto Error_Exit;
    }

    if(Info.wLanguage==0){
        if (g_bVerbose)
        {
            printf("\nERROR: Can not find specified language name in the source module.");
        }
        Usage();
        dwError=ERROR_NO_LANGUAGE_SPECIFIED;
        dwOffset=0;
        goto Error_Exit;
    }

    bInsertHeader(Info.hFile);

    bEnumTypesReturn=EnumResourceTypes(hModule, EnumTypesFunc, (LONG_PTR)&Info);

    //...Check for muibld errors
    if(!Info.bContainsResources){
        if (g_bVerbose)
        {
            printf("\nERROR: There is no resource in the source module.");
        }
        dwError=ERROR_NO_RESOURCES;
        dwOffset=0;
        goto Error_Exit;
    }

    if(!Info.bLanguageFound){
        if (g_bVerbose)
        {
            printf("\nERROR: There is no specified language in the source module.");
        }
        dwError=ERROR_LANGUAGE_NOT_IN_SOURCE;
        dwOffset=0;
        goto Error_Exit;
    }

    if(Info.bContainsOnlyVersion){
        if (g_bVerbose)
        {
            printf("\nERROR: The source module only contains version information.");
        }
        dwError=ERROR_ONLY_VERSION_STAMP;
        dwOffset=0;
        goto Error_Exit;
    }

    //...Check for system errors in EnumResourceTypes
    if(bEnumTypesReturn);
    else{
        
        dwError=GetLastError();
        dwOffset=ERROR_OFFSET;
        goto Error_Exit;
    }

    //...Check to see if extra resources were included
    if(Info.bIncDependent){
        CleanUp(&Info, hModule, FALSE);
        return DEPENDENT_RESOURCE_REMOVED;
    }
    CleanUp(&Info, hModule, FALSE);

    if (g_bVerbose)
    {
        printf("Resource file [%s] has been generated successfully.\n", Info.pszTarget);
    }
    return 0;

    Error_Exit:
        CleanUp(&Info, hModule, TRUE);
        if(dwOffset==ERROR_OFFSET){
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0, (LPTSTR)&pszBuffer, 399, NULL);
            fprintf(stderr, "\n%s\n", pszBuffer );
        }

        return dwError+dwOffset;
}



BOOL ParseCommandLine(int argc, char **argv, pCommandLineInfo pInfo){
    int iCount=1, chOpt=0, iLast=argc;
    int i;
    int iNumInc;
    BOOL bInc1=FALSE, bInc3=FALSE, bInc12=FALSE, bInc14=FALSE;

    iLast=argc;

    //...Must have at least: muibld -l langid source
    if(argc>3){

        //...Determine the target and source files.
        if(CreateFile(argv[argc-2], 0, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)!=INVALID_HANDLE_VALUE){

            pInfo->pszSource=LocalAlloc(0, (strlen(argv[argc-2])+1) * sizeof(char));
            if (pInfo->pszSource == NULL)
            {
                ExitFromOutOfMemory();
            }
            strcpy(pInfo->pszSource, argv[argc-2]);

            pInfo->pszTarget=LocalAlloc(0, (strlen(argv[argc-1])+1) * sizeof(char));
            if (pInfo->pszTarget == NULL)
            {
                ExitFromOutOfMemory();
            }
            strcpy(pInfo->pszTarget, argv[argc-1]);

            iLast=argc-2;
        }

        else {
            pInfo->pszSource=LocalAlloc(0, (strlen(argv[argc-1])+1) * sizeof(char));
            if (pInfo->pszSource == NULL)
            {
                ExitFromOutOfMemory();
            }
            strcpy(pInfo->pszSource, argv[argc-1]);

            pInfo->pszTarget=LocalAlloc(0, (strlen(argv[argc-1]) + strlen(ADDED_EXT) + 1) * sizeof(char));
            if (pInfo->pszTarget == NULL)
            {
                ExitFromOutOfMemory();
            }
            strcpy(pInfo->pszTarget, strcat(argv[argc-1], ADDED_EXT));

            iLast=argc-1;
        }
    }




    //...Read in flags and arguments
    while ( (iCount < iLast)  && (*argv[iCount] == '-' || *argv[iCount] == '/')){

        switch( ( chOpt = *CharLowerA( &argv[iCount][1]))) {

            case '?':
            case 'h':

                printf("\n\n");
                printf("MUIBLD [-h|?] [-v] [-c checksum_file] -l langid [-i resource_type] source_filename\n");
                printf("    [target_filename]\n\n");
                printf("-h(elp) or -?:      Show help screen.\n\n");

                printf("-i(nclude)      Use to include certain resource types,\n");
                printf("resource_type:      e.g. -i 2 to include bitmaps.\n");
                printf("            Multiple inclusion is possible. If this\n");
                printf("            flag is not used, all types are included\n");
                printf("            Standard resource types must be specified\n");
                printf("            by number. See below for list.\n");
                printf("            Types 1 and 12 are always included in pairs,\n");
                printf("            even if only one is specified. Types 3 and 14\n");
                printf("            are always included in pairs, too.\n\n");

                printf("-v(erbose):     Display source filename and target filename.\n\n");

                printf("-l(anguage) langid: Extract only resource in this language.\n");
                printf("            The language resource must be specified. The value is in decimal.\n\n");

                printf("source_filename:    The localized source file (no wildcard support)\n\n");

                printf("target_filename:    Optional. If no target_filename is specified,\n");
                printf("            a second extension.RES is added to the\n");
                printf("            source_filename.\n\n");

                printf("Standard Resource Types: CURSOR(1) BITMAP(2) ICON(3) MENU(4) DIALOG(5)\n");
                printf("STRING(6) FONTDIR(7) FONT(8) ACCELERATORS(9) RCDATA(10) MESSAGETABLE(11)\n");
                printf("GROUP_CURSOR(12) GROUP_ICON(14) VERSION(16)\n");



                iCount++;
                break;

            case 'v':
                g_bVerbose=TRUE;
                iCount++;
                break;

            case 'c':
                iCount++;
                pInfo->pszChecksumFile=LocalAlloc(0, (strlen(argv[iCount])+1) * sizeof(char));
                if (pInfo->pszChecksumFile == NULL)
                {
                    ExitFromOutOfMemory();
                }
                strcpy(pInfo->pszChecksumFile, argv[iCount]);
                iCount++;                                 
                break;

           case 'b':

               iCount++;
               wChecksumLangId = (WORD)strtoul(argv[iCount], NULL, 0);
               iCount++;
               break;


            case 'i':

                if(argc<4)
                    return FALSE;

                pInfo->bIncludeFlag=TRUE;
                iNumInc=++iCount;

                //...Allocate memory for and copy included types
                while (argv[iNumInc][0]!='-' && iNumInc<iLast){
                    iNumInc++;
                }

                iNumInc-=iCount;

                //... Allocate enough memory for specified included resources
                //    and unspecified resources dependent on them

                pInfo->pszIncResType=LocalAlloc(0 ,(iNumInc+3)*sizeof(char *));
                if (pInfo->pszIncResType == NULL)
                {
                    ExitFromOutOfMemory();
                }


                i=0;
                while(i<iNumInc){
                    pInfo->pszIncResType[i]=LocalAlloc(0, (strlen(argv[iCount])+1) * sizeof(char));
                    if (pInfo->pszIncResType[i] == NULL)
                    {
                        ExitFromOutOfMemory();
                    }
                    strcpy(pInfo->pszIncResType[i], argv[iCount]);

                    switch(atoi(argv[iCount])){

                        case 1:
                            bInc1=TRUE;
                            break;

                        case 3:
                            bInc3=TRUE;
                            break;

                        case 12:
                            bInc12=TRUE;
                            break;

                        case 14:
                            bInc14=TRUE;
                            break;

                        default:
                            break;
                    }



                    i++;
                    iCount++;
                }

                //...If 1 or 12 is included, make sure both are included
                if(bInc1 ^ bInc12){

                    pInfo->bIncDependent=TRUE;

                    if(bInc1){
                        pInfo->pszIncResType[i]=LocalAlloc(0, 3 * sizeof(char));
                        if (pInfo->pszIncResType[i] == NULL)
                        {
                            ExitFromOutOfMemory();
                        }
                        strcpy(pInfo->pszIncResType[i], "12");
                        i++;
                    }

                    else{
                        pInfo->pszIncResType[i]=LocalAlloc(0, 2 * sizeof(char));
                        if (pInfo->pszIncResType[i] == NULL)
                        {
                            ExitFromOutOfMemory();
                        }
                        strcpy(pInfo->pszIncResType[i], "1");
                        i++;
                    }
                }

                //..If 3 or 14 is included, make sure both are included
                if(bInc3 ^ bInc14){

                    pInfo->bIncDependent=TRUE;

                    if(bInc3){
                        pInfo->pszIncResType[i]=LocalAlloc(0, 3 * sizeof(char));
                        if (pInfo->pszIncResType[i] == NULL)
                        {
                            ExitFromOutOfMemory();
                        }
                        strcpy(pInfo->pszIncResType[i], "14");
                        i++;
                    }

                    else{
                        pInfo->pszIncResType[i]=LocalAlloc(0, 2 * sizeof(char));
                        if (pInfo->pszIncResType[i] == NULL)
                        {
                            ExitFromOutOfMemory();
                        }
                        strcpy(pInfo->pszIncResType[i], "3");
                        i++;
                    }
                }

                while(i<iNumInc + 3){
                    pInfo->pszIncResType[i++]=NULL;
                }

                break;


            case 'l':

                if(argc<4)
                    return FALSE;

                iCount++;
                pInfo->wLanguage=(WORD)strtol(argv[iCount], NULL, 0);
                iCount++;
                break;

        }
    }

    if(argc<4)
        return FALSE;

    else
        return TRUE;

}


BOOL CALLBACK EnumTypesFunc(HMODULE hModule, LPTSTR lpType, LONG_PTR lParam){

    pCommandLineInfo pInfo;

    pInfo=(pCommandLineInfo)lParam;

    if(!pInfo->bIncludeFlag || bTypeIncluded((char *)lpType, pInfo->pszIncResType)) {

        pInfo->bContainsResources=TRUE;

        //...If the type is a string or a number other than 16...
        if( (PtrToUlong(lpType) & 0xFFFF0000) || ((WORD)PtrToUlong(lpType)!=16) ){
            pInfo->bContainsOnlyVersion=FALSE;
        }

        if(EnumResourceNames(hModule, (LPCTSTR)lpType, EnumNamesFunc, (LONG_PTR)pInfo));
        else {
            return FALSE;
        }
    }


    return TRUE;
}

// This is a Var struct within VarFileInfo for storing checksum for the source file.
// The current size for this structure is 56 bytes.
typedef struct VAR_SRC_CHECKSUM
{
    WORD wLength;
    WORD wValueLength;
    WORD wType;
    WCHAR szResourceChecksum[17];    // For storing "ResourceChecksum" null-terminated string in Unicode.
    DWORD dwChecksum[4];    // 128 bit checksum = 16 bytes = 4 DWORD.
} VarResourceChecksum;

// This is a Var struct within VarFileInfo for stroing the resource types used in this file.
struct VarResourceTypes
{
    WORD wLength;
    WORD wValueLength;
    WORD wType;
    WCHAR szResourceType[13];
    //BYTE padding[0];    // WORD * 3 + UnicodeChar*13 = 32 bytes.  So we need 0 bytes padding for DWORD alignment.
    DWORD* dwTypes;    // 128 bit checksum = 16 bytes = 4 DWORD.
};

BOOL WriteResHeader(
    HANDLE hFile, LONG ResSize, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, DWORD* pdwBytesWritten, DWORD* pdwHeaderSize)
{
    DWORD iPadding;
    WORD IdFlag=0xFFFF;
    unsigned i;
    LONG dwOffset;
    
    //...write the resource's size.
    PutDWord(hFile, ResSize, pdwBytesWritten, pdwHeaderSize);

    //...Put in bogus header size
    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);

    //...Write Resource Type
    if(PtrToUlong(lpType) & 0xFFFF0000)
    {
        PutString(hFile, lpType, pdwBytesWritten, pdwHeaderSize);
    }
    else
    {
        PutWord(hFile, IdFlag, pdwBytesWritten, pdwHeaderSize);
        PutWord(hFile, (USHORT)lpType, pdwBytesWritten, pdwHeaderSize);
    }

    //...Write Resource Name

    if(PtrToUlong(lpName) & 0xFFFF0000){
        PutString(hFile, lpName, pdwBytesWritten, pdwHeaderSize);
    }

    else{
        PutWord(hFile, IdFlag, pdwBytesWritten, pdwHeaderSize);
        PutWord(hFile, (USHORT)lpName, pdwBytesWritten, pdwHeaderSize);
    }


    //...Make sure Type and Name are DWORD-aligned
    iPadding=(*pdwHeaderSize)%(sizeof(DWORD));

    if(iPadding){
        for(i=0; i<(sizeof(DWORD)-iPadding); i++){
            PutByte (hFile, 0, pdwBytesWritten, pdwHeaderSize);
        }
    }

    //...More Win32 header stuff
    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);
    PutWord(hFile, 0x1030, pdwBytesWritten, pdwHeaderSize);


    //...Write Language

    PutWord(hFile, wLanguage, pdwBytesWritten, pdwHeaderSize);

    //...More Win32 header stuff

    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);  //... Version

    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);  //... Characteristics

    dwOffset=(*pdwHeaderSize)-4;

    //...Set file pointer to where the header size is
    if(SetFilePointer(hFile, -dwOffset, NULL, FILE_CURRENT));
    else{
        return FALSE;
    }

    PutDWord(hFile, (*pdwHeaderSize), pdwBytesWritten, NULL);


    //...Set file pointer back to the end of the header
    if(SetFilePointer(hFile, dwOffset-4, NULL, FILE_CURRENT));
    else {
        return FALSE;
    }

    return (TRUE);
}

BOOL WriteResource(HANDLE hFile, HMODULE hModule, WORD wLanguage, LPCSTR lpName, LPCSTR lpType, HRSRC hRsrc)
{
    HGLOBAL hRes;
    PVOID pv;
    LONG ResSize=0L;

    DWORD iPadding;
    unsigned i;

    DWORD dwBytesWritten;
    DWORD dwHeaderSize=0L;


    // Handle other types other than VS_VERSION_INFO
    
    //...write the resource header
    if(!(ResSize=SizeofResource(hModule, hRsrc)))
    {
        return FALSE;
    }

    // 
    // Generate an item in the RES format (*.res) file.
    //

    //
    // First, we generated header for this resource.
    //

    if (!WriteResHeader(hFile, ResSize, lpType, lpName, wLanguage, &dwBytesWritten, &dwHeaderSize))
    {
        return (FALSE);
    }

    //Second, we copy resource data to the .res file
    if (!(hRes=LoadResource(hModule, hRsrc)))
    {
        return FALSE;
    }
    if(!(pv=LockResource(hRes)))
    {
        return FALSE;
    }

    if (!WriteFile(hFile, pv, ResSize, &dwBytesWritten, NULL))
    {
        return FALSE;
    }

    //...Make sure resource is DWORD aligned
    iPadding=dwBytesWritten%(sizeof(DWORD));

    if(iPadding){
        for(i=0; i<(sizeof(DWORD)-iPadding); i++){
            PutByte (hFile, 0, &dwBytesWritten, NULL);
        }
    }
    return TRUE;
}

LPBYTE UpdateAddr(LPBYTE pAddr, WORD size, WORD* len)
{
    *len += size;
    return (pAddr + size);
}

LPBYTE AddPadding(LPBYTE pAddr, WORD* padding, WORD* len)
{
    if ((*padding = *len % 4) != 0)
    {
        *padding = (4 - *padding);
        *len += *padding;
        return (pAddr + *padding);
    }
    return (pAddr);
}

BOOL WriteVersionResource(
    HANDLE hFile, HMODULE hModule, WORD wLanguage, LPCSTR lpName, LPCSTR lpType, HRSRC hRsrc, unsigned char* pbChecksum)
{
    LONG ResSize=0L, OldResSize=0L;
    DWORD dwBytesWritten;
    DWORD dwHeaderSize=0L;
    WORD IdFlag=0xFFFF;
    
    BYTE* newVersionData;
    BYTE* pAddr;
    VarResourceChecksum varResourceChecksum;
    PVOID pv = NULL;
    HGLOBAL hRes;
    WORD len = 0;

    WORD wLength;
    WORD wValueLength;    
    WORD wType;
    LPWSTR szKey;
    WORD wPadding1Count;
    LPBYTE pValue;
    WORD wPadding2Count;
    
    int wTotalLen;
    BOOL isVS_VERSIONINFO = TRUE;
    BOOL isVarFileInfo = FALSE;
    BOOL isStringFileInfo = FALSE;

    BOOL bRet = FALSE;    

    //
    // Copy resource data from the .res file
    //
    if (hRes=LoadResource(hModule, hRsrc))
    {
        pv=LockResource(hRes);
    }

    if (pv)
    {
        //
        // The first WORD is the size of the VERSIONINFO resource.
        // 
        OldResSize = *((WORD*)pv);
    
        ResSize = OldResSize + sizeof(VarResourceChecksum);
  
        // 
        // Generate an item in the RES format (*.res) file.
        //
    
        //
        // First, we generated header for this resource in the RES file.
        //
        if (WriteResHeader(hFile, ResSize, lpType, lpName, wLanguage, &dwBytesWritten, &dwHeaderSize) &&
            (newVersionData = (BYTE*)LocalAlloc(0, ResSize)))
        {
            bRet = TRUE;

            memcpy(newVersionData, pv, OldResSize);

            // Add the length of new VarResourceChecksum structure to VS_VERSIONINFO.wLength.
            pAddr = newVersionData;

            wTotalLen = *((WORD*)pAddr);

            while (wTotalLen > 0)
            {
                len = 0;
                wPadding1Count = 0;
                wPadding2Count = 0;

                // wLength
                wLength = *((WORD*)pAddr);
                pAddr = UpdateAddr(pAddr, sizeof(WORD), &len);    

                // wValueLength
                wValueLength = *((WORD*)pAddr);
                pAddr = UpdateAddr(pAddr, sizeof(WORD), &len);

                // wType
                wType = *((WORD*)pAddr);
                pAddr = UpdateAddr(pAddr, sizeof(WORD), &len);

                // szKey
                szKey = (LPWSTR)pAddr;
                pAddr = UpdateAddr(pAddr, (WORD)((wcslen((WCHAR*)pAddr) + 1) * sizeof(WCHAR)), &len);

                // Padding 1
                pAddr = AddPadding(pAddr, &wPadding1Count, &len);

                // Value
                pValue = pAddr;

                if (wValueLength > 0)
                {
                    if (wType==1)
                    {
                        // In the case of String, the wValueLength is in WORD (not in BYTE).
                        pAddr = UpdateAddr(pAddr, (WORD)(wValueLength * sizeof(WCHAR)), &len);

                        // Padding 2
                        pAddr = AddPadding(pAddr, &wPadding2Count, &len);
                    } else
                    {
                        pAddr = UpdateAddr(pAddr, wValueLength, &len);                
                        if (isStringFileInfo)
                        {
                            //
                            // Generally, padding is not necessary in binary data.
                            // However, in some rare cases, people use binary data in the StringFileInfo (
                            // which is not really appropriate),
                            // So we need to add proper padding here to get around this.
                            //
                    
                            // Padding 2
                            pAddr = AddPadding(pAddr, &wPadding2Count, &len);
                        }
                    }
                }

                if (isVS_VERSIONINFO)
                {
                    //
                    // This is VS_VERSION_INFO.
                    //

                    // VS_VERSIONINFO can have padding 2.
                    isVS_VERSIONINFO = FALSE;
                    // Padding 2
                    pAddr = AddPadding(pAddr, &wPadding2Count, &len);

                    //
                    // Add the new VarResourceChecksum structure.
                    //
                    wLength += sizeof(VarResourceChecksum);
                }

                if (wcscmp(szKey, L"StringFileInfo") == 0)
                {
                    isStringFileInfo = TRUE;
                }

                if (wcscmp(szKey, L"VarFileInfo") == 0)
                {
                    isStringFileInfo = FALSE;
                    isVarFileInfo = TRUE;
                    wLength += sizeof(VarResourceChecksum);
                }

                PutWord(hFile, wLength, &dwBytesWritten, NULL);
                PutWord(hFile, wValueLength, &dwBytesWritten, NULL);
                PutWord(hFile, wType, &dwBytesWritten, NULL);
                PutStringW(hFile, szKey, &dwBytesWritten, NULL);
                PutPadding(hFile, wPadding1Count, &dwBytesWritten, NULL);
                WriteFile(hFile, pValue, wValueLength * (wType == 0 ? sizeof(BYTE) : sizeof(WCHAR)), &dwBytesWritten, NULL);
                PutPadding(hFile, wPadding2Count, &dwBytesWritten, NULL);

                if (isVarFileInfo && wcscmp(szKey, L"Translation") == 0)
                {
                    isVarFileInfo = FALSE;
                    varResourceChecksum.wLength = sizeof(VarResourceChecksum);
                    varResourceChecksum.wValueLength = 16;   // 128 bits checksum = 16 bytes
                    varResourceChecksum.wType = 0;
                    wcscpy(varResourceChecksum.szResourceChecksum, RESOURCE_CHECK_SUM);
                    memcpy(varResourceChecksum.dwChecksum, pbChecksum, 16);

                    if (!WriteFile(hFile, &varResourceChecksum, sizeof(VarResourceChecksum), &dwBytesWritten, NULL))
                    {
                        bRet = FALSE;
                        break;
                    }
                }

                wTotalLen -= len;        
            }

            LocalFree(newVersionData);
        }
    }

    return (bRet);
}


BOOL CALLBACK EnumNamesFunc(HMODULE hModule, LPCTSTR lpType, LPTSTR lpName, LONG_PTR lParam){

    HRSRC hRsrc;
    pCommandLineInfo pInfo;

    if(lParam == 0)
        printf( "MUIBLD: EnumNamesFunc lParam value incorrect (%d)\n", lParam );

    pInfo=(pCommandLineInfo)lParam;

    if(hRsrc=FindResourceEx(hModule, lpType, lpName, pInfo->wLanguage)){
        pInfo->bLanguageFound=TRUE;
    }
    else{
        pInfo->bLanguageFound=FALSE;
        return FALSE;
    }

    if (lpType == MAKEINTRESOURCE(RT_VERSION) && pInfo->bIsResChecksumGenerated)
    {
        //
        // If this is a version resource and resource checksum is generated, call
        // the following function to embed the resource checksum into the version
        // resource.
        //
        return (WriteVersionResource(pInfo->hFile, hModule, pInfo->wLanguage, lpName, lpType, hRsrc, pInfo->pResourceChecksum));
    }
    return (WriteResource(pInfo->hFile, hModule, pInfo->wLanguage, lpName, lpType, hRsrc));
    
}



BOOL bTypeIncluded(LPCSTR lpType, char **pszIncResType){
    char *pszBuf;
    char **p;


    if (PtrToUlong(lpType) & 0xFFFF0000) {
        pszBuf=LocalAlloc(0, strlen(lpType) +1);
        if (pszBuf == NULL)
        {
            ExitFromOutOfMemory();
        }
        // sprintf(pszBuf, "%s", lpType);
        strcpy(pszBuf, lpType);
    }

    else {
        WORD wType = (WORD) lpType;
        pszBuf=LocalAlloc(0, sizeof(lpType) + 1);
        if (pszBuf == NULL)
        {
            ExitFromOutOfMemory();
        }
        sprintf(pszBuf, "%u", wType);
    }

    p=pszIncResType;

    while(p && *p){
        if(strcmp(pszBuf, *p)==0)
            return TRUE;
        p++;
    }
    LocalFree(pszBuf);

    return FALSE;
}


BOOL bInsertHeader(HANDLE hFile){
    DWORD dwBytesWritten;

    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x20, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);

    PutWord (hFile, 0xffff, &dwBytesWritten, NULL);
    PutWord (hFile, 0x00, &dwBytesWritten, NULL);
    PutWord (hFile, 0xffff, &dwBytesWritten, NULL);
    PutWord (hFile, 0x00, &dwBytesWritten, NULL);

    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);

    return TRUE;
}

void  PutByte(HANDLE OutFile, TCHAR b, LONG *plSize1, LONG *plSize2){
    BYTE temp=b;

    if (plSize2){
        (*plSize2)++;
    }

    WriteFile(OutFile, &b, 1, plSize1, NULL);
}

void PutWord(HANDLE OutFile, WORD w, LONG *plSize1, LONG *plSize2){
    PutByte(OutFile, (BYTE) LOBYTE(w), plSize1, plSize2);
    PutByte(OutFile, (BYTE) HIBYTE(w), plSize1, plSize2);
}

void PutDWord(HANDLE OutFile, DWORD l, LONG *plSize1, LONG *plSize2){
    PutWord(OutFile, LOWORD(l), plSize1, plSize2);
    PutWord(OutFile, HIWORD(l), plSize1, plSize2);
}


void PutString(HANDLE OutFile, LPCSTR szStr , LONG *plSize1, LONG *plSize2){
    WORD i = 0;

    do {
        PutWord( OutFile , szStr[ i ], plSize1, plSize2);
    }
    while ( szStr[ i++ ] != TEXT('\0') );
}

void PutStringW(HANDLE OutFile, LPCWSTR szStr , LONG *plSize1, LONG *plSize2){
    WORD i = 0;

    do {
        PutWord( OutFile , szStr[ i ], plSize1, plSize2);
    }
    while ( szStr[ i++ ] != L'\0' );
}

void PutPadding(HANDLE OutFile, int paddingCount, LONG *plSize1, LONG *plSize2)
{
    int i;
    for (i = 0; i < paddingCount; i++)
    {
        PutByte(OutFile, 0x00, plSize1, plSize2);
    }
}

void Usage(){
    printf("MUIBLD [-h|?] [-c checksum_filename] [-v] -l langid [-i resource_type] source_filename\n");
    printf("    [target_filename]\n\n");
}

void CleanUp(pCommandLineInfo pInfo, HANDLE hModule, BOOL bDeleteFile){
    if(hModule)
        FreeLibrary(hModule);

    if(pInfo->hFile)
        CloseHandle(pInfo->hFile);

    if(bDeleteFile && pInfo->pszTarget)
        DeleteFile(pInfo->pszTarget);

}

void FreeAll(pCommandLineInfo pInfo){
    char **p;

    LocalFree(pInfo->pszSource);
    LocalFree(pInfo->pszTarget);

    if(pInfo->pszIncResType){
        p=pInfo->pszIncResType;
        while(p && *p){
            LocalFree(*p);
            p++;
        }
        LocalFree(pInfo->pszIncResType);
    }
}

void ExitFromOutOfMemory()
{
    printf("Out of memory.  Can not continue. GetLastError() = 0x%x.", GetLastError());
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\witables.inc ===
'<script language='VBScript'>
' witables.inc - Windows Installer table definitions
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'

'--------------------------------------------------------'
' Boolean attribute to bit translation
'--------------------------------------------------------'
Dim dialogAttributes : dialogAttributes = Array("Hidden","Modeless","NoMinimize","SystemModal","KeepModeless","TrackDiskSpace","CustomPalette","RightToLeft","RightAligned","LeftScroll")
Dim   commonControlAttributes :   commonControlAttributes = Array("Hidden","Disabled","Sunken","Indirect","Integer","RightToLeft","RightAligned","LeftScroll")
Dim     textControlAttributes :     textControlAttributes = Array("Transparent","NoPrefix","NoWrap","FormatSize","UserLanguage")
Dim     editControlAttributes :     editControlAttributes = Array("Multiline", Empty, Empty, Empty,    Empty, "Password")
Dim progressControlAttributes : progressControlAttributes = Array("ProgressBlocks")
Dim   volumeControlAttributes :   volumeControlAttributes = Array("Removable","Fixed","Remote","CDROM","RAMDisk","Floppy","ShowRollbackCost")
Dim  listboxControlAttributes :  listboxControlAttributes = Array("Sorted")
Dim listviewControlAttributes : listviewControlAttributes = Array("Sorted",Empty    , Empty  , Empty, "FixedSize","Icon16","Icon32")
Dim comboboxControlAttributes : comboboxControlAttributes = Array("Sorted","ComboList")
Dim    radioControlAttributes :    radioControlAttributes = Array("Image","PushLike","Bitmap","Icon", "FixedSize","Icon16","Icon32",Empty,"HasBorder")
Dim   buttonControlAttributes :   buttonControlAttributes = Array("Image", Empty    ,"Bitmap","Icon", "FixedSize","Icon16","Icon32")    
Dim     iconControlAttributes :     iconControlAttributes = Array("Image", Empty    , Empty  , Empty, "FixedSize","Icon16","Icon32")
Dim   bitmapControlAttributes :   bitmapControlAttributes = Array("Image", Empty    , Empty  , Empty, "FixedSize")
Dim checkboxControlAttributes : checkboxControlAttributes = Array( Empty, "PushLike","Bitmap","Icon", "FixedSize","Icon16","Icon32")

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Boolean permission to bit translation
Dim standardPermissions : standardPermissions = Array("Delete","ReadPermission","ChangePermission","TakeOwnership","Synchronize")
Dim registryPermissions : registryPermissions = Array("Read",  "Write", "CreateSubkeys","EnumerateSubkeys","Notify","CreateLink")
Dim     filePermissions :     filePermissions = Array("Read",  "Write",   "Append",     "ReadExtendedAttributes","WriteExtendedAttributes","Execute",  Empty,       "ReadAttributes","WriteAttributes")
Dim   folderPermissions :   folderPermissions = Array("Read","CreateFile","CreateChild","ReadExtendedAttributes","WriteExtendedAttributes","Traverse","DeleteChild","ReadAttributes","WriteAttributes")
Dim  genericPermissions :  genericPermissions = Array("GenericAll","GenericExecute","GenericWrite","GenericRead")

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Database table schema
Dim   ActionTextTable(3)         : ActionTextTable(0)                      = "`ActionText`"
Const ActionText_Action      = 1 : ActionTextTable(ActionText_Action)      = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const ActionText_Description = 2 : ActionTextTable(ActionText_Description) = "`Description` CHAR(64) LOCALIZABLE"
Const ActionText_Template    = 3 : ActionTextTable(ActionText_Template)    = "`Template` CHAR(128) LOCALIZABLE"
Dim   AdminExecuteSequenceTable(3)       : AdminExecuteSequenceTable(0)                              = "`AdminExecuteSequence`"
Const AdminExecuteSequence_Action    = 1 : AdminExecuteSequenceTable(AdminExecuteSequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const AdminExecuteSequence_Condition = 2 : AdminExecuteSequenceTable(AdminExecuteSequence_Condition) = "`Condition` CHAR(255)"
Const AdminExecuteSequence_Sequence  = 3 : AdminExecuteSequenceTable(AdminExecuteSequence_Sequence)  = "`Sequence` SHORT"
Dim   AdminUISequenceTable(3)       : AdminUISequenceTable(0)                         = "`AdminUISequence`"
Const AdminUISequence_Action    = 1 : AdminUISequenceTable(AdminUISequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const AdminUISequence_Condition = 2 : AdminUISequenceTable(AdminUISequence_Condition) = "`Condition` CHAR(255)"
Const AdminUISequence_Sequence  = 3 : AdminUISequenceTable(AdminUISequence_Sequence)  = "`Sequence` SHORT"
Dim   AdvtExecuteSequenceTable(3)       : AdvtExecuteSequenceTable(0)                             = "`AdvtExecuteSequence`"
Const AdvtExecuteSequence_Action    = 1 : AdvtExecuteSequenceTable(AdvtExecuteSequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const AdvtExecuteSequence_Condition = 2 : AdvtExecuteSequenceTable(AdvtExecuteSequence_Condition) = "`Condition` CHAR(255)"
Const AdvtExecuteSequence_Sequence  = 3 : AdvtExecuteSequenceTable(AdvtExecuteSequence_Sequence)  = "`Sequence` SHORT"
Dim   AdvtUISequenceTable(3)       : AdvtUISequenceTable(0)                        = "`AdvtUISequence`"
Const AdvtUISequence_Action    = 1 : AdvtUISequenceTable(AdvtUISequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const AdvtUISequence_Condition = 2 : AdvtUISequenceTable(AdvtUISequence_Condition) = "`Condition` CHAR(255)"
Const AdvtUISequence_Sequence  = 3 : AdvtUISequenceTable(AdvtUISequence_Sequence)  = "`Sequence` SHORT"
Dim   AppIdTable(7)                  : AppIdTable(0)                          = "`AppId`"
Const AppId_AppId                = 1 : AppIdTable(AppId_AppId)                = "`AppId` CHAR(38) NOT NULL PRIMARY KEY"
Const AppId_RemoteServerName     = 2 : AppIdTable(AppId_RemoteServerName)     = "`RemoteServerName` CHAR(255)"
Const AppId_LocalService         = 3 : AppIdTable(AppId_LocalService)         = "`LocalService` CHAR(255)"
Const AppId_ServiceParameters    = 4 : AppIdTable(AppId_ServiceParameters)    = "`ServiceParameters` CHAR(255)"
Const AppId_DllSurrogate         = 5 : AppIdTable(AppId_DllSurrogate)         = "`DllSurrogate` CHAR(255)"
Const AppId_ActivateAtStorage    = 6 : AppIdTable(AppId_ActivateAtStorage)    = "`ActivateAtStorage` SHORT"
Const AppId_RunAsInteractiveUser = 7 : AppIdTable(AppId_RunAsInteractiveUser) = "`RunAsInteractiveUser` SHORT"
Dim   AppSearchTable(2)        : AppSearchTable(0)                    = "`AppSearch`"
Const AppSearch_Property   = 1 : AppSearchTable(AppSearch_Property)   = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const AppSearch_Signature_ = 2 : AppSearchTable(AppSearch_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Dim   BBControlTable(9)        : BBControlTable(0)                    = "`BBControl`"
Const BBControl_Billboard_ = 1 : BBControlTable(BBControl_Billboard_) = "`Billboard_` CHAR(50) NOT NULL PRIMARY KEY"
Const BBControl_BBControl  = 2 : BBControlTable(BBControl_BBControl)  = "`BBControl` CHAR(50) NOT NULL PRIMARY KEY"
Const BBControl_Type       = 3 : BBControlTable(BBControl_Type)       = "`Type` CHAR(50) NOT NULL"
Const BBControl_X          = 4 : BBControlTable(BBControl_X)          = "`X` SHORT NOT NULL"
Const BBControl_Y          = 5 : BBControlTable(BBControl_Y)          = "`Y` SHORT NOT NULL"
Const BBControl_Width      = 6 : BBControlTable(BBControl_Width)      = "`Width` SHORT NOT NULL"
Const BBControl_Height     = 7 : BBControlTable(BBControl_Height)     = "`Height` SHORT NOT NULL"
Const BBControl_Attributes = 8 : BBControlTable(BBControl_Attributes) = "`Attributes` LONG"
Const BBControl_Text       = 9 : BBControlTable(BBControl_Text)       = "`Text` CHAR(50) LOCALIZABLE"
Dim   BillboardTable(4)       : BillboardTable(0)                   = "`Billboard`"
Const Billboard_Billboard = 1 : BillboardTable(Billboard_Billboard) = "`Billboard` CHAR(50) NOT NULL PRIMARY KEY"
Const Billboard_Feature_  = 2 : BillboardTable(Billboard_Feature_)  = "`Feature_` CHAR(38) NOT NULL"
Const Billboard_Action    = 3 : BillboardTable(Billboard_Action)    = "`Action` CHAR(50)"
Const Billboard_Ordering  = 4 : BillboardTable(Billboard_Ordering)  = "`Ordering` SHORT"
Dim   BinaryTable(2)  : BinaryTable(0)           = "`Binary`"
Const Binary_Name = 1 : BinaryTable(Binary_Name) = "`Name` CHAR(72) NOT NULL PRIMARY KEY"
Const Binary_Data = 2 : BinaryTable(Binary_Data) = "`Data` OBJECT NOT NULL"
Dim   BindImageTable(2)   : BindImageTable(0)               = "`BindImage`"
Const BindImage_File_ = 1 : BindImageTable(BindImage_File_) = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const BindImage_Path  = 2 : BindImageTable(BindImage_Path)  = "`Path` CHAR(255)"
Dim   CCPSearchTable(1)        : CCPSearchTable(0)                    = "`CCPSearch`"
Const CCPSearch_Signature_ = 1 : CCPSearchTable(CCPSearch_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Dim   CheckBoxTable(2)      : CheckBoxTable(0)                 = "`CheckBox`"
Const CheckBox_Property = 1 : CheckBoxTable(CheckBox_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const CheckBox_Value    = 2 : CheckBoxTable(CheckBox_Value)    = "`Value` CHAR(64)"
Dim   ClassTable(13)             : ClassTable(0)                      = "`Class`"
Const Class_CLSID            = 1 : ClassTable(Class_CLSID)            = "`CLSID` CHAR(38) NOT NULL PRIMARY KEY"
Const Class_Context          = 2 : ClassTable(Class_Context)          = "`Context` CHAR(32) NOT NULL PRIMARY KEY"
Const Class_Component_       = 3 : ClassTable(Class_Component_)       = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const Class_ProgId_Default   = 4 : ClassTable(Class_ProgId_Default)   = "`ProgId_Default` CHAR(255)"
Const Class_Description      = 5 : ClassTable(Class_Description)      = "`Description` CHAR(255) LOCALIZABLE"
Const Class_AppId_           = 6 : ClassTable(Class_AppId_)           = "`AppId_` CHAR(38)"
Const Class_FileTypeMask     = 7 : ClassTable(Class_FileTypeMask)     = "`FileTypeMask` CHAR(255)"
Const Class_Icon_            = 8 : ClassTable(Class_Icon_)            = "`Icon_` CHAR(72)"
Const Class_IconIndex        = 9 : ClassTable(Class_IconIndex)        = "`IconIndex` SHORT"
Const Class_DefInprocHandler =10 : ClassTable(Class_DefInprocHandler) = "`DefInprocHandler` CHAR(32)"
Const Class_Argument         =11 : ClassTable(Class_Argument)         = "`Argument` CHAR(255)"
Const Class_Feature_         =12 : ClassTable(Class_Feature_)         = "`Feature_` CHAR(38) NOT NULL"
Const Class_Attributes       =13 : ClassTable(Class_Attributes)       = "`Attributes` SHORT"
Dim   ComboBoxTable(4)      : ComboBoxTable(0)                 = "`ComboBox`"
Const ComboBox_Property = 1 : ComboBoxTable(ComboBox_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const ComboBox_Order    = 2 : ComboBoxTable(ComboBox_Order)    = "`Order` SHORT NOT NULL PRIMARY KEY"
Const ComboBox_Value    = 3 : ComboBoxTable(ComboBox_Value)    = "`Value` CHAR(64) NOT NULL"
Const ComboBox_Text     = 4 : ComboBoxTable(ComboBox_Text)     = "`Text` CHAR(64) LOCALIZABLE"
Dim   CompLocatorTable(3)         : CompLocatorTable(0)                       = "`CompLocator`"
Const CompLocator_Signature_  = 1 : CompLocatorTable(CompLocator_Signature_)  = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Const CompLocator_ComponentId = 2 : CompLocatorTable(CompLocator_ComponentId) = "`ComponentId` CHAR(38) NOT NULL"
Const CompLocator_Type        = 3 : CompLocatorTable(CompLocator_Type)        = "`Type` SHORT"
Dim   ComplusTable(2)        : ComplusTable(0)                  = "`Complus`"
Const Complus_Component_ = 1 : ComplusTable(Complus_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const Complus_ExpType    = 2 : ComplusTable(Complus_ExpType)    = "`ExpType` SHORT PRIMARY KEY"
Dim   ComponentTable(6)         : ComponentTable(0)                     = "`Component`"
Const Component_Component   = 1 : ComponentTable(Component_Component)   = "`Component` CHAR(72) NOT NULL PRIMARY KEY"
Const Component_ComponentId = 2 : ComponentTable(Component_ComponentId) = "`ComponentId` CHAR(38)"
Const Component_Directory_  = 3 : ComponentTable(Component_Directory_)  = "`Directory_` CHAR(72) NOT NULL"
Const Component_Attributes  = 4 : ComponentTable(Component_Attributes)  = "`Attributes` SHORT NOT NULL"
Const Component_Condition   = 5 : ComponentTable(Component_Condition)   = "`Condition` CHAR(255)"
Const Component_KeyPath     = 6 : ComponentTable(Component_KeyPath)     = "`KeyPath` CHAR(72)"
Dim   ConditionTable(3)       : ConditionTable(0)                   = "`Condition`"
Const Condition_Feature_  = 1 : ConditionTable(Condition_Feature_)  = "`Feature_` CHAR(38) NOT NULL PRIMARY KEY"
Const Condition_Level     = 2 : ConditionTable(Condition_Level)     = "`Level` SHORT NOT NULL PRIMARY KEY"
Const Condition_Condition = 3 : ConditionTable(Condition_Condition) = "`Condition` CHAR(255)"
Dim   ControlTable(12)         : ControlTable(0)                    = "`Control`"
Const Control_Dialog_      = 1 : ControlTable(Control_Dialog_)      = "`Dialog_` CHAR(72) NOT NULL PRIMARY KEY"
Const Control_Control      = 2 : ControlTable(Control_Control)      = "`Control` CHAR(50) NOT NULL PRIMARY KEY"
Const Control_Type         = 3 : ControlTable(Control_Type)         = "`Type` CHAR(20) NOT NULL"
Const Control_X            = 4 : ControlTable(Control_X)            = "`X` SHORT NOT NULL"
Const Control_Y            = 5 : ControlTable(Control_Y)            = "`Y` SHORT NOT NULL"
Const Control_Width        = 6 : ControlTable(Control_Width)        = "`Width` SHORT NOT NULL"
Const Control_Height       = 7 : ControlTable(Control_Height)       = "`Height` SHORT NOT NULL"
Const Control_Attributes   = 8 : ControlTable(Control_Attributes)   = "`Attributes` LONG"
Const Control_Property     = 9 : ControlTable(Control_Property)     = "`Property` CHAR(50)"
Const Control_Text         =10 : ControlTable(Control_Text)         = "`Text` LONGCHAR LOCALIZABLE"
Const Control_Control_Next =11 : ControlTable(Control_Control_Next) = "`Control_Next` CHAR(50)"
Const Control_Help         =12 : ControlTable(Control_Help)         = "`Help` CHAR(50) LOCALIZABLE"
Dim   ControlConditionTable(4)       : ControlConditionTable(0)                          = "`ControlCondition`"
Const ControlCondition_Dialog_   = 1 : ControlConditionTable(ControlCondition_Dialog_)   = "`Dialog_` CHAR(72) NOT NULL PRIMARY KEY"
Const ControlCondition_Control_  = 2 : ControlConditionTable(ControlCondition_Control_)  = "`Control_` CHAR(50) NOT NULL PRIMARY KEY"
Const ControlCondition_Action    = 3 : ControlConditionTable(ControlCondition_Action)    = "`Action` CHAR(50) NOT NULL PRIMARY KEY"
Const ControlCondition_Condition = 4 : ControlConditionTable(ControlCondition_Condition) = "`Condition` CHAR(255) NOT NULL PRIMARY KEY"
Dim   ControlEventTable(6)       : ControlEventTable(0)                      = "`ControlEvent`"
Const ControlEvent_Dialog_   = 1 : ControlEventTable(ControlEvent_Dialog_)   = "`Dialog_` CHAR(72) NOT NULL PRIMARY KEY"
Const ControlEvent_Control_  = 2 : ControlEventTable(ControlEvent_Control_)  = "`Control_` CHAR(50) NOT NULL PRIMARY KEY"
Const ControlEvent_Event     = 3 : ControlEventTable(ControlEvent_Event)     = "`Event` CHAR(50) NOT NULL PRIMARY KEY"
Const ControlEvent_Argument  = 4 : ControlEventTable(ControlEvent_Argument)  = "`Argument` CHAR(255) NOT NULL PRIMARY KEY"
Const ControlEvent_Condition = 5 : ControlEventTable(ControlEvent_Condition) = "`Condition` CHAR(255) PRIMARY KEY"
Const ControlEvent_Ordering  = 6 : ControlEventTable(ControlEvent_Ordering)  = "`Ordering` SHORT"
Dim   CreateFolderTable(2)        : CreateFolderTable(0)                       = "`CreateFolder`"
Const CreateFolder_Directory_ = 1 : CreateFolderTable(CreateFolder_Directory_) = "`Directory_` CHAR(72) NOT NULL PRIMARY KEY"
Const CreateFolder_Component_ = 2 : CreateFolderTable(CreateFolder_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Dim   CustomActionTable(4)    : CustomActionTable(0)                   = "`CustomAction`"
Const CustomAction_Action = 1 : CustomActionTable(CustomAction_Action) = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const CustomAction_Type   = 2 : CustomActionTable(CustomAction_Type)   = "`Type` SHORT NOT NULL"
Const CustomAction_Source = 3 : CustomActionTable(CustomAction_Source) = "`Source` CHAR(64)"
Const CustomAction_Target = 4 : CustomActionTable(CustomAction_Target) = "`Target` CHAR(255)"
Dim   DialogTable(10)            : DialogTable(0)                      = "`Dialog`"
Const Dialog_Dialog          = 1 : DialogTable(Dialog_Dialog)          = "`Dialog` CHAR(72) NOT NULL PRIMARY KEY"
Const Dialog_HCentering      = 2 : DialogTable(Dialog_HCentering)      = "`HCentering` SHORT NOT NULL"
Const Dialog_VCentering      = 3 : DialogTable(Dialog_VCentering)      = "`VCentering` SHORT NOT NULL"
Const Dialog_Width           = 4 : DialogTable(Dialog_Width)           = "`Width` SHORT NOT NULL"
Const Dialog_Height          = 5 : DialogTable(Dialog_Height)          = "`Height` SHORT NOT NULL"
Const Dialog_Attributes      = 6 : DialogTable(Dialog_Attributes)      = "`Attributes` LONG"
Const Dialog_Title           = 7 : DialogTable(Dialog_Title)           = "`Title` CHAR(128) LOCALIZABLE"
Const Dialog_Control_First   = 8 : DialogTable(Dialog_Control_First)   = "`Control_First` CHAR(50) NOT NULL"
Const Dialog_Control_Default = 9 : DialogTable(Dialog_Control_Default) = "`Control_Default` CHAR(50)"
Const Dialog_Control_Cancel  =10 : DialogTable(Dialog_Control_Cancel)  = "`Control_Cancel` CHAR(50)"
Dim   DirectoryTable(3)              : DirectoryTable(0)                          = "`Directory`"
Const Directory_Directory        = 1 : DirectoryTable(Directory_Directory)        = "`Directory` CHAR(72) NOT NULL PRIMARY KEY"
Const Directory_Directory_Parent = 2 : DirectoryTable(Directory_Directory_Parent) = "`Directory_Parent` CHAR(72)"
Const Directory_DefaultDir       = 3 : DirectoryTable(Directory_DefaultDir)       = "`DefaultDir` CHAR(255) NOT NULL LOCALIZABLE"
Dim   DrLocatorTable(4)        : DrLocatorTable(0)                    = "`DrLocator`"
Const DrLocator_Signature_ = 1 : DrLocatorTable(DrLocator_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Const DrLocator_Parent     = 2 : DrLocatorTable(DrLocator_Parent)     = "`Parent` CHAR(72) PRIMARY KEY"
Const DrLocator_Path       = 3 : DrLocatorTable(DrLocator_Path)       = "`Path` CHAR(255) PRIMARY KEY"
Const DrLocator_Depth      = 4 : DrLocatorTable(DrLocator_Depth)      = "`Depth` SHORT"
Dim   DuplicateFileTable(5)        : DuplicateFileTable(0)                        = "`DuplicateFile`"
Const DuplicateFile_FileKey    = 1 : DuplicateFileTable(DuplicateFile_FileKey)    = "`FileKey` CHAR(72) NOT NULL PRIMARY KEY"
Const DuplicateFile_Component_ = 2 : DuplicateFileTable(DuplicateFile_Component_) = "`Component_` CHAR(72) NOT NULL"
Const DuplicateFile_File_      = 3 : DuplicateFileTable(DuplicateFile_File_)      = "`File_` CHAR(72) NOT NULL"
Const DuplicateFile_DestName   = 4 : DuplicateFileTable(DuplicateFile_DestName)   = "`DestName` CHAR(255) LOCALIZABLE"
Const DuplicateFile_DestFolder = 5 : DuplicateFileTable(DuplicateFile_DestFolder) = "`DestFolder` CHAR(72)"
Dim   EnvironmentTable(4)         : EnvironmentTable(0)                       = "`Environment`"
Const Environment_Environment = 1 : EnvironmentTable(Environment_Environment) = "`Environment` CHAR(72) NOT NULL PRIMARY KEY"
Const Environment_Name        = 2 : EnvironmentTable(Environment_Name)        = "`Name` CHAR(255) NOT NULL LOCALIZABLE"
Const Environment_Value       = 3 : EnvironmentTable(Environment_Value)       = "`Value` CHAR(255) LOCALIZABLE"
Const Environment_Component_  = 4 : EnvironmentTable(Environment_Component_)  = "`Component_` CHAR(72) NOT NULL"
Dim   ErrorTable(2)     : ErrorTable(0)             = "`Error`"
Const Error_Error   = 1 : ErrorTable(Error_Error)   = "`Error` SHORT NOT NULL PRIMARY KEY"
Const Error_Message = 2 : ErrorTable(Error_Message) = "`Message` CHAR(255) LOCALIZABLE"
Dim   EventMappingTable(4)       : EventMappingTable(0)                      = "`EventMapping`"
Const EventMapping_Dialog_   = 1 : EventMappingTable(EventMapping_Dialog_)   = "`Dialog_` CHAR(72) NOT NULL PRIMARY KEY"
Const EventMapping_Control_  = 2 : EventMappingTable(EventMapping_Control_)  = "`Control_` CHAR(50) NOT NULL PRIMARY KEY"
Const EventMapping_Event     = 3 : EventMappingTable(EventMapping_Event)     = "`Event` CHAR(50) NOT NULL PRIMARY KEY"
Const EventMapping_Attribute = 4 : EventMappingTable(EventMapping_Attribute) = "`Attribute` CHAR(50) NOT NULL"
Dim   ExtensionTable(5)        : ExtensionTable(0)                    = "`Extension`"
Const Extension_Extension  = 1 : ExtensionTable(Extension_Extension)  = "`Extension` CHAR(255) NOT NULL PRIMARY KEY"
Const Extension_Component_ = 2 : ExtensionTable(Extension_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const Extension_ProgId_    = 3 : ExtensionTable(Extension_ProgId_)    = "`ProgId_` CHAR(255)"
Const Extension_MIME_      = 4 : ExtensionTable(Extension_MIME_)      = "`MIME_` CHAR(64)"
Const Extension_Feature_   = 5 : ExtensionTable(Extension_Feature_)   = "`Feature_` CHAR(38) NOT NULL"
Dim   FeatureTable(8)            : FeatureTable(0)                      = "`Feature`"
Const Feature_Feature        = 1 : FeatureTable(Feature_Feature)        = "`Feature` CHAR(38) NOT NULL PRIMARY KEY"
Const Feature_Feature_Parent = 2 : FeatureTable(Feature_Feature_Parent) = "`Feature_Parent` CHAR(38)"
Const Feature_Title          = 3 : FeatureTable(Feature_Title)          = "`Title` CHAR(64) LOCALIZABLE"
Const Feature_Description    = 4 : FeatureTable(Feature_Description)    = "`Description` CHAR(255) LOCALIZABLE"
Const Feature_Display        = 5 : FeatureTable(Feature_Display)        = "`Display` SHORT"
Const Feature_Level          = 6 : FeatureTable(Feature_Level)          = "`Level` SHORT NOT NULL"
Const Feature_Directory_     = 7 : FeatureTable(Feature_Directory_)     = "`Directory_` CHAR(72)"
Const Feature_Attributes     = 8 : FeatureTable(Feature_Attributes)     = "`Attributes` SHORT NOT NULL"
Dim   FeatureComponentsTable(2)        : FeatureComponentsTable(0)                            = "`FeatureComponents`"
Const FeatureComponents_Feature_   = 1 : FeatureComponentsTable(FeatureComponents_Feature_)   = "`Feature_` CHAR(38) NOT NULL PRIMARY KEY"
Const FeatureComponents_Component_ = 2 : FeatureComponentsTable(FeatureComponents_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Dim   FileTable(8)        : FileTable(0)               = "`File`"
Const File_File       = 1 : FileTable(File_File)       = "`File` CHAR(72) NOT NULL PRIMARY KEY"
Const File_Component_ = 2 : FileTable(File_Component_) = "`Component_` CHAR(72) NOT NULL"
Const File_FileName   = 3 : FileTable(File_FileName)   = "`FileName` CHAR(255) NOT NULL LOCALIZABLE"
Const File_FileSize   = 4 : FileTable(File_FileSize)   = "`FileSize` LONG NOT NULL"
Const File_Version    = 5 : FileTable(File_Version)    = "`Version` CHAR(72)"
Const File_Language   = 6 : FileTable(File_Language)   = "`Language` CHAR(20)"
Const File_Attributes = 7 : FileTable(File_Attributes) = "`Attributes` SHORT"
Const File_Sequence   = 8 : FileTable(File_Sequence)   = "`Sequence` SHORT NOT NULL"
Dim   FontTable(2)       : FontTable(0)              = "`Font`"
Const Font_File_     = 1 : FontTable(Font_File_)     = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const Font_FontTitle = 2 : FontTable(Font_FontTitle) = "`FontTitle` CHAR(128)"
Dim   IconTable(2)  : IconTable(0)         = "`Icon`"
Const Icon_Name = 1 : IconTable(Icon_Name) = "`Name` CHAR(72) NOT NULL PRIMARY KEY"
Const Icon_Data = 2 : IconTable(Icon_Data) = "`Data` OBJECT NOT NULL"
Dim   IniFileTable(8)         : IniFileTable(0)                   = "`IniFile`"
Const IniFile_IniFile     = 1 : IniFileTable(IniFile_IniFile)     = "`IniFile` CHAR(72) NOT NULL PRIMARY KEY"
Const IniFile_FileName    = 2 : IniFileTable(IniFile_FileName)    = "`FileName` CHAR(255) NOT NULL LOCALIZABLE"
Const IniFile_DirProperty = 3 : IniFileTable(IniFile_DirProperty) = "`DirProperty` CHAR(72)"
Const IniFile_Section     = 4 : IniFileTable(IniFile_Section)     = "`Section` CHAR(96) NOT NULL LOCALIZABLE"
Const IniFile_Key         = 5 : IniFileTable(IniFile_Key)         = "`Key` CHAR(128) NOT NULL LOCALIZABLE"
Const IniFile_Value       = 6 : IniFileTable(IniFile_Value)       = "`Value` CHAR(255) NOT NULL LOCALIZABLE"
Const IniFile_Action      = 7 : IniFileTable(IniFile_Action)      = "`Action` SHORT NOT NULL"
Const IniFile_Component_  = 8 : IniFileTable(IniFile_Component_)  = "`Component_` CHAR(72) NOT NULL"
Dim   IniLocatorTable(6)        : IniLocatorTable(0)                     = "`IniLocator`"
Const IniLocator_Signature_ = 1 : IniLocatorTable(IniLocator_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Const IniLocator_FileName   = 2 : IniLocatorTable(IniLocator_FileName)   = "`FileName` CHAR(255) NOT NULL"
Const IniLocator_Section    = 3 : IniLocatorTable(IniLocator_Section)    = "`Section` CHAR(96) NOT NULL"
Const IniLocator_Key        = 4 : IniLocatorTable(IniLocator_Key)        = "`Key` CHAR(128) NOT NULL"
Const IniLocator_Field      = 5 : IniLocatorTable(IniLocator_Field)      = "`Field` SHORT"
Const IniLocator_Type       = 6 : IniLocatorTable(IniLocator_Type)       = "`Type` SHORT"
Dim   InstallExecuteSequenceTable(3)       : InstallExecuteSequenceTable(0)                                = "`InstallExecuteSequence`"
Const InstallExecuteSequence_Action    = 1 : InstallExecuteSequenceTable(InstallExecuteSequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const InstallExecuteSequence_Condition = 2 : InstallExecuteSequenceTable(InstallExecuteSequence_Condition) = "`Condition` CHAR(255)"
Const InstallExecuteSequence_Sequence  = 3 : InstallExecuteSequenceTable(InstallExecuteSequence_Sequence)  = "`Sequence` SHORT"
Dim   InstallUISequenceTable(3)       : InstallUISequenceTable(0)                           = "`InstallUISequence`"
Const InstallUISequence_Action    = 1 : InstallUISequenceTable(InstallUISequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const InstallUISequence_Condition = 2 : InstallUISequenceTable(InstallUISequence_Condition) = "`Condition` CHAR(255)"
Const InstallUISequence_Sequence  = 3 : InstallUISequenceTable(InstallUISequence_Sequence)  = "`Sequence` SHORT"
Dim   IsolatedComponentTable(2)                   : IsolatedComponentTable(0)                                       = "`IsolatedComponent`"
Const IsolatedComponent_Component_Shared      = 1 : IsolatedComponentTable(IsolatedComponent_Component_Shared)      = "`Component_Shared` CHAR(72) NOT NULL PRIMARY KEY"
Const IsolatedComponent_Component_Application = 2 : IsolatedComponentTable(IsolatedComponent_Component_Application) = "`Component_Application` CHAR(72) NOT NULL PRIMARY KEY"
Dim   LaunchConditionTable(2)         : LaunchConditionTable(0)                           = "`LaunchCondition`"
Const LaunchCondition_Condition   = 1 : LaunchConditionTable(LaunchCondition_Condition)   = "`Condition` CHAR(255) NOT NULL PRIMARY KEY"
Const LaunchCondition_Description = 2 : LaunchConditionTable(LaunchCondition_Description) = "`Description` CHAR(255) NOT NULL LOCALIZABLE"
Dim   ListBoxTable(4)      : ListBoxTable(0)                = "`ListBox`"
Const ListBox_Property = 1 : ListBoxTable(ListBox_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const ListBox_Order    = 2 : ListBoxTable(ListBox_Order)    = "`Order` SHORT NOT NULL PRIMARY KEY"
Const ListBox_Value    = 3 : ListBoxTable(ListBox_Value)    = "`Value` CHAR(64) NOT NULL"
Const ListBox_Text     = 4 : ListBoxTable(ListBox_Text)     = "`Text` CHAR(64) LOCALIZABLE"
Dim   ListViewTable(5)      : ListViewTable(0)                 = "`ListView`"
Const ListView_Property = 1 : ListViewTable(ListView_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const ListView_Order    = 2 : ListViewTable(ListView_Order)    = "`Order` SHORT NOT NULL PRIMARY KEY"
Const ListView_Value    = 3 : ListViewTable(ListView_Value)    = "`Value` CHAR(64) NOT NULL"
Const ListView_Text     = 4 : ListViewTable(ListView_Text)     = "`Text` CHAR(64) LOCALIZABLE"
Const ListView_Binary_  = 5 : ListViewTable(ListView_Binary_)  = "`Binary_` CHAR(72)"
Dim   LockPermissionsTable(5)        : LockPermissionsTable(0)                          = "`LockPermissions`"
Const LockPermissions_LockObject = 1 : LockPermissionsTable(LockPermissions_LockObject) = "`LockObject` CHAR(72) NOT NULL PRIMARY KEY"
Const LockPermissions_Table      = 2 : LockPermissionsTable(LockPermissions_Table)      = "`Table` CHAR(32) NOT NULL PRIMARY KEY"
Const LockPermissions_Domain     = 3 : LockPermissionsTable(LockPermissions_Domain)     = "`Domain` CHAR(255) PRIMARY KEY"
Const LockPermissions_User       = 4 : LockPermissionsTable(LockPermissions_User)       = "`User` CHAR(255) NOT NULL PRIMARY KEY"
Const LockPermissions_Permission = 5 : LockPermissionsTable(LockPermissions_Permission) = "`Permission` LONG"
Dim   MIMETable(3)         : MIMETable(0)                = "`MIME`"
Const MIME_ContentType = 1 : MIMETable(MIME_ContentType) = "`ContentType` CHAR(64) NOT NULL PRIMARY KEY"
Const MIME_Extension_  = 2 : MIMETable(MIME_Extension_)  = "`Extension_` CHAR(255) NOT NULL"
Const MIME_CLSID       = 3 : MIMETable(MIME_CLSID)       = "`CLSID` CHAR(38)"
Dim   MediaTable(6)          : MediaTable(0)                  = "`Media`"
Const Media_DiskId       = 1 : MediaTable(Media_DiskId)       = "`DiskId` SHORT NOT NULL PRIMARY KEY"
Const Media_LastSequence = 2 : MediaTable(Media_LastSequence) = "`LastSequence` SHORT NOT NULL"
Const Media_DiskPrompt   = 3 : MediaTable(Media_DiskPrompt)   = "`DiskPrompt` CHAR(64) LOCALIZABLE"
Const Media_Cabinet      = 4 : MediaTable(Media_Cabinet)      = "`Cabinet` CHAR(255)"
Const Media_VolumeLabel  = 5 : MediaTable(Media_VolumeLabel)  = "`VolumeLabel` CHAR(32)"
Const Media_Source       = 6 : MediaTable(Media_Source)       = "`Source` CHAR(32)"
Dim   MoveFileTable(7)          : MoveFileTable(0)                     = "`MoveFile`"
Const MoveFile_FileKey      = 1 : MoveFileTable(MoveFile_FileKey)      = "`FileKey` CHAR(72) NOT NULL PRIMARY KEY"
Const MoveFile_Component_   = 2 : MoveFileTable(MoveFile_Component_)   = "`Component_` CHAR(72) NOT NULL"
Const MoveFile_SourceName   = 3 : MoveFileTable(MoveFile_SourceName)   = "`SourceName` CHAR(255) LOCALIZABLE"
Const MoveFile_DestName     = 4 : MoveFileTable(MoveFile_DestName)     = "`DestName` CHAR(255) LOCALIZABLE"
Const MoveFile_SourceFolder = 5 : MoveFileTable(MoveFile_SourceFolder) = "`SourceFolder` CHAR(72)"
Const MoveFile_DestFolder   = 6 : MoveFileTable(MoveFile_DestFolder)   = "`DestFolder` CHAR(72) NOT NULL"
Const MoveFile_Options      = 7 : MoveFileTable(MoveFile_Options)      = "`Options` SHORT NOT NULL"
Dim   ODBCAttributeTable(3)       : ODBCAttributeTable(0)                       = "`ODBCAttribute`"
Const ODBCAttribute_Driver_   = 1 : ODBCAttributeTable(ODBCAttribute_Driver_)   = "`Driver_` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCAttribute_Attribute = 2 : ODBCAttributeTable(ODBCAttribute_Attribute) = "`Attribute` CHAR(40) NOT NULL PRIMARY KEY"
Const ODBCAttribute_Value     = 3 : ODBCAttributeTable(ODBCAttribute_Value)     = "`Value` CHAR(255) LOCALIZABLE"
Dim   ODBCDataSourceTable(5)               : ODBCDataSourceTable(0)                                = "`ODBCDataSource`"
Const ODBCDataSource_DataSource        = 1 : ODBCDataSourceTable(ODBCDataSource_DataSource)        = "`DataSource` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCDataSource_Component_        = 2 : ODBCDataSourceTable(ODBCDataSource_Component_)        = "`Component_` CHAR(72) NOT NULL"
Const ODBCDataSource_Description       = 3 : ODBCDataSourceTable(ODBCDataSource_Description)       = "`Description` CHAR(255) NOT NULL"
Const ODBCDataSource_DriverDescription = 4 : ODBCDataSourceTable(ODBCDataSource_DriverDescription) = "`DriverDescription` CHAR(255) NOT NULL"
Const ODBCDataSource_Registration      = 5 : ODBCDataSourceTable(ODBCDataSource_Registration)      = "`Registration` SHORT NOT NULL"
Dim   ODBCDriverTable(5)         : ODBCDriverTable(0)                      = "`ODBCDriver`"
Const ODBCDriver_Driver      = 1 : ODBCDriverTable(ODBCDriver_Driver)      = "`Driver` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCDriver_Component_  = 2 : ODBCDriverTable(ODBCDriver_Component_)  = "`Component_` CHAR(72) NOT NULL"
Const ODBCDriver_Description = 3 : ODBCDriverTable(ODBCDriver_Description) = "`Description` CHAR(255) NOT NULL"
Const ODBCDriver_File_       = 4 : ODBCDriverTable(ODBCDriver_File_)       = "`File_` CHAR(72) NOT NULL"
Const ODBCDriver_File_Setup  = 5 : ODBCDriverTable(ODBCDriver_File_Setup)  = "`File_Setup` CHAR(72)"
Dim   ODBCSourceAttributeTable(3)         : ODBCSourceAttributeTable(0)                               = "`ODBCSourceAttribute`"
Const ODBCSourceAttribute_DataSource_ = 1 : ODBCSourceAttributeTable(ODBCSourceAttribute_DataSource_) = "`DataSource_` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCSourceAttribute_Attribute   = 2 : ODBCSourceAttributeTable(ODBCSourceAttribute_Attribute)   = "`Attribute` CHAR(32) NOT NULL PRIMARY KEY"
Const ODBCSourceAttribute_Value       = 3 : ODBCSourceAttributeTable(ODBCSourceAttribute_Value)       = "`Value` CHAR(255) LOCALIZABLE"
Dim   ODBCTranslatorTable(5)         : ODBCTranslatorTable(0)                          = "`ODBCTranslator`"
Const ODBCTranslator_Translator  = 1 : ODBCTranslatorTable(ODBCTranslator_Translator)  = "`Translator` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCTranslator_Component_  = 2 : ODBCTranslatorTable(ODBCTranslator_Component_)  = "`Component_` CHAR(72) NOT NULL"
Const ODBCTranslator_Description = 3 : ODBCTranslatorTable(ODBCTranslator_Description) = "`Description` CHAR(255) NOT NULL"
Const ODBCTranslator_File_       = 4 : ODBCTranslatorTable(ODBCTranslator_File_)       = "`File_` CHAR(72) NOT NULL"
Const ODBCTranslator_File_Setup  = 5 : ODBCTranslatorTable(ODBCTranslator_File_Setup)  = "`File_Setup` CHAR(72)"
Dim   PatchTable(5)        : PatchTable(0)                = "`Patch`"
Const Patch_File_      = 1 : PatchTable(Patch_File_)      = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const Patch_Sequence   = 2 : PatchTable(Patch_Sequence)   = "`Sequence` SHORT NOT NULL PRIMARY KEY"
Const Patch_PatchSize  = 3 : PatchTable(Patch_PatchSize)  = "`PatchSize` LONG NOT NULL"
Const Patch_Attributes = 4 : PatchTable(Patch_Attributes) = "`Attributes` SHORT NOT NULL"
Const Patch_Header     = 5 : PatchTable(Patch_Header)     = "`Header` OBJECT NOT NULL"
Dim   PatchPackageTable(2)     : PatchPackageTable(0)                    = "`PatchPackage`"
Const PatchPackage_PatchId = 1 : PatchPackageTable(PatchPackage_PatchId) = "`PatchId` CHAR(38) NOT NULL PRIMARY KEY"
Const PatchPackage_Media_  = 2 : PatchPackageTable(PatchPackage_Media_)  = "`Media_` SHORT NOT NULL"
Dim   ProgIdTable(6)           : ProgIdTable(0)                    = "`ProgId`"
Const ProgId_ProgId        = 1 : ProgIdTable(ProgId_ProgId)        = "`ProgId` CHAR(255) NOT NULL PRIMARY KEY"
Const ProgId_ProgId_Parent = 2 : ProgIdTable(ProgId_ProgId_Parent) = "`ProgId_Parent` CHAR(255)"
Const ProgId_Class_        = 3 : ProgIdTable(ProgId_Class_)        = "`Class_` CHAR(38)"
Const ProgId_Description   = 4 : ProgIdTable(ProgId_Description)   = "`Description` CHAR(255) LOCALIZABLE"
Const ProgId_Icon_         = 5 : ProgIdTable(ProgId_Icon_)         = "`Icon_` CHAR(72)"
Const ProgId_IconIndex     = 6 : ProgIdTable(ProgId_IconIndex)     = "`IconIndex` SHORT"
Dim   PropertyTable(2)      : PropertyTable(0)                 = "`Property`"
Const Property_Property = 1 : PropertyTable(Property_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const Property_Value    = 2 : PropertyTable(Property_Value)    = "`Value` LONGCHAR NOT NULL LOCALIZABLE"
Dim   PublishComponentTable(5)         : PublishComponentTable(0)                            = "`PublishComponent`"
Const PublishComponent_ComponentId = 1 : PublishComponentTable(PublishComponent_ComponentId) = "`ComponentId` CHAR(38) NOT NULL PRIMARY KEY"
Const PublishComponent_Qualifier   = 2 : PublishComponentTable(PublishComponent_Qualifier)   = "`Qualifier` CHAR(255) NOT NULL PRIMARY KEY"
Const PublishComponent_Component_  = 3 : PublishComponentTable(PublishComponent_Component_)  = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const PublishComponent_AppData     = 4 : PublishComponentTable(PublishComponent_AppData)     = "`AppData` CHAR(255) LOCALIZABLE"
Const PublishComponent_Feature_    = 5 : PublishComponentTable(PublishComponent_Feature_)    = "`Feature_` CHAR(38) NOT NULL"
Dim   RadioButtonTable(9)      : RadioButtonTable(0)                    = "`RadioButton`"
Const RadioButton_Property = 1 : RadioButtonTable(RadioButton_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const RadioButton_Order    = 2 : RadioButtonTable(RadioButton_Order)    = "`Order` SHORT NOT NULL PRIMARY KEY"
Const RadioButton_Value    = 3 : RadioButtonTable(RadioButton_Value)    = "`Value` CHAR(64) NOT NULL"
Const RadioButton_X        = 4 : RadioButtonTable(RadioButton_X)        = "`X` SHORT NOT NULL"
Const RadioButton_Y        = 5 : RadioButtonTable(RadioButton_Y)        = "`Y` SHORT NOT NULL"
Const RadioButton_Width    = 6 : RadioButtonTable(RadioButton_Width)    = "`Width` SHORT NOT NULL"
Const RadioButton_Height   = 7 : RadioButtonTable(RadioButton_Height)   = "`Height` SHORT NOT NULL"
Const RadioButton_Text     = 8 : RadioButtonTable(RadioButton_Text)     = "`Text` CHAR(64) LOCALIZABLE"
Const RadioButton_Help     = 9 : RadioButtonTable(RadioButton_Help)     = "`Help` CHAR(50) LOCALIZABLE"
Dim   RegLocatorTable(5)        : RegLocatorTable(0)                     = "`RegLocator`"
Const RegLocator_Signature_ = 1 : RegLocatorTable(RegLocator_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Const RegLocator_Root       = 2 : RegLocatorTable(RegLocator_Root)       = "`Root` SHORT NOT NULL"
Const RegLocator_Key        = 3 : RegLocatorTable(RegLocator_Key)        = "`Key` CHAR(255) NOT NULL"
Const RegLocator_Name       = 4 : RegLocatorTable(RegLocator_Name)       = "`Name` CHAR(255)"
Const RegLocator_Type       = 5 : RegLocatorTable(RegLocator_Type)       = "`Type` SHORT"
Dim   RegistryTable(6)        : RegistryTable(0)                   = "`Registry`"
Const Registry_Registry   = 1 : RegistryTable(Registry_Registry)   = "`Registry` CHAR(72) NOT NULL PRIMARY KEY"
Const Registry_Root       = 2 : RegistryTable(Registry_Root)       = "`Root` SHORT NOT NULL"
Const Registry_Key        = 3 : RegistryTable(Registry_Key)        = "`Key` CHAR(255) NOT NULL LOCALIZABLE"
Const Registry_Name       = 4 : RegistryTable(Registry_Name)       = "`Name` CHAR(255) LOCALIZABLE"
Const Registry_Value      = 5 : RegistryTable(Registry_Value)      = "`Value` LONGCHAR LOCALIZABLE"
Const Registry_Component_ = 6 : RegistryTable(Registry_Component_) = "`Component_` CHAR(72) NOT NULL"
Dim   RemoveFileTable(5)         : RemoveFileTable(0)                      = "`RemoveFile`"
Const RemoveFile_FileKey     = 1 : RemoveFileTable(RemoveFile_FileKey)     = "`FileKey` CHAR(72) NOT NULL PRIMARY KEY"
Const RemoveFile_Component_  = 2 : RemoveFileTable(RemoveFile_Component_)  = "`Component_` CHAR(72) NOT NULL"
Const RemoveFile_FileName    = 3 : RemoveFileTable(RemoveFile_FileName)    = "`FileName` CHAR(255) LOCALIZABLE"
Const RemoveFile_DirProperty = 4 : RemoveFileTable(RemoveFile_DirProperty) = "`DirProperty` CHAR(72) NOT NULL"
Const RemoveFile_InstallMode = 5 : RemoveFileTable(RemoveFile_InstallMode) = "`InstallMode` SHORT NOT NULL"
Dim   RemoveIniFileTable(8)           : RemoveIniFileTable(0)                           = "`RemoveIniFile`"
Const RemoveIniFile_RemoveIniFile = 1 : RemoveIniFileTable(RemoveIniFile_RemoveIniFile) = "`RemoveIniFile` CHAR(72) NOT NULL PRIMARY KEY"
Const RemoveIniFile_FileName      = 2 : RemoveIniFileTable(RemoveIniFile_FileName)      = "`FileName` CHAR(255) NOT NULL LOCALIZABLE"
Const RemoveIniFile_DirProperty   = 3 : RemoveIniFileTable(RemoveIniFile_DirProperty)   = "`DirProperty` CHAR(72)"
Const RemoveIniFile_Section       = 4 : RemoveIniFileTable(RemoveIniFile_Section)       = "`Section` CHAR(96) NOT NULL LOCALIZABLE"
Const RemoveIniFile_Key           = 5 : RemoveIniFileTable(RemoveIniFile_Key)           = "`Key` CHAR(128) NOT NULL LOCALIZABLE"
Const RemoveIniFile_Value         = 6 : RemoveIniFileTable(RemoveIniFile_Value)         = "`Value` CHAR(255) LOCALIZABLE"
Const RemoveIniFile_Action        = 7 : RemoveIniFileTable(RemoveIniFile_Action)        = "`Action` SHORT NOT NULL"
Const RemoveIniFile_Component_    = 8 : RemoveIniFileTable(RemoveIniFile_Component_)    = "`Component_` CHAR(72) NOT NULL"
Dim   RemoveRegistryTable(5)            : RemoveRegistryTable(0)                             = "`RemoveRegistry`"
Const RemoveRegistry_RemoveRegistry = 1 : RemoveRegistryTable(RemoveRegistry_RemoveRegistry) = "`RemoveRegistry` CHAR(72) NOT NULL PRIMARY KEY"
Const RemoveRegistry_Root           = 2 : RemoveRegistryTable(RemoveRegistry_Root)           = "`Root` SHORT NOT NULL"
Const RemoveRegistry_Key            = 3 : RemoveRegistryTable(RemoveRegistry_Key)            = "`Key` CHAR(255) NOT NULL LOCALIZABLE"
Const RemoveRegistry_Name           = 4 : RemoveRegistryTable(RemoveRegistry_Name)           = "`Name` CHAR(255) LOCALIZABLE"
Const RemoveRegistry_Component_     = 5 : RemoveRegistryTable(RemoveRegistry_Component_)     = "`Component_` CHAR(72) NOT NULL"
Dim   ReserveCostTable(5)           : ReserveCostTable(0)                         = "`ReserveCost`"
Const ReserveCost_ReserveKey    = 1 : ReserveCostTable(ReserveCost_ReserveKey)    = "`ReserveKey` CHAR(72) NOT NULL PRIMARY KEY"
Const ReserveCost_Component_    = 2 : ReserveCostTable(ReserveCost_Component_)    = "`Component_` CHAR(72) NOT NULL"
Const ReserveCost_ReserveFolder = 3 : ReserveCostTable(ReserveCost_ReserveFolder) = "`ReserveFolder` CHAR(72)"
Const ReserveCost_ReserveLocal  = 4 : ReserveCostTable(ReserveCost_ReserveLocal)  = "`ReserveLocal` LONG NOT NULL"
Const ReserveCost_ReserveSource = 5 : ReserveCostTable(ReserveCost_ReserveSource) = "`ReserveSource` LONG NOT NULL"
Dim   SelfRegTable(2)   : SelfRegTable(0)             = "`SelfReg`"
Const SelfReg_File_ = 1 : SelfRegTable(SelfReg_File_) = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const SelfReg_Cost  = 2 : SelfRegTable(SelfReg_Cost)  = "`Cost` SHORT"
Dim   ServiceControlTable(6)            : ServiceControlTable(0)                             = "`ServiceControl`"
Const ServiceControl_ServiceControl = 1 : ServiceControlTable(ServiceControl_ServiceControl) = "`ServiceControl` CHAR(72) NOT NULL PRIMARY KEY"
Const ServiceControl_Name           = 2 : ServiceControlTable(ServiceControl_Name)           = "`Name` CHAR(255) NOT NULL LOCALIZABLE"
Const ServiceControl_Event          = 3 : ServiceControlTable(ServiceControl_Event)          = "`Event` SHORT NOT NULL"
Const ServiceControl_Arguments      = 4 : ServiceControlTable(ServiceControl_Arguments)      = "`Arguments` CHAR(255) LOCALIZABLE"
Const ServiceControl_Wait           = 5 : ServiceControlTable(ServiceControl_Wait)           = "`Wait` SHORT"
Const ServiceControl_Component_     = 6 : ServiceControlTable(ServiceControl_Component_)     = "`Component_` CHAR(72) NOT NULL"
Dim   ServiceInstallTable(13)           : ServiceInstallTable(0)                             = "`ServiceInstall`"
Const ServiceInstall_ServiceInstall = 1 : ServiceInstallTable(ServiceInstall_ServiceInstall) = "`ServiceInstall` CHAR(72) NOT NULL PRIMARY KEY"
Const ServiceInstall_Name           = 2 : ServiceInstallTable(ServiceInstall_Name)           = "`Name` CHAR(255) NOT NULL"
Const ServiceInstall_DisplayName    = 3 : ServiceInstallTable(ServiceInstall_DisplayName)    = "`DisplayName` CHAR(255) LOCALIZABLE"
Const ServiceInstall_ServiceType    = 4 : ServiceInstallTable(ServiceInstall_ServiceType)    = "`ServiceType` LONG NOT NULL"
Const ServiceInstall_StartType      = 5 : ServiceInstallTable(ServiceInstall_StartType)      = "`StartType` LONG NOT NULL"
Const ServiceInstall_ErrorControl   = 6 : ServiceInstallTable(ServiceInstall_ErrorControl)   = "`ErrorControl` LONG NOT NULL"
Const ServiceInstall_LoadOrderGroup = 7 : ServiceInstallTable(ServiceInstall_LoadOrderGroup) = "`LoadOrderGroup` CHAR(255)"
Const ServiceInstall_Dependencies   = 8 : ServiceInstallTable(ServiceInstall_Dependencies)   = "`Dependencies` CHAR(255)"
Const ServiceInstall_StartName      = 9 : ServiceInstallTable(ServiceInstall_StartName)      = "`StartName` CHAR(255)"
Const ServiceInstall_Password       =10 : ServiceInstallTable(ServiceInstall_Password)       = "`Password` CHAR(255)"
Const ServiceInstall_Arguments      =11 : ServiceInstallTable(ServiceInstall_Arguments)      = "`Arguments` CHAR(255)"
Const ServiceInstall_Component_     =12 : ServiceInstallTable(ServiceInstall_Component_)     = "`Component_` CHAR(72) NOT NULL"
Const ServiceInstall_Description    =13 : ServiceInstallTable(ServiceInstall_Description)    = "`Description` CHAR(255) LOCALIZABLE"
Dim   ShortcutTable(12)        : ShortcutTable(0)                    = "`Shortcut`"
Const Shortcut_Shortcut    = 1 : ShortcutTable(Shortcut_Shortcut)    = "`Shortcut` CHAR(72) NOT NULL PRIMARY KEY"
Const Shortcut_Directory_  = 2 : ShortcutTable(Shortcut_Directory_)  = "`Directory_` CHAR(72) NOT NULL"
Const Shortcut_Name        = 3 : ShortcutTable(Shortcut_Name)        = "`Name` CHAR(128) NOT NULL LOCALIZABLE"
Const Shortcut_Component_  = 4 : ShortcutTable(Shortcut_Component_)  = "`Component_` CHAR(72) NOT NULL"
Const Shortcut_Target      = 5 : ShortcutTable(Shortcut_Target)      = "`Target` CHAR(72) NOT NULL"
Const Shortcut_Arguments   = 6 : ShortcutTable(Shortcut_Arguments)   = "`Arguments` CHAR(255)"
Const Shortcut_Description = 7 : ShortcutTable(Shortcut_Description) = "`Description` CHAR(255) LOCALIZABLE"
Const Shortcut_Hotkey      = 8 : ShortcutTable(Shortcut_Hotkey)      = "`Hotkey` SHORT"
Const Shortcut_Icon_       = 9 : ShortcutTable(Shortcut_Icon_)       = "`Icon_` CHAR(72)"
Const Shortcut_IconIndex   =10 : ShortcutTable(Shortcut_IconIndex)   = "`IconIndex` SHORT"
Const Shortcut_ShowCmd     =11 : ShortcutTable(Shortcut_ShowCmd)     = "`ShowCmd` SHORT"
Const Shortcut_WkDir       =12 : ShortcutTable(Shortcut_WkDir)       = "`WkDir` CHAR(72)"
Dim   SignatureTable(9)        : SignatureTable(0)                    = "`Signature`"
Const Signature_Signature  = 1 : SignatureTable(Signature_Signature)  = "`Signature` CHAR(72) NOT NULL PRIMARY KEY"
Const Signature_FileName   = 2 : SignatureTable(Signature_FileName)   = "`FileName` CHAR(255) NOT NULL"
Const Signature_MinVersion = 3 : SignatureTable(Signature_MinVersion) = "`MinVersion` CHAR(20)"
Const Signature_MaxVersion = 4 : SignatureTable(Signature_MaxVersion) = "`MaxVersion` CHAR(20)"
Const Signature_MinSize    = 5 : SignatureTable(Signature_MinSize)    = "`MinSize` LONG"
Const Signature_MaxSize    = 6 : SignatureTable(Signature_MaxSize)    = "`MaxSize` LONG"
Const Signature_MinDate    = 7 : SignatureTable(Signature_MinDate)    = "`MinDate` LONG"
Const Signature_MaxDate    = 8 : SignatureTable(Signature_MaxDate)    = "`MaxDate` LONG"
Const Signature_Languages  = 9 : SignatureTable(Signature_Languages)  = "`Languages` CHAR(255)"
Dim   TextStyleTable(5)       : TextStyleTable(0)                   = "`TextStyle`"
Const TextStyle_TextStyle = 1 : TextStyleTable(TextStyle_TextStyle) = "`TextStyle` CHAR(72) NOT NULL PRIMARY KEY"
Const TextStyle_FaceName  = 2 : TextStyleTable(TextStyle_FaceName)  = "`FaceName` CHAR(32) NOT NULL"
Const TextStyle_Size      = 3 : TextStyleTable(TextStyle_Size)      = "`Size` SHORT NOT NULL"
Const TextStyle_Color     = 4 : TextStyleTable(TextStyle_Color)     = "`Color` LONG"
Const TextStyle_StyleBits = 5 : TextStyleTable(TextStyle_StyleBits) = "`StyleBits` SHORT"
Dim   TypeLibTable(8)         : TypeLibTable(0)                   = "`TypeLib`"
Const TypeLib_LibID       = 1 : TypeLibTable(TypeLib_LibID)       = "`LibID` CHAR(38) NOT NULL PRIMARY KEY"
Const TypeLib_Language    = 2 : TypeLibTable(TypeLib_Language)    = "`Language` SHORT NOT NULL PRIMARY KEY"
Const TypeLib_Component_  = 3 : TypeLibTable(TypeLib_Component_)  = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const TypeLib_Version     = 4 : TypeLibTable(TypeLib_Version)     = "`Version` SHORT"
Const TypeLib_Description = 5 : TypeLibTable(TypeLib_Description) = "`Description` CHAR(128) LOCALIZABLE"
Const TypeLib_Directory_  = 6 : TypeLibTable(TypeLib_Directory_)  = "`Directory_` CHAR(72)"
Const TypeLib_Feature_    = 7 : TypeLibTable(TypeLib_Feature_)    = "`Feature_` CHAR(38)"
Const TypeLib_Cost        = 8 : TypeLibTable(TypeLib_Cost)        = "`Cost` LONG"
Dim   UITextTable(2)  : UITextTable(0)           = "`UIText`"
Const UIText_Key  = 1 : UITextTable(UIText_Key)  = "`Key` CHAR(72) NOT NULL PRIMARY KEY"
Const UIText_Text = 2 : UITextTable(UIText_Text) = "`Text` CHAR(255) LOCALIZABLE"
Dim   UpgradeTable(7)            : UpgradeTable(0)                      = "`Upgrade`"
Const Upgrade_UpgradeCode    = 1 : UpgradeTable(Upgrade_UpgradeCode)    = "`UpgradeCode` CHAR(38) NOT NULL PRIMARY KEY"
Const Upgrade_VersionMin     = 2 : UpgradeTable(Upgrade_VersionMin)     = "`VersionMin` CHAR(20) PRIMARY KEY"
Const Upgrade_VersionMax     = 3 : UpgradeTable(Upgrade_VersionMax)     = "`VersionMax` CHAR(20) PRIMARY KEY"
Const Upgrade_Language       = 4 : UpgradeTable(Upgrade_Language)       = "`Language` CHAR(255) PRIMARY KEY"
Const Upgrade_Attributes     = 5 : UpgradeTable(Upgrade_Attributes)     = "`Attributes` LONG NOT NULL PRIMARY KEY"
Const Upgrade_Remove         = 6 : UpgradeTable(Upgrade_Remove)         = "`Remove` CHAR(255)"
Const Upgrade_ActionProperty = 7 : UpgradeTable(Upgrade_ActionProperty) = "`ActionProperty` CHAR(72) NOT NULL"
Dim   VerbTable(5)        : VerbTable(0)               = "`Verb`"
Const Verb_Extension_ = 1 : VerbTable(Verb_Extension_) = "`Extension_` CHAR(255) NOT NULL PRIMARY KEY"
Const Verb_Verb       = 2 : VerbTable(Verb_Verb)       = "`Verb` CHAR(32) NOT NULL PRIMARY KEY"
Const Verb_Sequence   = 3 : VerbTable(Verb_Sequence)   = "`Sequence` SHORT"
Const Verb_Command    = 4 : VerbTable(Verb_Command)    = "`Command` CHAR(255) LOCALIZABLE"
Const Verb_Argument   = 5 : VerbTable(Verb_Argument)   = "`Argument` CHAR(255) LOCALIZABLE"
Dim   ValidationTable(10)        : ValidationTable(0)                      = "`_Validation`"
Const Validation_Table       = 1 : ValidationTable(Validation_Table)       = "`Table` CHAR(32) NOT NULL PRIMARY KEY"
Const Validation_Column      = 2 : ValidationTable(Validation_Column)      = "`Column` CHAR(32) NOT NULL PRIMARY KEY"
Const Validation_Nullable    = 3 : ValidationTable(Validation_Nullable)    = "`Nullable` CHAR(4) NOT NULL"
Const Validation_MinValue    = 4 : ValidationTable(Validation_MinValue)    = "`MinValue` LONG"
Const Validation_MaxValue    = 5 : ValidationTable(Validation_MaxValue)    = "`MaxValue` LONG"
Const Validation_KeyTable    = 6 : ValidationTable(Validation_KeyTable)    = "`KeyTable` CHAR(255)"
Const Validation_KeyColumn   = 7 : ValidationTable(Validation_KeyColumn)   = "`KeyColumn` SHORT"
Const Validation_Category    = 8 : ValidationTable(Validation_Category)    = "`Category` CHAR(32)"
Const Validation_Set         = 9 : ValidationTable(Validation_Set)         = "`Set` CHAR(255)"
Const Validation_Description =10 : ValidationTable(Validation_Description) = "`Description` CHAR(255)"

' windows installer 1.5 tables
Dim MsiAssemblyTable(5): MsiAssemblyTable(0) = "`MsiAssembly`"
Const MsiAssembly_Component_ = 1 : MsiAssemblyTable(MsiAssembly_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiAssembly_Feature_ = 2 : MsiAssemblyTable(MsiAssembly_Feature_) = "`Feature_` CHAR(38) NOT NULL"
Const MsiAssembly_File_Manifest = 3 : MsiAssemblyTable(MsiAssembly_File_Manifest)  = "`File_Manifest` CHAR(72)"
Const MsiAssembly_File_Application = 4 : MsiAssemblyTable(MsiAssembly_File_Application)  = "`File_Application` CHAR(72)"
Const MsiAssembly_Attributes = 5 : MsiAssemblyTable(MsiAssembly_Attributes)  = "`Attributes` SHORT NOT NULL"
Dim MsiAssemblyNameTable(3): MsiAssemblyNameTable(0) = "`MsiAssemblyName`"
Const MsiAssemblyName_Component_ = 1 : MsiAssemblyNameTable(MsiAssemblyName_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiAssemblyName_Name = 2 : MsiAssemblyNameTable(MsiAssemblyName_Name) = "`Name` CHAR(255) NOT NULL PRIMARY KEY"
Const MsiAssemblyName_Value  = 3 : MsiAssemblyNameTable(MsiAssemblyName_Value)  = "`Value` CHAR(255)"
Dim MsiDigitalCertificateTable(2): MsiDigitalCertificateTable(0) = "`MsiDigitalCertificate`"
Const MsiDigitalCertificate_DigitalCertificate = 1 : MsiDigitalCertificateTable(MsiDigitalCertificate_DigitalCertificate) = "`DigitalCertificate` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiDigitalCertificate_CertData = 2 : MsiDigitalCertificateTable(MsiDigitalCertificate_CertData) = "`CertData` OBJECT NOT NULL"
Dim MsiDigitalSignatureTable(4): MsiDigitalSignatureTable(0) = "`MsiDigitalSignature`"
Const MsiDigitalSignature_Table = 1 : MsiDigitalSignatureTable(MsiDigitalSignature_Table) = "`Table` CHAR(32) NOT NULL PRIMARY KEY"
Const MsiDigitalSignature_SignObject = 2 : MsiDigitalSignatureTable(MsiDigitalSignature_SignObject) = "`SignObject` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiDigitalSignature_DigitalCertificate_ = 3 : MsiDigitalSignatureTable(MsiDigitalSignature_DigitalCertificate_)  = "`DigitalCertificate_` CHAR(72) NOT NULL"
Const MsiDigitalSignature_Hash = 4 : MsiDigitalSignatureTable(MsiDigitalSignature_Hash)  = "`Hash` OBJECT"
Dim MsiFileHashTable(6): MsiFileHashTable(0) = "`MsiFileHash`"
Const MsiFileHash_File_ = 1 : MsiFileHashTable(MsiFileHash_File_) = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiFileHash_Options = 2 : MsiFileHashTable(MsiFileHash_Options) = "`Options` SHORT NOT NULL"
Const MsiFileHash_HashPart1 = 3 : MsiFileHashTable(MsiFileHash_HashPart1) = "`HashPart1` LONG NOT NULL"
Const MsiFileHash_HashPart2 = 4 : MsiFileHashTable(MsiFileHash_HashPart2) = "`HashPart2` LONG NOT NULL"
Const MsiFileHash_HashPart3 = 5 : MsiFileHashTable(MsiFileHash_HashPart3) = "`HashPart3` LONG NOT NULL"
Const MsiFileHash_HashPart4 = 6 : MsiFileHashTable(MsiFileHash_HashPart4) = "`HashPart4` LONG NOT NULL"

' merge module only tables
Dim   ModuleSignatureTable(3): ModuleSignatureTable(0)        = "`ModuleSignature`"
Const ModuleSignature_ModuleID = 1 : ModuleSignatureTable(ModuleSignature_ModuleID) = "`ModuleID` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleSignature_Language = 2 : ModuleSignatureTable(ModuleSignature_Language) = "`Language` SHORT NOT NULL PRIMARY KEY"
Const ModuleSignature_Version  = 3 : ModuleSignatureTable(ModuleSignature_Version)  = "`Version` CHAR(72) NOT NULL"
Dim   ModuleComponentsTable(3): ModuleComponentsTable(0)         = "`ModuleComponents`"
Const ModuleComponents_Component  = 1 : ModuleComponentsTable(ModuleComponents_Component)  = "`Component` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleComponents_ModuleID   = 2 : ModuleComponentsTable(ModuleComponents_ModuleID)   = "`ModuleID` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleComponents_Language   = 3 : ModuleComponentsTable(ModuleComponents_Language)   = "`Language` SHORT NOT NULL PRIMARY KEY"
Dim   ModuleDependencyTable(5)              : ModuleDependencyTable(0)                                 = "`ModuleDependency`"
Const ModuleDependency_ModuleID         = 1 : ModuleDependencyTable(ModuleDependency_ModuleID)         = "`ModuleID` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleDependency_ModuleLanguage   = 2 : ModuleDependencyTable(ModuleDependency_ModuleLanguage)   = "`ModuleLanguage` SHORT NOT NULL PRIMARY KEY"
Const ModuleDependency_RequiredID       = 3 : ModuleDependencyTable(ModuleDependency_RequiredID)       = "`RequiredID` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleDependency_RequiredLanguage = 4 : ModuleDependencyTable(ModuleDependency_RequiredLanguage) = "`RequiredLanguage` SHORT NOT NULL PRIMARY KEY"
Const ModuleDependency_RequiredVersion  = 5 : ModuleDependencyTable(ModuleDependency_RequiredVersion)  = "`RequiredVersion` CHAR(72)"

' patching tables
Dim   ExternalFilesTable(8)           : ExternalFilesTable(0)                           = "`ExternalFiles`"
Const ExternalFiles_Family        = 1 : ExternalFilesTable(ExternalFiles_Family)        = "`Family` CHAR(8) NOT NULL PRIMARY KEY"
Const ExternalFiles_FTK           = 2 : ExternalFilesTable(ExternalFiles_FTK)           = "`FTK` CHAR(128) NOT NULL PRIMARY KEY"
Const ExternalFiles_FilePath      = 3 : ExternalFilesTable(ExternalFiles_FilePath)      = "`FilePath` CHAR(255) NOT NULL PRIMARY KEY"
Const ExternalFiles_SymbolPaths   = 4 : ExternalFilesTable(ExternalFiles_SymbolPaths)   = "`SymbolPaths` CHAR(255)"
Const ExternalFiles_IgnoreOffsets = 5 : ExternalFilesTable(ExternalFiles_IgnoreOffsets) = "`IgnoreOffsets` CHAR(255)"
Const ExternalFiles_IgnoreLengths = 6 : ExternalFilesTable(ExternalFiles_IgnoreLengths) = "`IgnoreLengths` CHAR(255)"
Const ExternalFiles_RetainOffsets = 7 : ExternalFilesTable(ExternalFiles_RetainOffsets) = "`RetainOffsets` CHAR(255)"
Const ExternalFiles_Order         = 8 : ExternalFilesTable(ExternalFiles_Order)         = "`Order` SHORT NOT NULL"
Dim   FamilyFileRangesTable(4)               : FamilyFileRangesTable(0)                             = "`FamilyFileRanges`"
Const FamilyFileRanges_Family         = 1 : FamilyFileRangesTable(FamilyFileRanges_Family)          = "`Family` CHAR(8) NOT NULL PRIMARY KEY"
Const FamilyFileRanges_FTK           = 2 : FamilyFileRangesTable(FamilyFileRanges_FTK)           = "`FTK` CHAR(128) NOT NULL PRIMARY KEY"
Const FamilyFileRanges_RetainOffsets = 3 : FamilyFileRangesTable(FamilyFileRanges_RetainOffsets) = "`RetainOffsets` CHAR(128) NOT NULL"
Const FamilyFileRanges_RetainLengths = 4 : FamilyFileRangesTable(FamilyFileRanges_RetainLengths) = "`RetainLengths` CHAR(128) NOT NULL"
Dim   ImageFamiliesTable(6)               : ImageFamiliesTable(0)                              = "`ImageFamilies`"
Const ImageFamilies_Family            = 1 : ImageFamiliesTable(ImageFamilies_Family)           = "`Family` CHAR(8) NOT NULL PRIMARY KEY"
Const ImageFamilies_MediaSrcPropName  = 2 : ImageFamiliesTable(ImageFamilies_MediaSrcPropName) = "`MediaSrcPropName` CHAR(72) NOT NULL"
Const ImageFamilies_MediaDiskId       = 3 : ImageFamiliesTable(ImageFamilies_MediaDiskId)      = "`MediaDiskId` SHORT NOT NULL"
Const ImageFamilies_FileSequenceStart = 4 : ImageFamiliesTable(ImageFamilies_FileSequenceStart)= "`FileSequenceStart` SHORT NOT NULL"
Const ImageFamilies_DiskPrompt        = 5 : ImageFamiliesTable(ImageFamilies_DiskPrompt)       = "`DiskPrompt` CHAR(128)"
Const ImageFamilies_VolumeLabel       = 6 : ImageFamiliesTable(ImageFamilies_VolumeLabel)      = "`VolumeLabel` CHAR(32)"
Dim   PropertiesTable(2)      : PropertiesTable(0)                   = "`Properties`"
Const Properties_Name = 1 : PropertiesTable(Properties_Name) = "`Name` CHAR(72) NOT NULL PRIMARY KEY"
Const Properties_Value    = 2 : PropertiesTable(Properties_Value)    = "`Value` CHAR(128) NOT NULL LOCALIZABLE"
Dim   TargetFiles_OptionalDataTable(6)               : TargetFiles_OptionalDataTable(0)                              = "`TargetFiles_OptionalData`"
Const TargetFiles_OptionalData_Target            = 1 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_Target)           = "`Target` CHAR(13) NOT NULL PRIMARY KEY"
Const TargetFiles_OptionalData_FTK  = 2 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_FTK) = "`FTK` CHAR(255) NOT NULL PRIMARY KEY"
Const TargetFiles_OptionalData_SymbolPaths       = 3 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_SymbolPaths)      = "`SymbolPaths` CHAR(255)"
Const TargetFiles_OptionalData_IgnoreOffsets = 4 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_IgnoreOffsets)= "`IgnoreOffsets` CHAR(255)"
Const TargetFiles_OptionalData_IgnoreLengths        = 5 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_IgnoreLengths)       = "`IgnoreLengths` CHAR(255)"
Const TargetFiles_OptionalData_RetainOffsets       = 6 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_RetainOffsets)      = "`RetainOffsets` CHAR(255)"
Dim   TargetImagesTable(7)                   : TargetImagesTable(0)                                  = "`TargetImages`"
Const TargetImages_Target                = 1 : TargetImagesTable(TargetImages_Target)                = "`Target` CHAR(13) NOT NULL PRIMARY KEY"
Const TargetImages_MsiPath               = 2 : TargetImagesTable(TargetImages_MsiPath)               = "`MsiPath` CHAR(255) NOT NULL"
Const TargetImages_SymbolPaths           = 3 : TargetImagesTable(TargetImages_SymbolPaths)           = "`SymbolPaths` CHAR(255)"
Const TargetImages_Upgraded              = 4 : TargetImagesTable(TargetImages_Upgraded)              = "`Upgraded` CHAR(13) NOT NULL"
Const TargetImages_Order                 = 5 : TargetImagesTable(TargetImages_Order)                 = "`Order` SHORT NOT NULL"
Const TargetImages_ProductValidateFlags  = 6 : TargetImagesTable(TargetImages_ProductValidateFlags)  = "`ProductValidateFlags` CHAR(16)"
Const TargetImages_IgnoreMissingSrcFiles = 7 : TargetImagesTable(TargetImages_IgnoreMissingSrcFiles) = "`IgnoreMissingSrcFiles` SHORT NOT NULL"
Dim   UpgradedFilesToIgnoreTable(2)      : UpgradedFilesToIgnoreTable(0)                              = "`UpgradedFilesToIgnore`"
Const UpgradedFilesToIgnore_Upgraded = 1 : UpgradedFilesToIgnoreTable(UpgradedFilesToIgnore_Upgraded) = "`Upgraded` CHAR(13) NOT NULL PRIMARY KEY"
Const UpgradedFilesToIgnore_FTK      = 2 : UpgradedFilesToIgnoreTable(UpgradedFilesToIgnore_FTK)      = "`FTK` CHAR(255) NOT NULL PRIMARY KEY"
Dim   UpgradedFiles_OptionalDataTable(5)              : UpgradedFiles_OptionalDataTable(0)                                      = "`UpgradedFiles_OptionalData`"
Const UpgradedFiles_OptionalData_Upgraded         = 1 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_Upgraded)    = "`Upgraded` CHAR(13) NOT NULL PRIMARY KEY"
Const UpgradedFiles_OptionalData_FTK              = 2 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_FTK)         = "`FTK` CHAR(255) NOT NULL PRIMARY KEY"
Const UpgradedFiles_OptionalData_SymbolPaths      = 3 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_SymbolPaths) = "`SymbolPaths` CHAR(255)"
Const UpgradedFiles_OptionalData_AllowIgnoreOnPatchError = 4 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_AllowIgnoreOnPatchError) = "`AllowIgnoreOnPatchError` SHORT"
Const UpgradedFiles_OptionalData_IncludeWholeFile = 5 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_IncludeWholeFile) = "`IncludeWholeFile` SHORT"
Dim   UpgradedImagesTable(5)          : UpgradedImagesTable(0)                           = "`UpgradedImages`"
Const UpgradedImages_Upgraded     = 1 : UpgradedImagesTable(UpgradedImages_Upgraded)     = "`Upgraded` CHAR(13) NOT NULL PRIMARY KEY"
Const UpgradedImages_MsiPath      = 2 : UpgradedImagesTable(UpgradedImages_MsiPath)      = "`MsiPath` CHAR(255) NOT NULL"
Const UpgradedImages_PatchMsiPath = 3 : UpgradedImagesTable(UpgradedImages_PatchMsiPath) = "`PatchMsiPath` CHAR(255)"
Const UpgradedImages_SymbolPaths  = 4 : UpgradedImagesTable(UpgradedImages_SymbolPaths)  = "`SymbolPaths` CHAR(255)"
Const UpgradedImages_Family       = 5 : UpgradedImagesTable(UpgradedImages_Family)       = "`Family` CHAR(8) NOT NULL"

Dim   dictStdDirs                : Set dictStdDirs = CreateObject("Scripting.Dictionary")
   dictStdDirs.Add "AdminToolsFolder", ""
   dictStdDirs.Add "AppDataFolder", ""
   dictStdDirs.Add "CommonAppDataFolder", ""
   dictStdDirs.Add "CommonFilesFolder", ""
   dictStdDirs.Add "DesktopFolder", ""
   dictStdDirs.Add "FavoritesFolder", ""
   dictStdDirs.Add "FontsFolder", ""
   dictStdDirs.Add "LocalAppDataFolder", ""
   dictStdDirs.Add "MyPicturesFolder", ""
   dictStdDirs.Add "PersonalFolder", ""
   dictStdDirs.Add "ProgramFilesFolder", ""
   dictStdDirs.Add "ProgramMenuFolder", ""
   dictStdDirs.Add "SendToFolder", ""
   dictStdDirs.Add "StartMenuFolder", ""
   dictStdDirs.Add "StartupFolder", ""
   dictStdDirs.Add "System16Folder", ""
   dictStdDirs.Add "SystemFolder", ""
   dictStdDirs.Add "TempFolder", ""
   dictStdDirs.Add "TemplateFolder", ""
   dictStdDirs.Add "WindowsFolder", ""
   dictStdDirs.Add "WindowsVolume", ""
   dictStdDirs.Add "CommonFiles64Folder", ""
   dictStdDirs.Add "ProgramFiles64Folder", ""
   dictStdDirs.Add "System64Folder", ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\wiconst.inc ===
'<script language='VBScript'>
' wiconsts.inc - Windows Installer constants
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'

'''''''''''''''''''''''''''''''''''''''''''''''''
' Windows Installer definitions - from msidefs.h
Const msiOpenDatabaseModeReadOnly = 0
Const msiOpenDatabaseModeTransact = 1
Const msiOpenDatabaseModeDirect   = 2
Const msiOpenDatabaseModeCreate   = 3
Const msiViewModifySeek     = -1
Const msiViewModifyInsert   = 1
Const msiViewModifyUpdate   = 2
Const msiViewModifyAssign   = 3
Const msiViewModifyReplace  = 4
Const msiViewModifyMerge    = 5
Const msiViewModifyDelete   = 6

' Component.Attributes mapping
Const msidbComponentAttributesSourceOnly   = &h01
Const msidbComponentAttributesOptional   = &h02
Const msidbComponentAttributesRegistryKeyPath   = &h04
Const msidbComponentAttributesSharedDllRefCount = &h08
Const msidbComponentAttributesPermanent         = &h10
Const msidbComponentAttributesODBCDataSource    = &h20
Const msidbComponentAttributesTransitive        = &h40
Const msidbComponentAttributesNeverOverwrite    = &h80

' File.Attributes mapping
Const msidbFileAttributesReadOnly      = &h0001
Const msidbFileAttributesHidden        = &h0002
Const msidbFileAttributesSystem        = &h0004
Const msidbFileAttributesVital         = &h0200
Const msidbFileAttributesChecksum      = &h0400
Const msidbFileAttributesPatchAdded    = &h1000
Const msidbFileAttributesNoncompressed = &h2000
Const msidbFileAttributesCompressed    = &h4000

' Feature.Attributes mapping
Const msidbFeatureAttributesFavorSource            = &h0001
Const msidbFeatureAttributesFollowParent           = &h0002
Const msidbFeatureAttributesFavorAdvertise         = &h0004
Const msidbFeatureAttributesDisallowAdvertise      = &h0008
Const msidbFeatureAttributesUIDisallowAbsent       = &h0010
Const msidbFeatureAttributesNoUnsupportedAdvertise = &h0020

' Class.Attributes mapping
Const msidbClassAttributesRelativePath = &h0001

' ServiceControl.Event
Const msidbServiceControlEventStart           = &h0001
Const msidbServiceControlEventStop            = &h0002
Const msidbServiceControlEventRemove          = &h0008
Const msidbServiceControlEventUninstallStart  = &h0010
Const msidbServiceControlEventUninstallStop   = &h0020
Const msidbServiceControlEventUninstallRemove = &h0080

' ServiceInstall.ServiceType
Const msidbServiceInstallOwnProcess           = &h0010
Const msidbServiceInstallShareProcess         = &h0020
Const msidbServiceInstallInteractive          = &h0100

' ServiceInstall.StartType
Const msidbServiceInstallAutoStart            = &h0002
Const msidbServiceInstallDemandStart          = &h0003
Const msidbServiceInstallDisabled             = &h0004

' ServiceInstall.ErrorControl
Const msidbServiceInstallErrorIgnore          = &h0000
Const msidbServiceInstallErrorNormal          = &h0001
Const msidbServiceInstallErrorCritical        = &h0004
Const msidbServiceInstallErrorControlVital    = &h8000

' IniFile actions
Const msidbIniFileActionAddLine    = 0
Const msidbIniFileActionCreateLine = 1
Const msidbIniFileActionRemoveLine = 2
Const msidbIniFileActionAddTag     = 3
Const msidbIniFileActionRemoveTag  = 4

' CustomAction.Type mapping
Const msidbCustomActionTypeDll            = &h0001 ' Target = entry point name
Const msidbCustomActionTypeExe            = &h0002 ' Target = command line args
Const msidbCustomActionTypeTextData       = &h0003 ' Target = text string to be formatted and set into property
Const msidbCustomActionTypeJScript        = &h0005 ' Target = entry point name, null if none to call
Const msidbCustomActionTypeVBScript       = &h0006 ' Target = entry point name, null if none to call
Const msidbCustomActionTypeInstall        = &h0007 ' Target = property list for nested engine initialization
Const msidbCustomActionTypeBinaryData     = &h0000 ' Source = Binary.Name, data stored in stream
Const msidbCustomActionTypeSourceFile     = &h0010 ' Source = File.File, file part of installation
Const msidbCustomActionTypeDirectory      = &h0020 ' Source = Directory.Directory, folder containing existing file
Const msidbCustomActionTypeProperty       = &h0030 ' Source = Property.Property, full path to executable
Const msidbCustomActionTypeContinue       = &h0040 ' ignore action return status, continue running
Const msidbCustomActionTypeAsync          = &h0080 ' run asynchronously
Const msidbCustomActionTypeFirstSequence  = &h0100 ' skip if UI sequence already run
Const msidbCustomActionTypeOncePerProcess = &h0200 ' skip if UI sequence already run in same process
Const msidbCustomActionTypeClientRepeat   = &h0300 ' run on client only if UI already run on client
Const msidbCustomActionTypeInScript       = &h0400 ' queue for execution within script
Const msidbCustomActionTypeRollback       = &h0100 ' in conjunction with InScript: queue in Rollback script
Const msidbCustomActionTypeCommit         = &h0200 ' in conjunction with InScript: run Commit ops from script on success
Const msidbCustomActionTypeNoImpersonate  = &h0800 ' no impersonation, run in system context

' Dialog.Attributes
Const msidbDialogAttributesVisible          = &h00000001
Const msidbDialogAttributesModal            = &h00000002
Const msidbDialogAttributesMinimize         = &h00000004
Const msidbDialogAttributesSysModal         = &h00000008
Const msidbDialogAttributesKeepModeless     = &h00000010
Const msidbDialogAttributesTrackDiskSpace   = &h00000020
Const msidbDialogAttributesUseCustomPalette = &h00000040
Const msidbDialogAttributesRTLRO            = &h00000080
Const msidbDialogAttributesRightAligned     = &h00000100
Const msidbDialogAttributesLeftScroll       = &h00000200
Const msidbDialogAttributesError            = &h00010000

' Control.Attributes - common
Const msidbControlAttributesVisible         = &h00000001
Const msidbControlAttributesEnabled         = &h00000002
Const msidbControlAttributesSunken          = &h00000004
Const msidbControlAttributesIndirect        = &h00000008
Const msidbControlAttributesInteger         = &h00000010
Const msidbControlAttributesRTLRO           = &h00000020
Const msidbControlAttributesRightAligned    = &h00000040
Const msidbControlAttributesLeftScroll      = &h00000080

' Control.Attributes - Text controls
Const msidbControlAttributesTransparent     = &h00010000
Const msidbControlAttributesNoPrefix        = &h00020000
Const msidbControlAttributesNoWrap          = &h00040000
Const msidbControlAttributesFormatSize      = &h00080000
Const msidbControlAttributesUsersLanguage   = &h00100000

' Control.Attributes - Edit controls
Const msidbControlAttributesMultiline       = &h00010000
Const msidbControlAttributesPasswordInput   = &h00200000

' Control.Attributes - ProgressBar
Const msidbControlAttributesProgress95      = &h00010000

' Control.Attributes - VolumeSelectCombo and DirectoryCombo
Const msidbControlAttributesRemovableVolume = &h00010000
Const msidbControlAttributesFixedVolume     = &h00020000
Const msidbControlAttributesRemoteVolume    = &h00040000
Const msidbControlAttributesCDROMVolume     = &h00080000
Const msidbControlAttributesRAMDiskVolume   = &h00100000
Const msidbControlAttributesFloppyVolume    = &h00200000

' Control.Attributes - VolumeCostList control
Const msidbControlShowRollbackCost          = &h00400000

' Control.Attributes - ListBox and ComboBox controls
Const msidbControlAttributesSorted          = &h00010000
Const msidbControlAttributesComboList       = &h00020000

' Control.Attributes - RadioButton controls
Const msidbControlAttributesHasBorder       = &h01000000

' Control.Attributes - picture button controls
Const msidbControlAttributesImageHandle     = &h00010000
Const msidbControlAttributesPushLike        = &h00020000
Const msidbControlAttributesBitmap          = &h00040000
Const msidbControlAttributesIcon            = &h00080000
Const msidbControlAttributesFixedSize       = &h00100000
Const msidbControlAttributesIconSize16      = &h00200000
Const msidbControlAttributesIconSize32      = &h00400000
Const msidbControlAttributesIconSize48      = &h00600000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\wixerror.inc ===
'<script language='VBScript'>
' wixerror.inc - preprocessor for Windows Installer XML
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'
' entrypoints:
'    Fail
'

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' Fail
Sub Fail(sMsg)
   WScript.Echo sMsg
   WScript.Quit -1
End Sub   ' Fail
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\xmlconst.inc ===
'<script language='VBScript'>
' xmlconsts.inc - MSXML DOM constants
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'

' MSXML DOM definitions
Const NODE_ELEMENT                = 1
Const NODE_ATTRIBUTE              = 2
Const NODE_TEXT                   = 3
Const NODE_CDATA_SECTION          = 4
Const NODE_ENTITY_REFERENCE       = 5
Const NODE_ENTITY                 = 6
Const NODE_PROCESSING_INSTRUCTION = 7
Const NODE_COMMENT                = 8
Const NODE_DOCUMENT               = 9
Const NODE_DOCUMENT_TYPE          = 10
Const NODE_DOCUMENT_FRAGMENT      = 11
Const NODE_NOTATION               = 12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muibld\muibld.h ===
#define ERROR_ONLY_VERSION_STAMP		1
#define ERROR_NO_RESOURCES				2
#define	ERROR_LANGUAGE_NOT_IN_SOURCE	3
#define ERROR_NO_SOURCE					4
#define	ERROR_NO_TARGET					5
#define ERROR_NO_LANGUAGE_SPECIFIED		6
#define ERROR_TOO_FEW_ARGUMENTS			7
#define DEPENDENT_RESOURCE_REMOVED		8

#define ERROR_OFFSET 100
#define ADDED_EXT ".RES"
#define ASCII_OFFSET 48

#define RESOURCE_CHECK_SUM L"ResourceChecksum"

#define GetFilePointer(hFile) SetFilePointer(hFile, 0, NULL, FILE_CURRENT)
 
#define GetVLFilePointer(hFile, lpPositionHigh) \
    (*lpPositionHigh = 0, \
    SetFilePointer(hFile, 0, lpPositionHigh, FILE_CURRENT))

#define MD5_CHECKSUM_SIZE 16

struct CommandLineInfo {
    char *pszSource;
    char *pszTarget;
    HANDLE hFile;
    WORD wLanguage;
    char **pszIncResType;
    BOOL bContainsOnlyVersion;
    BOOL bContainsResources;
    BOOL bLanguageFound;
    BOOL bIncDependent;
    BOOL bIncludeFlag;
    BOOL bVerbose;
    
    char *pszChecksumFile;
    BOOL bIsResChecksumGenerated;
    unsigned char pResourceChecksum[MD5_CHECKSUM_SIZE];

};

typedef struct CommandLineInfo *pCommandLineInfo;

void PutByte(HANDLE OutFile, TCHAR b, LONG *plSize1, LONG *plSize2);
void PutWord(HANDLE OutFile, WORD w, LONG *plSize1, LONG *plSize2);
void PutDWord (HANDLE OutFile, DWORD l, LONG *plSize1, LONG *plSize2);
void PutString(HANDLE OutFile, LPCSTR szStr , LONG *plSize1, LONG *plSize2);
void PutStringW(HANDLE OutFile, LPCWSTR szStr , LONG *plSize1, LONG *plSize2);
void PutPadding(HANDLE OutFile, int paddingCount, LONG *plSize1, LONG *plSize2);

void Usage();
void CleanUp(pCommandLineInfo pInfo, HANDLE hModule, BOOL bDeleteFile);
void FreeAll(pCommandLineInfo pInfo);

BOOL ParseCommandLine(int argc, char *argv[], pCommandLineInfo pInfo);
BOOL CALLBACK EnumTypesFunc(HMODULE hModule, LPTSTR lpType, LONG_PTR lParam);
BOOL CALLBACK EnumNamesFunc(HMODULE hModule, LPCTSTR lpType, LPTSTR lpName, LONG_PTR lParam);
BOOL bTypeIncluded(LPCSTR pszType, char **pszIncResType);
BOOL bInsertHeader(HANDLE hFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muisetup\installer.h ===
#ifndef __INSTALLER_H_
#define __INSTALLER_H_

#include "stdio.h"                               
#include "string.h"
#include <windows.h>
#include <fdi.h>

#ifdef _DEBUG
        #define INIFILE TEXT(".\\layout.inf")
#endif

#define MUIINFFILENAME          TEXT("mui.inf")
#define MUIINF                  TEXT(".\\mui.inf")
#define HELPDIR                 TEXT("HELP\\MUI")
#define MUI_LANGUAGES_SECTION   TEXT("Languages")
#define MUI_COMPONENTS_SECTION   TEXT("Components")
#define MUI_LANGPACK_SECTION    TEXT("LanguagePack")
#define MUI_DISPLAYNAME_SECTION TEXT("LanguageDisplayName")
#define MUI_COUNTRYNAME_SECTION TEXT("UseCountryName")
#define MUI_UIFILESIZE_SECTION  TEXT("FileSize_UI")
#define MUI_UIFILESIZE_SECTION_IA64   TEXT("FileSize_UI_IA64")
#define MUI_LPKFILESIZE_SECTION  TEXT("FileSize_LPK")
#define MUI_LPKFILESIZE_SECTION_IA64   TEXT("FileSize_LPK_IA64")
#define MUI_CDLAYOUT_SECTION    TEXT("CD_LAYOUT")
#define MUI_CDLAYOUT_SECTION_IA64    TEXT("CD_LAYOUT_IA64")
#define MUI_FILELAYOUT_SECTION  TEXT("File_Layout")
#define MUI_NOFALLBACK_SECTION  TEXT("FileType_NoFallback")
#define MUI_CDLABEL             TEXT("cdlabel")

#define PLATFORMNAME_PRO        TEXT("P")
#define PLATFORMNAME_SRV        TEXT("S")
#define PLATFORMNAME_AS         TEXT("A")
#define PLATFORMNAME_DTC        TEXT("D")
                                  

#define IE5_MUIINF_FILE        TEXT("ie5ui.inf")
#define IE5_MUI_DIR            TEXT("ie5")
#define IE5_INSTALL_SECTION    TEXT("DefaultInstall")
#define IE5_UNINSTALL_SECTION  TEXT("Uninstall")
#define IE5_Satellite_HOME     TEXT("Program Files\\Internet Explorer\\MUI\\")
#define IE5_Satellite_WEB      TEXT("web\\mui\\")
#define IE5_Satellite_JAVA     TEXT("Java\\Help\\")
#define IE5_Satellite_HH       TEXT("system32\\mui\\")

#define DEFAULT_CD_NUMBER      2
#define MFL                    20
#define DIRNUMBER              100
#define FILERENAMENUMBER       200
#define NOTFALLBACKNUMBER      20

#define MUIDIR          TEXT("MUI")
#define FALLBACKDIR     TEXT("\\MUI\\FALLBACK")

//
// max size of fontlink string, same as GRE
//
#define FONTLINK_BUF_SIZE MAX_PATH+LF_FACESIZE

//
// Diamond definitions/structures (diamond.c)
//
#define DIAMOND_NONE                0x00000000
#define DIAMOND_GET_DEST_FILE_NAME  0x00000001
#define DIAMOND_FILE                0x00000002

#define MUI_IS_WIN2K_PRO        0
#define MUI_IS_WIN2K_SERVER     1
#define MUI_IS_WIN2K_ADV_SERVER_OR_DATACENTER 2
#define MUI_IS_WIN2K_DATACENTER 3
#define MUI_IS_WIN2K_DC         4
#define MUI_IS_WIN2K_ENTERPRISE     5
#define MUI_IS_WIN2K_DC_DATACENTER  6
#define MUI_IS_WIN2K_PERSONAL   7

typedef struct 
{
    UINT flags;

    char szSrcFileName[ MAX_PATH ];

    char szSrcFilePath[ MAX_PATH ];

    char szDestFilePath[ MAX_PATH ];

} DIAMOND_PACKET, *PDIAMOND_PACKET;



//
// Diamond APIs (diamond.c)
//
HFDI Muisetup_InitDiamond();

BOOL Muisetup_FreeDiamond();

void Muisetup_DiamondReset(
    PDIAMOND_PACKET pDiamond);


BOOL Muisetup_IsDiamondFile(
    PWSTR pwszFileName,
    PWSTR pwszOriginalName,
    INT nSize,
    PDIAMOND_PACKET pDiamond);

BOOL Muisetup_CopyDiamondFile(
    PDIAMOND_PACKET pDiamond,
    PWSTR pwszCopyTo);


int EnumLanguages(LPTSTR Languages, BOOL bCheckDir = TRUE);
BOOL checkversion(BOOL bMatchBuildNumber);
BOOL FileExists(LPTSTR szFile);
BOOL EnumDirectories(void);
BOOL EnumFileRename();
BOOL EnumTypeNotFallback();
BOOL CopyFileFailed(LPTSTR lpFile, DWORD dwErrorCode);
BOOL CopyFiles(HWND hWnd, LPTSTR Languages);
BOOL MofCompileLanguages(LPTSTR Languages);
BOOL UpdateRegistry(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched);
BOOL UpdateRegistry_FontLink(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched);
BOOL MakeDir(LPTSTR szTarget);
BOOL MakeDirFailed(LPTSTR lpDirectory);
BOOL ExecuteComponentINF(
    HWND hDlg, PTSTR pComponentName, PTSTR pComponentInfFile, PTSTR pInstallSection, BOOL bInstall);

BOOL CheckLanguageDirectoryExist(LPTSTR Languages);
BOOL CheckProductType(INT_PTR nType);
BOOL CompareMuisetupVersion(LPTSTR pszSrc,LPTSTR pszTarget);
BOOL IsFileBeRenamed(LPTSTR lpszSrc,LPTSTR lpszDest);
BOOL InstallComponentsMUIFiles(PTSTR pszLangSourceDir, PTSTR pszLanguage, BOOL isInstall);

#endif //__INSTALLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muisetup\installer.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "muisetup.h"
#include "stdlib.h"
#include "tchar.h"
#include <setupapi.h>
#include <syssetup.h>
#include "lzexpand.h"
#include <shlwapi.h>
#include <sxsapi.h>
#include <shlwapip.h> // For SHRegisterValidateTemplate()
  
#define SHRVT_REGISTER                  0x00000001
#define DEFAULT_INSTALL_SECTION TEXT("DefaultInstall")
#define DEFAULT_UNINSTALL_SECTION TEXT("DefaultUninstall")

// GLOBAL variables
extern TCHAR  DirNames[MFL][MAX_PATH],DirNames_ie[MFL][MAX_PATH];
LPTSTR g_szSpecialFiles[] = {
    TEXT("hhctrlui.dll"),
};

void debug(char *printout);

////////////////////////////////////////////////////////////////////////////////////
//
//  EnumLanguages
//
//  Enumerate the languages in the [Languages] section of MUI.INF. And check for the language 
//  folders in the CD-ROM.
//  Languages is an OUT parameter, which will store the languages which has language folder
//  in the CD-ROM.
//
////////////////////////////////////////////////////////////////////////////////////

int EnumLanguages(LPTSTR Languages, BOOL bCheckDir)
{
    DWORD  dwErr;
    LPTSTR Language;
    LONG_PTR lppArgs[1];
    TCHAR  lpError[BUFFER_SIZE];
    TCHAR  lpMessage[BUFFER_SIZE];
    TCHAR  szInffile[MAX_PATH];
    int    iLanguages = 0;
                   
    //
    // MUI.INF should be in the same directory in which the installer was
    // started
    //

    _tcscpy(szInffile, g_szMUIInfoFilePath);             

    //
    // find out how many languages we can install
    //

    *Languages = TEXT('\0');
    if (!GetPrivateProfileString( MUI_LANGUAGES_SECTION,
                                  NULL,
                                  TEXT("NOLANG"),
                                  Languages,
                                  BUFFER_SIZE,
                                  szInffile))
    {               
        //
        //      "LOG: Unable to read MUI.INF - rc == %1"
        //
        lppArgs[0] = (LONG_PTR)GetLastError();
        LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);

        return(-1);
    }       

    if (bCheckDir)
    {
        CheckLanguageDirectoryExist(Languages);
    }

    Language = Languages;

    //
    // Count the number of languages which exist in the CD-ROM,
    // and return that value.
    //
    while (*Language)
    {
        iLanguages++;
        while (*Language++)
        {
        }
    }

    return(iLanguages);
}

BOOL CheckLanguageDirectoryExist(LPTSTR Languages)
{
    TCHAR szBuffer[BUFFER_SIZE];
    TCHAR szSource[ MAX_PATH ];
    TCHAR szTemp  [ MAX_PATH ]; 
    LPTSTR lpCur,lpBuffer;
    HANDLE          hFile;
    WIN32_FIND_DATA FindFileData;
    
    memcpy(szBuffer,Languages,BUFFER_SIZE);        
    lpCur=Languages;         
    lpBuffer=szBuffer;
    
    while (*lpBuffer)
    {     
       
        GetPrivateProfileString( MUI_LANGUAGES_SECTION, 
                            lpBuffer, 
                            TEXT("DEFAULT"),
                            szSource, 
                            (sizeof(szSource)/sizeof(TCHAR)),
                            g_szMUIInfoFilePath );
        _tcscpy(szTemp,g_szMUISetupFolder);
        _tcscat(szTemp,szSource);
        _tcscat(szTemp,TEXT("\\"));
        _tcscat(szTemp,g_szPlatformPath); // i386 or alpha
        _tcscat(szTemp,TEXT("*.*"));

        hFile = FindFirstFile( szTemp, &FindFileData );

        if (INVALID_HANDLE_VALUE != hFile )
        {
           if (FindNextFile( hFile, &FindFileData ) && 
               FindNextFile( hFile, &FindFileData )  )
           {
              _tcscpy(lpCur,lpBuffer);
              lpCur+=(_tcslen(lpBuffer)+1);
           }
           FindClose(hFile);
        }   
        
        while (*lpBuffer++)  
        {               
        }
    }
    *lpCur=TEXT('\0');
    return TRUE;
}






////////////////////////////////////////////////////////////////////////////////////
//
//  checkversion
//
//  Checks the NT version and build
//
////////////////////////////////////////////////////////////////////////////////////

BOOL checkversion(BOOL bMatchBuildNumber)
{
    TCHAR           buffer[20];
    TCHAR           build[20];
    OSVERSIONINFO verinfo;
    LANGID          rcLang;
    TCHAR           lpMessage[BUFFER_SIZE];


    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);    
    GetVersionEx( &verinfo) ;
  
 
    if (verinfo.dwMajorVersion < 5)        
    {
        debug("DBG: Need Windows NT version 5 or greater\r\n");
        return (FALSE);
    }

    rcLang = (LANGID) gpfnGetSystemDefaultUILanguage();

    //
    //      need to convert decimal to hex, LANGID to chr.
    //
    _stprintf(buffer,TEXT("00000%X"), rcLang);
    if (_tcscmp(buffer, TEXT("00000409")))
    {
        return(FALSE);
    }

    if (bMatchBuildNumber && FileExists(g_szMUIInfoFilePath))
    {
        GetPrivateProfileString( TEXT("Buildnumber"),
                                 NULL,
                                 TEXT("0"),
                                 buffer,
                                 (sizeof(buffer)/ sizeof(TCHAR)),
                                 g_szMUIInfoFilePath);
        
        _stprintf(build, TEXT("%d"), verinfo.dwBuildNumber);

        if (!_tcscmp(buffer, TEXT("-1")))
        {
            //
            //      "LOG: No version check forced by MUI.INF"
            //
            LoadString(ghInstance, IDS_NO_CHECK_L, lpMessage, ARRAYSIZE(lpMessage)-1);
            LogMessage(lpMessage);
            return TRUE;
        }

        if (_tcscmp(buffer, build))
        {
            debug(" wrong build.\r\n");
            return FALSE;    
        }
    }
    
    return(TRUE);
}


////////////////////////////////////////////////////////////////////////////////////
//
//  File Exists
//
//  Returns TRUE if the file exists, FALSE if it does not.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL FileExists(LPTSTR szFile)
{
    HANDLE  hFile;
    WIN32_FIND_DATA FindFileData;


    hFile = FindFirstFile( szFile, &FindFileData );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    FindClose( hFile );
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  EnumDirectories
//
//  Enumerates the directories listed in MUI.INF
//
////////////////////////////////////////////////////////////////////////////////////

BOOL EnumDirectories()
{
    DWORD  dwErr;
    LPTSTR Directories, Directory, TempDir;
    TCHAR  lpError[BUFFER_SIZE];
    TCHAR  lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[3];
    int    Dirnumber = 0;


    Directories = (LPTSTR) LocalAlloc( 0, (DIRNUMBER * MAX_PATH * sizeof(TCHAR)) );
    TempDir = (LPTSTR) LocalAlloc( 0, (MAX_PATH * sizeof(TCHAR)) );
    if (Directories == NULL || TempDir == NULL)
    {
        ExitFromOutOfMemory();
    }
        
    *Directories = TEXT('\0');
    //
    // Copy all key names into Directories.
    //
    if (!GetPrivateProfileString( TEXT("Directories"), 
                                  NULL, 
                                  TEXT("DEFAULT"),
                                  Directories, 
                                  (DIRNUMBER * MAX_PATH),
                                  g_szMUIInfoFilePath  ))
    {
        //
        //      "LOG: Unable to read - rc == %1"
        //
        lppArgs[0] = (LONG_PTR)GetLastError();
        LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);
        LocalFree( TempDir );
        LocalFree( Directories );
        return FALSE;
    }

    Directory = Directories;
    
    //
    // In case we don't find anything, we go to the fallback directory
    //
    _tcscpy(DirNames[0], TEXT("FALLBACK"));
        
    while (*Directory)
    {
        if (!GetPrivateProfileString( TEXT("Directories"), 
                                      Directory, 
                                      TEXT("\\DEFAULT"),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {
            //
            //      "LOG: Unable to read - rc == %1"
            //
            lppArgs[0] = (LONG_PTR)GetLastError();
            LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
                        
        _tcscpy(DirNames[++Dirnumber], TempDir);

        // Move to the beginning of next key name.
        while (*Directory++)
        {
        }
    }

    LocalFree( TempDir );
    LocalFree( Directories );
        
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  EnumFileRename
//
//  Enumerates the [File_Layout] section  listed in MUI.INF
//
////////////////////////////////////////////////////////////////////////////////////

BOOL EnumFileRename()
{
    DWORD  dwErr;
    LPTSTR Directories, Directory, TempDir,lpszNext;
    TCHAR  lpError[BUFFER_SIZE];
    TCHAR  lpMessage[BUFFER_SIZE],szPlatform[MAX_PATH+1],szTargetPlatform[MAX_PATH+1];
    LONG_PTR lppArgs[1];
    int    Dirnumber = 0,nIdx=0;


    Directories = (LPTSTR) LocalAlloc( 0, (FILERENAMENUMBER * (MAX_PATH+1) * sizeof(TCHAR)) );
    if (!Directories)
    {
       return FALSE;
    }  
    TempDir = (LPTSTR) LocalAlloc( 0, ( (MAX_PATH+1) * sizeof(TCHAR)) );
    if (!TempDir)
    {
       LocalFree(Directories);
       return FALSE;
    }

    if (gbIsAdvanceServer)
    {
       _tcscpy(szTargetPlatform,PLATFORMNAME_AS);
    }
    else if (gbIsServer)
    {
      _tcscpy(szTargetPlatform,PLATFORMNAME_SRV);
    }
    else if (gbIsWorkStation)
    {
       _tcscpy(szTargetPlatform,PLATFORMNAME_PRO);
    }
    else if ( gbIsDataCenter)
    {
       _tcscpy(szTargetPlatform,PLATFORMNAME_DTC);
    }
    else
    {
      _tcscpy(szTargetPlatform,PLATFORMNAME_PRO);
    }



        
    *Directories = TEXT('\0');
    if (!GetPrivateProfileString( MUI_FILELAYOUT_SECTION, 
                                  NULL, 
                                  TEXT(""),
                                  Directories, 
                                  (FILERENAMENUMBER * MAX_PATH),
                                  g_szMUIInfoFilePath  ))
    {
        LocalFree( TempDir );
        LocalFree( Directories );
        return FALSE;
    }

    Directory = Directories;

    //
    // Calculate # of entries in this section
    //
    while (*Directory)
    {
        if (!GetPrivateProfileString( MUI_FILELAYOUT_SECTION, 
                                      Directory, 
                                      TEXT(""),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {   
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
                      
      //
      // Check if platform ID field in this entry
      // 
      // Source_file_name=Destination_file_name,P,S,A
      //
        lpszNext=TempDir;
        while ( (lpszNext=_tcschr(lpszNext,TEXT(','))) )
        {
            lpszNext++;
            nIdx=0;
            szPlatform[0]=TEXT('\0');

            while ( (*lpszNext != TEXT('\0')) && (*lpszNext != TEXT(',')))
            {
                if (*lpszNext != TEXT(' '))
                {
                   szPlatform[nIdx++]=*lpszNext;
                }
                lpszNext++;
            }
            szPlatform[nIdx]=TEXT('\0');

            if (!_tcsicmp(szPlatform,szTargetPlatform))
            {
              Dirnumber++;
              break;
            }
         
         }
         while (*Directory++)
         {
         }
    }
    //
    // Allocte Space for Rename Table
    //
    g_pFileRenameTable=(PFILERENAME_TABLE)LocalAlloc( 0, Dirnumber * sizeof(FILERENAME_TABLE) );
    if (!g_pFileRenameTable)
    {
       LocalFree( TempDir );
       LocalFree( Directories );
       return FALSE;

    }
    g_nFileRename=0;
    Directory = Directories;
    //
    // Create Reanme Table
    //
    while (*Directory)
    {
        if (!GetPrivateProfileString( MUI_FILELAYOUT_SECTION, 
                                      Directory, 
                                      TEXT(""),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {   
            LocalFree(g_pFileRenameTable);
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
                      
        //
        // Check if platform ID field in this entry
        // 
        // Source_file_name=Destination_file_name,P,S,A
        //
        lpszNext=TempDir;
        while ( lpszNext =_tcschr(lpszNext,TEXT(',')))
        {
            lpszNext++;
            nIdx=0;
            szPlatform[0]=TEXT('\0');

            while ( (*lpszNext != TEXT('\0')) && (*lpszNext != TEXT(',')))
            {
                if (*lpszNext != TEXT(' '))
                {
                   szPlatform[nIdx++]=*lpszNext;
                }
                lpszNext++;
            }
            szPlatform[nIdx]=TEXT('\0');
            if (!_tcsicmp(szPlatform,szTargetPlatform) )
            {
              //
              // Insert this entry into rename table pointed by g_pFileRenameTable
              //
              _tcscpy(g_pFileRenameTable[g_nFileRename].szSource,Directory);
              lpszNext=TempDir;
              nIdx=0;
              g_pFileRenameTable[g_nFileRename].szDest[0]=TEXT('\0');
              while ( (*lpszNext != TEXT('\0')) && (*lpszNext != TEXT(',')) && (*lpszNext != TEXT(' ')) )
              {
                  g_pFileRenameTable[g_nFileRename].szDest[nIdx++]=*lpszNext;
                  lpszNext++;
              }
              g_pFileRenameTable[g_nFileRename].szDest[nIdx]=TEXT('\0');
              g_nFileRename++;
              break;
            }
         
         }
         while (*Directory++)
         {
         }
    }
    LocalFree( TempDir );
    LocalFree( Directories );
        
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  EnumTypeNotFallback
//
//  Enumerates the [FileType_NoFallback] section  listed in MUI.INF
//
////////////////////////////////////////////////////////////////////////////////////

BOOL EnumTypeNotFallback()
{
    
    LPTSTR Directories, Directory, TempDir,lpszNext;
    int    Dirnumber = 0,nIdx=0;


    Directories = (LPTSTR) LocalAlloc( 0, (NOTFALLBACKNUMBER  * (MAX_PATH+1) * sizeof(TCHAR)) );
    if (!Directories)
    {
       return FALSE;
    }  
    TempDir = (LPTSTR) LocalAlloc( 0, ( (MAX_PATH+1) * sizeof(TCHAR)) );
    if (!TempDir)
    {
       LocalFree(Directories);
       return FALSE;
    }
        
    *Directories = TEXT('\0');
    if (!GetPrivateProfileString( MUI_NOFALLBACK_SECTION, 
                                  NULL, 
                                  TEXT(""),
                                  Directories, 
                                  (NOTFALLBACKNUMBER * MAX_PATH),
                                  g_szMUIInfoFilePath  ))
    {
        LocalFree( TempDir );
        LocalFree( Directories );
        return FALSE;
    }

    Directory = Directories;

    //
    // Calculate # of entries in this section
    //
    while (*Directory)
    {
        if (!GetPrivateProfileString( MUI_NOFALLBACK_SECTION, 
                                      Directory, 
                                      TEXT(""),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {   
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
                      
        Dirnumber++;
        while (*Directory++)
        {
        }
    }
    //
    // Allocte Space for 
    //

    g_pNotFallBackTable=(PTYPENOTFALLBACK_TABLE)LocalAlloc( 0, Dirnumber * sizeof(TYPENOTFALLBACK_TABLE) );

    if (!g_pNotFallBackTable)
    {
       LocalFree( TempDir );
       LocalFree( Directories );
       return FALSE;

    }
    g_nNotFallBack=0;
    Directory = Directories;
    //
    // Create NoFallBack Table
    //
    while (*Directory)
    {
        if (!GetPrivateProfileString( MUI_NOFALLBACK_SECTION, 
                                      Directory, 
                                      TEXT(""),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {   
            LocalFree(g_pNotFallBackTable);
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
        //
        // 
        //
        lpszNext=TempDir;
        nIdx=0;
        g_pNotFallBackTable[g_nNotFallBack].szSource[0]=TEXT('\0');
        while ( (*lpszNext != TEXT('\0')) && (*lpszNext != TEXT(',')) && (*lpszNext != TEXT(' ')) )
        {
            g_pNotFallBackTable[g_nNotFallBack].szSource[nIdx++]=*lpszNext;
            lpszNext++;
        }
        g_pNotFallBackTable[g_nNotFallBack].szSource[nIdx]=TEXT('\0');
        g_nNotFallBack++;
        while (*Directory++)
        {
        }
    }
    LocalFree( TempDir );
    LocalFree( Directories );
        
    return TRUE;
}

//
// Check if a given file should be renamed by searching Rename Table
//
BOOL IsFileBeRenamed(LPTSTR lpszSrc,LPTSTR lpszDest)
{
    int   nIdx;
    BOOL  bResult=FALSE;   

    if (!lpszSrc)
        return bResult;

    for (nIdx=0; nIdx < g_nFileRename; nIdx++)
    {
        LPTSTR pMUI = StrStrI(lpszSrc,g_pFileRenameTable[nIdx].szSource);

        if (pMUI == lpszSrc)
        {
            pMUI += lstrlen(g_pFileRenameTable[nIdx].szSource);

            if (!*pMUI || !lstrcmpi(pMUI, TEXT(".MUI")))
            {    
                lstrcpy(lpszDest,g_pFileRenameTable[nIdx].szDest);
                lstrcat(lpszDest, pMUI);
                bResult=TRUE;
                break;
            }
        }
    }
    return bResult;
}
//
// Check if the file type of a given file belongs to the category "Do not Fallback"
//
BOOL IsDoNotFallBack(LPTSTR lpszFileName)
{
   BOOL bResult = FALSE;
   int  iLen,nIdx;
   
   iLen = _tcslen(lpszFileName);

   if (iLen > 4)
   {
      for (nIdx=0; nIdx < g_nNotFallBack ; nIdx++)
      {
         if (!_tcsicmp(&lpszFileName[iLen - 4],g_pNotFallBackTable[nIdx].szSource))
         {
            bResult = TRUE;
            break;
         }

      }
   }

   return bResult;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_CheckForExpandedFile
//
//  Retreives the original filename, in case the file is compressed.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_CheckForExpandedFile( 
    PTSTR pszPathName,
    PTSTR pszFileName,
    PTSTR pszOriginalFileName,
    PDIAMOND_PACKET pDiamond)
{
    TCHAR szCompressedFileName[ MAX_PATH ];
    TCHAR szOut[ MAX_PATH ];
    PTSTR pszTemp, pszDelimiter;
    BOOL  bIsCompressed;
    int   iLen=0;

    
    // Initializations
    bIsCompressed = FALSE;
    
    szOut[ 0 ] = szCompressedFileName[ 0 ] = TEXT('\0');


    //
    // Get the real name
    //
    _tcscpy(szCompressedFileName, pszPathName);
    _tcscat(szCompressedFileName, pszFileName);

    if (Muisetup_IsDiamondFile( szCompressedFileName,
                                pszOriginalFileName,
                                MAX_PATH,
                                pDiamond ))
    {
        return TRUE;
    }

    if (GetExpandedName(szCompressedFileName, szOut) == TRUE)
    {
        pszDelimiter = pszTemp = szOut;

        while (*pszTemp)
        {
            if ((*pszTemp == TEXT('\\')) ||
                (*pszTemp == TEXT('/')))
            {
                pszDelimiter = pszTemp;
            }
            pszTemp++;
        }

        if (*pszDelimiter == TEXT('\\') ||
            *pszDelimiter == TEXT('/'))
        {
            pszDelimiter++;
        }

        if (_tcsicmp(pszDelimiter, pszFileName) != 0)
        {
            bIsCompressed = TRUE;
            _tcscpy(pszOriginalFileName, pszDelimiter);
        }
    }

    if (!bIsCompressed)
    {
       _tcscpy(pszOriginalFileName, pszFileName);
       //
       // If muisetup is launched through [GUIRunOnce] command line mode,
       // W2K uncompresses all mui files and leave the name as xxxxxx.xxx.mu_
       // We should cover this situation by changing the name to xxxxxx.xxx.mui
       iLen = _tcslen(pszOriginalFileName);
       if (iLen > 4)
       {
          if (_tcsicmp(&pszOriginalFileName[iLen - 4], TEXT(".mu_")) == 0)
          {
             pszOriginalFileName[iLen-1]=TEXT('i');
          }
       }
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_CopyFile
//
//  Copy file, and expand it if necessary.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_CopyFile(
    PCTSTR pszCopyFrom,
    PTSTR  pszCopyTo,
    PDIAMOND_PACKET pDiamond,
    PTSTR pOriginalName)
{
    OFSTRUCT ofs;
    INT      hfFrom = -1, hfTo = -1;
    BOOL     bRet = FALSE;

  
    //
    // Check if diamond can handle it    
    //
    bRet = Muisetup_CopyDiamondFile( pDiamond,
                                 pszCopyTo );    

    if (bRet)
    {
        //
        // Diamond copy won't rename file for us
        //
        if (pOriginalName)
        {
            WCHAR wszPath[MAX_PATH];

            //
            // Diamond is ANSI
            //
            if (MultiByteToWideChar(1252, 0, pDiamond->szDestFilePath, -1, wszPath, ARRAYSIZE(wszPath)))
            {
                StrCat(wszPath, pOriginalName);
                MoveFileEx(wszPath,pszCopyTo,MOVEFILE_REPLACE_EXISTING);
            }
        }
        return bRet;
    }

    hfFrom = LZOpenFile( (PTSTR) pszCopyFrom,
                         &ofs,
                         OF_READ );
    if (hfFrom < 0)
    {
        goto CopyFileRetry;
    }

    hfTo = LZOpenFile( (PTSTR) pszCopyTo,
                       &ofs,
                       OF_CREATE | OF_WRITE);
    if (hfTo < 0)
    {
        goto CopyFileRetry;
    }

    if (LZCopy(hfFrom, hfTo) < 0)
    {
        goto CopyFileRetry;
    }

    LZClose(hfFrom);
    LZClose(hfTo);

    return TRUE;

CopyFileRetry:

    //
    // We may end up in a case where either the user uses directories with
    // path names > 128 characters(this will fail the LZ API's) or the LZ's
    // just fail. We just revert back to CopyFile and let the user deal
    // with that.
    //

    if(hfFrom >= 0) {
        LZClose(hfFrom);
    }

    if(hfTo >= 0) {
        LZClose(hfTo);
    }

    return CopyFile(pszCopyFrom, pszCopyTo, FALSE);    
}


////////////////////////////////////////////////////////////////////////////////////
//
// InstallComponentsMUIFiles
//
// Parameters:
//      pszLangSourceDir The sub-directory name for a specific lanuage in the MUI CD-ROM.  
//          E.g. "jpn.MUI"
//      pszLanguage     The LCID for the specific language.  E.g. "0404".
//      isInstall   TRUE if you are going to install the MUI files for the component.  FALSE 
//          if you are going to uninstall.
//      [OUT] pbCanceled    TRUE if the operation is canceled.
//      [OUT] pbError       TURE if error happens.
//
//  Return:
//      TRUE if success.  Otherwise FALSE.
//
//  Note:
//      For the language resources stored in pszLangSourceDir, this function will enumerate 
//      the compoents listed in the [Components] 
//      (the real section is put in MUI_COMPONENTS_SECTION) section, and execute the INF file 
//      listed in every entry in 
//      the [Components] section.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL InstallComponentsMUIFiles(PTSTR pszLangSourceDir, PTSTR pszLanguage, BOOL isInstall)
{
    BOOL result = TRUE;
    TCHAR szComponentName[BUFFER_SIZE];
    TCHAR CompDir[BUFFER_SIZE];
    TCHAR CompINFFile[BUFFER_SIZE];
    TCHAR CompInstallSection[BUFFER_SIZE];
    TCHAR CompUninstallSection[BUFFER_SIZE];

    TCHAR szCompInfFullPath[MAX_PATH];
    
    LONG_PTR lppArgs[2];
    INFCONTEXT InfContext;

    TCHAR szBuffer[BUFFER_SIZE];

    HINF hInf = SetupOpenInfFile(g_szMUIInfoFilePath, NULL, INF_STYLE_WIN4, NULL);
    if (hInf == INVALID_HANDLE_VALUE)
    {
        _stprintf(szBuffer, TEXT("%d"), GetLastError());    
        lppArgs[0] = (LONG_PTR)szBuffer;
        LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);
        return (FALSE);
    }    

    //
    // Get the first comopnent to be installed.
    //
    if (SetupFindFirstLine(hInf, MUI_COMPONENTS_SECTION, NULL, &InfContext))
    {
        do 
        {
            if (!SetupGetStringField(&InfContext, 0, szComponentName, sizeof(szComponentName), NULL))
            {
                lppArgs[0]=(LONG_PTR)szComponentName;                
                LogFormattedMessage(ghInstance, IDS_COMP_MISSING_NAME_L, lppArgs);
                continue;
            }
            if (!SetupGetStringField(&InfContext, 1, CompDir, sizeof(CompDir), NULL))
            {                
                //
                //  "LOG: MUI files for component %1 was not installed because of missing component direcotry.\n"
                //
                lppArgs[0]=(LONG_PTR)szComponentName;                
                LogFormattedMessage(ghInstance, IDS_COMP_MISSING_DIR_L, lppArgs);
                continue;        
            }
            if (!SetupGetStringField(&InfContext, 2, CompINFFile, sizeof(CompINFFile), NULL))
            {
                //
                //  "LOG: MUI files for component %1 were not installed because of missing component INF filename.\n"
                //
                lppArgs[0]=(LONG_PTR)szComponentName;                
                LogFormattedMessage(ghInstance, IDS_COMP_MISSING_INF_L, lppArgs);
                continue;        
            }
            if (!SetupGetStringField(&InfContext, 3, CompInstallSection, sizeof(CompInstallSection), NULL))
            {
                _tcscpy(CompInstallSection, DEFAULT_INSTALL_SECTION);
            }
            if (!SetupGetStringField(&InfContext, 4, CompUninstallSection, sizeof(CompUninstallSection), NULL))
            {
                _tcscpy(CompUninstallSection, DEFAULT_UNINSTALL_SECTION);
            }

            //
            // Establish the correct path for component INF file.
            //    
            if (isInstall)
            {
                //
                // For installation, we execute the INFs in the language directory of the CD-ROM (e.g.
                // g:\jpn.mui\i386\ie5\ie5ui.inf
                //
                _stprintf(szCompInfFullPath, TEXT("%s%s\\%s%s\\%s"), 
                          g_szMUISetupFolder, 
                          pszLangSourceDir, 
                          g_szPlatformPath,
                          CompDir, CompINFFile);
                if (!ExecuteComponentINF(NULL, szComponentName, szCompInfFullPath, CompInstallSection, TRUE))
                {                    
                    if (DoMessageBox(NULL, IDS_CANCEL_INSTALLATION, IDS_MAIN_TITLE, MB_YESNO) == IDNO)
                    {
                        result = FALSE;
                        break;
                    }
                }
            } else
            {
                //
                // For uninstallation, we execute the INFs in the \winnt\mui\fallback directory to remove component files.
                //
                _stprintf(szCompInfFullPath, TEXT("%s%s\\%s\\%s"), g_szWinDir, FALLBACKDIR, pszLanguage, CompINFFile) ;
                if (!ExecuteComponentINF(NULL, szComponentName, szCompInfFullPath, CompUninstallSection, FALSE) && result)	
                {
                    result = FALSE;
                }
            }
            
            //
            // Install the next component.
            //
        } while (SetupFindNextLine(&InfContext, &InfContext));
    }

    SetupCloseInfFile(hInf);

    return (result);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  CopyFiles
//
//  Copies the specified files to the appropriate directories
//
//  Parameters:
//      [in] languages: contain the hex string for the languages to be installed. There could be more than one language.
//      [out] lpbCopyCancelled: if the copy operation has been cancelled.
//
//  Notes:
//      This function first look at the [Languages] section in the INF file to find out the
//      source directory (in the CD-ROM) for the language to be installed.
//      From that directory, do:
//          1. install the MUI files for the components listed in the [Components] section, 
//          2. Enumarate every file in that direcotry to:
//              Check if the same file exists in directories in DirNames.  If yes, this means we have to copy
//              the mui file to that particular direcotry.  Otherwise, copy the file to the FALLBACK directory.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CopyFiles(HWND hWnd, LPTSTR Languages)
{
    LPTSTR          Language;
    HANDLE          hFile;
    HWND            hStatic;
    TCHAR           lpStatus[ BUFFER_SIZE ];
    TCHAR           lpLangText[ BUFFER_SIZE ];
    TCHAR           szSource[ MAX_PATH ] = {0};   // The source directory for a particular language
    TCHAR           szTarget[ MAX_PATH ];
    TCHAR           szTemp[ MAX_PATH ];
    TCHAR           szOriginalFileName[ MAX_PATH ];
    TCHAR           szFileNameBeforeRenamed[ MAX_PATH], szFileNameCopied[MAX_PATH];
    TCHAR           szFileRenamed[MAX_PATH];
    DIAMOND_PACKET  diamond;
    BOOL            CreateFailure = FALSE;
    BOOL            CopyOK=TRUE;
    BOOL            bFileWithNoMuiExt=FALSE;
    BOOL            FileCopied = FALSE;
    BOOL            bSpecialDirectory=FALSE;
    BOOL            bRename=FALSE;
    WIN32_FIND_DATA FindFileData;   
    int             FoundMore = 1;
    int             Dirnum = 0;
    int             iLen;
    int             NotDeleted = 0;
    int             i;
    
    TCHAR           dir[_MAX_DIR];
    TCHAR           fname[_MAX_FNAME];
    TCHAR           ext[_MAX_EXT];
    LONG_PTR        lppArgs[1];

    MSG             msg;

    //
    // we need to try to copy for each language to be installed the file
    //      
    hStatic = GetDlgItem(ghProgDialog, IDC_STATUS);
    Language = Languages;
        
    while (*Language)
    {
        //
        //  Find the directory in which the sourcefile for given language should be
        //
        GetPrivateProfileString( MUI_LANGUAGES_SECTION, 
                                 Language, 
                                 TEXT("DEFAULT"),
                                 szSource, 
                                 (sizeof(szSource)/sizeof(TCHAR)),
                                 g_szMUIInfoFilePath );

        //
        // Install Fusion MUI assemblies
        //
        if (gpfnSxsInstallW)
        {
            TCHAR pszLogFile[BUFFER_SIZE]; 
            if ( !DeleteSideBySideMUIAssemblyIfExisted(Language, pszLogFile))
            {
                TCHAR errInfo[BUFFER_SIZE];
                swprintf(errInfo, TEXT("Uninstall existing assemblies based on %s before new installation failed\n"), pszLogFile);
                OutputDebugString(errInfo);
            }
            if (GetFileAttributes(pszLogFile) != 0xFFFFFFFF) 
            {
                DeleteFile(pszLogFile); // no use anyway
            }
            TCHAR szFusionAssemblyPath[BUFFER_SIZE];
            
            PathCombine(szFusionAssemblyPath, g_szMUISetupFolder, szSource);
            PathAppend(szFusionAssemblyPath, g_szPlatformPath);
            PathAppend(szFusionAssemblyPath, TEXT("ASMS"));

            SXS_INSTALLW SxsInstallInfo = {sizeof(SxsInstallInfo)};
            SXS_INSTALL_REFERENCEW Reference = {sizeof(Reference)};
            
            Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
            Reference.lpIdentifier = MUISETUP_ASSEMBLY_INSTALLATION_REFERENCE_IDENTIFIER;    
    
            SxsInstallInfo.dwFlags = SXS_INSTALL_FLAG_REPLACE_EXISTING |        
                SXS_INSTALL_FLAG_REFERENCE_VALID |
                SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
                SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID | 
                SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY_RECURSIVE;
            SxsInstallInfo.lpReference = &Reference;
            SxsInstallInfo.lpLogFileName = pszLogFile;            
            SxsInstallInfo.lpManifestPath = szFusionAssemblyPath;
            SxsInstallInfo.lpCodebaseURL = SxsInstallInfo.lpManifestPath;

            if ( !gpfnSxsInstallW(&SxsInstallInfo))
            {
                TCHAR errInfo[BUFFER_SIZE];
                swprintf(errInfo, TEXT("Assembly Installation of %s failed. Please refer Eventlog for more information"), szFusionAssemblyPath);
                OutputDebugString(errInfo);
            }
        }

        GetLanguageGroupDisplayName((LANGID)_tcstol(Language, NULL, 16), lpLangText, ARRAYSIZE(lpLangText)-1);

        lppArgs[0] = (LONG_PTR)lpLangText;
        
        //
        // Try installing component satellite DLLs
        // 
        FormatStringFromResource(lpStatus, sizeof(lpStatus)/sizeof(TCHAR), ghInstance, IDS_INSTALLING_COMP_MUI, lppArgs);
        SetWindowText(hStatic, lpStatus);

        if (!InstallComponentsMUIFiles(szSource, NULL, TRUE))
        {
#ifndef IGNORE_COPY_ERRORS
           DeleteFiles(Languages,&NotDeleted);
           return FALSE;
#endif
        }
        
        //
        //  Output what is being installed on the progress dialog box
        //
        LoadString(ghInstance, IDS_INSTALLING, lpStatus, ARRAYSIZE(lpStatus)-1);
        FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      lpStatus,
                      0,
                      0,
                      lpStatus,
                      ARRAYSIZE(lpStatus)-1,
                      (va_list *)lppArgs);

        SetWindowText(hStatic, lpStatus);

        //
        //  find first file in language subdirectory
        //
        
        _tcscpy(szTemp,szSource);

        // szSource = g_szMUISetupFolder\szSource\tchPlatfromPath
        // e.g. szSource = "g_szMUISetupFolder\JPN.MUI\i386\"
        
        _tcscpy(szSource,g_szMUISetupFolder);
        _tcscat(szSource,szTemp);
        _tcscat(szSource, TEXT("\\"));
        _tcscat(szSource, g_szPlatformPath); // i386 or alpha

        // szTemp = szSource + "*.*"
        // e.g. szTemp = "g_szMUISetupFolder\JPN.MUI\i386\*.*"
        _tcscpy(szTemp,szSource);
        _tcscat(szTemp,TEXT("*.*"));

        FoundMore = 1;  // reset foundmore for next language.


        hFile = FindFirstFile( szTemp, &FindFileData );

        if (INVALID_HANDLE_VALUE == hFile)
            return FALSE;

        _tcscpy(szTemp, TEXT(""));
        
        while (FoundMore)
        {
            CreateFailure=FALSE;
            FileCopied=FALSE;

            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // Reset diamond stuff for the new file
                //
                Muisetup_DiamondReset(&diamond);

                //
                // Check if it's a compressed file or not
                //
                Muisetup_CheckForExpandedFile( szSource,
                                               FindFileData.cFileName,
                                               szOriginalFileName,
                                               &diamond );

                if (IsFileBeRenamed(szOriginalFileName,szFileRenamed))
                {
                   _tcscpy(szFileNameBeforeRenamed,szOriginalFileName);
                   _tcscpy(szOriginalFileName,szFileRenamed);
                   bRename=TRUE;
                }
                else
                {
                   bRename=FALSE;
                }

                // e.g. szTemp = "shell32.dll"
                _tcscpy(szTemp, szOriginalFileName);        //////////////
                

                FileCopied=FALSE;

                for (Dirnum=1; (_tcslen(DirNames[Dirnum])>0); Dirnum++ )
                {
                    //
                    //  see where this file has to go
                    //
                    pfnGetWindowsDir( szTarget, MAX_PATH);

                    // e.g. szTarget = "c:\winnt\system32\wbem"
                    _tcscat(szTarget, DirNames[Dirnum]);
                    if (_tcscmp(DirNames[Dirnum], TEXT("\\")))
                    {
                        _tcscat(szTarget, TEXT("\\"));
                    }
                    
                    bFileWithNoMuiExt = FALSE;

                    _tcscpy(szTemp, szOriginalFileName); //remove .mui  if it's .mui ////////
                    iLen = _tcslen(szTemp);
                    if (iLen > 4)
                    {
                        if (_tcsicmp(&szTemp[iLen - 4], TEXT(".mui")) == 0)
                        {
                            *(szTemp +  iLen - 4) = 0;
                        }
                        else
                        {
                            bFileWithNoMuiExt = TRUE;
                        }
                    }

                    _tcscat(szTarget, szTemp);

                    //
                    // Check the file with the same name (with the .mui extension) exist in the
                    // system directory.  If yes, this means that we need to copy the mui file.
                    // 
                    if (FileExists(szTarget))
                    {
                        //
                        //  need to copy this file to the directory
                        //
                        FileCopied = TRUE;
                                                
                        //
                        // copy filename in szTemp and directory in szTarget
                        //
                        _tsplitpath( szTarget, szTemp, dir, fname, ext );
                        _tcscpy(szTarget, szTemp);               // drive name
                        _tcscat(szTarget, dir);                  // directory name
                                                                                
                        //
                        //now szTarget = Directory, szTemp = filename
                        //
                        _tcscat(szTarget, MUIDIR);  // append MUI to directory
                        if (!MakeDir(szTarget))                    // if the MUI dir doesn't exist yet, create it.
                        {
                            MakeDirFailed(szTarget);
                            CreateFailure = TRUE;
                        }
                                                
                        _tcscat(szTarget, TEXT("\\"));                          
                        _tcscat(szTarget, Language); // add Language Identifier (from MUI.INF, e.g., 0407)                                      
                        if (!FileExists(szTarget))    // if the directory doesn't exist yet
                        {
                            if (!MakeDir(szTarget))       // if the LANGID dir doesn't exist yet, create it.
                            {
                                MakeDirFailed(szTarget);
                                CreateFailure=TRUE;
                            }
                        }
                                                
                        _tcscat(szTarget, TEXT("\\"));      // append \  /
                        if (bRename)
                        {
                           _tcscpy(szFileNameCopied,szTarget);
                           _tcscat(szFileNameCopied,szFileNameBeforeRenamed);
                        }
                        _tcscat(szTarget, szOriginalFileName);  // append filename
                        _tcscpy(szTemp, szSource);
                        _tcscat(szTemp, FindFileData.cFileName);

                        if (!CreateFailure)
                        {
                            if (!Muisetup_CopyFile(szTemp, szTarget, &diamond, bRename? szFileNameBeforeRenamed:NULL))
                            {               
                                CopyFileFailed(szTarget,0);
                                CreateFailure = TRUE;
                                CopyOK = FALSE;
                            }
                            else
                            {
                                SendMessage(ghProgress, PBM_DELTAPOS, (WPARAM)(1), 0);
                                //
                                // Diamond decompression doesn't rename correctly
                                //
                                /*
                                if (bRename)
                                {
                                    MoveFileEx(szFileNameCopied,szTarget,MOVEFILE_REPLACE_EXISTING);
                                } 
                                */

                            }
                        }
                    } // if fileexists
                } // of for

                //
                // the file was not found in any of the known MUI targets -> fallback.
                // Simple hack for FAXUI.DLL to be copied to the fallback directory as well.
                //
                bSpecialDirectory=FALSE;
                for (i = 0; i < ARRAYSIZE(g_szSpecialFiles); i++)
                {
                    if (_tcsicmp(szOriginalFileName, g_szSpecialFiles[i]) == 0)
                    {
                       bSpecialDirectory=TRUE;
                    }
                }

                if ( ( (FileCopied != TRUE) && (!IsDoNotFallBack(szOriginalFileName))) || 
                    (_tcsicmp(szOriginalFileName, TEXT("faxui.dll.mui")) == 0) )
                {
                    pfnGetWindowsDir(szTarget, MAX_PATH); //%windir%  //
                    _tcscat(szTarget, TEXT("\\"));
                    
                    
                    //
                    // If the file couldn't be found in any of the above, and it's extension
                    // doesn't contain .mui, then copy it to %windir%\system32
                    // szTemp holds the filename.
                    //
                    if (bSpecialDirectory)
                    {
                        // e.g. szTarget = "c:\winnt\system32\";
                        _tcscat(szTarget, TEXT("system32\\"));
                    }

                    // e.g. szTarget = "c:\winnt\system32\MUI" (when bSpecialDirectory = TRUE) or "c:\winnt\MUI"                                                            
                    _tcscat(szTarget, MUIDIR);                                // \MUI //

                    if (!MakeDir(szTarget))       // if the MUI dir doesn't exist yet, create it.
                    {
                        MakeDirFailed(szTarget);
                        CreateFailure = TRUE;
                    }
                                       
                    if (!bSpecialDirectory)
                    {
                        // e.g. szTarget = "C:\winnt\MUI\FALLBACK"
                       _tcscat(szTarget, TEXT("\\"));
                       _tcscat(szTarget, TEXT("FALLBACK"));      // FALLBACK

                       if (!MakeDir(szTarget))       // if the MUI dir doesn't exist yet, create it.
                       {
                           MakeDirFailed(szTarget);
                           CreateFailure = TRUE;
                       }
                    }   
                    _tcscat(szTarget, TEXT("\\"));  // \ //
                    // e.g. szTarget = "c:\winnt\system32\MUI\0411" (when bSpecialDirectory = TRUE) or "c:\winnt\MUI\FALLBACK\0411"
                    _tcscat(szTarget, Language);    // add Language Identifier (from MUI.INF, e.g., 0407)
                                        
                    if (!MakeDir(szTarget))       // if the MUI dir doesn't exist yet, create it.
                    {
                        MakeDirFailed(szTarget);
                        CreateFailure = TRUE;
                    }
                                        
                    _tcscat(szTarget, TEXT("\\"));                                    // \ //
                    _tcscat(szTarget, szOriginalFileName);                            // filename
                                
                    _tcscpy(szTemp, szSource);
                    _tcscat(szTemp, FindFileData.cFileName);


                    if (!CreateFailure)
                    {
                        if (!Muisetup_CopyFile(szTemp, szTarget, &diamond, bRename? szFileNameBeforeRenamed:NULL))
                        {
                            CopyFileFailed(szTarget,0);
                            CopyOK = FALSE;
                        }
                        else
                        {
                            SendMessage(ghProgress, PBM_DELTAPOS, (WPARAM)(1), 0);
                        }
                    }

                    if (CreateFailure == TRUE)
                    {
                        CopyOK=FALSE;
                    }
                }  // fallback case
            } // of file not dir

            FoundMore = FindNextFile( hFile, &FindFileData );

            //
            // Since this is a lengthy operation, we should
            // peek and dispatch window messages here so
            // that MUISetup dialog could repaint itself.
            //
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (msg.message == WM_QUIT)
                {
                    return (FALSE);
                }
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }            
        } // of while
        
        FindClose(hFile);

        lppArgs[0] = (LONG_PTR)Language;
        LogFormattedMessage(NULL, IDS_LANG_INSTALLED, lppArgs);
        while (*Language++)  // go to the next language and repeat
        {                       
        }        
    } // of while (*Language)
#ifndef IGNORE_COPY_ERRORS
    if (!CopyOK)
    {
        if (DoMessageBox(NULL, IDS_CANCEL_INSTALLATION, IDS_MAIN_TITLE, MB_YESNO) == IDNO)
        {
            DeleteFiles(Languages,&NotDeleted);
        } 
        else
        {
            CopyOK = TRUE;
        }
    }          
#endif
                
    return CopyOK;
}


////////////////////////////////////////////////////////////////////////////////////
//
// Copy or remove muisetup related files
//      Help file   : %windir%\help
//      Other files : %windir%\mui
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CopyRemoveMuiItself(BOOL bInstall)
{
    //
    // MUISETUP files need to be copied from MUI CD
    //
    TCHAR *TargetFiles[] = {
        TEXT("muisetup.exe"), 
        TEXT("mui.inf"), 
        TEXT("eula.txt"),
        TEXT("readme.txt"),
        TEXT("relnotes.txt")
    };
    
    TCHAR szTargetPath[MAX_PATH+1], szTargetFile[MAX_PATH+1];
    TCHAR szSrcFile[MAX_PATH+1];
    TCHAR szHelpFile[MAX_PATH+1];
    BOOL bRet = FALSE;
    int i;

    PathCombine(szTargetPath, g_szWinDir, MUIDIR);

    if (MakeDir(szTargetPath))    
    {
        //
        // Copy over MUISETUP related files
        //
        for (i=0; i<ARRAYSIZE(TargetFiles); i++)
        {
            PathCombine(szTargetFile, szTargetPath, TargetFiles[i]);
            PathCombine(szSrcFile, g_szMUISetupFolder, TargetFiles[i]);

            if (bInstall)
            {
                RemoveFileReadOnlyAttribute(szTargetFile);
                CopyFile(szSrcFile,szTargetFile,FALSE);
                RemoveFileReadOnlyAttribute(szTargetFile);
            }
            else
            {
                if (FileExists(szTargetFile) && 
                    !MUI_DeleteFile(szTargetFile))
                {
                    MoveFileEx(szTargetFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                }
            }
        }


        //
        // Copy over muisetup help file
        //
        LoadString(NULL, IDS_HELPFILE,szHelpFile,MAX_PATH);
        PathCombine(szTargetFile, g_szWinDir, HELPDIR);
        PathAppend(szTargetFile, szHelpFile);
        PathCombine(szSrcFile, g_szMUISetupFolder, szHelpFile);

        if (bInstall)
        {
            RemoveFileReadOnlyAttribute(szTargetFile);
            CopyFile(szSrcFile,szTargetFile,FALSE);
            RemoveFileReadOnlyAttribute(szTargetFile);
        }
        else
        {
            if (FileExists(szTargetFile) && 
                !MUI_DeleteFile(szTargetFile))
            {
                MoveFileEx(szTargetFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
            }
        }

        bRet = TRUE;
    }

    return bRet;
}


BOOL IsAllLanguageRemoved(LPTSTR Language)
{
   int mask[MAX_UI_LANG_GROUPS],nIdx;

   LCID SystemUILangId,lgCheck;
  
   BOOL bResult=FALSE;
  
   if (gNumLanguages_Install > 0)
      return bResult;              

   SystemUILangId=(LCID) gSystemUILangId; 

   for ( nIdx=0; nIdx<g_UILanguageGroup.iCount;nIdx++)
   {
      if ( gSystemUILangId == g_UILanguageGroup.lcid[nIdx])
      {
         mask[nIdx]=1;
      }
      else
      {
         mask[nIdx]=0;
      }
   }
   while (*Language)
   {   
       
       lgCheck = (LCID)_tcstol(Language,NULL,16);    

       for ( nIdx=0; nIdx<g_UILanguageGroup.iCount;nIdx++)
       {
          if ( lgCheck == g_UILanguageGroup.lcid[nIdx])
          {
             mask[nIdx]=1;
             break;
          }
       } 
       while (*Language++)  
       {            
       }
   }
   bResult=TRUE;
   for ( nIdx=0; nIdx<g_UILanguageGroup.iCount;nIdx++)
   {
       if ( mask[nIdx] == 0)
       {
          bResult = FALSE;
          break;
       }
   } 
   return bResult;
}

void DoRemoveFiles(LPTSTR szDirToDelete, int* pnNotDeleted)
{
    // File wildcard pattern.
    TCHAR szTarget[MAX_PATH];    
    // File to be deleted.
    TCHAR szFileName[MAX_PATH];
    // Sub-directory name
    TCHAR szSubDirName[MAX_PATH];
    
    int FoundMore = 1;
    
    HANDLE hFile;
    WIN32_FIND_DATA FindFileData;

    MSG msg;

    // e.g. szTarget = "c:\winnt\system32\Wbem\MUI\0404\*.*"
    _stprintf(szTarget, TEXT("%s\\*.*"), szDirToDelete);
    
    hFile = FindFirstFile(szTarget, &FindFileData);

    while (FoundMore)
    {
        if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            _tcscpy(szFileName, szDirToDelete);
            _tcscat(szFileName, TEXT("\\"));
            _tcscat(szFileName, FindFileData.cFileName);
    
            if (FileExists(szFileName))
            {
                // We should check if the said file is actually deleted
                // If it's not the case, then we should post a defered deletion
                //
                if (!MUI_DeleteFile(szFileName))
                {
                   (*pnNotDeleted)++;
                   MoveFileEx(szFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                }                
            }

            SendMessage(ghProgress, PBM_DELTAPOS, (WPARAM)(1), 0);
        } else
        {
            if (_tcscmp(FindFileData.cFileName, TEXT(".")) != 0 && _tcscmp(FindFileData.cFileName, TEXT("..")) != 0)
            {
                _stprintf(szSubDirName, TEXT("%s\\%s"), szDirToDelete, FindFileData.cFileName);
                DoRemoveFiles(szSubDirName, pnNotDeleted);
            }
        }

        //
        // Since this is a lengthy operation, we should
        // peek and dispatch window messages here so
        // that MUISetup dialog could repaint itself.
        //
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                return;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }            

        FoundMore = FindNextFile( hFile, &FindFileData );
    }

    FindClose(hFile);
    //
    // If the directory is not empty, then we should post a defered deletion
    // for the directory
    //
    if (!RemoveDirectory(szDirToDelete))
    {
       MoveFileEx(szDirToDelete, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
    }
}
 
////////////////////////////////////////////////////////////////////////////////////
//
//  DeleteFiles
//
//  Deletes MUI files for the languages specified
//
//  Parameters:
//      [IN]    Languages: a double-null terminated string which contains languages
//             to be processed.
//      [OUT]    lpNotDeleted: The number of files to be deleted after reboot.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL DeleteFiles(LPTSTR Languages, int *lpNotDeleted)
{
    LPTSTR Language,Langchk;
    HANDLE hFile;
    HWND   hStatic;
    TCHAR  lpLangText[BUFFER_SIZE];
    TCHAR  lpStatus[BUFFER_SIZE];

    TCHAR  szTarget[MAX_PATH];
    TCHAR  szMuiDir[MAX_PATH];
    TCHAR  szFallbackDir[MAX_PATH];
    
    BOOL   CreateFailure=FALSE;

    int Dirnum = 0;
    LONG_PTR lppArgs[3];
    int i;


    hStatic = GetDlgItem(ghProgDialog, IDC_STATUS);
    Language = Langchk = Languages;
    *lpNotDeleted = 0;

    while (*Language)
    {
        GetLanguageGroupDisplayName((LANGID)_tcstol(Language, NULL, 16), lpLangText, ARRAYSIZE(lpLangText)-1);

        lppArgs[0]= (LONG_PTR)lpLangText;
        //
        //
        //  Output what is being uninstalled on the progress dialog box
        //
        FormatStringFromResource(lpStatus, sizeof(lpStatus)/sizeof(TCHAR), ghInstance, IDS_UNINSTALLING, lppArgs);
        SetWindowText(hStatic, lpStatus);

        //
        // Remove all files under special directories (those directories listed under [Directories] in mui.inf.
        //
        for (Dirnum=1; (_tcslen(DirNames[Dirnum])>0); Dirnum++ )
        {
            // szTarget = "c:\winnt"
            _tcscpy(szTarget, g_szWinDir);
            
            // e.g. szTarget = "c:\winnt\system32\Wbem"
            _tcscat(szTarget, DirNames[Dirnum]);
                    
            if (_tcscmp(DirNames[Dirnum], TEXT("\\")))
            {
                // e.g. szTarget = "c:\winnt\system32\Wbem\"
                _tcscat(szTarget, TEXT("\\"));
            }

            // e.g. szTarget = "c:\winnt\system32\Wbem\MUI"
            _tcscat(szTarget, MUIDIR);

            // e.g. szTarget = "c:\winnt\system32\Wbem\MUI\0404"
            _tcscat(szTarget, TEXT("\\"));
            _tcscat(szTarget, Language);
            
            DoRemoveFiles(szTarget, lpNotDeleted);    
        }

        // Uninstall Component MUI Files.
        // Note that we should do this before removing all files under FALLBACK directory,
        // since we store compoent INF files under the FALLBACK directory.
        InstallComponentsMUIFiles(NULL, Language, FALSE);
        
        //
        //  Remove all files under FALLBACK directory.
        //

        // E.g. szTarget = "c:\winnt\mui"
        _tcscpy(szTarget, g_szWinDir);
        _tcscat(szTarget, TEXT("\\"));
        _tcscat(szTarget, MUIDIR);

        _tcscpy(szMuiDir, szTarget);

        // E.g. szTarget = "c:\winnt\mui\FALLBACK"
        _tcscat(szTarget, TEXT("\\"));
        _tcscat(szTarget, TEXT("FALLBACK"));

        _tcscpy(szFallbackDir, szTarget);
        _tcscat(szTarget, TEXT("\\"));

        // E.g. szTarget = "c:\winnt\mui\FALLBACK\0404"
        _tcscat(szTarget, Language);
        DoRemoveFiles(szTarget, lpNotDeleted);

        //
        // Remove files listed in g_szSpecialFiles
        // 
        for (i = 0; i < ARRAYSIZE(g_szSpecialFiles); i++)
        {            // e.g. szTarget = "c:\winnt\system32\mui\0411\hhctrlui.dll"
            wsprintf(szTarget, L"%s\\system32\\%s\\%s\\%s", 
                g_szWinDir, 
                MUIDIR, 
                Language,
                g_szSpecialFiles[i]);
            if (!MUI_DeleteFile(szTarget))
            {
                (*lpNotDeleted)++;
            }
        }

/*        
        // e.g. szTarget = "c:\winnt\system32\mui\0411"
        wsprintf(szTarget, L"%s\\system32\\%s\\%s", 
            g_szWinDir, 
            MUIDIR, 
            Language);
        DoRemoveFiles(szTarget, lpNotDeleted); 
*/

        lppArgs[0] = (LONG_PTR)Language;
        LogFormattedMessage(NULL, IDS_LANG_UNINSTALLED, lppArgs);
        
        while (*Language++)  // go to the next language and repeat
        {
        }
    } // of while (*Language)


    //
    //  Removes Fallback directory if all languages have been uninstalled.
    //
    if (!RemoveDirectory(szFallbackDir))
    {
       MoveFileEx(szFallbackDir, NULL, MOVEFILE_DELAY_UNTIL_REBOOT); 
    }
    //
    //  Removes MUI directory if all languages have been uninstalled and Fallback
    //  directory has been removed.
    //
    if (IsAllLanguageRemoved(Langchk))
    {
      CopyRemoveMuiItself(FALSE);   
    }

    if (!RemoveDirectory(szMuiDir))
    {
       MoveFileEx(szMuiDir, NULL, MOVEFILE_DELAY_UNTIL_REBOOT); 
    }
    return TRUE;
}


BOOL CompareMuisetupVersion(LPTSTR pszSrc,LPTSTR pszTarget)
{
    BOOL bResult=TRUE;
    ULONG  ulHandle,ulHandle1,ulBytes,ulBytes1;
    PVOID  pvoidBuffer=NULL,pvoidBuffer1=NULL;
    VS_FIXEDFILEINFO *lpvsInfo,*lpvsInfo1;
    UINT                  unLen;

    if ( (!pszSrc) || (!pszTarget))
    { 
       bResult = FALSE;
       goto endcompare;
    }
    
    ulBytes = GetFileVersionInfoSize( pszSrc, &ulHandle );

    if ( ulBytes == 0 )

       goto endcompare;
    

    ulBytes1 = GetFileVersionInfoSize( pszTarget,&ulHandle1 );

    if ( ulBytes1 == 0 ) 
    
       goto endcompare;
       

    pvoidBuffer=LocalAlloc(LMEM_FIXED,ulBytes+1);

    if (!pvoidBuffer)
       goto endcompare;
       
    
    pvoidBuffer1=LocalAlloc(LMEM_FIXED,ulBytes1+1);

    if (!pvoidBuffer1)
       goto endcompare;

    if ( !GetFileVersionInfo( pszSrc, ulHandle, ulBytes, pvoidBuffer ) ) 
       goto endcompare;

    if ( !GetFileVersionInfo( pszTarget, ulHandle1, ulBytes1, pvoidBuffer1 ) ) 
       goto endcompare;
    
    // Get fixed info block
    if ( !VerQueryValue( pvoidBuffer,_T("\\"),(LPVOID *)&lpvsInfo,&unLen ) )
       goto endcompare;
    

    if ( !VerQueryValue( pvoidBuffer1,_T("\\"),(LPVOID *)&lpvsInfo1,&unLen ) )
       goto endcompare;
               
    bResult = FALSE;

    //
    // We do nothing if major release version is different
    //
    // I.E We won't copy a new muisetup.exe over a old one if major release version of them are different
    //
    if ( (lpvsInfo->dwFileVersionMS == lpvsInfo1->dwFileVersionMS) &&
         (lpvsInfo->dwFileVersionLS < lpvsInfo1->dwFileVersionLS))
    
    {
    
       bResult = TRUE;  
    }                

    
endcompare:

   if(pvoidBuffer)
      LocalFree(pvoidBuffer);

   if(pvoidBuffer1)
      LocalFree(pvoidBuffer1);

   return bResult;

}




////////////////////////////////////////////////////////////////////////////////////
//
//  MZStrLen
//
//  Calculate the length of MULTI_SZ string
//
//  the length is in bytes and includes extra terminal NULL, so the length >= 1 (TCHAR)
//
////////////////////////////////////////////////////////////////////////////////////

UINT MZStrLen(LPTSTR lpszStr)
{
    UINT i=0;

    while (lpszStr && *lpszStr) 
    {
        i += ((lstrlen(lpszStr)+1) * sizeof(TCHAR));
        lpszStr += (lstrlen(lpszStr)+1);
    }

    //
    // extra NULL
    //
    i += sizeof(TCHAR);
    return i;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  SetFontLinkValue
//
//  Set necessary font link value into registry
//
//  lpszLinkInfo = "Target","Link1","Link2",....
//
////////////////////////////////////////////////////////////////////////////////////

BOOL SetFontLinkValue (LPTSTR lpszLinkInfo,BOOL *lpbFontLinkRegistryTouched)
{
    const TCHAR szDeli[] = TEXT("\\\\");
    TCHAR szStrBuf[FONTLINK_BUF_SIZE];
    TCHAR szRegDataStr[FONTLINK_BUF_SIZE];
    LPTSTR lpszDstStr,lpszSrcStr;
    LPTSTR lpszFontName;
    LPTSTR lpszTok;
    DWORD  dwType;
    DWORD  cbData;
    HKEY hKey;
    LONG rc;
    BOOL bRet = FALSE;

    lpszSrcStr = szStrBuf;

    lpszTok = _tcstok(lpszLinkInfo,szDeli);

    while (lpszTok) 
    {
        lstrcpy(lpszSrcStr,lpszTok);
        lpszSrcStr += (lstrlen(lpszTok) + 1);
        lpszTok = _tcstok(NULL,szDeli);
    }

    *lpszSrcStr = TEXT('\0');

    //
    // first token is base font name
    //

    lpszSrcStr = lpszFontName = szStrBuf;
    
    if (! *lpszFontName) 
    {
        //
        // there is no link info needs to be processed
        //

        bRet = FALSE;
        goto Exit1;
    }

    //
    // point to first linked font
    //
    lpszSrcStr += (lstrlen(lpszSrcStr) + 1);

    if (! *lpszSrcStr) 
    {
        //
        // no linked font
        //
        bRet = FALSE;
        goto Exit1;
    }

    rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink"),
                        0L,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        NULL);

    if (rc != ERROR_SUCCESS) 
    {
        bRet = FALSE;
        goto Exit1;
    }   

    cbData = sizeof(szRegDataStr);

    rc = RegQueryValueEx(hKey,
                         lpszFontName,
                         NULL,
                         &dwType,
                         (LPBYTE) szRegDataStr,
                         &cbData);

    if (rc != ERROR_SUCCESS) 
    {
        //
        // case 1, this font's font link hasn't been set yet, or something wrong in old value
        //
        lpszDstStr = lpszSrcStr;
    } 
    else 
    {
        //
        // case 2, this font's font link list has been there
        //
        // we need check if new font is defined in font list or not.
        //
        while (*lpszSrcStr) 
        {

            lpszDstStr = szRegDataStr;

            while (*lpszDstStr) 
            {
                if (lstrcmpi(lpszSrcStr,lpszDstStr) == 0) 
                {
                    break;
                }
                lpszDstStr += (lstrlen(lpszDstStr) + 1);
            }

            if (! *lpszDstStr) 
            {
                //
                // the font is not in original linke font list then
                //
                // append to end of list
                //

                //
                // make sure this is a safe copy
                //
                if (lpszDstStr+(lstrlen(lpszSrcStr)+2) < szRegDataStr+FONTLINK_BUF_SIZE) 
                {
                    lstrcpy(lpszDstStr,lpszSrcStr);
                    lpszDstStr += (lstrlen(lpszDstStr) + 1);
                    *lpszDstStr = TEXT('\0');
                }
            }
            lpszSrcStr += (lstrlen(lpszSrcStr) + 1);
        }
        lpszDstStr = szRegDataStr;
    }

    //
    // in this step,lpszDstStr is new font link list
    //
    rc = RegSetValueEx( hKey,
                        lpszFontName,
                        0L,
                        REG_MULTI_SZ,
                        (LPBYTE)lpszDstStr,
                        MZStrLen(lpszDstStr));

    if (rc != ERROR_SUCCESS) 
    {
        goto Exit2;
    }

    bRet = TRUE;

    *lpbFontLinkRegistryTouched = TRUE;

Exit2:
    RegCloseKey(hKey);

Exit1:
    return bRet;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  MofCompileLanguages
//
//  Call the WBEM API to mofcompile the MFL's for each language
//
////////////////////////////////////////////////////////////////////////////////////

BOOL MofCompileLanguages(LPTSTR Languages)
{
    pfnMUI_InstallMFLFiles pfnMUIInstall = NULL;
    TCHAR  buffer[5];
    LPTSTR Language = Languages;
    TCHAR  lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[1];
    HMODULE hWbemUpgradeDll = NULL;
    TCHAR szDllPath[MAX_PATH];

    //
    // Load the WBEM upgrade DLL from system wbem folder
    //
    if (GetSystemDirectory(szDllPath, ARRAYSIZE(szDllPath)) && 
        PathAppend(szDllPath, TEXT("wbem\\wbemupgd.dll")))
    {        
        hWbemUpgradeDll = LoadLibrary(szDllPath);
    }

    //
    // Fall back to system default path if previous loading fails
    //
    if (!hWbemUpgradeDll)
    {
        hWbemUpgradeDll = LoadLibrary(TEXT("WBEMUPGD.DLL"));
        if (!hWbemUpgradeDll)
        {
            return FALSE;
        }
    }


    //
    // Hook function pointer
    //
    pfnMUIInstall = (pfnMUI_InstallMFLFiles)GetProcAddress(hWbemUpgradeDll, "MUI_InstallMFLFiles");

    if (pfnMUIInstall == NULL)
    {
        FreeLibrary(hWbemUpgradeDll);
        return FALSE;
    }

	// process each language
    while (*Language)
    {
        _tcscpy(buffer, Language);

		if (!pfnMUIInstall(buffer))
		{
			// log error for this language
            LoadString(ghInstance, IDS_MOFCOMPILE_LANG_L, lpMessage, ARRAYSIZE(lpMessage)-1);
			lppArgs[0] = (LONG_PTR)buffer;
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          lpMessage,
                          0,
                          0,
                          lpMessage,
                          ARRAYSIZE(lpMessage)-1,
                          (va_list *)lppArgs);

			LogMessage(lpMessage);
		}

        while (*Language++)  // go to the next language and repeat
        {               
        }
    } // of while (*Language)

    FreeLibrary(hWbemUpgradeDll);
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  UpdateRegistry
//
//  Update the Registry to account for languages that have been installed
//
////////////////////////////////////////////////////////////////////////////////////

BOOL UpdateRegistry(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched)
{
    TCHAR  szRegPath[MAX_PATH];
    TCHAR  szValue[] = TEXT("1");
    LPTSTR Language;
    DWORD  dwErr;
    HKEY   hkey;
    DWORD  dwDisp;

    _tcscpy(szRegPath, TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\MUILanguages"));

    dwErr = RegCreateKeyEx( HKEY_LOCAL_MACHINE,  // handle of an open key
                            szRegPath, // address of subkey name
                            0, // reserved
                            TEXT("REG_SZ"),   // address of class string
                            REG_OPTION_NON_VOLATILE ,  // special options flag
                            KEY_ALL_ACCESS,  // desired security access
                            NULL,
                            &hkey,  // address of szRegPath for opened handle
                            &dwDisp  // address of disposition value szRegPath
                          );

    if (dwErr != ERROR_SUCCESS)
    {
        return FALSE;
    }

    Language = Languages;

    lstrcpy(szRegPath, TEXT("0409"));
    dwErr = RegSetValueEx( hkey,
                           szRegPath,
                           0,
                           REG_SZ,
                           (const BYTE *)szValue,
                           (lstrlen(szValue) + 1) * sizeof(TCHAR));
    
    while (*Language)
    {
        TCHAR szFontLinkVal[FONTLINK_BUF_SIZE];
        DWORD dwNum;

        lstrcpy(szRegPath, Language);
        dwErr = RegSetValueEx( hkey,
                               szRegPath,
                               0,
                               REG_SZ,
                               (const BYTE *)szValue,
                               (lstrlen(szValue) + 1)*sizeof(TCHAR));

        if (dwErr != ERROR_SUCCESS)
        {
            RegCloseKey(hkey);
            return FALSE;
        }

        dwNum = GetPrivateProfileString(TEXT("FontLink"),
                                        szRegPath,
                                        TEXT(""),
                                        szFontLinkVal,
                                        (sizeof(szFontLinkVal)/sizeof(TCHAR)),
                                        g_szMUIInfoFilePath);
        if (dwNum) 
        {
            SetFontLinkValue(szFontLinkVal,lpbFontLinkRegistryTouched);
        }    

        while (*Language++);  // go to the next language and repeat
    } // of while (*Language)

    RegCloseKey(hkey);
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  UpdateFontLinkRegistry
//
//  Update the Font Link Registry to account for languages that have been installed
//
////////////////////////////////////////////////////////////////////////////////////

BOOL UpdateRegistry_FontLink(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched)
{
    TCHAR  buffer[400];
    LPTSTR Language;
    DWORD  dwErr;
    DWORD  dwDisp;

   
    Language = Languages;
      
    while (*Language)
    {
        TCHAR szFontLinkVal[FONTLINK_BUF_SIZE];
        DWORD dwNum;

        _tcscpy(buffer, Language);
      
        dwNum = GetPrivateProfileString(TEXT("FontLink"),
                                        buffer,
                                        TEXT(""),
                                        szFontLinkVal,
                                        (sizeof(szFontLinkVal)/sizeof(TCHAR)),
                                        g_szMUIInfoFilePath);
        if (dwNum) 
        {
            SetFontLinkValue(szFontLinkVal,lpbFontLinkRegistryTouched);
        }
        
        
        while (*Language++)  // go to the next language and repeat
        {               
        }
    } // of while (*Language)

    return TRUE;
}


void debug(char *printout)
{
#ifdef _DEBUG
    fprintf(stderr, "%s", printout);
#endif
}


////////////////////////////////////////////////////////////////////////////////////
//
//  MakeDir
//
//  Create the directory if it does not already exist
//
////////////////////////////////////////////////////////////////////////////////////


BOOL MakeDir(LPTSTR szTarget)
{
    TCHAR  lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[1];

    if (!FileExists(szTarget))    // if the directory doesn't exist yet
    {
        if (!CreateDirectory( szTarget, NULL))  // create it
        {
            //
            // "LOG: Error creating directory %1"
            //
            LoadString(ghInstance, IDS_CREATEDIR_L, lpMessage, ARRAYSIZE(lpMessage)-1);
            lppArgs[0]=(LONG_PTR)szTarget;

            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          lpMessage,
                          0,
                          0,
                          lpMessage,
                          ARRAYSIZE(lpMessage)-1,
                          (va_list *)lppArgs);

            LogMessage(lpMessage);

            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          GetLastError(),
                          0,
                          lpMessage,
                          ARRAYSIZE(lpMessage)-1,
                          NULL);
                
            LogMessage(lpMessage);
            return FALSE;
        }
    }

    return TRUE;
}
                                

////////////////////////////////////////////////////////////////////////////////////
//
//  MakeDirFailed
//
//  Write message to log file that MakeDir failed.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL MakeDirFailed(LPTSTR lpDirectory)
{
    TCHAR  lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[1];

    //
    //      "LOG: MakeDir has failed: %1"
    //
    lppArgs[0]=(LONG_PTR)lpDirectory;
    LogFormattedMessage(NULL, IDS_MAKEDIR_L, lppArgs);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  CopyFileFailed
//  Write message to log file that CopyFile failed.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CopyFileFailed(LPTSTR lpFile,DWORD dwErrorCode)
{
    TCHAR lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[1];
    DWORD  MessageID;

    if ( dwErrorCode)
    {
       MessageID = dwErrorCode;
    }
    else
    {
       MessageID = GetLastError();
    }
                                        
    //
    //      "LOG: CopyFile has failed: %1"
    //
    LoadString(ghInstance, IDS_COPYFILE_L, lpMessage, ARRAYSIZE(lpMessage)-1);
                                                
    lppArgs[0]=(LONG_PTR)lpFile;
        
    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   lpMessage,
                   0,
                   0,
                   lpMessage,
                   ARRAYSIZE(lpMessage)-1,
                   (va_list *)lppArgs);
                
    LogMessage(lpMessage);

    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   MessageID,
                   0,
                   lpMessage,
                   ARRAYSIZE(lpMessage)-1,
                   NULL);
        
    LogMessage(lpMessage);
        
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_InitInf
//
//  Parameters:
//  
//      [OUT] phInf     the handle to the INF file opened.
//      [OUT] pFileQueue    the file queue created in this function.
//      [OUT] pQueueContext the context used by the default queue callback routine included with the Setup API.
//
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_InitInf(
    HWND hDlg,
    LPTSTR pszInf,
    HINF *phInf,
    HSPFILEQ *pFileQueue,
    PVOID *pQueueContext)
{
    //
    //  Open the Inf file.
    //
    *phInf = SetupOpenInfFile(pszInf, NULL, INF_STYLE_WIN4, NULL);
    if (*phInf == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    //
    //  Create a setup file queue and initialize default setup
    //  copy queue callback context.
    //
    *pFileQueue = SetupOpenFileQueue();
    if ((!*pFileQueue) || (*pFileQueue == INVALID_HANDLE_VALUE))
    {
        SetupCloseInfFile(*phInf);
        return FALSE;
    }

    *pQueueContext = SetupInitDefaultQueueCallback(hDlg);
    if (!*pQueueContext)
    {
        SetupCloseFileQueue(*pFileQueue);
        SetupCloseInfFile(*phInf);
        return FALSE;
    }

    //
    //  Return success.
    //
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_CloseInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_CloseInf(
    HINF hInf,
    HSPFILEQ FileQueue,
    PVOID QueueContext)
{
    //
    //  Terminate the Queue.
    //
    SetupTermDefaultQueueCallback(QueueContext);

    //
    //  Close the file queue.
    //
    SetupCloseFileQueue(FileQueue);

    //
    //  Close the Inf file.
    //
    SetupCloseInfFile(hInf);

    return TRUE;
}

UINT  MySetupQueueCallback (
    PVOID    QueueContext,
    UINT Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )
{
   UINT  status;
   PFILEPATHS              FilePaths = (PFILEPATHS)Param1;
   PSOURCE_MEDIA           SourceMedia = (PSOURCE_MEDIA)Param1;
   TCHAR                   szFileName[MAX_PATH];
   int                     iLen;
  
   if(Notification == SPFILENOTIFY_NEEDMEDIA) 
   {       
      if(SourceMedia->SourcePath && SourceMedia->SourceFile)
      {
        _tcscpy(szFileName,SourceMedia->SourcePath);
        _tcscat(szFileName,TEXT("\\"));
        _tcscat(szFileName,SourceMedia->SourceFile);
        if (!FileExists(szFileName))
        {  
           CopyFileFailed(szFileName,ERROR_FILE_NOT_FOUND);
           g_IECopyError=TRUE;
           return FILEOP_SKIP;
        }
      }
   }
   if (Notification == SPFILENOTIFY_COPYERROR)
   {  
      CopyFileFailed((LPTSTR)FilePaths->Source,ERROR_FILE_NOT_FOUND);
      g_IECopyError=TRUE;
      return FILEOP_SKIP;
   }
   //
   // Special for .htt file
   //
   // Sign webvw htt files in order for the shell to grant them security privilege to execute stuff.
   //
   if ( (Notification == SPFILENOTIFY_ENDCOPY) && (FilePaths->Win32Error == ERROR_SUCCESS))
   {

      iLen=_tcslen(FilePaths->Target);
      if (iLen > 4)
      {
         if (_tcsicmp(&FilePaths->Target[iLen - 4], TEXT(".htt")) == 0)
         {
            SHRegisterValidateTemplate(FilePaths->Target,SHRVT_REGISTER);
         }
       }
   }


   status= SetupDefaultQueueCallback(QueueContext,Notification, Param1, Param2);
   if (status == FILEOP_ABORT)
   {
      g_InstallCancelled = TRUE;
   }
   return status;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  ExecuteComponentINF
//
//  Installs component MUI files, by running the specified INF file.
//
//  Parameters:
//      pComponentName   the name of the component (e.g. "ie5")
//      pComponentInfFile: the full path of the component INF file.
//      pInstallSection the section in the component INF file to be executed. (e.g "DefaultInstall" or "Uninstall")
//
////////////////////////////////////////////////////////////////////////////////////

BOOL ExecuteComponentINF(
    HWND hDlg, PTSTR pComponentName, PTSTR pComponentInfFile, PTSTR pInstallSection, BOOL bInstall)
{
    int      iLen;
    TCHAR   tchCommandParam[BUFFER_SIZE];
    CHAR    chCommandParam[BUFFER_SIZE*sizeof(TCHAR)];
    
    HINF     hCompInf;      // the handle to the component INF file.
    HSPFILEQ FileQueue;
    PVOID    QueueContext;
    BOOL     bRet = TRUE;
    DWORD    dwResult;
    LONG_PTR lppArgs[3];

    TCHAR   szBuffer[BUFFER_SIZE];

    //
    // Advpack LaunchINFSection() command line format:
    //      INF file, INF section, flags, reboot string
    // 'N' or  'n' in reboot string means no reboot message popup.
    //
    wsprintf(tchCommandParam, TEXT("%s,%s,0,n"), pComponentInfFile, pInstallSection);
    WideCharToMultiByte(CP_ACP, 0, tchCommandParam, -1, chCommandParam, sizeof(chCommandParam), NULL, NULL);
    
    
    if (FileExists(pComponentInfFile))
    {
        // gpfnLaunchINFSection won't be NULL since InitializePFNs() already verifies that.
        if ((gpfnLaunchINFSection)(hDlg, ghInstance, chCommandParam, SW_SHOW) != S_OK)
        {
            lppArgs[0] = (LONG_PTR)pComponentName;
            DoMessageBoxFromResource(hDlg, ghInstance, bInstall? IDS_ERROR_INSTALL_COMP_UI : IDS_ERROR_UNINSTALL_COMP_UI, lppArgs, IDS_ERROR_T, MB_OK);
            return (FALSE);
        }
    } 
    
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  CheckProductType
//
//  Check product type of W2K
//
////////////////////////////////////////////////////////////////////////////////////
 BOOL CheckProductType(INT_PTR nType)
  {
      OSVERSIONINFOEX verinfo;
      INT64 dwConditionMask=0;
      BOOL  bResult=FALSE;
      DWORD dwTypeMask = VER_PRODUCT_TYPE;

      memset(&verinfo,0,sizeof(verinfo));
      verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

      VER_SET_CONDITION(dwConditionMask,VER_PRODUCT_TYPE,VER_EQUAL);

      switch (nType)
      {
           // W2K Professional
           case MUI_IS_WIN2K_PRO:
                verinfo.wProductType=VER_NT_WORKSTATION;
                break;
           // W2K Server
           case MUI_IS_WIN2K_SERVER:
                verinfo.wProductType=VER_NT_SERVER;
                break;
           // W2K Advanced Server or Data Center
           case MUI_IS_WIN2K_ADV_SERVER_OR_DATACENTER:
                verinfo.wProductType=VER_NT_SERVER;
                verinfo.wSuiteMask  =VER_SUITE_ENTERPRISE;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_OR);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break;
           // W2k Data Center
           case MUI_IS_WIN2K_DATACENTER:
                verinfo.wProductType=VER_NT_SERVER;
                verinfo.wSuiteMask  =VER_SUITE_DATACENTER;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_OR);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break;   
           // W2K Domain Controller
           case MUI_IS_WIN2K_DC:
                verinfo.wProductType=VER_NT_DOMAIN_CONTROLLER;
                break;
           case MUI_IS_WIN2K_ENTERPRISE:
                verinfo.wProductType=VER_NT_DOMAIN_CONTROLLER;
                verinfo.wSuiteMask  =VER_SUITE_ENTERPRISE;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_OR);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break;
           case MUI_IS_WIN2K_DC_DATACENTER:
                verinfo.wProductType=VER_NT_DOMAIN_CONTROLLER;
                verinfo.wSuiteMask  =VER_SUITE_DATACENTER;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_OR);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break; 
           // Whistler Personal                
           case MUI_IS_WIN2K_PERSONAL:
                verinfo.wProductType=VER_NT_WORKSTATION;
                verinfo.wSuiteMask  =VER_SUITE_PERSONAL;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_AND);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break;
           default:
                verinfo.wProductType=VER_NT_WORKSTATION;
                break;
      }
      return (VerifyVersionInfo(&verinfo,dwTypeMask,dwConditionMask));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muisetup\diamond.cpp ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    diamond.c

Abstract:

    Implement File Decompression Interface -FDI- for Cabinet files.


Revision History:

    04-20-1999    SamerA    Created.

--*/

#include "muisetup.h"
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include <sys/stat.h>


// 
// Module Global Variables
//

//
// Cabinet DLL handle
HINSTANCE hCabinetDll;
HFDI ghfdi;                  // diamond FDI context


//
// DLL Function pointers
//
typedef HFDI (DIAMONDAPI *PFNFDICREATE)(
    PFNALLOC pfnalloc,
    PFNFREE pfnfree,
    PFNOPEN pfnopen,
    PFNREAD pfnread,
    PFNWRITE pfnwrite,
    PFNCLOSE pfnclose,
    PFNSEEK pfnseek,
    int cpuType,
    PERF perf);

typedef BOOL (DIAMONDAPI *PFNFDIISCABINET)(
    HFDI hfdi,
    INT_PTR hf,
    PFDICABINETINFO pfdici);

typedef BOOL (DIAMONDAPI *PFNFDICOPY)(
    HFDI hfdi,
    char *pszCabinet,
    char *pszCabPath,
    int  flags,
    PFNFDINOTIFY pfnfdin,
    PFNFDIDECRYPT pfnfdid,
    void *pvUser);

typedef BOOL (DIAMONDAPI *PFNFDIDESTROY)(
    HFDI hfdi);
        

PFNFDICREATE pfnFDICreate;
PFNFDICOPY pfnFDICopy;
PFNFDIISCABINET pfnFDIIsCabinet;
PFNFDIDESTROY pfnFDIDestroy;


//-------------------------------------------------------------------------//
//                          FDI EXTERNAL ROUTINES                          //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  FDICreate
//
//  Tries to create an FDI context. Will load cabinet.dll and hook necessary
//  function pointers.
//
//  04-20-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

HFDI DIAMONDAPI FDICreate(
    PFNALLOC pfnalloc,
    PFNFREE  pfnfree,
    PFNOPEN  pfnopen,
    PFNREAD  pfnread,
    PFNWRITE pfnwrite,
    PFNCLOSE pfnclose,
    PFNSEEK  pfnseek,
    int      cpuType,
    PERF     perf)
{
    HFDI hfdi;


    //
    // Load cabinet DLL
    //
    hCabinetDll = LoadLibrary(TEXT("CABINET.DLL"));
    if (hCabinetDll == NULL)
    {
        return NULL;
    }

    //
    // Hook function pointers
    //
    pfnFDICreate = (PFNFDICREATE) GetProcAddress(hCabinetDll, "FDICreate");
    pfnFDICopy = (PFNFDICOPY) GetProcAddress(hCabinetDll, "FDICopy");
    pfnFDIIsCabinet = (PFNFDIISCABINET) GetProcAddress(hCabinetDll, "FDIIsCabinet");
    pfnFDIDestroy = (PFNFDIDESTROY) GetProcAddress(hCabinetDll, "FDIDestroy");

    if ((pfnFDICreate == NULL)    ||
        (pfnFDICopy == NULL)      ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary( hCabinetDll );
        return NULL;
    }

    //
    // Try to create an FDI context
    //
    hfdi = pfnFDICreate( pfnalloc,
                         pfnfree,
                         pfnopen,
                         pfnread,
                         pfnwrite,
                         pfnclose,
                         pfnseek,
                         cpuType,
                         perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
    }

    return hfdi;
}



////////////////////////////////////////////////////////////////////////////
//
//  FDIIsCabinet
//
//  Determines if file is a cabinet, returns info if it is
//
//  04-20-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL DIAMONDAPI FDIIsCabinet(
    HFDI            hfdi,
    INT_PTR         hf,
    PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return FALSE;
    }

    return (pfnFDIIsCabinet(hfdi,hf,pfdici));
}



////////////////////////////////////////////////////////////////////////////
//
//  FDICopy
//
//  Extracts files from a cabinet
//
//  04-20-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL DIAMONDAPI FDICopy(
    HFDI          hfdi,
    char         *pszCabinet,
    char         *pszCabPath,
    int           flags,
    PFNFDINOTIFY  pfnfdin,
    PFNFDIDECRYPT pfnfdid,
    void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return FALSE;
    }

    return (pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}



////////////////////////////////////////////////////////////////////////////
//
//  FDIDestroy
//
//  Destroy an FDI context. Should be called when you're done with the HFDI.
//
//  04-20-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL DIAMONDAPI FDIDestroy(
    HFDI hfdi)
{
    BOOL bRet;

    if (pfnFDIDestroy == NULL)
    {
        return FALSE;
    }

    bRet = pfnFDIDestroy( hfdi );
    if (bRet == TRUE)
    {
        FreeLibrary(hCabinetDll);
    }

    return bRet;
}



//-------------------------------------------------------------------------//
//                        FDI SUPPORT ROUTINES                             //
//-------------------------------------------------------------------------//


PVOID
DIAMONDAPI
DiamondMemAlloc(
    IN ULONG NumberOfBytes
    )
{
    return ((PVOID)LocalAlloc(LMEM_FIXED, NumberOfBytes));
}


VOID
DIAMONDAPI
DiamondMemFree(
    IN PVOID Block
    )
{
    LocalFree( (HLOCAL)Block );
}


INT_PTR
DIAMONDAPI
DiamondFileOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )
{
    HFILE h;
    int OpenMode;

    if (oflag & _O_WRONLY) 
    {
        OpenMode = OF_WRITE;
    } else 
    {
        if (oflag & _O_RDWR)
        {
            OpenMode = OF_READWRITE;
        } else 
        {
            OpenMode = OF_READ;
        }
    }

    h = _lopen(FileName, OpenMode | OF_SHARE_DENY_WRITE);

    if (h == HFILE_ERROR) 
    {
        return -1;
    }

    return ((INT_PTR) h);
}


UINT
DIAMONDAPI
DiamondFileRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )
{
    UINT rc;

    rc = _lread((HFILE)Handle, pv, ByteCount);

    if (rc == HFILE_ERROR) 
    {
        rc = (UINT)(-1);
    }

    return rc;
}


UINT
DIAMONDAPI
DiamondFileWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )
{
    UINT rc;

    rc = _lwrite((HFILE)Handle, (LPCSTR)pv, ByteCount);

    return rc;
}


int
DIAMONDAPI
DiamondFileClose(
    IN INT_PTR Handle
    )
{
    _lclose( (HFILE)Handle );
    return 0;
}


LONG
DIAMONDAPI
DiamondFileSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )
{
    LONG rc;

    rc = _llseek((HFILE)Handle, Distance, SeekType);

    if (rc == HFILE_ERROR) 
    {
        rc = -1L;
    }

    return rc;
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    switch (Operation)
    {        
        case fdintCABINET_INFO: // general information about the cabinet
            return 0;
        break;


        case fdintPARTIAL_FILE: // first file in cabinet is continuation
            return 0;
        break;

        case fdintCOPY_FILE:    // file to be copied
        {
            HFILE handle;
            char destination[256];
            PDIAMOND_PACKET pDiamond = (PDIAMOND_PACKET) Parameters->pv;

            
            //
            // Check to see if we just want the original file name
            //
            if (pDiamond->flags & DIAMOND_GET_DEST_FILE_NAME)
            {
                strcpy( pDiamond->szDestFilePath, 
                        Parameters->psz1 );
                return 0;
            }

            sprintf( destination,
                     "%s%s",
                     pDiamond->szDestFilePath,
                     Parameters->psz1
                   );

            handle = _lcreat(destination, 0);

            if (handle == HFILE_ERROR)
            {
                return -1;
            }

            return handle;
        }
        break;

        case fdintCLOSE_FILE_INFO:    // close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];
            PDIAMOND_PACKET pDiamond = (PDIAMOND_PACKET) Parameters->pv;


            if (pDiamond->flags & DIAMOND_GET_DEST_FILE_NAME)
            {
                return 0;
            }

            sprintf( destination,
                     "%s%s",
                     pDiamond->szDestFilePath,
                     Parameters->psz1
                   );

            _lclose( (HFILE)Parameters->hf );


            //
            // Set date/time
            //
            // Need Win32 type handle for to set date/time
            //
            handle = CreateFileA( destination,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL
                                );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime( Parameters->date,
                                                   Parameters->time,
                                                   &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime( &datetime,
                                                         &local_filetime))
                    {
                        SetFileTime( handle,
                                     &local_filetime,
                                     NULL,
                                     &local_filetime
                                   );
                    }
                }

                CloseHandle(handle);
            }

            //
            // Mask out attribute bits other than readonly,
            // hidden, system, and archive, since the other
            // attribute bits are reserved for use by
            // the cabinet format.
            //
            attrs = Parameters->attribs;

            attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

            SetFileAttributesA( destination,
                                attrs
                              );

            return TRUE;
        }
        break;

        case fdintNEXT_CABINET:  // file continued to next cabinet
            return 0;
        break;
    }

    return 0;
}




//-------------------------------------------------------------------------//
//                        MUISETUP-SUPPORT ROUTINES                        //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_InitDiamond
//
//  Initialize diamond DLL.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

HFDI Muisetup_InitDiamond()
{
    ERF erf;

    if (!ghfdi)
    {
        ghfdi = FDICreate( DiamondMemAlloc,
                           DiamondMemFree,
                           DiamondFileOpen,
                           DiamondFileRead,
                           DiamondFileWrite,
                           DiamondFileClose,
                           DiamondFileSeek,
                           cpuUNKNOWN,
                           &erf );
    }

    return ghfdi;
}


////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_FreeDiamond
//
//  Free diamond dll. Should be called at application shutdown.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_FreeDiamond()
{
    BOOL bRet = TRUE;

    if (ghfdi)
    {
        bRet = FDIDestroy(ghfdi);
    }

    return bRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_DiamondReset
//
//  Should be called at the start of processing a file to copy.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

void Muisetup_DiamondReset(
    PDIAMOND_PACKET pDiamond)
{
    pDiamond->flags = DIAMOND_NONE;

    return;
}



////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_IsDiamondFile
//
//  Determines if a file is a diamond file, and if so, returns its original
//  name.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_IsDiamondFile(
    PWSTR pwszFileName,
    PWSTR pwszOriginalName,
    INT nSize,
    PDIAMOND_PACKET pDiamond)
{
    INT_PTR hf;
    BOOL bRet;
    int nCount;
    char *p;
    FDICABINETINFO fdici;
    HFDI hfdi = ghfdi;


    if (!hfdi)
    {
#if SAMER_DBG
        OutputDebugStringA("Muisetup_IsDiamondFile : No HFDI context\n");
#endif
        return FALSE;
    }

    //
    // Init the diamond packet
    //
    pDiamond->flags = DIAMOND_NONE;

    if ((nCount = WideCharToMultiByte( CP_ACP,
                                       0,
                                       pwszFileName,
                                       -1,
                                       pDiamond->szSrcFilePath,
                                       sizeof( pDiamond->szSrcFilePath ),
                                       NULL,
                                       NULL )) == 0)
    {
#if SAMER_DBG
        OutputDebugStringA("Muisetup_IsDiamondFile : WideCharToMultiByte failed\n");
#endif
        return FALSE;
    }
    pDiamond->szSrcFilePath[ nCount ] = '\0';

    hf = DiamondFileOpen( pDiamond->szSrcFilePath,
                          _O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
                          0
                        );

    if (hf == -1)
    {
#if SAMER_DBG
        OutputDebugStringA("Muisetup_IsDiamondFile : file_open failed\n");
#endif
        return FALSE;
    }

    bRet = FDIIsCabinet( hfdi,
                         hf,
                         &fdici
                       );

    DiamondFileClose( hf );

    //
    // If succeeded, then let's setup everything else
    // to get the correct original file name
    //
    if (bRet)
    {
        pDiamond->flags |= DIAMOND_GET_DEST_FILE_NAME;

        p = strrchr(pDiamond->szSrcFilePath, '\\');

        if (p == NULL)
        {
            strcpy(pDiamond->szSrcFileName, pDiamond->szSrcFilePath);
            strcpy(pDiamond->szSrcFilePath, "");
        }
        else
        {
            strcpy(pDiamond->szSrcFileName, p+1);
            p[ 1 ] = '\0';
        }

        
        strcpy( pDiamond->szDestFilePath,
                "c:\\samer\\" );

        if (Muisetup_CopyDiamondFile( pDiamond,
                                      NULL))
        {
            //
            // Convert the original file name back to Unicode
            //
            nCount = MultiByteToWideChar( CP_ACP,
                                          0,
                                          pDiamond->szDestFilePath,
                                          -1,
                                          pwszOriginalName,
                                          nSize
                                        );

            if (!nCount)
            {
                return FALSE;
            }

            pwszOriginalName[ nCount ] = UNICODE_NULL;
            pDiamond->flags = DIAMOND_FILE;
        
#if SAMER_DBG
            {
                BYTE byBuf[200];

                wsprintfA(byBuf, "SrcFile = %s%s, OriginalFileName=%s\n", 
                                  pDiamond->szSrcFilePath,
                                  pDiamond->szSrcFileName,
                                  pDiamond->szDestFilePath);
                OutputDebugStringA(byBuf);
            }
#endif
        }

        pDiamond->flags &= ~DIAMOND_GET_DEST_FILE_NAME;
    }

    return bRet;
}




////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_CopyDiamondFile
//
//  Copies and expands a diamond file.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_CopyDiamondFile(
    PDIAMOND_PACKET pDiamond,
    PWSTR pwszCopyTo)
{
    char szDestPath[ MAX_PATH + 1];
    char *p;
    int nCount;
    BOOL bRet;
    HFDI hfdi = ghfdi;

    
    //
    // Validate that this is a diamond file
    //
    if ((!hfdi) ||
        (pDiamond->flags == DIAMOND_NONE))
    {
        return FALSE;
    }

    //
    // Validate flags
    //
    if (!(pDiamond->flags & (DIAMOND_FILE | DIAMOND_GET_DEST_FILE_NAME)))
    {
        return FALSE;
    }

#if SAMER_DBG
    {
      BYTE byBuf[100];
      wsprintfA(byBuf, "DiamondCopy called for %s, flags = %lx\n", pDiamond->szSrcFileName, pDiamond->flags);
      OutputDebugStringA(byBuf);
    }
#endif

    if (!(pDiamond->flags & DIAMOND_GET_DEST_FILE_NAME))
    {
        if ((nCount = WideCharToMultiByte( CP_ACP,
                                           0,
                                           pwszCopyTo,
                                           -1,
                                           szDestPath,
                                           sizeof( szDestPath ),
                                           NULL,
                                           NULL )) == 0)
        {
            return FALSE;
        }
        szDestPath[ nCount ] = '\0';


        p = strrchr(szDestPath, '\\');
        if (p)
        {
            p[1] = '\0';
        }
        else
        {
            szDestPath[ nCount ] = '\\';
            szDestPath[ nCount + 1 ] = '\0';
        }

        strcpy( pDiamond->szDestFilePath,
                szDestPath );
    }


    bRet = FDICopy( hfdi,
                    pDiamond->szSrcFileName,
                    pDiamond->szSrcFilePath,
                    0,
                    DiamondNotifyFunction,
                    NULL,
                    pDiamond);

#if SAMER_DBG
    {
        BYTE byBuf[200];

        wsprintfA(byBuf, "SrcFile = %s%s, DestPath=%s, Status=%lx\n", 
                         pDiamond->szSrcFilePath,
                         pDiamond->szSrcFileName,
                         pDiamond->szDestFilePath,
                         bRet);
        OutputDebugStringA(byBuf);
    }
#endif

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\wixload.inc ===
'<script language='VBScript'>
' wixload.inc - preprocessor for Windows Installer XML
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    wixerror.inc
'    xmlconsts.inc
'
' entrypoints:
'    WixLoad
'    WixApplyStyleSheet
'    WixPreProcess
'

Public wixload_dictPreProcessVars       ' As Scripting.Dictionary
Public wixload_sPreProcessIncludePaths  ' As String

Public wixload_fso                      ' As Scripting.FileSystemObject
Public wixload_sLoadDir                 ' As String

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' WixLoad
Function WixLoad(ByVal sPath, ByVal sIncludePaths, ByRef dictVars, ByVal bProcess)
   Dim xmlDoc :  Set xmlDoc = WScript.CreateObject("Microsoft.XMLDOM")
'WScript.Echo "Including: " & sPath
   ' set the global variables
   If Not IsEmpty(sIncludePaths) Then wixload_sPreProcessIncludePaths = sIncludePaths
   If Not IsEmpty(dictVars) Then Set wixload_dictPreProcessVars = dictVars
   If IsEmpty(wixload_dictPreProcessVars) Then Set wixload_dictPreProcessVars = WScript.CreateObject("Scripting.Dictionary")

   If IsEmpty(wixload_fso) Then Set wixload_fso = WScript.CreateObject("Scripting.FileSystemObject")
   If IsEmpty(wixload_sLoadDir) Then
      wixload_sLoadDir = wixload_fso.GetParentFolderName(wixload_fso.GetAbsolutePathName(sPath))
	  Dim nFind : nFind = InStrRev(sPath, "\")
      If 0 < nFind Then sPath = Mid(sPath, nFind + 1)
   End If
   
   ' try to load the document
   xmlDoc.preserveWhiteSpace = False
   xmlDoc.async = False
'   xmlDoc.validateOnParse = False
'   xmlDoc.resolveExternals = False

'WScript.Echo "Xml validate: " & xmlDoc.validateOnParse
'WScript.Echo "Xml resolve: " & xmlDoc.resolveExternals

'   Dim e : Set e = xmlDoc.createEntityReference("foo")
'   Dim n : Set n = xmlDoc.createElement("wazz")
'   n.nodeValue = "up"
'   e.nodeValue = "bar"
'   n.appendChild e
'WScript.Echo "xml: " & e.xml

   Dim bLoaded :  bLoaded = xmlDoc.load(wixload_sLoadDir & "\" & sPath)
   If Not bLoaded Then
      Dim pe :  Set pe = xmlDoc.parseError
      Dim sErr : sErr = "Failed to load XML file: " & pe.url & vbCrLf & "   " & pe.errorCode & " - " & pe.reason & vbCrLf & "   Line:" & pe.line & ", Character: " & pe.linepos
      Fail sErr
   End If

   ' if there is no root return with nothing
   Dim root : Set root = xmlDoc.firstChild
   If root Is Nothing Then 
      Set WixLoad = Nothing
      Exit Function
   End If

   If bProcess Then WixPreProcess root, Empty, Empty

   ' return the preprocessed    
   Set WixLoad = xmlDoc
End Function   ' WixLoad


''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' WixApplyStyleSheet
Function WixApplyStyleSheet(ByRef xmlDoc, ByVal sPath)
   Dim xmlStyle :  Set xmlStyle = WixLoad(sPath, Empty, Empty, False)

   ' if there is no root return with nothing changed
   Dim root : Set root = xmlStyle.firstChild
   If root Is Nothing Then 
      Set WixApplyStyleSheet = xmlDoc
      Exit Function
   End If

   Dim s :  sApplied = xmlDoc.transformNode(xmlStyle)
   xmlDoc.loadXml sApplied
   If xmlDoc.parseError.errorCode <> 0 Then
      Dim pe :  Set pe = xmlDoc.parseError
      Dim sErr : sErr = "Failed to properly apply stylesheet: " & sPath & " to XML file: " & pe.url & vbCrLf & "   " & pe.errorCode & " - " & pe.reason & vbCrLf & "   Line:" & pe.line & ", Character: " & pe.linepos
      Fail sErr
   End If

   Set WixApplyStyleSheet = xmlDoc
End Function   ' WixApplyStyleSheet


''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' WixPreProcess
Function WixPreProcess(ByRef root, ByVal sIncludePaths, ByRef dictVars)
   Dim child, nStartEntity, nEndEntity
'WScript.Echo "WixPreProcess"
   ' set the global variables
   If Not IsEmpty(sIncludePaths) Then wixload_sPreProcessIncludePaths = sIncludePaths
   If Not IsEmpty(dictVars) Then Set wixload_dictPreProcessVars = dictVars
   If IsEmpty(wixload_dictPreProcessVars) Then Set wixload_dictPreProcessVars = WScript.CreateObject("Scripting.Dictionary")

   ' if there is no root return with nothing   
'   Set root = xmlDoc.firstChild
   If root Is Nothing Then
      Set WixPreProcess = Nothing
      Exit Function
   End If
'WScript.Echo "Foo"
   ' loop through all of the nodes in the document
   ' !!! - should root just get children who are processing instructions?
   For Each child In root.childNodes
'WScript.Echo "child: " & child.nodeName
      ' look only at processing instructions
      If NODE_PROCESSING_INSTRUCTION = child.nodeType Then
         Select Case(child.target)
         Case "include" : wixload_WixProcessInclude child, child.parentNode : child.parentNode.removeChild child
         Case "if"      : wixload_WixProcessIf      child, child.parentNode
         Case "define"
            Dim var, name, value
            var = Split(child.data, "=")
            name = wixload_WixFixVarName(var(0))
            If UBound(var) > 0 Then value = var(1) Else value = True
            wixload_dictPreProcessVars.Add name, value
         Case "else"
         Case "endif"
         Case Else      : Fail "Unexpected processor instruction: " & child.target
         End Select
      ElseIf NODE_CDATA_SECTION <> child.nodeType Then	' don't do entity replacments in CDATA Sections
	     nStartEntity = InStr(child.nodeValue, "&")
         If 0 < nStartEntity Then
            nEndEntity = InStr(child.nodeValue, ";")
            If nEndEntity < nStartEntity Then
               Fail "Failed entity lookup for: " & child.nodeValue
            Else
               sVar = Mid(child.nodeValue, nStartEntity + 1, nEndEntity - nStartEntity - 1)
               If Not wixload_dictPreProcessVars.Exists(sVar) Then
                  Fail "Unknown entity reference: " & sVar
               Else
                  child.nodeValue = Left(child.nodeValue, 0, nStartEntity - 1) & wixload_dictPreProcessVars.Item(sVar) & Mid(child.nodeValue, nEndEntity + 1)
               End If
            End If
         End If
      End If
      If child.HasChildNodes Then
'WScript.Echo "Going down"
         WixPreProcess child, Empty, Empty
      End If
   Next

   Set WixPreProcess = root
End Function

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' wixload_WixProcessIf
Function wixload_WixProcessIf(node, nodeParent)
   Dim sEval : sEval = node.data
   Dim fInclude
   Dim fKeep : fKeep = wixload_WixEvaluate(sEval)

   Dim remove  ' node to remove possibly
   Dim sibling : Set sibling = node.nextSibling
   Do Until sibling Is Nothing
      fInclude = False  ' make sure the include flag is always started off

      If NODE_PROCESSING_INSTRUCTION = sibling.nodeType Then
         Select Case sibling.target
         Case "endif"   : Exit Do
         Case "else"    : fKeep = Not fKeep
         Case "include" : fInclude = True
         Case Else      : Fail "Unexepected processor instruction: " & sibling.target
         End Select
      End If

      ' move the sibling along
      Set remove = sibling
      Set sibling = sibling.nextSibling

      ' if we're not keeping nodes toast this one
      If Not fKeep Then 
         nodeParent.removeChild remove
      ElseIf fInclude Then ' if we're keeping nodes and this is an include node
         wixload_WixProcessInclude remove, remove.parentNode
         nodeParent.removeChild remove ' always remove the <?include ?> node
      End If
   Loop
End Function   ' wixload_WixProcessIf

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' wixload_WixProcessInclude
Function wixload_WixProcessInclude(node, nodeParent)
   Dim sOldDir, sLoad, sProcess
'WScript.Echo "Processing include, load: " & sLoad

   sLoad = node.data
   If InStr(sLoad , "\") Or InStr(sLoad, "/") Then
      sProcess = wixload_fso.GetAbsolutePathName(sLoad)
      If wixload_sLoadDir <> wixload_fso.GetParentFolderName(sProcess) Then
         sOldDir = wixload_sLoadDir
         wixload_sLoadDir = wixload_fso.GetParentFolderName(sProcess)
'WScript.Echo "Changing load dir from: " & sOldDir & " to: " & wixload_sLoadDir
         sLoad = wixload_fso.GetFileName(sLoad)
      End If
   End If

   Dim xmlInclude : Set xmlInclude = WixLoad(sLoad, Empty, Empty, True)
   If xmlInclude Is Nothing Then Fail "Failed to include: " & sLoad

   ' reset the wixload directory
   If 0 < Len(sOldDir) Then wixload_sLoadDir = sOldDir

   ' load the fragment and make sure it hooked up correctly
   Dim sParent, nodeFragment : Set nodeFragment = xmlInclude.firstChild
   If "Fragment" <> nodeFragment.nodeName Then Fail "Can only <?include ?> <Fragments />."
   If Not nodeFragment.selectSingleNode("text()") Is Nothing Then
      sParent = nodeFragment.firstChild.nodeValue  ' get the type of <Fragment>
   End If
   If Len(sParent) > 0 And nodeParent.nodeName <> sParent Then Fail "Fragment type: " & sParent & " does not match parent type: " & nodeParent.nodeName

   Dim child
   For Each child In nodeFragment.childNodes
'      If NODE_ELEMENT = child.nodeType Then nodeParent.insertBefore child, node
      nodeParent.insertBefore child, node
   Next
   
   Set wixload_WixProcessInclude = node
End Function   ' wixload_WixProcessInclude


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' helper functions

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' wixload_WixFixVarName
Function wixload_WixFixVarName(ByVal s)
   If "[" = Left(s, 1) Then s = Mid(s, 2)
   If "]" = Right(s, 1) Then s = Mid(s, 1, Len(s) - 1)
   If Instr(1, s, "]") Or Instr(1, s, "[") Then Fail "Invalid variable name: " & s
   wixload_WixFixVarName = s
End Function   ' wixload_WixFixVarName


''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' wixload_WixEvaluate
Function wixload_WixEvaluate(sExpression)
   sExpression = Replace(sExpression, "[", " wixload_dictPreProcessVars.Item(""")
   sExpression = Replace(sExpression, "]", """) ")
   wixload_WixEvaluate = CBool(Eval(sExpression))
End Function   ' wixload_WixEvaluate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muisetup\muisetup.h ===
#ifndef __MUISETUP_H_
#define __MUISETUP_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <winnls.h>
#include "installer.h"
#include "resource.h"
#include "sxsapi.h"


#define SUPPORT_PSEUDO_BUILD
//#define IGNORE_COPY_ERRORS

#define MUISETUP_HELP_FILENAME         TEXT("muisetup.hlp")
#define MUISETUP_EXECUTION_FILENAME    TEXT("muisetup.exe")
#define MUISETUP_ASSEMBLY_INSTALLATION_LOG_FILENAME TEXT("muisetup.log.") // langid would be ext

#define MUISETUP_ASSEMBLY_INSTALLATION_REFERENCE_IDENTIFIER TEXT("MUISETUP installation");

#define MUISETUP_PATH_SEPARATOR        TEXT("\\")

#define MUISETUP_FORWARDCALL_TAG       TEXT("/$_transfer_$")
#define MUI_FILLER_CHAR                TEXT('?')

//
// Context Help IDs for Muisetup
//
#define IDH_COMM_GROUPBOX              28548
#define IDH_MUISETUP_UILANGUAGE_LIST   3000
#define IDH_MUISETUP_UILANGUAGECOMBO   3001
#define IDH_MUISETUP_COMMANDLINE       3002
#define IDH_MUISETUP_CHECKLOCALE       3003
#define IDH_MUISETUP_MATCHUIFONT       3004
#define MAX_UI_LANG_GROUPS             64
#define INSTALLED_FILES                1500


#define MAX_MUI_LANGUAGES   32

#define MESSAGEBOX(hWnd, lpText, lpCaption, uiType)  (g_bSilent? IDNO : MessageBox(hWnd, lpText, lpCaption, uiType))

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

#define BUFFER_SIZE 1024

#define MUI_MATCH_LOCALE    0x0001
#define MUI_MATCH_UIFONT    0x0002

#define REGSTR_MUI_SETTING  TEXT("System\\CurrentControlSet\\Control\\NLS\\MUILanguages")
#define REGSTR_VALUE_MATCH_LOCALE TEXT("MatchSystemLocale")
#define REGSTR_VALUE_MATCH_UIFONT TEXT("UIFontSubstitute")

#define IS_FE_LANGPACK(lcid) (((lcid) == 0x0804) || ((lcid) == 0x0404) || ((lcid)==0x0411) || ((lcid)==0x0412))

//
// MUI Language Info attached to listview item
//
typedef struct _MUILANGIINFO_structtag
{
    LGRPID lgrpid;               // MUI's Lang Group

    LCID   lcid;                 // MUI's Lang LCID

    LPTSTR lpszLcid;             // MUI's LCID name

    TCHAR  szDisplayName[BUFFER_SIZE];    // The display for this language.

    int    cd_number;
    INT64  ulLPKSize;            // Size of LPK for this LCID 
    INT64  ulUISize;             // Size of MUI Resource files for this LCID

} MUILANGINFO, *PMUILANGINFO;


typedef struct _INSTALL_LANG_GROUP_Structtag
{
    LGRPID lgrpid[MAX_MUI_LANGUAGES];   // MUI Lang Group to install

    int    iCount;                      // count of MUI lang group to install
    BOOL   bFontLinkRegistryTouched;    // We have touched font link registry
    int    NotDeleted;

} INSTALL_LANG_GROUP, *PINSTALL_LANG_GROUP;

typedef struct UI_LangGroup_Structtag
{
    int    iCount;
    
    LCID lcid[MAX_UI_LANG_GROUPS];

} UILANGUAGEGROUP, *PUILANGUAGEGROUP;

typedef struct _FILERENAME_TABLE_Structtag
{
   TCHAR   szSource[MAX_PATH+1];
   TCHAR   szDest  [MAX_PATH+1];
}  FILERENAME_TABLE,*PFILERENAME_TABLE;

typedef struct _TYPENOTFALLBACK_TABLE_Structtag
{
   TCHAR   szSource[MAX_PATH+1];
} TYPENOTFALLBACK_TABLE,*PTYPENOTFALLBACK_TABLE;


//
//...Macro for ListView checkboxes
//
#ifndef ListView_SetCheckState
   #define ListView_SetCheckState(hwndLV, i, fCheck) \
      ListView_SetItemState(hwndLV, i, \
      INDEXTOSTATEIMAGEMASK((fCheck)+1), LVIS_STATEIMAGEMASK)
#endif

#define LOG_FILE TEXT("\\muisetup.log")
#define REG_MUI_PATH TEXT("System\\CurrentControlSet\\Control\\Nls\\MUILanguages")
#define REG_FILEVERSION_PATH TEXT("System\\CurrentControlSet\\Control\\Nls\\MUILanguages\\FileVersions")
#define MUI_LANG_GROUP_FILE TEXT("muilang.txt")

extern UINT (WINAPI *pfnGetWindowsDir)(LPWSTR pBuf, UINT uSize);

BOOL DeleteSideBySideMUIAssemblyIfExisted(LPTSTR Languages, TCHAR buf[BUFFER_SIZE]);

BOOL CheckMultipleInstances(void);
void InitGlobals(void);
void Muisetup_Cleanup();
void SetSourcePath(LPTSTR lpszPath);
LPTSTR NextCommandTag(LPTSTR lpcmd);
BOOL InitializePFNs();

void Muisetup_RebootTheSystem(void);
BOOL CheckForReboot(HWND hwnd, PINSTALL_LANG_GROUP pInstallLangGroup);
BOOL CheckDefault(HWND hwndDlg);
BOOL CheckLangGroupCommandLine(PINSTALL_LANG_GROUP pInstallLangGroup, LPTSTR lpArg);
BOOL DeleteFiles(LPTSTR Languages,int *lpNotDeleted);
int  EnumSelectedLanguages(HWND hList, LPTSTR lpAddLanguages);
int  EnumUnselectedLanguages(HWND hList, LPTSTR lpRemoveLanguages);
BOOL HaveFiles(LPTSTR lpBuffer, BOOL bCheckDir = TRUE);
BOOL InitializeInstallDialog(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL InitializeListView(HWND hList);
BOOL UpdateFontLinkRegistry(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched);
BOOL IsInstalled(LPTSTR lpUILang);
DWORD GetInstalledMUILanguages(LPTSTR lpUninstall, int cch);
BOOL ListViewChanged(HWND hDlg, int iID, NM_LISTVIEW *pLV);
BOOL ListViewChanging(HWND hDlg, int iID, NM_LISTVIEW *pLv);

BOOL RunRegionalOptionsApplet(LPTSTR pCommands);

BOOL ParseCommandLine(LPTSTR lpCommandLine);
BOOL StartGUISetup(HWND hwndDlg);
BOOL SelectInstalledLanguages(HWND hList);
BOOL SetDefault(HWND hCombo);
BOOL SetUserDefaultLanguage(LANGID langID, BOOL bApplyCurrentUser, BOOL bApplyAllUsers);
BOOL UninstallUpdateRegistry(LPTSTR Languages);
BOOL UpdateCombo(HWND hwndDlg);
INT_PTR CALLBACK DialogFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProgressDialogFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL GetMuiLangInfoFromListView(HWND hList, int i, PMUILANGINFO *ppMuiLangInfo);
int Muisetup_GetLocaleLanguageInfo(LCID lcid, PTSTR pBuf, int iLen, BOOL fCountryName);


HKEY OpenMuiKey(REGSAM samDesired);
BOOL GetLcidItemIndexFromListView(HWND hList, LCID lcid, int *piIndex);


int CopyArgument(LPTSTR dest, LPTSTR src);
int InsertLanguageInListView(HWND hList, LPTSTR lpLanguage, BOOL bCheckState);
int InstallSelected (LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched);
int UninstallSelected(LPTSTR Languages,int *lpNotDeleted);

PTCHAR SkipBlanks(PTCHAR pszText);

void DisplayHelpWindow(void);
void ListViewCustomDraw(HWND hDlg, LPNMLVCUSTOMDRAW pDraw);

// Language Group Installation
BOOL CALLBACK EnumLanguageGroupsProc(
  LGRPID LanguageGroup,
  LPTSTR lpLanguageGroupString,
  LPTSTR lpLanguageGroupNameString,
  DWORD dwFlags,
  LONG_PTR lParam);
LGRPID GetLanguageGroup( LCID lcid );
BOOL EnumLanguageGroupLocalesProc(
    LGRPID langGroupId, 
    LCID lcid, 
    LPTSTR lpszLocale,
    LONG_PTR lParam);
BOOL DetectLanguageGroups(HWND hwndDlg);
BOOL ConvertMUILangToLangGroup(HWND hwndDlg, PINSTALL_LANG_GROUP pInstallLangGroup);
BOOL AddMUILangGroup(PINSTALL_LANG_GROUP pInstallLangGroup, LGRPID lgrpid);
BOOL InstallLanguageGroups(PINSTALL_LANG_GROUP pInstallLangGroup);
BOOL CheckVolumeChange();
BOOL StartFromTSClient();
BOOL CheckLanguageIsQualified(LPTSTR lpLanguage);

BOOL CALLBACK Region_EnumUILanguagesProc(PWSTR pwszUILanguage,LONG_PTR lParam);
BOOL MUIGetAllInstalledUILanguages();
BOOL GetUIFileSize_commandline(LPTSTR lpszLcid, INT64 *ulUISize,INT64 *ulLPKSize);
BOOL GetUIFileSize(PMUILANGINFO pMuiLangInfo);
BOOL IsSpaceEnough(HWND hList,INT64 *ulSizeNeed,INT64 *ulSizeAvailable);
BOOL CopyRemoveMuiItself(BOOL bInstall);
BOOL RemoveFileReadOnlyAttribute(LPTSTR lpszFileName);
BOOL MUI_DeleteFile(LPTSTR lpszFileName);
void Set_SourcePath_FromForward(LPCTSTR lpszPath);
BOOL MUIShouldSwitchToNewVersion(LPTSTR lpszCommandLine);
BOOL MUI_TransferControlToNewVersion(LPTSTR lpszExecutable,LPTSTR lpszCommandLine);
void ExitFromOutOfMemory();
void NotifyKernel(
    LPTSTR LangList,
    ULONG Flags
    );
BOOL WelcomeDialog(HWND hWndParent);
BOOL DoSetup(
    HWND hwnd,
    int UninstallLangCount, LPTSTR lpUninstall, 
    INSTALL_LANG_GROUP installLangGroup, 
    int InstallLangCount, LPTSTR lpInstall, 
    LPTSTR lpDefaultUILang,
    BOOL fAllowReboot, BOOL bInteractive);

//
// Utility functions
//
BOOL IsAdmin(void);
DWORD_PTR TransNum(LPTSTR lpsz);
LANGID GetDotDefaultUILanguage();

//
// Log functions
//
HANDLE OpenLogFile(void);
void BeginLog(void);
BOOL LogMessage(LPCTSTR lpMessage);
BOOL LogFormattedMessage(HINSTANCE hInstance, int messageID, LONG_PTR* lppArgs);

//
// Resource utility functions
//
int DoMessageBox(HWND hwndParent, UINT uIdString, UINT uIdCaption, UINT uType);
int DoMessageBoxFromResource(HWND hwndParent, HMODULE hInstance, UINT uIdString, LONG_PTR* lppArgs, UINT uIdCaption, UINT uType);

LPTSTR FormatStringFromResource(LPTSTR pszBuffer, UINT bufferSize, HMODULE hInstance, int messageID, LONG_PTR* lppArgs);
void SetWindowTitleFromResource(HWND hwnd, int resourceID);

//
//  Registry utility functions
//
DWORD DeleteRegTree(HKEY hStartKey, LPTSTR pKeyName);



//
// External data refereces
//
extern BOOL gbError;
extern HINSTANCE ghInstance;
extern HWND ghProgress;
extern HWND ghProgDialog;

typedef
NTSTATUS
(NTAPI *pfnNtSetDefaultUILanguage)(
    LANGID DefaultUILanguageId
    );

typedef
LANGID
(WINAPI *pfnGetUserDefaultUILanguage)(
    void
    );

typedef
LANGID
(WINAPI *pfnGetSystemDefaultUILanguage)(
    void
    );

typedef
BOOL
(WINAPI *pfnIsValidLanguageGroup)(
    LGRPID LanguageGroup,
    DWORD dwFlags
    );

typedef
BOOL
(WINAPI *pfnEnumLanguageGroupLocalesW)(
    LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam
    );

typedef
BOOL
(WINAPI *pfnEnumSystemLanguageGroupsW)(
    LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam
    );

typedef
NTSTATUS
(NTAPI *pfnRtlAdjustPrivilege)(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,PBOOLEAN WasEnabled
    );

typedef
BOOL
(WINAPI *pfnGetDefaultUserProfileDirectoryW)(
    LPWSTR lpProfileDir,
    LPDWORD lpcchSize
    );

typedef 
BOOL (WINAPI *pfnMUI_InstallMFLFiles)( 
    TCHAR* pMUIInstallLanguage
    );

typedef
BOOL
(WINAPI *pfnProcessIdToSessionId)(
    DWORD_PTR dwProcessId,
    DWORD_PTR *pSessionId
    );

typedef
INT
(WINAPI *pfnLaunchINFSection)(
    HWND hWnd,
    HINSTANCE hInstance,
    PSTR pParams,
    INT flags
);

typedef BOOL (*UILANGUAGE_ENUMPROC)(LPTSTR, LONG_PTR);
typedef BOOL (*pfnEnumUILanguages)(UILANGUAGE_ENUMPROC, DWORD, LONG_PTR);

extern pfnNtSetDefaultUILanguage gpfnNtSetDefaultUILanguage;
extern pfnGetUserDefaultUILanguage gpfnGetUserDefaultUILanguage;
extern pfnGetSystemDefaultUILanguage gpfnGetSystemDefaultUILanguage;
extern pfnIsValidLanguageGroup gpfnIsValidLanguageGroup;
extern pfnEnumLanguageGroupLocalesW gpfnEnumLanguageGroupLocalesW;
extern pfnEnumSystemLanguageGroupsW gpfnEnumSystemLanguageGroupsW;
extern pfnRtlAdjustPrivilege gpfnRtlAdjustPrivilege;
extern pfnProcessIdToSessionId gpfnProcessIdToSessionId;
extern pfnGetDefaultUserProfileDirectoryW gpfnGetDefaultUserProfileDirectoryW;
extern pfnLaunchINFSection gpfnLaunchINFSection;
extern PSXS_INSTALL_W gpfnSxsInstallW;
extern PSXS_UNINSTALL_ASSEMBLYW gpfnSxsUninstallW;

extern TCHAR g_szPlatformPath[];
extern TCHAR g_AddLanguages[];
extern TCHAR g_szMUIInfoFilePath[];
extern TCHAR g_szMUISetupFolder[];
extern TCHAR g_szMuisetupPath[];
extern TCHAR g_szMUIHelpFilePath[];
extern TCHAR g_szWinDir[];
extern BOOL  g_InstallCancelled;
extern BOOL  g_IECopyError;
extern BOOL  gbIsWorkStation,gbIsServer,gbIsAdvanceServer,gbIsDataCenter,gbIsDomainController;
extern PFILERENAME_TABLE g_pFileRenameTable;
extern int   g_nFileRename;
extern PTYPENOTFALLBACK_TABLE g_pNotFallBackTable;
extern int   g_nNotFallBack;
extern LPTSTR g_SpecialFiles[];
extern int gNumLanguages_Install;
extern UILANGUAGEGROUP g_UILanguageGroup;
extern LANGID gUserUILangId, gSystemUILangId;
BOOL GetLanguageGroupDisplayName(LANGID LangId, LPTSTR lpBuffer, int nSize);

BOOL CheckMUIRegSetting(DWORD dwFlag);
BOOL SetMUIRegSetting(DWORD dwFlag, BOOL bEnable);
BOOL AddExtraLangGroupsFromINF(LPTSTR lpszLcid, PINSTALL_LANG_GROUP pInstallLangGroup);
BOOL InstallExternalComponents(LPTSTR Languages);
VOID UninstallExternalComponents(LPTSTR Languages);

#endif //__MUISETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muisetup\muisetup.cpp ===
////////////////////////////////////////////////////////////////////////////
//
//  MUISetup.c
//
//  This file contains the WinMain() and the UI handling of MUISetup.
//
//  MUISetup is compiled as an Unicode application.
//
////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <userenv.h>
#include <shellapi.h>
#include <regstr.h>
#include <wmistr.h>
#include <wmiumkm.h>
#include <setupapi.h>
#include <shlwapi.h>

#include "sxsapi.h"
#include "muisetup.h"

//
// Context Help IDs
//
//
//  Context Help Ids.
//

#define IA64_WOW64FOLDER TEXT("SysWOW64")

STDAPI_(BOOL) IsUserAnAdmin();

static int aMuisetupHelpIds[] =
{
    207,        IDH_COMM_GROUPBOX,              // Group Box
    IDC_LIST1,  IDH_MUISETUP_UILANGUAGE_LIST,   // UI Language ListView
    IDC_DEF_UI_LANG_COMBO, IDH_MUISETUP_UILANGUAGECOMBO,   // UI ComboBox selection
    IDC_CHECK_LOCALE, IDH_MUISETUP_CHECKLOCALE, // Match system locale with UI language
    IDC_CHECK_UIFONT, IDH_MUISETUP_MATCHUIFONT, // Match system locale with UI language
    0, 0
};


//
//  Global variables
//
BOOL InstallDialogStarted;
BOOL gbError;
BOOL g_bMatchUIFont;

// Store the special directories listed under [Directories] in mui.inf
TCHAR DirNames[MFL][MAX_PATH],DirNames_ie[MFL][MAX_PATH];

TCHAR szWindowsDir[MAX_PATH];

// The FOLDER where MUISetup.exe is executed.
TCHAR g_szMUISetupFolder[MAX_PATH];
// The FULL PATH for MUISetup.exe.
TCHAR g_szMuisetupPath[MAX_PATH];

// The full path where MUI.inf is located.
TCHAR g_szMUIInfoFilePath[MAX_PATH];

TCHAR g_szVolumeName[MAX_PATH],g_szVolumeRoot[MAX_PATH];
TCHAR g_szMUIHelpFilePath[MAX_PATH],g_szPlatformPath[16],g_szCDLabel[MAX_PATH];

// Windows directory
TCHAR g_szWinDir[MAX_PATH];

TCHAR g_AddLanguages[BUFFER_SIZE];

HANDLE ghMutex = NULL;

HINSTANCE ghInstance;

HWND ghProgDialog;      // The progress dialog showed during installation/uninstallation.
HWND ghProgress;        // The progress bar in the progress dialog

LANGID gUserUILangId, gSystemUILangId;
BOOL gbIsWorkStation,gbIsServer,gbIsAdvanceServer,gbIsDataCenter,gbIsDomainController;
HINSTANCE g_hUserEnvDll = NULL;
HMODULE g_hAdvPackDll = NULL;
HMODULE g_hSxSDll = NULL;

DWORD g_dwVolumeSerialNo;
BOOL g_InstallCancelled,g_IECopyError,g_bRemoveDefaultUI,g_bRemoveUserUI,g_bCmdMatchLocale,g_bCmdMatchUIFont, g_bReboot;
UILANGUAGEGROUP g_UILanguageGroup;

int g_cdnumber;

// Number of locales supported by the OS
int iLocaleCount;

// Number of MUI languges to insatll
int gNumLanguages,gNumLanguages_Install,gNumLanguages_Uninstall;

// Flag to indicate whether a language group is found for the locale or not.
BOOL gFoundLangGroup;
LGRPID gLangGroup;
LCID gLCID;

// The language groups installed in the system.
LGRPID gLanguageGroups[32] ;
int gNumLanguageGroups;

PFILERENAME_TABLE g_pFileRenameTable;
int   g_nFileRename;
PTYPENOTFALLBACK_TABLE g_pNotFallBackTable; 
int   g_nNotFallBack;                       

BOOL g_bSilent=FALSE;

//
// Required pfns
//

pfnNtSetDefaultUILanguage gpfnNtSetDefaultUILanguage;
pfnGetUserDefaultUILanguage gpfnGetUserDefaultUILanguage;
pfnGetSystemDefaultUILanguage gpfnGetSystemDefaultUILanguage;
pfnIsValidLanguageGroup gpfnIsValidLanguageGroup;
pfnEnumLanguageGroupLocalesW gpfnEnumLanguageGroupLocalesW;
pfnEnumSystemLanguageGroupsW gpfnEnumSystemLanguageGroupsW;
pfnRtlAdjustPrivilege gpfnRtlAdjustPrivilege;
pfnProcessIdToSessionId gpfnProcessIdToSessionId;
pfnGetDefaultUserProfileDirectoryW gpfnGetDefaultUserProfileDirectoryW = NULL;
pfnLaunchINFSection gpfnLaunchINFSection = NULL;
PSXS_INSTALL_W              gpfnSxsInstallW = NULL;
PSXS_UNINSTALL_ASSEMBLYW    gpfnSxsUninstallW = NULL;

//
// GetWindowsDirectory stuff
//
UINT WINAPI NT4_GetWindowsDir(LPWSTR pBuf, UINT uSize)
{
    return GetWindowsDirectoryW(pBuf, uSize);
}


//
// shlwapi StrToIntEx doesn't work for us
//
DWORD HexStrToInt(LPTSTR lpsz)
{
    DWORD   dw = 0L;
    TCHAR   c;

    while(*lpsz)
    {
        c = *lpsz++;

        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }

    return(dw);
}

UINT (WINAPI *pfnGetWindowsDir)(LPWSTR pBuf, UINT uSize) = NT4_GetWindowsDir;

void InitGetWindowsDirectoryPFN(HMODULE hMod)
{
    pfnGetWindowsDir = (UINT (WINAPI *) (LPWSTR pBuf, UINT uSize)) GetProcAddress(hMod, "GetSystemWindowsDirectoryW");
    if (!pfnGetWindowsDir)
    {
        pfnGetWindowsDir = NT4_GetWindowsDir;
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageDisplayName
//
//  Get the display name (in the form of "Language (Region)") for the specified
//  language ID.
//
//  Parameters:
//      [IN]  langID        Language ID
//      [OUT] lpBuffer      the buffer to receive the display name.
//      [IN]  nBufferSize   the size of buffer, in TCHAR.
//
//  Return Values:
//      TRUE if succeed.  FALSE if the buffer is not big enough.
//
//
//  01-11-2001  YSLin       Created.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetLanguageDisplayName(LANGID langID, LPTSTR lpBuffer, int nBufferSize)
{
    TCHAR lpLangName[BUFFER_SIZE];
    TCHAR lpRegionName[BUFFER_SIZE];
    int nCharCount = 0;
    
    nCharCount  = GetLocaleInfo(langID, LOCALE_SENGLANGUAGE, lpLangName, ARRAYSIZE(lpLangName)-1);
    nCharCount += GetLocaleInfo(langID, LOCALE_SENGCOUNTRY , lpRegionName, ARRAYSIZE(lpRegionName)-1);
    nCharCount += 3;

    if (nCharCount > nBufferSize)
    {
        if (nBufferSize)
            lstrcpy(lpBuffer, TEXT(""));
        return (FALSE);
    }

    wsprintf(lpBuffer, TEXT("%s (%s)"), lpLangName, lpRegionName);

    return (TRUE);                
}

//
// Our Message Box
//
int DoMessageBox(HWND hwndParent, UINT uIdString, UINT uIdCaption, UINT uType)
{
   TCHAR szString[MAX_PATH+MAX_PATH];
   TCHAR szCaption[MAX_PATH];

   szString[0] = szCaption[0] = TEXT('\0');

   if (uIdString)
       LoadString(NULL, uIdString, szString, MAX_PATH+MAX_PATH-1);

   if (uIdCaption)
       LoadString(NULL, uIdCaption, szCaption, MAX_PATH-1);

   return MESSAGEBOX(hwndParent, szString, szCaption, uType);
}

////////////////////////////////////////////////////////////////////////////
//
//  DoMessageBoxFromResource
//
//  Load a format string from resource, and format the string using the 
//  specified arguments.  Display a message box using the formatted string.
//
//  Parameters:
//
//  Return Values:
//      The return value from MessageBox.
//
//  Remarks:
//      The length of the formatted string is limited by BUFFER_SIZE.
//
//  08-07-2000  YSLin       Created.
//
////////////////////////////////////////////////////////////////////////////

int DoMessageBoxFromResource(HWND hwndParent, HMODULE hInstance, UINT uIdString, LONG_PTR* lppArgs, UINT uIdCaption, UINT uType)
{
    TCHAR szString[BUFFER_SIZE];
    TCHAR szCaption[BUFFER_SIZE];

    szString[0] = szCaption[0] = TEXT('\0');

    if (uIdCaption)
       LoadString(hInstance, uIdCaption, szCaption, MAX_PATH-1);
    
    FormatStringFromResource(szString, sizeof(szString)/sizeof(TCHAR), hInstance, uIdString, lppArgs);

    return (MESSAGEBOX(hwndParent, szString, szCaption, uType));            
}

BOOL IsMatchingPlatform(void)
{
    BOOL bx86Image = FALSE;
    BOOL bRet = TRUE;
    SYSTEM_INFO si;
    TCHAR szWOW64Path[MAX_PATH];

#ifdef _X86_
    bx86Image = TRUE;
#endif

    if (GetWindowsDirectory(szWOW64Path, ARRAYSIZE(szWOW64Path)) &&
        PathAppend(szWOW64Path, IA64_WOW64FOLDER) &&
        PathFileExists(szWOW64Path) &&
        bx86Image)
        bRet = FALSE;

    return bRet;
}


//
// Program Entry Point
//
INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    int result = 0;
    
    TCHAR lpCommandLine[BUFFER_SIZE+1];
    HMODULE hMod;
    int error,nNumArgs=0,i;
    LONG_PTR lppArgs[3];

    LPWSTR *pszArgv;
    
    if (!IsUserAnAdmin())
    {
        // 
        // "You must have administrator right to run muisetup.\n\n"
        // "If you want to switch your UI language, please use the regional option from control panel."
        //
        LogFormattedMessage(ghInstance, IDS_ADMIN_L, NULL);
        DoMessageBox(NULL, IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);        
        return result;
    }


    //
    // Bail out if image doesn't match the running platform
    // 
    if (!IsMatchingPlatform())
    {
        DoMessageBox(NULL, IDS_WRONG_IMAGE, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
        return result;
    }

    
    ghInstance = hInstance;

    //
    // Let make sure this NT5, and let's initialize all our pfns
    //
    if (!InitializePFNs())
    {
        //
        // Not an NT5 system. The following should be ANSI to work on Win9x.
        //
        CHAR szString[MAX_PATH];
        CHAR szCaption[MAX_PATH];

        LoadStringA(NULL, IDS_ERROR_NT5_ONLY, szString, MAX_PATH-1);
        LoadStringA(NULL, IDS_MAIN_TITLE, szCaption, MAX_PATH-1);

        MessageBoxA(NULL, szString, szCaption, MB_OK | MB_ICONINFORMATION);
        result = 1;
        goto Exit;
    }

    //
    // Check if the program has already been running ?
    //
    if (CheckMultipleInstances())
    {
        result = 1;        
        goto Exit;
    }

    //
    // Initialize any global vars
    //
    InitGlobals();

    //
    // Check if I'm launching from previous version of muisetup
    //
    // I.E. muisetup /$_transfer_$ path_of_MUI_installation_files
    //
    pszArgv = CommandLineToArgvW((LPCWSTR) GetCommandLineW(), &nNumArgs);
    lpCommandLine[0]=TEXT('\0');

    if (pszArgv)
    {
        for (i=1; i<nNumArgs;i++)
        {
            if (!_tcsicmp(pszArgv[i],MUISETUP_FORWARDCALL_TAG) && ((i+1) < nNumArgs) )
            {
                i++;
            }
            else
            {
                _tcscat(lpCommandLine,pszArgv[i]);
                _tcscat(lpCommandLine,TEXT(" "));
            }
        }

        GlobalFree((HGLOBAL) pszArgv);
    }

    InitCommonControls();
    BeginLog();

    //
    // Block the installation of Data Center and Personal.
    //
    if (/*gbIsDataCenter || */CheckProductType(MUI_IS_WIN2K_PERSONAL))
    {
         //
         //  "Windows XP MultiLanguage Version cannot be installed on this platform."
         //
         DoMessageBox(NULL, IDS_WRONG_NTAS, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);    
         result = 1;
         goto Exit;
    }
   
    //
    //  Check to see if a command line has been used
    //
    if(lpCommandLine && NextCommandTag(lpCommandLine))
    {
        lppArgs[0] = (LONG_PTR)lpCommandLine;
        LogFormattedMessage(NULL, IDS_COMMAND_LOG, lppArgs);
        LogMessage(TEXT(""));   //Add a carriage return and newline
        ParseCommandLine(lpCommandLine);
    }
    else
    {
        //
        // MUI version needs to match OS version
        //
        if (!checkversion(TRUE))
        {
            DoMessageBox(NULL, IDS_WRONG_VERSION, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
            result = 1;        
            goto Exit;
        }

        if (WelcomeDialog(0))
        {
            DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), 0, DialogFunc);
        }

        result = 1;
    }

Exit:
    //
    // Cleanup
    //
    Muisetup_Cleanup();

    return result;
}

////////////////////////////////////////////////////////////////////////////////////
//
//   CheckMultipleInstances
//
//   Checks if another instance is running, and if so, it switches to it.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CheckMultipleInstances(void)
{
    ghMutex = CreateMutex(NULL, TRUE, TEXT("Muisetup_Mutex"));

    if (ghMutex && (GetLastError() == ERROR_ALREADY_EXISTS))
    {
        const int idsTitles[] = {IDS_MAIN_TITLE, IDS_INSTALL_TITLE, IDS_PROG_TITLE_2, IDS_PROG_TITLE_3, IDS_UNINSTALL_TITLE};
        HWND hWnd;
        TCHAR szTitle[MAX_PATH];
        int i;

        //
        // Find the running instance by searching possible Window titles
        //
        for (i=0; i<ARRAYSIZE(idsTitles); i++)
        {
            LoadString(NULL, idsTitles[i], szTitle, MAX_PATH-1);

            hWnd = FindWindow(NULL,szTitle);

            if (hWnd && IsWindow(hWnd))
            {
                if (IsIconic(hWnd))
                    ShowWindow(hWnd, SW_RESTORE);

                SetForegroundWindow(hWnd);
                break;
            }
        }
        
        //
        // Always bail out if there is another running instance
        //
        return TRUE;
    }
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//   StartFromTSClient
//
//   Check if I'm launched from a TS client
//
////////////////////////////////////////////////////////////////////////////////////
BOOL StartFromTSClient()
{
    BOOL bResult=FALSE;
    DWORD_PTR SessionId;

    if (gpfnProcessIdToSessionId)
    {                   
      if (gpfnProcessIdToSessionId(GetCurrentProcessId(), &SessionId) && SessionId != 0)
      { 
         bResult = TRUE;
      }                 
    }
    return bResult;

}      
////////////////////////////////////////////////////////////////////////////////////
//
//   InitializePFNs
//
//   Initialize NT5 specific pfns
//
////////////////////////////////////////////////////////////////////////////////////

BOOL InitializePFNs()
{
    HMODULE     hModule;
    SYSTEM_INFO SystemInfo;
    LONG_PTR lppArgs[2];    

    //
    //  Determine platform
    //
    GetSystemInfo( &SystemInfo );
	if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ||
        SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ||
        SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)
    {
#if defined(_AMD64_)
        _tcscpy(g_szPlatformPath, TEXT("amd64\\"));
#elif defined(_IA64_)
        _tcscpy(g_szPlatformPath, TEXT("ia64\\"));
#else
        _tcscpy(g_szPlatformPath, TEXT("i386\\"));
#endif
    }
    else
    {
        // This is NOT supported yet
        return FALSE;
    }

    //
    // Let's bring ntdll!NtSetDefaultUILanguage
    //
    hModule = GetModuleHandle(TEXT("ntdll.dll"));
    if (!hModule)
        return FALSE;
    

    gpfnNtSetDefaultUILanguage =
        (pfnNtSetDefaultUILanguage)GetProcAddress(hModule,
                                                  "NtSetDefaultUILanguage");

    if (!gpfnNtSetDefaultUILanguage)
        return FALSE;
    

    gpfnRtlAdjustPrivilege =
        (pfnRtlAdjustPrivilege)GetProcAddress(hModule,
                                              "RtlAdjustPrivilege");

    if (!gpfnRtlAdjustPrivilege)
        return FALSE;

    //
    // Let's get out from kernel32.dll :
    // - GetUserDefaultUILanguage
    // - GetSystemDefaultUILanguage
    // - EnumLanguageGroupLocalesW
    //
    hModule = GetModuleHandle(TEXT("kernel32.dll"));
    if (!hModule)
        return FALSE;

    gpfnGetUserDefaultUILanguage =
        (pfnGetUserDefaultUILanguage)GetProcAddress(hModule,
                                                    "GetUserDefaultUILanguage");

    if (!gpfnGetUserDefaultUILanguage)
        return FALSE;

    gpfnGetSystemDefaultUILanguage =
        (pfnGetSystemDefaultUILanguage)GetProcAddress(hModule,
                                                      "GetSystemDefaultUILanguage");

    if (!gpfnGetSystemDefaultUILanguage)
        return FALSE;

    gpfnIsValidLanguageGroup =
        (pfnIsValidLanguageGroup)GetProcAddress(hModule,
                                                "IsValidLanguageGroup");

    if (!gpfnIsValidLanguageGroup)
        return FALSE;

    gpfnEnumLanguageGroupLocalesW =
        (pfnEnumLanguageGroupLocalesW)GetProcAddress(hModule,
                                                     "EnumLanguageGroupLocalesW");

    if (!gpfnEnumLanguageGroupLocalesW)
        return FALSE;

    gpfnEnumSystemLanguageGroupsW =
        (pfnEnumSystemLanguageGroupsW)GetProcAddress(hModule,
                                                     "EnumSystemLanguageGroupsW");

    if (!gpfnEnumSystemLanguageGroupsW)
        return FALSE;



    gpfnProcessIdToSessionId =  
       (pfnProcessIdToSessionId)  GetProcAddress(hModule,
                                                     "ProcessIdToSessionId");    

    //
    // Initialize the pfnGetWindowsDirectory
    //
    InitGetWindowsDirectoryPFN(hModule);

    //
    // Try to load userenv.dll
    //
    g_hUserEnvDll = LoadLibrary(TEXT("userenv.dll"));
    if (g_hUserEnvDll)
    {
        gpfnGetDefaultUserProfileDirectoryW =
            (pfnGetDefaultUserProfileDirectoryW)GetProcAddress(g_hUserEnvDll,
                                                               "GetDefaultUserProfileDirectoryW");
    }

    g_hAdvPackDll = LoadLibrary(TEXT("AdvPack.dll"));
    if (g_hAdvPackDll == NULL)
    {
        LogFormattedMessage(ghInstance, IDS_LOAD_ADVPACK_L, NULL);
        return (FALSE);
    }
    gpfnLaunchINFSection = (pfnLaunchINFSection)GetProcAddress(g_hAdvPackDll, "LaunchINFSection");
    if (gpfnLaunchINFSection == NULL)
    {
        lppArgs[0] = (LONG_PTR)TEXT("LaunchINFSection");
        LogFormattedMessage(ghInstance, IDS_LOAD_ADVPACK_API_L, lppArgs);        
        return (FALSE);
    }

    g_hSxSDll = LoadLibrary(TEXT("SxS.dll"));

    if (g_hSxSDll) 
    {
        gpfnSxsInstallW = (PSXS_INSTALL_W)GetProcAddress(g_hSxSDll, SXS_INSTALL_W);
        gpfnSxsUninstallW = (PSXS_UNINSTALL_ASSEMBLYW)GetProcAddress(g_hSxSDll, SXS_UNINSTALL_ASSEMBLYW);
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Find the path of execution file and set path for MUI.INF
//
//
////////////////////////////////////////////////////////////////////////////////////
void SetSourcePath(LPTSTR lpszPreviousMUIPath)
{
    UINT_PTR cb;
    LPTSTR   lpszPath,lpszNext=NULL;
    TCHAR    szHelpPath[MAX_PATH+1],szHelpFile[MAX_PATH+1];

    if (!lpszPreviousMUIPath)
    {
    
        g_szMUISetupFolder[0]=TEXT('\0');
        cb = GetModuleFileName (ghInstance, g_szMuisetupPath, MAX_PATH);

        _tcscpy(g_szMUISetupFolder,g_szMuisetupPath);
        
        //
        // Get folder for MUISetup.
        //
        lpszPath = g_szMUISetupFolder;
        while ( (lpszNext=_tcschr(lpszPath,TEXT('\\')))  )
        {    
            lpszPath = lpszNext+1;
        }
        *lpszPath=TEXT('\0');

    }
    else
    { 
      _tcscpy(g_szMUISetupFolder,lpszPreviousMUIPath);
    }

    _tcscpy(g_szMUIInfoFilePath,g_szMUISetupFolder);
    _tcscat(g_szMUIInfoFilePath,MUIINFFILENAME);

    //
    // Check the location of help file
    //
    _tcscpy(szHelpPath,g_szMUISetupFolder);
    LoadString(NULL, IDS_HELPFILE,szHelpFile,MAX_PATH);
    _tcscat(szHelpPath,szHelpFile);

    if (!FileExists(szHelpPath))
    {
       pfnGetWindowsDir(szHelpPath, MAX_PATH); 
       _tcscat(szHelpPath, TEXT("\\"));
       _tcscat(szHelpPath,HELPDIR);           // HELP\MUI
       _tcscat(szHelpPath, TEXT("\\"));
       _tcscat(szHelpPath,szHelpFile);
       if (FileExists(szHelpPath))
       {
          _tcscpy(g_szMUIHelpFilePath,szHelpPath);
       }
    }
    else
    {
       _tcscpy(g_szMUIHelpFilePath,szHelpPath);
    }

       

    if(g_szMUIInfoFilePath[1] == TEXT(':'))
    {
        _tcsncpy(g_szVolumeRoot,g_szMUIInfoFilePath,3);
        g_szVolumeRoot[3]=TEXT('\0');
        GetVolumeInformation(g_szVolumeRoot, g_szVolumeName, sizeof(g_szVolumeName)/sizeof(TCHAR),
                           &g_dwVolumeSerialNo, 0, 0, 0, 0);
    }

    if (!GetPrivateProfileString( MUI_CDLAYOUT_SECTION,
                            MUI_CDLABEL,
                            TEXT(""),
                            g_szCDLabel,
                            MAX_PATH-1,
                            g_szMUIInfoFilePath))

    {
       LoadString(NULL, IDS_CHANGE_CDROM, g_szCDLabel, MAX_PATH-1);
    }
}
void Set_SourcePath_FromForward(LPCTSTR lpszPath)
{
    TCHAR szMUIPath[MAX_PATH+1];
    int nidx=0;

    while (*lpszPath)
    {
       if (*lpszPath == MUI_FILLER_CHAR)
       {
          szMUIPath[nidx++]=TEXT(' ');
       }
       else
       {
          szMUIPath[nidx++]=*lpszPath;
       }
       lpszPath++;
    }
    szMUIPath[nidx]=TEXT('\0');

    SetSourcePath(szMUIPath);

}

BOOL MUIShouldSwitchToNewVersion(LPTSTR lpszCommandLine)
{
    BOOL   bResult=FALSE;

    TCHAR  szTarget[ MAX_PATH+1 ];

    ULONG  ulHandle,ulBytes;

    pfnGetWindowsDir(szTarget, MAX_PATH); //%windir%  //
    _tcscat(szTarget, TEXT("\\"));
    _tcscat(szTarget, MUIDIR);            // \MUI //
    _tcscat(szTarget, TEXT("\\"));
    _tcscat(szTarget,MUISETUP_EXECUTION_FILENAME);
    
    //
    // If %windir%\mui\muisetup.exe doesn't exist or current muisetup.exe is launched from %windir%\mui then
    //    do nothing
    //
    if (!FileExists(szTarget) || !_tcsicmp(szTarget,g_szMuisetupPath))
    {
       return bResult;
    }
    //
    // If %windir%mui\muisetup.exe is not a execuatble then do nothing
    //
    ulBytes = GetFileVersionInfoSize( szTarget, &ulHandle );

    if ( ulBytes == 0 )
       return bResult;

    //
    // Compare the version stamp
    //
    // if version of g_szMuisetupPath (cuurent process) < %windir%\mui\muisetup
    // then switch control to it
    //
    if (CompareMuisetupVersion(g_szMuisetupPath,szTarget))
    {
       bResult = TRUE;
       MUI_TransferControlToNewVersion(szTarget,lpszCommandLine);
    }                   
    return bResult;     
}

////////////////////////////////////////////////////////////////////////////////////
//
//    CheckVolumeChange
//
//    Make sure that MUI CD-ROM is put in the CD drive.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CheckVolumeChange()
{
   BOOL bResult = FALSE;

   TCHAR szVolumeName[MAX_PATH],szCaption[MAX_PATH+1],szMsg[MAX_PATH+1],szMsg00[MAX_PATH+1],szMsg01[MAX_PATH+1];
   DWORD dwVolumeSerialNo;
   BOOL  bInit=TRUE;
   LONG_PTR lppArgs[3];

   if( *g_szVolumeName &&
       GetVolumeInformation(g_szVolumeRoot, szVolumeName, sizeof(szVolumeName)/sizeof(TCHAR),
                            &dwVolumeSerialNo, 0, 0, 0, 0) )
   {             
       while( lstrcmp(szVolumeName,g_szVolumeName) || (dwVolumeSerialNo != g_dwVolumeSerialNo) )
       {

           if (bInit)
           {
              szCaption[0]=szMsg00[0]=szMsg01[0]=TEXT('\0');
              LoadString(NULL, IDS_MAIN_TITLE, szCaption, MAX_PATH);

              lppArgs[0] = (LONG_PTR)g_szCDLabel;
              lppArgs[1] = (LONG_PTR)g_cdnumber;
              FormatStringFromResource(szMsg, sizeof(szMsg)/sizeof(TCHAR), ghInstance, IDS_CHANGE_CDROM2, lppArgs);
              
              bInit=FALSE;
           }
           if (MESSAGEBOX(NULL, szMsg,szCaption, MB_YESNO | MB_ICONQUESTION) == IDNO)
           {
              return TRUE;
           }
           GetVolumeInformation(g_szVolumeRoot, szVolumeName, sizeof(szVolumeName)/sizeof(TCHAR),
                            &dwVolumeSerialNo, 0, 0, 0, 0);

       }
   }
   return bResult;

}



////////////////////////////////////////////////////////////////////////////////////
//
//    InitGlobals
//
//    Initialize global variables
//
////////////////////////////////////////////////////////////////////////////////////
void InitGlobals(void)
{
    // User UI Language Id
    gUserUILangId = gpfnGetUserDefaultUILanguage();
    gSystemUILangId = gpfnGetSystemDefaultUILanguage();

    // System Windows directory
    szWindowsDir[0] = TEXT('\0');
    pfnGetWindowsDir(szWindowsDir, MAX_PATH);

    // Does this have admin privliges ?
    gbIsWorkStation=CheckProductType(MUI_IS_WIN2K_PRO);
    gbIsServer= CheckProductType(MUI_IS_WIN2K_SERVER);
    gbIsAdvanceServer= (CheckProductType(MUI_IS_WIN2K_ADV_SERVER_OR_DATACENTER) || CheckProductType(MUI_IS_WIN2K_ENTERPRISE));
    gbIsDataCenter=(CheckProductType(MUI_IS_WIN2K_DATACENTER) || CheckProductType(MUI_IS_WIN2K_DC_DATACENTER));
    gbIsDomainController=CheckProductType(MUI_IS_WIN2K_DC);
    if (gbIsDomainController)
    {
       if ( (!gbIsWorkStation) && (!gbIsServer) && (!gbIsAdvanceServer))
       {
          gbIsServer=TRUE;
       }  
    }
    // Fill in system supported language groups
    gpfnEnumSystemLanguageGroupsW(EnumLanguageGroupsProc, LGRPID_SUPPORTED, 0);
    pfnGetWindowsDir(g_szWinDir, sizeof(g_szWinDir));

    g_AddLanguages[0]=TEXT('\0');
    g_szVolumeName[0]=TEXT('\0');
    g_szVolumeRoot[0]=TEXT('\0');
    g_szMUIHelpFilePath[0]=TEXT('\0');
    g_szCDLabel[0]=TEXT('\0');
    g_dwVolumeSerialNo = 0;
    gNumLanguages=0;
    gNumLanguages_Install=0;
    gNumLanguages_Uninstall=0;
    g_InstallCancelled = FALSE;
    g_bRemoveDefaultUI=FALSE;
    g_cdnumber=0;
    g_pFileRenameTable=NULL;
    g_nFileRename=0;

    g_pNotFallBackTable=NULL;
    g_nNotFallBack=0;
    // Detect source path for installation
    SetSourcePath(NULL);

    // Initialize the context for diamond FDI
    Muisetup_InitDiamond();

    // Get all installed UI languages
    MUIGetAllInstalledUILanguages();
}

BOOL CALLBACK EnumLanguageGroupsProc(
  LGRPID LanguageGroup,             // language group identifier
  LPTSTR lpLanguageGroupString,     // pointer to language group identifier string
  LPTSTR lpLanguageGroupNameString, // pointer to language group name string
  DWORD dwFlags,                    // flags
  LONG_PTR lParam)                  // user-supplied parameter
{
    gLanguageGroups[gNumLanguageGroups] = LanguageGroup;
    gNumLanguageGroups++;

    return TRUE;
}



////////////////////////////////////////////////////////////////////////////////////
//
//    Muisetup_Cleanup
//
//    Muisetup cleanup code.
//
////////////////////////////////////////////////////////////////////////////////////

void Muisetup_Cleanup()
{
    //
    // Free userenv.dll, if needed
    //
    if (g_hUserEnvDll)
    {
        FreeLibrary(g_hUserEnvDll);
    }

    if (g_hAdvPackDll)
    {
        FreeLibrary(g_hAdvPackDll);
    }

    if (g_hSxSDll)
    {
        FreeLibrary(g_hSxSDll);
    }

    if (ghMutex)
    {
        CloseHandle(ghMutex);
    }
    
    // Free/release diamond DLL
    Muisetup_FreeDiamond();


    return;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  OpenMuiKey
//
//  Opens the Registry Key where installed languages are stored
//
////////////////////////////////////////////////////////////////////////////////////

HKEY OpenMuiKey(REGSAM samDesired)
{
    DWORD dwDisposition;    
    HKEY hKey;
    TCHAR lpSubKey[BUFFER_SIZE];    

    _tcscpy(lpSubKey, REG_MUI_PATH);

    if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                      lpSubKey,
                      0,
                      NULL,
                      REG_OPTION_NON_VOLATILE,
                      samDesired,
                      NULL,
                      &hKey,
                      &dwDisposition) != ERROR_SUCCESS)
    {
        hKey = NULL;
    }

    return hKey;
}

void DialogCleanUp(HWND hwndDlg)
{
    HWND hList = GetDlgItem(hwndDlg, IDC_LIST1);
    int iCount = ListView_GetItemCount(hList);
    LVITEM lvItem;
    PMUILANGINFO pMuiLangInfo;

    while (iCount--)
    {
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iCount;
        lvItem.iSubItem = 0;
        lvItem.state = 0;
        lvItem.stateMask = 0;
        lvItem.pszText = 0;
        lvItem.cchTextMax = 0;
        lvItem.iImage = 0;
        lvItem.lParam = 0;

        ListView_GetItem(hList, &lvItem);
        pMuiLangInfo = (PMUILANGINFO)lvItem.lParam;

        if (pMuiLangInfo)
        {
            if (pMuiLangInfo->lpszLcid)
                LocalFree(pMuiLangInfo->lpszLcid);

            LocalFree(pMuiLangInfo);
        }
    }
}




////////////////////////////////////////////////////////////////////////////////////
//
//  DialogFunc
//
//  Callback function for main dialog (102)
//
////////////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DialogFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{   

    switch(uMsg)
    {
    case WM_INITDIALOG:
        SendMessage(hwndDlg, WM_SETICON , (WPARAM)ICON_BIG, (LPARAM)LoadIcon(ghInstance,MAKEINTRESOURCE(MUI_ICON)));
        SendMessage(hwndDlg, WM_SETICON , (WPARAM)ICON_SMALL, (LPARAM)LoadIcon(ghInstance,MAKEINTRESOURCE(MUI_ICON)));
        
        InitializeInstallDialog(hwndDlg, uMsg, wParam, lParam);
        return TRUE;

    case WM_HELP:
    {
        WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                 g_szMUIHelpFilePath,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPTSTR)aMuisetupHelpIds );
        break;
    }

    case WM_CONTEXTMENU:      // right mouse click
    {
        WinHelp( (HWND)wParam,
                 MUISETUP_HELP_FILENAME,
                 HELP_CONTEXTMENU,
                 (DWORD_PTR)(LPTSTR)aMuisetupHelpIds );
        break;
    }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            EnableWindow(hwndDlg, FALSE);            
            if (StartGUISetup(hwndDlg))
            {
                EndDialog(hwndDlg, 0);
            }
            else
            {
                EnableWindow(hwndDlg, TRUE);  
                SetFocus(hwndDlg);
            }
            return TRUE;

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            return TRUE;
                            
        case IDC_DEF_UI_LANG_COMBO:
            switch(HIWORD(wParam))
            {                       
            case CBN_SELCHANGE:
                UpdateCombo(hwndDlg);
                return TRUE;
            default:
                break;
            }
            break;
        case IDC_CHECK_LOCALE:
            if (BST_CHECKED == IsDlgButtonChecked( hwndDlg, IDC_CHECK_LOCALE))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_CHECK_UIFONT), TRUE);
            }
            else
            {
                CheckDlgButton(hwndDlg, IDC_CHECK_UIFONT, BST_UNCHECKED);
                EnableWindow(GetDlgItem(hwndDlg, IDC_CHECK_UIFONT), FALSE);                
            }
            break;
        }
            
        //
        //    End of WM_COMMAND case
        //
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
            case(NM_CUSTOMDRAW):
                ListViewCustomDraw(hwndDlg, (LPNMLVCUSTOMDRAW)lParam);
                return TRUE;
                break;

            case (LVN_ITEMCHANGING):
                return ListViewChanging( hwndDlg,
                                         IDC_LIST1,
                                         (NM_LISTVIEW *)lParam);
                break;

            case (LVN_ITEMCHANGED) :
                ListViewChanged( hwndDlg,
                                 IDC_LIST1,
                                 (NM_LISTVIEW *)lParam );
                break;

            default:
                return FALSE;

            }
            break;

        case WM_CLOSE:
            EndDialog(hwndDlg, 0);
            return TRUE;
            
        case WM_DESTROY:
            DialogCleanUp(hwndDlg);
            return TRUE;

        default:
            return FALSE;
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  ListViewChanging
//
//  Processing for a LVN_ITEMCHANGING message
//
////////////////////////////////////////////////////////////////////////////////////


BOOL ListViewChanging(HWND hDlg, int iID, NM_LISTVIEW *pLV)
{
    HWND         hwndLV = GetDlgItem(hDlg, iID);
    PMUILANGINFO pMuiLangInfo;
    
    //
    //  Make sure it's a state change message
    //
    if ((!(pLV->uChanged & LVIF_STATE)) || ((pLV->uNewState & 0x3000) == 0))
        return FALSE;

    //
    //  Don't let the System Default be unchecked
    //
    GetMuiLangInfoFromListView(hwndLV, pLV->iItem, &pMuiLangInfo);
    if (MAKELCID(gSystemUILangId, SORT_DEFAULT) == pMuiLangInfo->lcid)
        return TRUE;

    return FALSE;
}



////////////////////////////////////////////////////////////////////////////////////
//
//  ListViewChanged
//
//  Processing for a LVN_ITEMCHANGED message
//
////////////////////////////////////////////////////////////////////////////////////

BOOL ListViewChanged(HWND hDlg, int iID, NM_LISTVIEW *pLV)
{
    HWND         hwndLV = GetDlgItem(hDlg, iID);
    PMUILANGINFO pMuiLangInfo;
    int          iCount;
    BOOL         bChecked;

    //
    //  Make sure it's a state change message.
    //
    
    if ((!(pLV->uChanged & LVIF_STATE)) ||
        ((pLV->uNewState & 0x3000) == 0))
    {
        return (FALSE);
    }

    //
    //  Get the state of the check box for the currently selected item.
    //

    bChecked = ListView_GetCheckState(hwndLV, pLV->iItem) ? TRUE : FALSE;

    //
    //  Don't let the System Default or the current user UI language be unchecked
    //
    GetMuiLangInfoFromListView(hwndLV, pLV->iItem, &pMuiLangInfo);
    if (MAKELCID(gSystemUILangId, SORT_DEFAULT) == pMuiLangInfo->lcid)
        
    {
        //
        //  Set Default check state
        //
        
        if (bChecked == FALSE)
        {
            ListView_SetCheckState( hwndLV,
                                    pLV->iItem,
                                    TRUE );
        }

        return FALSE;
    }

    //
    //  Deselect all items.
    //
    
    iCount = ListView_GetItemCount(hwndLV);
    while (iCount > 0)
    {
        iCount--;
        ListView_SetItemState( hwndLV,
                               iCount,
                               0,
                               LVIS_FOCUSED | LVIS_SELECTED );
    }

    //
    //  Make sure this item is selected.
    //
    ListView_SetItemState( hwndLV,
                           pLV->iItem,
                           LVIS_FOCUSED | LVIS_SELECTED,
                           LVIS_FOCUSED | LVIS_SELECTED );

   //
   // Update the combo box
   //
   PostMessage( hDlg,
                WM_COMMAND,
                MAKEWPARAM(IDC_DEF_UI_LANG_COMBO, CBN_SELCHANGE),
                0L);


   //
   //  Return success.
   //
    
    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////////////
//
//  ListViewCustomDraw
//
//  Processing for list view WM_CUSTOMDRAW notification.
//
////////////////////////////////////////////////////////////////////////////////////

void ListViewCustomDraw(HWND hDlg, LPNMLVCUSTOMDRAW pDraw)
{
    HWND hwndLV = GetDlgItem(hDlg, IDC_LIST1);
    PMUILANGINFO pMuiLangInfo;

    //
    //  Tell the list view to notify me of item draws.
    //
    if (pDraw->nmcd.dwDrawStage == CDDS_PREPAINT)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW);
        return;
    }

    //  
    //  Handle the Item Prepaint.
    //
    if (pDraw->nmcd.dwDrawStage & CDDS_ITEMPREPAINT)
    {
        //
    // Check to see if the item being drawn is the system default or
        // the current active ui language
        //
        GetMuiLangInfoFromListView(hwndLV, (int)pDraw->nmcd.dwItemSpec, &pMuiLangInfo);

        if (MAKELCID(gSystemUILangId, SORT_DEFAULT) == pMuiLangInfo->lcid)
            
        {
            pDraw->clrText = (GetSysColor(COLOR_GRAYTEXT));
        }
    }   

    //
    //  Do the default action.
    //
    
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
}



////////////////////////////////////////////////////////////////////////////////////
//
//  StartGUISetup
//
//  Creates dialog with progress bar for installation
//
////////////////////////////////////////////////////////////////////////////////////

BOOL StartGUISetup(HWND hwndDlg)
{
    HWND hProgDlg=NULL;
    LONG_PTR lppArgs[3];
    ULONG ulParam[2];
    TCHAR lpMessage[BUFFER_SIZE];
    TCHAR szBuf[BUFFER_SIZE];
    BOOL  bLGInstalled,bContinue;
    INT64 ulSizeNeed,ulSizeAvailable;
    BOOL success;

    HWND hList;
    HWND hCombo;
    int iIndex;

    TCHAR lpAddLanguages[BUFFER_SIZE];
    TCHAR lpRemoveLanguages[BUFFER_SIZE];
    TCHAR lpDefaultUILang[BUFFER_SIZE];
    TCHAR szPostParameter[BUFFER_SIZE];
    
    int installLangCount;   // The number of MUI languages to be installed
    int uninstallLangCount; // The number of MUI langauges to be uninstalled.
    LANGID langID;
    
    INSTALL_LANG_GROUP installLangGroup;

    
    //
    // (0) Check available disk space
    //
    if(!IsSpaceEnough(hwndDlg,&ulSizeNeed,&ulSizeAvailable))
    {
     
       ulParam[0] = (ULONG) (ulSizeNeed/1024);
       ulParam[1] = (ULONG) (ulSizeAvailable/1024);

       LoadString(ghInstance, IDS_DISKSPACE_NOTENOUGH, lpMessage, ARRAYSIZE(lpMessage)-1);
       LoadString(ghInstance, IDS_ERROR_DISKSPACE, szBuf, ARRAYSIZE(szBuf)-1);
       FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                lpMessage,
                                0,
                                0,
                                lpMessage,
                                ARRAYSIZE(lpMessage)-1,
                                (va_list *)ulParam);
       LogMessage(lpMessage);
       MESSAGEBOX(NULL, lpMessage, szBuf, MB_OK | MB_DEFBUTTON1 | MB_ICONWARNING);
       //
       // Let User has another chance to reselect
       //
       return FALSE;
       
    }

    
    installLangGroup.bFontLinkRegistryTouched = FALSE;
    installLangGroup.NotDeleted               = 0;


    //
    // (1) Install Language Group First
    //
    ConvertMUILangToLangGroup(hwndDlg, &installLangGroup);
        
    hList=GetDlgItem(hwndDlg, IDC_LIST1);  
    hCombo=GetDlgItem(hwndDlg, IDC_DEF_UI_LANG_COMBO);
    
    installLangCount = EnumSelectedLanguages(hList, lpAddLanguages);
    memmove(g_AddLanguages,lpAddLanguages,ARRAYSIZE(lpAddLanguages));
    uninstallLangCount = EnumUnselectedLanguages(hList, lpRemoveLanguages);

    //
    // Let's read the user's UI language selection,
    // and then call the kernel to update the registry.
    //
    hList = GetDlgItem(hwndDlg, IDC_LIST1);
    hCombo = GetDlgItem(hwndDlg, IDC_DEF_UI_LANG_COMBO);

    iIndex = (int)SendMessage(hCombo, CB_GETCURSEL, 0, 0);
    if (iIndex == CB_ERR)
    {
        return FALSE;
    }

    langID = LANGIDFROMLCID((LCID) SendMessage(hCombo, CB_GETITEMDATA, iIndex, 0L));
    wsprintf(lpDefaultUILang, TEXT("%X"), langID);

    success = DoSetup(
        hwndDlg,
        uninstallLangCount, lpRemoveLanguages, 
        installLangGroup, 
        installLangCount, lpAddLanguages, 
        lpDefaultUILang, 
        TRUE, TRUE);

    return (success);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  ProgressDialogFunc
//
//  Callback function for progresss dialog
//
////////////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK ProgressDialogFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            return TRUE;
                
        }
        break;

     case WM_CLOSE:
         EndDialog(hwndDlg, 0);
         return TRUE;
            
     case WM_DESTROY:
         EndDialog(hwndDlg, 0);
         return TRUE;

     default:
         return FALSE;

    }

    return TRUE;
}



////////////////////////////////////////////////////////////////////////////////////
//
//  InitializeInstallDialog
//
//  Sets contents of list view and combo box in installation dialog
//
////////////////////////////////////////////////////////////////////////////////////

BOOL InitializeInstallDialog(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bInsertSystemDefault = FALSE;
    HANDLE hFile;
    HWND hList, hCombo;
    PTSTR lpLanguages;
    TCHAR tchBuffer[BUFFER_SIZE];
    TCHAR lpDefaultSystemLanguage[BUFFER_SIZE],lpUILanguage[BUFFER_SIZE];
    TCHAR lpMessage[BUFFER_SIZE];
    int iIndex;
    int iChkIndex,iCnt,iMUIDirectories=0;    
    lpLanguages = tchBuffer;

   
    SetWindowTitleFromResource(hwndDlg, IDS_MAIN_TITLE);

    hList = GetDlgItem(hwndDlg, IDC_LIST1);
    hCombo=GetDlgItem(hwndDlg, IDC_DEF_UI_LANG_COMBO);

    InitializeListView(hList);

    //
    //  Insert the default system language in the list view
    //  
    _stprintf(lpDefaultSystemLanguage, TEXT("%04x"), gSystemUILangId);
    iIndex=InsertLanguageInListView(hList, lpDefaultSystemLanguage, TRUE);

    //
    //  Insert the languages in MUI.INF in the list view
    //
    if ( ( (iMUIDirectories =EnumLanguages(lpLanguages)) == 0)  && (g_UILanguageGroup.iCount == 0 ) )
    {
        //
        //  No languages found in MUI.INF
        //
        LoadString(ghInstance, IDS_NO_LANG_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return FALSE;
    }
    while (*lpLanguages != TEXT('\0'))
    {
       if (CheckLanguageIsQualified(lpLanguages))
       {
            InsertLanguageInListView(hList, lpLanguages, FALSE);
       }
       lpLanguages = _tcschr(lpLanguages, '\0');
       lpLanguages++;       
    }   
    
    //
    // We should also check all installed UI languages
    //
    for (iCnt=0; iCnt<g_UILanguageGroup.iCount; iCnt++)
    {
        if (!GetLcidItemIndexFromListView(hList, g_UILanguageGroup.lcid[iCnt], &iChkIndex))
        {  
            _stprintf(lpUILanguage, TEXT("%04x"), g_UILanguageGroup.lcid[iCnt]);
            if (CheckLanguageIsQualified(lpUILanguage))
            {
                InsertLanguageInListView(hList, lpUILanguage, FALSE);
            }
        }

    }
    //
    // Let's detect which language groups are installed
    //
    DetectLanguageGroups(hwndDlg);

    SelectInstalledLanguages(hList);
    SetDefault(hCombo);


    //
    //  Deselect all items.
    //
    iIndex = ListView_GetItemCount(hList);
    while (iIndex > 0)
    {
        iIndex--;
        ListView_SetItemState( hList,
                               iIndex,
                               0,
                               LVIS_FOCUSED | LVIS_SELECTED );
    }

    //
    //  Select the first one in the list.
    //
    ListView_SetItemState( hList,
                           0,
                           LVIS_FOCUSED | LVIS_SELECTED,
                           LVIS_FOCUSED | LVIS_SELECTED );

    //
    // Match system locale with the default UI language
    //
    if (CheckMUIRegSetting(MUI_MATCH_LOCALE))
    {
        CheckDlgButton(hwndDlg, IDC_CHECK_LOCALE, BST_CHECKED);
        //
        // Match UI font with the default UI language
        // 
        if (g_bMatchUIFont = CheckMUIRegSetting(MUI_MATCH_UIFONT))
        {
            CheckDlgButton(hwndDlg, IDC_CHECK_UIFONT, BST_CHECKED);
        }
    }
    else
    {
        SetMUIRegSetting(MUI_MATCH_UIFONT, FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_CHECK_UIFONT), FALSE);
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//    CheckForUsingCountryName
//
//    Fetch MUIINF file if the selected UI lang needs to be displayed as a language
//    name or a country name.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CheckForUsingCountryName(PMUILANGINFO pMuiLangInfo)
{
    TCHAR szSource[MAX_PATH];


    szSource[0] = TEXT('\0');

    //
    // Try check if there is a value for it under [UseCountryName]
    //
    GetPrivateProfileString( MUI_COUNTRYNAME_SECTION,
                             pMuiLangInfo->lpszLcid,
                             TEXT(""),
                             szSource,
                             MAX_PATH,
                             g_szMUIInfoFilePath);

    if (szSource[0] == TEXT('1'))
    {
        return (TRUE);
    }

    return (FALSE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//    GetDisplayName
//
//    Fetch MUIINF file if the selected UI lang needs to be displayed using the
//    name specified in [LanguageDisplayName] section of mui.inf.
//    Otherwise, get the display name according to the values in [UseCountryName].
//    If the value for the specified LCID is 1, use the country name. Otherwise,
//    use the locale name.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL GetDisplayName(PMUILANGINFO pMuiLangInfo)
{
    //
    // Try check if there is a customized display name for the specified LCID under [LanguageDisplayName].
    //

    pMuiLangInfo->szDisplayName[0] = L'\0';

    if (pMuiLangInfo->lpszLcid)
    {
        GetPrivateProfileString( MUI_DISPLAYNAME_SECTION,
                                 pMuiLangInfo->lpszLcid,
                                 TEXT(""),
                                 pMuiLangInfo->szDisplayName,
                                 MAX_PATH,
                                 g_szMUIInfoFilePath);
    }

    if (pMuiLangInfo->szDisplayName[0] == L'\0')
    {
        //
        // There is no entry in [LanguageDisplayName].  Use the country name or locale name.
        //
        Muisetup_GetLocaleLanguageInfo( pMuiLangInfo->lcid,
                                        pMuiLangInfo->szDisplayName,
                                        ARRAYSIZE(pMuiLangInfo->szDisplayName)-1,
                                        CheckForUsingCountryName(pMuiLangInfo));

    }
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
// GetLanguageGroupDisplayName
// Get language group display name for MUI install/uninstall dialog
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetLanguageGroupDisplayName(LANGID LangId, LPTSTR lpBuffer, int nSize)
{
    BOOL bRet = FALSE;
    MUILANGINFO MuiLangInfo = {0};

    MuiLangInfo.lcid = MAKELCID(LangId, SORT_DEFAULT);
    MuiLangInfo.lgrpid = GetLanguageGroup(MuiLangInfo.lcid);

    if (GetDisplayName(&MuiLangInfo) &&
        nSize >= lstrlen(MuiLangInfo.szDisplayName))
    {
        lstrcpy(lpBuffer, MuiLangInfo.szDisplayName);
        bRet = TRUE;
    }

    return bRet;
}



////////////////////////////////////////////////////////////////////////////////////
//
//    Get UI, IE and LPK files size for the lcid
//
////////////////////////////////////////////////////////////////////////////////////

BOOL GetUIFileSize(PMUILANGINFO pMuiLangInfo)
{
    TCHAR szSize[MAX_PATH];
    int   nCD;

    pMuiLangInfo->ulUISize = 0;
    pMuiLangInfo->ulLPKSize = 0;
    
#if defined(_IA64_)
    BOOL bIA64 = TRUE;
#else
    BOOL bIA64 = FALSE;
#endif
    

    szSize[0] = TEXT('\0');
    //
    // Try to get UI files size under [FileSize_UI]
    //
    if (GetPrivateProfileString( bIA64? MUI_UIFILESIZE_SECTION_IA64 : MUI_UIFILESIZE_SECTION,
                             pMuiLangInfo->lpszLcid,
                             TEXT(""),
                             szSize,
                             MAX_PATH,
                             g_szMUIInfoFilePath))

    {  
       pMuiLangInfo->ulUISize =_wtoi64(szSize);
    }
    szSize[0] = TEXT('\0');
    //
    // Try to get LPK files size under [FileSize_LPK]
    //
    if (GetPrivateProfileString( bIA64? MUI_LPKFILESIZE_SECTION_IA64 : MUI_LPKFILESIZE_SECTION,
                             pMuiLangInfo->lpszLcid,
                             TEXT(""),
                             szSize,
                             MAX_PATH,
                             g_szMUIInfoFilePath))

    {  
       pMuiLangInfo->ulLPKSize =_wtoi64(szSize);

    }
    //
    // Try to get CD # under [CD_LAYOUT]
    //
    nCD=GetPrivateProfileInt(bIA64? MUI_CDLAYOUT_SECTION_IA64 : MUI_CDLAYOUT_SECTION,
                             pMuiLangInfo->lpszLcid,
                             0,
                             g_szMUIInfoFilePath);
    if (nCD)
    {    

       pMuiLangInfo->cd_number = nCD;

       if (g_cdnumber == 0)
       {
          g_cdnumber = pMuiLangInfo->cd_number;
       }
    }
    else
    {
       pMuiLangInfo->cd_number = DEFAULT_CD_NUMBER;
    }

    return TRUE;
}

BOOL GetUIFileSize_commandline(LPTSTR lpszLcid, INT64 *ulUISize,INT64 *ulLPKSize)
{
    TCHAR szSize[MAX_PATH];
    int   nCD;


    *ulUISize = 0;
    *ulLPKSize = 0;
    
#if defined(_IA64_)
    BOOL bIA64 = TRUE;
#else
    BOOL bIA64 = FALSE;
#endif


    szSize[0] = TEXT('\0');
    //
    // Try to get UI files size under [FileSize_UI]
    //
    if (GetPrivateProfileString( bIA64? MUI_UIFILESIZE_SECTION_IA64 : MUI_UIFILESIZE_SECTION,
                             lpszLcid,
                             TEXT(""),
                             szSize,
                             MAX_PATH,
                             g_szMUIInfoFilePath))

    {  
       *ulUISize =_wtoi64(szSize); 

    }
    
    szSize[0] = TEXT('\0');
    //
    // Try to get LPK files size under [FileSize_LPK]
    //
    if (GetPrivateProfileString( bIA64? MUI_LPKFILESIZE_SECTION_IA64 : MUI_LPKFILESIZE_SECTION,
                             lpszLcid,
                             TEXT(""),
                             szSize,
                             MAX_PATH,
                             g_szMUIInfoFilePath))

    {  
       *ulLPKSize =_wtoi64(szSize);

    }

    // Try to get CD # under [CD_LAYOUT]
    //
    if (g_cdnumber == 0)
    {

       g_cdnumber=GetPrivateProfileInt( bIA64? MUI_CDLAYOUT_SECTION_IA64 : MUI_CDLAYOUT_SECTION,
                                lpszLcid,
                                0,
                                g_szMUIInfoFilePath);
    }

    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    InitializeListView
//
//    Gets the list view ready for inserting items
//
////////////////////////////////////////////////////////////////////////////////////

BOOL InitializeListView(HWND hList)
{
    DWORD dwExStyle;
    LV_COLUMN Column;
    RECT Rect;
    
    GetClientRect(hList, &Rect);
    Column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    Column.fmt = LVCFMT_LEFT;
    Column.cx = Rect.right - GetSystemMetrics(SM_CYHSCROLL);
    Column.pszText = NULL;
    Column.cchTextMax = 0;
    Column.iSubItem = 0;
    ListView_InsertColumn(hList, 0, &Column);

    dwExStyle = ListView_GetExtendedListViewStyle(hList);
    ListView_SetExtendedListViewStyle(hList, dwExStyle | LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//
//    Check if specified language can install on the target machine.
//    I.E. Arabic, Turkish, Greek and Hebrew MUI can only install on NT Workstation;
//         They are not allowed on NT Server
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CheckLanguageIsQualified(LPTSTR lpLanguage)
{
#ifdef XCHECK_LANGUAGE_FOR_PLATFORM
    BOOL   bResult = FALSE;    
    
    LANGID LgLang;
    
    LgLang = (LANGID)_tcstol(lpLanguage, NULL, 16);
    LgLang = PRIMARYLANGID(LgLang);
    if(gbIsAdvanceServer)
    {
      if (LgLang == LANG_GERMAN     || LgLang == LANG_FRENCH  || LgLang == LANG_SPANISH   ||
          LgLang == LANG_JAPANESE   || LgLang == LANG_KOREAN  || LgLang == LANG_CHINESE)
      {
          bResult = TRUE;
      }   
    }
    else if(gbIsServer)
    {

      if (LgLang == LANG_GERMAN     || LgLang == LANG_FRENCH  || LgLang == LANG_SPANISH   ||
          LgLang == LANG_JAPANESE   || LgLang == LANG_KOREAN  || LgLang == LANG_CHINESE   ||
          LgLang == LANG_SWEDISH    || LgLang == LANG_ITALIAN || LgLang == LANG_DUTCH     ||
          LgLang == LANG_PORTUGUESE || LgLang == LANG_CZECH   || LgLang == LANG_HUNGARIAN ||
          LgLang == LANG_POLISH     || LgLang == LANG_RUSSIAN || LgLang == LANG_TURKISH)
      {
          bResult = TRUE;
      }
    }    
    else if(gbIsWorkStation)
    {
          bResult = TRUE;
    }                    
    return bResult;                           
#else
    return TRUE;
#endif
}

////////////////////////////////////////////////////////////////////////////////////
//
//    InsertLanguageInListView
//
//    Returns the index of the item in the list view after inserting it.
//
////////////////////////////////////////////////////////////////////////////////////

int InsertLanguageInListView(HWND hList, LPTSTR lpLanguage, BOOL bCheckState)
{
    LANGID LgLang;
    LV_ITEM lvItem;
    PMUILANGINFO pMuiLangInfo;
    int iIndex;

    lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE | LVIF_IMAGE;
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = LVIS_STATEIMAGEMASK;
    lvItem.cchTextMax = 0;
    lvItem.iImage = 0;

    //
    // Allocate enough space to hold pszLcid and MUILANGINFO
    //
    pMuiLangInfo = (PMUILANGINFO) LocalAlloc(LPTR, sizeof(MUILANGINFO));
    if (pMuiLangInfo == NULL)
    {
        ExitFromOutOfMemory();
    }
    pMuiLangInfo->lpszLcid = (LPTSTR) LocalAlloc(LMEM_FIXED, (_tcslen(lpLanguage) + 1) * sizeof(TCHAR));
    if (pMuiLangInfo->lpszLcid == NULL)
    {
        ExitFromOutOfMemory();
    }

    //
    // Init pszLcid
    //
    lvItem.lParam = (LPARAM)pMuiLangInfo;
    _tcscpy((LPTSTR)pMuiLangInfo->lpszLcid, lpLanguage);

    //
    //  Init lcid
    //
    LgLang = (LANGID)_tcstol(lpLanguage, NULL, 16);
    pMuiLangInfo->lcid = MAKELCID(LgLang, SORT_DEFAULT);

    if (pMuiLangInfo->szDisplayName[0] == L'\0')
    {
        GetDisplayName(pMuiLangInfo);
    }        
    
    lvItem.pszText = pMuiLangInfo->szDisplayName;
    
    GetUIFileSize(pMuiLangInfo);
    iIndex = ListView_InsertItem(hList, &lvItem);

    if (iIndex >= 0)
    {
        ListView_SetCheckState(hList, iIndex, bCheckState);
    }

    return iIndex;
}


////////////////////////////////////////////////////////////////////////////////////
//
//    GetMuiLangInfoFromListView
//
//    Get the MuiLangInfo of the corresponding ListView Item
//
////////////////////////////////////////////////////////////////////////////////////

BOOL GetMuiLangInfoFromListView(HWND hList, int i, PMUILANGINFO *ppMuiLangInfo)
{
    LVITEM lvItem;

    //
    // Check if Language Group is installed
    //
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = i;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.pszText = 0;
    lvItem.cchTextMax = 0;
    lvItem.iImage = 0;
    lvItem.lParam = 0;

    ListView_GetItem(hList, &lvItem);

    *ppMuiLangInfo = (PMUILANGINFO)lvItem.lParam;

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//    Muisetup_GetLocaleLanguageInfo
//
//    Read the locale info of the language or country name.
//
////////////////////////////////////////////////////////////////////////////////////

int Muisetup_GetLocaleLanguageInfo(LCID lcid, PTSTR pBuf, int iLen, BOOL fUseCountryName)
{
    TCHAR tchBuf[ MAX_PATH ] ;
    int iRet;

    //
    // If this is either 0x0404 or 0x0804, then mark them specially
    //
    if (0x0404 == lcid)
    {
        iRet = LoadString(ghInstance, IDS_MUI_CHT, pBuf, iLen);
    }
    else if (0x0804 == lcid)
    {
        iRet = LoadString(ghInstance, IDS_MUI_CHS, pBuf, iLen);
    }
    else
    {
        iRet = GetLocaleInfo( lcid,
                              LOCALE_SENGLANGUAGE,
                              pBuf,
                              iLen);

        if (fUseCountryName)
        {
            iRet = GetLocaleInfo( lcid,
                                  LOCALE_SENGCOUNTRY,
                                  tchBuf,
                                  (sizeof(tchBuf)/sizeof(TCHAR)));

            if (iRet)
            {
                _tcscat(pBuf, TEXT(" ("));
                _tcscat(pBuf, tchBuf);
                _tcscat(pBuf, TEXT(")"));
            }
        }

    }

    return iRet;
}

////////////////////////////////////////////////////////////////////////////////////
//
//    GetLcidFromComboBox
//
//    Retreives the index of the combo box item that corresponds to this UI Language
//
////////////////////////////////////////////////////////////////////////////////////

BOOL GetLcidFromComboBox(HWND hCombo, LCID lcid, int *piIndex)
{
    LCID ItemLcid;
    int i;
    int iCount = (int)SendMessage(hCombo, CB_GETCOUNT, 0L, 0L);


    if (CB_ERR != iCount)
    {
        i = 0;
        while (i < iCount)
        {
            ItemLcid = (LCID)SendMessage(hCombo, CB_GETITEMDATA, (WPARAM)i, (LPARAM)0);
            if ((CB_ERR != ItemLcid) && (ItemLcid == lcid))
            {
                *piIndex = i;
                return TRUE;
            }

            i++;
        }
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//    GetMuiLangInfoFromListView
//
//    Retreives the index of the listview item that corresponds to this UI Language
//
////////////////////////////////////////////////////////////////////////////////////

BOOL GetLcidItemIndexFromListView(HWND hList, LCID lcid, int *piIndex)
{
    int iCount = ListView_GetItemCount(hList);
    int i;
    PMUILANGINFO pMuiLangInfo;
    LVITEM lvItem;

    i = 0;
    while (i < iCount)
    {
        //
        // Check if Language Group is installed
        //
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.state = 0;
        lvItem.stateMask = 0;
        lvItem.pszText = 0;
        lvItem.cchTextMax = 0;
        lvItem.iImage = 0;
        lvItem.lParam = 0;

        ListView_GetItem(hList, &lvItem);
        pMuiLangInfo = (PMUILANGINFO)lvItem.lParam;

        if (pMuiLangInfo->lcid == lcid)
        {
            *piIndex = i;
            return TRUE;
        }

        i++;
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  SelectInstalledLanguages
//
//  Sets the list view check state for insalled languages
//
////////////////////////////////////////////////////////////////////////////////////

BOOL SelectInstalledLanguages(HWND hList)
{
    DWORD dwData;
    DWORD dwIndex;
    DWORD dwValue;
    HKEY hKey;
    LANGID LgLang;
    LONG rc;
    TCHAR lpItemString[BUFFER_SIZE];
    TCHAR szData[BUFFER_SIZE];
    TCHAR szValue[BUFFER_SIZE];

    int iIndex;
    int nLvIndex;

    if (hKey = OpenMuiKey(KEY_READ))
    {
        dwIndex = 0;
        rc = ERROR_SUCCESS;
        iIndex = ListView_GetItemCount(hList);

        while(rc==ERROR_SUCCESS)
        {
            dwValue=sizeof(szValue)/sizeof(TCHAR);
            szValue[0]=TEXT('\0');
            dwData = sizeof(szData);
            szData[0] = TEXT('\0');
            DWORD dwType;

            rc = RegEnumValue(hKey, dwIndex, szValue, &dwValue, 0, &dwType, (LPBYTE)szData, &dwData);
            
            if (rc == ERROR_SUCCESS)
            {
                if (dwType != REG_SZ)
                {
                    dwIndex++;
                    continue;
                }

                LgLang=(WORD)_tcstol(szValue, NULL, 16); 

                if (GetLcidItemIndexFromListView(hList, MAKELCID(LgLang, SORT_DEFAULT), &nLvIndex))
                {
                    ListView_SetCheckState(hList, nLvIndex, TRUE);
                }
            }

            dwIndex++;
        }

        RegCloseKey(hKey);
        return TRUE;
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  UpdateCombo
//
//  Updates the combo box to correspond to the languages selected in the list view
//
////////////////////////////////////////////////////////////////////////////////////

BOOL UpdateCombo(HWND hwndDlg)
{
    BOOL bDefaultSet=FALSE;
    HWND hCombo;
    HWND hList;
    TCHAR lpBuffer[BUFFER_SIZE];
    TCHAR lpSystemDefault[BUFFER_SIZE];
    int i;
    int iIndex;
    int iLbIndex;
    int iListIndex;
    WPARAM iPrevDefault;
    LCID lcidPrev;
    PMUILANGINFO pMuiLangInfo;

    hList = GetDlgItem(hwndDlg, IDC_LIST1);
    hCombo = GetDlgItem(hwndDlg, IDC_DEF_UI_LANG_COMBO);


    //
    //  If the Previous Default is still selected, keep it as the default
    //
    iPrevDefault = SendMessage(hCombo, CB_GETCURSEL, 0, 0);
    if (iPrevDefault == CB_ERR)
        return FALSE;

    lcidPrev = (LCID) SendMessage(hCombo, CB_GETITEMDATA, (WPARAM)iPrevDefault, 0);

    //
    //  Get the text of the currently selected default
    //
    GetLcidItemIndexFromListView(hList, lcidPrev, &iLbIndex);
    
    SendMessage(hCombo, CB_RESETCONTENT, 0, 0);
    iIndex = ListView_GetItemCount(hList);
    iListIndex = 0;
        
    //
    // See if we can preserve the default.
    //
    i = 0;
    while (i < iIndex)
    {
        if (ListView_GetCheckState(hList, i))
        {
            ListView_GetItemText(hList, i, 0, lpBuffer, ARRAYSIZE(lpBuffer)-1);
            iListIndex = (int) SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)lpBuffer);

            if (CB_ERR != iListIndex)
            {
                GetMuiLangInfoFromListView(hList, i, &pMuiLangInfo);

                SendMessage(hCombo, CB_SETITEMDATA, iListIndex, (LPARAM)(LCID)pMuiLangInfo->lcid);

                if (pMuiLangInfo->lcid == lcidPrev)
                {
                    SendMessage(hCombo, CB_SETCURSEL, (WPARAM)iListIndex, 0);
                    bDefaultSet = TRUE;
                }
            }
        }
        i++;
    }

    //
    // If no default, force the system default.
    //
    if (!bDefaultSet)
    {
        lcidPrev = MAKELCID(gSystemUILangId, SORT_DEFAULT);
        if (!GetLcidFromComboBox(hCombo, lcidPrev, &iIndex))
        {
            GetLocaleInfo(lcidPrev,
                          LOCALE_SENGLANGUAGE,
                          lpSystemDefault,
                          ARRAYSIZE(lpSystemDefault)-1);
            iIndex = (int) SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)lpSystemDefault);

            SendMessage(hCombo, CB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)(LCID)lcidPrev);
        }

        SendMessage(hCombo, CB_SETCURSEL, (WPARAM)iIndex, 0);
    }

    return TRUE;
}




////////////////////////////////////////////////////////////////////////////////////
//
//  SetDefault
//
//  Sets the default user setting in the combo box
//
////////////////////////////////////////////////////////////////////////////////////

BOOL SetDefault(HWND hCombo)
{
    int iIndex;
    TCHAR lpBuffer[BUFFER_SIZE];
    LCID lcid = MAKELCID(GetDotDefaultUILanguage(), SORT_DEFAULT);


    GetLocaleInfo(lcid,
                  LOCALE_SENGLANGUAGE,
                  lpBuffer,
                  ARRAYSIZE(lpBuffer)-1);
    
    iIndex = (int)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)lpBuffer);
    if (CB_ERR != iIndex)
    {
        SendMessage(hCombo, CB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)(DWORD) lcid);
        SendMessage(hCombo, CB_SETCURSEL, (WPARAM)iIndex, 0);
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  SetUserDefaultLanguage
//
//  Sets the default language in the registry
//
////////////////////////////////////////////////////////////////////////////////////

BOOL SetUserDefaultLanguage(LANGID langID, BOOL bApplyCurrentUser, BOOL bApplyAllUsers)
{
    TCHAR szCommands[BUFFER_SIZE];
    TCHAR szBuf[BUFFER_SIZE];
    BOOL  success;
    LONG_PTR lppArgs[2];

    //
    // Set the UI language now
    //
    // status = gpfnNtSetDefaultUILanguage(LANGIDFROMLCID(langID));

    szCommands[0] = TEXT('\0');
    if (bApplyCurrentUser)
    {
        // E.g. MUILanguage = "0411".
        wsprintf(szCommands, TEXT("MUILanguage=\"%x\"\n"), langID);
    }        

    if (bApplyAllUsers)
    {    
        wsprintf(szBuf, TEXT("MUILanguage_DefaultUser = \"%x\""), langID);
        _tcscat(szCommands, szBuf);
    }

    success = RunRegionalOptionsApplet(szCommands);

    lppArgs[0] = langID;
    if (success)
    {
        if (bApplyCurrentUser)
        {
            LogFormattedMessage(NULL, IDS_SET_UILANG_CURRENT, lppArgs);    
        }
        if (bApplyAllUsers)
        {
            LogFormattedMessage(NULL, IDS_SET_UILANG_ALLUSERS, lppArgs);        
        }
    } else
    {
        if (bApplyCurrentUser)
        {
            LogFormattedMessage(NULL, IDS_ERROR_SET_UILANG_CURRENT, lppArgs);        
        }
        if (bApplyAllUsers)
        {
            LogFormattedMessage(NULL, IDS_ERROR_SET_UILANG_ALLUSERS, lppArgs);        
        }
    }
    return (success);
}


////////////////////////////////////////////////////////////////////////////////////
//
//  GetDotDefaultUILanguage
//
//  Retrieve the UI language stored in the HKCU\.Default.
//  This is the default UI language for new users.
//
////////////////////////////////////////////////////////////////////////////////////

LANGID GetDotDefaultUILanguage()
{
    HKEY hKey;
    DWORD dwKeyType;
    DWORD dwSize;
    BOOL success = FALSE;
    TCHAR szBuffer[BUFFER_SIZE];
    LANGID langID;
    //
    //  Get the value in .DEFAULT.
    //
    if (RegOpenKeyEx( HKEY_USERS,
                            TEXT(".DEFAULT\\Control Panel\\Desktop"),
                            0L,
                            KEY_READ,
                            &hKey ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szBuffer) * sizeof(TCHAR);
        if (RegQueryValueEx( hKey,
                            TEXT("MultiUILanguageId"),
                            0L,
                            &dwKeyType,
                            (LPBYTE)szBuffer,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwKeyType == REG_SZ)
            {
                langID = (LANGID)_tcstol(szBuffer, NULL, 16);
                success = TRUE;
            }            
        }
        RegCloseKey(hKey);
    }

    if (!success)
    {
    	langID = GetSystemDefaultUILanguage();
    }
    
    return (langID);    
}

////////////////////////////////////////////////////////////////////////////////////
//
//  CheckLangGroupCommandLine
//
//  Command line version of CheckSupport
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CheckLangGroupCommandLine(PINSTALL_LANG_GROUP pInstallLangGroup, LPTSTR lpArg)
{
    int i = 0;
    int iArg;
    LGRPID lgrpid;

    iArg = _tcstol(lpArg, NULL, 16);

    //
    // See if the lang group for this MUI lang is installed or not
    //
    lgrpid = GetLanguageGroup(MAKELCID(iArg, SORT_DEFAULT));

    if (AddMUILangGroup(pInstallLangGroup, lgrpid))
    {
        return TRUE;        
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  SetWindowTitleFromResource
//
//  Set the window title using the specified resource string ID.
//
////////////////////////////////////////////////////////////////////////////////////

void SetWindowTitleFromResource(HWND hwnd, int resourceID)
{
    TCHAR szBuffer[BUFFER_SIZE];
    LoadString(NULL, resourceID, szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
    SetWindowText(hwnd, szBuffer);
}

BOOL UpdateFontLinkRegistry(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched)
{

   return UpdateRegistry_FontLink(Languages,lpbFontLinkRegistryTouched);
}

BOOL RemoveFileReadOnlyAttribute(LPTSTR lpszFileName)
{
   BOOL   bResult = FALSE;
   DWORD  dwAttrib;

   dwAttrib = GetFileAttributes (lpszFileName);

   if ( dwAttrib & FILE_ATTRIBUTE_READONLY )
   {
      dwAttrib &= ~FILE_ATTRIBUTE_READONLY;
      SetFileAttributes (lpszFileName, dwAttrib);
      bResult=TRUE;
   }  
   return bResult;

}
BOOL MUI_DeleteFile(LPTSTR lpszFileName)
{
   RemoveFileReadOnlyAttribute(lpszFileName);
   return DeleteFile(lpszFileName);
}

////////////////////////////////////////////////////////////////////////////////////
//
// MUI_TransferControlToNewVersion
//
// Call %windir%\mui\muisetup.exe /$_transfer_$ mui_installation_file_path command_line
//
////////////////////////////////////////////////////////////////////////////////////

BOOL MUI_TransferControlToNewVersion(LPTSTR lpszExecutable,LPTSTR lpszCommandLine)
{

   STARTUPINFO si;
   PROCESS_INFORMATION pi;
   TCHAR  szAppName[BUFFER_SIZE],szDropPath[MAX_PATH];
   int    nIdx,nLen;
   BOOL   bResult=FALSE;

   nLen=_tcslen(g_szMUISetupFolder);

   for (nIdx=0; nIdx <nLen ; nIdx++)
   {
       if (g_szMUISetupFolder[nIdx]==TEXT(' '))
       {
          szDropPath[nIdx]=MUI_FILLER_CHAR;
       }
       else
       {
          szDropPath[nIdx]=g_szMUISetupFolder[nIdx];
       }
   }
   szDropPath[nIdx]=TEXT('\0');

   wsprintf(szAppName,TEXT("%s %s %s %s"),lpszExecutable,MUISETUP_FORWARDCALL_TAG,szDropPath,lpszCommandLine);
   
   //
   // Run the process
   //
   memset( &si, 0x00, sizeof(si));
   si.cb = sizeof(STARTUPINFO);
 
   if (!CreateProcess(NULL,
              szAppName, 
              NULL,
              NULL,
              FALSE, 
              0L, 
              NULL, NULL,
              &si,
              &pi) )

      return bResult;

   WaitForSingleObject(pi.hProcess, INFINITE);
 

   bResult =TRUE; 

   return bResult;

}

BOOL DeleteSideBySideMUIAssemblyIfExisted(LPTSTR Languages, TCHAR pszLogFile[BUFFER_SIZE])
{
    lstrcpy(pszLogFile, g_szWinDir);                // c:\windows
    lstrcat(pszLogFile, MUISETUP_PATH_SEPARATOR);   // c:\windows\
    
    lstrcat(pszLogFile, MUIDIR);                    // c:\windows\mui
    lstrcat(pszLogFile, MUISETUP_PATH_SEPARATOR);   // c:\windows\mui\
    
    lstrcat(pszLogFile, MUISETUP_ASSEMBLY_INSTALLATION_LOG_FILENAME);     // c:\windows\mui\muisetup.log.
    lstrcat(pszLogFile, Languages);                 // c:\windows\mui\muisetup.log.1234

    if (GetFileAttributes(pszLogFile) != 0xFFFFFFFF) // existed
    {
        // open it and delete assemblies in the list
        SXS_UNINSTALLW UninstallData = {sizeof(UninstallData)};
        UninstallData.dwFlags = SXS_UNINSTALL_FLAG_USE_INSTALL_LOG;
        UninstallData.lpInstallLogFile = pszLogFile;

        return gpfnSxsUninstallW(&UninstallData,NULL);
    }else
        return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  InstallSelected
//
//   Install the languages specified
//
//  Return:
//      TURE if the operation succeeds. Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL InstallSelected(LPTSTR Languages, BOOL *lpbFontLinkRegistryTouched)
{
    TCHAR       lpMessage[BUFFER_SIZE];
    SYSTEM_INFO SystemInfo;
    int         section=0;
    int         iLanguages=0;

    //
    // Next step is to create a list of install directories from layout
    // the directories are listed in the [Directories] section of MUI.INF
    //
    if (!EnumDirectories())
    {
        //
        //  "LOG: Error reading directory list."
        //
        LoadString(ghInstance, IDS_DIRECTORY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return (FALSE);
    }
    EnumFileRename();
    EnumTypeNotFallback();
    //
    // Copy the common files
    //
    if (Languages)
    {
        //
        // Copy MUI files for the selected languages.
        //
        SetWindowTitleFromResource(ghProgDialog, IDS_INSTALL_TITLE);
        if (!CopyFiles(ghProgDialog, Languages))
        {
            //
            //  "LOG: Error copying files."
            //
            //  stop install if copy fails
            //
            LoadString(ghInstance, IDS_COPY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
            LogMessage(lpMessage);
#ifndef IGNORE_COPY_ERRORS
            gNumLanguages_Install = 0;
            return (FALSE);
#endif
        }
        CopyRemoveMuiItself(TRUE);

    }

    //
    // register MUI as installed in registry
    //
    if (!UpdateRegistry(Languages,lpbFontLinkRegistryTouched))
    {
        //
        // LOG: Error updating registry
        //
        LoadString(ghInstance, IDS_REGISTRY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return (FALSE);
    }

    if (!InstallExternalComponents(Languages))
    {
        return (FALSE);
    }
    
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//   UninstallSelected
//
//   Uninstall the languages specified
//
//  Return:
//      TRUE if the operation succeeds. Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL UninstallSelected(LPTSTR Languages,int *lpNotDeleted)
{
    TCHAR       lpMessage[BUFFER_SIZE];
    SYSTEM_INFO SystemInfo;
    int         section = 0;
    int         iLanguages = 0;
    
    //
    // Next step is to create a list of install directories
    // the directories are listed in the [Directories] section
    //

    //
    // this enumerates the directories and fills the array DirNames
    //
    if (!EnumDirectories())
    {
        //
        //   "LOG: Error reading directory list."
        //
        LoadString(ghInstance, IDS_DIRECTORY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return (FALSE);
    }

    UninstallExternalComponents(Languages);
    
    SetWindowTitleFromResource(ghProgDialog, IDS_UNINSTALL_TITLE);
    //
    // Copy the common files
    //
    if (!DeleteFiles(Languages,lpNotDeleted))
    {
        //
        //  "LOG: Error deleting files"
        //
        LoadString(ghInstance, IDS_DELETE_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return (FALSE);
    }

    //
    // register MUI as installed in registry
    //
    if (!UninstallUpdateRegistry(Languages))
    {
        //
        //  "LOG: Error updating registry."
        //
        LoadString(ghInstance, IDS_REGISTRY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
    }
    
    //
    // Delete sxs Assembly
    //
    if (gpfnSxsUninstallW) 
    {
        TCHAR pszLogFile[BUFFER_SIZE];
        if ( ! DeleteSideBySideMUIAssemblyIfExisted(Languages, pszLogFile)) 
        {
            TCHAR errInfo[BUFFER_SIZE];
            swprintf(errInfo, TEXT("Assembly UnInstallation of %s failed"), pszLogFile);
            OutputDebugString(errInfo);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////////////
//
//   UninstallUpdateRegistry
//
//   Update the Registry to account for languages that have been uninstalled
//
////////////////////////////////////////////////////////////////////////////////////

BOOL UninstallUpdateRegistry(LPTSTR Languages)
{
    LPTSTR Language;
    HKEY   hKeyMUI = 0;
    HKEY   hKeyFileVersions = 0;
    DWORD  dwDisp;
    BOOL   bRet = TRUE;

    if ((RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         REG_MUI_PATH,
                         0,
                         TEXT("REG_SZ"),
                         REG_OPTION_NON_VOLATILE ,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hKeyMUI,
                         &dwDisp) == ERROR_SUCCESS) &&
        ((RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         REG_FILEVERSION_PATH,
                         0,
                         TEXT("REG_SZ"),
                         REG_OPTION_NON_VOLATILE ,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hKeyFileVersions,
                         &dwDisp) == ERROR_SUCCESS)))
    {
        Language = Languages;

        while (*Language)
        {
            //
            // Don't remove system UI language for registry
            //
            if (HexStrToInt(Language) != gSystemUILangId)
            {
                //
                //  Delete UI Language key, subkeys and values.
                //
                if ((RegDeleteValue(hKeyMUI, Language) != ERROR_SUCCESS) ||
            	    (DeleteRegTree(hKeyFileVersions, Language) != ERROR_SUCCESS))
                {
                    bRet = FALSE;                    
                }
            }

            while (*Language++)  // go to the next language and repeat
            {
            }
        } // of while (*Language)
    }

    //
    //  Clean up
    //
    if (hKeyMUI)
        RegCloseKey(hKeyMUI);

    if (hKeyFileVersions)
        RegCloseKey(hKeyFileVersions);
    
    return bRet;
}



////////////////////////////////////////////////////////////////////////////////////
//
//  EnumSelectedLanguages
//
//  Enumerate the languages marked for installation
//
//  Return:
//      The total number of MUI languages to be added.
//
////////////////////////////////////////////////////////////////////////////////////


int EnumSelectedLanguages(HWND hList, LPTSTR lpAddLanguages)
{
    TCHAR  lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[3];
    TCHAR  szBuffer[BUFFER_SIZE];
    TCHAR *p;
    LPTSTR lpszLcid;
    int    iIndex;
    int    i = 0;
    PMUILANGINFO pMuiLangInfo;
    int installLangCount = 0;

    iIndex = ListView_GetItemCount(hList);  
    *lpAddLanguages=TEXT('\0');

    while(i<iIndex)
    {
        if(ListView_GetCheckState(hList, i))
        {
            GetMuiLangInfoFromListView(hList, i, &pMuiLangInfo);

            lpszLcid = pMuiLangInfo->lpszLcid;

            if (!IsInstalled(lpszLcid) && HaveFiles(lpszLcid))
            {
                _tcscat(lpAddLanguages, lpszLcid);
                _tcscat(lpAddLanguages, TEXT("*"));

                //
                // Count how many languages are being installed/uninstalled for the progress bar
                //
                gNumLanguages++;
                gNumLanguages_Install++;
                installLangCount++;
            }
          
        }

        i++;

    }

    p = lpAddLanguages;

    while (p=_tcschr(p, TEXT('*')))
    {
        *p=TEXT('\0');
        p++;
    }

    return (installLangCount);
}




////////////////////////////////////////////////////////////////////////////////////
//
//   EnumUnselectedLanguages
//
//   Enumerate the languages marked for removal
//
//  Return:
//      The total number of MUI languages to be added.
//
////////////////////////////////////////////////////////////////////////////////////


int EnumUnselectedLanguages(HWND hList, LPTSTR lpRemoveLanguages)
{
    LVITEM FindInfo;
    LPTSTR p;
    LONG_PTR lppArgs[1];
    TCHAR  lpMessage[BUFFER_SIZE];
    TCHAR  szBuffer[BUFFER_SIZE];
    LPTSTR lpszLcid;
    int    iIndex;
    int    i = 0;
    PMUILANGINFO pMuiLangInfo;
    int uninstallLangCount = 0;

    iIndex = ListView_GetItemCount(hList);
    *lpRemoveLanguages=TEXT('\0');
    g_bRemoveDefaultUI=FALSE;

    while (i < iIndex)
    {
        if (!ListView_GetCheckState(hList, i))
        {
            GetMuiLangInfoFromListView(hList, i, &pMuiLangInfo);

            lpszLcid = pMuiLangInfo->lpszLcid;

            if (IsInstalled(lpszLcid))
            {
                _tcscat(lpRemoveLanguages, lpszLcid);
                _tcscat(lpRemoveLanguages, TEXT("*"));
                if (GetDotDefaultUILanguage() == pMuiLangInfo->lcid)
                {
                   g_bRemoveDefaultUI=TRUE;
                }
                else if (GetUserDefaultUILanguage() == pMuiLangInfo->lcid)
                {
                    g_bRemoveUserUI = TRUE;                
                }
                //
                // Count how many languages are being installed/uninstalled for the progress bar
                //
                gNumLanguages++;
                gNumLanguages_Uninstall++;
                uninstallLangCount++;
            }
        }
        i++;
    }


    p = lpRemoveLanguages;

    while (p=_tcschr(p, TEXT('*')))
    {
        *p = TEXT('\0');
        p++;
    }

    return (uninstallLangCount);
}



////////////////////////////////////////////////////////////////////////////////////
//
//   SkipBlanks
//
//   Skips spaces and tabs in string. Returns pointer to next character
//
////////////////////////////////////////////////////////////////////////////////////


PTCHAR SkipBlanks(PTCHAR pszText)
{
    while (*pszText==TEXT(' ') || *pszText==TEXT('\t'))
    {
        pszText++;
    }

    return pszText;
}
////////////////////////////////////////////////////////////////////////////////////
//
//   NextCommandTag
//
//   pointing to next command tag (TEXT('-') or TEXT('/')
//
////////////////////////////////////////////////////////////////////////////////////
LPTSTR NextCommandTag(LPTSTR lpcmd)
{
    LPTSTR p=NULL;

    if(!lpcmd)
    {
        return (p);
    }     

    while(*lpcmd)
    {
        if ((*lpcmd == TEXT('-')) || (*lpcmd == TEXT('/')))
        {
            // Skip to the character after the '-','/'.
            p = lpcmd + 1;
            break;
        }
        lpcmd++;
    }
    return (p);
}

////////////////////////////////////////////////////////////////////////////////////
//
//   IsInInstallList
//
//   Check if a target is in the string list
//   
//   Structure of string list:
//
//   <string 1><NULL><string 2><NULL>......<string n><NULL><NULL>
//
//////////////////////////////////////////////////////////////////////////////////// 

BOOL IsInInstallList(LPTSTR lpList,LPTSTR lpTarget) 
{
     BOOL bResult=FALSE;

     if (!lpList || !lpTarget)
        return bResult;
     
     while (*lpList)
     {  
        if (!_tcsicmp(lpList,lpTarget))
        {
           bResult=TRUE;
           break;
        }  
        while (*lpList++) // move to next 
        {       
        }
     } 
     return bResult;
}  

////////////////////////////////////////////////////////////////////////////////////
//
//   CreateProgressDialog
//
//   Globals affected:
//      ghProgDialog
//      ghProgress
//
////////////////////////////////////////////////////////////////////////////////////

void CreateProgressDialog(HWND hwnd)
{
    ghProgDialog = CreateDialog(ghInstance,
             MAKEINTRESOURCE(IDD_DIALOG_INSTALL_PROGRESS),
             hwnd,
             ProgressDialogFunc);
    ghProgress = GetDlgItem(ghProgDialog, IDC_PROGRESS1);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  CheckLanguageGroupInstalled
//      Check if the Language groups for specified languages is installed correctly.
//  
//  Parameters:
//      [IN]    lpLanguages     The double-null-terminated string which contains the hex LCID
//                              strings to be checked.
//  Return:
//      TURE if all the required language packs are installed in the system.  Otherwise, FALSE is
//      returned.
//
//  CheckLanguageGroupInstalled
//      Check if the Language groups for specified languages is installed correctly.
//  
//  Parameters:
//      [IN]    lpLanguages     The double-null-terminated string which contains the hex LCID
//                              strings to be checked.
//  Return:
//      TURE if all the required language packs are installed in the system.  Otherwise, FALSE is
//      returned.
//
//  Remarks:
//  01-18-2001  YSLin       Created.
////////////////////////////////////////////////////////////////////////////////////
BOOL CheckLanguageGroupInstalled(LPTSTR lpLanguages)
{    
    LANGID langID;
    LGRPID lgrpID;
    
    while (*lpLanguages != TEXT('\0'))
    {
        langID = (LANGID)TransNum(lpLanguages);    
        lgrpID = GetLanguageGroup(langID);
        if (!gpfnIsValidLanguageGroup(lgrpID, LGRPID_INSTALLED))
        {
            return (FALSE);
        }
        // Go to the null character.
        lpLanguages = _tcschr(lpLanguages, TEXT('\0'));
        // Skip to next char after the null character.
        lpLanguages++;
    }
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  DoSetup
//
//  Parameters:
//      hwnd    The hwnd of the MUISetup main dialog. Pass null if the muisetup is run from command line.
//      UnistallLangCount   The number of languages to be uninstalled.
//      lpUninstall         The double-null-terminated string which contains the hex LCID strings for the
//                          languages to be uninstalled.
//      installLangGroup
//      InstallLangCount    The number of languages to be installed.
//      lpInstall           The double-null-terminated string which contains the hex LCID strings for the
//                          languages to be installed.
//      lpDefaultUILang     The language to be set as system default UI language.  Pass NULL if the system default
//                          UI language is not changed.
//      fAllowReboot        The flag to indicate if this function should check if reboot is necessary.
//      bInteractive        TRUE if run in interactive mode, or FALSE if run in silent mode.
//      
//
//  Return:
//      TRUE if installation is successful.  Otherwise FALSE.
//
//  Notes:
//      This functions serves as the entry point of the real installation process, shared by both the GUI setup
//      and the command line mode setup.
//
//      There are several steps in doing MUI setup.
//      1. Uninstall the selected MUI languages.
//      2. Install the necessary language packs according to the selected MUI languges(if any).
//      3. Install the selected MUI languages.
//      4. Change the default UI language.
//      5. Check for rebooting.
//
// Please note that to save space, we do the uninstallation first, then do the installation.
////////////////////////////////////////////////////////////////////////////////////

BOOL DoSetup(
    HWND hwnd,
    int UninstallLangCount, LPTSTR lpUninstall, 
    INSTALL_LANG_GROUP installLangGroup, 
    int InstallLangCount, LPTSTR lpInstall, 
    LPTSTR lpDefaultUILang,
    BOOL fAllowReboot, BOOL bInteractive)
{
    LONG_PTR lppArgs[3];
    TCHAR lpMessage[BUFFER_SIZE];   
    TCHAR lpForceUILang[BUFFER_SIZE];    
    TCHAR lpTemp[BUFFER_SIZE];
    TCHAR lpTemp2[BUFFER_SIZE];
    LANGID defaultLangID;
    
    HCURSOR hCurSave;

    int NotDeleted;
    BOOL bDefaultUIChanged = FALSE;

    LANGID lidSys = GetSystemDefaultLangID();
    BOOL isReboot;

    ghProgDialog = NULL;
    ghProgress = NULL;
    hCurSave=SetCursor(LoadCursor(NULL, IDC_WAIT));

    if(UninstallLangCount > 0)
    {
        CreateProgressDialog(hwnd);
        SendMessage(ghProgress, PBM_SETRANGE, (WPARAM)(int)0, (LPARAM)MAKELPARAM(0, UninstallLangCount * INSTALLED_FILES));
        SendMessage(ghProgress, PBM_SETPOS, (WPARAM)0, 0); 
        SetWindowTitleFromResource(ghProgDialog, IDS_UNINSTALL_TITLE);

        //
        // Uninstall MUI languages
        //
        if (!UninstallSelected(lpUninstall, &NotDeleted))
        {
            DestroyWindow(ghProgDialog);
            ghProgDialog = NULL;
            SetCursor(hCurSave);
            return (FALSE);
        }

        SendMessage(ghProgress, PBM_SETPOS, (WPARAM)(UninstallLangCount * INSTALLED_FILES), 0);
    }

    if(InstallLangCount > 0)
    {
        //
        // Install Language Group First
        //
        if (!InstallLanguageGroups(&installLangGroup))
        {
            DestroyWindow(ghProgDialog);
            ghProgDialog = NULL;
            SetCursor(hCurSave);
            return (FALSE);
        }

        //
        // Check if language group in installLangGroup is installed correctly
        //
        if (!CheckLanguageGroupInstalled(lpInstall))
        {
            LogFormattedMessage(NULL, IDS_LG_NOT_INSTALL_L, NULL);
            if (bInteractive)
            {
                DoMessageBox(NULL, IDS_LG_NOT_INSTALL, IDS_MAIN_TITLE, MB_OK);
            }
            return (FALSE);
        }
        
        //
        // Make sure MUI CD-ROM is put in the CD-ROM drive.
        //
        if(CheckVolumeChange())
        {
            DestroyWindow(ghProgDialog);
            ghProgDialog = NULL;
            SetCursor(hCurSave);
            return (FALSE);
        }

        if (ghProgDialog == NULL) 
        {
            CreateProgressDialog(hwnd);
        }            
        SendMessage(ghProgress, PBM_SETRANGE, (WPARAM)(int)0, (LPARAM)MAKELPARAM(0, InstallLangCount * INSTALLED_FILES));
        SendMessage(ghProgress, PBM_SETPOS, (WPARAM)0, 0);
        SetWindowTitleFromResource(ghProgDialog, IDS_INSTALL_TITLE);

        if (!InstallSelected(lpInstall,&installLangGroup.bFontLinkRegistryTouched))
        {
            DestroyWindow(ghProgDialog);
            ghProgDialog = NULL;
            SetCursor(hCurSave);
            return (FALSE);
        }
        
        SendMessage(ghProgress, PBM_SETPOS, (WPARAM)((UninstallLangCount+InstallLangCount) * INSTALLED_FILES), 0);
        
    }
    DestroyWindow(ghProgDialog);
    ghProgDialog = NULL;
    SetCursor(hCurSave); 

    if (UninstallLangCount + InstallLangCount > 0)
    {
        //
        //  "Installation Complete"
        //  "Installation was completed successfully."
        //
        if (bInteractive)
        {
            DoMessageBox(hwnd, InstallLangCount > 0 ? IDS_MUISETUP_SUCCESS : IDS_MUISETUP_UNINSTALL_SUCCESS, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);        

        }
    }

    //
    // In command line mode, if "/D" is specified, we should ask user to confirm making default UI language change.
    // In command line mode, if "/D" is NOT specified, we should NOT try to change the default UI language.
    // In command line mode, if "/D" & "/S" are specified, we will NOT ask user's confirmation.
    // In GUI mode, we always ask user to confirm making default UI language change.
    // 

    //
    // Special case:
    // If the current default UI language is going to be removed and user doesn't choose a new UI language,
    // we will force to set the default UI language to be the system UI language.
    //    
    if(g_bRemoveDefaultUI)
    {
        if (!lpDefaultUILang || !(IsInstalled(lpDefaultUILang)))
        {
            _stprintf(lpForceUILang, TEXT("%04x"), gSystemUILangId);
            lpDefaultUILang = lpForceUILang;
        }        
    }    

    if (lpDefaultUILang)
    {
        defaultLangID = (LANGID)_tcstol(lpDefaultUILang, NULL, 16);
        if (IsInstalled(lpDefaultUILang))
        {
            //
            // If the assigned UI language ID (defaultLangID) is already the default user UI language,
            // we don't do anything.  Otherwise, change the default user UI langauge.
            //
            if (defaultLangID != GetDotDefaultUILanguage())
            {
                if (SetUserDefaultLanguage(defaultLangID, FALSE, TRUE))
                {
                    bDefaultUIChanged = TRUE;
                } else
                {
                    if (bInteractive)
                    {
                        DoMessageBox(hwnd, IDS_DEFAULT_USER_ERROR, IDS_MAIN_TITLE, (MB_OK | MB_ICONEXCLAMATION));
                    }
                }
            } else
            {
                // Do nothing here. I leave this here intentionally to highlight that
                // we don't do antying if the specified defaultLangID is already the default UI language.
            }

            //
            // Make sure registry is set correctly
            //
            if(BST_CHECKED == IsDlgButtonChecked( hwnd, IDC_CHECK_LOCALE ))
            {
                SetMUIRegSetting(MUI_MATCH_LOCALE, TRUE);
                SetMUIRegSetting(MUI_MATCH_UIFONT, BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CHECK_UIFONT));
            }
            else
            {
                SetMUIRegSetting(MUI_MATCH_LOCALE, FALSE);
                SetMUIRegSetting(MUI_MATCH_UIFONT, FALSE);
            }

            //
            // Notify intl.cpl if we have system locale or UI font setting change
            //
            if ((BST_CHECKED == IsDlgButtonChecked( hwnd, IDC_CHECK_LOCALE)  || g_bCmdMatchLocale) && 
                defaultLangID != lidSys)
            {
                TCHAR szCommands[BUFFER_SIZE];
                
                //
                // Invoke intl.cpl to change system locale to match the default UI language
                //
                wsprintf(szCommands, TEXT("SystemLocale = \"%x\""), defaultLangID);
                //
                // Always reboot if system locale is changed
                //
                if (RunRegionalOptionsApplet(szCommands))
                {
                    g_bReboot = TRUE;
                }
            }
            else if (g_bMatchUIFont != (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CHECK_UIFONT)) ||
                     g_bCmdMatchUIFont)
            {
                TCHAR szCommands[BUFFER_SIZE];
                
                //
                // Invoke intl.cpl to change system locale to match the default UI language
                //
                wsprintf(szCommands, TEXT("SystemLocale = \"%x\""), lidSys);
                
                if (RunRegionalOptionsApplet(szCommands) && defaultLangID == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))
                {
                    // Don't prompt for reboot, intl.cpl will cause muisetup to loose focus if we do so.                     
                    // Need to fix this in XP server release
                    
                    // g_bReboot = TRUE;
                }
            }

        } else 
        {
            //
            //  "ERROR: %1 was not set as the default. It is not installed.\r\nNo default UI language change."
            //
            lppArgs[0] = (LONG_PTR)lpDefaultUILang;
            LogFormattedMessage(NULL, IDS_DEFAULT_L, lppArgs);
            return (FALSE);            
        }
    }

    //
    // Check for reboot, and if we are allowed to do so.
    //
    if (fAllowReboot)
    {
        //
        // Check if we need to reboot?
        //
        if (!CheckForReboot(hwnd, &installLangGroup))
        {
            //
            // Check if we recommend a reboot?
            //
            if (bInteractive && bDefaultUIChanged)
            {
                GetLanguageDisplayName(defaultLangID, lpTemp, ARRAYSIZE(lpTemp)-1);

                lppArgs[0] = (LONG_PTR)lpTemp;

                if (lidSys == defaultLangID)
                {
                    isReboot = (DoMessageBoxFromResource(hwnd, ghInstance, IDS_CHANGE_UI_NEED_RBOOT, lppArgs, IDS_MAIN_TITLE, MB_YESNO) == IDYES);
                } else
                {
                    GetLanguageDisplayName(lidSys, lpTemp2, ARRAYSIZE(lpTemp2)-1);

                    lppArgs[1] = (LONG_PTR)lpTemp2;
                
                    isReboot = (DoMessageBoxFromResource(hwnd, ghInstance, IDS_CHANGE_UI_NEED_RBOOT_SYSTEM_LCID, lppArgs, IDS_MAIN_TITLE, MB_YESNO) == IDYES);
                }
                if (isReboot) 
                {
                    Muisetup_RebootTheSystem();
                }
                
            }
        }            
    }

    return (TRUE);
}

int ParseUninstallLangs(LPTSTR p, LPTSTR lpUninstall, int cchUninstall, INT64* pulUISize, INT64* pulLPKSize, INT64* pulSpaceNeed, BOOL* pbLogError)
{
    int iCopied;
    TCHAR lpBuffer[BUFFER_SIZE];
    LONG_PTR lppArgs[2];
    int cLanguagesToUnInstall = 0;
    LANGID LgId;

    LPTSTR pU = lpUninstall;
    

    p = SkipBlanks(p);

    iCopied = 0;
    while((*p != TEXT('-')) && (*p != TEXT('/')) && (*p != TEXT('\0')))
    { 
        iCopied = CopyArgument(lpBuffer, p);

        if(!HaveFiles(lpBuffer, FALSE))
        {
            //
            //  "LOG: %1 was not installed. It is not listed in MUI.INF."
            //
            lppArgs[0] = (LONG_PTR)lpBuffer;
            LogFormattedMessage(NULL, IDS_NOT_LISTED_L, lppArgs);
            *pbLogError = TRUE;
        } else if (!IsInstalled(lpBuffer))
        {
            //
            //  "LOG: %1 was not uninstalled, because it is not installed. "
            //
            lppArgs[0] = (LONG_PTR)lpBuffer;
            LogFormattedMessage(NULL, IDS_IS_NOT_INSTALLED_L, lppArgs);
            *pbLogError = TRUE;
        } else if (!IsInInstallList(lpUninstall,lpBuffer))
        {
            iCopied = CopyArgument(pU, p);

            //
            // Check if we are going to remove the current UI language
            //
            LgId = (LANGID)_tcstol(pU, NULL, 16);                    
            if (LgId == GetDotDefaultUILanguage())
            {
                g_bRemoveDefaultUI = TRUE;
            }
            else if (LgId == GetUserDefaultUILanguage())
            {
                g_bRemoveUserUI = TRUE;
            }

            //
            // Calculate the space required
            //
            GetUIFileSize_commandline(lpBuffer, pulUISize,pulLPKSize);
            *pulSpaceNeed-=*pulUISize;
            pU += iCopied;
            pU++; //skip over NULL
            cLanguagesToUnInstall++;                    
        }

        p += iCopied;
        p  = SkipBlanks(p);
    }

    //
    // Uninstall all MUI languages if there is no language argument after /U
    //
    if (iCopied == 0)
    {
        cLanguagesToUnInstall = GetInstalledMUILanguages(lpUninstall, cchUninstall);
        if (cLanguagesToUnInstall == 0)
        {
            LogFormattedMessage(ghInstance, IDS_NO_MUI_LANG, NULL);
            *pbLogError = TRUE;
        }
        else
        {
            if (0x0409 != GetDotDefaultUILanguage())
            {
                g_bRemoveDefaultUI = TRUE;
            }
            if (0x0409 != GetUserDefaultUILanguage())
            {
                g_bRemoveUserUI = TRUE;
            }
        }
    }
    else
    {
        *pU=TEXT('\0');
    }                

    return (cLanguagesToUnInstall);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetCDNameFromLang
//
//  Given a langange ID (in hex string), return the CD name where the language 
//  installation folder exist.
//  This can also be used to check if the language is supported MUI language.
//
//  Parameters:
//      [IN]  lpLangName  the language to be installed in hex string.
//      [OUT] lpCDName    the number of the CD (e.g. "2" or "3").
//      [IN]  nCDNameSize the size of lpCDName, in TCHAR.
//
//  Return Values:
//      TRUE if lpLangName is a supported MUI language.  lpCDName will contain
//      the name of the CD. 
//      FALSE if the language ID is not a supported langauge. lpCDNAme will be 
//      empty string.
//
//  Remarks:
//
//  01-01-2001  YSLin       Created.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetCDNameFromLang(LPTSTR lpLangName, LPTSTR lpCDName, int nCDNameSize)
{
    if (!GetPrivateProfileString(
            MUI_CDLAYOUT_SECTION,
            lpLangName,
            TEXT(""),
            lpCDName,
            nCDNameSize,
            g_szMUIInfoFilePath))
    {
        return (FALSE);
    }
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  ParseCommandLine
//
//  Runs installation functions with command line specifications
//
////////////////////////////////////////////////////////////////////////////////////

BOOL ParseCommandLine(LPTSTR lpCommandLine)
{
    BOOL bSetDefaultUI=FALSE;    // Specify if the /D switch is used to change the user default UI language.
    BOOL bInstall=FALSE;
    BOOL bLogError=FALSE;
    BOOL bFELangpackAdded=FALSE;
    
    DWORD dwDisp;
    LANGID LgId;
    TCHAR lpBuffer[BUFFER_SIZE];
    TCHAR lpDefault[BUFFER_SIZE];
    TCHAR lpDefaultText[MAX_PATH];
    TCHAR lpInstall[BUFFER_SIZE];
    TCHAR lpMessage[BUFFER_SIZE];
    TCHAR lpUninstall[BUFFER_SIZE];
    TCHAR lpSystemDefault[BUFFER_SIZE];
    TCHAR lpTemp[BUFFER_SIZE];
    TCHAR  szWinDir[MAX_PATH];
    INSTALL_LANG_GROUP installLangGroup;
    LONG_PTR lppArgs[4];
    PTCHAR pI;
    PTCHAR pD;
    PTCHAR p;
    BOOL fAllowReboot = TRUE,bLGInstalled=FALSE;
    int cLanguagesToInstall = 0L;
    int cLanguagesToUnInstall = 0L;
    int iCopied;
    TCHAR chOpt;                     
    INT64 ulSpaceNeed=0,ulSpaceAvailable=0,ulUISize=0,ulLPKSize=0;
    ULONG ulParam[2];
    ULARGE_INTEGER ulgiFreeBytesAvailableToCaller;
    ULARGE_INTEGER ulgiTotalNumberOfBytes;
    BOOL bHasLangArgs = FALSE;

    BOOL bHelpDisplayed=FALSE;    
    TCHAR lpCDName[BUFFER_SIZE];

    //
    // Initialize Lang-Groups to install
    //
    installLangGroup.iCount = 0L;
    installLangGroup.NotDeleted = 0L;
    installLangGroup.bFontLinkRegistryTouched = FALSE;

    lpInstall[0]   = TEXT('\0');
    lpUninstall[0] = TEXT('\0');
    lpDefault[0] = TEXT('\0');

    pI = lpInstall;
    pD = lpDefault;
    p  = lpCommandLine;

    CharLower(p);
    while(p=NextCommandTag(p))
    {
        chOpt = *p++;
        switch (chOpt)
        {
        case '?':
        case 'h':
            if (!bHelpDisplayed)
            {  
                DisplayHelpWindow();
                bHelpDisplayed=TRUE;
            }
            p = SkipBlanks(p);
            break;
       
        case 'i':
            if (!FileExists(g_szMUIInfoFilePath))
            {
                //
                //    "The file MUI.INF cannot be found."
                //
                DoMessageBox(NULL, IDS_NO_MUI_FILE, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
                break;
            }

            //
            // MUI version needs to match OS version
            //
            if (!checkversion(TRUE))
            {
                DoMessageBox(NULL, IDS_WRONG_VERSION, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
                break;
            }
            
            p = SkipBlanks(p);
            while ((*p != TEXT('-'))  && (*p != TEXT('/')) && (*p != TEXT('\0')))
            {
                bHasLangArgs = TRUE;
                iCopied=CopyArgument(lpBuffer, p);

                if (!IsInstalled(lpBuffer) &&
                    CheckLanguageIsQualified(lpBuffer) &&
                    HaveFiles(lpBuffer) && (!IsInInstallList(lpInstall,lpBuffer)) )
                {   
                    //
                    // Calculate the space required
                    //
                    GetUIFileSize_commandline(lpBuffer, &ulUISize,&ulLPKSize);
                    ulSpaceNeed+=ulUISize;
                    if(CheckLangGroupCommandLine(&installLangGroup, lpBuffer))
                    {
                      if (IS_FE_LANGPACK(_tcstol(lpBuffer, NULL, 16)))
                      {
                        if (!bFELangpackAdded)
                        {
                            ulSpaceNeed+=ulLPKSize;                        
                            bFELangpackAdded = TRUE;
                        }
                      }else
                      {
                         ulSpaceNeed+=ulLPKSize;                        
                      }
                    }
                    AddExtraLangGroupsFromINF(lpBuffer, &installLangGroup);
                    iCopied=CopyArgument(pI, p);
                    pI += iCopied;
                    pI++; //skip over NULL
                    bInstall = TRUE;
                    cLanguagesToInstall++;
                }
                else
                {
                    lppArgs[0]=(LONG_PTR)lpBuffer;

                    if(IsInstalled(lpBuffer)|| IsInInstallList(lpInstall,lpBuffer))
                    {
                        // "LOG: %1 was not installed, because it is already installed. "
                        LogFormattedMessage(ghInstance, IDS_IS_INSTALLED_L, lppArgs);
                    }

                    if(!HaveFiles(lpBuffer))
                    {
                        if (!GetCDNameFromLang(lpBuffer, lpCDName, ARRAYSIZE(lpCDName)))
                        {
                            // lpBuffer is not a supported MUI language.
                            //  "LOG: %1 was not installed, because it is not listed in MUI.INF. Please check if it is a valid UI language ID."
                            LogFormattedMessage(ghInstance, IDS_NOT_LISTED_L, lppArgs);
                        } else
                        {
                            // lpBuffer is a supported MUI language, ask user to change CD and
                            // rerun setup.
                            LoadString(ghInstance, IDS_CHANGE_CDROM, lpTemp, ARRAYSIZE(lpTemp)-1);
                            lppArgs[1] = (LONG_PTR)lpTemp;
                            lppArgs[2] = (LONG_PTR)lpCDName;
                            // "ERROR: %1 was not installed, because it is located in %2 %3.  Please insert that CD and rerun MUISetup."
                            LogFormattedMessage(ghInstance, IDS_LANG_IN_ANOTHER_CD_L, lppArgs);
                        }
                    }
                    if(!CheckLanguageIsQualified(lpBuffer))
                    {   
                        // "LOG: %1 was not installed, because it cannot be installed on this platform\n"
                        LogFormattedMessage(ghInstance, IDS_NOT_QUALIFIED_L, lppArgs);
                    }                   

                    bLogError = TRUE;
                }

                p += iCopied;
                p  = SkipBlanks(p);
            }
            if (!bHasLangArgs)
            {
                lppArgs[0] = (LONG_PTR)TEXT("/I");
                FormatStringFromResource(lpMessage, sizeof(lpMessage)/sizeof(TCHAR), ghInstance, IDS_ERROR_NO_LANG_ARG, lppArgs);
                LogMessage(lpMessage);
                bLogError = TRUE;
            }

            *pI = TEXT('\0');
            break;
      
        case 'u':
            if (!checkversion(FALSE))
            {
                DoMessageBox(NULL, IDS_WRONG_VERSION, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
                break;
            }
            cLanguagesToUnInstall = ParseUninstallLangs(p, lpUninstall, ARRAYSIZE(lpUninstall), &ulUISize, &ulLPKSize, &ulSpaceNeed, &bLogError);
            break;

        case 'd':
            if (!checkversion(FALSE))
            {
                DoMessageBox(NULL, IDS_WRONG_VERSION, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
                break;
            }

            bSetDefaultUI = TRUE;
            p = SkipBlanks(p);
            if (CopyArgument(lpDefault, p) == 0)
            {
                lppArgs[0] = (LONG_PTR)TEXT("/D");
                FormatStringFromResource(lpMessage, sizeof(lpMessage)/sizeof(TCHAR), 
                    ghInstance, IDS_ERROR_NO_LANG_ARG, lppArgs);
                LogMessage(lpMessage);
                bLogError = TRUE;
            }
            break;
        case 'r':
            fAllowReboot = FALSE;
            break;
        case 's' :
            g_bSilent = TRUE;
            break;
        case 'l':
            g_bCmdMatchLocale = TRUE;
            break;
        case 'f':
            g_bCmdMatchUIFont = TRUE;
            break;
        // Internal, MSI uses this switch to call out external MUI APIs
        case 'e':
            {
                TCHAR szLanguages[32] = {0};
                p = SkipBlanks(p);
                if (CopyArgument(szLanguages, p))
                {
                    InstallExternalComponents(szLanguages);
                }
                break;
            }
        // Internal, MSI uses this switch to call out external MUI APIs
        case 'm':
            {
                TCHAR szLanguages[32] = {0};
                p = SkipBlanks(p);
                if (CopyArgument(szLanguages, p))
                {
                    UninstallExternalComponents(szLanguages);
                }
                break;
            }

        }
    }

    //
    // UI Font depends on system locale
    //
    if (!g_bCmdMatchLocale && g_bCmdMatchUIFont)
    {
        g_bCmdMatchUIFont = FALSE;
    }

    //
    // Check the disk space
    //  
    //
    pfnGetWindowsDir( szWinDir, MAX_PATH);
    szWinDir[3]=TEXT('\0');
    if (GetDiskFreeSpaceEx(szWinDir,
                      &ulgiFreeBytesAvailableToCaller,
                      &ulgiTotalNumberOfBytes,
                      NULL))
    {
      ulSpaceAvailable= ulgiFreeBytesAvailableToCaller.QuadPart;
      if ( ulSpaceAvailable <  ulSpaceNeed )
      { 
         ulParam[0] = (ULONG) (ulSpaceNeed/1024);
         ulParam[1] = (ULONG) (ulSpaceAvailable/1024);

         LoadString(ghInstance, IDS_DISKSPACE_NOTENOUGH, lpMessage, ARRAYSIZE(lpMessage)-1);
         LoadString(ghInstance, IDS_ERROR_DISKSPACE, lpTemp, ARRAYSIZE(lpTemp)-1);
         FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                  lpMessage,
                                  0,
                                  0,
                                  lpMessage,
                                  ARRAYSIZE(lpMessage)-1,
                                  (va_list *) ulParam);
         LogMessage(lpMessage);
         bLogError = TRUE;
         MESSAGEBOX(NULL, lpMessage, lpTemp, MB_OK | MB_DEFBUTTON1 | MB_ICONWARNING);
         bInstall = FALSE;
         cLanguagesToUnInstall = 0;
      }
      
    } 

    if (!bLogError)
    {
        //
        // Let's set the default UI language
        //
        if (!DoSetup(
            NULL,
            cLanguagesToUnInstall, lpUninstall, 
            installLangGroup, 
            cLanguagesToInstall, lpInstall,
            (bSetDefaultUI ? lpDefault : NULL), 
            fAllowReboot, !g_bSilent))
        {
            bLogError = TRUE;
        }
    } 

    if (bLogError && !g_bSilent)
    {
        //
        //  "Installation Error"
        //  "One or more errors occurred during installation.
        //   Please see %1\muisetup.log for more information."
        //
        lppArgs[0] = (LONG_PTR)szWindowsDir;
        DoMessageBoxFromResource(NULL, ghInstance, IDS_ERROR, lppArgs, IDS_ERROR_T, MB_OK | MB_DEFBUTTON1 | MB_ICONWARNING);
    }
    return TRUE;
} 


////////////////////////////////////////////////////////////////////////////////////
//
//  DisplayHelpWindow
//
//  Displays help window for command line version
//
////////////////////////////////////////////////////////////////////////////////////

void DisplayHelpWindow()
{

  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  TCHAR Appname[MAX_PATH+MAX_PATH+1];
  
  
  if (FileExists(g_szMUIHelpFilePath))
  {
     wsprintf(Appname,TEXT("winhlp32.exe -n%d %s"),IDH_MUISETUP_COMMANDLINE,g_szMUIHelpFilePath);
     memset( &si, 0x00, sizeof(si));
     si.cb = sizeof(STARTUPINFO);
  
     if (!CreateProcess(NULL,
               Appname, 
               NULL,
               NULL,
               FALSE, 
               0L, 
               NULL, NULL,
               &si,
               &pi) )
        return;

     WaitForSingleObject(pi.hProcess, INFINITE);
  }
  else
  { 
     //////////////////////////////////////////////
     //  MessageBox should be changed to Dialog
     //////////////////////////////////////////////
     DoMessageBox(NULL, IDS_HELP, IDS_HELP_T, MB_OK | MB_DEFBUTTON1);
  }

} 

////////////////////////////////////////////////////////////////////////////////////
//
//  CopyArgument
//
//  Copies command line argument pointed to by src to dest
//
////////////////////////////////////////////////////////////////////////////////////

int CopyArgument(LPTSTR dest, LPTSTR src)
{
    int i=0;
    while(*src!=TEXT(' ') && *src!=TEXT('\0'))
    {
        *dest=*src;
        dest++;
        src++;
        i++;
    }

    *dest = TEXT('\0');
    return i;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  IsInstalled
//
//  Checks to see if lpArg is a language installed in the registry
//
////////////////////////////////////////////////////////////////////////////////////

BOOL IsInstalled(LPTSTR lpArg)
{ 
    HKEY hKey;
    DWORD dwData;
    DWORD dwIndex;
    DWORD dwValue;
    TCHAR lpData[BUFFER_SIZE];
    TCHAR lpValue[BUFFER_SIZE];

    int rc;
    int iArg;
    
    
    hKey=OpenMuiKey(KEY_READ);
    if (hKey == NULL)
    {
        return (FALSE);
    }

    dwIndex=0;
    rc=ERROR_SUCCESS;
    
    iArg=_tcstol(lpArg, NULL, 16);

    if (iArg == gSystemUILangId)
    {
        return (TRUE);
    }

    while(rc==ERROR_SUCCESS)
    {
        dwValue=sizeof(lpValue)/sizeof(TCHAR);
        lpValue[0]=TEXT('\0');
        dwData=sizeof(lpData);
        lpData[0]=TEXT('\0');
        DWORD dwType;
    
        rc=RegEnumValue(hKey, dwIndex, lpValue, &dwValue, 0, &dwType, (LPBYTE)lpData, &dwData);

        if(rc==ERROR_SUCCESS)
        {
            if (dwType != REG_SZ)
            {
                dwIndex++;
                continue;
            }

            if(_tcstol(lpValue, NULL, 16)==iArg)
            {           
                RegCloseKey(hKey);  
                return TRUE;
            }
        }

        dwIndex++;
    }

    RegCloseKey(hKey);
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  GetInstalledMUILanguages
//
//  Get installed MUI languages, dump it to lpUninstall buffer in a MULTI_SZ format
//
////////////////////////////////////////////////////////////////////////////////////

DWORD GetInstalledMUILanguages(LPTSTR lpUninstall, int cch)
{ 
    HKEY hKey;
    DWORD dwIndex = 0;
    DWORD dwCount = 0;
    DWORD dwValue = cch;
    DWORD dwType;

    if (hKey = OpenMuiKey(KEY_READ))
    {
        while(ERROR_NO_MORE_ITEMS != RegEnumValue(hKey, dwIndex++, lpUninstall, &dwValue, 0, &dwType, NULL, NULL) && 
            cch > 0)
        {
            if (dwType != REG_SZ)
                continue;

            if (_tcstol(lpUninstall, NULL, 16) != gSystemUILangId) 
            {
                //
                // Count in NULL
                //
                dwValue++;
                lpUninstall += dwValue;
                cch -= dwValue;

                dwCount++;                
            }
            dwValue = cch;                
        }

        RegCloseKey(hKey);
        *lpUninstall = TEXT('\0');
    }

    return dwCount;
}



////////////////////////////////////////////////////////////////////////////////////
//
//  HaveFiles
//
//  Checks that the language in lpBuffer is in MUI.INF
//
////////////////////////////////////////////////////////////////////////////////////

BOOL HaveFiles(LPTSTR lpBuffer, BOOL bCheckDir)
{
    LPTSTR lpLanguages;
    TCHAR  lpMessage[BUFFER_SIZE];
    TCHAR  tchBuffer[BUFFER_SIZE];

    lpLanguages = tchBuffer;

    if (EnumLanguages(lpLanguages, bCheckDir) == 0)
    {
        //
        //  "LOG: No languages found in MUI.INF"
        //
        LoadString(ghInstance, IDS_NO_LANG_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return FALSE;
    }

    while (*lpLanguages != TEXT('\0'))
    {
        if (_tcscmp(lpBuffer, lpLanguages) == 0)
        {
            return TRUE;
        }
        lpLanguages = _tcschr(lpLanguages, '\0');
        lpLanguages++;
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  OpenLogFile
//
//  Opens the setup log for writing
//
////////////////////////////////////////////////////////////////////////////////////

HANDLE OpenLogFile()
{
    DWORD dwSize;
    DWORD dwUnicodeHeader;
    HANDLE hFile;
    SECURITY_ATTRIBUTES SecurityAttributes;
    TCHAR lpPath[BUFFER_SIZE];

    int error;
    
    pfnGetWindowsDir(lpPath, MAX_PATH);
    error=GetLastError();
    _tcscat(lpPath, LOG_FILE);

    SecurityAttributes.nLength=sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor=NULL;
    SecurityAttributes.bInheritHandle=FALSE;
        
    hFile=CreateFile(
        lpPath,
        GENERIC_WRITE,
        0,
        &SecurityAttributes,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);  

#ifdef UNICODE

    //
    //  If the file did not already exist, add the unicode header
    //
    if(GetLastError()==0)
    {
        dwUnicodeHeader=0xFEFF;
        WriteFile(hFile, &dwUnicodeHeader, 2, &dwSize, NULL);
    }

#endif

    error=GetLastError();

    return hFile;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  LogMessage
//
//  Writes lpMessage to the setup log
//
////////////////////////////////////////////////////////////////////////////////////

BOOL LogMessage(LPCTSTR lpMessage)
{
    DWORD dwBytesWritten;
    HANDLE hFile;
    
    hFile=OpenLogFile();
    
    if(hFile==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile(
        hFile,
        lpMessage,
        _tcslen(lpMessage) * sizeof(TCHAR),
        &dwBytesWritten,
        NULL);

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile(
        hFile,
        TEXT("\r\n"),
        _tcslen(TEXT("\r\n")) * sizeof(TCHAR),
        &dwBytesWritten,
        NULL);


    CloseHandle(hFile);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
// LogFormattedMessage
//
// Writes a formatted lpMessage to the setup log
//
////////////////////////////////////////////////////////////////////////////////////

BOOL LogFormattedMessage(HINSTANCE hInstance, int messageID, LONG_PTR* lppArgs)
{
    TCHAR szBuffer[BUFFER_SIZE];
    
    LoadString(hInstance, messageID, szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
    if (lppArgs == NULL)
    {
        return (LogMessage(szBuffer));
    }
    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        szBuffer,
        0,
        0,
        szBuffer,
        sizeof(szBuffer) / sizeof(TCHAR),
        (va_list *)lppArgs);
    
    return (LogMessage(szBuffer));
}

////////////////////////////////////////////////////////////////////////////
//
//  FormatStringFromResource
//
//  Format a string using the format specified in the resource and the 
//  specified arguments.
//
//  Parameters:
//
//  Return Values:
//      the formatted string.
//
//  Remarks:
//
//  08-07-2000  YSLin       Created.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR FormatStringFromResource(LPTSTR pszBuffer, UINT bufferSize, HMODULE hInstance, int messageID, LONG_PTR* lppArgs)
{
    TCHAR szFormatStr[BUFFER_SIZE];
    
    LoadString(hInstance, messageID, szFormatStr, ARRAYSIZE(szFormatStr)-1);
    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  szFormatStr,
                  0,
                  0,
                  pszBuffer,
                  bufferSize ,
                  (va_list *)lppArgs);
    return (pszBuffer);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  BeginLog
//
//  Writes a header to the setup log
//
////////////////////////////////////////////////////////////////////////////////////

void BeginLog(void)
{
    TCHAR lpMessage[BUFFER_SIZE];

    //
    //  "**********************************************************
    //  Language Module Installation Log
    //  **********************************************************" (LOG)
    //
    LoadString(ghInstance, IDS_LOG_HEAD, lpMessage, ARRAYSIZE(lpMessage)-1);
    LogMessage(lpMessage);
    
}

////////////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageGroup
//
//  Retreive the Language Group of this locale.
//
////////////////////////////////////////////////////////////////////////////////////

LGRPID GetLanguageGroup(LCID lcid)
{
    int i;

    gLangGroup = LGRPID_WESTERN_EUROPE;
    gFoundLangGroup = FALSE;

    gLCID = lcid;

    for (i=0 ; i<gNumLanguageGroups; i++)
    {
        // The globals gLangGroup and gFoundLangGroup is used in the callback function
        // EnumLanguageGroupLocalesProc.
        gpfnEnumLanguageGroupLocalesW(EnumLanguageGroupLocalesProc, gLanguageGroups[i], 0L, 0L);

        //
        // If we found it, then break now
        //
        if (gFoundLangGroup)
            break;

    }

    return gLangGroup;
}


BOOL EnumLanguageGroupLocalesProc(
    LGRPID langGroupId,
    LCID lcid,
    LPTSTR lpszLocale,
    LONG_PTR lParam)

{
    if (lcid == gLCID)
    {
        gLangGroup = langGroupId;
        gFoundLangGroup = TRUE;

        // stop iterating
        return FALSE;
    }

    // next iteration
    return TRUE;
}



////////////////////////////////////////////////////////////////////////////////////
//
//  DetectLanguageGroups
//
//  Detect language groups installed.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL DetectLanguageGroups(HWND hwndDlg)
{
    int i, iItems;
    HWND hwndList = GetDlgItem(hwndDlg, IDC_LIST1);
    HWND hwndProgress, hwndStatus,hProgDlg;
    int iCount = ListView_GetItemCount(hwndList);
    LVITEM lvItem;
    PMUILANGINFO pMuiLangInfo;
    TCHAR szBuf[MAX_PATH], szStatus[MAX_PATH];
    PVOID ppArgs[1];


    hProgDlg = CreateDialog(ghInstance,
                            MAKEINTRESOURCE(IDD_DIALOG_INSTALL_PROGRESS),
                            hwndDlg,
                            ProgressDialogFunc);

    hwndProgress = GetDlgItem(hProgDlg, IDC_PROGRESS1);
    hwndStatus = GetDlgItem(hProgDlg, IDC_STATUS);

    //
    // Reflect that we doing something on the UI
    //
    LoadString(ghInstance, IDS_INSTALLLANGGROUP, szBuf, MAX_PATH-1);
    SetWindowText(hProgDlg, szBuf);
    SendMessage(hwndProgress, PBM_SETRANGE, (WPARAM)(int)0, (LPARAM)MAKELPARAM(0, iCount));
    SendMessage(hwndProgress, PBM_SETPOS, (WPARAM)(int)(0), 0);
    SetWindowText(hwndStatus, TEXT(""));


    i = 0;
    while (i < iCount)
    {
        //
        // Check if Language Group is installed
        //
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.state = 0;
        lvItem.stateMask = 0;
        lvItem.pszText = 0;
        lvItem.cchTextMax = 0;
        lvItem.iImage = 0;
        lvItem.lParam = 0;

        ListView_GetItem(hwndList, &lvItem);

        pMuiLangInfo = (PMUILANGINFO)lvItem.lParam;

        SendMessage(hwndProgress, PBM_SETPOS, (WPARAM)(int)i+1, 0L);

        LoadString(ghInstance, IDS_CHECK_LANG_GROUP, szStatus, MAX_PATH-1);
        if (pMuiLangInfo->szDisplayName[0] == L'\0')
        {
            GetDisplayName(pMuiLangInfo);
        }
        ppArgs[0] = pMuiLangInfo->szDisplayName;
        FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szStatus,
                      0,
                      0,
                      szStatus,
                      MAX_PATH-1,
                      (va_list *)ppArgs);

        SetWindowText(hwndStatus, szStatus);

        pMuiLangInfo->lgrpid = GetLanguageGroup(pMuiLangInfo->lcid);
        i++;
    };

    SendMessage(hwndProgress, PBM_SETPOS, (WPARAM)(int)i+1, 0L);

    DestroyWindow(hProgDlg);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
// AddExtraLangGroupsFromINF
//
//      Look at the [LanguagePack] section to see if we need to install extra
//      language packs for the language specified in lpszLcid.
//
//      This is basically used to support pseudo localized build.
//
//  Parameter:
//      lpszLcid the LCID of UI language to be installed in string form.
//      pInstallLangGroup   points to a strcutre which stores language groups to be installed.
//
//  Remarks:
//
//      10-11-2000  YSLin       Created.
////////////////////////////////////////////////////////////////////////////////////

BOOL AddExtraLangGroupsFromINF(LPTSTR lpszLcid, PINSTALL_LANG_GROUP pInstallLangGroup)
{
    WCHAR szBuffer[BUFFER_SIZE];
    HINF hInf;
    INFCONTEXT InfContext;
    LONG_PTR lppArgs[2];    
    int LangGroup;
    int i;

    hInf = SetupOpenInfFile(g_szMUIInfoFilePath, NULL, INF_STYLE_WIN4, NULL);    
    
    if (hInf == INVALID_HANDLE_VALUE)
    {
        _stprintf(szBuffer, TEXT("%d"), GetLastError());    
        lppArgs[0] = (LONG_PTR)szBuffer;
        LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);
        return (FALSE);
    }

    if (SetupFindFirstLine(hInf, MUI_LANGPACK_SECTION, lpszLcid, &InfContext))
    {
        i = 1;
        while (SetupGetIntField(&InfContext, i++, &LangGroup))
        {
            AddMUILangGroup(pInstallLangGroup, LangGroup);
        }
    }

    SetupCloseInfFile(hInf);
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
// ConvertMUILangToLangGroup
//
//      Generate Lang-Group IDs for the selected items in the listview,
//      in preparation to pass them to InstallLanguageGroups(...)
////////////////////////////////////////////////////////////////////////////////////

BOOL ConvertMUILangToLangGroup(HWND hwndDlg, PINSTALL_LANG_GROUP pInstallLangGroup)
{
    int i;
    LVITEM lvItem;
    HWND hwndList = GetDlgItem(hwndDlg, IDC_LIST1);
    int iCount = ListView_GetItemCount(hwndList);
    PMUILANGINFO pMuiLangInfo;
    BOOL bFirstTime=FALSE;

    //
    // Initialize to "No lang-groups to install"
    //
    pInstallLangGroup->iCount = 0L;

    i = 0;
    while (i < iCount)
    {
        if (ListView_GetCheckState(hwndList, i))
        {
           //
           // Check if Language Group is installed
           //
           lvItem.mask = LVIF_PARAM;
           lvItem.iItem = i;
           lvItem.iSubItem = 0;
           lvItem.state = 0;
           lvItem.stateMask = 0;
           lvItem.pszText = 0;
           lvItem.cchTextMax = 0;
           lvItem.iImage = 0;
           lvItem.lParam = 0;

           ListView_GetItem(hwndList, &lvItem);

           pMuiLangInfo = (PMUILANGINFO)lvItem.lParam;

           //
           // Make sure there are no redundant elements
           //
           AddMUILangGroup(pInstallLangGroup, pMuiLangInfo->lgrpid);

           //
           // Add extra language groups specified in [LangPack] section of mui.inf
           // This is used to support Pesudo Localized Build.           
           //
           AddExtraLangGroupsFromINF(pMuiLangInfo->lpszLcid, pInstallLangGroup);
        }
        i++;
    };

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  AddMUILangGroup
//
//      Add a language a group to INSTALL_LANG_GROUP. Takes care of duplicates.
////////////////////////////////////////////////////////////////////////////////////

BOOL AddMUILangGroup(PINSTALL_LANG_GROUP pInstallLangGroup, LGRPID lgrpid)
{
    int j = 0L;
    BOOL bFound = FALSE;


    //
    // Check if it is installed by default
    //
    if (gpfnIsValidLanguageGroup(lgrpid, LGRPID_INSTALLED))
    {
        return FALSE;
    }

    while (j < pInstallLangGroup->iCount)
    {
        if (pInstallLangGroup->lgrpid[j] == lgrpid)
        {
            bFound = TRUE;
        }

        j++;
    }

    if (!bFound)
    {
        pInstallLangGroup->lgrpid[j] = lgrpid;
        pInstallLangGroup->iCount++;
        return TRUE;
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  RunRegionalOptionsApplet
//
//  Run the Regional Option silent mode installation using the specified pCommands.
//
//  This function will create the "[RegigionalSettings]" string, so there is no need
//  to supply that in pCommands.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL RunRegionalOptionsApplet(LPTSTR pCommands)
{
    HANDLE hFile;
    TCHAR szFilePath[MAX_PATH], szCmdLine[MAX_PATH];
    DWORD dwNumWritten = 0L;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    int i;

    LONG_PTR lppArgs[3];
    
    TCHAR szSection[MAX_PATH] = TEXT("[RegionalSettings]\r\n");

    //
    // prepare the file for un-attended mode setup
    //
    szFilePath[0] = UNICODE_NULL;
    if (!pfnGetWindowsDir(szFilePath, MAX_PATH-1))
    {
        return FALSE;
    }

    i = lstrlen(szFilePath);
    if (szFilePath[i-1] != TEXT('\\'))
    {
        lstrcat(szFilePath, TEXT("\\"));
    }
    lstrcat(szFilePath, MUI_LANG_GROUP_FILE);

    hFile = CreateFile(szFilePath,
                       GENERIC_WRITE,
                       0L,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        lppArgs[0] = (LONG_PTR)szFilePath;
        LogFormattedMessage(ghInstance, IDS_ERROR_FILE_CREATE, lppArgs);
        return FALSE;
    }

    WriteFile(hFile,
              szSection,
              (lstrlen(szSection) * sizeof(TCHAR)),
              &dwNumWritten,
              NULL);

    if (dwNumWritten != (lstrlen(szSection) * sizeof(TCHAR)))
    {
        lppArgs[0] = (LONG_PTR)szFilePath;
        LogFormattedMessage(ghInstance, IDS_ERROR_FILE_CREATE, lppArgs);
        CloseHandle(hFile);
        return FALSE;
    }

    WriteFile(hFile,
               pCommands,
              (lstrlen(pCommands) * sizeof(TCHAR)),
              &dwNumWritten,
              NULL);

    if (dwNumWritten != (lstrlen(pCommands) * sizeof(TCHAR)))
    {
#if SAMER_DBG
        OutputDebugString(TEXT("Unable to write to Language Groups to muilang.txt\n"));
#endif
        CloseHandle(hFile);
        return (FALSE);
    }

    CloseHandle(hFile);

    //
    // Call the control panel regional-options applet, and wait for it to complete
    //
    lstrcpy(szCmdLine, TEXT("rundll32 shell32,Control_RunDLL intl.cpl,, /f:\""));

    lstrcat(szCmdLine, szFilePath);
    if (g_bCmdMatchUIFont)
        lstrcat(szCmdLine, TEXT("\"/g/t"));
    else
        lstrcat(szCmdLine, TEXT("\"/g"));

    memset( &si, 0x00, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    if (!CreateProcess(NULL,
                       szCmdLine,
                       NULL,
                       NULL,
                       FALSE,
                       0L,
                       NULL,
                       NULL,
                       &si,
                       &pi))
    {
        lppArgs[0] = (LONG_PTR)szCmdLine;
        LogFormattedMessage(ghInstance, IDS_ERROR_LAUNCH_INTLCPL, lppArgs);
        return FALSE;
    }

    //
    // Wait forever till intl.cpl terminates.
    //
    WaitForSingleObject(pi.hProcess, INFINITE);

    //
    // Delete the File
    //
    DeleteFile(szFilePath);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////////////
//
//  InstallLanguageGroups
//
//  Checks whether a language group is needed to be installed or not. If
//      any lang-group needs to be installed, then the routine will invoke
//      the Regional-Options applet in unattended mode setup.
//
//  Return:
//      TURE if the operation succeeds.  Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL InstallLanguageGroups(PINSTALL_LANG_GROUP pInstallLangGroup)
{
    TCHAR pCommands[MAX_PATH];
    int i, iCount = pInstallLangGroup->iCount;
    BOOL bFirstTime=FALSE;

    //
    // If nothing to do, then just return
    //
    if (0L == iCount)
    {
        return TRUE;
    }

    i = 0;
    while (i < iCount)
    {
        if (!gpfnIsValidLanguageGroup(pInstallLangGroup->lgrpid[i], LGRPID_INSTALLED))
        {
            if (!bFirstTime)
            {
                bFirstTime = TRUE;
                wsprintf(pCommands, TEXT("LanguageGroup = %d\0"), pInstallLangGroup->lgrpid[i]);
            }
            else
            {
                wsprintf(&pCommands[lstrlen(pCommands)], TEXT(",%d\0"), pInstallLangGroup->lgrpid[i]);
            }
        }
        i++;
    };

    if (!bFirstTime)
    {
        //
        // There is no language group to be added.
        return (FALSE);        
    }

    return (RunRegionalOptionsApplet(pCommands));
}


////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_RebootTheSystem
//
//  This routine enables all privileges in the token, calls ExitWindowsEx
//  to reboot the system, and then resets all of the privileges to their
//  old state.
//
////////////////////////////////////////////////////////////////////////////

void Muisetup_RebootTheSystem(void)
{
    HANDLE Token = NULL;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState = NULL;
    PTOKEN_PRIVILEGES OldState = NULL;
    BOOL Result;

    Result = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &Token );
    if (Result)
    {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        OldState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        Result = (BOOL)((NewState != NULL) && (OldState != NULL));
        if (Result)
        {
            Result = GetTokenInformation( Token,            // TokenHandle
                                          TokenPrivileges,  // TokenInformationClass
                                          NewState,         // TokenInformation
                                          ReturnLength,     // TokenInformationLength
                                          &ReturnLength );  // ReturnLength
            if (Result)
            {
                //
                // Set the state settings so that all privileges are enabled...
                //
                if (NewState->PrivilegeCount > 0)
                {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++)
                    {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                Result = AdjustTokenPrivileges( Token,           // TokenHandle
                                                FALSE,           // DisableAllPrivileges
                                                NewState,        // NewState
                                                ReturnLength,    // BufferLength
                                                OldState,        // PreviousState
                                                &ReturnLength ); // ReturnLength
                if (Result)
                {
                    ExitWindowsEx(EWX_REBOOT, 0);


                    AdjustTokenPrivileges( Token,
                                           FALSE,
                                           OldState,
                                           0,
                                           NULL,
                                           NULL );
                }
            }
        }
    }

    if (NewState != NULL)
    {
        LocalFree(NewState);
    }
    if (OldState != NULL)
    {
        LocalFree(OldState);
    }
    if (Token != NULL)
    {
        CloseHandle(Token);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckForReboot
//
//  Check if we need to reboot the system, if a lang group is installed
//
//  Return:
//  TRUE if we need user to reboot, otherwise FALSE.   
//
////////////////////////////////////////////////////////////////////////////

BOOL CheckForReboot(HWND hwnd, PINSTALL_LANG_GROUP pInstallLangGroup)
{
    int nIDS,nMask=MB_YESNO | MB_ICONQUESTION;

    if (pInstallLangGroup->iCount || pInstallLangGroup->bFontLinkRegistryTouched || pInstallLangGroup->NotDeleted 
        || g_bRemoveDefaultUI || g_bRemoveUserUI || g_bReboot)
    {
        if (g_bRemoveUserUI)
        {
           nIDS=IDS_MUST_REBOOT_STRING1;
           nMask=MB_YESNO | MB_ICONWARNING;
        }
        else if (g_bRemoveDefaultUI)
        {
            nMask=MB_YESNO | MB_ICONWARNING;
            nIDS=IDS_MUST_REBOOT_STRING2;
        }
        else
        {
           nIDS=IDS_REBOOT_STRING;
        }
         
        if (DoMessageBox(hwnd, nIDS, IDS_MAIN_TITLE, nMask) == IDYES)
        {
           Muisetup_RebootTheSystem();
        }
        return (TRUE);
    }
    return (FALSE);
}

////////////////////////////////////////////////////////////////////////////
//
// Following code are stolen from intl.cpl
//
// We want to enumulate all installed UI languages
//
////////////////////////////////////////////////////////////////////////////
DWORD_PTR TransNum(
    LPTSTR lpsz)
{
    DWORD dw = 0L;
    TCHAR c;

    while (*lpsz)
    {
        c = *lpsz++;

        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return (dw);
}

BOOL MUIGetAllInstalledUILanguages()
{
    pfnEnumUILanguages fnEnumUILanguages;
    BOOL result = TRUE;
    HINSTANCE hKernel32;
    //
    //  Enumerate the installed UI languages.
    //
    g_UILanguageGroup.iCount = 0L;


    hKernel32 = LoadLibrary(TEXT("kernel32.dll"));
    fnEnumUILanguages = (pfnEnumUILanguages)GetProcAddress(hKernel32, "EnumUILanguagesW");
    if (fnEnumUILanguages == NULL) 
    {
        result = FALSE;
    } else
    {
        fnEnumUILanguages(Region_EnumUILanguagesProc, 0, (LONG_PTR)&g_UILanguageGroup);
    }
    FreeLibrary(hKernel32);
    return (result);
}

BOOL CALLBACK Region_EnumUILanguagesProc(
    LPWSTR pwszUILanguage,
    LONG_PTR lParam)
{
    int Ctr = 0;
    LGRPID lgrp;
    PUILANGUAGEGROUP pUILangGroup = (PUILANGUAGEGROUP)lParam;
    LCID UILanguage = (LCID)TransNum( pwszUILanguage );

    if (UILanguage)
    {
        while (Ctr < pUILangGroup->iCount)
        {
            if (pUILangGroup->lcid[Ctr] == UILanguage)
            {
                break;
            }
            Ctr++;
        }

        //
        //  Theoritically, we won't go over 64 language groups!
        //
        if ((Ctr == pUILangGroup->iCount) && (Ctr < MAX_UI_LANG_GROUPS))
        {
            pUILangGroup->lcid[Ctr] = UILanguage;
            pUILangGroup->iCount++;
        }
    }

    return (TRUE);
}

BOOL IsSpaceEnough(HWND hwndDlg,INT64 *ulSizeNeed,INT64 *ulSizeAvailable)
{
    
    HWND    hList; 
    LGRPID lgrpid[MAX_MUI_LANGUAGES];
    LPTSTR lpszLcid;
    int    iIndex;
    int    i = 0;
    int    iCount=0,iArrayIndex=0;
    PMUILANGINFO pMuiLangInfo;
    BOOL   bChked,bResult=TRUE;
    INT64  ulTotalBytesRequired=0,ulSpaceAvailable;
    TCHAR  szWinDir[MAX_PATH];
    BOOL   bFELangpackAdded = FALSE;
    
    ULARGE_INTEGER ulgiFreeBytesAvailableToCaller;
    ULARGE_INTEGER ulgiTotalNumberOfBytes;

     *ulSizeNeed=0; 
    *ulSizeAvailable=0;
    hList=GetDlgItem(hwndDlg, IDC_LIST1);

    iIndex = ListView_GetItemCount(hList);   
       
    while(i<iIndex)
    {
        bChked=ListView_GetCheckState(hList, i);
        GetMuiLangInfoFromListView(hList, i, &pMuiLangInfo);        
        lpszLcid = pMuiLangInfo->lpszLcid;
        //
        // Install required
        //
        if (bChked && !IsInstalled(lpszLcid) && HaveFiles(lpszLcid))
        {
           if (!gpfnIsValidLanguageGroup(pMuiLangInfo->lgrpid, LGRPID_INSTALLED))
           {

              for(iArrayIndex=0;iArrayIndex < iCount;iArrayIndex++)
              {
                 if (lgrpid[iArrayIndex]==pMuiLangInfo->lgrpid)
                    break;
              }
              if(iArrayIndex == iCount)
              {  
                 if (IS_FE_LANGPACK(pMuiLangInfo->lcid))
                 {
                    if (!bFELangpackAdded)
                    {
                        ulTotalBytesRequired+=pMuiLangInfo->ulLPKSize;
                        bFELangpackAdded = TRUE;
                    }
                 }
                 else
                 {
                    ulTotalBytesRequired+=pMuiLangInfo->ulLPKSize;
                 }
                 lgrpid[iCount]= pMuiLangInfo->lgrpid;
                 iCount++;
              }

           }
           ulTotalBytesRequired+=pMuiLangInfo->ulUISize;
        }
        // Uninstall required
        if (!bChked && IsInstalled(lpszLcid))
        {
           ulTotalBytesRequired-=pMuiLangInfo->ulUISize;
        } 
        i++;
    }
    //
    // Let's check available disk space of system drive
    //
    pfnGetWindowsDir( szWinDir, MAX_PATH);
    szWinDir[3]=TEXT('\0');
    if (GetDiskFreeSpaceEx(szWinDir,
                       &ulgiFreeBytesAvailableToCaller,
                       &ulgiTotalNumberOfBytes,
                       NULL))
    {
       ulSpaceAvailable= ulgiFreeBytesAvailableToCaller.QuadPart;
       if ( ulSpaceAvailable <  ulTotalBytesRequired )
       {
          *ulSizeNeed =ulTotalBytesRequired;
          *ulSizeAvailable=ulSpaceAvailable;  
          bResult=FALSE;
       }
       
    } 

    return bResult;
}

void ExitFromOutOfMemory()
{
    LONG_PTR lppArgs[1];

    lppArgs[0] = (LONG_PTR)GetLastError();

    DoMessageBox(NULL, IDS_OUT_OF_MEMORY, IDS_MAIN_TITLE, MB_ICONEXCLAMATION | MB_OK);
    LogFormattedMessage(ghInstance, IDS_OUT_OF_MEMORY_L, lppArgs);
    
    ExitProcess(1);
}


////////////////////////////////////////////////////////////////////////////
//
// Call the kernel to notify it that a new language is being added or
// removed
//
////////////////////////////////////////////////////////////////////////////
void NotifyKernel(
    LPTSTR LangList,
    ULONG Flags
    )
{
    HANDLE Handle;
    WMILANGUAGECHANGE LanguageChange;
    ULONG ReturnSize;
    BOOL IoctlSuccess;
    ULONG Status;

    if ((LangList != NULL) &&
        (*LangList != 0))
    {
        Handle = CreateFile(WMIDataDeviceName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if (Handle != INVALID_HANDLE_VALUE)
        {

            while (*LangList != 0)
            {
                memset(&LanguageChange, 0, sizeof(LanguageChange));
                _tcscpy(LanguageChange.Language, LangList);
                LanguageChange.Flags = Flags;

                IoctlSuccess = DeviceIoControl(Handle,
                                          IOCTL_WMI_NOTIFY_LANGUAGE_CHANGE,
                                          &LanguageChange,
                                          sizeof(LanguageChange),
                                          NULL,
                                          0,
                                          &ReturnSize,
                                          NULL);

#if ALANWAR_DBG
                {
                    WCHAR Buf[256];
                    wsprintf(Buf, L"MUISetup: Notify Lang change -> %d for %ws\n",
                             GetLastError(), LangList);
                    OutputDebugStringW(Buf);
                }
#endif              

                while (*LangList++ != 0) ;
            }

            CloseHandle(Handle);
        }
    }
}


//
// Query MUI registry setting
//
BOOL CheckMUIRegSetting(DWORD dwFlag)
{
    BOOL bRet = FALSE;
    HKEY hKey;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_MUI_SETTING, 0, KEY_READ, &hKey))
    {
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        DWORD dwType;

        if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, 
                (dwFlag & MUI_MATCH_UIFONT)? REGSTR_VALUE_MATCH_UIFONT : REGSTR_VALUE_MATCH_LOCALE, 
                0, &dwType, (LPBYTE)&dwValue, &dwSize))
        {
            bRet = (BOOL) dwValue;
        }

        RegCloseKey(hKey);
    }         
    
    return bRet;
}


//
// Set MUI registry setting
//
BOOL SetMUIRegSetting(DWORD dwFlag, BOOL bEnable)
{
    BOOL bRet = FALSE;
    HKEY hKey;    

    if (ERROR_SUCCESS  ==
        RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_MUI_SETTING, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, &hKey, NULL))
    {
        DWORD dwValue = (DWORD) bEnable;

        if (ERROR_SUCCESS ==
            RegSetValueEx(hKey, 
                (dwFlag & MUI_MATCH_UIFONT)? REGSTR_VALUE_MATCH_UIFONT : REGSTR_VALUE_MATCH_LOCALE, 
                0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD)))
        {
            bRet = TRUE;
        }

        RegCloseKey(hKey);
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  DeleteRegTree
//
//  This deletes all subkeys under a specific key.
//
//  Note: The code makes no attempt to check or recover from partial
//  deletions.
//
//  A registry key that is opened by an application can be deleted
//  without error by another application.  This is by design.
//
////////////////////////////////////////////////////////////////////////////

DWORD DeleteRegTree(
    HKEY hStartKey,
    LPTSTR pKeyName)
{
    DWORD dwRtn, dwSubKeyLength;
    LPTSTR pSubKey = NULL;
    TCHAR szSubKey[REGSTR_MAX_VALUE_LENGTH];   // (256) this should be dynamic.
    HKEY hKey;

    //
    //  Do not allow NULL or empty key name.
    //
    if (pKeyName && lstrlen(pKeyName))
    {
        if ((dwRtn = RegOpenKeyEx( hStartKey,
                                   pKeyName,
                                   0,
                                   KEY_ENUMERATE_SUB_KEYS | DELETE,
                                   &hKey )) == ERROR_SUCCESS)
        {
            while (dwRtn == ERROR_SUCCESS)
            {
                dwSubKeyLength = REGSTR_MAX_VALUE_LENGTH;
                dwRtn = RegEnumKeyEx( hKey,
                                      0,       // always index zero
                                      szSubKey,
                                      &dwSubKeyLength,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL );

                if (dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = RegDeleteKey(hStartKey, pKeyName);
                    break;
                }
                else if (dwRtn == ERROR_SUCCESS)
                {
                    dwRtn = DeleteRegTree(hKey, szSubKey);
                }
            }

            RegCloseKey(hKey);
        }
        else if (dwRtn == ERROR_FILE_NOT_FOUND)
        {
            dwRtn = ERROR_SUCCESS;
        }
    }
    else
    {
        dwRtn = ERROR_BADKEY;
    }

    return (dwRtn);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  InstallExternalComponents
//
//
//  Return:
//      TURE if the operation succeeds. Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL InstallExternalComponents(LPTSTR Languages)
{
    BOOL    bRet = TRUE;
    TCHAR   lpMessage[BUFFER_SIZE];

    //
    // call WBEM API to mofcompile MUI MFL's for each language
    //
    if (!MofCompileLanguages(Languages))
    {
        //
        // LOG: Error mofcompiling
        //
        LoadString(ghInstance, IDS_MOFCOMPILE_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        bRet = FALSE;
    }

    if (bRet)
    {    
        //
        // Inform kernel that new languages have been added
        //
        NotifyKernel(Languages,
                     WMILANGUAGECHANGE_FLAG_ADDED);
    }

    return bRet;

}

////////////////////////////////////////////////////////////////////////////////////
//
//  UninstallExternalComponents
//
////////////////////////////////////////////////////////////////////////////////////
VOID UninstallExternalComponents(LPTSTR Languages)
{

    //
    // Inform kernel that new languages have been added
    //
    NotifyKernel(Languages,
                 WMILANGUAGECHANGE_FLAG_REMOVED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muisetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by muisetup.rc
//
#define MUI_ICON                        1
#define IDS_WRONG_VERSION               3
#define IDS_SUCCESS                     4
#define IDS_COMPLETE_T                  5
#define IDS_ERROR                       6
#define IDS_NO_LANG_L                   7
#define IDS_INVALID_DEFAULT             9
#define IDS_DEFAULT_T                   10
#define IDS_NO_SUPPORT_T                11
#define IDS_NO_SUPPORT                  12
#define IDS_DIRECTORY_L                 13
#define IDS_COPY_L                      14
#define IDS_REGISTRY_L                  15
#define IDS_DELETE_L                    16
#define IDS_WAS_NOT_INSTALLED_L         17
#define IDS_IS_INSTALLED_L              18
#define IDS_NOT_LISTED_L                19
#define IDS_WAS_NOT_UNINSTALLED_L       20
#define IDS_IS_NOT_INSTALLED_L          21
#define IDS_ADMIN_L                     22
#define IDS_NO_SUPPORT_L                23
#define IDS_DEFAULT_L                   24
#define IDS_SUCCESS_L                   25
#define IDS_LOG_HEAD                    26
#define IDS_NO_READ_L                   27
#define IDS_HANDLE_L                    28
#define IDS_PROCADD_L                   29
#define IDS_COPYFILE_L                  30
#define IDS_MAKEDIR_L                   31
#define IDS_NO_CHECK_L                  32
#define IDS_CREATEDIR_L                 33
#define IDS_INSTALLING                  34
#define IDS_UNINSTALLING                35
#define IDS_SETTING                     36
#define IDS_HELP_T                      37
#define IDS_HELP                        38
#define IDS_INSTALLLANGGROUP            39
#define IDS_CHECK_LANG_GROUP            40
#define IDS_ERROR_FILE_CREATE           41
#define IDS_ERROR_LAUNCH_INTLCPL        42
#define IDS_MAIN_TITLE                  43
#define IDS_ALREADY_RUNNING             44
#define IDS_APP                         45
#define IDS_ERROR_NT5_ONLY              46
#define IDS_REBOOT_STRING               47
#define IDS_CHANGE_UI_LANG              48
#define IDS_DEFAULT_USER_ERROR          49
#define IDS_ERROR_INSTALL_COMP_UI       50
#define IDS_ERROR_SETUP_COMP_UI         51
#define IDS_INSTALLING_COMP_MUI         52
#define IDS_REMOVING_COMP_MUI           53
#define IDS_MUI_CHS                     54
#define IDS_MUI_CHT                     55
#define IDS_LG_NOT_INSTALL              56
#define IDS_CHANGE_CDROM                57     
#define IDS_INSTALL_TITLE               58
#define IDS_PROG_TITLE_2                59
#define IDS_IS_TSCLIENT                 60
#define IDS_SUCCESS_UNINSTALL           61
#define IDS_COMPLETE_T_UNINSTALL        62
#define IDS_WRONG_NTAS                  63
#define IDS_NOT_QUALIFIED_L             64
#define IDS_CHANGE_CDROM2               66
#define IDS_DISKSPACE_NOTENOUGH         68
#define IDS_ERROR_DISKSPACE             69
#define IDS_MUST_REBOOT_STRING1         70
#define IDS_NO_MUI_FILE                 71
#define IDS_HELPFILE                    72
#define IDS_ERROR_T                     73
#define IDS_COMP_MISSING_NAME_L         75
#define IDS_COMP_MISSING_DIR_L          76
#define IDS_COMP_MISSING_INF_L          77
#define IDS_COMP_MISSING_INF_FILE_L     78
#define IDS_COMP_COPY_FILES_ERROR_L     79
#define IDS_COMP_INSTALL_ERROR_L        80
#define IDS_OUT_OF_MEMORY               81
#define IDS_OUT_OF_MEMORY_L             82
#define IDS_LOAD_ADVPACK_L              83
#define IDS_LOAD_ADVPACK_API_L          84
#define IDS_PROG_TITLE_3                85
#define IDS_WRONG_IMAGE                 86  
#define IDS_ADMIN                       87
#define IDS_UNINSTALL_TITLE             88
#define IDS_ERROR_NO_LANG_ARG           89
#define IDS_MUISETUP_SUCCESS            90
#define IDS_COMMAND_LOG                 91
#define IDS_LANG_INSTALLED              92
#define IDS_LANG_UNINSTALLED            93
#define IDS_SET_UILANG_CURRENT          94
#define IDS_ERROR_SET_UILANG_CURRENT    95
#define IDS_SET_UILANG_ALLUSERS         96
#define IDS_ERROR_SET_UILANG_ALLUSERS   97
#define IDS_CHANGE_UI_NEED_RBOOT        98
#define IDS_NO_MUI_LANG                 99
#define IDS_CHANGE_UI_NEED_RBOOT_SYSTEM_LCID    100
#define IDS_LANG_IN_ANOTHER_CD_L        101
#define IDS_MUST_REBOOT_STRING2         102
#define IDS_MOFCOMPILE_L                103
#define IDS_MOFCOMPILE_LANG_L           104
#define IDS_LG_NOT_INSTALL_L            105
#define IDS_MUISETUP_UNINSTALL_SUCCESS  106
#define IDS_ERROR_UNINSTALL_COMP_UI     107
#define IDS_CANCEL_INSTALLATION         108

//
// Dialogs
//

#define IDD_DIALOG_MAIN                 102
#define IDD_DIALOG_INSTALL_PROGRESS     105
#define IDD_DIALOG_PROGRESS_LG          106
#define IDD_WELCOME                     107

#define IDC_DEF_UI_LANG_COMBO                      1001
#define IDC_LIST1                       1002
#define IDC_LIST6                       1010
#define IDC_LIST2                       1013
#define IDC_PROGRESS1                   1016
#define IDC_STATUS                      1022
#define IDC_WELCOME_LINE                1023
#define IDC_EDIT_LICENSE                1024
#define IDC_CHECK_LICENSE               1025
#define IDC_README                      1027
#define IDC_CHECK_LOCALE                1028
#define IDC_CHECK_UIFONT                1029
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\muisetup\welcome.cpp ===
#include "muisetup.h"
#include <shlwapi.h>
#include <shellapi.h>


#define README_FILENAME TEXT("README.TXT")
#define EULA_FILENAME   TEXT("EULA.TXT")

BOOL g_bLicenseAccepted;


INT_PTR 
CALLBACK
WelcomeDialogProc(HWND   hWndDlg, UINT   uMsg, WPARAM wParam, LPARAM lParam)
{ 
    HANDLE hFile;
    DWORD  dwFileSize;
    DWORD  dwActual;
    LPVOID pFileBuffer; 
    TCHAR   szEulaPath[MAX_PATH];

    switch ( uMsg ) {

        case WM_INITDIALOG:

            //
            // Load EULA file from the path where MUISETUP was lunched
            //
            GetModuleFileName( NULL, szEulaPath, ARRAYSIZE( szEulaPath ));

            lstrcpy(StrRChrI(szEulaPath, NULL, TEXT('\\'))+1, EULA_FILENAME);

            hFile = CreateFile(
                        szEulaPath,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                dwFileSize = GetFileSize( hFile, NULL );

                if ( dwFileSize != -1 ) {

                    pFileBuffer = LocalAlloc(LPTR, dwFileSize + 1 );

                    if ( pFileBuffer ) {

                        if ( ReadFile( hFile, pFileBuffer, dwFileSize, &dwActual, NULL )) {

                            //
                            // Make sure to NULL terminate the string
                            //
                            *((PCHAR)((PCHAR)pFileBuffer + dwFileSize)) = 0x00;

                            //
                            // Use ANSI text
                            //
                            SetDlgItemTextA( hWndDlg, IDC_EDIT_LICENSE, (LPCSTR)pFileBuffer );
                            }

                        LocalFree( pFileBuffer );
                        }
                    }
                }
            SetFocus( GetDlgItem( hWndDlg, IDC_CHECK_LICENSE ));
            return 0;

        case WM_COMMAND:

            switch ( LOWORD( wParam )) 
            {
                case IDOK:
                    g_bLicenseAccepted = ( IsDlgButtonChecked( hWndDlg, IDC_CHECK_LICENSE ) == BST_CHECKED );
                    EndDialog( hWndDlg, 0 );
                    return 1;

                case IDCANCEL:
                    EndDialog( hWndDlg, ERROR_CANCELLED );
                    return 1;

                case IDC_README:
                    {
                        // invoke notepad.exe open readme.txt
                        TCHAR szReadMePath[MAX_PATH];
                        SHELLEXECUTEINFO ExecInfo = {0};                        

                        GetModuleFileName(NULL, szReadMePath, sizeof(szReadMePath)/sizeof(TCHAR));
                        lstrcpy(StrRChrI(szReadMePath, NULL, TEXT('\\'))+1, README_FILENAME);
                        
                        ExecInfo.lpParameters    = szReadMePath;
                        ExecInfo.lpFile          = TEXT("NOTEPAD.EXE");
                        ExecInfo.nShow           = SW_SHOWNORMAL;
                        ExecInfo.cbSize          = sizeof(SHELLEXECUTEINFO);                 
                        ShellExecuteEx(&ExecInfo);
                    }
                    return 1;

                case IDC_CHECK_LICENSE:
                    EnableWindow( GetDlgItem( hWndDlg, IDOK ), IsDlgButtonChecked( hWndDlg, IDC_CHECK_LICENSE ) == BST_CHECKED );
                    return 1;

            }
            break;

        case WM_CLOSE:
            EndDialog( hWndDlg, ERROR_CANCELLED );
            return 1;

        }

    return 0;
}


BOOL
WelcomeDialog(HWND hWndParent)
{
    INT_PTR Status;

    Status = DialogBox(
                 NULL,
                 MAKEINTRESOURCE( IDD_WELCOME ),
                 hWndParent,
                 WelcomeDialogProc
                 );

    return (( Status == ERROR_SUCCESS ) && ( g_bLicenseAccepted ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\msi\wival.inc ===
'<script language='VBScript'>
' wival.inc - Windows Installer _Validation table definitions
'
'  6/9/2001 13:34:56 - created - val.wsf (tool by robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    AddValidation
'

Dim val_dicValidation : Set val_dicValidation = CreateObject("Scripting.Dictionary")
Dim val__Validation(9)
val__Validation(0) = "'_Validation'&&'Table'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of table'"
val__Validation(1) = "'_Validation'&&'Column'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of column'"
val__Validation(2) = "'_Validation'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Description of column'"
val__Validation(3) = "'_Validation'&&'Set'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Set of values that are permitted'"
val__Validation(4) = "'_Validation'&&'Category'&&'Y'&&''&&''&&''&&''&&''&&'Text;Formatted;Template;Condition;Guid;Path;Version;Language;Identifier;Binary;UpperCase;LowerCase;Filename;Paths;AnyPath;WildCardFilename;RegPath;KeyFormatted;CustomSource;Property;Cabinet;Shortcut;URL'&&'String category'"
val__Validation(5) = "'_Validation'&&'KeyColumn'&&'Y'&&'1'&&'32'&&''&&''&&''&&''&&'Column to which foreign key connects'"
val__Validation(6) = "'_Validation'&&'KeyTable'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'For foreign key, Name of table to which data must link'"
val__Validation(7) = "'_Validation'&&'MaxValue'&&'Y'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Maximum value allowed'"
val__Validation(8) = "'_Validation'&&'MinValue'&&'Y'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Minimum value allowed'"
val__Validation(9) = "'_Validation'&&'Nullable'&&'N'&&''&&''&&''&&''&&''&&'Y;N;@'&&'Whether the column is nullable'"
val_dicValidation.Add "_Validation", val__Validation

Dim val_ActionText(2)
val_ActionText(0) = "'ActionText'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Localized description displayed in progress dialog and log when action is executing.'"
val_ActionText(1) = "'ActionText'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to be described.'"
val_ActionText(2) = "'ActionText'&&'Template'&&'Y'&&''&&''&&''&&''&&'Template'&&''&&'Optional localized format template used to format action data records for display during action execution.'"
val_dicValidation.Add "ActionText", val_ActionText

Dim val_AdminExecuteSequence(2)
val_AdminExecuteSequence(0) = "'AdminExecuteSequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_AdminExecuteSequence(1) = "'AdminExecuteSequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_AdminExecuteSequence(2) = "'AdminExecuteSequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "AdminExecuteSequence", val_AdminExecuteSequence

Dim val_Condition(2)
val_Condition(0) = "'Condition'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Expression evaluated to determine if Level in the Feature table is to change.'"
val_Condition(1) = "'Condition'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Reference to a Feature entry in Feature table.'"
val_Condition(2) = "'Condition'&&'Level'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'New selection Level to set in Feature table if Condition evaluates to TRUE.'"
val_dicValidation.Add "Condition", val_Condition

Dim val_AdminUISequence(2)
val_AdminUISequence(0) = "'AdminUISequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_AdminUISequence(1) = "'AdminUISequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_AdminUISequence(2) = "'AdminUISequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "AdminUISequence", val_AdminUISequence

Dim val_AdvtExecuteSequence(2)
val_AdvtExecuteSequence(0) = "'AdvtExecuteSequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_AdvtExecuteSequence(1) = "'AdvtExecuteSequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_AdvtExecuteSequence(2) = "'AdvtExecuteSequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "AdvtExecuteSequence", val_AdvtExecuteSequence

Dim val_AdvtUISequence(2)
val_AdvtUISequence(0) = "'AdvtUISequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_AdvtUISequence(1) = "'AdvtUISequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_AdvtUISequence(2) = "'AdvtUISequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "AdvtUISequence", val_AdvtUISequence

Dim val_AppId(6)
val_AppId(0) = "'AppId'&&'AppId'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&''"
val_AppId(1) = "'AppId'&&'ActivateAtStorage'&&'Y'&&'0'&&'1'&&''&&''&&''&&''&&''"
val_AppId(2) = "'AppId'&&'DllSurrogate'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&''"
val_AppId(3) = "'AppId'&&'LocalService'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&''"
val_AppId(4) = "'AppId'&&'RemoteServerName'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&''"
val_AppId(5) = "'AppId'&&'RunAsInteractiveUser'&&'Y'&&'0'&&'1'&&''&&''&&''&&''&&''"
val_AppId(6) = "'AppId'&&'ServiceParameters'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&''"
val_dicValidation.Add "AppId", val_AppId

Dim val_AppSearch(1)
val_AppSearch(0) = "'AppSearch'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The property associated with a Signature'"
val_AppSearch(1) = "'AppSearch'&&'Signature_'&&'N'&&''&&''&&'Signature;RegLocator;IniLocator;DrLocator;CompLocator'&&'1'&&'Identifier'&&''&&'The Signature_ represents a unique file signature and is also the foreign key in the Signature,  RegLocator, IniLocator, CompLocator and the DrLocator tables.'"
val_dicValidation.Add "AppSearch", val_AppSearch

Dim val_Property(1)
val_Property(0) = "'Property'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of property, uppercase if settable by launcher or loader.'"
val_Property(1) = "'Property'&&'Value'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'String value for property.  Never null or empty.'"
val_dicValidation.Add "Property", val_Property

Dim val_BBControl(8)
val_BBControl(0) = "'BBControl'&&'Type'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The type of the control.'"
val_BBControl(1) = "'BBControl'&&'Y'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Vertical coordinate of the upper left corner of the bounding rectangle of the control.'"
val_BBControl(2) = "'BBControl'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'A string used to set the initial text contained within a control (if appropriate).'"
val_BBControl(3) = "'BBControl'&&'BBControl'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the control. This name must be unique within a billboard, but can repeat on different billboard.'"
val_BBControl(4) = "'BBControl'&&'Attributes'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'A 32-bit word that specifies the attribute flags to be applied to this control.'"
val_BBControl(5) = "'BBControl'&&'Billboard_'&&'N'&&''&&''&&'Billboard'&&'1'&&'Identifier'&&''&&'External key to the Billboard table, name of the billboard.'"
val_BBControl(6) = "'BBControl'&&'Height'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Height of the bounding rectangle of the control.'"
val_BBControl(7) = "'BBControl'&&'Width'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Width of the bounding rectangle of the control.'"
val_BBControl(8) = "'BBControl'&&'X'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Horizontal coordinate of the upper left corner of the bounding rectangle of the control.'"
val_dicValidation.Add "BBControl", val_BBControl

Dim val_Billboard(3)
val_Billboard(0) = "'Billboard'&&'Action'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'The name of an action. The billboard is displayed during the progress messages received from this action.'"
val_Billboard(1) = "'Billboard'&&'Billboard'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the billboard.'"
val_Billboard(2) = "'Billboard'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'An external key to the Feature Table. The billboard is shown only if this feature is being installed.'"
val_Billboard(3) = "'Billboard'&&'Ordering'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'A positive integer. If there is more than one billboard corresponding to an action they will be shown in the order defined by this column.'"
val_dicValidation.Add "Billboard", val_Billboard

Dim val_Feature(7)
val_Feature(0) = "'Feature'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Longer descriptive text describing a visible feature item.'"
val_Feature(1) = "'Feature'&&'Attributes'&&'N'&&''&&''&&''&&''&&''&&'0;1;2;4;5;6;8;9;10;16;17;18;20;21;22;24;25;26;32;33;34;36;37;38;48;49;50;52;53;54'&&'Feature attributes'"
val_Feature(2) = "'Feature'&&'Feature'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key used to identify a particular feature record.'"
val_Feature(3) = "'Feature'&&'Directory_'&&'Y'&&''&&''&&'Directory'&&'1'&&'UpperCase'&&''&&'The name of the Directory that can be configured by the UI. A non-null value will enable the browse button.'"
val_Feature(4) = "'Feature'&&'Level'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The install level at which record will be initially selected. An install level of 0 will disable an item and prevent its display.'"
val_Feature(5) = "'Feature'&&'Title'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Short text identifying a visible feature item.'"
val_Feature(6) = "'Feature'&&'Display'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'Numeric sort order, used to force a specific display ordering.'"
val_Feature(7) = "'Feature'&&'Feature_Parent'&&'Y'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Optional key of a parent record in the same table. If the parent is not selected, then the record will not be installed. Null indicates a root item.'"
val_dicValidation.Add "Feature", val_Feature

Dim val_Binary(1)
val_Binary(0) = "'Binary'&&'Name'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Unique key identifying the binary data.'"
val_Binary(1) = "'Binary'&&'Data'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'The unformatted binary data.'"
val_dicValidation.Add "Binary", val_Binary

Dim val_BindImage(1)
val_BindImage(0) = "'BindImage'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'The index into the File table. This must be an executable file.'"
val_BindImage(1) = "'BindImage'&&'Path'&&'Y'&&''&&''&&''&&''&&'Paths'&&''&&'A list of ;  delimited paths that represent the paths to be searched for the import DLLS. The list is usually a list of properties each enclosed within square brackets [] .'"
val_dicValidation.Add "BindImage", val_BindImage

Dim val_File(7)
val_File(0) = "'File'&&'Sequence'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'Sequence with respect to the media images; order must track cabinet order.'"
val_File(1) = "'File'&&'Attributes'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'Integer containing bit flags representing file attributes (with the decimal value of each bit position in parentheses)'"
val_File(2) = "'File'&&'File'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token, must match identifier in cabinet.  For uncompressed files, this field is ignored.'"
val_File(3) = "'File'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key referencing Component that controls the file.'"
val_File(4) = "'File'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'File name used for installation, may be localized.  This may contain a ""short name|long name"" pair.'"
val_File(5) = "'File'&&'FileSize'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_File(6) = "'File'&&'Language'&&'Y'&&''&&''&&''&&''&&'Language'&&''&&'List of decimal language Ids, comma-separated if more than one.'"
val_File(7) = "'File'&&'Version'&&'Y'&&''&&''&&'File'&&'1'&&'Version'&&''&&'Version string for versioned files;  Blank for unversioned files.'"
val_dicValidation.Add "File", val_File

Dim val_CCPSearch(0)
val_CCPSearch(0) = "'CCPSearch'&&'Signature_'&&'N'&&''&&''&&'Signature;RegLocator;IniLocator;DrLocator;CompLocator'&&'1'&&'Identifier'&&''&&'The Signature_ represents a unique file signature and is also the foreign key in the Signature,  RegLocator, IniLocator, CompLocator and the DrLocator tables.'"
val_dicValidation.Add "CCPSearch", val_CCPSearch

Dim val_CheckBox(1)
val_CheckBox(0) = "'CheckBox'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to the item.'"
val_CheckBox(1) = "'CheckBox'&&'Value'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The value string associated with the item.'"
val_dicValidation.Add "CheckBox", val_CheckBox

Dim val_Class(12)
val_Class(0) = "'Class'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Localized description for the Class.'"
val_Class(1) = "'Class'&&'Attributes'&&'Y'&&''&&'32767'&&''&&''&&''&&''&&'Class registration attributes.'"
val_Class(2) = "'Class'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Required foreign key into the Feature Table, specifying the feature to validate or install in order for the CLSID factory to be operational.'"
val_Class(3) = "'Class'&&'AppId_'&&'Y'&&''&&''&&'AppId'&&'1'&&'Guid'&&''&&'Optional AppID containing DCOM information for associated application (string GUID).'"
val_Class(4) = "'Class'&&'Argument'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'optional argument for LocalServers.'"
val_Class(5) = "'Class'&&'CLSID'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'The CLSID of an OLE factory.'"
val_Class(6) = "'Class'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table, specifying the component for which to return a path when called through LocateComponent.'"
val_Class(7) = "'Class'&&'Context'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The numeric server context for this server. CLSCTX_xxxx'"
val_Class(8) = "'Class'&&'DefInprocHandler'&&'Y'&&''&&''&&''&&''&&'Filename'&&'1;2;3'&&'Optional default inproc handler.  Only optionally provided if Context=CLSCTX_LOCAL_SERVER.  Typically ""ole32.dll"" or ""mapi32.dll""'"
val_Class(9) = "'Class'&&'FileTypeMask'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Optional string containing information for the HKCRthis CLSID) key. If multiple patterns exist, they must be delimited by a semicolon, and numeric subkeys will be generated: 0,1,2...'"
val_Class(10) = "'Class'&&'Icon_'&&'Y'&&''&&''&&'Icon'&&'1'&&'Identifier'&&''&&'Optional foreign key into the Icon Table, specifying the icon file associated with this CLSID. Will be written under the DefaultIcon key.'"
val_Class(11) = "'Class'&&'IconIndex'&&'Y'&&'-32767'&&'32767'&&''&&''&&''&&''&&'Optional icon index.'"
val_Class(12) = "'Class'&&'ProgId_Default'&&'Y'&&''&&''&&'ProgId'&&'1'&&'Text'&&''&&'Optional ProgId associated with this CLSID.'"
val_dicValidation.Add "Class", val_Class

Dim val_Component(5)
val_Component(0) = "'Component'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'A conditional statement that will disable this component if the specified condition evaluates to the 'True' state. If a component is disabled, it will not be installed, regardless of the 'Action' state associated with the component.'"
val_Component(1) = "'Component'&&'Attributes'&&'N'&&''&&''&&''&&''&&''&&''&&'Remote execution option, one of irsEnum'"
val_Component(2) = "'Component'&&'Component'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key used to identify a particular component record.'"
val_Component(3) = "'Component'&&'ComponentId'&&'Y'&&''&&''&&''&&''&&'Guid'&&''&&'A string GUID unique to this component, version, and language.'"
val_Component(4) = "'Component'&&'Directory_'&&'N'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Required key of a Directory table record. This is actually a property name whose value contains the actual path, set either by the AppSearch action or with the default setting obtained from the Directory table.'"
val_Component(5) = "'Component'&&'KeyPath'&&'Y'&&''&&''&&'File;Registry;ODBCDataSource'&&'1'&&'Identifier'&&''&&'Either the primary key into the File table, Registry table, or ODBCDataSource table. This extract path is stored when the component is installed, and is used to detect the presence of the component and to return the path to it.'"
val_dicValidation.Add "Component", val_Component

Dim val_Icon(1)
val_Icon(0) = "'Icon'&&'Name'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key. Name of the icon file.'"
val_Icon(1) = "'Icon'&&'Data'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'Binary stream. The binary icon data in PE (.DLL or .EXE) or icon (.ICO) format.'"
val_dicValidation.Add "Icon", val_Icon

Dim val_ProgId(5)
val_ProgId(0) = "'ProgId'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Localized description for the Program identifier.'"
val_ProgId(1) = "'ProgId'&&'Icon_'&&'Y'&&''&&''&&'Icon'&&'1'&&'Identifier'&&''&&'Optional foreign key into the Icon Table, specifying the icon file associated with this ProgId. Will be written under the DefaultIcon key.'"
val_ProgId(2) = "'ProgId'&&'IconIndex'&&'Y'&&'-32767'&&'32767'&&''&&''&&''&&''&&'Optional icon index.'"
val_ProgId(3) = "'ProgId'&&'ProgId'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The Program Identifier. Primary key.'"
val_ProgId(4) = "'ProgId'&&'Class_'&&'Y'&&''&&''&&'Class'&&'1'&&'Guid'&&''&&'The CLSID of an OLE factory corresponding to the ProgId.'"
val_ProgId(5) = "'ProgId'&&'ProgId_Parent'&&'Y'&&''&&''&&'ProgId'&&'1'&&'Text'&&''&&'The Parent Program Identifier. If specified, the ProgId column becomes a version independent prog id.'"
val_dicValidation.Add "ProgId", val_ProgId

Dim val_ComboBox(3)
val_ComboBox(0) = "'ComboBox'&&'Text'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The visible text to be assigned to the item. Optional. If this entry or the entire column is missing, the text is the same as the value.'"
val_ComboBox(1) = "'ComboBox'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to this item. All the items tied to the same property become part of the same combobox.'"
val_ComboBox(2) = "'ComboBox'&&'Value'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The value string associated with this item. Selecting the line will set the associated property to this value.'"
val_ComboBox(3) = "'ComboBox'&&'Order'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'A positive integer used to determine the ordering of the items within one list.	The integers do not have to be consecutive.'"
val_dicValidation.Add "ComboBox", val_ComboBox

Dim val_CompLocator(2)
val_CompLocator(0) = "'CompLocator'&&'Type'&&'Y'&&'0'&&'1'&&''&&''&&''&&''&&'A boolean value that determines if the registry value is a filename or a directory location.'"
val_CompLocator(1) = "'CompLocator'&&'Signature_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The table key. The Signature_ represents a unique file signature and is also the foreign key in the Signature table.'"
val_CompLocator(2) = "'CompLocator'&&'ComponentId'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'A string GUID unique to this component, version, and language.'"
val_dicValidation.Add "CompLocator", val_CompLocator

Dim val_Complus(1)
val_Complus(0) = "'Complus'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key referencing Component that controls the ComPlus component.'"
val_Complus(1) = "'Complus'&&'ExpType'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'ComPlus component attributes.'"
val_dicValidation.Add "Complus", val_Complus

Dim val_Directory(2)
val_Directory(0) = "'Directory'&&'Directory'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Unique identifier for directory entry, primary key. If a property by this name is defined, it contains the full path to the directory.'"
val_Directory(1) = "'Directory'&&'DefaultDir'&&'N'&&''&&''&&''&&''&&'DefaultDir'&&''&&'The default sub-path under parent's path.'"
val_Directory(2) = "'Directory'&&'Directory_Parent'&&'Y'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Reference to the entry in this table specifying the default parent directory. A record parented to itself or with a Null parent represents a root of the install tree.'"
val_dicValidation.Add "Directory", val_Directory

Dim val_Control(11)
val_Control(0) = "'Control'&&'Type'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The type of the control.'"
val_Control(1) = "'Control'&&'Y'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Vertical coordinate of the upper left corner of the bounding rectangle of the control.'"
val_Control(2) = "'Control'&&'Text'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'A string used to set the initial text contained within a control (if appropriate).'"
val_Control(3) = "'Control'&&'Property'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'The name of a defined property to be linked to this control. '"
val_Control(4) = "'Control'&&'Attributes'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'A 32-bit word that specifies the attribute flags to be applied to this control.'"
val_Control(5) = "'Control'&&'Height'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Height of the bounding rectangle of the control.'"
val_Control(6) = "'Control'&&'Width'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Width of the bounding rectangle of the control.'"
val_Control(7) = "'Control'&&'X'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Horizontal coordinate of the upper left corner of the bounding rectangle of the control.'"
val_Control(8) = "'Control'&&'Control'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the control. This name must be unique within a dialog, but can repeat on different dialogs. '"
val_Control(9) = "'Control'&&'Control_Next'&&'Y'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'The name of an other control on the same dialog. This link defines the tab order of the controls. The links have to form one or more cycles!'"
val_Control(10) = "'Control'&&'Dialog_'&&'N'&&''&&''&&'Dialog'&&'1'&&'Identifier'&&''&&'External key to the Dialog table, name of the dialog.'"
val_Control(11) = "'Control'&&'Help'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The help strings used with the button. The text is optional. '"
val_dicValidation.Add "Control", val_Control

Dim val_Dialog(9)
val_Dialog(0) = "'Dialog'&&'Attributes'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'A 32-bit word that specifies the attribute flags to be applied to this dialog.'"
val_Dialog(1) = "'Dialog'&&'Height'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Height of the bounding rectangle of the dialog.'"
val_Dialog(2) = "'Dialog'&&'Width'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Width of the bounding rectangle of the dialog.'"
val_Dialog(3) = "'Dialog'&&'Dialog'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the dialog.'"
val_Dialog(4) = "'Dialog'&&'Control_Cancel'&&'Y'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'Defines the cancel control. Hitting escape or clicking on the close icon on the dialog is equivalent to pushing this button.'"
val_Dialog(5) = "'Dialog'&&'Control_Default'&&'Y'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'Defines the default control. Hitting return is equivalent to pushing this button.'"
val_Dialog(6) = "'Dialog'&&'Control_First'&&'N'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'Defines the control that has the focus when the dialog is created.'"
val_Dialog(7) = "'Dialog'&&'HCentering'&&'N'&&'0'&&'100'&&''&&''&&''&&''&&'Horizontal position of the dialog on a 0-100 scale. 0 means left end, 100 means right end of the screen, 50 center.'"
val_Dialog(8) = "'Dialog'&&'Title'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'A text string specifying the title to be displayed in the title bar of the dialog's window.'"
val_Dialog(9) = "'Dialog'&&'VCentering'&&'N'&&'0'&&'100'&&''&&''&&''&&''&&'Vertical position of the dialog on a 0-100 scale. 0 means top end, 100 means bottom end of the screen, 50 center.'"
val_dicValidation.Add "Dialog", val_Dialog

Dim val_ControlCondition(3)
val_ControlCondition(0) = "'ControlCondition'&&'Action'&&'N'&&''&&''&&''&&''&&''&&'Default;Disable;Enable;Hide;Show'&&'The desired action to be taken on the specified control.'"
val_ControlCondition(1) = "'ControlCondition'&&'Condition'&&'N'&&''&&''&&''&&''&&'Condition'&&''&&'A standard conditional statement that specifies under which conditions the action should be triggered.'"
val_ControlCondition(2) = "'ControlCondition'&&'Dialog_'&&'N'&&''&&''&&'Dialog'&&'1'&&'Identifier'&&''&&'A foreign key to the Dialog table, name of the dialog.'"
val_ControlCondition(3) = "'ControlCondition'&&'Control_'&&'N'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'A foreign key to the Control table, name of the control.'"
val_dicValidation.Add "ControlCondition", val_ControlCondition

Dim val_ControlEvent(5)
val_ControlEvent(0) = "'ControlEvent'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'A standard conditional statement that specifies under which conditions an event should be triggered.'"
val_ControlEvent(1) = "'ControlEvent'&&'Ordering'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'An integer used to order several events tied to the same control. Can be left blank.'"
val_ControlEvent(2) = "'ControlEvent'&&'Argument'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'A value to be used as a modifier when triggering a particular event.'"
val_ControlEvent(3) = "'ControlEvent'&&'Dialog_'&&'N'&&''&&''&&'Dialog'&&'1'&&'Identifier'&&''&&'A foreign key to the Dialog table, name of the dialog.'"
val_ControlEvent(4) = "'ControlEvent'&&'Control_'&&'N'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'A foreign key to the Control table, name of the control'"
val_ControlEvent(5) = "'ControlEvent'&&'Event'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'An identifier that specifies the type of the event that should take place when the user interacts with control specified by the first two entries.'"
val_dicValidation.Add "ControlEvent", val_ControlEvent

Dim val_CreateFolder(1)
val_CreateFolder(0) = "'CreateFolder'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table.'"
val_CreateFolder(1) = "'CreateFolder'&&'Directory_'&&'N'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Primary key, could be foreign key into the Directory table.'"
val_dicValidation.Add "CreateFolder", val_CreateFolder

Dim val_CustomAction(3)
val_CustomAction(0) = "'CustomAction'&&'Type'&&'N'&&'1'&&'16383'&&''&&''&&''&&''&&'The numeric custom action type, consisting of source location, code type, entry, option flags.'"
val_CustomAction(1) = "'CustomAction'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, name of action, normally appears in sequence table unless private use.'"
val_CustomAction(2) = "'CustomAction'&&'Source'&&'Y'&&''&&''&&''&&''&&'CustomSource'&&''&&'The table reference of the source of the code.'"
val_CustomAction(3) = "'CustomAction'&&'Target'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Excecution parameter, depends on the type of custom action'"
val_dicValidation.Add "CustomAction", val_CustomAction

Dim val_DrLocator(3)
val_DrLocator(0) = "'DrLocator'&&'Signature_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The Signature_ represents a unique file signature and is also the foreign key in the Signature table.'"
val_DrLocator(1) = "'DrLocator'&&'Path'&&'Y'&&''&&''&&''&&''&&'AnyPath'&&''&&'The path on the user system. This is a either a subpath below the value of the Parent or a full path. The path may contain properties enclosed within [ ] that will be expanded.'"
val_DrLocator(2) = "'DrLocator'&&'Depth'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'The depth below the path to which the Signature_ is recursively searched. If absent, the depth is assumed to be 0.'"
val_DrLocator(3) = "'DrLocator'&&'Parent'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'The parent file signature. It is also a foreign key in the Signature table. If null and the Path column does not expand to a full path, then all the fixed drives of the user system are searched using the Path.'"
val_dicValidation.Add "DrLocator", val_DrLocator

Dim val_DuplicateFile(4)
val_DuplicateFile(0) = "'DuplicateFile'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Foreign key referencing the source file to be duplicated.'"
val_DuplicateFile(1) = "'DuplicateFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key referencing Component that controls the duplicate file.'"
val_DuplicateFile(2) = "'DuplicateFile'&&'DestFolder'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full pathname to a destination folder.'"
val_DuplicateFile(3) = "'DuplicateFile'&&'DestName'&&'Y'&&''&&''&&''&&''&&'Filename'&&''&&'Filename to be given to the duplicate file.'"
val_DuplicateFile(4) = "'DuplicateFile'&&'FileKey'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key used to identify a particular file entry'"
val_dicValidation.Add "DuplicateFile", val_DuplicateFile

Dim val_Environment(3)
val_Environment(0) = "'Environment'&&'Name'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The name of the environmental value.'"
val_Environment(1) = "'Environment'&&'Value'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The value to set in the environmental settings.'"
val_Environment(2) = "'Environment'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the installing of the environmental value.'"
val_Environment(3) = "'Environment'&&'Environment'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Unique identifier for the environmental variable setting'"
val_dicValidation.Add "Environment", val_Environment

Dim val_Error(1)
val_Error(0) = "'Error'&&'Error'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Integer error number, obtained from header file IError(...) macros.'"
val_Error(1) = "'Error'&&'Message'&&'Y'&&''&&''&&''&&''&&'Template'&&''&&'Error formatting template, obtained from user ed. or localizers.'"
val_dicValidation.Add "Error", val_Error

Dim val_EventMapping(3)
val_EventMapping(0) = "'EventMapping'&&'Dialog_'&&'N'&&''&&''&&'Dialog'&&'1'&&'Identifier'&&''&&'A foreign key to the Dialog table, name of the Dialog.'"
val_EventMapping(1) = "'EventMapping'&&'Control_'&&'N'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'A foreign key to the Control table, name of the control.'"
val_EventMapping(2) = "'EventMapping'&&'Event'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'An identifier that specifies the type of the event that the control subscribes to.'"
val_EventMapping(3) = "'EventMapping'&&'Attribute'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The name of the control attribute, that is set when this event is received.'"
val_dicValidation.Add "EventMapping", val_EventMapping

Dim val_Extension(4)
val_Extension(0) = "'Extension'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Required foreign key into the Feature Table, specifying the feature to validate or install in order for the CLSID factory to be operational.'"
val_Extension(1) = "'Extension'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table, specifying the component for which to return a path when called through LocateComponent.'"
val_Extension(2) = "'Extension'&&'Extension'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The extension associated with the table row.'"
val_Extension(3) = "'Extension'&&'MIME_'&&'Y'&&''&&''&&'MIME'&&'1'&&'Text'&&''&&'Optional Context identifier, typically ""type/format"" associated with the extension'"
val_Extension(4) = "'Extension'&&'ProgId_'&&'Y'&&''&&''&&'ProgId'&&'1'&&'Text'&&''&&'Optional ProgId associated with this extension.'"
val_dicValidation.Add "Extension", val_Extension

Dim val_MIME(2)
val_MIME(0) = "'MIME'&&'CLSID'&&'Y'&&''&&''&&''&&''&&'Guid'&&''&&'Optional associated CLSID.'"
val_MIME(1) = "'MIME'&&'ContentType'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Primary key. Context identifier, typically ""type/format"".'"
val_MIME(2) = "'MIME'&&'Extension_'&&'N'&&''&&''&&'Extension'&&'1'&&'Text'&&''&&'Optional associated extension (without dot)'"
val_dicValidation.Add "MIME", val_MIME

Dim val_FeatureComponents(1)
val_FeatureComponents(0) = "'FeatureComponents'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Foreign key into Feature table.'"
val_FeatureComponents(1) = "'FeatureComponents'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into Component table.'"
val_dicValidation.Add "FeatureComponents", val_FeatureComponents

Dim val_FileSFPCatalog(1)
val_FileSFPCatalog(0) = "'FileSFPCatalog'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'File associated with the catalog'"
val_FileSFPCatalog(1) = "'FileSFPCatalog'&&'SFPCatalog_'&&'N'&&''&&''&&'SFPCatalog'&&'1'&&'Filename'&&''&&'Catalog associated with the file'"
val_dicValidation.Add "FileSFPCatalog", val_FileSFPCatalog

Dim val_SFPCatalog(2)
val_SFPCatalog(0) = "'SFPCatalog'&&'SFPCatalog'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'File name for the catalog.'"
val_SFPCatalog(1) = "'SFPCatalog'&&'Catalog'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'SFP Catalog'"
val_SFPCatalog(2) = "'SFPCatalog'&&'Dependency'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Parent catalog - only used by SFP'"
val_dicValidation.Add "SFPCatalog", val_SFPCatalog

Dim val_Font(1)
val_Font(0) = "'Font'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Primary key, foreign key into File table referencing font file.'"
val_Font(1) = "'Font'&&'FontTitle'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Font name.'"
val_dicValidation.Add "Font", val_Font

Dim val_IniFile(7)
val_IniFile(0) = "'IniFile'&&'Action'&&'N'&&''&&''&&''&&''&&''&&'0;1;3'&&'The type of modification to be made, one of iifEnum'"
val_IniFile(1) = "'IniFile'&&'Value'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The value to be written.'"
val_IniFile(2) = "'IniFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the installing of the .INI value.'"
val_IniFile(3) = "'IniFile'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The .INI file name in which to write the information'"
val_IniFile(4) = "'IniFile'&&'IniFile'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_IniFile(5) = "'IniFile'&&'DirProperty'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Foreign key into the Directory table denoting the directory where the .INI file is.'"
val_IniFile(6) = "'IniFile'&&'Key'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The .INI file key below Section.'"
val_IniFile(7) = "'IniFile'&&'Section'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The .INI file Section.'"
val_dicValidation.Add "IniFile", val_IniFile

Dim val_IniLocator(5)
val_IniLocator(0) = "'IniLocator'&&'Type'&&'Y'&&'0'&&'2'&&''&&''&&''&&''&&'An integer value that determines if the .INI value read is a filename or a directory location or to be used as is w/o interpretation.'"
val_IniLocator(1) = "'IniLocator'&&'Signature_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The table key. The Signature_ represents a unique file signature and is also the foreign key in the Signature table.'"
val_IniLocator(2) = "'IniLocator'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The .INI file name.'"
val_IniLocator(3) = "'IniLocator'&&'Key'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Key value (followed by an equals sign in INI file).'"
val_IniLocator(4) = "'IniLocator'&&'Section'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Section name within in file (within square brackets in INI file).'"
val_IniLocator(5) = "'IniLocator'&&'Field'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'The field in the .INI line. If Field is null or 0 the entire line is read.'"
val_dicValidation.Add "IniLocator", val_IniLocator

Dim val_InstallExecuteSequence(2)
val_InstallExecuteSequence(0) = "'InstallExecuteSequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_InstallExecuteSequence(1) = "'InstallExecuteSequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_InstallExecuteSequence(2) = "'InstallExecuteSequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "InstallExecuteSequence", val_InstallExecuteSequence

Dim val_InstallUISequence(2)
val_InstallUISequence(0) = "'InstallUISequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_InstallUISequence(1) = "'InstallUISequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_InstallUISequence(2) = "'InstallUISequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "InstallUISequence", val_InstallUISequence

Dim val_IsolatedComponent(1)
val_IsolatedComponent(0) = "'IsolatedComponent'&&'Component_Application'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Key to Component table item for application'"
val_IsolatedComponent(1) = "'IsolatedComponent'&&'Component_Shared'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Key to Component table item to be isolated'"
val_dicValidation.Add "IsolatedComponent", val_IsolatedComponent

Dim val_LaunchCondition(1)
val_LaunchCondition(0) = "'LaunchCondition'&&'Description'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'Localizable text to display when condition fails and install must abort.'"
val_LaunchCondition(1) = "'LaunchCondition'&&'Condition'&&'N'&&''&&''&&''&&''&&'Condition'&&''&&'Expression which must evaluate to TRUE in order for install to commence.'"
val_dicValidation.Add "LaunchCondition", val_LaunchCondition

Dim val_ListBox(3)
val_ListBox(0) = "'ListBox'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The visible text to be assigned to the item. Optional. If this entry or the entire column is missing, the text is the same as the value.'"
val_ListBox(1) = "'ListBox'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to this item. All the items tied to the same property become part of the same listbox.'"
val_ListBox(2) = "'ListBox'&&'Value'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The value string associated with this item. Selecting the line will set the associated property to this value.'"
val_ListBox(3) = "'ListBox'&&'Order'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'A positive integer used to determine the ordering of the items within one list..The integers do not have to be consecutive.'"
val_dicValidation.Add "ListBox", val_ListBox

Dim val_ListView(4)
val_ListView(0) = "'ListView'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The visible text to be assigned to the item. Optional. If this entry or the entire column is missing, the text is the same as the value.'"
val_ListView(1) = "'ListView'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to this item. All the items tied to the same property become part of the same listview.'"
val_ListView(2) = "'ListView'&&'Value'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The value string associated with this item. Selecting the line will set the associated property to this value.'"
val_ListView(3) = "'ListView'&&'Order'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'A positive integer used to determine the ordering of the items within one list..The integers do not have to be consecutive.'"
val_ListView(4) = "'ListView'&&'Binary_'&&'Y'&&''&&''&&'Binary'&&'1'&&'Identifier'&&''&&'The name of the icon to be displayed with the icon. The binary information is looked up from the Binary Table.'"
val_dicValidation.Add "ListView", val_ListView

Dim val_LockPermissions(4)
val_LockPermissions(0) = "'LockPermissions'&&'Table'&&'N'&&''&&''&&''&&''&&'Identifier'&&'Directory;File;Registry'&&'Reference to another table name'"
val_LockPermissions(1) = "'LockPermissions'&&'Domain'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Domain name for user whose permissions are being set. (usually a property)'"
val_LockPermissions(2) = "'LockPermissions'&&'LockObject'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Foreign key into Registry or File table'"
val_LockPermissions(3) = "'LockPermissions'&&'Permission'&&'Y'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Permission Access mask.  Full Control = 268435456 (GENERIC_ALL = 0x10000000)'"
val_LockPermissions(4) = "'LockPermissions'&&'User'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'User for permissions to be set.  (usually a property)'"
val_dicValidation.Add "LockPermissions", val_LockPermissions

Dim val_Media(5)
val_Media(0) = "'Media'&&'Source'&&'Y'&&''&&''&&''&&''&&'Property'&&''&&'The property defining the location of the cabinet file.'"
val_Media(1) = "'Media'&&'Cabinet'&&'Y'&&''&&''&&''&&''&&'Cabinet'&&''&&'If some or all of the files stored on the media are compressed in a cabinet, the name of that cabinet.'"
val_Media(2) = "'Media'&&'DiskId'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'Primary key, integer to determine sort order for table.'"
val_Media(3) = "'Media'&&'DiskPrompt'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Disk name: the visible text actually printed on the disk.  This will be used to prompt the user when this disk needs to be inserted.'"
val_Media(4) = "'Media'&&'LastSequence'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'File sequence number for the last file for this media.'"
val_Media(5) = "'Media'&&'VolumeLabel'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The label attributed to the volume.'"
val_dicValidation.Add "Media", val_Media

Dim val_ModuleComponents(2)
val_ModuleComponents(0) = "'ModuleComponents'&&'Component'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Component contained in the module.'"
val_ModuleComponents(1) = "'ModuleComponents'&&'Language'&&'N'&&''&&''&&'ModuleSignature'&&'2'&&''&&''&&'Default language ID for module (may be changed by transform).'"
val_ModuleComponents(2) = "'ModuleComponents'&&'ModuleID'&&'N'&&''&&''&&'ModuleSignature'&&'1'&&'Identifier'&&''&&'Module containing the component.'"
val_dicValidation.Add "ModuleComponents", val_ModuleComponents

Dim val_ModuleSignature(2)
val_ModuleSignature(0) = "'ModuleSignature'&&'Language'&&'N'&&''&&''&&''&&''&&''&&''&&'Default decimal language of module.'"
val_ModuleSignature(1) = "'ModuleSignature'&&'Version'&&'N'&&''&&''&&''&&''&&'Version'&&''&&'Version of the module.'"
val_ModuleSignature(2) = "'ModuleSignature'&&'ModuleID'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Module identifier (String.GUID).'"
val_dicValidation.Add "ModuleSignature", val_ModuleSignature

Dim val_ModuleDependency(4)
val_ModuleDependency(0) = "'ModuleDependency'&&'ModuleID'&&'N'&&''&&''&&'ModuleSignature'&&'1'&&'Identifier'&&''&&'Module requiring the dependency.'"
val_ModuleDependency(1) = "'ModuleDependency'&&'ModuleLanguage'&&'N'&&''&&''&&'ModuleSignature'&&'2'&&''&&''&&'Language of module requiring the dependency.'"
val_ModuleDependency(2) = "'ModuleDependency'&&'RequiredID'&&'N'&&''&&''&&''&&''&&''&&''&&'String.GUID of required module.'"
val_ModuleDependency(3) = "'ModuleDependency'&&'RequiredLanguage'&&'N'&&''&&''&&''&&''&&''&&''&&'LanguageID of the required module.'"
val_ModuleDependency(4) = "'ModuleDependency'&&'RequiredVersion'&&'Y'&&''&&''&&''&&''&&'Version'&&''&&'Version of the required version.'"
val_dicValidation.Add "ModuleDependency", val_ModuleDependency

Dim val_ModuleExclusion(5)
val_ModuleExclusion(0) = "'ModuleExclusion'&&'ModuleID'&&'N'&&''&&''&&'ModuleSignature'&&'1'&&'Identifier'&&''&&'String.GUID of module with exclusion requirement.'"
val_ModuleExclusion(1) = "'ModuleExclusion'&&'ModuleLanguage'&&'N'&&''&&''&&'ModuleSignature'&&'2'&&''&&''&&'LanguageID of module with exclusion requirement.'"
val_ModuleExclusion(2) = "'ModuleExclusion'&&'ExcludedID'&&'N'&&''&&''&&''&&''&&''&&''&&'String.GUID of excluded module.'"
val_ModuleExclusion(3) = "'ModuleExclusion'&&'ExcludedLanguage'&&'N'&&''&&''&&''&&''&&''&&''&&'Language of excluded module.'"
val_ModuleExclusion(4) = "'ModuleExclusion'&&'ExcludedMaxVersion'&&'Y'&&''&&''&&''&&''&&'Version'&&''&&'Maximum version of excluded module.'"
val_ModuleExclusion(5) = "'ModuleExclusion'&&'ExcludedMinVersion'&&'Y'&&''&&''&&''&&''&&'Version'&&''&&'Minimum version of excluded module.'"
val_dicValidation.Add "ModuleExclusion", val_ModuleExclusion

Dim val_MoveFile(6)
val_MoveFile(0) = "'MoveFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'If this component is not ""selected"" for installation or removal, no action will be taken on the associated MoveFile entry'"
val_MoveFile(1) = "'MoveFile'&&'DestFolder'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full path to the destination directory'"
val_MoveFile(2) = "'MoveFile'&&'DestName'&&'Y'&&''&&''&&''&&''&&'Filename'&&''&&'Name to be given to the original file after it is moved or copied.  If blank, the destination file will be given the same name as the source file'"
val_MoveFile(3) = "'MoveFile'&&'FileKey'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key that uniquely identifies a particular MoveFile record'"
val_MoveFile(4) = "'MoveFile'&&'Options'&&'N'&&'0'&&'1'&&''&&''&&''&&''&&'Integer value specifying the MoveFile operating mode, one of imfoEnum'"
val_MoveFile(5) = "'MoveFile'&&'SourceFolder'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full path to the source directory'"
val_MoveFile(6) = "'MoveFile'&&'SourceName'&&'Y'&&''&&''&&''&&''&&'WildCardFilename'&&''&&'Name of the source file(s) to be moved or copied.  Can contain the '*' or '?' wildcards.'"
val_dicValidation.Add "MoveFile", val_MoveFile

Dim val_MsiAssembly(4)
val_MsiAssembly(0) = "'MsiAssembly'&&'Attributes'&&'Y'&&''&&''&&''&&''&&''&&''&&'Assembly attributes'"
val_MsiAssembly(1) = "'MsiAssembly'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Foreign key into Feature table.'"
val_MsiAssembly(2) = "'MsiAssembly'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into Component table.'"
val_MsiAssembly(3) = "'MsiAssembly'&&'File_Application'&&'Y'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Foreign key into File table, denoting the application context for private assemblies. Null for global assemblies.'"
val_MsiAssembly(4) = "'MsiAssembly'&&'File_Manifest'&&'Y'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Foreign key into the File table denoting the manifest file for the assembly.'"
val_dicValidation.Add "MsiAssembly", val_MsiAssembly

Dim val_MsiAssemblyName(2)
val_MsiAssemblyName(0) = "'MsiAssemblyName'&&'Name'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The name part of the name-value pairs for the assembly name.'"
val_MsiAssemblyName(1) = "'MsiAssemblyName'&&'Value'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The value part of the name-value pairs for the assembly name.'"
val_MsiAssemblyName(2) = "'MsiAssemblyName'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into Component table.'"
val_dicValidation.Add "MsiAssemblyName", val_MsiAssemblyName

Dim val_MsiDigitalCertificate(1)
val_MsiDigitalCertificate(0) = "'MsiDigitalCertificate'&&'CertData'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'A certificate context blob for a signer certificate'"
val_MsiDigitalCertificate(1) = "'MsiDigitalCertificate'&&'DigitalCertificate'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A unique identifier for the row'"
val_dicValidation.Add "MsiDigitalCertificate", val_MsiDigitalCertificate

Dim val_MsiDigitalSignature(3)
val_MsiDigitalSignature(0) = "'MsiDigitalSignature'&&'Table'&&'N'&&''&&''&&''&&''&&''&&'Media'&&'Reference to another table name (only Media table is supported)'"
val_MsiDigitalSignature(1) = "'MsiDigitalSignature'&&'DigitalCertificate_'&&'N'&&''&&''&&'MsiDigitalCertificate'&&'1'&&'Identifier'&&''&&'Foreign key to MsiDigitalCertificate table identifying the signer certificate'"
val_MsiDigitalSignature(2) = "'MsiDigitalSignature'&&'Hash'&&'Y'&&''&&''&&''&&''&&'Binary'&&''&&'The encoded hash blob from the digital signature'"
val_MsiDigitalSignature(3) = "'MsiDigitalSignature'&&'SignObject'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Foreign key to Media table'"
val_dicValidation.Add "MsiDigitalSignature", val_MsiDigitalSignature

Dim val_MsiFileHash(5)
val_MsiFileHash(0) = "'MsiFileHash'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Primary key, foreign key into File table referencing file with this hash'"
val_MsiFileHash(1) = "'MsiFileHash'&&'Options'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Various options and attributes for this hash.'"
val_MsiFileHash(2) = "'MsiFileHash'&&'HashPart1'&&'N'&&''&&''&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_MsiFileHash(3) = "'MsiFileHash'&&'HashPart2'&&'N'&&''&&''&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_MsiFileHash(4) = "'MsiFileHash'&&'HashPart3'&&'N'&&''&&''&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_MsiFileHash(5) = "'MsiFileHash'&&'HashPart4'&&'N'&&''&&''&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_dicValidation.Add "MsiFileHash", val_MsiFileHash

Dim val_MsiPatchHeaders(1)
val_MsiPatchHeaders(0) = "'MsiPatchHeaders'&&'StreamRef'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key. A unique identifier for the row.'"
val_MsiPatchHeaders(1) = "'MsiPatchHeaders'&&'Header'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'Binary stream. The patch header, used for patch validation.'"
val_dicValidation.Add "MsiPatchHeaders", val_MsiPatchHeaders

Dim val_ODBCAttribute(2)
val_ODBCAttribute(0) = "'ODBCAttribute'&&'Value'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Value for ODBC driver attribute'"
val_ODBCAttribute(1) = "'ODBCAttribute'&&'Attribute'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Name of ODBC driver attribute'"
val_ODBCAttribute(2) = "'ODBCAttribute'&&'Driver_'&&'N'&&''&&''&&'ODBCDriver'&&'1'&&'Identifier'&&''&&'Reference to ODBC driver in ODBCDriver table'"
val_dicValidation.Add "ODBCAttribute", val_ODBCAttribute

Dim val_ODBCDriver(4)
val_ODBCDriver(0) = "'ODBCDriver'&&'Description'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Text used as registered name for driver, non-localized'"
val_ODBCDriver(1) = "'ODBCDriver'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Reference to key driver file'"
val_ODBCDriver(2) = "'ODBCDriver'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Reference to associated component'"
val_ODBCDriver(3) = "'ODBCDriver'&&'Driver'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized.internal token for driver'"
val_ODBCDriver(4) = "'ODBCDriver'&&'File_Setup'&&'Y'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Optional reference to key driver setup DLL'"
val_dicValidation.Add "ODBCDriver", val_ODBCDriver

Dim val_ODBCDataSource(4)
val_ODBCDataSource(0) = "'ODBCDataSource'&&'Description'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Text used as registered name for data source'"
val_ODBCDataSource(1) = "'ODBCDataSource'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Reference to associated component'"
val_ODBCDataSource(2) = "'ODBCDataSource'&&'DataSource'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized.internal token for data source'"
val_ODBCDataSource(3) = "'ODBCDataSource'&&'DriverDescription'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Reference to driver description, may be existing driver'"
val_ODBCDataSource(4) = "'ODBCDataSource'&&'Registration'&&'N'&&'0'&&'1'&&''&&''&&''&&''&&'Registration option: 0=machine, 1=user, others t.b.d.'"
val_dicValidation.Add "ODBCDataSource", val_ODBCDataSource

Dim val_ODBCSourceAttribute(2)
val_ODBCSourceAttribute(0) = "'ODBCSourceAttribute'&&'Value'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Value for ODBC data source attribute'"
val_ODBCSourceAttribute(1) = "'ODBCSourceAttribute'&&'Attribute'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Name of ODBC data source attribute'"
val_ODBCSourceAttribute(2) = "'ODBCSourceAttribute'&&'DataSource_'&&'N'&&''&&''&&'ODBCDataSource'&&'1'&&'Identifier'&&''&&'Reference to ODBC data source in ODBCDataSource table'"
val_dicValidation.Add "ODBCSourceAttribute", val_ODBCSourceAttribute

Dim val_ODBCTranslator(4)
val_ODBCTranslator(0) = "'ODBCTranslator'&&'Description'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Text used as registered name for translator'"
val_ODBCTranslator(1) = "'ODBCTranslator'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Reference to key translator file'"
val_ODBCTranslator(2) = "'ODBCTranslator'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Reference to associated component'"
val_ODBCTranslator(3) = "'ODBCTranslator'&&'File_Setup'&&'Y'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Optional reference to key translator setup DLL'"
val_ODBCTranslator(4) = "'ODBCTranslator'&&'Translator'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized.internal token for translator'"
val_dicValidation.Add "ODBCTranslator", val_ODBCTranslator

Dim val_Patch(5)
val_Patch(0) = "'Patch'&&'Sequence'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Primary key, sequence with respect to the media images; order must track cabinet order.'"
val_Patch(1) = "'Patch'&&'Attributes'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Integer containing bit flags representing patch attributes'"
val_Patch(2) = "'Patch'&&'File_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token, foreign key to File table, must match identifier in cabinet.'"
val_Patch(3) = "'Patch'&&'Header'&&'Y'&&''&&''&&''&&''&&'Binary'&&''&&'Binary stream. The patch header, used for patch validation.'"
val_Patch(4) = "'Patch'&&'PatchSize'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'Size of patch in bytes (long integer).'"
val_Patch(5) = "'Patch'&&'StreamRef_'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Identifier. Foreign key to the StreamRef column of the MsiPatchHeaders table.'"
val_dicValidation.Add "Patch", val_Patch

Dim val_PatchPackage(1)
val_PatchPackage(0) = "'PatchPackage'&&'Media_'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Foreign key to DiskId column of Media table. Indicates the disk containing the patch package.'"
val_PatchPackage(1) = "'PatchPackage'&&'PatchId'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'A unique string GUID representing this patch.'"
val_dicValidation.Add "PatchPackage", val_PatchPackage

Dim val_PublishComponent(4)
val_PublishComponent(0) = "'PublishComponent'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Foreign key into the Feature table.'"
val_PublishComponent(1) = "'PublishComponent'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table.'"
val_PublishComponent(2) = "'PublishComponent'&&'ComponentId'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'A string GUID that represents the component id that will be requested by the alien product.'"
val_PublishComponent(3) = "'PublishComponent'&&'AppData'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'This is localisable Application specific data that can be associated with a Qualified Component.'"
val_PublishComponent(4) = "'PublishComponent'&&'Qualifier'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'This is defined only when the ComponentId column is an Qualified Component Id. This is the Qualifier for ProvideComponentIndirect.'"
val_dicValidation.Add "PublishComponent", val_PublishComponent

Dim val_RadioButton(8)
val_RadioButton(0) = "'RadioButton'&&'Y'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The vertical coordinate of the upper left corner of the bounding rectangle of the radio button.'"
val_RadioButton(1) = "'RadioButton'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The visible title to be assigned to the radio button.'"
val_RadioButton(2) = "'RadioButton'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to this radio button. All the buttons tied to the same property become part of the same group.'"
val_RadioButton(3) = "'RadioButton'&&'Height'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The height of the button.'"
val_RadioButton(4) = "'RadioButton'&&'Width'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The width of the button.'"
val_RadioButton(5) = "'RadioButton'&&'X'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The horizontal coordinate of the upper left corner of the bounding rectangle of the radio button.'"
val_RadioButton(6) = "'RadioButton'&&'Value'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The value string associated with this button. Selecting the button will set the associated property to this value.'"
val_RadioButton(7) = "'RadioButton'&&'Order'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'A positive integer used to determine the ordering of the items within one list..The integers do not have to be consecutive.'"
val_RadioButton(8) = "'RadioButton'&&'Help'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The help strings used with the button. The text is optional.'"
val_dicValidation.Add "RadioButton", val_RadioButton

Dim val_Registry(5)
val_Registry(0) = "'Registry'&&'Name'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The registry value name.'"
val_Registry(1) = "'Registry'&&'Value'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The registry value.'"
val_Registry(2) = "'Registry'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the installing of the registry value.'"
val_Registry(3) = "'Registry'&&'Key'&&'N'&&''&&''&&''&&''&&'RegPath'&&''&&'The key for the registry value.'"
val_Registry(4) = "'Registry'&&'Registry'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_Registry(5) = "'Registry'&&'Root'&&'N'&&'-1'&&'3'&&''&&''&&''&&''&&'The predefined root key for the registry value, one of rrkEnum.'"
val_dicValidation.Add "Registry", val_Registry

Dim val_RegLocator(4)
val_RegLocator(0) = "'RegLocator'&&'Name'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The registry value name.'"
val_RegLocator(1) = "'RegLocator'&&'Type'&&'Y'&&'0'&&'18'&&''&&''&&''&&''&&'An integer value that determines if the registry value is a filename or a directory location or to be used as is w/o interpretation.'"
val_RegLocator(2) = "'RegLocator'&&'Signature_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The table key. The Signature_ represents a unique file signature and is also the foreign key in the Signature table. If the type is 0, the registry values refers a directory, and _Signature is not a foreign key.'"
val_RegLocator(3) = "'RegLocator'&&'Key'&&'N'&&''&&''&&''&&''&&'RegPath'&&''&&'The key for the registry value.'"
val_RegLocator(4) = "'RegLocator'&&'Root'&&'N'&&'0'&&'3'&&''&&''&&''&&''&&'The predefined root key for the registry value, one of rrkEnum.'"
val_dicValidation.Add "RegLocator", val_RegLocator

Dim val_RemoveFile(4)
val_RemoveFile(0) = "'RemoveFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key referencing Component that controls the file to be removed.'"
val_RemoveFile(1) = "'RemoveFile'&&'FileKey'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key used to identify a particular file entry'"
val_RemoveFile(2) = "'RemoveFile'&&'FileName'&&'Y'&&''&&''&&''&&''&&'WildCardFilename'&&''&&'Name of the file to be removed.'"
val_RemoveFile(3) = "'RemoveFile'&&'DirProperty'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full pathname to the folder of the file to be removed.'"
val_RemoveFile(4) = "'RemoveFile'&&'InstallMode'&&'N'&&''&&''&&''&&''&&''&&'1;2;3'&&'Installation option, one of iimEnum.'"
val_dicValidation.Add "RemoveFile", val_RemoveFile

Dim val_RemoveIniFile(7)
val_RemoveIniFile(0) = "'RemoveIniFile'&&'Action'&&'N'&&''&&''&&''&&''&&''&&'2;4'&&'The type of modification to be made, one of iifEnum.'"
val_RemoveIniFile(1) = "'RemoveIniFile'&&'Value'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The value to be deleted. The value is required when Action is iifIniRemoveTag'"
val_RemoveIniFile(2) = "'RemoveIniFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the deletion of the .INI value.'"
val_RemoveIniFile(3) = "'RemoveIniFile'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The .INI file name in which to delete the information'"
val_RemoveIniFile(4) = "'RemoveIniFile'&&'DirProperty'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Foreign key into the Directory table denoting the directory where the .INI file is.'"
val_RemoveIniFile(5) = "'RemoveIniFile'&&'Key'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The .INI file key below Section.'"
val_RemoveIniFile(6) = "'RemoveIniFile'&&'Section'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The .INI file Section.'"
val_RemoveIniFile(7) = "'RemoveIniFile'&&'RemoveIniFile'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_dicValidation.Add "RemoveIniFile", val_RemoveIniFile

Dim val_RemoveRegistry(4)
val_RemoveRegistry(0) = "'RemoveRegistry'&&'Name'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The registry value name.'"
val_RemoveRegistry(1) = "'RemoveRegistry'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the deletion of the registry value.'"
val_RemoveRegistry(2) = "'RemoveRegistry'&&'Key'&&'N'&&''&&''&&''&&''&&'RegPath'&&''&&'The key for the registry value.'"
val_RemoveRegistry(3) = "'RemoveRegistry'&&'Root'&&'N'&&'-1'&&'3'&&''&&''&&''&&''&&'The predefined root key for the registry value, one of rrkEnum'"
val_RemoveRegistry(4) = "'RemoveRegistry'&&'RemoveRegistry'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_dicValidation.Add "RemoveRegistry", val_RemoveRegistry

Dim val_ReserveCost(4)
val_ReserveCost(0) = "'ReserveCost'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Reserve a specified amount of space if this component is to be installed.'"
val_ReserveCost(1) = "'ReserveCost'&&'ReserveFolder'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full path to the destination directory'"
val_ReserveCost(2) = "'ReserveCost'&&'ReserveKey'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key that uniquely identifies a particular ReserveCost record'"
val_ReserveCost(3) = "'ReserveCost'&&'ReserveLocal'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'Disk space to reserve if linked component is installed locally.'"
val_ReserveCost(4) = "'ReserveCost'&&'ReserveSource'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'Disk space to reserve if linked component is installed to run from the source location.'"
val_dicValidation.Add "ReserveCost", val_ReserveCost

Dim val_SelfReg(1)
val_SelfReg(0) = "'SelfReg'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Foreign key into the File table denoting the module that needs to be registered.'"
val_SelfReg(1) = "'SelfReg'&&'Cost'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'The cost of registering the module.'"
val_dicValidation.Add "SelfReg", val_SelfReg

Dim val_ServiceControl(5)
val_ServiceControl(0) = "'ServiceControl'&&'Name'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'Name of a service. /, \, comma and space are invalid'"
val_ServiceControl(1) = "'ServiceControl'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table that controls the startup of the service'"
val_ServiceControl(2) = "'ServiceControl'&&'Event'&&'N'&&'0'&&'187'&&''&&''&&''&&''&&'Bit field:  Install:  0x1 = Start, 0x2 = Stop, 0x8 = Delete, Uninstall: 0x10 = Start, 0x20 = Stop, 0x80 = Delete'"
val_ServiceControl(3) = "'ServiceControl'&&'ServiceControl'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_ServiceControl(4) = "'ServiceControl'&&'Arguments'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Arguments for the service.  Separate by [~].'"
val_ServiceControl(5) = "'ServiceControl'&&'Wait'&&'Y'&&'0'&&'1'&&''&&''&&''&&''&&'Boolean for whether to wait for the service to fully start'"
val_dicValidation.Add "ServiceControl", val_ServiceControl

Dim val_ServiceInstall(12)
val_ServiceInstall(0) = "'ServiceInstall'&&'Name'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'Internal Name of the Service'"
val_ServiceInstall(1) = "'ServiceInstall'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Description of service.'"
val_ServiceInstall(2) = "'ServiceInstall'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table that controls the startup of the service'"
val_ServiceInstall(3) = "'ServiceInstall'&&'Arguments'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Arguments to include in every start of the service, passed to WinMain'"
val_ServiceInstall(4) = "'ServiceInstall'&&'ServiceInstall'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_ServiceInstall(5) = "'ServiceInstall'&&'Dependencies'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Other services this depends on to start.  Separate by [~], and end with [~][~]'"
val_ServiceInstall(6) = "'ServiceInstall'&&'DisplayName'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'External Name of the Service'"
val_ServiceInstall(7) = "'ServiceInstall'&&'ErrorControl'&&'N'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Severity of error if service fails to start'"
val_ServiceInstall(8) = "'ServiceInstall'&&'LoadOrderGroup'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'LoadOrderGroup'"
val_ServiceInstall(9) = "'ServiceInstall'&&'Password'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'password to run service with.  (with StartName)'"
val_ServiceInstall(10) = "'ServiceInstall'&&'ServiceType'&&'N'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Type of the service'"
val_ServiceInstall(11) = "'ServiceInstall'&&'StartName'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'User or object name to run service as'"
val_ServiceInstall(12) = "'ServiceInstall'&&'StartType'&&'N'&&'0'&&'4'&&''&&''&&''&&''&&'Type of the service'"
val_dicValidation.Add "ServiceInstall", val_ServiceInstall

Dim val_Shortcut(11)
val_Shortcut(0) = "'Shortcut'&&'Name'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The name of the shortcut to be created.'"
val_Shortcut(1) = "'Shortcut'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The description for the shortcut.'"
val_Shortcut(2) = "'Shortcut'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table denoting the component whose selection gates the the shortcut creation/deletion.'"
val_Shortcut(3) = "'Shortcut'&&'Icon_'&&'Y'&&''&&''&&'Icon'&&'1'&&'Identifier'&&''&&'Foreign key into the File table denoting the external icon file for the shortcut.'"
val_Shortcut(4) = "'Shortcut'&&'IconIndex'&&'Y'&&'-32767'&&'32767'&&''&&''&&''&&''&&'The icon index for the shortcut.'"
val_Shortcut(5) = "'Shortcut'&&'Directory_'&&'N'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Foreign key into the Directory table denoting the directory where the shortcut file is created.'"
val_Shortcut(6) = "'Shortcut'&&'Target'&&'N'&&''&&''&&''&&''&&'Shortcut'&&''&&'The shortcut target. This is usually a property that is expanded to a file or a folder that the shortcut points to.'"
val_Shortcut(7) = "'Shortcut'&&'Arguments'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The command-line arguments for the shortcut.'"
val_Shortcut(8) = "'Shortcut'&&'Shortcut'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_Shortcut(9) = "'Shortcut'&&'Hotkey'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'The hotkey for the shortcut. It has the virtual-key code for the key in the low-order byte, and the modifier flags in the high-order byte. '"
val_Shortcut(10) = "'Shortcut'&&'ShowCmd'&&'Y'&&''&&''&&''&&''&&''&&'1;3;7'&&'The show command for the application window.The following values may be used.'"
val_Shortcut(11) = "'Shortcut'&&'WkDir'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of property defining location of working directory.'"
val_dicValidation.Add "Shortcut", val_Shortcut

Dim val_Signature(8)
val_Signature(0) = "'Signature'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The name of the file. This may contain a ""short name|long name"" pair.'"
val_Signature(1) = "'Signature'&&'Signature'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The table key. The Signature represents a unique file signature.'"
val_Signature(2) = "'Signature'&&'Languages'&&'Y'&&''&&''&&''&&''&&'Language'&&''&&'The languages supported by the file.'"
val_Signature(3) = "'Signature'&&'MaxDate'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The maximum creation date of the file.'"
val_Signature(4) = "'Signature'&&'MaxSize'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The maximum size of the file. '"
val_Signature(5) = "'Signature'&&'MaxVersion'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The maximum version of the file.'"
val_Signature(6) = "'Signature'&&'MinDate'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The minimum creation date of the file.'"
val_Signature(7) = "'Signature'&&'MinSize'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The minimum size of the file.'"
val_Signature(8) = "'Signature'&&'MinVersion'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The minimum version of the file.'"
val_dicValidation.Add "Signature", val_Signature

Dim val_TextStyle(4)
val_TextStyle(0) = "'TextStyle'&&'TextStyle'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the style. The primary key of this table. This name is embedded in the texts to indicate a style change.'"
val_TextStyle(1) = "'TextStyle'&&'Color'&&'Y'&&'0'&&'16777215'&&''&&''&&''&&''&&'A long integer indicating the color of the string in the RGB format (Red, Green, Blue each 0-255, RGB = R + 256*G + 256^2*B).'"
val_TextStyle(2) = "'TextStyle'&&'FaceName'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'A string indicating the name of the font used. Required. The string must be at most 31 characters long.'"
val_TextStyle(3) = "'TextStyle'&&'Size'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The size of the font used. This size is given in our units (1/12 of the system font height). Assuming that the system font is set to 12 point size, this is equivalent to the point size.'"
val_TextStyle(4) = "'TextStyle'&&'StyleBits'&&'Y'&&'0'&&'15'&&''&&''&&''&&''&&'A combination of style bits.'"
val_dicValidation.Add "TextStyle", val_TextStyle

Dim val_TypeLib(7)
val_TypeLib(0) = "'TypeLib'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&''"
val_TypeLib(1) = "'TypeLib'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Required foreign key into the Feature Table, specifying the feature to validate or install in order for the type library to be operational.'"
val_TypeLib(2) = "'TypeLib'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table, specifying the component for which to return a path when called through LocateComponent.'"
val_TypeLib(3) = "'TypeLib'&&'Directory_'&&'Y'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Optional. The foreign key into the Directory table denoting the path to the help file for the type library.'"
val_TypeLib(4) = "'TypeLib'&&'Language'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The language of the library.'"
val_TypeLib(5) = "'TypeLib'&&'Version'&&'Y'&&'0'&&'16777215'&&''&&''&&''&&''&&'The version of the library. The minor version is in the lower 8 bits of the integer. The major version is in the next 16 bits. '"
val_TypeLib(6) = "'TypeLib'&&'Cost'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The cost associated with the registration of the typelib. This column is currently optional.'"
val_TypeLib(7) = "'TypeLib'&&'LibID'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'The GUID that represents the library.'"
val_dicValidation.Add "TypeLib", val_TypeLib

Dim val_UIText(1)
val_UIText(0) = "'UIText'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The localized version of the string.'"
val_UIText(1) = "'UIText'&&'Key'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A unique key that identifies the particular string.'"
val_dicValidation.Add "UIText", val_UIText

Dim val_Upgrade(6)
val_Upgrade(0) = "'Upgrade'&&'Attributes'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The attributes of this product set.'"
val_Upgrade(1) = "'Upgrade'&&'Language'&&'Y'&&''&&''&&''&&''&&'Language'&&''&&'A comma-separated list of languages for either products in this set or products not in this set.'"
val_Upgrade(2) = "'Upgrade'&&'ActionProperty'&&'N'&&''&&''&&''&&''&&'UpperCase'&&''&&'The property to set when a product in this set is found.'"
val_Upgrade(3) = "'Upgrade'&&'Remove'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The list of features to remove when uninstalling a product from this set.  The default is ""ALL"".'"
val_Upgrade(4) = "'Upgrade'&&'UpgradeCode'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'The UpgradeCode GUID belonging to the products in this set.'"
val_Upgrade(5) = "'Upgrade'&&'VersionMax'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The maximum ProductVersion of the products in this set.  The set may or may not include products with this particular version.'"
val_Upgrade(6) = "'Upgrade'&&'VersionMin'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The minimum ProductVersion of the products in this set.  The set may or may not include products with this particular version.'"
val_dicValidation.Add "Upgrade", val_Upgrade

Dim val_Verb(4)
val_Verb(0) = "'Verb'&&'Sequence'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'Order within the verbs for a particular extension. Also used simply to specify the default verb.'"
val_Verb(1) = "'Verb'&&'Argument'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Optional value for the command arguments.'"
val_Verb(2) = "'Verb'&&'Extension_'&&'N'&&''&&''&&'Extension'&&'1'&&'Text'&&''&&'The extension associated with the table row.'"
val_Verb(3) = "'Verb'&&'Verb'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The verb for the command.'"
val_Verb(4) = "'Verb'&&'Command'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The command text.'"

val_dicValidation.Add "Verb", val_Verb

Sub AddValidation(installer, db, sTable, fVerbose)
	Dim vw, rec, arrSplit
	' create the validation table if necessary
	If db.TablePersistent("_Validation") = 2 Then
		Set vw = db.OpenView("CREATE TABLE _Validation(`Table` CHAR(32) NOT NULL, `Column` CHAR(32) NOT NULL, `Nullable` CHAR(4) NOT NULL, `MinValue` LONG, `MaxValue` LONG, `KeyTable` CHAR(255), `KeyColumn` SHORT, `Category` CHAR(32), `Set` CHAR(255), `Description` CHAR(255) PRIMARY KEY `Table`, `Column`)")
		vw.Execute
		AddValidation installer, db, "_Validation", fVerbose
	End If
	If val_dicValidation.Exists(sTable) Then
		Dim i, arTable : arTable = val_dicValidation.Item(sTable)
		Set vw = db.OpenView("SELECT `Table`, `Column`, `Nullable`, `MinValue`, `MaxValue`, `KeyTable`, `KeyColumn`, `Category`, `Set`, `Description` FROM `_Validation`")
		vw.Execute
		Set rec = installer.CreateRecord(10)
		For i = 0 To UBound(arTable)
			If fVerbose Then WScript.Echo arTable(i)
			arrSplit = Split(arTable(i), "&&")
			For j = 0 To UBound(arrSplit)
				rec.StringData(j + 1) = Mid(arrSplit(j), 2, Len(arrSplit(j)) - 2)
			Next
			vw.Modify 1, rec
		Next
	End If
End Sub
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\resonexe\read.c ===
/****************************************************************************/
/*                                                                          */
/*  READ.C -                                                                */
/*                                                                          */
/*    Windows DOS Version 3.2 add resource onto executable		    */
/*   (C) Copyright Microsoft Corporation 1988-1992                          */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include <windows.h>

#include <stdlib.h>

#include "rc.h"
#include "resonexe.h"

//
// Reads a String structure from fhIn
// If the first word is 0xffff then this is an ID
// return the ID instead
//

BOOL
ReadStringOrID(
    IN int	fhIn,
    IN WCHAR	*s,
    OUT WORD	*pOrdinal
    )
{
    USHORT	cb;
    WCHAR	*pwch;

    pwch = s;
    *pwch = 0;
    *pOrdinal = 0;
    MyRead(fhIn, (PUCHAR)s, sizeof(WORD));

    if ( *s == ID_WORD) {

        //
        // an ID
        //

        MyRead(fhIn, (PUCHAR)pOrdinal, sizeof(WORD));
        return IS_ID;

    }
    else {

        //
        // a string
        //

        while (*s) {
              s++;
              MyRead(fhIn, (PUCHAR)s, sizeof(WCHAR));
        }

        *(s+1) = 0;
        cb = s - pwch;
        return IS_STRING;
    }

}

CHAR	*pTypeName[] = {
		    NULL,		/* 0 */
		    "CURSOR",		/* 1 */
		    "BITMAP",		/* 2 */
		    "ICON",		/* 3 */
		    "MENU",		/* 4 */
		    "DIALOG",		/* 5 */
		    "STRING",		/* 6 */
		    "FONTDIR",		/* 7 */
		    "FONT",		/* 8 */
		    "ACCELERATOR",	/* 9 */
		    "RCDATA",		/* 10 */
		    "MESSAGETABLE",	/* 11 */
		    "GROUP_CURSOR",	/* 12 */
		    NULL,		/* 13 */
		    "GROUP_ICON",	/* 14 */
		    NULL,		/* 15 */
		    "VERSION",		/* 16 */
		    "DLGINCLUDE"	/* 17 */
		    };


BOOL
ReadRes(
    IN int fhIn,
    IN ULONG cbInFile,
    IN HANDLE hupd
    )

/*++

Routine Description:


Arguments:

    fhIn - Supplies input file handle.
    fhOut - Supplies output file handle.
    cbInFile - Supplies size of input file.

Return Value:

    fSuccess

--*/

{
    WCHAR	type[256];
    WCHAR	name[256];
    WORD	typeord;
    WORD	nameord;
    ULONG	offHere;     // input file offset
    RESADDITIONAL	Additional;
    UCHAR	Buffer[1024];
    PVOID	pdata;

    //
    // Build up Type and Name directories
    //

    offHere = 0;
    while (offHere < cbInFile) {
	//
	// Get the sizes from the file
	//

	MyRead(fhIn, (PUCHAR)&Additional.DataSize, sizeof(ULONG));
	MyRead(fhIn, (PUCHAR)&Additional.HeaderSize, sizeof(ULONG));
	if (Additional.DataSize == 0) {
	    offHere = MySeek(fhIn, Additional.HeaderSize-2*sizeof(ULONG), SEEK_CUR);
	    continue;
	}

	//
	// Read the TYPE and NAME
	//
        ReadStringOrID(fhIn, type, &typeord);
        ReadStringOrID(fhIn, name, &nameord);
        offHere = MySeek(fhIn, 0, SEEK_CUR);
        while (offHere & 3)
            offHere = MySeek(fhIn, 1, SEEK_CUR);

	//
	// Read the rest of the header
	//
	MyRead(fhIn, (PUCHAR)&Additional.DataVersion,
		sizeof(RESADDITIONAL)-2*sizeof(ULONG));

        //
        // if were converting a win30 resource and this is
        // a name table then discard it
        //

        if (fVerbose)  {
            if ( typeord == 0) {
                printf("Adding resource - Type:%S, ", type);
            }
	    else {
		if (typeord <= 17)
		    printf("Adding resource - Type:%s, ", pTypeName[typeord]);
		else
		    printf("Adding resource - Type:%d, ", typeord);
            }

            if ( nameord == 0 ) {
                printf("Name:%S, ", name);
            }
	    else {
                printf("Name:%d, ", nameord);
            }

            printf("Size:%ld\n", Additional.DataSize);
        }
        pdata = (PVOID)MyAlloc(Additional.DataSize);
        MyRead(fhIn, pdata, Additional.DataSize);

        if (typeord == 0) {
            if (nameord == 0) {
                UpdateResourceW(hupd, type, name,
				Additional.LanguageId,
			        pdata, Additional.DataSize);
            }
            else {
                UpdateResourceW(hupd, type, (LPWSTR)nameord,
				Additional.LanguageId,
			        pdata, Additional.DataSize);
	    }
        }
        else {
            if (nameord == 0) {
                UpdateResourceW(hupd, (LPWSTR)typeord, name,
				Additional.LanguageId,
			        pdata, Additional.DataSize);
            }
            else {
                UpdateResourceW(hupd, (LPWSTR)typeord, (LPWSTR)nameord,
				Additional.LanguageId,
			        pdata, Additional.DataSize);
	    }
        }

        offHere = MySeek(fhIn, 0, SEEK_CUR);
        while (offHere & 3)
            offHere = MySeek(fhIn, 1, SEEK_CUR);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\mui\tools\muiver\muiver.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <io.h>
#include <md5.h>

#define MD5_CHECKSUM_SIZE 16
#define RESOURCE_CHECKSUM_LANGID 0x0409

BOOL g_bVerbose = FALSE;

typedef struct 
{
    BOOL bContainResource;
    MD5_CTX ChecksumContext;
} CHECKSUM_ENUM_DATA;

void PrintError()
{
    LPTSTR lpMsgBuf;
    
    if (FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
    ))
    {
        printf("GetLastError():\n   %s", lpMsgBuf);
        LocalFree( lpMsgBuf );            
    }
    return;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  ChecksumEnumNamesFunc
//
//  The callback funciton for enumerating the resource names in the specified module and
//  type.
//  The side effect is that MD5 checksum context (contained in CHECKSUM_ENUM_DATA
//  pointed by lParam) will be updated.
//
//  Return:
//      Always return TRUE so that we can finish all resource enumeration.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK ChecksumEnumNamesFunc(HMODULE hModule, LPCTSTR lpType, LPTSTR lpName, LONG_PTR lParam){

    HRSRC hRsrc;
    HGLOBAL hRes;
    const unsigned char* pv;
    LONG ResSize=0L;
    WORD IdFlag=0xFFFF;

    DWORD dwHeaderSize=0L;
    CHECKSUM_ENUM_DATA* pChecksumEnumData = (CHECKSUM_ENUM_DATA*)lParam;   

    if(!(hRsrc=FindResourceEx(hModule, lpType, lpName,  RESOURCE_CHECKSUM_LANGID)))
    {
        //
        // If US English resource is not found for the specified type and name, we 
        // will continue the resource enumeration.
        //
        return (TRUE);
    }
    pChecksumEnumData->bContainResource = TRUE;

    if (!(ResSize=SizeofResource(hModule, hRsrc)))
    {
        printf("WARNING: Can not get resource size when generating resource checksum.\n");
        return (TRUE);
    }

    if (!(hRes=LoadResource(hModule, hRsrc)))
    {
        printf("WARNING: Can not load resource when generating resource checksum.\n");
        return (TRUE);
    }
    pv=(unsigned char*)LockResource(hRes);

    //
    // Update MD5 context using the binary data of this particular resource.
    //
    MD5Update(&(pChecksumEnumData->ChecksumContext), pv, ResSize);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  ChecksumEnumTypesFunc
//
//  The callback function for enumerating the resource types in the specified module.
//  This function will call EnumResourceNames() to enumerate all resource names of
//  the specified resource type.
//
//  Return:
//      TRUE if EnumResourceName() succeeds.  Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK ChecksumEnumTypesFunc(HMODULE hModule, LPSTR lpType, LONG_PTR lParam)
{
    CHECKSUM_ENUM_DATA* pChecksumEnumData = (CHECKSUM_ENUM_DATA*)lParam;
    //
    // Skip the version resource type, so that version is not included in the resource checksum.
    //
    if (lpType == RT_VERSION)
    {
        return (TRUE);
    }    
    
    if(!EnumResourceNames(hModule, (LPCSTR)lpType, ChecksumEnumNamesFunc, (LONG_PTR)lParam))
    {
        return (FALSE);
    }
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  GenerateResourceChecksum
//
//  Generate the resource checksum for the US English resource in the specified file.
//
//  Parameters:
//      pszSourceFileName   The file used to generate resource checksum.
//      pResourceChecksum   Pointer to a 16 bytes (128 bits) buffer for storing
//                          the calcuated MD5 checksum.
//  Return:
//      TURE if resource checksum is generated from the given file.  Otherwise FALSE.
//  
//  The following situation may return FALSE:
//      * The specified file does not contain resource.
//      * If the specified file contains resource, but the resource is not US English.
//      * The specified file only contains US English version resource.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL GenerateResourceChecksum(LPCSTR pszSourceFileName, unsigned char* pResourceChecksum)
{
    HMODULE hModule;
    ULONG i;

    DWORD dwResultLen;
    BOOL  bRet = FALSE;

    //
    // The stucture to be passed into the resource enumeration functions.
    //
    CHECKSUM_ENUM_DATA checksumEnumData;

    checksumEnumData.bContainResource = FALSE;

    //
    // Start MD5 checksum calculation by initializing MD5 context.
    //
    MD5Init(&(checksumEnumData.ChecksumContext));
    
    if (g_bVerbose)
    {
        printf("Generate resource checksum for [%s]\n", pszSourceFileName);
    }
    
    if(!(hModule = LoadLibraryEx(pszSourceFileName, NULL, DONT_RESOLVE_DLL_REFERENCES|LOAD_LIBRARY_AS_DATAFILE)))
    {
        if (g_bVerbose)
        {
            printf("\nERROR: Error in opening resource checksum module [%s]\n", pszSourceFileName);
        }
        PrintError();
        goto GR_EXIT;
    }

    if (g_bVerbose)
    {
        printf("\nLoad checksum file: %s\n", pszSourceFileName);
    }

    //
    //  Enumerate all resources in the specified module.
    //  During the enumeration, the MD5 context will be updated.
    //
    if (!EnumResourceTypes(hModule, ChecksumEnumTypesFunc, (LONG_PTR)&checksumEnumData))
    {
        if (g_bVerbose)
        {
            printf("\nWARNING: Unable to generate resource checksum from resource checksum module [%s]\n", pszSourceFileName);
        }
        goto GR_EXIT;
    }    

    if (checksumEnumData.bContainResource)
    {
        //
        // If the enumeration succeeds, and the specified file contains US English
        // resource, get the MD5 checksum from the accumulated MD5 context.
        //
        MD5Final(&checksumEnumData.ChecksumContext);

        memcpy(pResourceChecksum, checksumEnumData.ChecksumContext.digest, 16);

        if (g_bVerbose)
        {
            printf("Generated checksum: [");
            for (i = 0; i < MD5_CHECKSUM_SIZE; i++)
            {
                printf("%02x ", pResourceChecksum[i]);
            }
            printf("]\n");    
        }
        bRet = TRUE;
    }

GR_EXIT:
    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return (bRet);
}

void PrintUsage() 
{
    printf("muiver - Print out MUI resource checksum\n");
    printf("Usage:\n\n");
    printf("    muiver <US English file name>\n");
    
}

void PrintChecksum(BYTE* lpChecksum, int nSize) 
{
    int i;
    for (i = 0; i < nSize; i++) 
    {
        printf("%02x ", lpChecksum[i]);
    }
}

struct LANGANDCODEPAGE {
  WORD wLanguage;
  WORD wCodePage;
};

LPWSTR EmptyString = L"N/A";

LPWSTR GetFileVersionStringData(LPVOID pVerData, LANGANDCODEPAGE* pLang, LPWSTR pVersionDataType) 
{
    WCHAR subBlcok[256];
    LPVOID lpBuffer;    
    UINT dwBytes;
    
    wsprintfW( subBlcok, 
            L"\\StringFileInfo\\%04x%04x\\%s",
            pLang->wLanguage,
            pLang->wCodePage,
            pVersionDataType);

    // Retrieve file description for language and code page "i". 
    if (VerQueryValueW(pVerData, 
                subBlcok, 
                &lpBuffer, 
                &dwBytes)) {
        return ((LPWSTR)lpBuffer);                
    }
    
    return (EmptyString);
}

void PrintFileVersion(LPVOID pVerData) 
{
    UINT cbTranslate;

    LANGANDCODEPAGE  *lpTranslate;
    
    
    // Read the list of languages and code pages.

    VerQueryValueW(pVerData, 
                  L"\\VarFileInfo\\Translation",
                  (LPVOID*)&lpTranslate,
                  &cbTranslate);

    // Read the file description for each language and code page.

    for(UINT i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++)
    {
        wprintf(L"  Locale = 0x%04x, CodePage = %d\n", lpTranslate->wLanguage, lpTranslate->wCodePage);
        wprintf(L"    FileDescriptions: [%s", GetFileVersionStringData(pVerData, lpTranslate+i, L"FileDescription")); 
        wprintf(L"]\n");
        wprintf(L"    FileVersion     : [%s]\n", GetFileVersionStringData(pVerData, lpTranslate+i, L"FileVersion")); 
        wprintf(L"    ProductVersion  : [%s]\n", GetFileVersionStringData(pVerData, lpTranslate+i, L"ProductVersion")); 
        //wprintf(L"    Comments        : [%s]\n", GetFileVersionStringData(pVerData, lpTranslate+i, L"Comments")); 
    }

    BYTE* lpResourceChecksum;
    UINT cbResourceChecksum;

    wprintf(L"    ResourceChecksum: [");

    if (VerQueryValueW(pVerData,
                     L"\\VarFileInfo\\ResourceChecksum",
                     (LPVOID*)&lpResourceChecksum,
                     &cbResourceChecksum))
    {
        for (i = 0; i < cbResourceChecksum; i++) 
        {
            wprintf(L"%02x ", lpResourceChecksum[i]);
        }
    } else 
    {
        wprintf(L"n/a");
    }
    wprintf(L"]\n");

}

void PrintResult(LPSTR fileName, LPVOID pVerData, BYTE* pChecksum)
{
    printf("File: [%s]\n", fileName);
    printf("\nVersion information:\n");
    if (pVerData == NULL) 
    {
        printf("    !!! Not availabe.  Failed in GetFileVersionInfo()\n");
    } else 
    {
        PrintFileVersion(pVerData);
    }
    
    printf("\n\n  Resource Checksum:\n    ", fileName);
    if (pChecksum == NULL) 
    {
        printf("    n/a.  Probably resources for 0x%04x is not available.\n", RESOURCE_CHECKSUM_LANGID);
    } else 
    {    
        PrintChecksum(pChecksum, MD5_CHECKSUM_SIZE);
    }
    printf("\n");
}

int __cdecl main(int argc, char *argv[]){
    LPSTR pFileName;

    LPBYTE lpVerData = NULL;
    DWORD dwVerDataSize;
    DWORD dwHandle;

    BYTE MD5Checksum[MD5_CHECKSUM_SIZE];

    if (argc == 1) 
    {
        PrintUsage();
        return (1);
    }

    pFileName = argv[1];

    if (dwVerDataSize = GetFileVersionInfoSizeA(pFileName, &dwHandle)) 
    {
        lpVerData = new BYTE[dwVerDataSize];
        if (!GetFileVersionInfoA(pFileName, 0, dwVerDataSize, (LPVOID)lpVerData)) {
            lpVerData = NULL;
        }
    }

    if (GenerateResourceChecksum(pFileName, MD5Checksum))
    {
        PrintResult(pFileName, (LPVOID)lpVerData, MD5Checksum);
    } else 
    {
        PrintResult(pFileName, (LPVOID)lpVerData, NULL);    
    }
    

    if (!lpVerData)
    {
        delete [] lpVerData;
    }
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\resonexe\resonexe.c ===
/****************************************************************************/
/*                                                                          */
/*  resonexe.C -                                                            */
/*                                                                          */
/*    Windows DOS Version 3.2 add resource onto executable                  */
/*   (C) Copyright Microsoft Corporation 1988-1992                          */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include <windows.h>

#include <fcntl.h>
#include <io.h>
#include <stdlib.h>

#include "ntverp.h"
#include "rc.h"
#include "resonexe.h"

#define BUFSIZE 4096

//
// Globals
//

PUCHAR  szInFile=NULL;
BOOL    fDebug = FALSE;
BOOL    fVerbose = FALSE;
BOOL    fReplace = FALSE;
BOOL    fDelete = FALSE;
int     fhBin = -1;
UCHAR	szType[256];
UCHAR	szName[256];
int	idLang;
int	idType=0;
int	idName=0;

void
usage ( int rc );

void
usage ( int rc )
{
#if DBG
    printf("Microsoft (R) Windows RESONEXE Version %s\n", VER_PRODUCTVERSION_STR);
#else
    printf("Microsoft (R) Windows RESONEXE Version %s.%d\n", VER_PRODUCTVERSION_STR, VER_PRODUCTBUILD);
#endif /* dbg */
    printf("Copyright (C) Microsoft Corp. 1991-1992.  All rights reserved.\n\n");
    printf( "usage: resonexe [-v] [-r|-x resspec] [-fo outfile] <input file> [<exe file>]\n");
    printf( "       where  input file is an WIN32 .RES file\n");
    printf( "              -v verbose - print info\n");
    printf( "              -d debug - print debug info\n");
    printf( "              -r replace - delete all resource from input file before adding new resources.\n");
    printf( "              -x delete - delete specified resource from input file.\n");
    printf( "              resspec is of the form: typeid,nameid,langid\n");
    printf( "              typeid is a string or decimal number\n");
    printf( "              nameid is a string or decimal number\n");
    printf( "              langid is a hexadecimal number\n");
    printf( "              outfile is the desired output file name.\n");
    printf( "                      outfile defaults to filespec.exe.\n");
    printf( "              exe file is the exe file to attach resources to.\n");
    exit(rc);
}

void
__cdecl main(
    IN int argc,
    IN char *argv[]
    )

/*++

Routine Description:

    Determines options
    locates and opens input files
    reads input files
    writes output files
    exits

Exit Value:

        0 on success
        1 if error

--*/

{
    int         i;
    UCHAR       *s1;
    UCHAR       *szOutFile=NULL;
    UCHAR       *szExeFile=NULL;
    long        lbytes;
    BOOL        result;
    HANDLE      hupd;

    if (argc == 1) {
        usage(0);
        }

    for (i=1; i<argc; i++) {
        s1 = argv[i];
        if (*s1 == '/' || *s1 == '-') {
            s1++;
            if (!_stricmp(s1, "fo")) {
                szOutFile = argv[++i];
	    }
            else if (!_stricmp(s1, "d")) {
                fDebug = TRUE;
	    }
            else if (!_stricmp(s1, "v")) {
                fVerbose = TRUE;
	    }
            else if (!_stricmp(s1, "r")) {
                fReplace = TRUE;
	    }
            else if (!_stricmp(s1, "x")) {
                fDelete = TRUE;
		if (i+1 == argc)
		    usage(1);
		s1 = argv[++i];
		if (sscanf(s1, "%d,%d,%x", &idType, &idName, &idLang) == 3)
		    continue;
		idType = 0;
		idName = 0;
		if (sscanf(s1, "%d,%[^,],%x", &idType, szName, &idLang) == 3)
		    continue;
		idType = 0;
		idName = 0;
		if (sscanf(s1, "%[^,],%d,%x", szType, &idName, &idLang) == 3)
		    continue;
		idType = 0;
		idName = 0;
		if (sscanf(s1, "%[^,],%[^,],%x", szType, szName, &idLang) == 3)
		    continue;
		printf("Unrecognized type,name,lang triplet <%s>\n", s1);
		usage(1);
	    }
            else if (!_stricmp(s1, "h")) {
                usage(1);
	    }
            else if (!_stricmp(s1, "?")) {
                usage(1);
	    }
            else {
                usage(1);
	    }
	}
        else if (szInFile == NULL) {
            szInFile = s1;
	}
        else {
            szExeFile = s1;
        }
    }
    //
    // Make sure that we actually got a file
    //

    if (fDelete) {
	if (fReplace) {
	    printf("usage error:  Can't do both Replace and Delete\n");
	    usage(1);
	}
	if (!szInFile) {
	    printf("usage error:  Missing exe file spec\n");
	    usage(1);
	}
	if (szInFile && !szExeFile) {
	    szExeFile = szInFile;
	    if (!szOutFile)
		szOutFile = _strdup(szInFile);
	    szInFile = NULL;
	if (idType == 0)
	    _strupr(szType);
	if (idName == 0)
	    _strupr(szName);
	}
    }
    else if (!szInFile) {
	printf("usage error:  Must have file spec\n");
        usage(1);
    }

    if (fVerbose || fDebug) {
#if DBG
    printf("Microsoft (R) Windows RESONEXE Version %s\n", VER_PRODUCTVERSION_STR);
#else
    printf("Microsoft (R) Windows RESONEXE Version %s.%d\n", VER_PRODUCTVERSION_STR, VER_PRODUCTBUILD);
#endif /* dbg */
        printf("Copyright (C) Microsoft Corp. 1991-1992.  All rights reserved.\n\n");
    }


    if (szInFile && (fhBin = _open( szInFile, O_RDONLY|O_BINARY )) == -1) {
        /*
         *  try adding a .RES extension.
         */
        s1 = MyAlloc(strlen(szInFile) + 4 + 1);
        strcpy(s1, szInFile);
        szInFile = s1;
        strcat(szInFile, ".RES");
        if ((fhBin = _open( szInFile, O_RDONLY|O_BINARY )) == -1) {
            pehdr();
            printf("Cannot open %s for reading.\n", szInFile);
            exit(1);
        }
#if DBG
	printf("Reading %s\n", szInFile);
#endif /* DBG */
    }

    if (fhBin != -1) {
	lbytes = MySeek(fhBin, 0L, SEEK_END);
	MySeek(fhBin, 0L, SEEK_SET);
    }

    if (szExeFile == NULL) {
        /*
         * Make exefile = infile.exe
         */
        szExeFile = MyAlloc(strlen(szInFile) + 4 + 1);
        strcpy(szExeFile, szInFile);
        s1 = &szExeFile[strlen(szExeFile) - 4];
        if (s1 < szExeFile)
            s1 = szExeFile;
        while (*s1) {
            if (*s1 == '.')
                break;
            s1++;
        }
        strcpy(s1, ".exe");
    }

    if (szOutFile == NULL) {
        /*
         * Make outfile = infile.exe
         */
        szOutFile = MyAlloc(strlen(szInFile) + 4 + 1);
        strcpy(szOutFile, szInFile);
        s1 = &szOutFile[strlen(szOutFile) - 4];
        if (s1 < szOutFile)
            s1 = szOutFile;
        while (*s1) {
            if (*s1 == '.')
                break;
            s1++;
        }
        strcpy(s1, ".exe");
    }
    else {
        /*
         * Make outfile = copyof(exefile)
         */
        if (CopyFile(szExeFile, szOutFile, FALSE) == FALSE) {
            pehdr();
            printf("RW1001: copy of %s to %s failed", szExeFile, szOutFile);
            _close(fhBin);
            exit(1);
        }
	SetFileAttributes(szOutFile, FILE_ATTRIBUTE_NORMAL);
    }

#if DBG
    printf("Writing %s\n", szOutFile);
#endif /* DBG */

    hupd = BeginUpdateResourceA(szOutFile, fReplace);
    if (hupd == NULL) {
        pehdr();
        printf("RW1001: unable to load %s\n", szOutFile);
        _close(fhBin);
        exit(1);
    }
    if (fDelete) {
	result = UpdateResourceA(hupd,
			idType!=0?(PCHAR)idType:szType,
			idName!=0?(PCHAR)idName:szName,
			idLang, NULL, 0);
	if (result == 0) {
	    pehdr();
	    if (idType) {
		if (idName)
		    printf("RW1004: unable to delete resource %d,%d,%x from %s, status:%d\n", idType, idName, idLang, szExeFile, GetLastError());
		else
		    printf("RW1004: unable to delete resource %d,%s,%x from %s, status:%d\n", idType, szName, idLang, szExeFile, GetLastError());
	    }
	    else {
		if (idName)
		    printf("RW1004: unable to delete resource %s,%d,%x from %s, status:%d\n", szType, idName, idLang, szExeFile, GetLastError());
		else
		    printf("RW1004: unable to delete resource %s,%s,%x from %s, status:%d\n", szType, szName, idLang, szExeFile, GetLastError());
	    }
            _close(fhBin);
	    exit(1);
	}
    }
    else {
	result = ReadRes(fhBin, lbytes, hupd);
	if (result == 0) {
	    pehdr();
	    printf("RW1002: unable to read resources from %s, status:%d\n", szInFile, GetLastError());
            _close(fhBin);
	    exit(1);
	}
    }
    result = EndUpdateResourceW(hupd, FALSE);
    if (result == 0) {
        pehdr();
        printf("RW1003: unable to write resources to %s, status:%d\n", szOutFile, GetLastError());
    }

    _close( fhBin );
    exit(result ? 0 : 1);
}


UCHAR*
MyAlloc(ULONG nbytes )
{
    UCHAR       *s;

    if ((s = (UCHAR*)calloc( 1, nbytes )) != NULL)
        return s;
    else {
        pehdr();
        printf( "Memory allocation, needed %u bytes\n", nbytes );
        exit(1);
    }
}


ULONG
MyRead(int fh, UCHAR*p, ULONG n )
{
    USHORT      n1;

    if ((n1 = _read( fh, p, n )) != n) {
        eprintf( "a file read error occured" );
        exit(1);
    }
    else
        return 0;
}


LONG
MySeek( int fh, long pos, int cmd )
{
    if ((pos = _lseek( fh, pos, cmd )) == -1) {
        eprintf( "seek error" );
        exit(1);
    }

    return pos;
}


ULONG
MoveFilePos( int fh, ULONG pos )
{
    return MySeek( fh, pos, SEEK_SET );
}


void
eprintf(
    UCHAR *s
    )
{
    pehdr();
    printf("%s.\n", s);
}

void
pehdr(
    )
{
    printf("RESONEXE: error - ");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\resonexe\resonexe.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    resonexe.h

Author:

    Floyd A Rogers 2/7/92

Revision History:

    2/7/92 floydr
        Created
--*/

#include <common.h>

/*  Global externs */

extern PUCHAR   szInFile;
extern BOOL     fDebug;
extern BOOL     fVerbose;
extern BOOL     fUnicode;

/* functions in main.c */

void    __cdecl main(int argc, char *argv[]);
PUCHAR  MyAlloc( ULONG nbytes );
PUCHAR  MyReAlloc(char *p, ULONG nbytes );
PUCHAR  MyFree( PUCHAR  );
ULONG   MyRead( int fh, PUCHAR p, ULONG n );
LONG    MyTell( int fh );
LONG    MySeek( int fh, long pos, int cmd );
ULONG   MoveFilePos( int fh, ULONG pos);
ULONG   MyWrite( int fh, PUCHAR p, ULONG n );
void    eprintf( PUCHAR s);
void    pehdr(void);
int     fcopy (char *, char *);

/* functions in read.c */

BOOL
ReadRes(
    IN int fhIn,
    IN ULONG cbInFile,
    IN HANDLE hupd
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\resonexe\test\test.c ===
int main (char**argv, int argc) { return 1;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\main.cpp ===
//////////////////////////////////////////////////////////////////////////
//
// This application will generate a localized binary given in input
// a source binary and two token files.
//
// The format of the token file is:
// [[TYPE ID|RES ID|Item ID|Flags|Status Flags|Item Name]]=
// this is the standar format used by several token file tools in MS.
//
///////////////////////////////////////////////////////////////////////////////
//
// Other DLL used: IODLL.DLL
//
///////////////////////////////////////////////////////////////////////////////
//
// Author: 	Alessandro Muti
// Date:	01-16-95
//
///////////////////////////////////////////////////////////////////////////////

#include <afx.h>

#include "main.h"
#include <iodll.h>
#include <winuser.h>
#include <ntverp.h>

//////////////////////////////////////////////////////////////////////////
#define BANNER   "Microsoft (R) 32-bit RLTools Version 3.5 (Build %d)\r\n"                     \
                 "Copyright (C) Microsoft Corp. 1991-1998. All Rights reserved.\r\n"\
                 "\r\n"                                                             \
                 "Binary file generator utility.\r\n\r\n"

#ifdef _DEBUG
#define BUILDSTAMP "Build:  " __DATE__ " " __TIME__ " ("  __TIMESTAMP__  ")\r\n\r\n"
#endif

// Need to split the help screen in two since it is too long.
// The good thing to do would be to put this string in a message table
// To be done...
char strHelp0[] =                                                                   \
"BINGEN [-w|n] [-h|?] [-b|s|f] [-p cp] [-{i|o} Pri Sub] [-d char]              \r\n"\
"       [-{t|u|r|a|x} files]                                                   \r\n"\
"                                                                              \r\n"\
"  -w                  (Show warning messages)                                 \r\n"\
"  -? or -h            (Show more complete help using winhelp)                 \r\n"\
"  -b                  (Extract bitmaps and icons)                             \r\n"\
"  -c                  (Extract embedded gifs, htmls, infs and other binaries) \r\n"\
"  -y                  (Extract Static Control alignment style)                \r\n"\
"  -l                  (Lean mode and do not append redundant resources)       \r\n"\
"  -s                  (Split Message table messages at \\n\\r)                \r\n"\
"  -f                  (Add/Use font information field for dialogs)            \r\n"\
"  -n                  (Nologo)                                                \r\n"\
"  -v                  (Ignore selected version stamp information)             \r\n"\
"  -p  CodePage        (Default code page of text in project token file)       \r\n"\
"  -d  Character       (Default for unmappable characters)                     \r\n"\
"                                                                              \r\n"\
"<<The commands -{t|r|a} are mutually exlusive>>                               \r\n"\
"  -t  InputExeFile  OutputTokenFile                                           \r\n"\
"                      (Extract token file)                                    \r\n"\
"  -u  InputExeFile  InputUSTokFile  InputLOCTokFile  OutputExeFile            \r\n"\
"                      (Replace old lang resources with localized tokens)      \r\n"\
"  -r  InputExeFile  InputLOCTokFile  OutputExeFile                            \r\n"\
"                      (Replace old lang resources with localized tokens)      \r\n"\
"                      (Doesn't perform any consistency check)                 \r\n"\
"  -a  InputExeFile  InputLOCTokFile  OutputExeFile                            \r\n"\
"                      (Append resources in localized tokens)                  \r\n"\
"                                                                              \r\n";
char strHelp1[] =                                                                   \
"<<Default language is always NEUTRAL>>                                        \r\n"\
"  -i  PriLangId SecLangId (Primary- and Sub-Lang IDs, dec/hex, Input file)    \r\n"\
"  -o  PriLangId SecLangId (Primary- and Sub-Lang IDs, dec/hex, Output file)   \r\n"\
"                                                                              \r\n"\
"  -x  InputRuleFile   (Pseudo translation options)                            \r\n"\
"  -m  InputSymbolPath OutputSymbolPath                                        \
                       (Update symbol checksum if neccesory)                   \r\n";

//////////////////////////////////////////////////////////////////////////

CMainApp::CMainApp()
{
    m_dwFlags = NO_OPTION;
    m_dwReturn = ERROR_NO_ERROR;

    m_StdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    m_StdError = GetStdHandle(STD_ERROR_HANDLE);

    // Check if we have being piped to a file
    BY_HANDLE_FILE_INFORMATION HndlFileInfo;
    if(GetFileInformationByHandle(m_StdOutput, &HndlFileInfo) ||
       GetFileInformationByHandle(m_StdError, &HndlFileInfo))
        m_dwFlags |= PIPED;

    m_strBuffer1 = "";
    m_strBuffer2 = "";

    m_pBuf = new BYTE[MAX_BUF_SIZE];

    m_wIDNotFound = 0;
    m_wCntxChanged = 0;
    m_wResized = 0;

    //
    // Set default values for Language
    //

    m_usIPriLangId = -1;
    m_usISubLangId = -1;

    m_usOPriLangId = -1;
    m_usOSubLangId = -1;

    m_uiCodePage = GetACP();

    m_unmappedChar = '?';
    m_strSymPath = "";
    m_strOutputSymPath = "";
}

CMainApp::~CMainApp()
{
    if(m_pBuf)
        delete m_pBuf;
}

//////////////////////////////////////////////////////////////////////////

CMainApp::Error_Codes CMainApp::ParseCommandLine(int argc, char ** argv)
{
    char * pArgument;
    int count = 0;

    if(argc==1)
        m_dwFlags |= HELP;

    while(++count<argc)
    {
        pArgument = argv[count];
        if(*pArgument=='/' || *pArgument=='-')
        {
            while(*(++pArgument))
            {
                switch(*pArgument)
                {
                    case 'a':   // Append resources
                    case 'A':
                    {
                        //Make sure no other conflicting flags are specified
                        if(IsFlag(REPLACE) | IsFlag(UPDATE) | IsFlag(EXTRACT))
                        {
                            Banner();
                            WriteCon(CONERR, "Please use -a without the -r, -u or -t option!");
                            return ERR_COMMAND_LINE;
                        }

                        // Make sure none of the next item is another option

                        for(int c=1; c<=3; c++)
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Not enough parameters specified for the -a option\r\n"\
                                                 "  -a  InputExeFile  InputLOCTokFile  OutputExeFile\r\n");
                                return ERR_COMMAND_LINE;
                            };

                        m_dwFlags |= APPEND;

                        // Get the input EXE file name
                        m_strInExe = argv[++count];

                        // Get the target token file name
                        m_strTgtTok = argv[++count];

                        // Get the output EXE file name
                        m_strOutExe = argv[++count];
                    }
                    break;
                    case 'b':
                    case 'B':
                        m_dwFlags |= BITMAPS;
                    break;
                    case 'd':
                    case 'D':   // Default  for unmappable characters
                        m_unmappedChar = argv[++count][0];
                    break;
                    case 'f':
                    case 'F':
                        m_dwFlags |= FONTS;
                    break;
                    case 'c':
                    case 'C':
                        m_dwFlags |= GIFHTMLINF;
                    break;
                    case '?':   // Help
                    case 'h':
                    case 'H':
                        m_dwFlags |= HELP;
                    break;
                    case 'i':   // Input language/sublanguage
                    case 'I':
                        m_dwFlags |= INPUT_LANG;
                        m_usIPriLangId = GetLangID(argv[++count]);
                        m_usISubLangId = GetLangID(argv[++count]);
                    break;
                    case 'l':
                    case 'L':
                    {
                        m_dwFlags |= LEANAPPEND;
                    break;
                    }
                    case 'm':
                    case 'M':
                    {
                        for(int c=1; c<=2; c++)
                        {
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Please specify Input and Output Symbol Paths.\r\n");
                                return ERR_COMMAND_LINE;
                            }
                        }
                        m_strSymPath = argv[++count];
                        m_strOutputSymPath = argv[++count];
                    }
                    break;
                    case 'n':
                    case 'N':
                        m_dwFlags |= NOLOGO;
                    break;
                    case 'o':   // Output language/sublanguage
                    case 'O':
                        m_dwFlags |= OUTPUT_LANG;
                        m_usOPriLangId = GetLangID(argv[++count]);
                        m_usOSubLangId = GetLangID(argv[++count]);
                    break;
                    case 'p':   // Code page
                    case 'P':
                        m_uiCodePage = GetCodePage(argv[++count]);
                    break;
                    case 'r':   // Replace resources
                    case 'R':
                    {
                        //Make sure no other conflicting flags are specified
                        if(IsFlag(APPEND) | IsFlag(EXTRACT) | IsFlag(UPDATE))
                        {
                            Banner();
                            WriteCon(CONERR, "Please use -r without the -a, -u or -t option!");
                            return ERR_COMMAND_LINE;
                        }

                        // Make sure none of the next item is another option
                        for(int c=1; c<=3; c++)
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Not enough parameters specified for the -r option\r\n"\
                                                 "  -r  InputExeFile  InputLOCTokFile  OutputExeFile\r\n");
                                return ERR_COMMAND_LINE;
                            };

                        m_dwFlags |= REPLACE;

                        // Get the input EXE file name
                        m_strInExe = argv[++count];

                        // Get the target token file name
                        m_strTgtTok = argv[++count];

                        // Get the output EXE file name
                        m_strOutExe = argv[++count];
                    }
                    break;
                    case 'u':   // Update resources
                    break;
                    case 's':
                    case 'S':
                        m_dwFlags |= SPLIT;
                    break;
                    case 't':   // Create token file
                    case 'T':
                    {
                        //Make sure no other conflicting flags are specified
                        if(IsFlag(APPEND) | IsFlag(REPLACE) | IsFlag(UPDATE))
                        {
                            Banner();
                            WriteCon(CONERR, "Please use -t without the -a, -u, or -r option!");
                            return ERR_COMMAND_LINE;
                        }

                        // Make sure none of the next item is another option
                        for(int c=1; c<=2; c++)
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Not enough parameters specified for the -t option\r\n"\
                                                 "  -t  InputExeFile  OutputTokenFile\r\n");
                                return ERR_COMMAND_LINE;
                            };

                        m_dwFlags |= EXTRACT;

                        // Get the input EXE file name
                        m_strInExe = argv[++count];

                        // Get the target token file name
                        m_strTgtTok = argv[++count];
                    }
                    break;
                    case 'U':
                    {
                        //Make sure no other conflicting flags are specified
                        if(IsFlag(APPEND) | IsFlag(EXTRACT) | IsFlag(REPLACE))
                        {
                            Banner();
                            WriteCon(CONERR, "Please use -u without the -a, -r or -t option!");
                            return ERR_COMMAND_LINE;
                        }

                        // Make sure none of the next item is another option
                        for(int c=1; c<=4; c++)
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Not enough parameters specified for the -u option\r\n"\
                                                 "  -u  InputExeFile  InputUSTokFile  InputLOCTokFile  OutputExeFile\r\n");
                                return ERR_COMMAND_LINE;
                            };

                        m_dwFlags |= UPDATE;

                        // Get the input EXE file name
                        m_strInExe = argv[++count];

                        // Get the source token file name
                        m_strSrcTok = argv[++count];

                        // Get the target token file name
                        m_strTgtTok = argv[++count];

                        // Get the output EXE file name
                        m_strOutExe = argv[++count];
                    }
                    break;
                    case 'v':   // Display warnings
                    case 'V':
                        m_dwFlags |= NOVERSION;
                    break;
                    case 'w':   // Display warnings
                    case 'W':
                        m_dwFlags |= WARNING;
                    break;
                    case 'y':
                    case 'Y':
                        m_dwFlags |= ALIGNMENT;
                    break;
                    default:
                    break;
                }
            }
        }
    }
    // Do we want the banner
    if(!IsFlag(NOLOGO))
        Banner();
	
    // Before exiting make sure we display the help screen if requested
    if(IsFlag(HELP))
    {
        Help();
        return ERR_HELP_CHOOSE;
    }

    // Check if the code page we have is installed in this system
    if(!IsValidCodePage(m_uiCodePage))
    {
        // Warn the user and get back the default CP
        m_uiCodePage = GetACP();
        WriteCon(CONERR, "The code page specified is not installed in the system or is invalid! Using system default!\r\n");
    }

    // Make sure the input file is there
    CFileStatus fs;
    if(!m_strInExe.IsEmpty())
    {
        if(!CFile::GetStatus(m_strInExe, fs))
        {
            WriteCon(CONERR, "File not found: %s\r\n", m_strInExe);
            return ERR_FILE_NOTFOUND;
        }
    }

    // Check if the tgt token file or exe are read only
    if(!m_strOutExe.IsEmpty())
    {
        if(CFile::GetStatus(m_strOutExe, fs))
        {
            if((fs.m_attribute & 0x1)==0x1)
            {
                WriteCon(CONERR, "File is read only: %s\r\n", m_strOutExe);
                return ERR_FILE_CREATE;
            }
        }
    }

    if(!m_strTgtTok.IsEmpty() && IsFlag(EXTRACT))
    {
        if(CFile::GetStatus(m_strTgtTok, fs))
        {
            if((fs.m_attribute & 0x1)==0x1)
            {
                WriteCon(CONERR, "File is read only: %s\r\n", m_strTgtTok);
                return ERR_FILE_CREATE;
            }
        }
    }

    //
    // Check the value specified for the output language.
    // If none has been specified, warn the user and default to neutral.
    //
    if(IsFlag(APPEND) | IsFlag(REPLACE))
    {
        if(m_usOPriLangId==-1)
        {
            m_usOPriLangId = LANG_NEUTRAL; // set the PRI language ID to neutral
            WriteCon(CONERR, "Output language ID not specified, default to neutral(%d)\r\n", m_usOPriLangId);
        }

        if(m_usOSubLangId==-1)
        {
            m_usOSubLangId = SUBLANG_NEUTRAL; // set the SEC language ID to neutral
            WriteCon(CONERR, "Output sub-language ID not specified, default to neutral(%d)\r\n", m_usOSubLangId);
        }
    }

    WriteCon(CONWRN, "Code Page              : %d\r\n", m_uiCodePage);
    WriteCon(CONWRN, "In  Primary Language   : %d (%d)\r\n", m_usIPriLangId, MAKELANGID(m_usIPriLangId,m_usISubLangId));
    WriteCon(CONWRN, "In  Secondary Language : %d (0x%x)\r\n", m_usISubLangId, MAKELANGID(m_usIPriLangId,m_usISubLangId));
    WriteCon(CONWRN, "Out Primary Language   : %d (%d)\r\n", m_usOPriLangId, MAKELANGID(m_usOPriLangId,m_usOSubLangId));
    WriteCon(CONWRN, "Out Secondary Language : %d (0x%x)\r\n", m_usOSubLangId, MAKELANGID(m_usOPriLangId,m_usOSubLangId));
    WriteCon(CONWRN, "Default unmapped char  : %c \r\n", m_unmappedChar);

    return ERR_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper start

void CMainApp::Banner()
{
    WriteCon(CONOUT, BANNER, VER_PRODUCTBUILD);
    #ifdef _DEBUG
        WriteCon(CONOUT, BUILDSTAMP);
    #endif
}

void CMainApp::Help()
{
    WriteCon(CONOUT, strHelp0);
    WriteCon(CONOUT, strHelp1);
}

CString CMainApp::CalcTab(CString str, int tablen, char ch)
{
    for(int i = tablen-str.GetLength();i>0;i--)
        str += (char)ch;

    return str.GetBuffer(0);
}

int __cdecl CMainApp::WriteCon(int iFlags, const char * lpstr, ...)
{
    DWORD dwWritten;

    va_list ptr;

    va_start(ptr, lpstr);
    _vsnprintf(m_strBuffer1.GetBuffer(MAX_STR_SIZE), MAX_STR_SIZE, lpstr, ptr);

    m_strBuffer1.ReleaseBuffer();

    // Check if we want to have the handle sent to both out and err
    if((iFlags==CONBOTH) && (IsFlag(PIPED)))
    {
        WriteFile(m_StdError, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);
        WriteFile(m_StdOutput, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);
        return dwWritten;
    }

    if((iFlags==CONWRN))
    {
        if(IsFlag(WARNING))
            WriteFile(m_StdError, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);
        return dwWritten;
    }

    if(iFlags==CONERR)
        WriteFile(m_StdError, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);
    else
        WriteFile(m_StdOutput, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);

    return dwWritten;
}

int CMainApp::SetReturn(int rc)
        { return (m_dwReturn = rc); }

////////////////////////////////////////////////
// Will convert the string strNum in to a short
USHORT CMainApp::GetLangID(CString strNum)
{
    strNum.MakeUpper();
    // If is there is any of this char "ABCDEFX" assume is an hex number
    return LOWORD(strtol(strNum, NULL, ((strNum.FindOneOf("ABCDEFX")!=-1) ? 16:10)));
}

UINT CMainApp::GetCodePage(CString strNum)
{
    strNum.MakeUpper();
    // If is there is any of this char "ABCDEFX" assume is an hex number
    return strtol(strNum, NULL, ((strNum.FindOneOf("ABCDEFX")!=-1) ? 16:10));
}

#ifdef NOSLASH
LPCSTR CMainApp::Format(CString strTmp)
{
    int iPos;
    char * pStr = strTmp.GetBuffer(0);
    char * pStrStart = pStr;
    int i = 0;

    m_strBuffer2 = strTmp;

    while((pStr = strchr(pStr, '\\')))
    {
        iPos = pStr++ - pStrStart + i++;
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\\\" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-1);
    }

    while((iPos = m_strBuffer2.Find('\t'))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\t" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-1);

    while((iPos = m_strBuffer2.Find('\n'))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\n" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-1);

    while((iPos = m_strBuffer2.Find('\r'))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\r" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-1);

    return m_strBuffer2;
}

LPCSTR CMainApp::UnFormat(CString strTmp)
{
    int iPos;
    char * pStr = strTmp.GetBuffer(0);
    char * pStrStart = pStr;
    int i = 0;

    m_strBuffer2 = strTmp;

    while((pStr = strstr(pStr, "\\\\")))
    {
        iPos = pStr - pStrStart - i++; pStr += 2;
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-2);
    }

    while((iPos = m_strBuffer2.Find("\\t"))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\t" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-2);

    while((iPos = m_strBuffer2.Find("\\n"))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\n" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-2);

    while((iPos = m_strBuffer2.Find("\\r"))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\r" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-2);

    return m_strBuffer2;
}
#endif

LPCSTR CMainApp::Format(CString strTmp)
{
    char * pStr = strTmp.GetBuffer(0);
    char * pDest = m_strBuffer2.GetBuffer(MAX_STR_SIZE);
    char * pNext;


    while(*pStr)
    {
        if(!IsDBCSLeadByteEx(m_uiCodePage, *pStr))
        {
            switch(*pStr)
            {
                case '\\':
                    *pDest++ = '\\';
                    *pDest++ = '\\';
                    break;
                case '\t':
                    *pDest++ = '\\';
                    *pDest++ = 't';
                    break;
                case '\r':
                    *pDest++ = '\\';
                    *pDest++ = 'r';
                    break;
                case '\n':
                    *pDest++ = '\\';
                    *pDest++ = 'n';
                    break;
                default:
                    *pDest++ = *pStr;
                    break;
            }
        }
        else {
            memcpy( pDest, pStr, 2 );
            pDest += 2;
        }

        pStr = CharNextExA((WORD)m_uiCodePage, pStr, 0);
    }

    *pDest = '\0';

    m_strBuffer2.ReleaseBuffer(-1);

    return m_strBuffer2;
}

LPCSTR CMainApp::UnFormat(CString strTmp)
{
    m_strBuffer2 = strTmp;

    int i = m_strBuffer2.GetLength();
    char * pStr = m_strBuffer2.GetBuffer(0);
    char * pNext;


    while(*pStr)
    {
        if(*pStr=='\\' && !IsDBCSLeadByteEx(m_uiCodePage, *pStr))
        {
            pNext = CharNextExA((WORD)m_uiCodePage, pStr, 0);
            switch(*pNext)
            {
                case '\\':
                    *pStr = '\\';
                    break;
                case 't':
                    *pStr = '\t';
                    break;
                case 'n':
                    *pStr = '\n';
                    break;
                case 'r':
                    *pStr = '\r';
                    break;
                default:
                    break;
            }

            pStr = pNext;
            pNext = CharNextExA((WORD)m_uiCodePage, pNext, 0);
            memmove(pStr, pNext, --i);

        }
        else
        {
            //DBCS shorten length by 2
            if (IsDBCSLeadByteEx(m_uiCodePage, *pStr))
                i-=2;
            else
                i--;
            pStr = CharNextExA((WORD)m_uiCodePage, pStr, 0);
        }
    }

    m_strBuffer2.ReleaseBuffer(-1);

    return m_strBuffer2;
}


int CMainApp::IoDllError(int iError)
{
    CString str = "";

    switch (iError) {
    case 0:                                                                     break;
    case ERROR_HANDLE_INVALID:          str = "Invalid handle.";                break;
    case ERROR_READING_INI:             str = "Error reading WIN.INI file.";    break;
    case ERROR_NEW_FAILED:              str = "Running low on memory.";         break;
    case ERROR_FILE_OPEN:               str = "Error opening file.";            break;
    case ERROR_FILE_CREATE:             str = "Error creating file.";           break;
    case ERROR_FILE_INVALID_OFFSET:     str = "File corruption detected.";      break;
    case ERROR_FILE_READ:               str = "Error reading file.";            break;
    case ERROR_DLL_LOAD:                str = "Error loading R/W DLL.";         break;
    case ERROR_DLL_PROC_ADDRESS:        str = "Error loading R/W procedure.";   break;
    case ERROR_RW_LOADIMAGE:            str = "Error loading R/W image.";       break;
    case ERROR_RW_PARSEIMAGE:           str = "Error parsing R/W image.";       break;
    case ERROR_RW_NOTREADY:             str = "Error:  R/W not ready?";         break;
    case ERROR_RW_BUFFER_TOO_SMALL:     str = "Running low on memory?";         break;
    case ERROR_RW_INVALID_FILE:         str = "Invalid R/W file.";              break;
    case ERROR_RW_IMAGE_TOO_BIG:        str = "Can't load HUGE image.";         break;
    case ERROR_RW_TOO_MANY_LEVELS:      str = "Resource directory too deep.";   break;
    case ERROR_RW_NO_RESOURCES:         str = "This file contains no resources.";
break;
    case ERROR_IO_INVALIDITEM:          str = "Invalid resource item.";         break;
    case ERROR_IO_INVALIDID:            str = "Invalid resource ID.";           break;
    case ERROR_IO_INVALID_DLL:          str = "Unrecognized file format.";      break;
    case ERROR_IO_TYPE_NOT_SUPPORTED:   str = "Type not supported.";            break;
    case ERROR_IO_INVALIDMODULE:        str = "Invalid module.";                break;
    case ERROR_IO_RESINFO_NULL:         str = "ResInfo is NULL?";               break;
    case ERROR_IO_UPDATEIMAGE:          str = "Error updating image.";          break;
    case ERROR_IO_FILE_NOT_SUPPORTED:   str = "File not supported.";            break;
    case ERROR_IO_CHECKSUM_MISMATCH:    str = "Symbol file checksum mismatch.";
break;
    case ERROR_IO_SYMBOLFILE_NOT_FOUND: str = "Symbol file not found.";
break;
    case ERROR_FILE_SYMPATH_NOT_FOUND:  str = "Output symbol path not found.";
break;
    case ERROR_RW_VXD_MSGPAGE:
        str  = "The specified VxD file contains a message page as its";
        str += " last page.  This may cause the VxD not to work.  Please";
        str += " inform the development team of the problem with this file.";
        break;
    case ERROR_OUT_OF_DISKSPACE:        str = "Out of disk space.";             break;
    case ERROR_RES_NOT_FOUND:           str = "Resource not found.";            break;

    default:
        if(iError-LAST_ERROR>0)
        {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
        			NULL,
        			iError-LAST_ERROR,
        			MAKELANGID(LANG_NEUTRAL,LANG_NEUTRAL),
        			str.GetBuffer(1024),
        			1024,
           			NULL);
            str.ReleaseBuffer();
        }
    break;
    }

    if (!str.IsEmpty())
    {
        WriteCon(CONERR, "%s: %s\r\n", (iError < LAST_WRN) ? "IODLL Warning" : "IODLL Error", str);
        SetReturn(iError);
    }

    return iError;
}

// Helper end
/////////////////////////////////////////////////////////////////////////////////////////////////////

CMainApp::Error_Codes CMainApp::GenerateFile()
{
    Error_Codes bRet;

    // Before we procede let's give the global info to the IODLL
    SETTINGS settings;

    settings.cp = m_uiCodePage;
    settings.bAppend = IsFlag(APPEND);
    settings.bUpdOtherResLang = TRUE;  //we save this option for future
    settings.szDefChar[0] = m_unmappedChar; settings.szDefChar[1] = '\0';
    RSSetGlobals(settings);

    // Here we decide what is the action we have to take
    if(IsFlag(EXTRACT))
    {
        // we want to generate a token file
        bRet = TokGen();
    }
    else if(IsFlag(APPEND) | IsFlag(REPLACE) | IsFlag(UPDATE) )
    {
        // we want to generate a binary
        bRet = BinGen();
    }

    return bRet;
}

// Main application
CMainApp theApp;

//////////////////////////////////////////////////////////////////////////
int _cdecl main(int argc, char** argv)
{
    if(theApp.ParseCommandLine(argc, argv)){
        return theApp.ReturnCode();
    }

    theApp.GenerateFile();
    return theApp.ReturnCode();
}
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\bingen.cpp ===
//////////////////////////////////////////////////////////////////////////
//
// The format of the token file is:
// [[TYPE ID|RES ID|Item ID|Flags|Status Flags|Item Name]]=
// this is the standar format used by several token file tools in MS.
//
///////////////////////////////////////////////////////////////////////////////
//
// Author: 	Alessandro Muti
// Date:	12/02/94
//
///////////////////////////////////////////////////////////////////////////////


#include <afx.h>
#include "iodll.h"
#include "main.h"
#include "token.h"
#include "vktbl.h"
#include "imagehlp.h"

extern CMainApp theApp;

/*******************************************************\
 This is the part were the real code starts.
 The function Bingen generate a binary from a token file.
 If the user select the -u options then we perform a
 token checking otherwise we'll be compatible with RLMAN
 and just trust the ID.
\*******************************************************/

CMainApp::Error_Codes CMainApp::BinGen()
{
    Error_Codes iErr = ERR_NOERROR;
    CTokenFile m_tokenfile;
    CToken * pToken;

    iErr = (CMainApp::Error_Codes)m_tokenfile.Open(m_strSrcTok, m_strTgtTok);

    if(iErr) {
        return iErr;
    }

    WriteCon(CONERR, "%s\r\n", CalcTab("", 79, '-'));

    // Copy the Src binary over the target
    // Now we can go and open an handle to the SrcExe file
    HANDLE hModule = RSOpenModule(m_strInExe, NULL);
    if ((int)(UINT_PTR)hModule < LAST_ERROR) {
            // error or warning
            WriteCon(CONERR, "%s", CalcTab(m_strInExe, m_strInExe.GetLength()+5, ' '));
            IoDllError((int)(UINT_PTR)hModule);
            return ERR_FILE_NOTSUPP;
    } else {
        LPCSTR lpszType = 0L;
        LPCSTR lpszRes = 0L;
        DWORD  dwLang = 0L;
        DWORD  dwItem = 0L;
        DWORD  dwItemId;
        LPRESITEM lpResItem = NULL;
        CString strResName = "";

        BOOL bSkip;
		BOOL bSkipLang = FALSE;
        WORD wCount = 0;

        CString strFaceName;
        WORD    wPointSize;
        BYTE    bCharSet;

        // before we do anything else we have to check how many languages we have in the file
        CString strLang;
        char szLang[8];
        BOOL b_multi_lang = FALSE;
        USHORT usInputLang = MAKELANGID(m_usIPriLangId, m_usISubLangId);

        if((b_multi_lang = RSLanguages(hModule, strLang.GetBuffer(1024))) && !IsFlag(INPUT_LANG))
        {
            // this is a multiple language file but we don't have an input language specified
            // Fail, but warn the user that he has to set the input language to continue.
            strLang.ReleaseBuffer();
            theApp.SetReturn(ERROR_FILE_MULTILANG);
            WriteCon(CONERR, "Multiple language file. Please specify an input language %s.\r\n", strLang);
            goto exit;
        }

        strLang.ReleaseBuffer();

        // Convert the language in to the hex value
        if (usInputLang)
            sprintf(szLang,"0x%3X", usInputLang);
        else
            sprintf(szLang,"0x000");

        // Check if the input language that we got is a valid one
        if(IsFlag(INPUT_LANG) && strLang.Find(szLang)==-1)
        {
            WriteCon(CONERR, "The language %s in not a valid language for this file.\r\n", szLang);
            WriteCon(CONERR, "Valid languages are: %s.\r\n", strLang);
            theApp.SetReturn(ERROR_RES_NOT_FOUND);
            goto exit;
        }

        CString strFileName = m_strInExe;
        CString strFileType;
        CString strTokenDir = "";
        int pos = m_strInExe.ReverseFind('\\');
        if(pos!=-1)
        {
            strFileName = m_strInExe.Right(m_strInExe.GetLength()-pos-1);
        }
        else
        if((pos = m_strInExe.ReverseFind(':'))!=-1)
        {
            strFileName = m_strInExe.Right(m_strInExe.GetLength()-pos-1);
        }

        pos = m_strTgtTok.ReverseFind('\\');
        if(pos==-1)
            pos = m_strTgtTok.ReverseFind(':');

        if(pos!=-1)
            strTokenDir = m_strTgtTok.Left(pos+1);

        if (m_strSymPath[0] && m_strSymPath != m_strOutputSymPath)
        {
            CString strInDebugFile;
            CString strOutDebugFile;

            HANDLE hDebugFile = FindDebugInfoFile(
                                    strFileName.GetBuffer(MAX_PATH),
                                    m_strSymPath.GetBuffer(MAX_PATH),
                                    strInDebugFile.GetBuffer(MAX_PATH)
                                    );
            strInDebugFile.ReleaseBuffer();
            if ( hDebugFile == NULL ) {
                return (Error_Codes)IoDllError(ERROR_IO_SYMBOLFILE_NOT_FOUND);
            }
            CloseHandle(hDebugFile);

            strOutDebugFile = m_strOutputSymPath + strInDebugFile.Right(strInDebugFile.GetLength()-m_strSymPath.GetLength());

            if (!CopyFile(strInDebugFile.GetBuffer(MAX_PATH), strOutDebugFile.GetBuffer(MAX_PATH),FALSE))
            {
                CString strTmp;
                strTmp = strOutDebugFile.Left(strOutDebugFile.GetLength()-strFileName.GetLength()-1);

                CreateDirectory(strTmp.GetBuffer(MAX_PATH),NULL);

                if (!CopyFile(strInDebugFile.GetBuffer(MAX_PATH), strOutDebugFile.GetBuffer(MAX_PATH),FALSE))
                {
                    return (Error_Codes)IoDllError(ERROR_FILE_SYMPATH_NOT_FOUND);
                }
            }
        }

        WriteCon(CONOUT, "Processing\t");
        WriteCon(CONBOTH, "%s", CalcTab(strFileName, strFileName.GetLength()+5, ' '));
        RSFileType(m_strInExe, strFileType.GetBuffer(10));
        strFileType.ReleaseBuffer();
        WriteCon(CONBOTH, "%s", CalcTab(strFileType, strFileType.GetLength()+5, ' '));
        if(IsFlag(WARNING))
            WriteCon(CONBOTH, "\r\n");

        while ((lpszType = RSEnumResType(hModule, lpszType)))
        {
            // Check if is one of the type we care about
            if(HIWORD(lpszType)==0)
                switch(LOWORD(lpszType))
                {
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 14:
                    case 16:
                    case 23:
                    case 240:
                    case 1024:
                    case 2110:
                        bSkip = FALSE;
                        break;
                    default:
                        bSkip = TRUE;
                }
            else
                bSkip = FALSE;

            lpszRes = 0L;
            dwLang = 0L;
            dwItem = 0L;
            CString strText;
            int iTokenErr = 0;

            while ((!bSkip) && (lpszRes = RSEnumResId(hModule, lpszType, lpszRes))) {
                while ((dwLang = RSEnumResLang(hModule, lpszType, lpszRes, dwLang))) {

					// Check if we have to skip this language
                    if(b_multi_lang && (LOWORD(dwLang)!=usInputLang))
                        bSkipLang = TRUE;
                    else
                        bSkipLang = FALSE;


					while ((!bSkipLang) && (dwItem = RSEnumResItemId(hModule, lpszType, lpszRes, dwLang, dwItem))) {

                        // Now Get the Data
                        DWORD dwImageSize = RSGetResItemData( hModule,
                                              lpszType,
                                              lpszRes,
                                              dwLang,
                                              dwItem,
                                              m_pBuf,
                                              MAX_BUF_SIZE );

                        lpResItem = (LPRESITEM)m_pBuf;

                        if(((wCount++ % 50)==0) && !(IsFlag(WARNING)))
                            WriteCon(CONOUT, ".");

                        if (HIWORD(lpszType))
                        {
                            if (lstrcmp (lpszType,"REGINST") == 0)
                            {
                                //
                                // Currently there is no id for REGINST defined
                                // in nt.  We just use this 2200 for now.
                                //
                                lpResItem->dwTypeID = 2200;
                            }
                        }

                        lpResItem->dwLanguage = theApp.GetOutLang();

                        // Version stamp use class name as res id
                        if(lpResItem->lpszResID)
                            strResName = lpResItem->lpszResID;
                        else strResName = "";

                        if(lpResItem->dwTypeID==16)
                        {
                            strResName = lpResItem->lpszClassName;
                        }

                        switch(LOWORD(lpResItem->dwTypeID))
                        {
                            case 4:
                                {

                                    if(!(lpResItem->dwFlags & MF_POPUP))
                                        dwItemId = (LOWORD(lpResItem->dwItemID)==0xffff ? HIWORD(lpResItem->dwItemID) : lpResItem->dwItemID);
                                    else dwItemId = lpResItem->dwItemID;
                                }
                            break;
                            case 5:
                                dwItemId = (LOWORD(lpResItem->dwItemID)==0xffff ? HIWORD(lpResItem->dwItemID) : lpResItem->dwItemID);
                            break;
                            case 11:
                                dwItemId = LOWORD(lpResItem->dwItemID);
                            break;
                            default:
                                dwItemId = lpResItem->dwItemID;
                        }

                        if (lpResItem->dwTypeID==1 || lpResItem->dwTypeID==12
                           || lpResItem->dwTypeID==14)
                        {
                            // if user don't want to append redundant cursors,
                            // bitmaps, and icons, we make it NULL
                            if (IsFlag(LEANAPPEND) && IsFlag(APPEND)){
                             dwImageSize=0;
                             RSUpdateResImage(hModule,lpszType,lpszRes,dwLang,0,lpResItem,dwImageSize);
                            }
                            continue;
                        }

                        // Is this a bitmap?
                        if(lpResItem->dwTypeID==2
                           || lpResItem->dwTypeID==3
                           || lpResItem->dwTypeID==23
                           || lpResItem->dwTypeID== 240
                           || lpResItem->dwTypeID== 1024
                           || lpResItem->dwTypeID== 2110
                           || lpResItem->dwTypeID== 2200)
                        {

                            if (IsFlag(LEANAPPEND)
                                && IsFlag(APPEND)
                                && (lpResItem->dwTypeID == 2
                                || lpResItem->dwTypeID == 3))
                            {
                                dwImageSize=0;
                                RSUpdateResImage(hModule,lpszType,lpszRes,dwLang,0,lpResItem,dwImageSize);
                                continue;
                            }
                            // Search for a token with this ID
                            pToken = (CToken *)m_tokenfile.GetNoCaptionToken(lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemId,
                                strResName);

                            if(pToken!=NULL)
                            {
                                // Get the name of the input image
                                strText = pToken->GetTgtText();

                                // Open the file
                                CFile inputFile;
                                if(!inputFile.Open(strText,
                                                   CFile::modeRead |
                                                   CFile::shareDenyNone |
                                                   CFile::typeBinary ) &&
                                   !inputFile.Open(strTokenDir + strText,
                                                   CFile::modeRead |
                                                   CFile::shareDenyNone |
                                                   CFile::typeBinary))
                                {
                                    WriteCon(CONERR, "Input file %s not found! Using Src file data!\r\n", strTokenDir+strText);
                                    goto skip;
                                }

                                DWORD dwSize = inputFile.GetLength();
                                BYTE * pInputBuf = (BYTE*)new BYTE[dwSize];

                                if(pInputBuf==NULL)
                                {
                                    WriteCon(CONERR, "Error allocating memory for the image! (%d)\r\n", dwSize);
                                    goto skip;
                                }

                                BYTE * pInputBufOrigin = pInputBuf;

                                inputFile.ReadHuge(pInputBuf, inputFile.GetLength());

                                CString strTmp = pToken->GetTokenID();
                                WriteCon(CONWRN, "Using image in file %s for ID %s\"]]!\r\n", strText.GetBuffer(0), strTmp.GetBuffer(0));

                                BYTE * pInputImage=(BYTE *) new BYTE[dwSize];
                                DWORD dwImageSize;
                                // remove the header from the file
                                switch(lpResItem->dwTypeID)
                                {
                                    case 2:
                                    {
                                        dwImageSize = dwSize - sizeof(BITMAPFILEHEADER);
                                        pInputBuf += sizeof(BITMAPFILEHEADER);
                                    }
                                    break;
                                    case 3:
                                    {
                                        dwImageSize = dwSize - sizeof(ICONHEADER);
                                        pInputBuf += sizeof(ICONHEADER);
                                    }
                                    case 23:
                                    case 240:
                                    case 1024:
                                    case 2110:
                                    case 2200:
                                    {
                                        dwImageSize = dwSize;
                                    }
                                    break;

                                    default:
                                    break;
                                }

                                memcpy(pInputImage, pInputBuf, dwImageSize);
                                //
                                //  We need to keep output lang info seperately,
                                //  because we dont't have lpResItem to send
                                //  the info to io for icons and bitmaps.
                                //
                                DWORD dwUpdLang = theApp.GetOutLang();

                                // Update the resource
                                RSUpdateResImage(hModule,lpszType,lpszRes,dwLang,dwUpdLang, pInputImage,dwImageSize);

                                delete pInputBufOrigin;
                                delete pInputImage;
                            }
                            else
                            {
                                goto skip;
                            }
                        }
                        // is this an accelerator
                        else if(lpResItem->dwTypeID==9)
                        {
                            // Search for a token with this ID
                            pToken = (CToken *)m_tokenfile.GetNoCaptionToken(lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemId,
                                strResName);

                            if(pToken!=NULL)
                            {
                                CAccel acc(pToken->GetTgtText());

                                if( (lpResItem->dwFlags & 0x80)==0x80 )
                                    lpResItem->dwFlags = acc.GetFlags() | 0x80;
                                else
                                    lpResItem->dwFlags = acc.GetFlags();

                                lpResItem->dwStyle = acc.GetEvent();

                                if(IoDllError(RSUpdateResItemData(hModule,lpszType,lpszRes,dwLang,dwItem,lpResItem,MAX_BUF_SIZE)))
                                {
                                    // we have an error, warn the user
                                    WriteCon(CONWRN, "Error updating token\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                    lpResItem->dwTypeID,
                                                    lpResItem->dwResID,
                                                    dwItemId,
                                                    0,
                                                    4,
                                                    strResName);
                                    AddNotFound();
                                }
                            }
                        }
                        else
                        {
                            // Search for a token with this ID
                            pToken = (CToken *)m_tokenfile.GetToken(lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemId,
                                Format(lpResItem->lpszCaption),
                                strResName);
                        }

                        if(pToken!=NULL) {
                            iTokenErr = pToken->GetLastError();
                            if(pToken->GetFlags() & ISEXTSTYLE){
                                CString strStyle= pToken->GetTgtText();
                                lpResItem->dwExtStyle = strtol(strStyle, (char**)0,16);
                                // Get the real Token
                                pToken = (CToken *)m_tokenfile.GetToken(lpResItem->dwTypeID,
                                    lpResItem->dwResID,
                                    dwItemId,
                                    Format(lpResItem->lpszCaption),
                                    strResName);

                                if(pToken!=NULL)
                                    wCount++;
                            }

                            // Check if is a dialog font name
                            if(pToken != NULL &&
                               ((pToken->GetFlags() & ISDLGFONTNAME) ||
                               (pToken->GetFlags() & ISDLGFONTSIZE)))
                            {
                                if(theApp.IsFlag(CMainApp::FONTS))
                                {
                                    int iColon;
                                    CString strTgtFaceName = pToken->GetTgtText();

                                    // This should be the font description token
                                    if( strTgtFaceName.IsEmpty() || ((iColon = strTgtFaceName.Find(':'))==-1) )
                                        WriteCon(CONWRN, "Using Src file FaceName for ID %s\"]]!\r\n", pToken->GetTokenID());

                                    // Check if the dialog has the DS_SETFONT flag set, otherwise let the user
                                    // know that we can't do much with his font description
                                    if( (lpResItem->dwStyle & DS_SETFONT)!=DS_SETFONT )
                                       WriteCon(CONWRN, "Dialog ID %s\"]] is missing the DS_SETFONT bit. Cannot change font!\r\n", pToken->GetTokenID());
                                    else
                                    {
                                        strFaceName = strTgtFaceName.Left(iColon);
                                        strFaceName.TrimRight();
                                        strTgtFaceName = strTgtFaceName.Right(strTgtFaceName.GetLength() - iColon-1);
                                        strTgtFaceName.TrimLeft();
                                        //sscanf( strTgtFaceName, "%d", &wPointSize );
                                            if ((iColon=strTgtFaceName.Find(':'))!=-1) {
                                                wPointSize=(WORD)atoi(strTgtFaceName.Left(iColon));
                                                strTgtFaceName = strTgtFaceName.Right(strTgtFaceName.GetLength() - iColon-1);
                                                bCharSet = (BYTE)atoi(strTgtFaceName);
                                                lpResItem->bCharSet = bCharSet;
                                            }else{
                                                wPointSize=(WORD)atoi(strTgtFaceName);
                                            }

                                            lpResItem->lpszFaceName = strFaceName.GetBuffer(0);
                                            lpResItem->wPointSize = wPointSize;

                                        strFaceName.ReleaseBuffer();
                                    }
                                }

                                // Get the real Token
                                pToken = (CToken *)m_tokenfile.GetToken(lpResItem->dwTypeID,
                                    lpResItem->dwResID,
                                    dwItemId,
                                    Format(lpResItem->lpszCaption),
                                    strResName);

                                if(pToken!=NULL)
                                    wCount++;
                            }
                        }

                        if(pToken!=NULL && !pToken->GetLastError())
                        {
                            strText = UnFormat(pToken->GetTgtText());
                            if(m_tokenfile.GetTokenSize(pToken, &lpResItem->wX, &lpResItem->wY,
                                &lpResItem->wcX, &lpResItem->wcY))
                                wCount++;

                            lpResItem->lpszCaption = strText.GetBuffer(0);

                            // Static control and style flag is set.  We need
                            // to take style alignment change as well
                            if (LOBYTE(lpResItem->wClassName) == 0x82 &&
                                theApp.IsFlag(CMainApp::ALIGNMENT))
                            {
                                //Get style alignment token
                                pToken = (CToken *)m_tokenfile.GetToken(
                                    lpResItem->dwTypeID,
                                    lpResItem->dwResID,
                                    dwItemId,
                                    Format(lpResItem->lpszCaption),
                                    strResName);

                                if (pToken!=NULL)
                                {
                                    wCount++;

                                    CString strStyle=pToken->GetTgtText();

                                    if (strStyle=="SS_CENTER")
                                        lpResItem->dwStyle |= SS_CENTER;

                                    else if (strStyle=="SS_RIGHT")
                                    {
                                        //reset the alignment bit
                                        lpResItem->dwStyle &= 0xfffffffc;
                                        lpResItem->dwStyle |= SS_RIGHT;
                                    }
                                    else if (strStyle=="SS_LEFT")
                                        lpResItem->dwStyle &= 0xfffffffc;

                                    else
                                        //use provided style is wrong. warn!
                                        WriteCon(CONWRN, "Using Src file alignment style for ID %s\"]]!\r\n", pToken->GetTokenID());
                                }
                            }


                            if(IoDllError(RSUpdateResItemData(hModule,lpszType,lpszRes,dwLang,dwItem,lpResItem,MAX_BUF_SIZE)))
                            {
                                // we have an error, warn the user
                                WriteCon(CONWRN, "Error updating token\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                lpResItem->dwTypeID,
                                                lpResItem->dwResID,
                                                dwItemId,
                                                0,
                                                4,
                                                strResName);
                                AddNotFound();
                            }
                            strText.ReleaseBuffer();
                        }
                        else
                        {
                             pToken = (CToken *)m_tokenfile.GetNoCaptionToken(lpResItem->dwTypeID,
                                 lpResItem->dwResID,
                                 dwItemId,
                                 strResName);

                             if(pToken!=NULL)
                             {
                                if(pToken->GetFlags() & ISEXTSTYLE){

                                    CString strStyle= pToken->GetTgtText();
                                    lpResItem->dwExtStyle = strtol(strStyle, (char**)0,16);
                                    // Get the real Token
                                    pToken = (CToken *)m_tokenfile.GetNoCaptionToken(lpResItem->dwTypeID,
                                        lpResItem->dwResID,
                                        dwItemId,
                                        strResName);

                                    if(pToken!=NULL)
                                        wCount++;
                                }

                                // Check if is a dialog font name
                                if(pToken != NULL &&
                                   ((pToken->GetFlags() & ISDLGFONTNAME) ||
                                    (pToken->GetFlags() & ISDLGFONTSIZE)))
                                {
                                    if(theApp.IsFlag(CMainApp::FONTS))
                                    {
                                        int iColon;
                                        CString strTgtFaceName = pToken->GetTgtText();

                                        // This should be the font description token
                                        if( strTgtFaceName.IsEmpty() || ((iColon = strTgtFaceName.Find(':'))==-1) )
                                            WriteCon(CONWRN, "Using Src file FaceName for ID %s\"]]!\r\n", pToken->GetTokenID());

                                        // Check if the dialog has the DS_SETFONT flag set, otherwise let the user
                                        // know that we can't do much with his font description
                                        if( (lpResItem->dwStyle & DS_SETFONT)!=DS_SETFONT )
                                            WriteCon(CONWRN, "Dialog ID %s\"]] is missing the DS_SETFONT bit. Cannot change font!\r\n", pToken->GetTokenID());
                                        else
                                        {
                                            strFaceName = strTgtFaceName.Left(iColon);
                                            strFaceName.TrimRight();
                                            strTgtFaceName = strTgtFaceName.Right(strTgtFaceName.GetLength() - iColon-1);
                                            strTgtFaceName.TrimLeft();
                                           // sscanf( strTgtFaceName, "%d", &wPointSize );
                                            if ((iColon=strTgtFaceName.Find(':'))!=-1){
                                                wPointSize=(WORD)atoi(strTgtFaceName.Left(iColon));
                                                strTgtFaceName = strTgtFaceName.Right(strTgtFaceName.GetLength() - iColon-1);
                                                bCharSet = (BYTE)atoi(strTgtFaceName);
                                                lpResItem->bCharSet = bCharSet;
                                            }else{
                                                wPointSize=(WORD)atoi(strTgtFaceName);
                                            }

                                            lpResItem->lpszFaceName = strFaceName.GetBuffer(0);
                                            lpResItem->wPointSize = wPointSize;
                                            strFaceName.ReleaseBuffer();
                                        }
                                    }
                                    if(m_tokenfile.GetTokenSize(pToken, &lpResItem->wX, &lpResItem->wY,
                                            &lpResItem->wcX, &lpResItem->wcY))
                                        wCount++;
                                }
                                // Check if is a dialog size
                                else if(pToken->GetFlags() & ISCOR)
                                {
                                    pToken->GetTgtSize(&lpResItem->wX, &lpResItem->wY,
                                            &lpResItem->wcX, &lpResItem->wcY);
                                }

                                // Just size and/or font updated
                                if(IoDllError(RSUpdateResItemData(hModule,lpszType,lpszRes,dwLang,dwItem,lpResItem,MAX_BUF_SIZE)))
                                {
                                    // we have an error, warn the user
                                    WriteCon(CONWRN, "Error updating token\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                    lpResItem->dwTypeID,
                                                    lpResItem->dwResID,
                                                    dwItemId,
                                                    0,
                                                    4,
                                                    strResName);
                                    AddNotFound();
                                }
                            }
                            else
                            {
                                switch(LOWORD(lpszType))
                                {
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 10:
                                    case 11:
                                        // No Token was found for this ID
                                        // Leave it for now but here will come the
                                        // PSEUDO Translation code.
                                        if(strlen(lpResItem->lpszCaption) && !iTokenErr)
                                        {
                                            WriteCon(CONWRN, "ID not found\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                lpResItem->dwTypeID,
                                                lpResItem->dwResID,
                                                dwItemId,
                                                0,
                                                4,
                                                strResName);
                                            AddNotFound();
                                        }
                                        break;
                                    case 9:
                                        WriteCon(CONWRN, "ID not found\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                lpResItem->dwTypeID,
                                                lpResItem->dwResID,
                                                dwItemId,
                                                0,
                                                4,
                                                strResName);
                                        AddNotFound();
                                        break;
                                        break;
                                    case 16:
                                        if (theApp.IsFlag(CMainApp::NOVERSION) &&
                                            (strResName==TEXT("FileVersion") ||
                                            strResName==TEXT("ProductVersion") ||
                                            strResName==TEXT("Platform"))){
                                            //
                                            // do nothing
                                            //
                                        }else if(strlen(lpResItem->lpszCaption)                                                  && !iTokenErr){
                                            WriteCon(CONWRN, "ID not found\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                lpResItem->dwTypeID,
                                                lpResItem->dwResID,
                                                dwItemId,
                                                0,
                                                4,
                                                strResName);
                                            AddNotFound();
                                        }
                                        break;

                                    default:
                                    break;
                                }

                                // Let's update the item anyway, since the language might have changed
                                // RSUpdateResItemData(hModule,lpszType,lpszRes,dwLang,dwItem,lpResItem,MAX_BUF_SIZE);
                            }
                        }
skip:;
                    }
                }
            }
        }
        iErr=(Error_Codes)IoDllError(RSWriteResFile(hModule, m_strOutExe, NULL,m_strOutputSymPath));

        if ((int)iErr > 0){
            //WriteCon(CONERR, "%s", CalcTab(m_strOutExe, m_strOutExe.GetLength()+5, ' '));
            goto exit;
        }

        WriteCon(CONBOTH, " %hu(%hu) Items\r\n", wCount, m_wIDNotFound);

        // Check if some items were removed from the file
        if(wCount<m_tokenfile.GetTokenNumber() ||
           m_wIDNotFound ||
           m_wCntxChanged ||
           m_wResized)
            WriteCon(CONWRN, "%s\tToken: ", CalcTab(strFileName, strFileName.GetLength()+5, ' '));

        if(wCount<m_tokenfile.GetTokenNumber())
        {
            SetReturn(ERROR_RET_RESIZED);
            WriteCon(CONWRN, "Removed %d ", m_tokenfile.GetTokenNumber()-wCount);
        }

        if(m_wIDNotFound)
            WriteCon(CONWRN, "Not Found %d ", m_wIDNotFound);

        if(m_wCntxChanged)
            WriteCon(CONWRN, "Contex Changed %d ", m_wCntxChanged);

        if(m_wResized)
            WriteCon(CONWRN, "Resize Changed %d ", m_wResized);

        if(wCount<m_tokenfile.GetTokenNumber() ||
           m_wIDNotFound ||
           m_wCntxChanged ||
           m_wResized)
            WriteCon(CONWRN, "\r\n");
    }

exit:
    RSCloseModule(hModule);

    return iErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\main.h ===
#ifndef __MAIN_H__
#define __MAIN_H__

#include <afx.h>
#include <iodll.h>

///////////////////////////////////////////////////////////////////////////////
// From RLMan
// Token flag Masks

#define ISPOPUP         0x0001
#define ISCOR	        0x0010
#define ISDUP	        0x0020
#define ISCAP	        0x0040
#define ISDLGFONTCHARSET 0x0002
#define ISDLGFONTNAME   0x0004
#define ISDLGFONTSIZE   0x0008
#define ISALIGN         0x0080
#define ISEXTSTYLE      0x0200

#define OLD_POPUP_ID	0x0100

#define ISKEY	        0x0010
#define ISVAL	        0x0020

// status bits
#define ST_TRANSLATED   4
#define ST_READONLY     2
#define ST_NEW	        1
#define ST_DIRTY        1
#define ST_CHANGED      4

#define MAX_STR_SIZE    8192    // Max Len of a string passed to WriteCon
#define MAX_BUF_SIZE    8192    // Max ResItem Buffer size

// Console flags
#define CONOUT          0        // Used with WriteCon to send the message to stdout
#define CONERR          1        // Used with WriteCon to send the message to stderr
#define CONBOTH         2        // Used with WriteCon to send the message to stderr and stdout if not the same handle
#define CONWRN          3        // Used with WriteCon to send the message to stderr only if WARNING enabled

class CMainApp
{
public:
    // Error codes
    enum Error_Codes
    {
        ERR_NOERROR           =  0x00000000,  //
        ERR_COMMAND_LINE      =  0x00000001,  // Wrong command line
        ERR_TOKEN_MISMATCH    =  0x00000002,  // Token file don't match
        ERR_TOKEN_WRONGFORMAT =  0x00000004,  // Token file are not in the right format
        ERR_FILE_OPEN         =  0x00000100,  // Cannot open the file
        ERR_FILE_COPY         =  0x00000200,  // Cannot copy the file
        ERR_FILE_CREATE       =  0x00000400,  // Cannot create the file
        ERR_FILE_NOTSUPP      =  0x00000800,  // This file type is not supported
        ERR_FILE_NOTFOUND     =  0x00001000,  // The file doesn't exist
        ERR_FILE_VERSTAMPONLY =  0x00002000,  // The file has only version stamping
        ERR_HELP_CHOOSE       =  0x00004000   // The user want to see the help file
    };

    // Options Flags
    enum Option_Codes
    {
        NO_OPTION   = 0x00000000,  //  Initializer
        WARNING     = 0x00000001,  //  -w                  (Show warning messages)
        HELP        = 0x00000002,  //  -? or -h            (Show more complete help using winhelp)
        APPEND      = 0x00000004,  //  -a                  (Append resources in localized tokens)
        REPLACE     = 0x00000008,  //  -r                  (Replace resources in localized tokens, no checking)
        EXTRACT     = 0x00000010,  //  -t                  (Extract token file)
        BITMAPS     = 0x00000020,  //  -b                  (Extract bitmaps and icons)
        SPLIT       = 0x00000040,  //  -s                  (Split the message table)
        NOLOGO      = 0x00000080,  //  -n                  (Nologo)
        UPDATE      = 0x00000100,  //  -u                  (Update the resources in localized file)
        FONTS       = 0x00000200,  //  -f                  (Font information for dialog)
        PIPED       = 0x00001000,  //  We have being piped to a file
        INPUT_LANG  = 0x00002000,  //  -i                  (Input language resources set)
        OUTPUT_LANG = 0x00004000,  //  -o                  (Output language resources set)
        LEANAPPEND   = 0x00010000,   //  -l                (Do not append redudant resources)
        ALIGNMENT   = 0x00020000,  //  -y                  (Extract static control alignment style info)
        GIFHTMLINF  = 0x00040000,  //  -c                  (Extract embedded gifs, htmls and infs)
        NOVERSION   = 0x00080000   //  -v                  (Do not generate selected version stamp information)
    };

#if 0
    enum Return_Codes
    {
        RET_NOERROR           =  0x00000000,  //
        RET_ID_NOTFOUND       =  0x00000001,  // An Id was not found
        RET_CNTX_CHANGED      =  0x00000002,  // Contex changed
        RET_RESIZED           =  0x00000004,  // item resized
        RET_INVALID_TOKEN     =  0x00000008,  // The token file is not valid
        RET_TOKEN_REMOVED     =  0x00000010,  // some token were removed
        RET_TOKEN_MISMATCH    =  0x00000020,  // The token mismatch
        RET_IODLL_ERROR       =  0x00000040,  // There is an error in IO
        RET_IODLL_WARNING     =  0x00000080,  // There is an warning in IO
        RET_FILE_VERSTAMPONLY =  0x00000100,  // File has only version stamping
        RET_FILE_NORESOURCE   =  0x00000200,  // File has no resource
        RET_FILE_MULTILANG    =  0x00000400,  // File has multiple language
        RET_IODLL_CHKMISMATCH =  0x00000800,  // Symbool checksum mismatch
        RET_FILE_CUSTOMRES    =  0x00001000,  // Contains custom resource.
        RET_IODLL_NOSYMBOL    =  0x00002000,  // Symbol file not found
        RET_FILE_NOSYMPATH    =  0x00004000   // Output symbol path not found.
    };
#endif

public:
    // Constructor
    CMainApp();
    ~CMainApp();

    // Operations
    Error_Codes ParseCommandLine(int argc, char ** argv);
    Error_Codes GenerateFile();

    void Banner();
    void Help();

    BOOL IsFlag(Option_Codes dwFlag)
        { return ((m_dwFlags & dwFlag)==dwFlag); }

    int  __cdecl WriteCon(int iFlags, const char * lpstr, ...);

    void AddNotFound()
        { m_wIDNotFound++; SetReturn(ERROR_RET_ID_NOTFOUND); }
    void AddChanged()
        { m_wCntxChanged++; SetReturn(ERROR_RET_CNTX_CHANGED); }
    void AddResized()
        { m_wResized++; SetReturn(ERROR_RET_RESIZED); }

    int ReturnCode()
        { return m_dwReturn; }

    // Language support
    WORD GetOutLang()
        { return ( MAKELANGID(m_usOPriLangId, m_usOSubLangId) ); }

    int SetReturn(int rc);
    int IoDllError(int iError);
    UINT GetUICodePage()
        { return m_uiCodePage; }

private:
    // Attributes
    Option_Codes m_dwFlags;        // Command line parameters
    int m_dwReturn;       // Return codes

    // Console Handles
    HANDLE m_StdOutput;
    HANDLE m_StdError;

    // String Buffers
    CString m_strBuffer1;
    CString m_strBuffer2;
    BYTE *  m_pBuf;

    // File Names
    CString m_strInExe;
    CString m_strOutExe;
    CString m_strSrcTok;
    CString m_strTgtTok;

    // Symbol Path Name
    CString m_strSymPath;
    CString m_strOutputSymPath;

    SHORT  m_usIPriLangId;     // Primary language ID for the input file
    SHORT  m_usISubLangId;     // Secondary language ID for the input file

    SHORT  m_usOPriLangId;     // Primary language ID for the output file
    SHORT  m_usOSubLangId;     // Secondary language ID for the output file

    UINT   m_uiCodePage;       // Code page to use during conversion
    char   m_unmappedChar;     // Default for unmappable characters

    // report counters
    WORD    m_wIDNotFound;
    WORD    m_wCntxChanged;
    WORD    m_wResized;

    // Helper operators
    CString CalcTab(CString str, int tablen, char ch);
    USHORT  GetLangID(CString strNum);
    UINT    GetCodePage(CString strNum);
    LPCSTR  Format(CString strTmp);
    LPCSTR  UnFormat(CString strTmp);

    // Member functions
    Error_Codes BinGen();
    Error_Codes TokGen();
    Error_Codes DelRes();
};

/////////////////////////////////////////////////////////////////////////
// This is needed to make sure that the operator |= will work fine on the
// enumerated type Option_Codes
inline CMainApp::Option_Codes operator|=( CMainApp::Option_Codes &oc, int i )
    { return oc = (CMainApp::Option_Codes)(oc | i); }

#if 0
inline CMainApp::Error_Codes operator|=( CMainApp::Error_Codes &rc, int i )
    { return rc = (CMainApp::Return_Codes)(rc | i); }
#endif

#pragma pack(1)
typedef struct iconHeader
{
    WORD idReserved;
    WORD idType;
    WORD idCount;
    BYTE bWidth;
    BYTE bHeight;
    BYTE bColorCount;
    BYTE bReserved;
    WORD wPlanes;
    WORD wBitCount;
    DWORD dwBytesInRes;
    DWORD dwImageOffset;
} ICONHEADER;
#pragma pack(8)

#endif // __MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\token.cpp ===
////////////////////////////////////////
// token.cpp
////////////////////////////////////////
//
//  This file handle all the token strings
//
////////////////////////////////////////

#include "token.h"
#include "main.h"

extern CMainApp theApp;
#define MAX_TOKEN   8192

CToken::CToken()
{
    m_uiTypeID      = 0;
    m_uiResID       = 0;
    m_uiItemID      = 0;
    m_uiFlags       = 0;
    m_uiStatusFlags = 0;
    m_uiLastError   = 0;
    m_strItemName   = "";
    m_strSrcText    = "";
    m_strTgtText    = "";

}

int CToken::Parse(CString strSrc, CString strTgt)
{
    CString strSrcTokenID;
    int pos;

    if(!strSrc.IsEmpty())
    {
        pos = strSrc.Find('=');
        if(pos==-1)
        {
            theApp.WriteCon(CONERR, "Invalid token [equal sign missing]\t%s\r\n", strSrc);
            theApp.SetReturn(ERROR_RET_INVALID_TOKEN);
            return CMainApp::ERR_TOKEN_WRONGFORMAT;
        }

        strSrcTokenID = strSrc.Left(pos-3);
        m_strSrcText = strSrc.Right(strSrc.GetLength()-++pos);
        pos = m_strSrcText.Find('\n');
        if(pos!=-1)
            m_strSrcText = m_strSrcText.Left(pos);
    }
    else
        m_strSrcText = "";

    pos = strTgt.Find('=');
    if(pos==-1)
    {
        theApp.WriteCon(CONERR, "Invalid token  [equal sign missing]\t%s\r\n", strTgt);
        theApp.SetReturn(ERROR_RET_INVALID_TOKEN);
        return CMainApp::ERR_TOKEN_WRONGFORMAT;
    }

    if(pos<=3)
    {
        theApp.WriteCon(CONERR, "Invalid token  [token corruption]\t%s\r\n", strTgt);
        theApp.SetReturn(ERROR_RET_INVALID_TOKEN);
        return CMainApp::ERR_TOKEN_WRONGFORMAT;
    }

    m_strTokenID = strTgt.Left(pos-3);
    m_strTgtText = strTgt.Right(strTgt.GetLength()-++pos);

    //pos = m_strTgtText.Find('\n');
    //if(pos!=-1)
    //    m_strTgtText = m_strTgtText.Left(pos);
    //
    // On FE platforms, "Find" could not find the
    // ending \n when the last char is a High ansi because it is leadbyte.

    char * pStr = m_strTgtText.GetBuffer(0);
    pos = 0;
    while (*pStr){
        if(*pStr == '\n'){
            m_strTgtText = m_strTgtText.Left(pos);
            break;
        }
        if (IsDBCSLeadByteEx(theApp.GetUICodePage(), *pStr))
        {
            pos+=2;
        }
        else
        {
            pos++;
        }
        pStr = CharNextExA((WORD)theApp.GetUICodePage(), pStr, 0);
    }

    if(5>sscanf(m_strTokenID, TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]"),
        &m_uiTypeID,
        &m_uiResID,
        &m_uiItemID,
        &m_uiFlags,
        &m_uiStatusFlags,
        m_strItemName.GetBuffer(128)))
    {
        theApp.WriteCon(CONERR, "Invalid token [not enough arguments converted]\t%s\"]]\r\n", m_strTokenID);
        theApp.SetReturn(ERROR_RET_INVALID_TOKEN);
        return CMainApp::ERR_TOKEN_WRONGFORMAT;
    }

	// Special case the Menu Popup
	if(m_uiTypeID==4 && (m_uiFlags & ISPOPUP)==ISPOPUP && (m_uiFlags & OLD_POPUP_ID)==OLD_POPUP_ID)
    {
        m_uiItemID = MAKELONG( 0xFFFF, LOWORD(m_uiItemID) );
    }
	
    m_strItemName.ReleaseBuffer();
    m_strItemName = m_strTokenID.Mid(m_strTokenID.Find("|\"")+2);

    if(!strSrc.IsEmpty())
    {
        // Perform a consistency check on the token files
        unsigned int    uiTypeID = 0;
        unsigned int    uiResID = 0;
        unsigned int    uiItemID = 0;
        unsigned int    uiFlags = 0;
        unsigned int    uiStatusFlags = 0;
        CString         strItemName = "";

        sscanf(strSrcTokenID, TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]"),
            &uiTypeID,
            &uiResID,
            &uiItemID,
            &uiFlags,
            &uiStatusFlags,
            strItemName.GetBuffer(128));

        strItemName.ReleaseBuffer();
        strItemName = strSrcTokenID.Mid(strSrcTokenID.Find("|\"")+2);

        // Special case the Menu Popup
		if(uiTypeID==4 && (uiFlags & ISPOPUP)==ISPOPUP && (m_uiFlags & OLD_POPUP_ID)==OLD_POPUP_ID)
        {
            uiItemID = MAKELONG( 0xFFFF, LOWORD(uiItemID) );
        } 		
		
        // Compare token ID
        if(!((uiTypeID == m_uiTypeID) &&
           (uiResID  == m_uiResID) &&
           (uiItemID == m_uiItemID) &&
           (uiFlags  == m_uiFlags) &&
           (strItemName == m_strItemName)))
        {
            theApp.WriteCon(CONERR, "Token ID mismatch\t%s\"]]\t%s\"]]\r\n", strSrcTokenID.GetBuffer(0), m_strTokenID.GetBuffer(0));
            theApp.SetReturn(ERROR_RET_TOKEN_MISMATCH);
            return CMainApp::ERR_TOKEN_MISMATCH;
        }
    }

    return 0;
}

BOOL CToken::GetTgtSize(WORD * px, WORD * py,WORD * pcx, WORD * pcy)
{
   return sscanf(m_strTgtText, TEXT("%hu %hu %hu %hu"),
        px,
        py,
        pcx,
        pcy);
}

BOOL CToken::GetSrcSize(WORD * px, WORD * py,WORD * pcx, WORD * pcy)
{
   return sscanf(m_strSrcText, TEXT("%hu %hu %hu %hu"),
        px,
        py,
        pcx,
        pcy);
}


/////////////////////////////////////////////////////////////////////////

CTokenFile::CTokenFile()
{
    m_Tokens.SetSize(0, 10);
    m_iLastPos      = 0;
    m_iUpperBound   = -1;
    m_strSrcFile    = "";
    m_strTgtFile    = "";
}

CTokenFile::~CTokenFile()
{
    for(INT_PTR at=0; at<=m_iUpperBound; at++)
        delete (m_Tokens.GetAt(at));

    m_Tokens.RemoveAll();
}

int CTokenFile::Open(CString strSrcFile, CString strTgtFile)
{
    int iErr = CMainApp::ERR_NOERROR;
    // Open the files
    CStdioFile SrcFile;
    CStdioFile TgtFile;

    // If we are doing an UPDATE we need both src and tgt files
    // while if we are not it is enough the tgt file.
    // If only the tgt file is given no consistency will be done.
    if(theApp.IsFlag(CMainApp::UPDATE))
        if(!SrcFile.Open(strSrcFile, CFile::modeRead | CFile::shareDenyWrite))
        {
            theApp.WriteCon(CONERR, "Cannot open file: %s\r\n", strSrcFile);
            return CMainApp::ERR_FILE_OPEN;
        }

    if(!TgtFile.Open(strTgtFile, CFile::modeRead | CFile::shareDenyWrite))
    {
        theApp.WriteCon(CONERR, "Cannot open file: %s\r\n", strTgtFile);
        return CMainApp::ERR_FILE_OPEN;
    }

    CString strSrc = "";
    CString strTgt = "";
    INT_PTR at;

    while(TgtFile.ReadString(strTgt.GetBuffer(MAX_TOKEN), MAX_TOKEN))
    {
        if(theApp.IsFlag(CMainApp::UPDATE))
            if(!SrcFile.ReadString(strSrc.GetBuffer(MAX_TOKEN), MAX_TOKEN))
            {
                theApp.WriteCon(CONERR, "The file  %s has more tokens than the file %s!\r\n", strTgtFile, strSrcFile);
                theApp.SetReturn(ERROR_RET_TOKEN_MISMATCH);
                return CMainApp::ERR_TOKEN_MISMATCH;
            }

        strSrc.ReleaseBuffer();
        strTgt.ReleaseBuffer();

        at = m_Tokens.Add(new CToken());

        if(iErr = ((CToken*)m_Tokens.GetAt(at))->Parse(strSrc,strTgt))
        {
            goto close;
        }

    }

    m_iUpperBound = m_Tokens.GetUpperBound();

close:
    if(theApp.IsFlag(CMainApp::UPDATE))
        SrcFile.Close();

    TgtFile.Close();

    return iErr;
}

const CToken * CTokenFile::GetTokenSize(CToken * pToken, WORD * px, WORD * py,
                      WORD * pcx, WORD * pcy)
{

    if((pToken!=NULL) && (pToken->m_uiTypeID!=5))
        return NULL;

    CToken * pTokenSize = (CToken *)m_Tokens.GetAt(m_iLastPos++);

    if(pTokenSize==NULL)
        return NULL;

    WORD x, y, cx, cy;
    pTokenSize->GetSrcSize(&x, &y, &cx, &cy);

    // check if the size changed
    if(!theApp.IsFlag(CMainApp::UPDATE) ||
       (x==*px &&
       y==*py &&
       cx==*pcx &&
       cy==*pcy) )
    {
        pTokenSize->GetTgtSize(px, py, pcx, pcy);
    }
    else
    {
        theApp.WriteCon(CONWRN, "Item Resized\t%s\"]]\r\n", pTokenSize->m_strTokenID);
        theApp.AddResized();
    }

    return pTokenSize;
}

const CToken * CTokenFile::GetTokenSize(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strItemName,
                      WORD * px, WORD * py,
                      WORD * pcx, WORD * pcy)
{
    if(TypeID!=5)
        return NULL;

    BOOL bMatch = FALSE;

    ASSERT(m_iUpperBound!=-1);
    if(m_iLastPos>m_iUpperBound)
        m_iLastPos = 0;

    CToken * pToken = NULL;
    INT_PTR iLastPos = m_iLastPos;

    while(!bMatch)
    {
        pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);

        if(pToken==NULL)
            return NULL;

        while(pToken->m_uiTypeID!=TypeID && !bMatch) {
            if(m_iLastPos>m_iUpperBound) {
                m_iLastPos = 0;
                bMatch = TRUE;
            }
            pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);
            if(pToken==NULL)
                return NULL;
        }

        // Let's see if we have at least some parameter to find the token
        if(pToken->m_uiTypeID==TypeID &&
           pToken->m_uiResID==ResID &&
           pToken->m_uiItemID==ItemID &&
           pToken->m_strItemName==strItemName &&
           (pToken->m_uiFlags & ISCOR))      // to be compatible with rlman token ids
        {
            WORD x, y, cx, cy;
            pToken->GetSrcSize(&x, &y, &cx, &cy);

            // check if the size changed
            if(!theApp.IsFlag(CMainApp::UPDATE) ||
               (x==*px &&
               y==*py &&
               cx==*pcx &&
               cy==*pcy) )
            {
                pToken->GetTgtSize(px, py, pcx, pcy);
            }
            else
            {
                theApp.WriteCon(CONWRN, "Item Resized\t%s\"]]\r\n", pToken->m_strTokenID);
                theApp.AddResized();
            }

            return pToken;
        }
        else if(pToken->m_uiTypeID!=TypeID)
        {
            m_iLastPos = iLastPos;
            return NULL;
        }

        if(m_iLastPos>m_iUpperBound)
           return NULL;
    }

    return NULL;
}

const CToken * CTokenFile::GetToken(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strText,
                      CString strItemName)
{
    if(strText.IsEmpty() && (TypeID != 5L))      // Allow Dialog Strings to be NULL
        return NULL;

    BOOL bMatch = FALSE;

    ASSERT(m_iUpperBound!=-1);
    if(m_iLastPos>m_iUpperBound)
        m_iLastPos = 0;

    CToken * pToken = NULL;
    INT_PTR iLastPos = m_iLastPos;

    while(!bMatch)
    {
        pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);

        if(pToken==NULL)
            return NULL;

        while(pToken->m_uiTypeID!=TypeID && !bMatch) {
            if(m_iLastPos>m_iUpperBound) {
                m_iLastPos = 0;
                bMatch = TRUE;
            }
            pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);
            if(pToken==NULL)
                return NULL;
        }

        // Let's see if we have at least some parameter to find the token
        if(pToken->m_uiTypeID==TypeID &&
           pToken->m_uiResID==ResID &&
           pToken->m_uiItemID==ItemID &&
           pToken->m_strItemName==strItemName &&
           !(pToken->m_uiFlags & ISCOR))    // to be compatible with rlman token ids
        {
            if(!theApp.IsFlag(CMainApp::FONTS) && (pToken->m_uiFlags & ISDLGFONTNAME) || (pToken->m_uiFlags & ISDLGFONTSIZE))
                return pToken;
            else if(!theApp.IsFlag(CMainApp::UPDATE) || pToken->m_strSrcText==strText)
                return pToken;
            else
            {
                theApp.WriteCon(CONWRN, "Context changed\t%s\"]]\r\n", pToken->m_strTokenID);
                theApp.AddChanged();
                pToken->m_uiLastError = 1;
                return pToken;
            }
        }
        else if(pToken->m_uiTypeID!=TypeID) {
                m_iLastPos = iLastPos;
                return NULL;
        }

        if(m_iLastPos>m_iUpperBound)
           return NULL;
    }

    return NULL;
}

const CToken * CTokenFile::GetNoCaptionToken(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strItemName)
{
    BOOL bMatch = FALSE;

    ASSERT(m_iUpperBound!=-1);
    if(m_iLastPos>m_iUpperBound)
        m_iLastPos = 0;

    CToken * pToken = NULL;
    INT_PTR iLastPos = m_iLastPos;

    while(!bMatch)
    {
        pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);

        if(pToken==NULL)
            return NULL;

        while(pToken->m_uiTypeID!=TypeID && !bMatch) {
            if(m_iLastPos>m_iUpperBound) {
                m_iLastPos = 0;
                bMatch = TRUE;
            }
            pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);
            if(pToken==NULL)
                return NULL;
        }

        // Let's see if we have at least some parameter to find the token
        if(pToken->m_uiTypeID==TypeID &&
           pToken->m_uiResID==ResID &&
           pToken->m_uiItemID==ItemID &&
           pToken->m_strItemName==strItemName &&  // to be compatible with rlman token ids
           (!pToken->m_strSrcText || TypeID !=4)) // Some binaries like shell32.dll uses the same id 0 as MENU SEPARATOR.  Filter those out.
        {
           return pToken;
        }
        else if(pToken->m_uiTypeID!=TypeID) {
                m_iLastPos = iLastPos;
                return NULL;
        }

        if(m_iLastPos>m_iUpperBound)
           return NULL;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\vktbl.h ===
#ifndef __VKTBL_H__
#define __VKTBL_H__


#define ACC_SHIFT   0x04
#define ACC_CTRL    0x08
#define ACC_ALT     0x10
#define ACC_VK      0x01

#define ISACCFLG(x,y)    ((x & y)==y)

class CAccel
{
public:
    CAccel();       // Default
    CAccel(LPCSTR strText);
    CAccel(DWORD dwFlags, DWORD dwEvent);

    DWORD GetEvent()
        { return m_dwEvent; }
    DWORD GetFlags()
        { return m_dwFlags; }
    CString GetText()
        { return m_strText; }

private:
    CString VKToString(DWORD dwVKCode);
    DWORD StringToVK(CString str);

    CString m_strText;
    DWORD   m_dwFlags;
    DWORD   m_dwEvent;
};

#endif // __VKTBL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\vktbl.cpp ===
#include <afx.h>
#include "vktbl.h"

char vkstrTable[][15] = 
{ 
    "VK_LBUTTON",   
    "VK_RBUTTON",  
    "VK_CANCEL",                
                     
    "VK_MBUTTON",              
    "VK_BACK",                    
    "VK_TAB",                      
                     
    "VK_CLEAR",                  
    "VK_RETURN",                
                    
    "VK_SHIFT",                  
    "VK_CONTROL",              
    "VK_MENU",                    
    "VK_PAUSE",                  
    "VK_CAPITAL",              
                    
    "VK_ESCAPE",                
                    
    "VK_SPACE",                  
    "VK_PRIOR",                  
    "VK_NEXT",                    
    "VK_END",                      
    "VK_HOME",                    
    "VK_LEFT",                    
    "VK_UP",                        
    "VK_RIGHT",                  
    "VK_DOWN",                    
    "VK_SELECT",                
    "VK_PRINT",                  
    "VK_EXECUTE",              
    "VK_SNAPSHOT",            
    "VK_INSERT",                
    "VK_DELETE",                
    "VK_HELP",                    
                     
    "VK_LWIN",                    
    "VK_RWIN",                    
    "VK_APPS",                    
                    
    "VK_NUMPAD0",              
    "VK_NUMPAD1",              
    "VK_NUMPAD2",              
    "VK_NUMPAD3",              
    "VK_NUMPAD4",              
    "VK_NUMPAD5",              
    "VK_NUMPAD6",              
    "VK_NUMPAD7",              
    "VK_NUMPAD8",              
    "VK_NUMPAD9",              
    "VK_MULTIPLY",            
    "VK_ADD",                      
    "VK_SEPARATOR",
    "VK_SUBTRACT",            
    "VK_DECIMAL",              
    "VK_DIVIDE",                
    "VK_F1",                        
    "VK_F2",                        
    "VK_F3",                        
    "VK_F4",                        
    "VK_F5",                        
    "VK_F6",                        
    "VK_F7",                        
    "VK_F8",                        
    "VK_F9",                        
    "VK_F10",                      
    "VK_F11",                      
    "VK_F12",                      
    "VK_F13",                      
    "VK_F14",                      
    "VK_F15",                      
    "VK_F16",                      
    "VK_F17",                      
    "VK_F18",                      
    "VK_F19",                      
    "VK_F20",                      
    "VK_F21",                      
    "VK_F22",                      
    "VK_F23",                      
    "VK_F24",                      
                    
    "VK_NUMLOCK",              
    "VK_SCROLL",                
                    
    "VK_LSHIFT",                
    "VK_RSHIFT",                
    "VK_LCONTROL",            
    "VK_RCONTROL",            
    "VK_LMENU",                  
    "VK_RMENU",                  
                     
    "VK_ATTN",                    
    "VK_CRSEL",                  
    "VK_EXSEL",                  
    "VK_EREOF",                  
    "VK_PLAY",                    
    "VK_ZOOM",                    
    "VK_NONAME",                
    "VK_PA1",                      
    "VK_OEM_CLEAR",

    // added for Pagasus
    "VK_OEM_PLUS",
    "VK_OEM_COMMA",
    "VK_OEM_MINUS",
    "VK_OEM_PERIOD",
    "VK_OEM_1",
    "VK_OEM_2",
    "VK_OEM_3",
    "VK_OEM_4",
    "VK_OEM_5",
    "VK_OEM_6",
    "VK_OEM_7",
    "VK_OEM_102"
};

DWORD vkdwTable[] = 
{
     VK_LBUTTON  
    ,VK_RBUTTON  
    ,VK_CANCEL   
            
    ,VK_MBUTTON  
    ,VK_BACK     
    ,VK_TAB      
            
    ,VK_CLEAR    
    ,VK_RETURN   
            
    ,VK_SHIFT    
    ,VK_CONTROL  
    ,VK_MENU     
    ,VK_PAUSE    
    ,VK_CAPITAL  
            
    ,VK_ESCAPE   
            
    ,VK_SPACE    
    ,VK_PRIOR    
    ,VK_NEXT     
    ,VK_END      
    ,VK_HOME     
    ,VK_LEFT     
    ,VK_UP       
    ,VK_RIGHT    
    ,VK_DOWN     
    ,VK_SELECT   
    ,VK_PRINT    
    ,VK_EXECUTE  
    ,VK_SNAPSHOT 
    ,VK_INSERT   
    ,VK_DELETE   
    ,VK_HELP     
            
    ,VK_LWIN     
    ,VK_RWIN     
    ,VK_APPS     
            
    ,VK_NUMPAD0  
    ,VK_NUMPAD1  
    ,VK_NUMPAD2  
    ,VK_NUMPAD3  
    ,VK_NUMPAD4  
    ,VK_NUMPAD5  
    ,VK_NUMPAD6  
    ,VK_NUMPAD7  
    ,VK_NUMPAD8  
    ,VK_NUMPAD9  
    ,VK_MULTIPLY 
    ,VK_ADD      
    ,VK_SEPARATOR
    ,VK_SUBTRACT 
    ,VK_DECIMAL  
    ,VK_DIVIDE   
    ,VK_F1       
    ,VK_F2       
    ,VK_F3       
    ,VK_F4       
    ,VK_F5       
    ,VK_F6       
    ,VK_F7       
    ,VK_F8       
    ,VK_F9       
    ,VK_F10      
    ,VK_F11      
    ,VK_F12      
    ,VK_F13      
    ,VK_F14      
    ,VK_F15      
    ,VK_F16      
    ,VK_F17      
    ,VK_F18      
    ,VK_F19      
    ,VK_F20      
    ,VK_F21      
    ,VK_F22      
    ,VK_F23      
    ,VK_F24      
            
    ,VK_NUMLOCK  
    ,VK_SCROLL   
            
    ,VK_LSHIFT   
    ,VK_RSHIFT   
    ,VK_LCONTROL 
    ,VK_RCONTROL 
    ,VK_LMENU    
    ,VK_RMENU    
            
    ,VK_ATTN     
    ,VK_CRSEL    
    ,VK_EXSEL    
    ,VK_EREOF    
    ,VK_PLAY     
    ,VK_ZOOM     
    ,VK_NONAME   
    ,VK_PA1      
    ,VK_OEM_CLEAR

    // added for Pagasus
    ,VK_OEM_PLUS
    ,VK_OEM_COMMA
    ,VK_OEM_MINUS
    ,VK_OEM_PERIOD
    ,VK_OEM_1
    ,VK_OEM_2
    ,VK_OEM_3
    ,VK_OEM_4
    ,VK_OEM_5
    ,VK_OEM_6
    ,VK_OEM_7
    ,VK_OEM_102

};

int imaxvktable = sizeof(vkdwTable)/sizeof(DWORD);

CAccel::CAccel()
{
    m_dwFlags = 0;
    m_dwEvent = 0;
    m_strText = "";
}

CAccel::CAccel(LPCSTR strText)
{
    CString strAcc = strText;
    m_dwFlags = 0;
    m_dwEvent = 0;
    m_strText = "";

    // First check for the VIRTKEY or ASCII tag
    if(strAcc.Find("VIRTKEY")!=-1)
    {
        m_dwFlags |= ACC_VK;

        // Check for the Key tags
        if(strAcc.Find("Ctrl")!=-1)
            m_dwFlags |= ACC_CTRL;
        if(strAcc.Find("Shift")!=-1)
            m_dwFlags |= ACC_SHIFT;
        if(strAcc.Find("Alt")!=-1)
            m_dwFlags |= ACC_ALT;

        // Now clean the string and get the VK code
        int iPos = strAcc.Find("VK_");
        if(iPos==-1)
        {
            // something is wrong 
            m_dwFlags = 0;
            m_dwEvent = 0;
            m_strText = "";
        }
        int iCount = 0;
        while(strAcc[iPos+iCount]!=',')
            iCount++;

        m_dwEvent = StringToVK(strAcc.Mid(iPos, iCount));
    }
    else if(strAcc.Find("ASCII")!=-1)
    {
        // Check for the Key tags
        if(strAcc.Find("Ctrl")!=-1)
        {
            int iPos = strAcc.Find('+');
            if(iPos!=-1)
            {
                m_dwEvent = ((DWORD)strAcc[iPos+1])-0x40;
            }
        }
        else if(strAcc.Find("Alt")!=-1)
        {
            int iPos = strAcc.Find('+');
            if(iPos!=-1)
            {
                m_dwEvent = ((DWORD)strAcc[iPos+1]);
                m_dwFlags |= ACC_ALT;
            }
        }
        else
        {
            m_dwEvent = (DWORD)strAcc[0];
        }
    }
}

CAccel::CAccel(DWORD dwFlags, DWORD dwEvent)
{
    m_dwFlags = dwFlags;
    m_dwEvent = dwEvent;
    
    // Accelerator handling
    if(ISACCFLG(m_dwFlags, ACC_CTRL))
        m_strText += "Ctrl+";
    if(ISACCFLG(m_dwFlags, ACC_SHIFT))
        m_strText += "Shift+";
    if(ISACCFLG(m_dwFlags, ACC_ALT))
        m_strText += "Alt+";
    
    if(ISACCFLG(m_dwFlags, ACC_VK))
    {
        m_strText += VKToString(m_dwEvent);
        m_strText += ", VIRTKEY";
    }
    else 
    {
        if(m_dwEvent + 0x40 >= 'A' && m_dwEvent + 0x40 <= 'Z')
        {
            m_strText += "Ctrl+";
            m_strText += (char)(m_dwEvent + 0x40);
        }
        else m_strText += (char)m_dwEvent;

        m_strText += ", ASCII";
    }
}

CString CAccel::VKToString(DWORD dwEvent)
{
    CString strVK = "";

    if((dwEvent >= 0x30) && (dwEvent <= 0x5A))
    {
        strVK = "VK_";
        strVK += (char)dwEvent;
    }

    int i = 0;
    while(i<imaxvktable)
    {
        if(dwEvent==vkdwTable[i++])
        {
            strVK = vkstrTable[i-1];
            break;
        }
    }
    
    return strVK;
}

DWORD CAccel::StringToVK(CString str)
{
    DWORD dwVK = 0;

    if(str.GetLength()==4)
    {
        // remove the VK_ and get the char
        str = str.Mid(3);
        dwVK = (DWORD)str[0];
    }
    else 
    {
        int i = 0;
        while(i<imaxvktable)
        {
            if(str==vkstrTable[i++])
            {
                dwVK = vkdwTable[i-1];
                break;
            }
        }
    }
    
    return dwVK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\token.h ===
#ifndef __TOKEN_H__
#define __TOKEN_H__

#include <afx.h>

class CToken: public CObject
{
friend class CTokenFile;
public:
    // Constructor
    CToken();

    int Parse(CString strSrc, CString strTgt);

    CString GetTgtText()
        { return m_strTgtText; }
    CString GetSrcText()
        { return m_strSrcText; }

    unsigned int GetFlags()
        { return m_uiFlags;    }

    BOOL GetTgtSize(WORD *, WORD *, WORD *, WORD *);
    BOOL GetSrcSize(WORD *, WORD *, WORD *, WORD *);

    int GetLastError()
        { return m_uiLastError; }

    CString GetTokenID()
        { return m_strTokenID; }

protected:
    unsigned int    m_uiTypeID;
    unsigned int    m_uiResID;
    unsigned int    m_uiItemID;
    unsigned int    m_uiFlags;
    unsigned int    m_uiStatusFlags;
    unsigned int    m_uiLastError;
    CString         m_strItemName;
    CString         m_strSrcText;
    CString         m_strTgtText;
    CString         m_strTokenID;

};

class CTokenFile
{
public:
    CTokenFile();
    ~CTokenFile();

    // Operators
    int Open(CString strSrcFile, CString strTgtFile);

    const CToken * GetToken(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strText,
                      CString strItemName = "");

    const CToken * GetNoCaptionToken(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strItemName = "");

    // Overload GetTokenSize since some item have no text but change in size
    const CToken * GetTokenSize(CToken * pToken, WORD * px, WORD * py,
                      WORD * pcx, WORD * pcy);
    const CToken * CTokenFile::GetTokenSize(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strItemName,
                      WORD * px, WORD * py,
                      WORD * pcx, WORD * pcy);

    int GetTokenNumber()
        { return (int)m_Tokens.GetSize(); }


private:
    CObArray  m_Tokens;
    INT_PTR   m_iLastPos;
    INT_PTR   m_iUpperBound;

    CString m_strSrcFile;
    CString m_strTgtFile;
};

#endif // __TOKEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\bingen\tokgen.cpp ===
//////////////////////////////////////////////////////////////////////////
//
// The format of the token file is:
// [[TYPE ID|RES ID|Item ID|Flags|Status Flags|Item Name]]=
// this is the standar format used by several token file tools in MS.
//
///////////////////////////////////////////////////////////////////////////////
//
// Author: 	Alessandro Muti
// Date:	12/02/94
//
///////////////////////////////////////////////////////////////////////////////


#include <afx.h>
#include "iodll.h"
#include "main.h"
#include "vktbl.h"

extern CMainApp theApp;

#define RECURSIVE   0x10
#define WARNINGS    0x20

///////////////////////////////////////////////////////////////////////////////
CString CreateName(CString & strTokenName, CString strExt, int iID)
{
    CString strOutputName = strTokenName;
    int iNamePos = strTokenName.ReverseFind('\\');
    if(iNamePos!=-1) {
        strOutputName = strTokenName.Right(strTokenName.GetLength()-iNamePos-1);
    } else if(iNamePos = strTokenName.ReverseFind(':')!=-1){
        strOutputName = strTokenName.Right(strTokenName.GetLength()-iNamePos-1);
    }

    CString strID = "";
    // subst with ID name
    _itoa(iID++, strID.GetBuffer(10), 10);
    strID.ReleaseBuffer(-1);

    // Check the length of the name
    iNamePos = strOutputName.Find('.');
    if(iNamePos!=-1)
        strOutputName.SetAt(iNamePos, '_');

    strOutputName = strOutputName + "_" + strID + strExt;
    return strOutputName;
}

CString CreateName(CString & strTokenName, CString strExt, CString strIdName)
{
    CString strOutputName = strTokenName;
    int iNamePos = strTokenName.ReverseFind('\\');
    if(iNamePos!=-1) {
        strOutputName = strTokenName.Right(strTokenName.GetLength()-iNamePos-1);
    } else if(iNamePos = strTokenName.ReverseFind(':')!=-1){
        strOutputName = strTokenName.Right(strTokenName.GetLength()-iNamePos-1);
    }

    iNamePos = strOutputName.Find('.');
    if(iNamePos!=-1)
        strOutputName.SetAt(iNamePos, '_');

    iNamePos = strIdName.Find(':');
    if (iNamePos!=-1)
        strIdName.SetAt(iNamePos, '_');

    iNamePos = strIdName.Find('\\');
    if (iNamePos!=-1)
        strIdName.SetAt(iNamePos, '_');

    strOutputName = strOutputName + "_" + strIdName + strExt;
    return strOutputName;
}

///////////////////////////////////////////////////////////////////////////////
// This function will parse the source file and create the token file
CMainApp::Error_Codes CMainApp::TokGen()
{
    Error_Codes ReturnErr = ERR_NOERROR;

    WriteCon(CONERR, "%s\r\n", CalcTab("", 79, '-'));

    // Open the iodll.dll using the first file name
    HANDLE hModule = RSOpenModule(m_strInExe, NULL);
    if ((int)(INT_PTR)hModule < LAST_ERROR) {
            // error or warning
            WriteCon(CONERR, "%s", CalcTab(m_strInExe, m_strInExe.GetLength()+5, ' '));
            IoDllError((int)(INT_PTR)hModule);
            return ERR_FILE_NOTSUPP;
    } else {
        // before we do anything else we have to check how many languages we have in the file
        CString strLang;
        char szLang[8];
        BOOL b_multi_lang = FALSE;
        USHORT usInputLang = MAKELANGID(m_usIPriLangId, m_usISubLangId);

        if((b_multi_lang = RSLanguages(hModule, strLang.GetBuffer(1024))) && !IsFlag(INPUT_LANG))
        {
            // this is a multiple language file but we don't have an input language specified
            // Fail, but warn the user that he has to set the input language to continue.
            strLang.ReleaseBuffer();
            WriteCon(CONERR, "Multiple language file. Please specify an input language %s.\r\n", strLang);
            theApp.SetReturn(ERROR_FILE_MULTILANG);
            goto exit;
        }

        // Convert the language in to the hex value
        sprintf(szLang,"0x%3.3X", usInputLang);

        // Check if the input language that we got is a valid one
        if(IsFlag(INPUT_LANG) && strLang.Find(szLang)==-1)
        {
            WriteCon(CONERR, "The language %s in not a valid language for this file.\r\n", szLang);
            WriteCon(CONERR, "Valid languages are: %s.\r\n", strLang);
            theApp.SetReturn(ERROR_RES_NOT_FOUND);
            goto exit;
        }

        // Check if the user is extracting the neutral language
        if(!usInputLang)
            usInputLang = 0xFFFF;

        // Open the output file
        CStdioFile fileOut;
        if(!fileOut.Open(m_strTgtTok, CFile::modeCreate | CFile::modeReadWrite)) {
            WriteCon(CONERR, "Cannot create file: %s\r\n", CalcTab(m_strTgtTok, m_strTgtTok.GetLength()+5, ' '));
            return ERR_FILE_CREATE;
        }

        CString strOutputDir = "";
        CString strFileName = m_strInExe;
        int pos = m_strInExe.ReverseFind('\\');
        if(pos!=-1)
        {
            strFileName = m_strInExe.Right(m_strInExe.GetLength()-pos-1);
        }
        else
        if((pos = m_strInExe.ReverseFind(':'))!=-1)
        {
            strFileName = m_strInExe.Right(m_strInExe.GetLength()-pos-1);
        }

        pos = m_strTgtTok.ReverseFind('\\');
        if(pos!=-1)
        {
            strOutputDir = m_strTgtTok.Left(pos+1);
        }
        else
        if((pos = m_strTgtTok.ReverseFind(':'))!=-1)
        {
            strOutputDir = m_strTgtTok.Left(pos+1);
        }

        // inform the user ...
        WriteCon(CONOUT, "Processing\t");
        WriteCon(CONBOTH, "%s", CalcTab(strFileName, strFileName.GetLength()+5, ' '));

        if (IsFlag(WARNING))
            WriteCon(CONOUT, "\r\n");

		LPCSTR lpszType = 0L;
        LPCSTR lpszRes = 0L;
        DWORD  dwLang = 0L;
        DWORD  dwItem = 0L;
        DWORD  dwItemID = 0L;
        LPRESITEM lpResItem = NULL;

        CString strToken;
        CString strResName;
        CString strCaption;
        WORD wFlag;
        BOOL bSkip = FALSE;
        BOOL bSkipEmpty = FALSE;
        BOOL bSkipLang = FALSE;
        WORD wCount = 0;

        WORD wMsgCount = 0;
        int iPos = 1;
        int iBmpIdCount = 0;

        BOOL bVersionStampOnly = TRUE;
        BOOL bCustomResource = FALSE;

        while ((lpszType = RSEnumResType(hModule, lpszType))) {

            // Check if is one of the type we care about
            if(HIWORD(lpszType)==0)
            {
                switch(LOWORD(lpszType))
                {
                    case 2:
                    case 3:
                        if(theApp.IsFlag(CMainApp::BITMAPS))
                            bSkip = FALSE;
                        else bSkip = TRUE;
                    break;
                    case 4:
                    case 5:
                    case 6:
                    case 11:
                        bVersionStampOnly = FALSE;
                    case 9:
                    case 10:
                    case 16:
                        bSkip = FALSE;
                        break;
                    case 23:
                    case 240:
                    case 1024:
                    case 2110:
                        if(theApp.IsFlag(CMainApp::GIFHTMLINF))
                             bSkip = FALSE;
                        else
                             bSkip = TRUE;
                        bVersionStampOnly = FALSE;
                        bCustomResource = TRUE;
                        break;
                    default:
                        bSkip = TRUE;
                }
            }
            else
            {
                if (lstrcmp (lpszType, "REGINST") == 0)
                {
                   if(theApp.IsFlag(CMainApp::GIFHTMLINF))
                        bSkip = FALSE;
                   else
                        bSkip = TRUE;
                   bCustomResource = TRUE;
                }
                else
                {
                    bSkip = FALSE;
                }
                bVersionStampOnly = FALSE;
            }

            lpszRes = 0L;
            dwLang = 0L;
            dwItem = 0L;

            while ((!bSkip) && (lpszRes = RSEnumResId(hModule, lpszType, lpszRes))) {
                while ((dwLang = RSEnumResLang(hModule, lpszType, lpszRes, dwLang))) {

                    // Check if we have to skip this language
                    if(b_multi_lang && (LOWORD(dwLang)!=usInputLang))
                        bSkipLang = TRUE;
                    else
                        bSkipLang = FALSE;

                    while ((!bSkipLang) && (dwItem = RSEnumResItemId(hModule, lpszType, lpszRes, dwLang, dwItem))) {

                    // Now Get the Data
                    DWORD dwImageSize = RSGetResItemData( hModule,
											  lpszType,
											  lpszRes,
											  dwLang,
											  dwItem,
											  m_pBuf,
											  MAX_BUF_SIZE );
											
				    lpResItem = (LPRESITEM)m_pBuf;

                    if((wCount++ % 50)==0 && !(IsFlag(WARNING)))
                        WriteCon(CONOUT, ".");


                    if (HIWORD(lpszType))
                    {
                        if (lstrcmp (lpszType,"REGINST") == 0)
                        {
                            //
                            // Currently there is no id for REGINST defined
                            // in nt.  We just use this 2200 for now.
                            //
                            lpResItem->dwTypeID = 2200;
                        }
                    }

                    // Check if we want or not empty strings
                    // Allow empty strings for Dialog resources
                    switch(lpResItem->dwTypeID)
                    {
                        case 4:
                        case 16:
                            bSkipEmpty = TRUE;
                        break;
                        default:
                            bSkipEmpty = FALSE;
                        break;
                    }

                    // Version stamp use class name as res id
                    if(lpResItem->lpszResID)
                        strResName = lpResItem->lpszResID;
                    else strResName = "";

                    dwItemID = lpResItem->dwItemID;

                    if(lpResItem->dwTypeID==5 &&
                       dwItemID==0 &&
                       lpResItem->dwExtStyle){
                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=0x%08x\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID,
                                ISEXTSTYLE,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                lpResItem->dwExtStyle);
                                fileOut.WriteString(strToken);
                    }

                    // Add font info for dialogs
                    if((theApp.IsFlag(CMainApp::FONTS)
                        && (lpResItem->dwTypeID==5) && (dwItemID==0)))
                    {
                        if( (lpResItem->dwStyle & DS_SETFONT)!=DS_SETFONT ){
                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID,
                                ISDLGFONTNAME | ISDLGFONTSIZE,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0));

                                WriteCon(CONWRN, "Dialog ID %s is missing the DS_SETFONT bit. Cannot extract font information!\r\n", strToken);

                        }else{
                        // Add font information
                            if (lpResItem->bCharSet != DEFAULT_CHARSET){
                                sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s:%hd:%d\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID,
                                ISDLGFONTNAME | ISDLGFONTSIZE|ISDLGFONTCHARSET,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                Format(lpResItem->lpszFaceName),
                                lpResItem->wPointSize,
                                lpResItem->bCharSet);

                            }else{
                                sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s:%hd\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID,
                                ISDLGFONTNAME | ISDLGFONTSIZE ,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                Format(lpResItem->lpszFaceName),
                                lpResItem->wPointSize);
                            }

                                fileOut.WriteString(strToken);
	                    }

                    }


                    strCaption = lpResItem->lpszCaption;

                    // Set the flag
                    wFlag = 0;


                    if(!(bSkipEmpty && strCaption.IsEmpty()))
                    {
                        CString strExt;
                        switch(lpResItem->dwTypeID)
                        {
                            case 2:
                            case 3:
                            case 23:
                            case 240:
                            case 1024:
                            case 2110:
                            case 2200:
                            {
                                switch(lpResItem->dwTypeID)
                                {
                                    case 2:
                                        strExt = ".bmp";
                                        break;

                                    case 3:
                                        strExt = ".ico";
                                        break;

                                    case 240:
                                    case 1024:
                                        strExt = ".bin";
                                        break;

                                    case 23:
                                    case 2110:
                                        strExt = "";
                                        break;


                                    case 2200:
                                        strExt = ".inf";
                                        break;

                                }

                                // create the output name
                                CString strOutputName;
                                if(lpResItem->dwResID)
                                {
                                    strOutputName = CreateName(
                                                        strFileName,
                                                        strExt,
                                                        lpResItem->dwResID);
                                }
                                else
                                {
                                    strOutputName = CreateName(
                                                        strFileName,
                                                        strExt,
                                                        lpResItem->lpszResID);
                                }

                                // Get the image from the file
                                DWORD dwBufSize = RSGetResImage( hModule,
											                     lpszType,
											                     lpszRes,
											                     dwLang,
											                     NULL,
											                     0 );

                                BYTE * pBuf = (BYTE*)(new BYTE[dwBufSize]);

                                if(pBuf==NULL)
                                {
                                    WriteCon(CONERR,
                                             "Warning: Failed to allocate buffer for image! (%d, %d, %s, Size: %d)\r\n",
                                             lpResItem->dwTypeID,
                                             lpResItem->dwResID,
                                             lpResItem->lpszResID,
                                             dwBufSize);
                                    break;
                                }

                                dwBufSize = RSGetResImage( hModule,
			                                  lpszType,
											  lpszRes,
											  dwLang,
											  pBuf,
											  dwBufSize );

                                // write the data in to a file
                                CFile OutputFile;
                                if(!OutputFile.Open(strOutputDir+strOutputName, CFile::modeCreate | CFile::modeWrite))
                                {
                                    WriteCon(CONERR, "Cannot create file: %s\r\n",
                                        CalcTab(strOutputDir+strOutputName, strOutputName.GetLength()+strOutputDir.GetLength()+5, ' '));
                                    delete pBuf;
                                    break;
                                }

                                switch(lpResItem->dwTypeID)
                                {
                                    case 2:
                                    {
                                        BITMAPFILEHEADER bmpFileHeader;
                                        BITMAPINFO * pbmpInfo = (BITMAPINFO *)pBuf;
                                        DWORD dwNumColor = 0;
                                        if(pbmpInfo->bmiHeader.biBitCount!=24)
                                            dwNumColor = ( 1L << pbmpInfo->bmiHeader.biBitCount);

                                        bmpFileHeader.bfType = 0x4d42;
                                        bmpFileHeader.bfSize = (dwBufSize+sizeof(BITMAPFILEHEADER))/4;
                                        bmpFileHeader.bfReserved1 = 0;
                                        bmpFileHeader.bfReserved2 = 0;
                                        bmpFileHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + pbmpInfo->bmiHeader.biSize + dwNumColor*sizeof(RGBQUAD);

                                        OutputFile.Write(&bmpFileHeader, sizeof(BITMAPFILEHEADER));
                                    }
                                    break;
                                    case 3:
                                    {
                                        ICONHEADER icoHeader;
                                        BITMAPINFOHEADER * pbmpInfoH = (BITMAPINFOHEADER*)pBuf;

                                        icoHeader.idReserved = 0;
                                        icoHeader.idType = 1;
                                        icoHeader.idCount = 1;
                                        icoHeader.bWidth = LOBYTE(pbmpInfoH->biWidth);
                                        icoHeader.bHeight = LOBYTE(pbmpInfoH->biWidth);
                                        icoHeader.bColorCount = 16;
                                        icoHeader.bReserved = 0;
                                        icoHeader.wPlanes = 0;
                                        icoHeader.wBitCount = 0;
                                        icoHeader.dwBytesInRes = dwBufSize;
                                        icoHeader.dwImageOffset = sizeof(ICONHEADER);

                                        OutputFile.Write(&icoHeader, sizeof(ICONHEADER));
                                    }
                                    case 23:
                                    case 240:
                                    case 1024:
                                    case 2110:
                                    case 2200:
                                    {
                                        //
                                        // No header for html stuff.
                                        //
                                        break;
                                    }
                                    break;
                                    default:
                                    break;
                                }

                                OutputFile.Write(pBuf, dwBufSize);

                                OutputFile.Close();
                                delete pBuf;

                                strCaption = strOutputName;
                            }
                            break;
                            case 4:
                                if(lpResItem->dwFlags & MF_POPUP) {
									wFlag = ISPOPUP;

									// check if this popup has a valid ID
									if (LOWORD(dwItemID)==0xffff)
										wFlag |= OLD_POPUP_ID;

                                    dwItemID = (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID);
                                }
                                else if (LOWORD(dwItemID)==0xffff)
                                {
                                    dwItemID = HIWORD(dwItemID);
                                    WriteCon (CONWRN,  TEXT("Token [[%u|%u|%u|%u|%u|\"%s\"]] is generated with a suspicious ID. Please check the resource file for invalid ID's.\n"),
                                               lpResItem->dwTypeID,
                                               lpResItem->dwResID,
                                               dwItemID,
                                               wFlag,
                                               ST_TRANSLATED,
                                               strResName.GetBuffer(0));

                                }

                            break;
                            case 5:
                                if(dwItemID==0) {
                                    wFlag = ISCAP;
                                }

                                // check if this is a duplicated id
                                if (LOWORD(dwItemID)==0xffff)
							        wFlag |= ISDUP;

                                dwItemID = (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID);
                            break;
                            case 9:
                            {
                                CAccel accel(lpResItem->dwFlags, lpResItem->dwStyle);
                                strCaption = accel.GetText();

                                // check if this is a duplicated ID
                                if(HIWORD(dwItemID))
                                {
                                    wFlag |= ISDUP;
                                }
                            }
                            break;
                            case 11:
                                dwItemID = LOWORD(dwItemID);
                            break;
                            case 16:
                                strResName = lpResItem->lpszClassName;
                            break;
                            default:
                            break;
                        }

                        // Create the token file
                        if(lpResItem->dwTypeID==11 && theApp.IsFlag(CMainApp::SPLIT))
                        {
                            // Search for the \r\n and replace them
                            while((iPos = strCaption.Find("\r\n"))!=-1)
                            {
                                sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                    TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s\\r\\n\n"),
                                    lpResItem->dwTypeID,
                                    lpResItem->dwResID,
                                    dwItemID,
                                    wFlag | wMsgCount++,
                                    ST_TRANSLATED,
                                    strResName.GetBuffer(0),
                                    Format(strCaption.Left(iPos)));

                                strCaption = strCaption.Right(strCaption.GetLength()-2-iPos);
                                fileOut.WriteString(strToken);
                            }
                            wMsgCount = 0;
                        }
                        else
                        {
                            if(lpResItem->dwTypeID==16 &&
                                theApp.IsFlag(CMainApp::NOVERSION) &&
                                (strResName==TEXT("FileVersion") ||
                                strResName==TEXT("ProductVersion") ||
                                strResName==TEXT("Platform"))){
                                //
                                // do not generate token for these resources
                                //
                            }else{
                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID, /*(LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID),*/
                                wFlag,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                Format(strCaption));

                            fileOut.WriteString(strToken);
                            }
                        }

                        // If this is a dialog box add the coordinates
                        if(lpResItem->dwTypeID==5)
                        {
                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%hu %hu %hu %hu\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID),
                                wFlag | ISCOR,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                lpResItem->wX,
                                lpResItem->wY,
                                lpResItem->wcX,
                                lpResItem->wcY);

                            fileOut.WriteString(strToken);

                         //Extract STATIC control alignment style info
                         if (LOBYTE(lpResItem->wClassName) == 0x82  &&
                             theApp.IsFlag(CMainApp::ALIGNMENT))
                         {

                            CHAR szBuf[20]="SS_LEFT";
                            if ((lpResItem->dwStyle & SS_CENTER) == SS_CENTER)
                                lstrcpy(szBuf, "SS_CENTER");
                            else if ((lpResItem->dwStyle & SS_RIGHT)==SS_RIGHT)
                                lstrcpy(szBuf, "SS_RIGHT");

                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID),
                                wFlag | ISALIGN,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                szBuf);

                            fileOut.WriteString(strToken);
                         }
                        }

                    }
                    else
                    {
                        // If this is a dialog box add the coordinates
                        if(lpResItem->dwTypeID==5) {

                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%hu %hu %hu %hu\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID),
                                wFlag | ISCOR,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                lpResItem->wX,
                                lpResItem->wY,
                                lpResItem->wcX,
                                lpResItem->wcY);

                            fileOut.WriteString(strToken);
                        }
                    }
                    } // end while
                }
            }
        }

		fileOut.Close();

        // Check the size of the new file and remove it if empty...
        CFileStatus fstat;	
        if(CFile::GetStatus(m_strTgtTok, fstat))
            if(fstat.m_size==0)
                CFile::Remove(m_strTgtTok);

        WriteCon(CONBOTH, " %hu Items\r\n", wCount);
        if(bVersionStampOnly) {
            ReturnErr = ERR_FILE_VERSTAMPONLY;
            theApp.SetReturn(ERROR_FILE_VERSTAMPONLY);
            WriteCon(CONWRN, "%s : Version Stamping only!\r\n", strFileName);
        }
        if(bCustomResource) {
            SetReturn(ERROR_FILE_CUSTOMRES);
            WriteCon(CONWRN, "%s : Custom resource!\r\n", strFileName);
        }
	}

exit:
    RSCloseModule(hModule);

    return ReturnErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\delcert\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\delcert\afxres.h ===
// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rsrc\afxres.h ===
// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rsrc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\inc\iodll.h ===
//+---------------------------------------------------------------------------
//
//  File:       iodll.h
//
//  Contents:   Declarations for the I/O API Layer DLL
//
//  Classes:    none
//
//  History:    27-May-93   alessanm    created
//
//----------------------------------------------------------------------------
#ifndef _IODLL_H_
#define _IODLL_H_


//////////////////////////////////////////////////////////////////////////////
// Type declaration, common to all the module in the Reader/Writer
//////////////////////////////////////////////////////////////////////////////
#define DllExport

typedef unsigned char * LPUCHAR;
typedef void  *      LPVOID;

#define LAST_WRN    100 // last valid value for warning
typedef enum Errors
{                              
    ERROR_NO_ERROR                  = 0,                
    // Warning have values smaller than LAST_WRN
    ERROR_RW_NO_RESOURCES           = 1,    
    ERROR_RW_VXD_MSGPAGE            = 2,
    ERROR_IO_CHECKSUM_MISMATCH      = 3,   
    ERROR_FILE_CUSTOMRES            = 4,
    ERROR_FILE_VERSTAMPONLY         = 5,
    ERROR_RET_RESIZED               = 6,
    ERROR_RET_ID_NOTFOUND           = 7,
    ERROR_RET_CNTX_CHANGED          = 8,
    ERROR_RET_INVALID_TOKEN         = 9,
    ERROR_RET_TOKEN_REMOVED         = 10,
    ERROR_RET_TOKEN_MISMATCH        = 11,
	
    // Errors will have positive values
    ERROR_HANDLE_INVALID            = LAST_WRN + 1,
    ERROR_READING_INI               = LAST_WRN + 2,        
    ERROR_NEW_FAILED                = LAST_WRN + 3,
    ERROR_OUT_OF_DISKSPACE          = LAST_WRN + 4,
    ERROR_FILE_OPEN                 = LAST_WRN + 5,
    ERROR_FILE_CREATE               = LAST_WRN + 6,
    ERROR_FILE_INVALID_OFFSET       = LAST_WRN + 7,
    ERROR_FILE_READ                 = LAST_WRN + 8,
    ERROR_FILE_WRITE                = LAST_WRN + 9,
    ERROR_DLL_LOAD                  = LAST_WRN + 10,
    ERROR_DLL_PROC_ADDRESS          = LAST_WRN + 11,
    ERROR_RW_LOADIMAGE              = LAST_WRN + 12,
    ERROR_RW_PARSEIMAGE             = LAST_WRN + 13,
    ERROR_RW_GETIMAGE               = LAST_WRN + 14,
    ERROR_RW_NOTREADY               = LAST_WRN + 15,
    ERROR_RW_BUFFER_TOO_SMALL       = LAST_WRN + 16,
    ERROR_RW_INVALID_FILE           = LAST_WRN + 17,
    ERROR_RW_IMAGE_TOO_BIG          = LAST_WRN + 18,
    ERROR_RW_TOO_MANY_LEVELS        = LAST_WRN + 19,
    ERROR_IO_INVALIDITEM            = LAST_WRN + 20,
    ERROR_IO_INVALIDID              = LAST_WRN + 21,
    ERROR_IO_INVALID_DLL            = LAST_WRN + 22,
    ERROR_IO_TYPE_NOT_SUPPORTED     = LAST_WRN + 23,
    ERROR_IO_INVALIDMODULE          = LAST_WRN + 24,
    ERROR_IO_RESINFO_NULL           = LAST_WRN + 25,
    ERROR_IO_UPDATEIMAGE            = LAST_WRN + 26,
    ERROR_IO_FILE_NOT_SUPPORTED     = LAST_WRN + 27,
    ERROR_FILE_SYMPATH_NOT_FOUND    = LAST_WRN + 28,
    ERROR_FILE_MULTILANG            = LAST_WRN + 29,
    ERROR_IO_SYMBOLFILE_NOT_FOUND   = LAST_WRN + 30,
    ERROR_RES_NOT_FOUND             = LAST_WRN + 31
};

#define LAST_ERROR      200 // last valid value for IODLL error. System error get passed as LAST_ERROR+syserr
#define IODLL_LAST_ERROR      LAST_ERROR // last valid value for IODLL error. System error get passed as LAST_ERROR+syserr

typedef enum ResourceType
{
	RS_ALL     = 0,
	RS_CURSORS = 1,
	RS_BITMAPS = 2 ,
	RS_ICONS   = 3,
	RS_MENUS   = 4,
	RS_DIALOGS = 5,
	RS_STRINGS = 6,
	RS_FONTDIRS= 7,
	RS_FONTS   = 8,
	RS_ACCELERATORS = 9,
	RS_RCDATA  = 10,
	RS_ERRTABLES = 11,
	RS_GROUP_CURSORS = 12,
	RS_GROUP_ICONS = 14,
	RS_NAMETABLES = 15,
	RS_VERSIONS = 16,
	RS_CUSTOMS = 100
} RESTYPES;

typedef struct _ResItem
{
		DWORD   dwSize;             // Size of the buffer to hold the structure
		
		WORD    wX;                 // POSITION
		WORD    wY;
		WORD    wcX;                // SIZE
		WORD    wcY;
		
		DWORD   dwCheckSum;         // Checksum for bitmap
		DWORD   dwStyle;            // Styles
		DWORD   dwExtStyle;         // Extended style
		DWORD   dwFlags;            // Menu flags
		
		DWORD   dwItemID;           // Item Identifier
		DWORD   dwResID;            // Resource identifier (if ordinal)
		DWORD   dwTypeID;           // Type identifier (if Ordinal)
		DWORD   dwLanguage;         // Language identifier
		
		DWORD   dwCodePage;         // Code page
		WORD    wClassName;         // Class name (if ordinal)
		WORD    wPointSize;         // Point Size
		WORD    wWeight;            // Weight 
		BYTE    bItalic;            // Italic
		BYTE    bCharSet;           // Charset
		
		LPSTR   lpszClassName;      // Class name (if string)
		LPSTR   lpszFaceName;       // Face Name 
		LPSTR   lpszCaption;        // Caption
		LPSTR   lpszResID;          // Resource identifier (if string)
		LPSTR   lpszTypeID;         // Type identifier (if string)
		
} RESITEM, * PRESITEM, FAR * LPRESITEM;

typedef struct _Settings
{
		UINT	cp;
        BOOL    bAppend;        // Append resource to win32 files
        BOOL    bUpdOtherResLang; //update language info of res. not specified.
        char    szDefChar[2];
} SETTINGS, * LPSETTINGS;


//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Module Opening/Closing API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
HANDLE 
APIENTRY 
RSOpenModule(
	LPCSTR   lpszSrcfilename,        // File name of the executable to use as source file
	LPCSTR   lpszfiletype );         // Type of the executable file if known

extern "C"
DllExport
HANDLE 
APIENTRY 
RSOpenModuleEx(
	LPCSTR   lpszSrcfilename,       // File name of the executable to use as source file
	LPCSTR   lpszfiletype,			// Type of the executable file if known
	LPCSTR   lpszRDFfile,           // Resource Description File (RDF)
    DWORD    dwFlags );             // Flags to be passed to the RW to specify particular behaviour
                                    // LOWORD is for iodll while HIWORD if for RW
extern "C"
DllExport
UINT 
APIENTRY 
RSCloseModule(
	HANDLE  hResFileModule );       // Handle to the session opened before

extern "C"
DllExport
HANDLE
APIENTRY 
RSHandleFromName(
	LPCSTR   lpszfilename );        // Handle to the session with the file name specified

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Enumeration API                        
//--------------------------------------------------------------------------------------------
	
extern "C"
DllExport
LPCSTR
APIENTRY 
RSEnumResType(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszPrevResType);       // Previously enumerated type

extern "C"
DllExport
LPCSTR
APIENTRY 
RSEnumResId(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszPrevResId);         // Previously enumerated id

extern "C"
DllExport
DWORD
APIENTRY 
RSEnumResLang(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwPrevResLang);         // Previously enumerated language
    
extern "C"
DllExport
DWORD
APIENTRY 
RSEnumResItemId(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language
	DWORD   dwPrevResItemId);       // Previously enumerated item id

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Data acquisition API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT 
APIENTRY 
RSGetResItemData(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language
	DWORD   dwResItemId,                    // Previously enumerated item id
	LPVOID  lpbuffer,           // Pointer to the buffer that will get the resource info
	UINT    uiBufSize);                     // Size of the buffer that will hold the resource info

extern "C"
DllExport
DWORD
APIENTRY 
RSGetResImage(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language                
	LPVOID  lpbuffer,                       // Pointer to the buffer to get the resource Data
	DWORD   dwBufSize);                     // Size of the allocated buffer
	
//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Update API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSUpdateResItemData(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language                
	DWORD   dwResItemId,            // Previously enumerated items id
	LPVOID  lpbuffer,                       // Pointer to the buffer to the resource item Data
	UINT    uiBufSize);                     // Size of the buffer
	
extern "C"
DllExport
DWORD
APIENTRY 
RSUpdateResImage(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language                
	DWORD   dwUpdLang,                      // Desired output language                
	LPVOID  lpbuffer,                       // Pointer to the buffer to the resource item Data
	DWORD   dwBufSize);                     // Size of the buffer
	
//--------------------------------------------------------------------------------------------           
//********************************************************************************************
//      Conversion API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSUpdateFromResFile(
	HANDLE  hResFileModule,         // Handle to the file session
	LPSTR   lpszResFilename);       // The resource filename to be converted
	
//--------------------------------------------------------------------------------------------           
//********************************************************************************************
//      Writing API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSWriteResFile(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszTgtfilename,        // The new filename to be generated
	LPCSTR  lpszTgtfileType,        // Target Resource type 16/32
	LPCSTR  lpszSymbolPath);        // Symbol path for updating symbol checksum

extern "C"
DllExport
HANDLE
APIENTRY
RSCopyModule(
    HANDLE  hSrcfilemodule,         // Handle to the source file
    LPCSTR  lpszModuleName,            // Name of the new module filename
    LPCSTR  lpszfiletype );         // Type of the target module


//--------------------------------------------------------------------------------------------           
//********************************************************************************************
//      Recognition API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSFileType(
	LPCSTR   lpszfilename,   // File name of the executable to use as source file
	LPSTR    lpszfiletype ); // Type of the executable file if known


extern "C"
DllExport
UINT
APIENTRY 
RSLanguages(
	HANDLE  hfilemodule,      // Handle to the file
	LPSTR   lpszLanguages );  // will be filled with a string of all the languages in the file
  

//--------------------------------------------------------------------------------------------           
//********************************************************************************************
//      Global Settings API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSSetGlobals(    
	SETTINGS	settings);         // Set the global variable, like CP to use.

extern "C"
DllExport
UINT
APIENTRY 
RSGetGlobals(    
	LPSETTINGS	lpSettings);         // Retrieve the global variable


     
#endif   // _IODLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\delcert\delcert.cpp ===
////    DelCert - Delete all certificates in Win32 image
//





/////   delCert Command line
//
//c     delCert Executable
//
//p     Executable: Win32 binary to update
//








#pragma warning( disable : 4786 )       // map creates some ridiculously long debug identifiers


#include "stdio.h"
#include "windows.h"
#include "imagehlp.h"
#include "time.h"

#define DBG 1


void __cdecl DebugMsg(char *fmt, ...) {

    va_list vargs;

    va_start(vargs, fmt);
    vfprintf(stderr, fmt, vargs);
}

BOOL g_fError = FALSE;


#define warn DebugMsg

#define MUST(a,b) {HRESULT hr; hr = (a); if (hr!= S_OK) {if (!g_fError) DebugMsg b; g_fError = TRUE; return E_FAIL;};}
#define SHOULD(a,b) {HRESULT hr; hr = (a); if (hr!= S_OK) {DebugMsg b; g_fWarn = TRUE; return S_FALSE;};}


#if DBG

    #pragma message("Checked build")

    #define OK(a) {HRESULT hr; hr = (a); if (hr!= S_OK) {DebugMsg("%s(%d): error RSRC999 : HRESULT not S_OK: "#a"\n", __FILE__, __LINE__); return hr;};}
    #define ASSERT(a) {if (!(a)) {DebugMsg("%s(%d): error RSRC999 : Assertion failed: "#a"\n", __FILE__, __LINE__); return E_UNEXPECTED;};}

#else

    #pragma message ("Free build")

    #define OK(a) {HRESULT hr; hr = (a); if (hr != S_OK) return hr;}
    #define ASSERT(a)  {if (!(a)) {return E_UNEXPECTED;};}

#endif




////    Mapped files
//
//      File mapping is used to read executable and token files.
//
//      File mapping is also used to update in place checksum information
//      in executable and symbol files.


class MappedFile {

    HANDLE  m_hFileMapping;
    BOOL    fRW;             // True when writeable
    char    m_szFileName[MAX_PATH];

public:

    BYTE   *m_pStart;
    BYTE   *m_pLimit;

    MappedFile() {m_hFileMapping = NULL;}

    HRESULT Open(const char *pcFileName, BOOL fWrite) {

        HANDLE hFile;

        strcpy(m_szFileName, pcFileName);

        hFile = CreateFileA(
                           pcFileName,
                           GENERIC_READ     | (fWrite ? GENERIC_WRITE : 0),
                           FILE_SHARE_READ  | (fWrite ? FILE_SHARE_WRITE | FILE_SHARE_DELETE : 0 ),
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        ASSERT(hFile != INVALID_HANDLE_VALUE);

        m_hFileMapping = CreateFileMapping(
                                          hFile,
                                          NULL,
                                          fWrite ? PAGE_READWRITE : PAGE_WRITECOPY,
                                          0,0, NULL);

        ASSERT(m_hFileMapping != NULL);

        m_pStart = (BYTE*) MapViewOfFile(
                                        m_hFileMapping,
                                        fWrite ? FILE_MAP_WRITE : FILE_MAP_READ,
                                        0,0, 0);

        ASSERT(m_pStart != NULL);

        m_pLimit = m_pStart + GetFileSize(hFile, NULL);
        CloseHandle(hFile);

        fRW = fWrite;
        return S_OK;
    }




    DWORD CalcChecksum() {

        DWORD dwHeaderSum;
        DWORD dwCheckSum;

        if (CheckSumMappedFile((void*)m_pStart, (DWORD)(m_pLimit-m_pStart), &dwHeaderSum, &dwCheckSum) == NULL) {
            return 0;
        } else {
            return dwCheckSum;
        }
    }




    HRESULT Close() {
        if (m_pStart) {
            UnmapViewOfFile(m_pStart);
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
            m_pStart = NULL;
        }
        return S_OK;
    }
};









class Win32Executable : public MappedFile {

    IMAGE_NT_HEADERS      *m_pNtHeader;
    IMAGE_SECTION_HEADER  *m_pSections;

public:

    DWORD GetChecksum()      const {return m_pNtHeader->OptionalHeader.CheckSum;}
    void  SetChecksum(DWORD dwChecksum) {m_pNtHeader->OptionalHeader.CheckSum=dwChecksum;}

    void  SetCertificateRVA (DWORD rva)
    {
        m_pNtHeader->OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]
        .VirtualAddress
        = rva;
    }

    HRESULT Open(const char *pcFileName, BOOL fWrite) {

        int i;

        OK(MappedFile::Open(pcFileName, fWrite));


        MUST((    *(WORD*)m_pStart == IMAGE_DOS_SIGNATURE
                  &&  *(WORD*)(m_pStart+0x18) >= 0x40)    // WinVer >= 4
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC501: %s is not an executable file\n", pcFileName));

        m_pNtHeader = (IMAGE_NT_HEADERS*)(m_pStart + *(WORD*)(m_pStart+0x3c));

        MUST((m_pNtHeader->Signature == IMAGE_NT_SIGNATURE)
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC502: %s is not a Win32 executable file\n", pcFileName));

        m_pSections     = (IMAGE_SECTION_HEADER*)(m_pNtHeader+1);

        return S_OK;
    }
};













void DeleteCertificates(
                       const char *fileName
                       )
{

    HANDLE fileHandle = CreateFile(
                                  fileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  0,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL
                                  );

    if (fileHandle == INVALID_HANDLE_VALUE) {
        warn("Could not access %s\n", fileName);
        return;
    }

    DWORD certificateCount;
    DWORD *certificateIndices;

    if (!ImageEnumerateCertificates(
                                   fileHandle,
                                   CERT_SECTION_TYPE_ANY,
                                   &certificateCount,
                                   NULL,
                                   0
                                   )) {
        warn("Could not enumerate certificates in %s.\n", fileName);
        CloseHandle(fileHandle);
        return;
    }

    if (certificateCount == 0) {
        warn("No certificates found in %s.\n", fileName);
        CloseHandle(fileHandle);
        return;
    }


    certificateIndices = new DWORD[certificateCount];

    if (certificateIndices == NULL) {
        CloseHandle(fileHandle);
        warn("Couldn't allocate buffer for %d certificate indices for %s.\n", certificateCount, fileName);
        return;
    }

    ImageEnumerateCertificates(
                              fileHandle,
                              CERT_SECTION_TYPE_ANY,
                              &certificateCount,
                              certificateIndices,
                              certificateCount
                              );

    if (certificateCount == 0) {
        warn("Couldn't get certificate indices for %s.\n", fileName);
        CloseHandle(fileHandle);
        return;
    }


    for (DWORD i=0; i<certificateCount; i++) {
        if (!ImageRemoveCertificate(fileHandle, certificateIndices[i])) {
            warn("Could not remove certificate index %d from %s\n", certificateIndices[i], fileName);
            CloseHandle(fileHandle);
            return;
        }
    }


    warn("All %d certificate(s) removed from %s.\n", certificateCount, fileName);
    CloseHandle(fileHandle);


    // Now clear the rva of any security certificates

    Win32Executable w32x;

    if (w32x.Open(fileName, TRUE) != S_OK) {
        warn("Could not map %s to update security certificate RVA\n", fileName);
        return;
    }

    w32x.SetCertificateRVA(0);
    w32x.SetChecksum(w32x.CalcChecksum());

    w32x.Close();

    warn("Certificate section virtual address zeroed in %s section index.\n", fileName);
}


////    Parameter parsing
//
//


char g_cSwitch = '-';   // Switch character is recorded the first time one is seen


void SkipWhitespace(char** p, char* pE) {
    while ((*p<pE) && ((**p==' ')||(**p==9))) (*p)++;
}


void ParseToken(char** p, char* pE, char* s, int l) {

    // Parse up to whitespace into string s
    // Guarantee zero terminator and modify no more than l chars
    // Return with p beyond whitespace


    if (*p < pE  &&  **p == '\"') {

        // Quoted parameter

        (*p)++;  // Skip over leading quote

        while (l>0  &&  *p<pE  &&  **p!='\"') {
            *s=**p;  s++;  (*p)++;  l--;
        }

        // Skip any part of token that didn't fit s

        while (*p<pE  &&  **p!='\"') { // Skip up to terminating quote
            (*p)++;
        }

        if (*p<pE) { // Skip over terminating quote
            (*p)++;
        }

    } else {

        // Unquoted parameter


        while ((l>0) && (*p<pE) && (**p>' ')) {
            *s=**p;  s++;  (*p)++;
            l--;
        }

        // Skip any part of token that didn't fit into s
        while ((*p<pE) && (**p>' ')) (*p)++;
    }


    if (l>0)
        *s++ = 0;
    else
        *(s-1) = 0;

    SkipWhitespace(p, pE);
}


void ParseName(char** p, char* pE, char* s, int l) {

    // Uses ParseToken to parse a name such as a filename.
    // If the name starts with '/' or '-' it is assumed to be
    // an option rather than a filename and ParseName returns
    // a zero length string.

    if (*p<pE  &&  **p==g_cSwitch) {

        // This is an option and should not be treated as a name argument

        s[0] = 0;

    } else {

        ParseToken(p, pE, s, l);
    }
}





void DisplayUsage() {
    fprintf(stdout, "Usage: delCert executable\n");
}


DWORD g_dwOptions = 0;
#define OPTHELP 1


HRESULT ProcessParameters() {

    char   *p;      // Current command line character
    char   *pE;     // End of command line
    char   *pcStop;

    char    token        [MAX_PATH];
    char    szExecutable [MAX_PATH];

    int     i,j;
    int     cFiles    = 0;

    BOOL    fArgError = FALSE;

    p  = GetCommandLine();
    pE = p+strlen((char *)p);


    // Skip command name
    ParseToken(&p, pE, token, sizeof(token));

    while (p<pE) {
        ParseToken(&p, pE, token, sizeof(token));

        if (    token[0] == '-'
                ||  token[0] == '/') {

            // Process command option(s)

            i = 1;
            g_cSwitch = token[0];       // Argument may start with the other switch character
            CharLower((char*)token);
            while (token[i]) {
                switch (token[i]) {
                    case '?':
                    case 'h': g_dwOptions |= OPTHELP;      break;

                    default:
                        fprintf(stderr, "Unrecognised argument '%c'.\n", token[i]);
                        fArgError = TRUE;
                        break;
                }
                i++;
            }

        } else {

            // Process filename

            switch (cFiles) {
                case 0:  strcpy(szExecutable, token); break;
            }
            cFiles++;
        }
    }


    if (    fArgError
            ||  g_dwOptions & OPTHELP) {

        DisplayUsage();
        return S_OK;

    } else if (cFiles != 1) {

        DisplayUsage();
        return E_INVALIDARG;

    } else {

        // We have valid parameters

        DeleteCertificates(szExecutable);
        return S_OK;
    }
}






int _cdecl main(void) {

    if (SUCCEEDED(ProcessParameters())) {

        return 0;       // No problems

    } else {

        return 2;       // Error(s)

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\io\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by Script1.rc
//
#define IDR_VERSION1                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\io\iodll.cpp ===
//+---------------------------------------------------------------------------
//
//  File:   iodll.cpp
//
//  Contents:   Implementation for the I/O module
//
//  Classes:
//
//  History:    27-May-93   alessanm    created
//              25-Jun-93   alessanm    eliminated TRANSCONTEXT and added RESITEM
//
//----------------------------------------------------------------------------

#include <afx.h>
#include <afxwin.h>
#include <afxcoll.h>
#include <iodll.h>
#include <limits.h>
#include <memory.h>
#include <malloc.h>
#include <stdlib.h>
#include <dos.h>
#include <errno.h>
#include <setjmp.h>

//
// UlongToHandle is defined in basetsd.h now
//
// #define UlongToHandle(x)  (HANDLE)UlongToPtr(x)
//


/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };


/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define MODULENAME "iodll.dll"
#define Pad4(x) ((((x+3)>>2)<<2)-x)
#define PadPtr(x) ((((x+(sizeof(PVOID)-1))/sizeof(PVOID))*sizeof(PVOID))-x)

#define LPNULL 0L

// INI Informations
#define SECTION "iodll32"
#define MAXENTRYBUF 1024    // Buffer to entry in the INI file
#define MAXDLLNUM 20        // We hard-code the number of DLL. TO fix later

#define MAXKEYLEN  32

// HANDLE Informations
#define FIRSTVALIDVALUE LAST_ERROR // The first valid value for an HANDLE to a module

typedef unsigned char UCHAR;
typedef char * PCHAR;
typedef UCHAR * PUCHAR;
/////////////////////////////////////////////////////////////////////////////
// Function Declarations

/////////////////////////////////////////////////////////////////////////////
// Helper Function Declarations

/////////////////////////////////////////////////////////////////////////////
// Class declarations

class CFileModule;

class CItemInfo : public CObject
{
public:
    CItemInfo(  WORD x, WORD y,
                WORD cx, WORD cy,
                DWORD dwPosId, WORD wPos,
                DWORD dwStyle, DWORD dwExtendStyle,
                CString szText );

    CItemInfo( LPRESITEM lpResItem, WORD wTabPos );

    CItemInfo( const CItemInfo &iteminfo );

    WORD    GetId()         { return LOWORD(m_dwPosId); }
    CString GetCaption()    { return m_szCaption; }
    WORD    GetX()          { return m_wX; }
    WORD    GetY()          { return m_wY; }
    WORD    GetcX()         { return m_wCX; }
    WORD    GetcY()         { return m_wCY; }
    DWORD   GetPosId()      {
		if (LOWORD(m_dwPosId)==0xFFFF)
            return GetTabPosId();
        return m_dwPosId;
    }
    DWORD   GetStyle()      { return m_dwStyle; }
    DWORD   GetExtStyle()   { return m_dwExtStyle; }
    DWORD   GetTabPosId();
    CString GetFaceName()   { return m_szFaceName; }
    CString GetClassName()  { return m_szClassName; }
    DWORD   GetCheckSum()   { return m_dwCheckSum; }
    DWORD   GetFlags()      { return m_dwFlags; }
    DWORD   GetCodePage()   { return m_dwCodePage; }
    DWORD   GetLanguage()   { return m_dwLanguage; }
    WORD    GetClassNameID(){ return m_wClassName; }
    WORD    GetPointSize()  { return m_wPointSize; }
    WORD    GetWeight()     { return m_wWeight; }
    BYTE    GetItalic()     { return m_bItalic; }
    BYTE    GetCharSet()    { return m_bCharSet; }



    UINT    UpdateData( LPVOID lpbuffer, UINT uiBufSize );
    UINT    UpdateData( LPRESITEM lpResItem );

    void    SetPos( WORD wPos );
    void    SetId( WORD wId );

private:

    WORD    m_wX;
    WORD    m_wY;

    WORD    m_wCX;
    WORD    m_wCY;

    DWORD   m_dwCheckSum;
    DWORD   m_dwStyle;
    DWORD   m_dwExtStyle;
    DWORD   m_dwFlags;

    DWORD   m_dwPosId;
    WORD    m_wTabPos;

    DWORD   m_dwCodePage;
    DWORD   m_dwLanguage;
    WORD    m_wClassName;
    WORD    m_wPointSize;
    WORD    m_wWeight;
    BYTE    m_bItalic;
    BYTE    m_bCharSet;

    CString m_szClassName;
    CString m_szFaceName;
    CString m_szCaption;

};

// This class will keep all the information about each of the resources in the file
class CResInfo : public CObject
{
public:
    CResInfo( WORD Typeid, CString sztypeid,
              WORD nameid, CString sznameid,
              DWORD dwlang, DWORD dwsize, DWORD dwfileoffset, CFileModule* pFileModule );

    ~CResInfo();

    WORD    GetTypeId()
        { return m_TypeId; }
    CString GetTypeName()
        { return m_TypeName; }

    WORD    GetResId()
        { return m_ResId; }
    CString GetResName()
        { return m_ResName; }

    DWORD   GetSize()
        { return m_dwImageSize; }

    DWORD   GetFileOffset()
        { return m_FileOffset; }

    DWORD   GetLanguage()
        { return (DWORD)LOWORD(m_Language); }

    DWORD   GetAllLanguage()
        { return m_Language; }

    BOOL    GetUpdImage()
        { return m_ImageUpdated; }

    DWORD   LoadImage( CString lpszFilename, HINSTANCE hInst );
    void    FreeImage();

    DWORD   ParseImage( HINSTANCE hInst );
    DWORD   GetImage( LPCSTR lpszFilename, HINSTANCE hInst, LPVOID lpbuffer, DWORD dwBufSize );
    DWORD   UpdateImage( LONG dwSize, HINSTANCE hInst, LPCSTR lpszType );
    DWORD   ReplaceImage( LPVOID lpNewImage, DWORD dwNewImageSize, DWORD dwLang );

    UINT    GetData( LPCSTR lpszFilename, HINSTANCE hInst,
                     DWORD dwItem, LPVOID lpbuffer, UINT uiBufSize );

    UINT    UpdateData(  LPCSTR lpszFilename, HINSTANCE hInst,
                         DWORD dwItem, LPVOID lpbuffer, UINT uiBufSize );

    void    SetFileOffset( DWORD dwOffset )
        { m_FileOffset = dwOffset; }

	void    SetFileSize( DWORD dwSize )
        { m_FileSize = dwSize; }

    void    SetImageUpdated( BYTE bStatus )
        { m_ImageUpdated = bStatus; }

    void    FreeItemArray();

    DWORD   EnumItem( LPCSTR lpszFilename, HINSTANCE hInst, DWORD dwPrevItem );
    UINT    Copy( CResInfo* pResInfo, CString szFileName, HINSTANCE hInst );
    UINT    CopyImage( CResInfo* pResInfo );
    int     AddItem( CItemInfo ItemInfo );

private:
    DWORD       m_FileOffset;
    DWORD       m_FileSize;

    DWORD       m_Language;

    CString     m_TypeName;
    WORD        m_TypeId;

    CString     m_ResName;
    WORD        m_ResId;

    BYTE far *  m_lpImageBuf; // This is a pointer to the raw data in the resource
    DWORD       m_dwImageSize;
    BYTE        m_ImageUpdated;

    CObArray    m_ItemArray;
    int         m_ItemPos;

    //
    // FileModule the resource belongs to
    //

    CFileModule* m_pFileModule;

    UINT    AllocImage(DWORD dwSize);
};

// This class has all the information we need on each of the modules that the user
// open. When the DLL is discarded this class will clean all the memory allocated.
class CFileModule : public CObject
{
public:
    CFileModule();
    CFileModule( LPCSTR, LPCSTR, int, DWORD );
    ~CFileModule();

    LPCSTR  EnumType( LPCSTR lpszPrevType );
    LPCSTR  EnumId( LPCSTR lpszType, LPCSTR lpszPrevId );
    DWORD   EnumLang( LPCSTR lpszType, LPCSTR lpszId, DWORD dwPrevLang );
    DWORD   EnumItem( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang, DWORD dwPrevItem );

    HINSTANCE   LoadDll();      // Load the Dll Hinstance
    void        FreeDll();      // Free the DLL hInstance
    UINT        CleanUp();      // Clean the module memory

    HINSTANCE GetHInstance()
        { return m_DllHInstance; }

    CString GetName()
        { return m_SrcFileName; }
    CString GetRDFName()
        { return m_RdfFileName; }

    CResInfo* GetResInfo( LPCSTR lpszType, LPCSTR lpszId, DWORD dwPrevLang );
    CResInfo* GetResInfo( int iPos )
        { return ((CResInfo*)m_ResArray.GetAt(iPos)); }

    DWORD   GetImage( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang,
                      LPVOID lpbuffer, DWORD dwBufSize );

    DWORD   UpdateImage( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang,
                      DWORD dwUpdLang, LPVOID lpbuffer, DWORD dwBufSize );

    UINT    GetData( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang, DWORD dwItem,
                     LPVOID lpbuffer, UINT uiBufSize );

    UINT    UpdateData( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang, DWORD dwItem,
                        LPVOID lpbuffer, UINT uiBufSize );

    int AddTypeInfo( INT_PTR iPos, int iId, CString szId );

    int AddResInfo(
              WORD Typeid, CString sztypeid,
              WORD nameid, CString sznameid,
              DWORD dwlang, DWORD dwsize, DWORD dwfileoffset );

    void GenerateIdTable( LPCSTR lpszType, BOOL bNameOrID );

    UINT WriteUpdatedResource( LPCSTR lpszTgtfilename, HANDLE hFileModule, LPCSTR lpszSymbolPath );


    void SetResBufSize( UINT uiSize )   { m_ResBufSize = uiSize;}
    UINT GetResBufSize()                { return m_ResBufSize;}
    UINT Copy( CFileModule* pFileModule );
    UINT CopyImage( CFileModule* pFileModule, LPCSTR lpszType, LPCSTR lpszResId );

    UINT GetLanguageStr( LPSTR lpszLanguage );

private:
    CString     m_SrcFileName;      // The filename of the file to process
    CString     m_RdfFileName;      // The filename of the RDF file
    UINT        m_DllTypeEntry;     // The CDLLTable position for the file type
    HINSTANCE   m_DllHInstance;     // The HINSTANCE to the dll
    DWORD       m_dwFlags;          // IODLL and RW flags

    CObArray    m_ResArray;         // Array of all the Resources in the file.
    UINT        m_ResBufSize;       // Will be usefull when we have to write the resource

    int         m_TypePos;          // Position in the ResArray for the last enum type
    CWordArray  m_TypeArray;        // Array of resource types in the file

    int         m_IdPos;
    CWordArray  m_IdArray;          // Array of resource id of a types in the file

    int         m_LangPos;
    CWordArray  m_LangArray;        // Array of Language if of a given type/id

    char m_IdStr[100];              // Resource name
    char m_TypeStr[100];            // Type name
	char m_LastTypeName[100];
	LPSTR m_LastTypeID;
};

// This class will old the information on each entry in the INI file related with the
// R/W modules. When the DLL will be discarded the memory will be cleaned.
class CDllEntryTable : public CObject
{
public:
    CDllEntryTable( CString szEntry );
	~CDllEntryTable();

    CString GetType( ) { return m_szDllType; }
    CString GetName( ) { return m_szDllName; }
	HINSTANCE  LoadEntry( );
	BOOL	FreeEntry( );
private:
    CString     m_szDllName;        // Dll Name and directory
    CString     m_szDllType;        // Dll type tag
	HINSTANCE 	m_handle;
};

// This class is a dinamyc array of CDllEntryTable elements.
// When the DLL is initialized the class read the INI file and is ready with the information
// on each of the RW Modules present on the hard disk. When the DLL il discarded the Class
// will take care to delete all the entry allocated.
class CDllTable : public CObArray
{
public:
    CDllTable( UINT );
    ~CDllTable();

    UINT GetPosFromTable( CString szFileType );
    UINT GetMaxEntry() { return m_MaxEntry; }

private:
    UINT m_MaxEntry;
    UINT m_InitNum;
};

class CModuleTable : public CObArray
{
public:
    CModuleTable( UINT );
    ~CModuleTable();

private:
    UINT m_LastHandle;
    UINT m_InitNum;
};

/////////////////////////////////////////////////////////////////////////////
// Global variables
CDllTable gDllTable(MAXENTRYBUF);       // When the DLL is initialized the constructor is called
CModuleTable gModuleTable(2);           // When the DLL is initialized the constructor is called

TCHAR szDefaultRcdata[][MAXKEYLEN] = { "kernel32.dll,rcdata1.dll" };
TCHAR szDefaultRWDll[][MAXKEYLEN] = {"rwwin16.dll,WIN16",
                                     "rwwin32.dll,WIN32",
                                     "rwmac.dll,MAC",
                                     "rwres32.dll,RES32",
                                     "rwinf.dll,INF"};

static BYTE sizeofWord = sizeof(WORD);
static BYTE sizeofDWord = sizeof(DWORD);
static BYTE sizeofDWordPtr = sizeof(DWORD_PTR);
static BYTE sizeofByte = sizeof(BYTE);

/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

static UINT CopyFile( const char * pszfilein, const char * pszfileout );
static BYTE Allign(LONG bLen);
void CheckError(LPCSTR szStr);

int			g_iDllLoaded;
SETTINGS	g_Settings;

////////////////////////////////////////////////////////////////////////////
// RDF File support code

HANDLE
OpenModule(
	LPCSTR   lpszSrcfilename,       // File name of the executable to use as source file
	LPCSTR   lpszfiletype,			// Type of the executable file if known
	LPCSTR   lpszRDFfile,
	DWORD    dwFlags );


//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Global Settings API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSSetGlobals(
	SETTINGS	Settings)         // Set the global variable, like CP to use.
{
	g_Settings.cp = Settings.cp;
    g_Settings.bAppend = Settings.bAppend;
    g_Settings.bUpdOtherResLang = Settings.bUpdOtherResLang;
    strncpy(g_Settings.szDefChar, Settings.szDefChar, 1);
    g_Settings.szDefChar[1] = '\0';

	return 1;
}

extern "C"
DllExport
UINT
APIENTRY
RSGetGlobals(
	LPSETTINGS	lpSettings)         // Retrieve the global variable
{
	lpSettings->cp = g_Settings.cp;
    lpSettings->bAppend = g_Settings.bAppend;
    lpSettings->bUpdOtherResLang = g_Settings.bUpdOtherResLang;
    strncpy(lpSettings->szDefChar, g_Settings.szDefChar, 1);
    lpSettings->szDefChar[1] = '\0';



	return 1;
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Module Opening/Closing API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
HANDLE
APIENTRY
RSOpenModule(
    LPCSTR   lpszSrcfilename,    // File name of the executable to use as source file
    LPCSTR   lpszfiletype )      // Type of the executable file if known
{
    return OpenModule(lpszSrcfilename, lpszfiletype, NULL, 0 );
}

extern "C"
DllExport
HANDLE
APIENTRY
RSOpenModuleEx(
	LPCSTR   lpszSrcfilename,       // File name of the executable to use as source file
	LPCSTR   lpszfiletype,			// Type of the executable file if known
	LPCSTR   lpszRDFfile,           // Resource Description File (RDF)
    DWORD    dwFlags )              // HIWORD=rw flags LOWORD=iodll flags
{
	// Check if we have a RDF file defined
	if(lpszRDFfile) {
		return OpenModule(lpszSrcfilename, lpszfiletype, lpszRDFfile, dwFlags );
	}
	else
		return OpenModule(lpszSrcfilename, lpszfiletype, NULL, dwFlags );
}

extern "C"
DllExport
HANDLE
APIENTRY
RSCopyModule(
    HANDLE  hSrcfilemodule,         // Handle to the source file
    LPCSTR   lpszModuleName,            // Name of the new module filename
    LPCSTR  lpszfiletype )          // Type of the target module
{
    TRACE2("IODLL.DLL: RSCopyModule: %d %s\n", (int)hSrcfilemodule, lpszfiletype);
    UINT uiError = ERROR_NO_ERROR;
    INT_PTR uiHandle = 0 ;

    // Check if the type is not null
    CString szSrcFileType;
    if (!lpszfiletype) {
        return UlongToHandle(ERROR_IO_TYPE_NOT_SUPPORTED);
    } else szSrcFileType = lpszfiletype;

    gModuleTable.Add(new CFileModule( (LPSTR)lpszModuleName,
                                      NULL,
                                      gDllTable.GetPosFromTable(szSrcFileType),
                                      0 ));

    // Get the position in the array.
    uiHandle = gModuleTable.GetSize();

    // Read the informations on the type in the file.
    CFileModule* pFileModule = (CFileModule*)gModuleTable.GetAt(uiHandle-1);

    if (!pFileModule)
        return UlongToHandle(ERROR_IO_INVALIDMODULE);

    // We have to copy the information from the source module
    INT_PTR uiSrcHandle = (UINT_PTR)hSrcfilemodule-FIRSTVALIDVALUE-1;
    if (uiSrcHandle<0)
        return (HANDLE)(ERROR_HANDLE_INVALID);
    CFileModule* pSrcFileModule = (CFileModule*)gModuleTable.GetAt((UINT)uiSrcHandle);
    if (!pSrcFileModule)
        return (HANDLE)(ERROR_IO_INVALIDMODULE);

    if (pSrcFileModule->Copy( pFileModule ))
        return (HANDLE)(ERROR_IO_INVALIDITEM);

    pFileModule->SetResBufSize( pSrcFileModule->GetResBufSize() );

    return (HANDLE)(uiHandle+FIRSTVALIDVALUE);
}


extern "C"
DllExport
UINT
APIENTRY
RSCloseModule(
    HANDLE  hResFileModule )    // Handle to the session opened before
{
    TRACE1("IODLL.DLL: RSCloseModule: %d\n", (int)hResFileModule);
    UINT uiError = ERROR_NO_ERROR;

    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0)
        return ERROR_HANDLE_INVALID;

    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    uiError = pFileModule->CleanUp();

    return uiError;
}

extern "C"
DllExport
HANDLE
APIENTRY
RSHandleFromName(
	LPCSTR   lpszfilename )        // Handle to the session with the file name specified
{
    TRACE("IODLL.DLL: RSHandleFromName: %s\n", lpszfilename);

    INT_PTR UpperBound = gModuleTable.GetUpperBound();
    CFileModule* pFileModule;
    while( UpperBound!=-1 ) {
        pFileModule = (CFileModule*)gModuleTable.GetAt(UpperBound);
        if(pFileModule->GetName()==lpszfilename)
            return (HANDLE)(UpperBound+FIRSTVALIDVALUE+1);
        UpperBound--;
    }

    return (HANDLE)0;
}


//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Enumeration API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
LPCSTR
APIENTRY
RSEnumResType(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszPrevResType)    // Previously enumerated type
{
    TRACE2("IODLL.DLL: RSEnumResType: %u %Fp\n", (UINT)hResFileModule,
                                                 lpszPrevResType);

    // By now all the information on the types should be here.
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0)
        return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return LPNULL;

    return pFileModule->EnumType( lpszPrevResType );
}

extern "C"
DllExport
LPCSTR
APIENTRY
RSEnumResId(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszPrevResId)      // Previously enumerated id
{
    TRACE3("IODLL.DLL: RSEnumResId: %u %Fp %Fp\n", (UINT)hResFileModule,
                                                   lpszResType,
                                                   lpszPrevResId);
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    return pFileModule->EnumId( lpszResType, lpszPrevResId );
}

extern "C"
DllExport
DWORD
APIENTRY
RSEnumResLang(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwPrevResLang)      // Previously enumerated language
{
    TRACE3("IODLL.DLL: RSEnumResLang: %u %Fp %Fp ", (UINT)hResFileModule,
                                                    lpszResType,
                                                    lpszResId);
    TRACE1("%ld\n", dwPrevResLang);
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->EnumLang( lpszResType, lpszResId, dwPrevResLang );
}

extern "C"
DllExport
DWORD
APIENTRY
RSEnumResItemId(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    DWORD   dwPrevResItemId)    // Previously enumerated item id
{
    TRACE3("IODLL.DLL: RSEnumResItemId: %u %Fp %Fp ", (UINT)hResFileModule,
                                                      lpszResType,
                                                      lpszResId);
    TRACE2("%ld %Fp\n", dwResLang,
                      dwPrevResItemId);

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->EnumItem( lpszResType, lpszResId, dwResLang, dwPrevResItemId );
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Data acquisition API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSGetResItemData(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    DWORD   dwResItemId,        // Previously enumerated item id
    LPVOID  lpbuffer,           // Pointer to the buffer that will get the resource info
    UINT    uiBufSize)          // Size of the buffer that will hold the resource info
{
    TRACE3("IODLL.DLL: RSGetResItemData: %u %Fp %Fp ", (UINT)hResFileModule,
                                                       lpszResType,
                                                       lpszResId);
    TRACE3("%ld %Fp %Fp ", dwResLang,
                           dwResItemId,
                           lpbuffer);
    TRACE1("%d\n", uiBufSize);
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->GetData( lpszResType, lpszResId, dwResLang, dwResItemId,
                                 lpbuffer, uiBufSize );
}

extern "C"
DllExport
DWORD
APIENTRY
RSGetResImage(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    LPVOID  lpbuffer,           // Pointer to the buffer to get the resource Data
    DWORD   dwBufSize)          // Size of the allocated buffer
{
    TRACE3("IODLL.DLL: RSGetResImage: %u %Fp %Fp ", (UINT)hResFileModule,
                                                    lpszResType,
                                                    lpszResId);
    TRACE2("%ld %Fp ", dwResLang,
                       lpbuffer);
    TRACE1("%lu\n", dwBufSize);

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->GetImage( lpszResType, lpszResId, dwResLang, lpbuffer, dwBufSize );
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Update API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSUpdateResItemData(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    DWORD   dwResItemId,        // Previously enumerated items id
    LPVOID  lpbuffer,           // Pointer to the buffer to the resource item Data
    UINT    uiBufSize)          // Size of the buffer
{
    TRACE3("IODLL.DLL: RSUpdateResItemData: %u %Fp %Fp ", (UINT)hResFileModule,
                                                          lpszResType,
                                                          lpszResId);
    TRACE3("%ld %Fp %Fp ", dwResLang,
                           dwResItemId,
                           lpbuffer);
    TRACE1("%u\n", uiBufSize);
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->UpdateData( lpszResType, lpszResId, dwResLang, dwResItemId,
                                    lpbuffer, uiBufSize );
}

extern "C"
DllExport
DWORD
APIENTRY
RSUpdateResImage(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    DWORD   dwUpdLang,          // Desired output language
    LPVOID  lpbuffer,           // Pointer to the buffer to the resource item Data
    DWORD   dwBufSize)          // Size of the buffer
{
    TRACE3("IODLL.DLL: RSUpdateResImage: %d %Fp %Fp ", hResFileModule,
                                                       lpszResType,
                                                       lpszResId);
    TRACE("%Fp %Fp %Fp ", dwResLang,
                           lpbuffer);
    TRACE1("%d\n", dwBufSize);
    UINT uiError = ERROR_NO_ERROR;

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->UpdateImage( lpszResType, lpszResId, dwResLang,
                                     dwUpdLang, lpbuffer, dwBufSize );

    return (DWORD)uiError;
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Conversion API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSUpdateFromResFile(
    HANDLE  hResFileModule,     // Handle to the file session
    LPSTR   lpszResFilename)    // The resource filename to be converted
{
    TRACE2("IODLL.DLL: RSUpdateFromResFile: %d %s\n", hResFileModule,
                                                       lpszResFilename);
    UINT uiError = 0;
    const int       CBSTRMAX        = 8192;
    BOOL            fReturn         = TRUE;
    HANDLE          hResFileSrc     = NULL;
    LPCSTR          lpszTypeSrc     = NULL;
    LPCSTR          lpszResSrc      = NULL;
    DWORD           dwLangSrc       = 0L;
    DWORD           dwLangDest      = 0L;
    DWORD           dwItemSrc       = 0L;
    DWORD           dwItemDest      = 0L;
    WORD            cbResItemSrc    = 0;
    WORD            cbResItemDest   = 0;
    LPRESITEM       lpriSrc         = NULL;
    LPRESITEM       lpriDest        = NULL;

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return ERROR_HANDLE_INVALID;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];
    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;


    // Initialize storage for ResItem
    if (lpriSrc = (LPRESITEM)malloc(CBSTRMAX))
        cbResItemSrc = CBSTRMAX;
    else {
        AfxThrowMemoryException();
    }

    // Read in the resource files
    if ((UINT_PTR)(hResFileSrc = RSOpenModule((LPSTR)lpszResFilename, "RES32")) <= 100) {
        uiError = (UINT)(UINT_PTR)hResFileSrc;
        if (lpriSrc)
            free(lpriSrc);
        return uiError;
    }

    // Get the File Module of the Resource file. This is needed for the image conversion

    CFileModule* pResFileModule = (CFileModule*)gModuleTable[(UINT)((UINT_PTR)hResFileSrc-FIRSTVALIDVALUE-1)];
    if(!pResFileModule)
    	return ERROR_IO_INVALIDMODULE;

    while (lpszTypeSrc = RSEnumResType(hResFileSrc,
                                        lpszTypeSrc)) {
        while (lpszResSrc = RSEnumResId(hResFileSrc,
                                         lpszTypeSrc,
                                         lpszResSrc)) {
			// Hack Hack, This is done to handle Bitmap conversion
            // Will need to be done better after the Chicago release
            switch(LOWORD(lpszTypeSrc)) {
            	case 2:
            		TRACE("Here we will have to swap the images!\n");
            		pFileModule->CopyImage( pResFileModule, lpszTypeSrc, lpszResSrc );
            	break;
            	default:
            	break;
            }
            while (dwLangSrc = RSEnumResLang(hResFileSrc,
                                              lpszTypeSrc,
                                              lpszResSrc,
                                              dwLangSrc)) {
                while (dwItemSrc = RSEnumResItemId(hResFileSrc,
                                                    lpszTypeSrc,
                                                    lpszResSrc,
                                                    dwLangSrc,
                                                    dwItemSrc)){

                    WORD wSize;
                    wSize = (WORD)RSGetResItemData(hResFileSrc,
                                             lpszTypeSrc,
                                             lpszResSrc,
                                             dwLangSrc,
                                             dwItemSrc,
                                             (LPRESITEM)lpriSrc,
                                             cbResItemSrc);

                    if (cbResItemSrc < wSize) {
                        if (lpriSrc = (LPRESITEM)realloc(lpriSrc, wSize))
                            cbResItemSrc = wSize;
                        else
                            AfxThrowMemoryException();
                        RSGetResItemData(hResFileSrc,
                                         lpszTypeSrc,
                                         lpszResSrc,
                                         dwLangSrc,
                                         dwItemSrc,
                                         (LPRESITEM)lpriSrc,
                                         cbResItemSrc);
                    }

                    if ((uiError = RSUpdateResItemData(hResFileModule,
                                                   lpszTypeSrc,
                                                   lpszResSrc,
                                                   1033,
                                                   dwItemSrc,
                                                   lpriSrc,
                                                   cbResItemSrc)) != 0) {
                        /*
                        if (lpriSrc)
                            free(lpriSrc);
                        RSCloseModule(hResFileSrc);
                        return uiError;
                        */
                    }
                }
            }
        }
    }


    // Save out to the updated resource file, same format.
    RSCloseModule(hResFileSrc);

    // The user want to write the file with the same format as the original
    uiError = pFileModule->WriteUpdatedResource( pFileModule->GetName(), hResFileModule, NULL);

    // Clean up
    return uiError;
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Writing API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSWriteResFile(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszTgtfilename,    // The new filename to be generated
    LPCSTR  lpszTgtfileType,    // Target Resource type 16/32
    LPCSTR  lpszSymbolPath)     // Symbol Path for updating symbol checksum
{
    TRACE3("IODLL.DLL: RSWriteResFile: %d %s %s\n", hResFileModule,
                                                      lpszTgtfilename,
                                                      lpszTgtfileType);
    UINT uiError = ERROR_NO_ERROR;

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return ERROR_HANDLE_INVALID;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;


    if(lpszTgtfileType!=LPNULL) {
        // The user want a conversion.
        // Check if the type the user want is one of the supported one
        CDllEntryTable* pDllEntry;
        INT_PTR iUpperBound = gDllTable.GetUpperBound();
        while(iUpperBound>=0) {
            pDllEntry = (CDllEntryTable*) gDllTable.GetAt(iUpperBound);
            if ( (pDllEntry) && (pDllEntry->GetType()==lpszTgtfileType) )
                    iUpperBound = -1;
            iUpperBound--;
        }
        if (iUpperBound==-1)
            return ERROR_IO_TYPE_NOT_SUPPORTED;

        // We will open a new module now.
        // We will generate the images from the other module
        HANDLE hTgtFileHandle = RSCopyModule( hResFileModule, LPNULL, lpszTgtfileType );
        if ((UINT_PTR)hTgtFileHandle<=FIRSTVALIDVALUE)
            return ((UINT)(UINT_PTR)hTgtFileHandle);

        // Write the file
        CFileModule* pNewFileModule = (CFileModule*)gModuleTable[(UINT)((UINT_PTR)hTgtFileHandle-FIRSTVALIDVALUE-1)];
        if (!pNewFileModule)
            return ERROR_IO_INVALIDMODULE;

        uiError = pNewFileModule->WriteUpdatedResource( lpszTgtfilename, hTgtFileHandle, lpszSymbolPath );

        // Close the module we just create
        RSCloseModule(hTgtFileHandle);
        return uiError;
    }

    // The user want to write the file with the same format as the original
    return pFileModule->WriteUpdatedResource( lpszTgtfilename,
                                              hResFileModule,
                                              lpszSymbolPath);
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Recognition API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSFileType(
    LPCSTR   lpszfilename,   // File name of the executable to use as source file
    LPSTR   lpszfiletype )  // Type of the executable file if known
{
    //Get the executable file format querying all the R/W DLL
    INT_PTR UpperBound = gDllTable.GetUpperBound();
    int c = 0;
    CDllEntryTable* pDllEntry;
    while(c<=UpperBound) {
        // Get the module name
        pDllEntry = (CDllEntryTable*) gDllTable.GetAt(c);

        if (!pDllEntry)
            return ERROR_IO_INVALID_DLL;
        // Get the handle to the dll and query validate
        HINSTANCE hInst = pDllEntry->LoadEntry();

        if (hInst) {
            BOOL (FAR PASCAL * lpfnValidateFile)(LPCSTR);
            // Get the pointer to the function to extract the resources
            lpfnValidateFile = (BOOL (FAR PASCAL *)(LPCSTR))
                                GetProcAddress( hInst, "RWValidateFileType" );
            if (lpfnValidateFile==NULL) {
                return ERROR_DLL_PROC_ADDRESS;
            }
            if( (*lpfnValidateFile)((LPCSTR)lpszfilename) ) {
                // this DLL can handle the file type
                strcpy(lpszfiletype, pDllEntry->GetType());
                return ERROR_NO_ERROR;
            }
        }
		else {
            CheckError("(RSFileType) LoadLibrary()" + pDllEntry->GetName());
		}

        c++;
    }
    strcpy(lpszfiletype, "");
    return ERROR_IO_TYPE_NOT_SUPPORTED;
}


////////////////////////////////////////////////////////////////////////////
// Return TRUE if the file has more than one language.
// Will fill the lpszLanguage with a list of the languages in the file
////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport
UINT
APIENTRY
RSLanguages(
	HANDLE  hfilemodule,      // Handle to the file
	LPSTR   lpszLanguages )   // will be filled with a string of all the languages in the file
 {
    INT_PTR uiHandle = (UINT_PTR)hfilemodule-FIRSTVALIDVALUE-1;
    if (uiHandle<0)
        return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return LPNULL;

    return pFileModule->GetLanguageStr(lpszLanguages);
}


////////////////////////////////////////////////////////////////////////////
// Class implementation
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// CFileModule

CFileModule::CFileModule()
{
    //TRACE("IODLL.DLL: CFileModule::CFileModule\n");

    m_SrcFileName = "";
    m_RdfFileName = "";
    m_DllTypeEntry = 0; // Invalid position
    m_DllHInstance = 0; // Not loaded yet
    m_TypePos = 0;
    m_IdPos = 0;
    m_LangPos = 0;
    m_LastTypeName[0] = '\0';
	m_LastTypeID = LPNULL;
    m_IdStr[0] = '\0';
    m_dwFlags = 0;

	m_ResArray.SetSize(100,10);
	m_TypeArray.SetSize(100,10);
	m_IdArray.SetSize(100,10);
    m_LangArray.SetSize(100,10);
}

CFileModule::CFileModule( LPCSTR lpszSrcfilename,
                          LPCSTR lpszRdffilename,
                          int DllTblPos,
                          DWORD dwFlags)
{
    //TRACE2("IODLL.DLL: CFileModule::CFileModule %s %d\n", lpszSrcfilename,
    //                                                    DllTblPos );


    m_SrcFileName = lpszSrcfilename;
    if(!lpszRdffilename)
    {
        CString strMap;

        // assign a default name
        m_RdfFileName = lpszSrcfilename;

        // remove the the path...
        int iPos = m_RdfFileName.ReverseFind('\\');
        if(iPos!=-1)
            m_RdfFileName = m_RdfFileName.Mid(iPos+1);

        // Get name from INI file
        GetProfileString("IODLL-RCDATA", m_RdfFileName, "", strMap.GetBuffer(MAX_PATH), MAX_PATH);
        strMap.ReleaseBuffer();

        if(strMap.IsEmpty())
        {
            //
            //  Not found in win.ini, we use default.
            //
            int c = 0;
            int iMax = sizeof(szDefaultRcdata)/sizeof(TCHAR)/MAXKEYLEN;
            PCHAR pstr;
            CString Entry;

            for ( pstr = szDefaultRcdata[0]; c< iMax; pstr += MAXKEYLEN, c++)
            {
                Entry = pstr;
                if(Entry.Find (m_RdfFileName) !=-1)
                {
                    strMap = Entry.Mid(lstrlen(m_RdfFileName)+1);
                    break;
                }
            }
        }

        if (!strMap.IsEmpty())
        {
            m_RdfFileName = strMap;
            // we will use the dll in the directory from were we have been spawned
            GetModuleFileName( NULL, strMap.GetBuffer(MAX_PATH), MAX_PATH );
            strMap.ReleaseBuffer(-1);

            // remove the file name
            iPos = strMap.ReverseFind('\\');
            if(iPos!=-1)
                strMap = strMap.Left(iPos+1);

            // append the path to the file name
            m_RdfFileName = strMap + m_RdfFileName;
        }
        else
        {
            m_RdfFileName = "";
        }
    }
    else m_RdfFileName = lpszRdffilename;

    m_SrcFileName.MakeUpper();
    m_DllTypeEntry = DllTblPos;
    m_DllHInstance = 0; // Not loaded yet

    m_TypePos = 0;
    m_IdPos = 0;
    m_LangPos = 0;
    m_LastTypeName[0] = '\0';
	m_LastTypeID = LPNULL;
    m_IdStr[0] = '\0';
    m_dwFlags = dwFlags;
}

CFileModule::~CFileModule()
{
    TRACE("IODLL.DLL: CFileModule::~CFileModule\n");
    CleanUp();
}

HINSTANCE CFileModule::LoadDll()
{
    if (!(m_DllHInstance) && (m_DllTypeEntry))
        if((m_DllHInstance = ((CDllEntryTable*)gDllTable[m_DllTypeEntry-1])->LoadEntry())==NULL) {
            CheckError("(CFileModule::LoadDll) LoadLibrary() for " + ((CDllEntryTable*)gDllTable[m_DllTypeEntry-1])->GetName() );
        } else
            TRACE("CFileModule::LoadDll call %d --->> %08x\n", g_iDllLoaded++, m_DllHInstance);
    return m_DllHInstance;
}

void
CFileModule::FreeDll()
{
    TRACE("IODLL.DLL: CFileModule::FreeDll() m_DllHInstance=%08x\n", m_DllHInstance );

    if (m_DllHInstance)
    	m_DllHInstance = 0;
}

UINT
CFileModule::CleanUp()
{
    INT_PTR UpperBound = m_ResArray.GetUpperBound();
    TRACE1("IODLL.DLL: CFileModule::CleanUp %d\n", UpperBound);

    // Free the memory for the resource information
    CResInfo* pResInfo;
    for(INT_PTR c=0; c<=UpperBound; c++) {
        pResInfo = (CResInfo*)m_ResArray.GetAt(c);
        TRACE("\tCFileModule\t%d\tCResInfo->%Fp\n", c, pResInfo);
        delete pResInfo;
    }
    m_ResArray.RemoveAll();

    // Unload the DLL
	FreeDll();

    return 0;
}

int
CFileModule::AddResInfo(
              WORD Typeid, CString sztypeid,
              WORD nameid, CString sznameid,
              DWORD dwlang, DWORD dwsize, DWORD dwfileoffset )
{
    return (int)m_ResArray.Add( new CResInfo(
        Typeid,
        sztypeid,
        nameid,
        sznameid,
        dwlang,
        dwsize,
        dwfileoffset,
        this
        ));
}

int
CFileModule::AddTypeInfo( INT_PTR iPos, int iId, CString szId )
{
    //TRACE3("IODLL.DLL: CFileModule::AddTypeInfo %d %d %Fp\n", iPos, iId, szId);
    INT_PTR  UpperBound = m_TypeArray.GetUpperBound();

    for( INT_PTR c = 0; c<=UpperBound; c++) {
        int pos = m_TypeArray.GetAt(c);
        CResInfo* pResPos = (CResInfo*)m_ResArray.GetAt(pos);
        CResInfo* pResLast = (CResInfo*)m_ResArray.GetAt(iPos);

        if( ((pResPos->GetTypeId()==pResLast->GetTypeId()) &&
             (pResPos->GetTypeName()==pResLast->GetTypeName())
            )) return 0;
    }
    //TRACE3("IODLL.DLL: CFileModule::AddTypeInfo %d %d %Fp\n", iPos, iId, szId);
    m_TypeArray.Add( (WORD)iPos );
    return 1;
}

UINT
CFileModule::GetLanguageStr( LPSTR lpszLanguage )
{
    CResInfo* pResInfo;
    CString strLang = "";
    char szLang[8];
    BOOL multi_lang = FALSE;

    for(INT_PTR c=0, iUpperBound = m_ResArray.GetUpperBound(); c<=iUpperBound; c++) {
        pResInfo = (CResInfo*)m_ResArray.GetAt(c);

        // Convert the language in to the hex value
        sprintf(szLang,"0x%3.3X", pResInfo->GetLanguage());

        // check if the language is already in the string
        if(strLang.Find(szLang)==-1)
        {
            if(!strLang.IsEmpty())
            {
                multi_lang = TRUE;
                strLang += ", ";
            }

            strLang += szLang;
        }
    }

    strcpy( lpszLanguage, strLang );

    return multi_lang;
}

CResInfo*
CFileModule::GetResInfo( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang )
{
    BOOL fIdName = HIWORD(lpszId);
    BOOL fTypeName = HIWORD(lpszType);
    CResInfo*   pResInfo;

    // We must have at least the type to procede
    if(!lpszType)
        return LPNULL;

    for( INT_PTR i = 0, iUpperBoundRes = m_ResArray.GetUpperBound() ; i<=iUpperBoundRes ; i++)
    {
        pResInfo = (CResInfo*)m_ResArray.GetAt(i);
        if(pResInfo)
        {
            if( fTypeName ? !strcmp(pResInfo->GetTypeName(), lpszType) : pResInfo->GetTypeId()==LOWORD(lpszType))
            {
                // do we need the ID and language or can we exit
                if(!lpszId)
                    return pResInfo;

                if( fIdName ? !strcmp(pResInfo->GetResName(), lpszId) : pResInfo->GetResId()==LOWORD(lpszId))
                {
                    // are we done or we want the language as well
                    if((LONG)dwLang==-1)
                        return pResInfo;

                    if( dwLang==pResInfo->GetLanguage() )
                        return pResInfo;
                }
            }
        }
    }

    return LPNULL;
}

DWORD
CFileModule::GetImage(  LPCSTR lpszType,
                        LPCSTR lpszId,
                        DWORD dwLang,
                        LPVOID lpbuffer,
                        DWORD dwBufSize )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;
    //if (!dwLang) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (!LoadDll()) return 0L;

    if (pResInfo)
        return pResInfo->GetImage( m_SrcFileName, m_DllHInstance, lpbuffer, dwBufSize );

    return 0L;
}

DWORD
CFileModule::UpdateImage(  LPCSTR lpszType,
                        LPCSTR lpszId,
                        DWORD dwLang,
                        DWORD dwUpdLang,
                        LPVOID lpbuffer,
                        DWORD dwBufSize )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (!LoadDll()) return 0L;
    if (pResInfo)
        return pResInfo->ReplaceImage(lpbuffer, dwBufSize, dwUpdLang );

    return 0L;
}


UINT
CFileModule::GetData( LPCSTR lpszType,
                      LPCSTR lpszId,
                      DWORD dwLang,
                      DWORD dwItem,
                      LPVOID lpbuffer,
                      UINT uiBufSize )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;
    //if (!dwLang) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (LoadDll()==NULL) return 0L;

    UINT uiSize = 0;
    if (pResInfo)
        uiSize = pResInfo->GetData( m_SrcFileName, m_DllHInstance,
                                    dwItem, lpbuffer, uiBufSize );

    return uiSize;
}

UINT
CFileModule::UpdateData(  LPCSTR lpszType,
                          LPCSTR lpszId,
                          DWORD dwLang,
                          DWORD dwItem,
                          LPVOID lpbuffer,
                          UINT uiBufSize )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;
    //if (!dwLang) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (LoadDll()==NULL) return 0L;

    UINT uiError = ERROR_NO_ERROR;
    if (pResInfo)
        uiError = pResInfo->UpdateData( m_SrcFileName, m_DllHInstance,
                                        dwItem, lpbuffer, uiBufSize );

    return uiError;
}

void
CFileModule::GenerateIdTable( LPCSTR lpszType, BOOL bNameOrId )
{
    m_IdArray.RemoveAll();

    CResInfo* pResInfo;
	for( WORD c=0, UpperBound= (WORD)m_ResArray.GetUpperBound(); c<=UpperBound; c++) {
        pResInfo = (CResInfo*)m_ResArray.GetAt(c);

		if(bNameOrId) {
	        if (pResInfo->GetTypeId() && pResInfo->GetTypeName()=="") {
	            if (pResInfo->GetTypeId()==(WORD)LOWORD((DWORD)(DWORD_PTR)lpszType)) {
	                //TRACE2("IODLL.DLL: CFileModule::EnumId %d %d\n", c,
	                //  (WORD)LOWORD((DWORD)lpszType) );
	                m_IdArray.Add( c );
	            }
				m_LastTypeID = (LPSTR)lpszType;
				m_LastTypeName[0] = '\0';
	        } else {
				if (HIWORD((DWORD)(DWORD_PTR)lpszType)!=0) {
	                if (pResInfo->GetTypeName()==(CString)(lpszType))
	                    m_IdArray.Add( c );
					strcpy(m_LastTypeName, lpszType);
					m_LastTypeID = LPNULL;
				}
	        }
		}
		else {
			if (pResInfo->GetTypeId()) {
	            if (pResInfo->GetTypeId()==(WORD)LOWORD((DWORD)(DWORD_PTR)lpszType)) {
	                //TRACE2("IODLL.DLL: CFileModule::EnumId %d %d\n", c,
	                //  (WORD)LOWORD((DWORD)lpszType) );
	                m_IdArray.Add( c );
	            }
				m_LastTypeID = (LPSTR)lpszType;
				m_LastTypeName[0] = '\0';
	        } else {
				if (HIWORD((DWORD)(DWORD_PTR)lpszType)!=0) {
	                if (pResInfo->GetTypeName()==(CString)(lpszType))
	                    m_IdArray.Add( c );
					strcpy(m_LastTypeName, lpszType);
					m_LastTypeID = LPNULL;
				}
	        }
		}
    }
}

UINT
CFileModule::WriteUpdatedResource( LPCSTR lpszTgtfilename, HANDLE hFileModule, LPCSTR szSymbolPath)
{
    UINT uiError = ERROR_NO_ERROR;
    // We have to check which resource have been updated and
    // generate a list to give back to the RW module
    CResInfo* pResInfo;
    TRACE1("CFileModule::WriteUpdatedResource\tNewSize: %ld\n", (LONG)m_ResBufSize);
    BYTE * pBuf = new BYTE[m_ResBufSize];
    BYTE * pBufStart = pBuf;
    BYTE * pBufPos = pBuf;
    BYTE bPad = 0;
    BOOL bIsTmp = FALSE;
    if (!pBuf)
        return ERROR_NEW_FAILED;
    if (!m_DllHInstance)
        if (LoadDll()==NULL) return 0L;

    UINT uiBufSize = 0;

	// MAC RW fixes. Since the MAC RW will update images while updating images
	// The list of updated images could potentialy be wrong. We first scan the list for
	// Updated resources and then we will do the same thing to write the list in the buffer.
	// So for instance updating the DLG image will update a DITL connected with
	// the DLG itself. If the DITL was already gone in the for loop we would
	// skip it and never save the DITL image that is now updated.
	for( INT_PTR c=0, UpperBound = m_ResArray.GetUpperBound(); c<=UpperBound ; c++) {
        pResInfo = (CResInfo*) m_ResArray.GetAt(c);
        if(!pResInfo)
            return ERROR_IO_RESINFO_NULL;

        if(!pResInfo->GetFileOffset()) {
            // The offset is null. This mean that the resource has been updated.
            // Check if the image is up to date or not
            if (!pResInfo->GetUpdImage()) {
                DWORD dwSize = pResInfo->UpdateImage( 0,
                                                      m_DllHInstance,
                                                      (LPCSTR)UlongToPtr(pResInfo->GetTypeId()) );
                if (dwSize)
                    if(pResInfo->UpdateImage( dwSize,
                                              m_DllHInstance,
                                              (LPCSTR)UlongToPtr(pResInfo->GetTypeId()))) {
                        delete []pBufStart;
                        return ERROR_IO_UPDATEIMAGE;
                    }
            }
        }
    }

	// Now add the image to the list...
	for( c=0, UpperBound = m_ResArray.GetUpperBound(); c<=UpperBound ; c++) {
        pResInfo = (CResInfo*) m_ResArray.GetAt(c);
        if(!pResInfo)
            return ERROR_IO_RESINFO_NULL;

        if(!pResInfo->GetFileOffset()) {
            // Write the information in the bufer and give it back to the RW module
            pBufPos = pBuf;
            *((WORD*)pBuf) = pResInfo->GetTypeId();
            pBuf += sizeofWord;

            strcpy((char*)pBuf, pResInfo->GetTypeName());
            pBuf += (pResInfo->GetTypeName()).GetLength()+1;

            // Check the allignment
            bPad = Pad4((BYTE)(pBuf-pBufPos));
            while (bPad) {
               *pBuf = 0x00;
               pBuf += 1;
               bPad--;
            }

            *((WORD*)pBuf) = pResInfo->GetResId();
            pBuf += sizeofWord;

            strcpy((char*)pBuf, pResInfo->GetResName());
            pBuf += (pResInfo->GetResName()).GetLength()+1;

            // Check the allignment
            bPad = Pad4((BYTE)(pBuf-pBufPos));
            while (bPad) {
               *pBuf = 0x00;
               pBuf += 1;
               bPad--;
            }

            *((DWORD*)pBuf) = pResInfo->GetAllLanguage();
            pBuf += sizeofDWord;

            *((DWORD*)pBuf) = pResInfo->GetSize();
            pBuf += sizeofDWord;

            uiBufSize += (UINT)(pBuf-pBufPos);

            TRACE1("TypeId: %d\t", pResInfo->GetTypeId());
            TRACE1("TypeName: %s\t", pResInfo->GetTypeName());
            TRACE1("NameId: %d\t", pResInfo->GetResId());
            TRACE1("NameName: %s\t", pResInfo->GetResName());
            TRACE1("ResLang: %lu\t", pResInfo->GetLanguage());
            TRACE1("ResSize: %lu\n", pResInfo->GetSize());

            //TRACE1("uiError: %u\n", uiSize);
        }
    }

    UINT (FAR PASCAL * lpfnWriteFile)(LPCSTR, LPCSTR, HANDLE, LPVOID, UINT, HINSTANCE, LPCSTR);
    // Get the pointer to the function to extract the resources
    lpfnWriteFile = (UINT (FAR PASCAL *)(LPCSTR, LPCSTR, HANDLE, LPVOID, UINT, HINSTANCE, LPCSTR))
                        GetProcAddress( m_DllHInstance, "RWWriteFile" );
    if (lpfnWriteFile==NULL) {
        delete []pBufStart;
        return (DWORD)ERROR_DLL_PROC_ADDRESS;
    }

    CString szTgtFilename = lpszTgtfilename;


    // We have to check if the filename is a full qualified filename
    CFileStatus status;

	strcpy(status.m_szFullName, lpszTgtfilename);
    if (CFile::GetStatus( lpszTgtfilename, status ))
        // The file exist, get the full file name
        szTgtFilename = status.m_szFullName;

    // Generate a temporary file name
    bIsTmp = TRUE;
	CString cszTmpPath;
	DWORD dwRet = GetTempPath( 512, cszTmpPath.GetBuffer(512));
	cszTmpPath.ReleaseBuffer(-1);
	if(dwRet>512 )
		dwRet = GetTempPath( dwRet, cszTmpPath.GetBuffer(dwRet));
	cszTmpPath.ReleaseBuffer(-1);

	if(dwRet==0 || GetFileAttributes(cszTmpPath) != FILE_ATTRIBUTE_DIRECTORY){
		// Failed to get the temporary path fail, default to local dir
		dwRet = GetCurrentDirectory(512, cszTmpPath.GetBuffer(512));
        if(dwRet>512 )
            dwRet = GetCurrentDirectory( dwRet, cszTmpPath.GetBuffer(dwRet));
    }

    GetTempFileName(cszTmpPath, "RLT", 0, szTgtFilename.GetBuffer(_MAX_PATH));
    szTgtFilename.ReleaseBuffer();
	
	szTgtFilename.MakeUpper();

    // Check if the size of the file is bigger that the size on the HD
    if (CFile::GetStatus( m_SrcFileName, status )) {
        // Get drive number
        BYTE ndrive = ((BYTE)*szTgtFilename.GetBuffer(0)-(BYTE)'A')+1;


        // Get the space on the HD
        struct _diskfree_t diskfree;
        if(_getdiskfree(ndrive, &diskfree)) {
            delete []pBufStart;
            return ERROR_OUT_OF_DISKSPACE;
        }
        if ( (status.m_size*3/diskfree.bytes_per_sector)>
             (DWORD)(diskfree.avail_clusters*(DWORD)diskfree.sectors_per_cluster)) {
            delete []pBufStart;
            return ERROR_OUT_OF_DISKSPACE;
        }

    }

	TRY
	{
    uiError = (*lpfnWriteFile)((LPCSTR)m_SrcFileName,
                               (LPCSTR)szTgtFilename,
                               (HANDLE)hFileModule,
                               (LPVOID)pBufStart,
                               (UINT)uiBufSize,
                               (HINSTANCE)NULL,
                               (LPCSTR)szSymbolPath);
    }
    CATCH(CFileException, fe)
    {
        uiError = fe->m_lOsError+LAST_ERROR;
    }
    AND_CATCH( CMemoryException, e )
    {
        uiError = ERROR_NEW_FAILED;
    }
    AND_CATCH( CException, e )
    {
        uiError = ERROR_NEW_FAILED;
    }
    END_CATCH

    delete []pBufStart;

    if ( bIsTmp ) {
        if (uiError < LAST_WRN) {
            TRY {
                //
                // BUG: 409
                // We will rename if on the same drive. Otherwise copy it
                //
                if (_strnicmp( szTgtFilename, lpszTgtfilename, 1 )) {
                    UINT ErrTmp;
    				TRACE("\t\tCopyFile:\tszTgtFilename: %s\tlpszTgtfilename: %s\n", szTgtFilename.GetBuffer(0), lpszTgtfilename);
                    ErrTmp = CopyFile( szTgtFilename, lpszTgtfilename );
                    if (ErrTmp){
                        uiError = ErrTmp+LAST_ERROR;
                    }
                } else {
                    TRACE("\t\tMoveFile:\tszTgtFilename: %s\tlpszTgtfilename: %s\n", szTgtFilename.GetBuffer(0), lpszTgtfilename );
    				// Remove temporary file
    				if(CFile::GetStatus( lpszTgtfilename, status ))
    					CFile::Remove(lpszTgtfilename);
                    CFile::Rename(szTgtFilename, lpszTgtfilename);
                }
    			// Remove temporary file
    			if(CFile::GetStatus( szTgtFilename, status ))
    				CFile::Remove(szTgtFilename);
            }
            CATCH( CFileException, fe )
            {
                uiError = fe->m_lOsError+LAST_ERROR;
            }
            AND_CATCH( CException, e )
            {
                uiError = ERROR_NEW_FAILED;
            }
            END_CATCH
        }
    }

    return uiError;
}

UINT
CFileModule::CopyImage( CFileModule* pFileModule, LPCSTR lpszType, LPCSTR lpszResId )
{
	CResInfo* pResInfo;
	CResInfo* pTgtResInfo;
	int iResID = (HIWORD(lpszResId) ? 0 : LOWORD(lpszResId) );
	int iTypeID = (HIWORD(lpszType) ? 0 : LOWORD(lpszType) );

	// Find the CResInfo object we have to copy
	INT_PTR c = m_ResArray.GetUpperBound();
	while(c>=0)
	{
		pResInfo = (CResInfo*)m_ResArray.GetAt(c--);								
		if(!pResInfo)
			return  ERROR_IO_INVALIDITEM;

		// Check the type ID
		if( iTypeID && pResInfo->GetTypeName()=="" && (int)pResInfo->GetTypeId()==iTypeID) {
			// Check for the res ID
			if( iResID && (int)pResInfo->GetResId()==iResID) {
				c = -2;
			}
			// check for the res name
			else if( (iResID==0) && pResInfo->GetResName()==lpszResId) {
				c = -2;
			}
		}
		// check for the type name
		else if( HIWORD(lpszType) && pResInfo->GetTypeName()==lpszType) {
			// Check for the res ID
			if( iResID && (int)pResInfo->GetResId()==iResID) {
				c = -2;
			}
			// check for the res name
			else if( (iResID==0) && pResInfo->GetResName()==lpszResId) {
				c = -2;
			}
		}
	}
	
	if (c==-1)
		return ERROR_IO_INVALIDID;

	// find were we have to copy it
	c = pFileModule->m_ResArray.GetUpperBound();
	while(c>=0)
	{
		pTgtResInfo = (CResInfo*)pFileModule->m_ResArray.GetAt(c--);
		if(!pTgtResInfo)
			return  ERROR_IO_INVALIDITEM;

		// Check the type ID
		if( iTypeID && pTgtResInfo->GetTypeName()=="" && (int)pTgtResInfo->GetTypeId()==iTypeID) {
			// Check for the res ID
			if( iResID && (int)pTgtResInfo->GetResId()==iResID) {
				c = -2;
			}
			// check for the res name
			else if( (iResID==0) && pTgtResInfo->GetResName()==lpszResId) {
				c = -2;
			}
		}
		// check for the type name
		else if( HIWORD(lpszType) && pTgtResInfo->GetTypeName()==lpszType) {
			// Check for the res ID
			if( iResID && (int)pTgtResInfo->GetResId()==iResID) {
				c = -2;
			}
			// check for the res name
			else if( (iResID==0) && pTgtResInfo->GetResName()==lpszResId) {
				c = -2;
			}
		}
	}

	if(c==-1)
		return ERROR_IO_INVALIDID;

    // Load the image in memory from the res file
    DWORD dwReadSize = pTgtResInfo->LoadImage( pFileModule->GetName(),
    										   pFileModule->GetHInstance() );
    if (dwReadSize!=pTgtResInfo->GetSize())
        return ERROR_RW_LOADIMAGE;

	// copy the image from the res file
	pTgtResInfo->CopyImage( pResInfo );

	// We have to mark the resource has updated
    pTgtResInfo->SetFileOffset(0L);
    pTgtResInfo->SetImageUpdated(0);

	return 0;
}

UINT
CFileModule::Copy( CFileModule* pFileModule )
{
    CResInfo* pResInfo;
    CResInfo* pTgtResInfo;
    int TgtPos;
    m_dwFlags = pFileModule->m_dwFlags;

    for(INT_PTR u = m_ResArray.GetUpperBound(), c=0; c<=u ; c++) {
        pResInfo = (CResInfo*) m_ResArray.GetAt(c);
        if(!pResInfo)
            return  ERROR_IO_INVALIDITEM;
        TgtPos = pFileModule->AddResInfo( pResInfo->GetTypeId(),
                              pResInfo->GetTypeName(),
                              pResInfo->GetResId(),
                              pResInfo->GetResName(),
                              pResInfo->GetLanguage(),
                              0,
                              0);
        pTgtResInfo = (CResInfo*) pFileModule->GetResInfo( TgtPos );
        if(!pTgtResInfo)
            return  ERROR_IO_INVALIDITEM;
        pResInfo->Copy( pTgtResInfo, m_SrcFileName, m_DllHInstance );
    }
    return ERROR_NO_ERROR;
}

LPCSTR
CFileModule::EnumType( LPCSTR lpszPrevType)
{
    if (lpszPrevType) {
        // Check if the value we get is consistent.
        if (m_TypePos==0) return LPNULL;
        if (m_TypePos==m_TypeArray.GetSize()) {
            m_TypePos = 0;
            return LPNULL;
        }
        CResInfo* pResInfo = (CResInfo*)m_ResArray.GetAt(m_TypeArray.GetAt(m_TypePos-1));
		if(HIWORD(lpszPrevType)) {
			if(pResInfo->GetTypeName() != lpszPrevType)
				return LPNULL;
		}
		else {
	        if((DWORD_PTR)pResInfo->GetTypeId()!=(DWORD_PTR)lpszPrevType)
	        	return LPNULL;
		}
    } else {
        // It is the first time we have been called.
        // Generate the list of Types
        m_TypePos = 0;

        if (!m_TypeArray.GetSize())
            // We have to generate the TABLE
            for( INT_PTR c=0, UpperBound=m_ResArray.GetUpperBound(); c<=UpperBound; c++)
                 AddTypeInfo( c,
                              ((CResInfo*)m_ResArray[c])->GetTypeId(),
                              ((CResInfo*)m_ResArray[c])->GetTypeName());

        if (m_TypePos==m_TypeArray.GetSize()) {
            m_TypePos = 0;
            return LPNULL;
        }
    }


    CResInfo* pResInfo = (CResInfo*)m_ResArray.GetAt(m_TypeArray.GetAt(m_TypePos++));
    if (pResInfo->GetTypeId() && pResInfo->GetTypeName()==""){
        // It is an ordinal ID
        DWORD dwReturn = 0L;
        dwReturn = (DWORD)pResInfo->GetTypeId();
        return (LPCSTR) UlongToPtr(dwReturn);
    } else {
        // It is a string type
        strcpy( m_TypeStr, pResInfo->GetTypeName());
        return m_TypeStr;
    }
}

LPCSTR
CFileModule::EnumId( LPCSTR lpszType, LPCSTR lpszPrevId )
{
    if (!lpszType) return LPNULL;

    if(!lpszPrevId)
    {
        if(m_IdPos==0)
        {
            // Create the list of resources
            BOOL fTypeName = HIWORD(lpszType);
            CResInfo*   pResInfo;

            m_IdArray.RemoveAll();

            for( WORD i = 0, iUpperBoundRes = (WORD)m_ResArray.GetUpperBound() ; i<=iUpperBoundRes ; i++)
            {
                pResInfo = (CResInfo*)m_ResArray.GetAt(i);
                if(pResInfo)
                {
                    if( fTypeName ? !strcmp(pResInfo->GetTypeName(), lpszType) : pResInfo->GetTypeId()==LOWORD(lpszType))
                    {
                        // add this item to the LangArray
                        m_IdArray.Add(i);
                    }
                }
            }
        }
    }

    ASSERT(m_IdArray.GetSize());

    if (m_IdPos>=m_IdArray.GetSize())
    {
        m_IdPos = 0;
        return LPNULL;
    }

    // We will increment m_IdPos in the lang enum since we use the same array m_IdArray
    CResInfo* pResInfo = (CResInfo*)m_ResArray.GetAt(m_IdArray.GetAt(m_IdPos));
    if( pResInfo )
    {
        if (pResInfo->GetResId()){
            // It is an ordinal ID
            return (LPCSTR)pResInfo->GetResId();
        } else {
            // It is a string type
            strcpy( m_IdStr, pResInfo->GetResName());
            return m_IdStr;
        }
    }

    return LPNULL;
}

DWORD
CFileModule::EnumLang( LPCSTR lpszType, LPCSTR lpszId, DWORD dwPrevLang )
{
    // Parameter checking
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;

    ASSERT(m_IdArray.GetSize());

    // This is true when we have done all the languages
    // Return null but keep the m_IdPos, this will let us exit safelly from the
    // EnumId function
    if (m_IdPos==m_IdArray.GetSize())
    {
        return LPNULL;
    }

    CResInfo* pResInfo = (CResInfo*)m_ResArray.GetAt(m_IdArray.GetAt(m_IdPos++));
    if( pResInfo )
    {
        // Check if the ID match
        if(HIWORD(lpszId) ? !strcmp(lpszId, pResInfo->GetResName() ) : LOWORD(lpszId)==pResInfo->GetResId() )
        {
            if(pResInfo->GetLanguage()!=0)
                return pResInfo->GetLanguage();
            else
                return 0xFFFFFFFF;  // for the neutral language case
        }
    }

    m_IdPos--;
    return 0;
}

DWORD
CFileModule::EnumItem( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang, DWORD dwPrevItem )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;
    //if (!dwLang) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (LoadDll()==NULL) return 0L;

    if (pResInfo)
        return pResInfo->EnumItem( m_SrcFileName, m_DllHInstance, dwPrevItem );
    return 0L;
}

////////////////////////////////////////////////////////////////////////////
// CDllTable

CDllTable::CDllTable( UINT InitNum )
{

    //TRACE1("IODLL.DLL: CDllTable::CDllTable %d\n", InitNum);
    m_InitNum = InitNum;
    PCHAR pkey;
    PCHAR pbuf = new char[InitNum];
    if (pbuf==LPNULL) return;
			
	GetProfileString(SECTION, NULL, "", pbuf, InitNum);

    int c;
    if (*pbuf != '\0')
    {
        PCHAR pkey;
        CString szString;

        PCHAR pstr = new char[InitNum];
        for( pkey = pbuf, c = 0;
             *pkey != '\0' ; pkey += strlen(pkey)+1 ) {
            GetProfileString( SECTION, pkey, "Empty", pstr, InitNum);
            szString = pstr;
            if (!szString.IsEmpty())
                Add( new CDllEntryTable(szString) );
            c++;
        }
        delete pstr;
    }
    else
    {
        for (pkey = szDefaultRWDll[0], c=0;
             c < sizeof(szDefaultRWDll)/MAXKEYLEN/sizeof(TCHAR) ; pkey+= MAXKEYLEN)
        {
            Add ( new CDllEntryTable(pkey) );
            c++;
        }
    }
    m_MaxEntry = c+1;

    delete pbuf;

    return;
}

UINT CDllTable::GetPosFromTable( CString szFileType )
{
    UINT c = 0;

    // Check if the string type is not empty
    if (szFileType.IsEmpty()) return 0;

    while( (szFileType!=((CDllEntryTable*)GetAt(c))->GetType()) && (c<m_MaxEntry) ) c++;

    // Be really sure
    if ((szFileType!=((CDllEntryTable*)GetAt(c))->GetType()))
        // 0 Is an invalid position in the Table for us
        return 0;
    return c+1;
}

CDllTable::~CDllTable()
{
    INT_PTR UpperBound = GetUpperBound();
    //TRACE1("IODLL.DLL: CDllTable::~CDllTable %d\n", UpperBound);
    CDllEntryTable* pDllEntry;
    for( int c=0 ; c<=UpperBound ; c++) {
        pDllEntry = (CDllEntryTable*)GetAt(c);
        //TRACE1("\tCDllTable\tCDllEntryTable->%Fp\n", pDllEntry);
        delete pDllEntry;
    }
    RemoveAll();
}

////////////////////////////////////////////////////////////////////////////
// CModuleTable

CModuleTable::CModuleTable( UINT InitNum)
{
    //TRACE1("IODLL.DLL: CModuleTable::CModuleTable %d\n", InitNum);
	m_InitNum = InitNum;
    m_LastHandle = 0;
}

CModuleTable::~CModuleTable()
{
    INT_PTR UpperBound = GetUpperBound();
    //TRACE1("IODLL.DLL: CModuleTable::~CModuleTable %d\n", UpperBound);
    CFileModule* pFileModule;
    for( int c=0 ; c<=UpperBound ; c++) {
        pFileModule = (CFileModule*)GetAt(c);
        //TRACE1("\tCModuleTable\tCFileModule->%Fp\n", pFileModule);
        pFileModule->CleanUp();
        delete pFileModule;
    }
    RemoveAll();
}

////////////////////////////////////////////////////////////////////////////
// CDllEntryTable

CDllEntryTable::CDllEntryTable( CString szEntry )
{
    int chPos;
    if ( (chPos = szEntry.Find(","))==-1 ) {
        m_szDllName = "";
        m_szDllType = "";
        return;
    }

    m_szDllName = szEntry.Left(chPos);
    szEntry = szEntry.Right(szEntry.GetLength()-chPos-1);

    m_szDllType = szEntry;
	m_handle = NULL;
}

CDllEntryTable::~CDllEntryTable()
{
	FreeEntry();
}

HINSTANCE CDllEntryTable::LoadEntry()
{
	if(!m_handle) {
		m_handle = LoadLibrary(m_szDllName);
		TRACE("CDllEntryTable::LoadEntry: %s loaded at %p\n",m_szDllName.GetBuffer(0), (UINT_PTR)m_handle);
	}
	return m_handle;
}

BOOL CDllEntryTable::FreeEntry()
{
	BOOL bRet = FALSE;
	if(m_handle) {
		bRet = FreeLibrary(m_handle);
		TRACE("CDllEntryTable::FreeEntry: %s FreeLibrary return %d\n",m_szDllName.GetBuffer(0),bRet);
	}																
	return bRet;
}

////////////////////////////////////////////////////////////////////////////
// CResInfo

CResInfo::CResInfo( WORD Typeid, CString sztypeid,
              WORD nameid, CString sznameid,
              DWORD dwlang, DWORD dwsize, DWORD dwfileoffset, CFileModule * pFileModule )
{
    m_FileOffset = dwfileoffset;
    m_FileSize = dwsize;

    m_Language = MAKELONG(LOWORD(dwlang),LOWORD(dwlang));

    m_TypeName = sztypeid;
    m_TypeId = Typeid;

    m_ResName = sznameid;
    m_ResId = nameid;

    m_lpImageBuf = LPNULL;
    m_dwImageSize = 0L;

    m_ItemPos = 0;

    m_pFileModule = pFileModule;
}

CResInfo::~CResInfo()
{
    //TRACE("IODLL.DLL: CResInfo::~CResInfo\n");
    FreeImage();
    FreeItemArray();
}

void
CResInfo::FreeImage()
{
    if (m_lpImageBuf)
		delete []m_lpImageBuf;

    m_lpImageBuf = LPNULL;
    m_dwImageSize = 0L;
}

void
CResInfo::FreeItemArray()
{
    CItemInfo* pItemInfo;
    for( INT_PTR c=0, UpperBound=m_ItemArray.GetUpperBound(); c<=UpperBound; c++) {
        pItemInfo = (CItemInfo*)m_ItemArray.GetAt(c);
        delete pItemInfo;
    }

    m_ItemArray.RemoveAll();
}

UINT
CResInfo::AllocImage(DWORD dwSize)
{
    // Check if we have to free the value in m_lpImageBuf
    if (m_lpImageBuf)
        FreeImage();

    //TRACE2("CResInfo::AllocImage\tNewSize: %ld\tNum: %ld\n", (LONG)dwSize, lRequestLast+1);
    TRACE1("CResInfo::AllocImage\tNewSize: %ld\n", (LONG)dwSize);
	m_lpImageBuf = new BYTE[dwSize];
    if (!m_lpImageBuf) {
        TRACE("\n"
              "************* ERROR **********\n"
              "CResInfo::AllocImage: New Failed!! BYTE far * lpImageBuf = new BYTE[dwSize];\n"
              "************* ERROR **********\n"
              "\n" );
        return ERROR_NEW_FAILED;
    }

    m_dwImageSize = dwSize;
    return 0;
}

DWORD
CResInfo::LoadImage( CString lpszFilename, HINSTANCE hInst )
{
	if(!m_FileSize)
		return 0;

    if(AllocImage(m_FileSize))
        return ERROR_NEW_FAILED;

    // Call the RW and read thead the Image from the file
    DWORD (FAR PASCAL * lpfnGetImage)(LPCSTR, DWORD, LPVOID, DWORD);
    // Get the pointer to the function to extract the resources
    lpfnGetImage = (DWORD (FAR PASCAL *)(LPCSTR, DWORD, LPVOID, DWORD))
                        GetProcAddress( hInst, "RWGetImage" );
    if (lpfnGetImage==NULL) {
        FreeImage();
        return (DWORD)ERROR_DLL_PROC_ADDRESS;
    }

    DWORD dwReadSize = 0l;
    if (m_FileOffset)
        dwReadSize = (*lpfnGetImage)((LPCSTR)lpszFilename,
                                       (DWORD)m_FileOffset,
                                       (LPVOID)m_lpImageBuf,
                                       (DWORD)m_FileSize);
    if (dwReadSize!=m_FileSize) {
        FreeImage();
        return 0l;
    }
    return m_dwImageSize;
}

DWORD
CResInfo::GetImage( LPCSTR lpszFilename, HINSTANCE hInst, LPVOID lpbuffer, DWORD dwBufSize )
{
    if(!m_FileSize)
    	return 0;

    if ( (!m_lpImageBuf) && (m_FileOffset)) {
        DWORD dwReadSize = LoadImage( lpszFilename, hInst );
        if (dwReadSize!=m_dwImageSize)
            return 0L;
    }
    if (dwBufSize<m_dwImageSize)
        return m_dwImageSize;

    memcpy( lpbuffer, m_lpImageBuf, (UINT)m_dwImageSize );

    return m_dwImageSize;
}

DWORD
CResInfo::ReplaceImage( LPVOID lpNewImage, DWORD dwNewImageSize, DWORD dwUpdLang )
{
    m_ImageUpdated = 1;
    FreeImage();
    if(!m_lpImageBuf) {
		if(AllocImage(dwNewImageSize))
            return ERROR_NEW_FAILED;

        if (lpNewImage){
            memcpy(m_lpImageBuf, lpNewImage, (UINT)dwNewImageSize);
            if (dwUpdLang != 0xffffffff){
                m_Language=MAKELONG(m_Language,dwUpdLang);
            }
        }else{
            m_lpImageBuf = LPNULL;
        }

        // check if the size of the image is 0
        if(!m_FileOffset) {
            // Chances are that this is a conversion.
            // set the file size to the size of the image
            // to have it work in the getimage call back
            m_FileSize = dwNewImageSize;
        }
        m_dwImageSize = dwNewImageSize;
        m_FileOffset = 0;
    }
    return 0;
}


DWORD
CResInfo::UpdateImage( LONG dwSize, HINSTANCE hInst, LPCSTR lpszType )
{
    // We have to generate a list of info and give it back to the RW

    if (!dwSize) dwSize = m_dwImageSize*4+sizeof(RESITEM);
    if (!dwSize) dwSize = 10000;
    if (dwSize>UINT_MAX) dwSize = UINT_MAX-1024;
    TRACE1("CResInfo::UpdateImage\tNewSize: %ld\n", (LONG)dwSize);
    BYTE far * lpBuf = new BYTE[dwSize];
    if (!lpBuf) return ERROR_NEW_FAILED;
    BYTE far * lpBufStart = lpBuf;
    BYTE far * lpStrBuf = lpBuf+sizeof(RESITEM);
    LPRESITEM lpResItem = (LPRESITEM)lpBuf;
    DWORD dwBufSize = dwSize;
    CItemInfo* pItemInfo;
    DWORD dwUpdLang = m_Language;
    BOOL fUpdLang = TRUE;

    int istrlen;
    LONG lBufSize = 0;
    for(INT_PTR c=0, UpperBound=m_ItemArray.GetUpperBound(); c<=UpperBound; c++) {

        pItemInfo = (CItemInfo*) m_ItemArray.GetAt(c);
        if (!pItemInfo)
            return ERROR_IO_RESINFO_NULL;

        if(fUpdLang)
        {
            dwUpdLang = pItemInfo->GetLanguage();
            if(dwUpdLang==0xffffffff)
            {
                dwUpdLang = m_Language;
            }
            else
                fUpdLang = FALSE;
        }

		lBufSize = (LONG)dwSize;
        if (dwSize>=sizeofDWord) {
            lpResItem->dwSize = sizeof(RESITEM);    // Size
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofWord) {
            lpResItem->wX = pItemInfo->GetX(); // Coordinate
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;
        if (dwSize>=sizeofWord) {
            lpResItem->wY = pItemInfo->GetY();
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;

        if (dwSize>=sizeofWord) {
            lpResItem->wcX = pItemInfo->GetcX(); // Position
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;
        if (dwSize>=sizeofWord) {
            lpResItem->wcY = pItemInfo->GetcY();
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwCheckSum = pItemInfo->GetCheckSum();   // Checksum
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwStyle = pItemInfo->GetStyle(); // Style
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwExtStyle = pItemInfo->GetExtStyle();   // ExtendedStyle
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwFlags = pItemInfo->GetFlags();         // Flags
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwItemID = pItemInfo->GetTabPosId();     // PosId
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwResID = m_ResId;                            // ResourceID
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;
        if (dwSize>=sizeofDWord) {
            lpResItem->dwTypeID = m_TypeId;                           // Type ID
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;
        if (dwSize>=sizeofDWord) {
            lpResItem->dwLanguage = pItemInfo->GetLanguage();   // Language ID
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwCodePage = pItemInfo->GetCodePage();   // CodePage
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofWord) {
            lpResItem->wClassName = pItemInfo->GetClassNameID();// ClassName
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;
        if (dwSize>=sizeofWord) {
            lpResItem->wPointSize = pItemInfo->GetPointSize();  // CodePage
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;

        if (dwSize>=sizeofWord) {
            lpResItem->wWeight = pItemInfo->GetWeight();  // Weight
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;

        if (dwSize>=sizeofByte) {
            lpResItem->bItalic = pItemInfo->GetItalic();  // Italic
            dwSize -= sizeofByte;
        } else dwSize -= sizeofByte;

        if (dwSize>=sizeofByte) {
            lpResItem->bCharSet = pItemInfo->GetCharSet();  // CharSet
            dwSize -= sizeofByte;
        } else dwSize -= sizeofByte;

        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszClassName = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;
        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszFaceName = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;
        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszCaption = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;
        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszResID = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;
        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszTypeID = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;

        // Copy the strings
        istrlen = (pItemInfo->GetClassName()).GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszClassName = strcpy((char*)lpStrBuf, pItemInfo->GetClassName());
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        istrlen = (pItemInfo->GetFaceName()).GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszFaceName = strcpy((char*)lpStrBuf, pItemInfo->GetFaceName());
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        istrlen = (pItemInfo->GetCaption()).GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszCaption = strcpy((char*)lpStrBuf, pItemInfo->GetCaption());
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        istrlen = m_ResName.GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszResID = strcpy((char*)lpStrBuf, m_ResName);
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        istrlen = m_TypeName.GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszTypeID = strcpy((char*)lpStrBuf, m_TypeName);
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        // Check if we are alligned
        BYTE bPad = Allign(lBufSize-(LONG)dwSize);
    	if((LONG)dwSize>=bPad) {
            	lpResItem->dwSize += bPad;
            	dwSize -= bPad;
            	while(bPad) {
                		*lpStrBuf = 0x00;
                		lpStrBuf += 1;
                		bPad--;
            	}
    	}
	else dwSize -= bPad;

        // move to the next item
        lpResItem = (LPRESITEM) lpStrBuf;
        lpStrBuf  += sizeof(RESITEM);

    }

    if (dwSize<0){
        delete []lpBufStart;
        return dwBufSize-dwSize;
    }
    else dwSize = dwBufSize-dwSize;

    // Give all back to the RW and wait
    UINT (FAR PASCAL * lpfnGenerateImage)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*);
    UINT (FAR PASCAL * lpfnGenerateImageEx)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*, LPCSTR);

    //
    // Trye to get the pointer to the extended version of the function...
    //
    lpfnGenerateImageEx = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*, LPCSTR))
                                GetProcAddress( hInst, "RWUpdateImageEx" );

    if (lpfnGenerateImageEx==NULL) {
        //
        // get the old update image function since the RW doesn't support RC data
        //
        lpfnGenerateImage = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*))
                                GetProcAddress( hInst, "RWUpdateImage" );

        if (lpfnGenerateImage==NULL)
           return ERROR_DLL_PROC_ADDRESS;
    }

    DWORD dwNewImageSize = m_dwImageSize*3+sizeof(RESITEM);
    if(!dwNewImageSize)
        dwNewImageSize = 10000;
    if (dwNewImageSize>UINT_MAX)
        dwNewImageSize = UINT_MAX-1024;
    DWORD dwOriginalImageSize = dwNewImageSize;
    BYTE far * lpNewImage = new BYTE[dwNewImageSize];
    if (!lpNewImage) {
        delete []lpBufStart;
        return ERROR_NEW_FAILED;
    }

#ifndef _DEBUG
    // set the memory to 0
    memset( lpNewImage, 0, (size_t)dwNewImageSize );
#endif

    UINT uiError;
    if(lpfnGenerateImageEx)
    {

        uiError = (*lpfnGenerateImageEx)( (LPCSTR)lpszType,
                                            (LPVOID)lpBufStart,
                                            (DWORD) dwSize,
                                            (LPVOID)m_lpImageBuf,
                                            (DWORD) m_dwImageSize,
                                            (LPVOID)lpNewImage,
                                            (DWORD*)&dwNewImageSize,
                                            (LPCSTR)m_pFileModule->GetRDFName()
                                            );
    }
    else
    {
        uiError = (*lpfnGenerateImage)( (LPCSTR)lpszType,
                                            (LPVOID)lpBufStart,
                                            (DWORD) dwSize,
                                            (LPVOID)m_lpImageBuf,
                                            (DWORD) m_dwImageSize,
                                            (LPVOID)lpNewImage,
                                            (DWORD*)&dwNewImageSize
                                            );
    }

    if (dwNewImageSize>dwOriginalImageSize) {
        delete []lpNewImage;
        TRACE1("CResInfo::UpdateImage\tNewSize: %ld\n", (LONG)dwNewImageSize);
        if (dwNewImageSize>UINT_MAX)
            dwNewImageSize = UINT_MAX-1024;
        lpNewImage = new BYTE[dwNewImageSize];
        if (!lpNewImage) {
            delete []lpBufStart;
            return ERROR_NEW_FAILED;
        }

#ifndef _DEBUG
        // set the memory to 0
        memset( lpNewImage, 0, (size_t)dwNewImageSize );
#endif

        if(lpfnGenerateImageEx)
        {

            uiError = (*lpfnGenerateImageEx)( (LPCSTR)lpszType,
                                                (LPVOID)lpBufStart,
                                                (DWORD) dwSize,
                                                (LPVOID)m_lpImageBuf,
                                                (DWORD) m_dwImageSize,
                                                (LPVOID)lpNewImage,
                                                (DWORD*)&dwNewImageSize,
                                                (LPCSTR)m_pFileModule->GetRDFName()
                                                );
        }
        else
        {
            uiError = (*lpfnGenerateImage)( (LPCSTR)lpszType,
                                                (LPVOID)lpBufStart,
                                                (DWORD) dwSize,
                                                (LPVOID)m_lpImageBuf,
                                                (DWORD) m_dwImageSize,
                                                (LPVOID)lpNewImage,
                                                (DWORD*)&dwNewImageSize
                                                );
        }


    }


    if ((dwNewImageSize) && (!uiError)) {
        m_ImageUpdated = 1;
        FreeImage();
        if(!m_lpImageBuf) {
			if(AllocImage(dwNewImageSize))
                return ERROR_NEW_FAILED;
            memcpy(m_lpImageBuf, lpNewImage, (UINT)dwNewImageSize);
            // check if the size of the image is 0
            if(!m_FileOffset) {
                // Chances are that this is a conversion.
                // set the file size to the size of the image
                // to have it work in the getimage call back
                m_FileSize = dwNewImageSize;
            }
            m_dwImageSize = dwNewImageSize;
            dwNewImageSize = 0;
            m_Language = MAKELONG(HIWORD(m_Language),LOWORD(dwUpdLang));
        }
    }

    delete []lpNewImage;
    delete []lpBufStart;

    return dwNewImageSize;
}

UINT
CResInfo::GetData(  LPCSTR lpszFilename, HINSTANCE hInst,
                    DWORD dwItem, LPVOID lpbuffer, UINT uiBufSize )
{
    // We assume the buffer is pointing to a _ResItem Struct

    // [ALESSANM 25-06-93] - mod 1
    LPRESITEM lpResItem = (LPRESITEM) lpbuffer;

    UINT uiPos = HIWORD(dwItem);

    if (!m_ItemArray.GetSize()) {
        // We have to load the array again. What if the image has been modified?
        // Check the fileoffset to see if it is 0.
        if (!m_lpImageBuf) {
            // Load the resource.image
            DWORD dwReadSize = LoadImage( lpszFilename, hInst );

            if (dwReadSize!=m_dwImageSize)
                return 0;
        }

        // We have now to pass the Buffer back to the RW to Parse the info
        if (!(ParseImage( hInst )) )
            return 0;
    }

    if (uiPos>(UINT)m_ItemArray.GetSize())
        // Wrong pointer to the item
        return 0;

    CItemInfo* pItemInfo = (CItemInfo*)m_ItemArray.GetAt( uiPos-1 );

    if (!pItemInfo)
        return 0;

    // Check if the Id match
    if (pItemInfo->GetId()!=LOWORD(dwItem))
        return 0;

    // fill the structure with the info we have
    UINT uiSize = 0;

    // calc the size and check if the buffer is too small
    // Strings Field in the CItemInfo
    uiSize =  (pItemInfo->GetCaption()).GetLength()+1;
    uiSize +=  (pItemInfo->GetFaceName()).GetLength()+1;
    uiSize +=  (pItemInfo->GetClassName()).GetLength()+1;
    // Strings field in the CResItem
    uiSize += (m_ResName).GetLength()+1;
    uiSize += (m_TypeName).GetLength()+1;
    // Fixed field in the ResItem Structure
    uiSize += sizeof(RESITEM);

    // Check if the user buffer is too small
    if (uiBufSize<uiSize)
        return uiSize;

    // Get the pointer to the end of the structure (begin of the buffer)
    char far * lpStrBuf = (char far *)lpbuffer+sizeof(RESITEM);

    // Size of the structure
    lpResItem->dwSize = uiSize;

    // Copy the items in the buffer
    // Start from the fixed field
    // Coordinate
    lpResItem->wX = pItemInfo->GetX();
    lpResItem->wY = pItemInfo->GetY();
    lpResItem->wcX = pItemInfo->GetcX();
    lpResItem->wcY = pItemInfo->GetcY();

    // Checksum and Style
    lpResItem->dwCheckSum = pItemInfo->GetCheckSum();
    lpResItem->dwStyle = pItemInfo->GetStyle();
    lpResItem->dwExtStyle = pItemInfo->GetExtStyle();
    lpResItem->dwFlags = pItemInfo->GetFlags();

    // ID
    // This is needed for the update by terms.
    // We have to have unique ID
	if((m_TypeId==4) &&(pItemInfo->GetFlags() & MF_POPUP)) {
        // Check if we have an id. otherwise is the old ID format
        lpResItem->dwItemID = pItemInfo->GetPosId();

        if(!lpResItem->dwItemID)
		    lpResItem->dwItemID = pItemInfo->GetTabPosId();
    } else {
        // Fixed bug No: 165
        if(pItemInfo->GetId() != -1)
            lpResItem->dwItemID = pItemInfo->GetPosId();
        else lpResItem->dwItemID = pItemInfo->GetTabPosId();
    }

    lpResItem->dwResID = m_ResId;
    lpResItem->dwTypeID = m_TypeId;
    lpResItem->dwLanguage = LOWORD(m_Language);

    // Code page, Class and Font
    lpResItem->dwCodePage = pItemInfo->GetCodePage();
    lpResItem->wClassName = pItemInfo->GetClassNameID();
    lpResItem->wPointSize = pItemInfo->GetPointSize();
    lpResItem->wWeight = pItemInfo->GetWeight();
    lpResItem->bItalic = pItemInfo->GetItalic();
    lpResItem->bCharSet = pItemInfo->GetCharSet();

    // Let's start copy the string

    lpResItem->lpszClassName = strcpy( lpStrBuf, pItemInfo->GetClassName() );
    lpStrBuf += strlen(lpResItem->lpszClassName)+1;

    lpResItem->lpszFaceName = strcpy( lpStrBuf, pItemInfo->GetFaceName() );
    lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

    lpResItem->lpszCaption = strcpy( lpStrBuf, pItemInfo->GetCaption() );
    lpStrBuf += strlen(lpResItem->lpszCaption)+1;

    lpResItem->lpszResID = strcpy( lpStrBuf, m_ResName );
    lpStrBuf += strlen(lpResItem->lpszResID)+1;

    lpResItem->lpszTypeID = strcpy( lpStrBuf, m_TypeName );
    lpStrBuf += strlen(lpResItem->lpszTypeID)+1;

    return uiSize;
}

UINT
CResInfo::UpdateData(  LPCSTR lpszFilename, HINSTANCE hInst,
                       DWORD dwItem, LPVOID lpbuffer, UINT uiBufSize )
{
    UINT uiError = ERROR_NO_ERROR;
    UINT uiPos = HIWORD(dwItem);
    TRACE1("UpdateData:\tdwItem:%lx\t", dwItem);
    // we have to see if the array has been loaded before
    if (!m_ItemArray.GetSize()) {
        // We have to load the array again
        if (!m_lpImageBuf) {
            // Load the resource.image
            DWORD dwReadSize = LoadImage( lpszFilename, hInst );

            if (dwReadSize!=m_dwImageSize)
                return ERROR_RW_LOADIMAGE;
        }

        // We have now to pass the Buffer back to the RW to Parse the info
        if (!(ParseImage( hInst )) )
            return ERROR_RW_PARSEIMAGE;
    }

    if (uiPos>(UINT)m_ItemArray.GetSize())
        // Wrong pointer to the item
        return ERROR_IO_INVALIDITEM;

    CItemInfo* pItemInfo = (CItemInfo*)m_ItemArray.GetAt( uiPos-1 );

    if (!pItemInfo)
        return ERROR_IO_INVALIDITEM;

    TRACE2("m_dwPosId:%lx\tm_wTabPos:%lx\n", pItemInfo->GetPosId(), pItemInfo->GetTabPosId());
    // Check if the Id match
    if (lpbuffer)
        if (pItemInfo->GetPosId()!=((LPRESITEM)lpbuffer)->dwItemID)
        {
            // we have some files with ID = 0, check for that
            if (pItemInfo->GetTabPosId()!=((LPRESITEM)lpbuffer)->dwItemID)
                return ERROR_IO_INVALIDID;
        }

    if ((uiError = pItemInfo->UpdateData( (LPRESITEM)lpbuffer )) )
        return uiError;

    // We have to mark the resource has updated
    m_FileOffset = 0L;
    m_ImageUpdated = 0;
    return uiError;
}

DWORD
CResInfo::ParseImage( HINSTANCE hInst )
{
    //
    // Check if the new RCData handling is supported
    //

    UINT (FAR PASCAL  * lpfnParseImageEx)(LPCSTR, LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPCSTR);
    UINT (FAR PASCAL  * lpfnParseImage)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD);

    // Get the pointer to the function to extract the resources
    lpfnParseImageEx = (UINT (FAR PASCAL *)(LPCSTR, LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPCSTR))
                        GetProcAddress( hInst, "RWParseImageEx" );
    if (lpfnParseImageEx==NULL) {
        //
        // This is and old RW get the old entry point
        //
        lpfnParseImage = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD))
                            GetProcAddress( hInst, "RWParseImage" );
        if (lpfnParseImage==NULL) {
            return (DWORD)ERROR_DLL_PROC_ADDRESS;
        }
    }

    BYTE far * lpBuf;
    DWORD dwSize = m_dwImageSize*8+sizeof(RESITEM);

    if ((dwSize>UINT_MAX) || (dwSize==0))
        dwSize = 30000;

    TRACE1("CResInfo::ParseImage\tNewSize: %ld\n", (LONG)dwSize);
    lpBuf = new BYTE[dwSize];
    if (!lpBuf)
        return 0;

    LPSTR   lpszType = LPNULL;
    if (m_TypeName=="" && m_TypeId)
    	lpszType = (LPSTR)((WORD)m_TypeId);
	else
		lpszType = (LPSTR)(m_TypeName.GetBuffer(0));

    LPSTR   lpszResId = LPNULL;
    if (m_ResName=="" && m_ResId)
    	lpszResId = (LPSTR)((WORD)m_ResId);
	else
		lpszResId = (LPSTR)(m_ResName.GetBuffer(0));

    LONG dwRead = 0;

    if(lpfnParseImageEx)
    {
        dwRead = (*lpfnParseImageEx)((LPCSTR)lpszType,
                                     (LPCSTR)lpszResId,
                                     (LPVOID)m_lpImageBuf,
                                     (DWORD)m_dwImageSize,
                                     (LPVOID)lpBuf,
                                     (DWORD)dwSize,
                                     (LPCSTR)m_pFileModule->GetRDFName());
    } else
    {
        dwRead = (*lpfnParseImage)((LPCSTR)lpszType,
                                     (LPVOID)m_lpImageBuf,
                                     (DWORD)m_dwImageSize,
                                     (LPVOID)lpBuf,
                                     (DWORD)dwSize);
    }

    if (dwRead>(LONG)dwSize) {
        // We have to allocate a bigger buffer
        delete []lpBuf;
        TRACE1("CResInfo::ParseImage\tNewSize: %ld\n", (LONG)dwRead);
    	lpBuf = (BYTE far *) new BYTE[dwRead];

        if (!lpBuf)
            return 0;

        dwSize = dwRead;
        // try to read again
        if(lpfnParseImageEx)
        {
            dwRead = (*lpfnParseImageEx)((LPCSTR)lpszType,
                                         (LPCSTR)lpszResId,
                                         (LPVOID)m_lpImageBuf,
                                         (DWORD)m_dwImageSize,
                                         (LPVOID)lpBuf,
                                         (DWORD)dwSize,
                                         (LPCSTR)m_pFileModule->GetRDFName());
        } else
        {
            dwRead = (*lpfnParseImage)((LPCSTR)lpszType,
                                         (LPVOID)m_lpImageBuf,
                                         (DWORD)m_dwImageSize,
                                         (LPVOID)lpBuf,
                                         (DWORD)dwSize);
        }

        if (dwRead>(LONG)dwSize) {
            // Abort
            delete []lpBuf;
            return 0;
        }
    }


    // Parse the buffer we have got and fill the array with the information
    // The buffer we are expecting is a series of ResItem structure
    FreeItemArray();

    // We want to parse all the stucture in the buffer
    LPRESITEM   lpResItem = (LPRESITEM) lpBuf;
    BYTE far * lpBufStart = lpBuf;
    WORD wTabPos = 0;
    WORD wPos = 0;
	//m_ItemArray.SetSize(10,5);
    while ( (dwRead>0) && ((LONG)lpResItem->dwSize!=-1) ) {
        //TRACE1("Caption: %Fs\n", lpResItem->lpszCaption);
        wTabPos++;
        if ( !(
             ((int)lpResItem->wX==-1) &&
             ((int)lpResItem->wY==-1) &&
             ((int)lpResItem->wcX==-1) &&
             ((int)lpResItem->wcY==-1) &&
             ((LONG)lpResItem->dwItemID==-1) &&
             //(LOWORD(dwPosId)==0) &&
             ((LONG)lpResItem->dwStyle==-1) &&
             ((LONG)lpResItem->dwExtStyle==-1) &&
             ((LONG)lpResItem->dwFlags==-1) &&
             (strlen((LPSTR)lpResItem->lpszCaption)==0)
             )
            ) {

            TRACE2("\tItems-> x: %d\ty: %d\t", lpResItem->wX, lpResItem->wY );
            TRACE2("cx: %d\tcy: %d\t", lpResItem->wcX, lpResItem->wcY );
            TRACE1("Id: %lu\t", lpResItem->dwItemID);
            TRACE2("Style: %ld\tExtStyle: %ld\n", lpResItem->dwStyle, lpResItem->dwExtStyle);
            if (lpResItem->lpszCaption) {
                UINT len = strlen((LPSTR)lpResItem->lpszCaption);
                TRACE2("Len: %d\tText: %s\n", len,
                                          (len<256 ? lpResItem->lpszCaption : ""));
            }
            TRACE2("dwRead: %lu\tdwSize: %lu\n", dwRead, lpResItem->dwSize);

            //lpResItem->dwItemID = MAKELONG(LOWORD(lpResItem->dwItemID), ++wPos);

			m_ItemArray.Add( new CItemInfo( lpResItem, wTabPos ));
        }

        // Next Item
        lpBuf += lpResItem->dwSize;
        dwRead -= lpResItem->dwSize;
        lpResItem = (LPRESITEM) lpBuf;

    }

	delete []lpBufStart;


    return (DWORD)m_ItemArray.GetSize();
}

UINT
CResInfo::CopyImage( CResInfo* pResInfo )
{
	// Will copy the image from this object to the pResInfo object
	// We need this to hack the image transformation
	// When we will have time we will do the thing right
	// Allocate memory for the new image
	if(!m_dwImageSize)
		return 0;
	if(pResInfo->AllocImage(m_dwImageSize))
        return ERROR_NEW_FAILED;

    // Copy the data
    memcpy( pResInfo->m_lpImageBuf, m_lpImageBuf, (size_t)m_dwImageSize );

	// set the file size so the GetImage will not complain
	pResInfo->SetFileSize(m_FileSize);

	return 0;
}

UINT
CResInfo::Copy( CResInfo* pResInfo, CString szFileName, HINSTANCE hInst )
{
    CItemInfo* pItemInfo;
    INT_PTR u = m_ItemArray.GetUpperBound();
    if (u==-1) {
        if ( (!m_lpImageBuf) && (m_FileOffset)) {
            DWORD dwReadSize = LoadImage( szFileName, hInst );
            if (dwReadSize!=m_dwImageSize)
                return ERROR_RW_LOADIMAGE;
        }
        if (!(ParseImage( hInst )) )
            return ERROR_RW_PARSEIMAGE;
        u = m_ItemArray.GetUpperBound();
    }

    // This is a bad hack and doesn't fit at all in the design of the module.
    // We have to copy the image between ResInfo object to be able to
    // Pass on the raw data. Since in the RESITEM structure there isn't a
    // pointer to a raw data buffer we cannot pass the data for the Cursor, bitmaps...
    // What we will do is hard code the type id of this image and if the resource
    // is one of this we will copy the raw data and perform an UpdateImage in the RES16
    // module. If it is a standard item then we procede as usual calling the GenerateImage
    // in the RES16 Module.
    // The right thing to do should be to have a pointer to the raw data in the RESITEM
    // structure so when the item is a pure data item we can still pass the data on.
    // To do this we have to change the RESITEM structure and this will mean go in each RW
    // and make sure that all the place in which we fill the RESITEM get modified.

    switch(m_TypeId) {
    	// Copy only the Bitmaps, Cursors and Icons usualy have no localizable strings
    	/*
    	case 1:
    		// copy the image
    		CopyImage( pResInfo );
    	break;
    	*/
    	case 2:
    		// copy the image
    		CopyImage( pResInfo );
    	break;
    	/*
    	case 3:
    		// copy the image
    		CopyImage( pResInfo );
    	break;
    	*/
    	default:
    		// do nothing
    	break;
    }
	//m_ItemArray.SetSize(u,10);
    for( int c=0; c<=u ; c++) {
        pItemInfo = (CItemInfo*) m_ItemArray.GetAt(c);
        if(!pItemInfo)
            return  ERROR_IO_INVALIDITEM;
        pResInfo->AddItem( *pItemInfo );
    }

    // We have to mark the resource has updated
    pResInfo->SetFileOffset(0L);
    pResInfo->SetImageUpdated(0);

    return ERROR_NO_ERROR;
}

int
CResInfo::AddItem( CItemInfo ItemInfo )
{
    return (int)m_ItemArray.Add( new CItemInfo( ItemInfo ));
}

DWORD
CResInfo::EnumItem( LPCSTR lpszFilename, HINSTANCE hInst, DWORD dwPrevItem )
{
    if (dwPrevItem) {
        if (m_ItemPos==0) return LPNULL;
        if (m_ItemPos==m_ItemArray.GetSize()) {
            m_ItemPos = 0;
            return LPNULL;
        }
    } else {
        // It is the first time or the user want to restart

        // Load the resource.image
        DWORD dwReadSize = LoadImage( lpszFilename, hInst );

        if (dwReadSize!=m_FileSize) {
            return 0L;
        }

        // We have now to pass the Buffer back to the RW to Parse the info
        if (!(ParseImage( hInst )) )
            return 0L;

        m_ItemPos = 0;
    }

    CItemInfo* pItemInfo = (CItemInfo*)m_ItemArray.GetAt( m_ItemPos++ );
    while( (
             (pItemInfo->GetX()==0) &&
             (pItemInfo->GetY()==0) &&
             (pItemInfo->GetcX()==0) &&
             (pItemInfo->GetcY()==0) &&
             (pItemInfo->GetId()==0) &&
             (pItemInfo->GetStyle()==0) &&
             (pItemInfo->GetExtStyle()==0) &&
             ((pItemInfo->GetCaption()).IsEmpty())
             )
            ) {
        if(m_ItemArray.GetUpperBound()>=m_ItemPos)
            pItemInfo = (CItemInfo*)m_ItemArray.GetAt( m_ItemPos++ );
        else return 0L;

    }


    if (!pItemInfo) return 0L;

    return pItemInfo->GetTabPosId();
}

////////////////////////////////////////////////////////////////////////////
// CItemInfo

CItemInfo::CItemInfo(   WORD x, WORD y,
                WORD cx, WORD cy,
                DWORD dwPosId, WORD wPos,
                DWORD dwStyle, DWORD dwExtStyle,
                CString szText )
{
    m_wX = x;
    m_wY = y;

    m_wCX = cx;
    m_wCY = cy;

    m_dwPosId = dwPosId;
    m_wTabPos = wPos;

    m_dwStyle = dwStyle;
    m_dwExtStyle = dwExtStyle;

    m_szCaption = szText;
}

CItemInfo::CItemInfo( LPRESITEM lpResItem, WORD wTabPos )
{
    m_wX = lpResItem->wX;
    m_wY = lpResItem->wY;

    m_wCX = lpResItem->wcX;
    m_wCY = lpResItem->wcY;

    m_dwCheckSum = lpResItem->dwCheckSum;
    m_dwStyle = lpResItem->dwStyle;
    m_dwExtStyle = lpResItem->dwExtStyle;
    m_dwFlags = lpResItem->dwFlags;
    m_dwPosId = lpResItem->dwItemID;
    m_wTabPos = wTabPos;

    m_dwCodePage = lpResItem->dwCodePage;
    m_dwLanguage = lpResItem->dwLanguage;
    m_wClassName = lpResItem->wClassName;
    m_wPointSize = lpResItem->wPointSize;
    m_wWeight = lpResItem->wWeight;
    m_bItalic   = lpResItem->bItalic;
    m_bCharSet   = lpResItem->bCharSet;

    m_szClassName = lpResItem->lpszClassName;
    m_szFaceName = lpResItem->lpszFaceName;
    m_szCaption = lpResItem->lpszCaption;
}

UINT
CItemInfo::UpdateData( LPVOID lpbuffer, UINT uiBufSize )
{
    UINT uiError = ERROR_NO_ERROR;
    //
    // This is old and was used at the very beginning. Never used now.
    //
    return uiError;

}

UINT
CItemInfo::UpdateData( LPRESITEM lpResItem )
{
    if (lpResItem){
        m_wX = lpResItem->wX;
        m_wY = lpResItem->wY;

        m_wCX = lpResItem->wcX;
        m_wCY = lpResItem->wcY;

        m_dwCheckSum = lpResItem->dwCheckSum;
        m_dwStyle = lpResItem->dwStyle;
        m_dwExtStyle = lpResItem->dwExtStyle;
        m_dwFlags = lpResItem->dwFlags;

        SetId(LOWORD(lpResItem->dwItemID)); //m_dwPosId = lpResItem->dwItemId;
        //m_wTabPos = wTabPos;

        m_dwCodePage = lpResItem->dwCodePage;
        m_dwLanguage = lpResItem->dwLanguage;
        m_wClassName = lpResItem->wClassName;
        m_wPointSize = lpResItem->wPointSize;
        m_wWeight = lpResItem->wWeight;
        m_bItalic   = lpResItem->bItalic;
        m_bCharSet   = lpResItem->bCharSet;

        m_szClassName = lpResItem->lpszClassName;
        m_szFaceName = lpResItem->lpszFaceName;
        m_szCaption = lpResItem->lpszCaption;
    }
    return 0;
}


void
CItemInfo::SetPos( WORD wPos )
{
    WORD wId = LOWORD(m_dwPosId);

    m_dwPosId = 0;
    m_dwPosId = wPos;
    m_dwPosId = (m_dwPosId << 16);

    if (wId>0)
        m_dwPosId += wId;
    else m_dwPosId -= wId;
}

void
CItemInfo::SetId( WORD wId )
{
    WORD wPos = HIWORD(m_dwPosId);

    m_dwPosId = 0;
    m_dwPosId = wPos;
    m_dwPosId = (m_dwPosId << 16);

    if (wId>0)
        m_dwPosId += wId;
    else m_dwPosId -= wId;
}

DWORD
CItemInfo::GetTabPosId()
{
    DWORD dwTabPosId = 0;
    WORD wId = LOWORD(m_dwPosId);

    dwTabPosId = m_wTabPos;
    dwTabPosId = (dwTabPosId << 16);

    if (wId>0)
        dwTabPosId += wId;
    else dwTabPosId -= wId;
    return dwTabPosId;
}

CItemInfo::CItemInfo( const CItemInfo &iteminfo )
{
    m_wX = iteminfo.m_wX;
    m_wY = iteminfo.m_wY;

    m_wCX = iteminfo.m_wCX;
    m_wCY = iteminfo.m_wCY;

    m_dwCheckSum = iteminfo.m_dwCheckSum;
    m_dwStyle = iteminfo.m_dwStyle;
    m_dwExtStyle = iteminfo.m_dwExtStyle;
    m_dwFlags = iteminfo.m_dwFlags;

    m_dwPosId = iteminfo.m_dwPosId;
    m_wTabPos = iteminfo.m_wTabPos;

    m_dwCodePage = iteminfo.m_dwCodePage;
    m_dwLanguage = iteminfo.m_dwLanguage;
    m_wClassName = iteminfo.m_wClassName;
    m_wPointSize = iteminfo.m_wPointSize;
    m_wWeight = iteminfo.m_wWeight;
    m_bItalic   = iteminfo.m_bItalic;
    m_bCharSet   = iteminfo.m_bCharSet;

    m_szClassName = iteminfo.m_szClassName;
    m_szFaceName = iteminfo.m_szFaceName;
    m_szCaption = iteminfo.m_szCaption;
}

static BYTE Allign(LONG bLen)
{
   BYTE bPad =(BYTE)PadPtr(bLen);
   return bPad;
}

static UINT CopyFile( const char * pszfilein, const char * pszfileout )
{
    CFile filein;
    CFile fileout;

    if (!filein.Open(pszfilein, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return ERROR_FILE_OPEN;

    if (!fileout.Open(pszfileout, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
        return ERROR_FILE_CREATE;

    LONG lLeft = filein.GetLength();
    WORD wRead = 0;
    DWORD dwOffset = 0;
    BYTE far * pBuf = (BYTE far *) new BYTE[32739];

    if(!pBuf)
        return ERROR_NEW_FAILED;

    while(lLeft>0){
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!= filein.Read( pBuf, wRead))
            return ERROR_FILE_READ;
        fileout.Write( pBuf, wRead );
        lLeft -= wRead;
        dwOffset += wRead;
    }

    delete []pBuf;
    return ERROR_NO_ERROR;
}


void CheckError(LPCSTR szStr)
{
TRY
{
    DWORD dwErr = GetLastError();
    char szBuf[256];
    wsprintf( szBuf, "%s return: %d\n", szStr, dwErr);
    TRACE(szBuf);
}
CATCH( CException, e )
{
    TRACE("There is an Exception!\n");
}
END_CATCH
}


////////////////////////////////////////////////////////////////////////////
// RDF File support code

HANDLE
OpenModule(
	LPCSTR   lpszSrcfilename,       // File name of the executable to use as source file
	LPCSTR   lpszfiletype,			// Type of the executable file if known
	LPCSTR   lpszRDFfile,
    DWORD    dwFlags )
{
    TRACE2("IODLL.DLL: RSOpenModule: %s %s\n", lpszSrcfilename, lpszfiletype);
    UINT uiError = ERROR_NO_ERROR;
    INT_PTR uiHandle = 0 ;

    // Before we do anything we have to check if the file exist
    CFileStatus status;
    if(!CFile::GetStatus( lpszSrcfilename, status ))
    	return UlongToHandle(ERROR_FILE_OPEN);

    // Check if the user already knows the type of the executable
    CString szSrcFileType;
    if (!lpszfiletype) {
        if(uiError = RSFileType( lpszSrcfilename, szSrcFileType.GetBuffer(100) ))
            return UlongToHandle(uiError);
        szSrcFileType.ReleaseBuffer(-1);
    } else szSrcFileType = lpszfiletype;

    gModuleTable.Add(new CFileModule( lpszSrcfilename,
                                      lpszRDFfile,
                                      gDllTable.GetPosFromTable(szSrcFileType),
                                      dwFlags ));

    // Get the position in the array.
    uiHandle = gModuleTable.GetSize();

    // Read the informations on the type in the file.
    CFileModule* pFileModule = (CFileModule*)gModuleTable.GetAt(uiHandle-1);

    if (!pFileModule)
        return UlongToHandle(ERROR_IO_INVALIDMODULE);

    if (pFileModule->LoadDll()==NULL)
        return UlongToHandle(ERROR_DLL_LOAD);

    HINSTANCE hInst = pFileModule->GetHInstance();
    UINT (FAR PASCAL * lpfnReadResInfo)(LPCSTR, LPVOID, UINT*);
    // Get the pointer to the function to extract the resources
    lpfnReadResInfo = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, UINT*))
                        GetProcAddress( hInst, "RWReadTypeInfo" );
    if (lpfnReadResInfo==NULL) {
        return UlongToHandle(ERROR_DLL_PROC_ADDRESS);
    }

    UINT uiSize = 50000;
    BYTE far * pBuf = new BYTE[uiSize];

    if (!pBuf)
        return UlongToHandle(ERROR_NEW_FAILED);

    uiError = (*lpfnReadResInfo)((LPCSTR)pFileModule->GetName(),
                                 (LPVOID)pBuf,
                                 (UINT*) &uiSize);

    // Check if the buffer was big enough
    if (uiSize>50000) {
        // The buffer was too small reallocate
        UINT uiNewSize = uiSize;
        delete [] pBuf;
        pBuf = new BYTE[uiSize];
        if (!pBuf)
            return UlongToHandle(ERROR_NEW_FAILED);
        uiError = (*lpfnReadResInfo)((LPCSTR)pFileModule->GetName(),
                                 (LPVOID)pBuf,
                                 (UINT*) &uiSize);
        if (uiSize!=uiNewSize)
            return UlongToHandle(ERROR_NEW_FAILED);

    }

    if (uiError!=ERROR_NO_ERROR) {
        delete pBuf;
        pFileModule->CleanUp();
        return UlongToHandle(uiError);
    }

    // We have a buffer with all the information the DLL was able to get.
    // Fill the array in the CFileModule class

    BYTE* pBufPos = pBuf;
    BYTE* pBufStart = pBuf;

    WORD wTypeId;
    WORD wNameId;

    CString szTypeId;
    CString szNameId;

    DWORD dwlang;
    DWORD dwfileOffset;
    DWORD dwsize;

    pFileModule->SetResBufSize( uiSize );
    while(uiSize) {
        wTypeId = *((WORD*)pBuf);
        pBuf += sizeofWord;

        szTypeId = (char*)pBuf;
        pBuf += strlen((char*)pBuf)+1;
        pBuf += Allign((LONG)(pBuf-pBufPos));

        wNameId = *((WORD*)pBuf);
        pBuf += sizeofWord;

        szNameId = (char*)pBuf;
        pBuf += strlen((char*)pBuf)+1;
        pBuf += Allign((LONG)(pBuf-pBufPos));

        dwlang = *((DWORD*)pBuf);
        pBuf += sizeofDWord;

        dwsize = *((DWORD*)pBuf);
        pBuf += sizeofDWord;

        dwfileOffset = *((DWORD*)pBuf);
        pBuf += sizeofDWord;

        uiSize -= (UINT)(pBuf-pBufPos);
        pBufPos = pBuf;


        TRACE1("TypeId: %d\t", wTypeId);
        TRACE1("TypeName: %s\t", szTypeId);
        TRACE1("NameId: %d\t", wNameId);
        TRACE1("NameName: %s\t", szNameId);
        TRACE1("ResLang: %lu\t", dwlang);
        TRACE1("ResSize: %lu\t", dwsize);
        TRACE1("FileOffset: %lX\n", dwfileOffset);

        //TRACE1("uiError: %u\n", uiSize);
       	pFileModule->AddResInfo( wTypeId,
                              szTypeId,
                              wNameId,
                              szNameId,
                              dwlang,
                              dwsize,
                              dwfileOffset );
    }

    delete pBufStart;
    return (HANDLE)(uiHandle+FIRSTVALIDVALUE);
}

////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation

////////////////////////////////////////////////////////////////////////////
// Library init
////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory
		// here, use the TRACE or ASSERT macros or call MessageBox
		AfxInitExtensionModule(extensionDLL, hInstance);
		g_iDllLoaded = 0;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxWinTerm();
	}

	if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
		return 0;		// CRT term	Failed

	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\common\helper.h ===
//=============================================================================
// These are headers for common rw functions
//=============================================================================

//=============================================================================
// Global definitions

#define MAXSTR 8192

#define Pad4(x) ((((x+3)>>2)<<2)-x)
#define Pad16(x) ((((x+15)>>4)<<4)-x)

extern  UINT g_cp/* = CP_ACP*/; // Default to CP_ACP

//=============================================================================
// Functions prototypes

UINT _MBSTOWCS( WCHAR * pwszOut, CHAR * pszIn, UINT nLength);
UINT _WCSTOMBS( CHAR * pszOut, WCHAR * wszIn, UINT nLength);
UINT _WCSLEN( WCHAR * pwszIn );


UINT GetStringW( BYTE * * lplpBuf, LPSTR lpszText, LONG* pdwSize, WORD cLen );
UINT GetStringA( BYTE * * lplpBuf, LPSTR lpszText, LONG* pdwSize );
UINT GetPascalStringW( BYTE * * lplpBuf, LPSTR lpszText, WORD wMaxLen, LONG* pdwSize );
UINT GetPascalStringA( BYTE * * lplpBuf, LPSTR lpszText, BYTE bMaxLen, LONG* pdwSize );
UINT GetNameOrOrd( BYTE * * lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize );
UINT GetNameOrOrdU( PUCHAR pRes, ULONG ulId, LPWSTR lpwszStrId, DWORD* pdwId );

BYTE GetDWord( BYTE * * lplpBuf, DWORD* dwValue, LONG* pdwSize );
BYTE GetWord( BYTE * * lplpBuf, WORD* wValue, LONG* pdwSize );
BYTE GetByte( BYTE * * lplpBuf, BYTE* bValue, LONG* pdwSize );


UINT PutStringA( BYTE * * lplpBuf, LPSTR lpszText, LONG* pdwSize );
UINT PutStringW( BYTE * * lplpBuf, LPSTR lpszText, LONG* pdwSize );
UINT PutNameOrOrd( BYTE * * lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize );
UINT PutPascalStringW( BYTE * * lplpBuf, LPSTR lpszText, WORD wLen, LONG* pdwSize );

BYTE PutDWord( BYTE * * lplpBuf, DWORD dwValue, LONG* pdwSize );
BYTE PutWord( BYTE * * lplpBuf, WORD wValue, LONG* pdwSize );
BYTE PutByte( BYTE * * lplpBuf, BYTE bValue, LONG* pdwSize );

UINT SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwRead );

LONG ReadFile(CFile*, UCHAR *, LONG);
UINT CopyFile( CFile* filein, CFile* fileout );

LONG Allign( BYTE * * lplpBuf, LONG* plBufSize, LONG lSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\common\m68k.h ===
//=====================================================================
//
//	Definition for the standard Mac formats
//
//=====================================================================

#define LPNULL 0L

#define MAXLEVELS 					3			// Max number of level in the PE header tree

#define IMAGE_FILE_MACHINE_M68K		0x0268		// Identify the M68K machine signature
#define appleMark                   20

#define CODEPAGE					(DWORD)-1L	// Will assume ansi char set [might be wrong]

#define	MENU_TYPE					4			// Map MENU to menu (4)
#define	DLOG_TYPE					5			// Map DLOG to dialog (5)
#define DITL_TYPE                   17          // Map DITL to 17 since 17 is unused we avoid ID conflicts with DLOG
#define STR_TYPE					6			// Map STR to string table (6)
#define MSG_TYPE					11			// Map STR# and TEXT to message table (11)
#define WIND_TYPE                   18          // Map WIND to 18, unknown type, treated like a STR

#define COORDINATE_FACTOR			0.50		// factor of reduction from mac to windows

#define _APPLE_MARK_                "_APPLE_MARK_"

//=====================================================================
//	Conversion utility 
//=====================================================================

#define MACLONG(x)	BYTE x[4]
#define MACWORD(x)	BYTE x[2]

BYTE * WordToMacWord(WORD w);
BYTE * LongToMacLong(LONG l);
BYTE * LongToMacOffset(LONG l);
BYTE * WinValToMacVal(WORD w);

LONG __inline MacLongToLong(BYTE * p)
{								
    LONG l = 0;						
    BYTE *pl = (BYTE *) &l;		
								
    p += 3;						
    *pl++ = *p--;				
    *pl++ = *p--;				
    *pl++ = *p--;				
    *pl = *p;					
								
    return l;					
}								

LONG __inline MacOffsetToLong(BYTE * p)
{								
    LONG l = 0;						
    BYTE *pl = (BYTE *) &l;		
								
    p += 2;						
    
	*pl++ = *p--;				
	*pl++ = *p--;				
    *pl = *p;					
								
    return l;
}								

WORD __inline MacWordToWord(BYTE * p)
{								
    WORD w = 0;						
    BYTE *pw = (BYTE *) &w;		
								
    p += 1;						
    *pw++ = *p--;				
    *pw = *p;					
								
    return w;
}								

WORD __inline MacValToWinVal(BYTE * p)
{
	return (WORD)(MacWordToWord(p)*COORDINATE_FACTOR);
}

DWORD __inline MemCopy( LPVOID lpTgt, LPVOID lpSrc, DWORD dwSize, DWORD dwMaxTgt)
{
    if(!dwSize)      // If the user is asking us to copy 0 then 
        return 1;   // do nothing but return 1 so the return test will be succesfull

    if(dwMaxTgt>=dwSize) {
        memcpy(lpTgt, lpSrc, dwSize);
        lpTgt = (BYTE*)lpTgt+dwSize;
        return dwSize;
    }
    return 0;
}


typedef BYTE * * LPLPBYTE;

typedef struct tagMacResHeader
{
    MACLONG(mulOffsetToResData);
	MACLONG(mulOffsetToResMap);
	MACLONG(mulSizeOfResData);
	MACLONG(mulSizeOfResMap);
} MACRESHEADER, *PMACRESHEADER;

typedef struct tagMacResMap
{
    BYTE	reserved[16+4+2];
	MACWORD(mwResFileAttribute);
	MACWORD(mwOffsetToTypeList);
	MACWORD(mwOffsetToNameList);
} MACRESMAP, *PMACRESMAP;

typedef struct tagMacResTypeList
{
    BYTE	szResName[4];
	MACWORD(mwNumOfThisType);
	MACWORD(mwOffsetToRefList);
} MACRESTYPELIST, *PMACRESTYPELIST;

typedef struct tagMacResRefList
{
    MACWORD(mwResID);
	MACWORD(mwOffsetToResName);
	BYTE	bResAttribute;
	BYTE	bOffsetToResData[3];
	MACLONG(reserved);
} MACRESREFLIST, *PMACRESREFLIST;


typedef struct tagMacToWindowsMap
{
    WORD	wType;
	char 	szTypeName[5];
	WORD	wResID;
	char 	szResName[256];
	DWORD	dwOffsetToData;
	DWORD	dwSizeOfData;
} MACTOWINDOWSMAP, *PMACTOWINDOWSMAP;

typedef struct tagUpdResList
{
    WORD *  pTypeId;
    BYTE *  pTypeName;
    WORD *  pResId;
    BYTE *  pResName;
    DWORD * pLang;
    DWORD * pSize;
    struct tagUpdResList* pNext;
} UPDATEDRESLIST, *PUPDATEDRESLIST;

//=============================================================================
//=============================================================================
//
// Dialog structures
//
//=============================================================================
//=============================================================================

typedef struct tagMacWDLG
{
	MACLONG(dwStyle);
	MACLONG(dwExtStyle);
	MACWORD(wNumOfElem);
	MACWORD(wX);
	MACWORD(wY);
	MACWORD(wcX);
	MACWORD(wcY);
	// more
} MACWDLG, *PMACWDLG;

typedef struct tagMacWDLGI
{
	MACLONG(dwStyle);
	MACLONG(dwExtStyle);
	MACWORD(wX);
	MACWORD(wY);
	MACWORD(wcX);
	MACWORD(wcY);
	MACWORD(wID);
	// more
} MACWDLGI, *PMACWDLGI;

typedef struct tagMacDLOG
{
	MACWORD(wTop);
	MACWORD(wLeft);
	MACWORD(wBottom);
	MACWORD(wRight);
	MACWORD(wProcID);
	BYTE bVisibile;
	BYTE ignored1;
	BYTE bGoAway;
	BYTE ignored2;
	MACLONG(lRefCon);
	MACWORD(wRefIdOfDITL);
	BYTE bLenOfTitle;
	//BYTE Title[];
} MACDLOG, *PMACDLOG;

typedef struct tagMacALRT
{
	MACWORD(wTop);
	MACWORD(wLeft);
	MACWORD(wBottom);
	MACWORD(wRight);
	MACWORD(wRefIdOfDITL);
	MACLONG(lStage);
} MACALRT, *PMACALRT;

typedef struct tagMacDIT
{
	MACLONG(lPointer);
	MACWORD(wTop);
	MACWORD(wLeft);
	MACWORD(wBottom);
	MACWORD(wRight);
	BYTE bType;
	BYTE bSizeOfDataType;
} MACDIT, *PMACDIT;

typedef struct tagMacWIND
{
    MACWORD(wTop);
	MACWORD(wLeft);
	MACWORD(wBottom);
	MACWORD(wRight);
	MACWORD(wProcId);
    BYTE bVisibile;
	BYTE ignored1;
	BYTE bGoAway;
	BYTE ignored2;
	MACLONG(lRefCon);
    BYTE bLenOfTitle;
	//BYTE Title[];
} MACWIND, *PMACWIND;

//=============================================================================
//=============================================================================
//
// Menu structures
//
//=============================================================================
//=============================================================================

typedef struct tagMacMenu
{
	MACWORD(wId);
	MACWORD(wWidth);
	MACWORD(wHeigth);
	MACWORD(wDefProcId);
    MACWORD(wReserved);     // must be 0
    MACLONG(lEnableFlags);
	BYTE bSizeOfTitle;
} MACMENU, *PMACMENU;

typedef struct tagMacMenuItem
{
    //BYTE bSizeOfText;
    // text
	BYTE   bIconId;
    BYTE   bKeyCodeId;
    BYTE   bKeyCodeMark;
    BYTE   bCharStyle;
} MACMENUITEM, *PMACMENUITEM;

//=============================================================================
//=============================================================================
//
// PE Header parsing functions
//
//=============================================================================
//=============================================================================

UINT FindMacResourceSection( CFile*, BYTE **, PIMAGE_SECTION_HEADER*, int *);
UINT ParseResourceFile( BYTE * pResFile, PIMAGE_SECTION_HEADER, BYTE **, LONG *, int );
BOOL IsMacResFile ( CFile * pFile );

//=============================================================================
//=============================================================================
//
// Parsing functions
//
//=============================================================================
//=============================================================================

UINT ParseSTR( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseTEXT( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseSTRNUM( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

UINT ParseDLOG( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseALRT( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseWDLG( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseWIND( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

UINT ParseWMNU( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseMENU( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseMBAR( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

//=============================================================================
// Used by ParseDLOG and ParseALRT to find the DITL
DWORD FindMacResource( LPSTR pfilename, LPSTR lpType, LPSTR pName );
DWORD FindResourceInResFile( BYTE * pResFile, PIMAGE_SECTION_HEADER pResSection, LPSTR pResType, LPSTR pResName);

UINT ParseDITL( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

//=============================================================================
//=============================================================================
//
// Updating functions
//
//=============================================================================
//=============================================================================
UINT UpdateMENU( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);

UINT UpdateSTR( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateSTRNUM( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);

UINT UpdateDLOG( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateALRT( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateDITL( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateWDLG( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateWIND( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);

//=============================================================================
//=============================================================================
//
// General helper functions
//
//=============================================================================
//=============================================================================

WORD GetMacWString( WORD **, char *, int );
WORD PutMacWString( WORD *, char *, int );
PUPDATEDRESLIST IsResUpdated( BYTE*, MACRESREFLIST, PUPDATEDRESLIST);
PUPDATEDRESLIST UpdatedResList( LPVOID, UINT );

//=============================================================================
//=============================================================================
//
// Mac to ANSI and back conversion
//
//=============================================================================
//=============================================================================

LPCSTR MacCpToAnsiCp(LPCSTR str);
LPCSTR AnsiCpToMacCp(LPCSTR str);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rsrc\rsrc.cpp ===
////    RSRC - Win32 command line resource manager
//
//      Copyright (c) 1996-9, Microsoft Corporation. All rights reserved.
//
//      David C Brown  [dbrown]  29th October 1998.





/////   RSRC Command line
//
//c     RSRC Executable [-l LocLang] [-u UnlocLang] [-i Types] [-q]
//c          [   [-t|-d] TextOutput [-c UnlocExecutable]
//c            | [-a|-r] text-input [-s symbols] [-v]    ]
//
//p     Executable: Win32 binary to analyse (default), to generate tokens (-t)
//          or dump (-d) from, or containing resources to be replaced (-r)
//          or appended to (-a).
//
//p     -l LocLang: Restrict processing to the specified localized language. LangId
//          should be specified as a full hex NLS Language id, for example use
//          '-l 409' for US English. Required for replace (-r) operation.
//
//p     -u UnlocLang: Specifies unlocalized language, defaults to 409 (US English).
//
//p     -i Types: Restrict processing to listed types. Each type is indicated by a letter
//          as below:
//
//t         Letter | Type      |    Letter | Type             |   Letter | Type
//t         ------ | ----      |    ------ | ----             |   ------ | ----
//t            c   | Cursors   |      g    | Message tables   |      n   | INFs
//t            b   | Bitmaps   |      v    | Version info     |      h   | HTML
//t            i   | Icons     |      a    | Accelerators     |      x   | Binary data
//t            m   | Menus     |      f    | Font directories |          |
//t            d   | Dialogs   |      t    | Fonts            |      o   | All others
//t            s   | Strings   |      r    | RCDATA           |      a   | All (default)
//
//
//p     -q: Quiet. By default Rsrc displays summary statistics of types and languages
//          of resources processed. -q suppresses all output except warning and error messages.
//
//p     -t TextOutput: Generate tokens in checkin format.
//
//p     -d TextOutput: Dump resources in Hex & ASCII format.
//
//p     -c UnlocExecutable: Compare with unlocalized (English) resources - localised
//          resources in executable are compared with English resources in
//          UnlocExecutable. When the localised resource is bit for bit identical
//          with the English resource RSRC writes a one line unloc
//          token instead of the full resource. Valid only with tokenise (-t)
//          option.
//
//p     -a TextInput: Append resources from text input file. Every resource in the
//          text file is added to the executable. Resources already in the executable
//          are not removed. When a resource from the token file has the same type, id
//          and language as one in the executable, the executable resource is replaced
//          by the token resource.
//
//p     -r TextInput: Replace English resources in executable by localised resources
//          from text file. Requires -l parameter to specify localisation language.
//          When a resource from the token file has the same type and id as one in the
//          executable, and the executable resource is US English (409) and the localised
//          resource is in the language specified on the -l parameter, the US English
//          resource is removed.
//
//p     -s Symbols: Symbol file (.dbg format). When RSRC updates the header checksum
//          in executable, it will also do so in the named symbol file. Valid only
//          with the replace (-r) and append (-a) options.
//
//
//      Miscellaneous options
//
//p     -v: Update file and product version. By default any file and product version
//          in the token file is ignored during update/append, the file and product
//          versions from the original unlocalised resources are retained.
//






/////   Definitions
//
//p     Resource key: The combination of resource type, resource id and
//          resource language. The resource key uniquely identifies the
//          resource. A Win32 executable can contain any combination of
//          languages, ids and types so long as no two resources have the
//          same type, key and language.
//
//p     Resource type: A numeric or string value. Some numeric values are
//          predefined, for example menus and dialogs, but apps can and
//          do use any value they choose.
//
//p     Resource id: A numeric or string value. Used by an application to
//          identify the resource when calling FindResource, LoadString etc.
//
//p     Resource language: An NLS LANGID, i.e. a combination of primary and
//          sub-language, such as 0409 (US English).
//
//p     Unloc token: A line in the token file specifying a localised resource
//          key followed by '=lang,cksum' where lang is the unlocalised
//          language (usually 0409) and cksum is the checksum of the unlocalised
//          resource. Used when the only difference between the localised and
//          unlocalised resource is the language in the resource key.





/////   Use during localisation checkin process
//
//c     RSRC LocalisedExecutable -c UnlocExecutable -t Tokens -l LocLang [-u UnlocLang]
//
//      Extracts localized tokens for the specified langauge.
//
//      Where a resource in the localised executable is bit for bit identical
//      to a resource in the unlocalized executable, the resource content is not
//      written to the token file. In its place RSRC writes an unloc token
//      giving the checksum of the resource and specifying the target language.
//
//      Warnings are generated if the localised executable contains resources
//      in languages other than that specified by the -l parameter.
//
//      Unlocalised resources for comparison are looked up in the unlocalised
//      executable in the language specified on the -u parameter, default 409
//      (US ENglish).






/////   Use during the build to update a single language executable
//
//c     RSRC Executable [-u UnlocLang] -r Tokens -l LocLang -s SymbolFile
//
//      Each localised resource in the token file is added to the executable.
//
//      Each corresponding unlocalized resource is removed from the executable.
//
//      For each unloc token the unlocalized resource is found in the executable
//      and its language is updated to the target localized language recorded
//      in the unloc token.
//
//      Tokens of other than the specified localised language are not
//      processed, but generate warnings.
//
//      Warnings are generated for any resources not appearing in both the
//      executable and token files.
//
//      Warnings are also generated for resources of other than the unlocalised
//      language found in the original executable, and resources of other than
//      the localised language in the token file.
//
//      The unlocalised language defaults to 409 (US English).




/////   Use during the build to add resources to a multi-language executable
//
//c     RSRC Executable [-u UnlocLang] -a Tokens [-l Language] -s SymbolFile
//
//      Localised resources from the token file are added to the executable.
//
//      For each unloc token the unlocalised resource is found in the executable
//      and copied for the localised language recorded in the unloc token.
//
//      If '-l Languge' is specified, only tokens of that language are added.
//      When used with the append (-a) option, '-l Language' applies only to
//      the token file: pre-existing resources in the executable are not affected.
//
//      If a resource from the token file matches a resource already in the
//      executable in type, name and language, the executable resource
//      is replaced.
//
//      Warnings are generated if any token in the executable is replaced, or
//      if the unlocalised resource corresponding to an unloc token is missing
//      or has a checksum which differs from the unlocalised resource that was
//      passed on the '-u' parameter when the toke file was created.
//
//      If the '-l Language' option is used, warnings are generated for any
//      resources of other languages found in the token file.





/////   Token format - resource key and header
//
//      A resource may be represented by one or more lines. When
//      a resource is spread over more than one line, all lines except the
//      first are indented by three spaces.
//
//      The first line of every resource starts with the resource key as follows:
//
//      type,id,language;
//
//      This is followed by the codepage recorded in the resource directory.
//      Note that the codepage is not part of the resource key, and is not
//      maintained consistently by all software. In particular:
//
//      o RC writes the codepage as zero
//      o The NT UpdateResource API writes the codepage as 1252
//      o Locstudio writes a codepage that corresponds to the resource language
//
//      Winnt.h documents the codepage as follows:
//
//      "Each resource data entry ... contains ... a CodePage that should be
//      used when decoding code point values within the resource data.
//      Typically for new applications the code page would be the unicode
//      code page.'
//
//      In practise I have never seen the codepage value set to Unicode (1200).
//
//      If the '-c' (unlocalised comparison) parameter was provided on the
//      rsrc command, and there was an unlocalised resource with the same type
//      and id, the language and checksum of that unlocalised resource are
//      appended.
//
//      Finally, the resource data is represented in one of the forms below,
//      or as 'unloc' if the resource data exactly matches the unlocalised resource
//      found in the file passed by 'c'.
//
//
//      There are thus three possible token key/header formats as follows:
//
//c     type,id,language;codepage;resource-data
//
//      Resource recorded in full, either no '-c' parameter specified, or
//      resource does not exist in unlocalised file.
//
//
//c     type,id,language;codepage,unlocalised-checksum,language;resource-data
//
//      Resource recorded in full, '-c' parameter was specified, and localised
//      resource image differed from unlocalised resource image.
//
//
//c     type,id,language;codepage,unlocalised-checksum,language;'Unloc'
//
//      Resource recorded in full, '-c' parameter was specified, and localised
//      resource image was identical to unlocalised resource image.








/////   Token samples - default hex format
//
//
//      For most resource types, RSRC generates resources
//      as a string of hex digits.
//
//      For example, the following represents an accelerator resource.
//
//c     0009,0002,0409;00000000;Hex;00000020:030074008e00000003002e00840000000b0044008400000087002e0084000000
//
//      o Type 0x0009 (Accelerator)
//      o Id   0x0002
//      o Language 0x0409 (LANG_ENGLISH, SUBLANG_US)
//      o Codepage 0 (implies resource was probably generated by RC)
//      o Length in bytes 0x0020
//
//      The resource is short, so its hex representation follows the length.
//
//
//      A larger binary resource is represented on multiple lines as follows:
//
//c     000a,4000,0409;00000000;Hex;0000016a
//c        00000000:0000640100004c0000000114020000000000c000000000000046830000003508000050130852c8e0bd0170493f38ace1bd016044d085c9e0bd01003000000000000001000000000000000000000000000000590014001f0fe04fd020ea3a6910a2d808002b30309d190023563a5c000000000000000000000000000000000065
//c        00000080:7c15003100000000003025a49e308857696e6e74000015003100000000002f25d3863508466f6e747300000000490000001c000000010000001c0000003900000000000000480000001d0000000300000063de7d98100000005f535445504853544550485f00563a5c57494e4e545c466f6e7473000010000000050000a02400
//c        00000100:00004200000060000000030000a05800000000000000737465706800000000000000000000004255867d3048d211b5d8d085029b1cfa4119c94a9f4dd211871f0000000000004255867d3048d211b5d8d085029b1cfa4119c94a9f4dd211871f00000000000000000000
//
//      o Type 0x000a (RCDATA)
//      o Id   0x4000
//      o Language 0x0409 (LANG_ENGLISH, SUBLANG_US)
//      o Codepage 0
//      o Length in bytes 0x016a
//
//      The hex representation is split onto multiple lines each of 128 bytes.






/////   Warnings and errors
//
//
//
//
//
//      o warning RSRC100: Localised resource has no corresponding unlocalised resource in %s
//      o warning RSRC110: Unlocalised resource from token file appended to executable
//      o warning RSRC111: Unlocalised resource from token file replaced unlocalised resource in executable
//      o warning RSRC112: Localised resource from token file replaced localised resource already present in executable
//      o warning RSRC113: Localised resource from token file appended to executable - there was no matching unlocalised resource
//
//      o warning RSRC120: Token file resource does not match specified language - ignored
//      o warning RSRC121: Token file resource is not a requested resource type - ignored
//      o warning RSRC122: executable unlocalised resource checksum does not match checksum recorded in token file for resource %s
//      o warning RSRC124: missing executable unlocalised resource for %s
//      o warning RSRC125: executable contains no unlocalised resource corresponding to resource %s
//
//      o warning RSRC160: Symbol file does not match exectable
//      o warning RSRC161: Symbol file not processed
//      o warning RSRC162: Could not reopen executable %s to update checksum
//      o warning RSRC163: Failed to write updated symbol checksum
//
//      o warning RSRC170: No localizable resources in %s
//      o warning RSRC171: could not close executable
//
//
//      o error   RSRC230: 'Unloc' token is missing unlocalised resource information for %s
//      o error   RSRC231: Failed to apply unloc token
//      o error   RSRC232: Failed to apply token
//
//      o error   RSRC300: Hex digit expected
//      o error   RSRC301: Hex value too large
//      o error   RSRC302: Unexpected end of file
//      o error   RSRC303: \'%s\' expected
//      o error   RSRC304: newline expected
//      o error   RSRC310: Unrecognised resource type for resource %s
//
//      o error   RSRC400: -t (tokenise) option excludes -d, -a, -r, and -s
//      o error   RSRC401: -d (dump) option excludes -t, -u, -a, -r, and -s
//      o error   RSRC402: -a (append) option excludes -t, -d, -u, and -r
//      o error   RSRC403: -r (replace) option excludes -t, -d, -u, and -a
//      o error   RSRC404: -r (replace) option requires -l (LangId)
//      o error   RSRC405: Analysis excludes -s
//
//      o error   RSRC420: Update failed.
//      o error   RSRC421: Token extraction failed.
//      o error   RSRC422: Analysis failed.
//
//      o error   RSRC500: Corrupt executable - resource appears more than once
//      o error   RSRC501: %s is not an executable file
//      o error   RSRC502: %s is not a Win32 executable file
//      o error   RSRC503: No resources in %s
//
//      o error   RSRC510: Cannot open executable file %s
//      o error   RSRC511: cannot find resource directory in %s
//      o error   RSRC512: Cannot create resource token file %s
//      o error   RSRC513: Cannot open unlocalised executable file %s
//      o error   RSRC514: cannot find resource directory in unlocalised executable %s
//      o error   RSRC515: cannot write delta token file %s
//      o error   RSRC516: cannot write stand alone token file %s
//
//      o error   RSRC520: Cannot open resource token file %s
//      o error   RSRC521: UTF8 BOM missing from token file
//
//      o error   RSRC530: Cannot read executable resources from %s
//      o error   RSRC531: Failed reading update tokens
//
//      o error   RSRC600: BeginUpdateResource failed on %s
//      o error   RSRC601: UpdateResourceW failed on %s
//      o error   RSRC602: EndUpdateResourceW failed on %s










////    From Adina
//
//      Here is my follow up on 2.
//
//      Abstract:
//      The build team needs the new tool eventually run with build.exe, i.e.
//      we need build.exe recognize the errors, warnings, and simple output
//      messages from rsrc.exe and write them to build.err, build.wrn and
//      build.log files respectively.
//
//      Solution:
//      All we need is RSRC complain to the general rule for the MS tools.
//      That is (\\orville\razzle\src\sdktools\build\buildexe.c):
//             {toolname} : {number}: {text}
//
//          where:
//
//              toolname    If possible, the container and specific module that has
//                          the error.  For instance, the compiler uses
//                          filename(linenum), the linker uses library(objname), etc.
//                          If unable to provide a container, use the tool name.
//              number      A number, prefixed with some tool identifier (C for
//                          compiler, LNK for linker, LIB for librarian, N for nmake,
//                          etc).
//              test        The descriptive text of the message/error.
//
//              Accepted String formats are:
//              container(module): error/warning NUM ...
//              container(module) : error/warning NUM ...
//              container (module): error/warning NUM ...
//              container (module) : error/warning NUM ...
//
//      Ex. of RSRC error:
//
//      RSRC : error RSRC2001: unable to open file d:\nt\binaries\jpn\ntdll.dll
//
//      Ex. of RSRC warning:
//
//      RSRC : warning RSRC5000: unable to find symbol file
//      d:\nt\binaries\jpn\retail\dll\ntdll.dbg
//
//      Be aware that the error number after "error/warning" is NOT optional.
//      As the format above says, you can also display any information you
//      consider useful (for example the name of the binary being processed,
//      or the line number in the token file that caused the error/warning)
//      immediately after the name of the tool: RSRC(<info>).
//
//      I confirm that RSRC_OK=0, RSRC_WRN=1, RSRC_ERR=2 are fine with us as
//      return values. Also, it does not make any difference if you write the
//      output to stderr ot stdout, but I would suggest to write the tool's
//      usage and all the warning and error message lines to stderr, and any
//      other text to stdout (based on other ms tools we're using, like
//      rebase.exe, binplace.exe, etc).
//
//      I can make the changes to build.exe so that it recognizes RSRC.
//
//      Please let me know if you have any questions.
//
//      Thank you
//      Adina




///     Following meeting Joerg. here are my action items:
//
//      Meet with Joerg, Uwe, Majd, Hideki, Adina to plan usage in bidi NT5
//      build process and consider use for odd jobs in other languages.
//
//      P1. Implement option to skip updating file and product version, and
//          to omit these from token file.
//      P1. Implement separate error code for detecting unhandled binary
//          format (such as win16).
//
//      P2. Add CRC to each resource to detect SLM or editor corruption.
//          (Delete CRC in token file always accepted to allow hand modification).
//      P2. Option to disable header comment in token file
//
//      P3. Interpret MSGTBL, ACCELERATOR and RCDATA - RCDATA as string
//          depending on option.
//
//      Thanks -- Dave.




////    From Joerg
//
//      Howdy,
//      I'm playing with rsrc and ran into problems with ParseToken(): if rsrc
//      is located in a directory with spaces (e.g. Program Files),
//      the function fails to skip the command name, since it's quoted and
//      ParseToken stops at the first blank within the quotes.
//      I also had trouble compiling it (so I can step thru and see what it's
//      doing) under VC5 because there is no default constructor
//      for the class "LangId", so I just added a dummy constructor.
//
//      Jrg




////    Following meeting planning bidi build, Wednesday 2nd Dec.
//
//      Checksum protection against user changes to tok file
//      Include length in warning comparison
//      Will need alpha build
//      Default file name - add .rsrc
//      Don't extract file or product version
//      => If version resource updated use file and product version from
//         US at write time
//      Diagnose version only resources
//      Diagnose not win32
//      Warning for no translations on tokenisation
//      Warning no no translations on update, and don't touch executable
//      Ability to -r any unlocalised language




////    Resultant priorities (8th Dec):
//
//     1.  Use unlocalised file/product version if updating version resource
//     2.  Analyse mode diagnoses no localisable resources and unhandled binary formats
//      3.  Warn when no translations, don't touch executable if updating
//     4.  Support -r from any language to any language
//      5.  Allocate error numbers, clarify error messages
//
//      6.  Include length in unloc token
//     7.  Handle quoted installation directory and default filenames
//      8.  Add checksum protection against corruption of token file
//      9.  Option to interpret RCDATA as Unicode string (for kernel)
//      10. Interpret MSGTBL and ACCELERATOR
//      11. Support Win16 binaries
//      12. ? Option to disable token file header






#pragma warning( disable : 4786 )       // map creates some ridiculously long debug identifiers


#include "stdio.h"
#include "windows.h"
#include "imagehlp.h"
#include "time.h"
#include <map>

using namespace std ;
using namespace std::rel_ops ;



#define DBG 1


////    OK and ASSERT macros
//
//      All functions return an HRESULT.
//      All function calls are wrapped in 'OK()'.
//      OK checks for a failed HRESULT and if so returns that HRESULT directly.
//      Thus all errors propagate back up the call chain.
//
//      MUST issues a message if an HRESULT is not S_OK and returns E_FAIL
//      back up the call chain.


void __cdecl DebugMsg(char *fmt, ...) {

    va_list vargs;

    va_start(vargs, fmt);
    vfprintf(stderr, fmt, vargs);
}



#define MUST(a,b) {HRESULT hr; hr = (a); if (hr!= S_OK) {if (!g_fError) DebugMsg b; g_fError = TRUE; return E_FAIL;};}
#define SHOULD(a,b) {HRESULT hr; hr = (a); if (hr!= S_OK) {DebugMsg b; g_fWarn = TRUE; return S_FALSE;};}


#if DBG

    #pragma message("Checked build")

    #define OK(a) {HRESULT hr; hr = (a); if (hr!= S_OK) {DebugMsg("%s(%d): error RSRC999 : HRESULT not S_OK: "#a"\n", __FILE__, __LINE__); return hr;};}
    #define ASSERT(a) {if (!(a)) {DebugMsg("%s(%d): error RSRC999 : Assertion failed: "#a"\n", __FILE__, __LINE__); return E_UNEXPECTED;};}

#else

    #pragma message ("Free build")

    #define OK(a) {HRESULT hr; hr = (a); if (hr != S_OK) return hr;}
    #define ASSERT(a)  {if (!(a)) {return E_UNEXPECTED;};}

#endif


const int MAXPATH = 128;
const char HexDigit[] = "0123456789abcdef";
const BYTE bZeroPad[] = { 0, 0, 0, 0};

const int MAXHEXLINELEN=128;




const int OPTHELP     = 0x00000001;
const int OPTQUIET    = 0x00000002;
const int OPTEXTRACT  = 0x00000004;
const int OPTUNLOC    = 0x00000008;
const int OPTHEXDUMP  = 0x00000010;
const int OPTAPPEND   = 0x00000020;
const int OPTREPLACE  = 0x00000040;
const int OPTSYMBOLS  = 0x00000080;
const int OPTVERSION  = 0x00000100;


const int PROCESSCUR  = 0x00000001;
const int PROCESSBMP  = 0x00000002;
const int PROCESSICO  = 0x00000004;
const int PROCESSMNU  = 0x00000008;
const int PROCESSDLG  = 0x00000010;
const int PROCESSSTR  = 0x00000020;
const int PROCESSFDR  = 0x00000040;
const int PROCESSFNT  = 0x00000080;
const int PROCESSACC  = 0x00000100;
const int PROCESSRCD  = 0x00000200;
const int PROCESSMSG  = 0x00000400;
const int PROCESSVER  = 0x00000800;
const int PROCESSBIN  = 0x00001000;
const int PROCESSINF  = 0x00002000;
const int PROCESSOTH  = 0x00004000;


const int PROCESSALL  = 0xFFFFFFFF;




DWORD  g_dwOptions     = 0;
DWORD  g_dwProcess     = 0;
LANGID g_LangId        = 0xffff;
BOOL   g_fWarn         = FALSE;
BOOL   g_fError        = FALSE;
LANGID g_liUnlocalized = 0x0409;        // Standard unlocalized language

int    g_cResourcesIgnored    = 0;
int    g_cResourcesUpdated    = 0;      // Simple replacement
int    g_cResourcesTranslated = 0;      // Changed from unloc language to loc language
int    g_cResourcesAppended   = 0;      // Added without affecting existing resources
int    g_cResourcesExtracted  = 0;      // Extracted to token file

char   g_szTypes      [MAXPATH];
char   g_szExecutable [MAXPATH];        // Name of executable being analysed, tokenised or updated
char   g_szResources  [MAXPATH];        // Name of resource token file
char   g_szUnloc      [MAXPATH];        // Name of unlocalized executable for comparison




int HexCharVal(char c) {
    switch (c) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            return c - '0';
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
            return c - 'a' + 10;
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
            return c - 'A' + 10;
    }
    return -1;  // Not a hex value
}





////    Scanner
//
//      A structure for scanning through a block of memory


class Scanner {

protected:

    const BYTE  *m_pStart;
    const BYTE  *m_pRead;
    const BYTE  *m_pLimit;


public:

    Scanner() {m_pStart = NULL; m_pRead = NULL; m_pLimit = NULL;}
    Scanner(const BYTE *pb, DWORD dwLen) {m_pStart = pb; m_pRead = pb; m_pLimit = pb+dwLen;}
    ~Scanner() {m_pStart = NULL; m_pRead = NULL; m_pLimit=NULL;}


    const BYTE* GetRead()  {return m_pRead;}
    const BYTE* GetLimit() {return m_pLimit;}



    HRESULT Advance(UINT cBytes) {
        ASSERT(m_pStart != NULL);
        ASSERT(m_pRead+cBytes <= m_pLimit);
        m_pRead += cBytes;
        return S_OK;
    }

    HRESULT Align(const BYTE *pb, int iAlignment) {
        // Advance until read position is a multiple of iAlignment
        // past pb. iAlignment MUST be a power of 2.
        // Does not advance past limit.


        // Ensure iAlignment is a power of 2
        // This seems like a good test, though I'm not sure I could prove it!
        ASSERT((iAlignment | iAlignment-1) == iAlignment*2 - 1);


        if (m_pRead - pb & iAlignment - 1) {

            m_pRead += (iAlignment - (m_pRead - pb & iAlignment - 1));

            if (m_pRead > m_pLimit) {
                m_pRead = m_pLimit;
            }
        }
        return S_OK;
    }

    HRESULT SetRead(const BYTE *pb) {
        ASSERT(m_pRead != NULL);
        ASSERT(pb >= m_pStart);
        ASSERT(pb <  m_pLimit);
        m_pRead = pb;
        return S_OK;
    }
};






class TextScanner : public Scanner {

protected:

    const BYTE  *m_pLine;           // Start of current line
    int          m_iLine;           // Current line
    char         m_szTextPos[40];

public:

    TextScanner() {m_pLine = NULL; m_iLine = 0; Scanner();}

    virtual char *GetTextPos() {
        sprintf(m_szTextPos,  "%d:%d", m_iLine, m_pRead-m_pLine+1);
        return m_szTextPos;
    }


    ////    ReadString
    //
    //      Translates UTF8 to Unicode
    //      Removes '\' escapes as necessary
    //      Always returns a new zero terminated string

    HRESULT ReadString(WCHAR **ppwcString, int *piLen) {

        char   *pc;
        WCHAR  *pwc;
        int     iLen;


        ASSERT(*((char*)m_pRead) == '\"');
        OK(Advance(1));

        pc   = (char*)m_pRead;
        iLen = 0;


        // Count the number of unicode codepoints represented by the string

        while (    *pc != '\"'
                   &&  pc < (char*)m_pLimit) {

            while (    pc < (char*)m_pLimit
                       &&  *pc != '\\'
                       &&  *pc != '\"'       ) {

                if (*pc < 128) {
                    pc++;
                } else {
                    ASSERT(*pc >= 0xC0);    // 80-BF reserved for trailing bytes
                    if (*pc < 0xE0) {
                        pc+=2;
                    } else if (*pc < 0xF0) {
                        pc+=3;
                    } else {
                        iLen++; // Additional Unicode codepoint required for surrogate
                        pc+=4;
                    }
                    ASSERT(pc <= (char*)m_pLimit);
                }
                iLen++;
            }

            if (*pc == '\\') {
                pc++;
                if (pc < (char*)m_pLimit) {
                    pc++;
                    iLen++;
                }
            }
        }


        // Create a Unicode copy of the string

        *ppwcString = new WCHAR[iLen+1];

        ASSERT(*ppwcString != NULL);

        pwc = *ppwcString;

        while (*((char*)m_pRead) != '\"') {

            while (    *((char*)m_pRead) != '\\'
                       &&  *((char*)m_pRead) != '\"') {

                if (*m_pRead < 0x80) {
                    *pwc++ = *(char*)m_pRead;
                    m_pRead++;
                } else {
                    if (*m_pRead < 0xE0) {
                        *pwc++ =    (WCHAR)(*m_pRead     & 0x1F) << 6
                                    |  (WCHAR)(*(m_pRead+1) & 0x3F);
                        m_pRead+=2;
                    } else if (*m_pRead < 0xF0) {
                        *pwc++ =    (WCHAR)(*m_pRead     & 0x0F) << 12
                                    |  (WCHAR)(*(m_pRead+1) & 0x3F) << 6
                                    |  (WCHAR)(*(m_pRead+2) & 0x3F);
                        m_pRead+=3;
                    } else {
                        *pwc++ =     0xd800
                                     |   ((   (WCHAR)(*m_pRead     & 0x07 << 2)
                                              |  (WCHAR)(*(m_pRead+1) & 0x30 >> 4)) - 1) << 6
                                     |  (WCHAR)(*(m_pRead+1) & 0x0F) << 2
                                     |  (WCHAR)(*(m_pRead+2) & 0x30) >> 4;
                        *pwc++ =     0xdc00
                                     |  (WCHAR)(*(m_pRead+2) & 0x0f) << 6
                                     |  (WCHAR)(*(m_pRead+3) & 0x3f);
                        m_pRead+=4;
                    }
                }
            }

            if (*(char*)m_pRead == '\\') {
                m_pRead++;
                if (m_pRead < m_pLimit) {
                    switch (*(char*)m_pRead) {
                        case 'r':  *pwc++ = '\r';   break;
                        case 'n':  *pwc++ = '\n';   break;
                        case 't':  *pwc++ = '\t';   break;
                        case 'z':  *pwc++ = 0;      break;
                        case 'L':  *pwc++ = 0x2028; break; // Line separator
                        case 'P':  *pwc++ = 0x2029; break; // Paragraph separator
                        default:   *pwc++ = *(char*)m_pRead;
                    }
                    m_pRead++;
                }
            }
        }

        *pwc = 0;       // Add zero terminator
        m_pRead ++;
        *piLen = pwc - *ppwcString;


        ASSERT(m_pRead <= m_pLimit);
        return S_OK;
    }



    ////    ReadHex
    //
    //      Reads all characters up to he first non-hex digit and returns
    //      the value represented by the sequence as a DWORD


    HRESULT ReadHex(DWORD *pdwVal) {
        *pdwVal = 0;

        MUST(HexCharVal(*(char*)m_pRead) >= 0
             ? S_OK : E_FAIL,
             ("%s: error RSRC300: Hex digit expected\n", GetTextPos()));

        while (    HexCharVal(*(char*)m_pRead) >= 0
                   &&  m_pRead < m_pLimit) {

            MUST(*pdwVal < 0x10000000
                 ? S_OK : E_FAIL,
                 ("%s: error RSRC301: Hex value too large\n", GetTextPos()));


            *pdwVal = *pdwVal << 4 | HexCharVal(*(char*)m_pRead);
            OK(Advance(1));
        }
        return S_OK;
    }


    ////    ReadHexByte - Read exactly 2 hex digits

    HRESULT ReadHexByte(BYTE *pb) {
        int n1,n2; // The two nibbles.
        n1 = HexCharVal(*(char*)m_pRead);
        n2 = HexCharVal(*(char*)(m_pRead+1));

        MUST(    n1 >= 0
                 &&  n2 >= 0
                 ? S_OK : E_FAIL,
                 ("%s: error RSRC300: Hex digit expected\n", GetTextPos()));

        *pb = (n1 << 4) + n2;

        MUST(Advance(2),
             ("%s: error RSRC302: Unexpected end of file\n", GetTextPos()));
        return S_OK;
    }



    HRESULT Expect(const char *pc) {
        while (    *pc
                   &&  m_pRead+1 <= m_pLimit) {

            MUST(*(char*)m_pRead == *pc
                 ? S_OK : E_FAIL,
                 ("%s: error RSRC303: \'%s\' expected\n", GetTextPos(), pc));
            m_pRead++;
            pc++;
        }

        MUST(*pc == 0
             ? S_OK : E_FAIL,
             ("%s: error RSRC303: \'%s\' expected\n", GetTextPos(), pc));

        return S_OK;
    }



    ////    SkipLn
    //
    //      Skip to beginning of next non empty, non comment line.


    HRESULT SkipLn() {

        ASSERT(m_pRead != NULL);

        while (m_pRead < m_pLimit) {

            if (*(char*)m_pRead == '\r') {

                m_pRead++;

                if (m_pRead < m_pLimit  &&  *(char*)m_pRead == '\n') {

                    m_pRead++;
                    m_pLine = m_pRead;
                    m_iLine++;

                    if (    m_pRead < m_pLimit
                            &&  *(char*)m_pRead != '#'
                            &&  *(char*)m_pRead != '\r') {

                        break;
                    }
                }

            } else {

                m_pRead++;
            }
        }

        return S_OK;
    }



    ////    ExpectLn
    //
    //      Expect end of line, preceeded by any whitespace
    //
    //      Also skips trailing comments and whole line comments
    //
    //      Any parameter is passed to Expect to vb found at the beginning of the new line


    HRESULT ExpectLn(const char *pc) {

        ASSERT(m_pRead != NULL);

        while (    m_pRead < m_pLimit
                   &&  (    *(char*)m_pRead == ' '
                            ||  *(char*)m_pRead == '\t')) {

            m_pRead++;
        }


        if (    m_pRead < m_pLimit
                &&  (    *(char*)m_pRead == '\r'
                         ||  *(char*)m_pRead == '#')) {

            // Condition satisfied, skip to first non comment line

            SkipLn();

        } else {

            MUST(E_FAIL,("%s: error RSRC304: newline expected\n", GetTextPos()));
        }


        if (pc) {
            return Expect(pc);
        }

        return S_OK;
    }
};






////    Mapped files
//
//      File mapping is used to read executable and token files.
//
//      File mapping is also used to update in place checksum information
//      in executable and symbol files.


class MappedFile : public TextScanner {

    HANDLE  m_hFileMapping;
    BOOL    fRW;             // True when writeable
    char    m_szFileName[MAXPATH];
    char    m_szTextPos[MAXPATH+40];

public:

    MappedFile() {m_hFileMapping = NULL; TextScanner();}


    const BYTE* GetFile()  {return m_pStart;}
    virtual char *GetTextPos() {
        sprintf(m_szTextPos,  "%s(%s)", m_szFileName, TextScanner::GetTextPos());
        return m_szTextPos;
    }


    HRESULT Open(const char *pcFileName, BOOL fWrite) {

        HANDLE hFile;

        m_pStart  = NULL;
        m_pRead   = NULL;
        m_pLimit  = NULL;

        strcpy(m_szFileName, pcFileName);

        hFile = CreateFileA(
                           pcFileName,
                           GENERIC_READ     | (fWrite ? GENERIC_WRITE : 0),
                           FILE_SHARE_READ  | (fWrite ? FILE_SHARE_WRITE | FILE_SHARE_DELETE : 0 ),
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        ASSERT(hFile != INVALID_HANDLE_VALUE);

        m_hFileMapping = CreateFileMapping(
                                          hFile,
                                          NULL,
                                          fWrite ? PAGE_READWRITE : PAGE_WRITECOPY,
                                          0,0, NULL);

        ASSERT(m_hFileMapping != NULL);

        m_pStart = (BYTE*) MapViewOfFile(
                                        m_hFileMapping,
                                        fWrite ? FILE_MAP_WRITE : FILE_MAP_READ,
                                        0,0, 0);

        ASSERT(m_pStart != NULL);

        m_pRead  = m_pStart;
        m_pLine  = m_pStart;
        m_pLimit = m_pStart + GetFileSize(hFile, NULL);
        m_iLine  = 1;
        CloseHandle(hFile);

        fRW = fWrite;
        return S_OK;
    }




    DWORD CalcChecksum() {

        DWORD dwHeaderSum;
        DWORD dwCheckSum;

        if (CheckSumMappedFile((void*)m_pStart, m_pLimit-m_pStart, &dwHeaderSum, &dwCheckSum) == NULL) {
            return 0;
        } else {
            return dwCheckSum;
        }
    }




    HRESULT Close() {
        if (m_pStart) {
            UnmapViewOfFile(m_pStart);
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
            m_pStart = NULL;
        }
        return S_OK;
    }
};






////    NewFile - services for writing a new text otr binary file
//
//


class NewFile {

    HANDLE     hFile;
    DWORD      cbWrite;         // Bytes written
    BYTE       buf[4096];       // Performance buffer
    int        iBufUsed;

public:

    NewFile() {iBufUsed = 0;}

    int   GetWrite() {return cbWrite;}


    HRESULT OpenWrite(char *pcFileName) {

        cbWrite = 0;        // Bytes written

        hFile = CreateFileA(
                           pcFileName,
                           GENERIC_READ | GENERIC_WRITE,
                           0,          // Not shared
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        ASSERT(hFile != INVALID_HANDLE_VALUE);

        return S_OK;
    }




    HRESULT WriteBytes(const BYTE *pb, DWORD dwLen) {

        DWORD dwWritten;

        if (iBufUsed + dwLen <= sizeof(buf)) {

            memcpy(buf+iBufUsed, pb, dwLen);
            iBufUsed += dwLen;

        } else {

            ASSERT(hFile != NULL);

            if (iBufUsed > 0) {
                ASSERT(WriteFile(hFile, buf, iBufUsed, &dwWritten, NULL));
                ASSERT(dwWritten == iBufUsed);
                iBufUsed = 0;
            }

            if (dwLen <= sizeof(buf)) {

                memcpy(buf, pb, dwLen);
                iBufUsed = dwLen;

            } else {

                ASSERT(WriteFile(hFile, pb, dwLen, &dwWritten, NULL));
                ASSERT(dwWritten == dwLen);
            }
        }

        cbWrite += dwLen;

        return S_OK;
    }



    HRESULT WriteS(const char *pc) {
        return WriteBytes((BYTE*)pc, strlen(pc));
    }



    ////    WriteString
    //
    //      Translates Unicode to UTF8
    //      Adds '\' escapes as necessary


    HRESULT WriteString(const WCHAR *pwc, int iLen) {

        BYTE          buf[3];
        const WCHAR  *pwcLimit;

        pwcLimit = pwc + iLen;
        OK(WriteBytes((BYTE*)"\"", 1));
        while (pwc < pwcLimit) {
            switch (*pwc) {
                case 0:       OK(WriteS("\\z"));  break;
                case '\r':    OK(WriteS("\\r"));  break;
                case '\n':    OK(WriteS("\\n"));  break;
                case '\t':    OK(WriteS("\\t"));  break;
                case 0x2028:  OK(WriteS("\\L"));  break;  // Line separator
                case 0x2029:  OK(WriteS("\\P"));  break;  // Paragraph separator
                case '\"':    OK(WriteS("\\\"")); break;
                case '\\':    OK(WriteS("\\\\")); break;
                default:
                    if (*pwc < 128) {
                        OK(WriteBytes((BYTE*)pwc, 1));
                    } else if (*pwc < 0x7FF) {
                        buf[0] = 0xC0 | *pwc >> 6;
                        buf[1] = 0x80 | *pwc & 0x3F;
                        OK(WriteBytes(buf, 2));
                    } else {
                        // Note - should code surrogates properly, this doesn't
                        buf[0] = 0xE0 | *pwc>>12 & 0x0F;
                        buf[1] = 0x80 | *pwc>>6  & 0x3F;
                        buf[2] = 0x80 | *pwc     & 0x3F;
                        OK(WriteBytes(buf, 3));
                    }
            }
            pwc++;
        }
        OK(WriteBytes((BYTE*)"\"", 1));
        return S_OK;
    }



    ////    WriteHex
    //
    //      Writes the given value in the given number of digits.
    //
    //      If cDigits is zero, uses as many as necessary.



    HRESULT WriteHex(DWORD dw, int cDigits) {
        int    i;
        char   cBuf[8];

        i = 7;

        while (dw  &&  i >= 0) {
            cBuf[i] = HexDigit[dw & 0xf];
            dw >>= 4;
            i--;
        }

        if (cDigits != 0) {
            while (i >= (8-cDigits)) {
                cBuf[i] = '0';
                i--;
            }
        }

        OK(WriteBytes((BYTE*)(cBuf+i+1), 7-i));

        return S_OK;
    }



    ////    WriteHexBuffer
    //
    //      Writes a buffer of up to 256 bytes as a continuous stream of hex digits



    HRESULT WriteHexBuffer(const BYTE *pb, DWORD dwLength) {
        DWORD  i;
        char   cBuf[512];

        ASSERT(hFile);
        ASSERT(dwLength <= 256);

        for (i=0; i<dwLength; i++) {
            cBuf[2*i]   = HexDigit[*pb >> 4 & 0xf];
            cBuf[2*i+1] = HexDigit[*pb & 0xf];
            pb++;
        }

        OK(WriteBytes((BYTE*)cBuf, 2*dwLength));
        cbWrite += 2*dwLength;

        return S_OK;
    }



    ////    WriteLn
    //
    //      Write end of line mark (CR,LF)

    HRESULT WriteLn() {
        return WriteS("\r\n");
    }


    HRESULT Close() {
        DWORD dwWritten;
        if (hFile) {
            if (iBufUsed > 0) {
                ASSERT(WriteFile(hFile, buf, iBufUsed, &dwWritten, NULL));
                ASSERT(dwWritten == iBufUsed);
            }
            CloseHandle(hFile);
            hFile = NULL;
        }
        return S_OK;
    }
};






////    Resource structures
//
//      Each resource structure has an internal representation for the
//      resource that may be read and written to/from both text and
//      executable files.
//
//      The ReadTok and WriteTok functions handle formatting and parsing
//      of the token file.
//
//      The ReadBin function unpacks a resource from a memory mapped
//      executable into the internal representation.
//
//      The cbBin function returns the unpadded length required for the
//      item in executable (packed) format.
//
//      The CopyBin function packs the internal representation into a
//      target buffer.


class Resource {
public:
    virtual HRESULT ReadTok  (TextScanner &mfText)                    = 0;
    virtual HRESULT ReadBin  (Scanner     &mfBin, DWORD dwLen)        = 0;

    virtual HRESULT WriteTok (NewFile     &nfText)              const = 0;
    virtual size_t  cbBin    ()                                 const = 0;
    virtual HRESULT CopyBin  (BYTE       **ppb)                 const = 0;

    // For statistics

    virtual int     GetItems ()                                 const = 0;
    virtual int     GetWords ()                                 const = 0;
};






////    ResourceBYTE
//
//      BYTE value represented in hex digits.


class ResourceBYTE {


public:

    BYTE b;

    HRESULT ReadBin(Scanner *pmf) {
        b = *((BYTE*)(pmf->GetRead()));
        OK(pmf->Advance(sizeof(BYTE)));
        return S_OK;
    }

    size_t cbBin() const {
        return 1;
    }

    HRESULT CopyBin(BYTE **ppb) const {
        **ppb = b;
        (*ppb)++;
        return S_OK;
    }

    HRESULT ReadTok(TextScanner *pmf) {
        DWORD dw;
        OK(pmf->ReadHex(&dw));
        ASSERT(dw < 0x100);
        b = (BYTE)dw;
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        OK(pmf->WriteHex(b, 2));
        return S_OK;
    }
};






////    ResoureWORD
//
//      WORD value represented in hex digits.


class ResourceWORD {

public:

    WORD  w;

    HRESULT ReadBin(Scanner *pmf) {
        w = *((WORD*)(pmf->GetRead()));
        OK(pmf->Advance(sizeof(WORD)));
        return S_OK;
    }

    size_t cbBin() const {
        return sizeof(WORD);
    }

    HRESULT CopyBin(BYTE **ppb) const {
        *(WORD*)*ppb = w;
        *ppb += sizeof(WORD);
        return S_OK;
    }

    HRESULT ReadTok(TextScanner *pmf) {
        DWORD dw;
        OK(pmf->ReadHex(&dw));
        ASSERT(dw < 0x10000);
        w = (WORD)dw;
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf)  const {
        OK(pmf->WriteHex(w, 4));
        return S_OK;
    }
};






////    ResourceDWORD
//
//      DWORD value represented in hex digits.


class ResourceDWORD {

public:

    DWORD dw;

    HRESULT ReadBin(Scanner *pmf) {
        dw = *((DWORD*)(pmf->GetRead()));
        OK(pmf->Advance(sizeof(DWORD)));
        return S_OK;
    }

    size_t cbBin() const {
        return sizeof(DWORD);
    }

    HRESULT CopyBin(BYTE **ppb) const {
        *(DWORD*)*ppb = dw;
        *ppb += sizeof(DWORD);
        return S_OK;
    }

    HRESULT ReadTok(TextScanner *pmf) {
        OK(pmf->ReadHex(&dw));
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        OK(pmf->WriteHex(dw, 8));
        return S_OK;
    }
};






////    ResourceString
//
//      String displayed with quotes. May be zero terminated or length
//      word.


const WCHAR wcZero = 0;

class ResourceString {

    WCHAR *pwcString;
    WORD   iLen;

    void rsFree() {
        if (pwcString)
            delete [] pwcString;
        pwcString = NULL;
        iLen = 0;
    }

public:

    ResourceString() {pwcString = NULL; iLen = 0;}
    ~ResourceString() {rsFree();}

    ResourceString& operator= (const ResourceString &rs) {
        iLen      = rs.iLen;
        pwcString = new WCHAR[iLen+1];
        memcpy(pwcString, rs.pwcString, 2*(iLen+1));
        return *this;
    }

    ResourceString(const ResourceString &rs) {
        *this = rs;
    }


    const WCHAR *GetString() const {return pwcString;}
    const int    GetLength() const {return iLen;};
    void         SetEmpty ()       {iLen = 0;  pwcString = NULL;}

    HRESULT ReadBinL(Scanner *pmf) {
        rsFree();

        iLen = *((WORD*)(pmf->GetRead()));
        OK(pmf->Advance(sizeof(WORD)));

        pwcString = new WCHAR[iLen+1];
        ASSERT(pwcString != NULL);
        memcpy(pwcString, (WCHAR*)pmf->GetRead(), 2*iLen);
        pwcString[iLen] = 0;

        OK(pmf->Advance(iLen * sizeof(WCHAR)));
        return S_OK;
    }

    size_t cbBinL() const {
        return iLen * sizeof(WCHAR) + sizeof(WORD);
    }

    HRESULT CopyBinL(BYTE **ppb) const {
        *(WORD*)*ppb = iLen;
        *ppb += sizeof(WORD);
        memcpy(*ppb, pwcString, sizeof(WCHAR)*iLen);
        *ppb += sizeof(WCHAR)*iLen;
        return S_OK;
    }


    // Zero terminated

    HRESULT ReadBinZ(Scanner *pmf) {

        const WCHAR* pwc;
        rsFree();

        pwc = (WCHAR*)pmf->GetRead();
        while (*(WCHAR*)pmf->GetRead() != 0) {
            OK(pmf->Advance(2));
        }

        iLen = (WCHAR*)pmf->GetRead() - pwc;
        OK(pmf->Advance(2));


        pwcString = new WCHAR[iLen+1];
        ASSERT(pwcString != NULL);
        memcpy(pwcString, pwc, 2*(iLen+1));

        return S_OK;
    }

    size_t cbBinZ() const {
        return (iLen+1) * sizeof(WCHAR);
    }


    // Known length (dwLen excludes zero terminator)

    HRESULT ReadBin(Scanner *pmf, DWORD dwLen) {

        rsFree();
        iLen = dwLen;

        pwcString = new WCHAR[dwLen+1];
        ASSERT(pwcString != NULL);
        memcpy(pwcString, pmf->GetRead(), 2*dwLen);
        pwcString[dwLen] = 0;
        OK(pmf->Advance(2*dwLen));

        return S_OK;
    }

    size_t cbBin() const {
        return iLen * sizeof(WCHAR);
    }

    HRESULT CopyBinZ(BYTE **ppb) const {
        memcpy(*ppb, pwcString, sizeof(WCHAR)*iLen);
        *ppb += sizeof(WCHAR)*iLen;
        *(WCHAR*)*ppb = 0;
        *ppb += sizeof(WCHAR);
        return S_OK;
    }

    HRESULT ReadTok(TextScanner *pmf) {
        int l;
        rsFree();
        OK(pmf->ReadString(&pwcString, &l));
        ASSERT(l < 0x10000  &&  l >= 0);
        iLen = (WORD) l;
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        OK(pmf->WriteString(pwcString, iLen));
        return S_OK;
    }

    int GetWords() const {

        int i;
        int wc;

        i  = 0;
        wc = 0;

        while (i<iLen) {

            while (    i < iLen
                       &&  pwcString[i] <= ' ') {
                i++;
            }

            if (i<iLen) {
                wc++;
            }

            while (    i < iLen
                       &&  pwcString[i] > ' ') {
                i++;
            }
        }

        return wc;
    }
};






////    ResourceVariant
//
//      A widely used alternative of either a Unicode string or a WORD value.


class ResourceVariant {

    ResourceString  *prs;
    ResourceWORD     rw;
    BOOL             fString;

    void rvFree() {
        if (fString && prs)
            delete prs;
        prs = NULL;
        fString=FALSE;
    }

public:

    ResourceVariant() {fString=FALSE; prs=NULL;}
    ~ResourceVariant() {rvFree();}

    // Copy and assignment constructors required as this is used as the key in an STL map

    ResourceVariant& operator= (const ResourceVariant &rv) {
        fString = rv.fString;
        if (fString) {
            prs = new ResourceString(*rv.prs);
        } else {
            prs = NULL;
            rw = rv.rw;
        }
        return *this;
    }

    ResourceVariant(const ResourceVariant &rv) {
        *this = rv;
    }


    void fprint(FILE *fh) const {
        if (fString) {
            fprintf(fh, "%S", prs->GetString());
        } else {
            fprintf(fh, "%x", rw.w);
        }
    }


    const BOOL   GetfString() const {return fString;}
    const WORD   GetW()       const {return rw.w;}
    void         SetW(WORD w)       {if (fString) {delete prs; fString = FALSE;}rw.w = w;}
    const WCHAR *GetString()  const {return prs->GetString();}
    const int    GetLength()  const {return prs->GetLength();}
    const int    GetWords()   const {return fString ? prs->GetWords() : 0;}


    HRESULT ReadBinFFFFZ(Scanner *pmf) {
        rvFree();
        fString = *(WORD*)pmf->GetRead() != 0xffff;
        if (fString) {
            prs = new ResourceString;
            OK(prs->ReadBinZ(pmf));
        } else {
            OK(pmf->Advance(sizeof(WORD)));
            OK(rw.ReadBin(pmf));
        }
        return S_OK;
    }

    size_t cbBinFFFFZ() const {
        return fString ? prs->cbBinZ() : rw.cbBin() + sizeof(WORD);
    }

    HRESULT CopyBinFFFFZ(BYTE **ppb) const {
        if (fString) {
            return prs->CopyBinZ(ppb);
        } else {
            *(WORD*)*ppb = 0xFFFF;  // Mark as value
            (*ppb) += sizeof(WORD);
            return rw.CopyBin(ppb);
        }
    }

    HRESULT ReadBinFFFFL(Scanner *pmf) {
        rvFree();
        fString = *(WORD*)pmf->GetRead() != 0xffff;
        if (fString) {
            prs = new ResourceString;
            OK(prs->ReadBinL(pmf));
        } else {
            OK(pmf->Advance(sizeof(WORD)));
            OK(rw.ReadBin(pmf));
        }
        return S_OK;
    }

    size_t cbBinFFFFL() const {
        return fString ? prs->cbBinL() : rw.cbBin() + sizeof(WORD);
    }

    HRESULT CopyBinFFFFL(BYTE **ppb) const {
        if (fString) {
            return prs->CopyBinL(ppb);
        } else {
            *(WORD*)*ppb = 0xFFFF;  // Mark as value
            (*ppb) += sizeof(WORD);
            return rw.CopyBin(ppb);
        }
    }

    HRESULT ReadTok(TextScanner *pmf) {
        rvFree();
        fString = *(char*)pmf->GetRead() == '\"';
        if (fString) {
            prs = new ResourceString;
            OK(prs->ReadTok(pmf));
        } else {
            OK(rw.ReadTok(pmf));
        }
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        if (fString) {
            OK(prs->WriteTok(pmf));
        } else {
            OK(rw.WriteTok(pmf));
        }
        return S_OK;
    }

    HRESULT ReadWin32ResDirEntry(
                                Scanner                        *pmf,
                                const BYTE                     *pRsrc,
                                IMAGE_RESOURCE_DIRECTORY_ENTRY *pirde) {

        rvFree();
        fString = pirde->NameIsString;

        if (fString) {
            prs = new ResourceString;
            OK(pmf->SetRead(pRsrc + pirde->NameOffset));
            OK(prs->ReadBinL(pmf));
        } else {
            OK(pmf->SetRead((BYTE*)&pirde->Id));
            OK(rw.ReadBin(pmf));
        }
        return S_OK;
    }

    bool operator< (const ResourceVariant &rv) const {

        int l,c;

        if (fString != rv.GetfString()) {

            return !fString;            // Numerics before strings

        } else if (!fString) {

            return rw.w < rv.GetW();

        } else {

            l = prs->GetLength();
            if (l > rv.GetLength()) {
                l = rv.GetLength();
            }

            c = wcsncmp(prs->GetString(), rv.GetString(), l);

            if (c==0) {
                return prs->GetLength() < rv.GetLength();
            } else {
                return c < 0;
            }
        }

        return FALSE;   // Equal at all depths
    }
};






////    ResourceKey
//
//      The resource key is the unique identifier of a resource, containing
//      a resource type, a programmer defined unique id for the resource, and
//      a language identifier.


class ResourceKey {

public:

    int              iDepth;
    ResourceVariant *prvId[3];

    ResourceKey() {iDepth=0;}

    ResourceKey& operator= (const ResourceKey &rk) {
        int i;
        iDepth = rk.iDepth;
        for (i=0; i<iDepth; i++) {
            prvId[i] = new ResourceVariant(*rk.prvId[i]);
        }
        return *this;
    }

    ResourceKey(const ResourceKey& rk) {
        *this = rk;
    }

    void fprint(FILE *fh) const {

        prvId[0]->fprint(fh);
        fprintf(fh, ",");
        prvId[1]->fprint(fh);
        fprintf(fh, ",");
        prvId[2]->fprint(fh);
    }


    LPCWSTR GetResName(int i) const {
        if (i >= iDepth) {
            return (LPCWSTR) 0;
        }
        if (prvId[i]->GetfString()) {
            return prvId[i]->GetString();
        } else {
            return (LPCWSTR)prvId[i]->GetW();
        }
    }


    HRESULT SetLanguage(WORD lid) {

        ASSERT(iDepth == 3);
        ASSERT(prvId[2]->GetfString() == FALSE);
        prvId[2]->SetW(lid);

        return S_OK;
    }


    HRESULT ReadTok(TextScanner *pmf) {
        prvId[0] = new ResourceVariant;
        ASSERT(prvId[0] != NULL);
        OK(prvId[0]->ReadTok(pmf));
        iDepth = 1;
        while (*(char*)pmf->GetRead() == ',') {
            OK(pmf->Advance(1));
            prvId[iDepth] = new ResourceVariant;
            ASSERT(prvId[iDepth] != NULL);
            OK(prvId[iDepth]->ReadTok(pmf));
            iDepth++;
        }
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        int i;
        OK(prvId[0]->WriteTok(pmf));
        for (i=1; i<iDepth; i++) {
            OK(pmf->WriteS(","));
            OK(prvId[i]->WriteTok(pmf));
        }
        return S_OK;
    }

    bool operator< (const ResourceKey &rk) const {
        int i,l,c;

        if (iDepth != rk.iDepth) {
            return iDepth < rk.iDepth;   // Lower depths come first
        } else {
            for (i=0; i<iDepth; i++) {
                if (prvId[i]->GetfString() != rk.prvId[i]->GetfString()) {
                    return prvId[i]->GetfString() ? true : false;   // Strings come before values
                } else {
                    if (prvId[i]->GetfString()) {
                        // Compare strings
                        l = prvId[i]->GetLength();
                        if (l > rk.prvId[i]->GetLength()) {
                            l = rk.prvId[i]->GetLength();
                        }
                        c = wcsncmp(prvId[i]->GetString(), rk.prvId[i]->GetString(), l);
                        if (c == 0) {
                            if (prvId[i]->GetLength() != rk.prvId[i]->GetLength()) {
                                return prvId[i]->GetLength() < rk.prvId[i]->GetLength();
                            }
                        } else {
                            return c < 0;
                        }
                    } else {
                        // Compare numeric values
                        if (prvId[i]->GetW() != rk.prvId[i]->GetW()) {
                            return prvId[i]->GetW() < rk.prvId[i]->GetW();
                        }
                    }

                }
            }
            return FALSE;   // Equal at all depths
        }
    }
};






////    ResourceBinary
//
//      Arbitrary binary resource
//
//      Formatted as lines of hex digits


class ResourceBinary : public Resource {

protected:  // Accessed by ResourceHexDump

    BYTE    *pb;
    DWORD    dwLength;

    void rbFree() {if (pb) {delete[] pb; pb=NULL;}dwLength = 0;}

public:

    ResourceBinary() {pb = NULL; dwLength = 0;}
    ~ResourceBinary() {rbFree();}

    DWORD GetLength() const {return dwLength;}

    HRESULT ReadTok(TextScanner &mfText) {
        DWORD  i;
        DWORD  dwOffset;
        DWORD  dwCheckOffset;

        rbFree();

        OK(mfText.Expect("Hex;"));
        OK(mfText.ReadHex(&dwLength));

        pb = new BYTE[dwLength];
        ASSERT(pb != NULL);

        if (dwLength <= MAXHEXLINELEN) {

            // Hex follows on same line

            OK(mfText.Expect(":"));
            for (i=0; i<dwLength; i++) {
                OK(mfText.ReadHexByte(pb+i));
            }

        } else {

            // Hex follows on subsequent lines

            dwOffset = 0;
            while (dwLength - dwOffset > MAXHEXLINELEN) {
                OK(mfText.ExpectLn("   "));
                OK(mfText.ReadHex(&dwCheckOffset));
                ASSERT(dwOffset == dwCheckOffset);
                OK(mfText.Expect(":"));
                for (i=0; i<MAXHEXLINELEN; i++) {
                    OK(mfText.ReadHexByte(pb+dwOffset+i));
                }
                dwOffset += MAXHEXLINELEN;
            }

            OK(mfText.ExpectLn("   "));
            OK(mfText.ReadHex(&dwCheckOffset));
            ASSERT(dwOffset == dwCheckOffset);
            OK(mfText.Expect(":"));
            for (i=0; i<dwLength - dwOffset; i++) {
                OK(mfText.ReadHexByte(pb+dwOffset+i));
            }
        }

        return S_OK;
    }

    HRESULT ReadBin(Scanner &mfText, DWORD dwLen) {
        rbFree();
        dwLength = dwLen;
        pb = new BYTE[dwLength];
        memcpy(pb, mfText.GetRead(), dwLength);
        OK(mfText.Advance(dwLen));
        return S_OK;
    }

    HRESULT WriteTok(NewFile &nfText) const {

        DWORD dwOffset;


        // Write binary resource in lines of up to 256 bytes

        OK(nfText.WriteS("Hex;"));
        OK(nfText.WriteHex(dwLength, 8));


        if (dwLength <= MAXHEXLINELEN) {

            // Write <= MAXHEXLINELEN bytes on same line

            OK(nfText.WriteS(":"));
            OK(nfText.WriteHexBuffer(pb, dwLength));

        } else {

            // write MAXHEXLINELEN bytes per line on subsequent lines

            dwOffset = 0;
            while (dwLength - dwOffset > MAXHEXLINELEN) {
                OK(nfText.WriteS("\r\n   "));
                OK(nfText.WriteHex(dwOffset, 8));
                OK(nfText.WriteS(":"));
                OK(nfText.WriteHexBuffer(pb+dwOffset, MAXHEXLINELEN));
                dwOffset += MAXHEXLINELEN;
            }

            // Write remaining bytes, if any

            OK(nfText.WriteS("\r\n   "));
            OK(nfText.WriteHex(dwOffset, 8));
            OK(nfText.WriteS(":"));
            OK(nfText.WriteHexBuffer(pb+dwOffset, dwLength - dwOffset));
        }

        return S_OK;
    }


    size_t cbBin() const {
        return dwLength;
    }

    HRESULT CopyBin(BYTE **ppb) const {
        if (dwLength > 0) {
            memcpy(*ppb, pb, dwLength);
            *ppb += dwLength;
        }
        return S_OK;
    }

    int GetItems() const {
        return 0;
    }

    int GetWords() const {
        return 0;
    }


    BOOL CompareBin(const BYTE *pbComp, DWORD dwLen) const {

        if (dwLength != dwLen) return FALSE;
        if (dwLength == 0)     return TRUE;
        if (pb ==pbComp)       return true;

        return !memcmp(pb, pbComp, dwLength);
    }

};




////    ResourceHexDump
//
//      Special version of ResourceBinary for generating a hex dump analysis


class ResourceHexDump : public ResourceBinary {

public:
    HRESULT WriteTok(NewFile &nfText) const {
        DWORD i,j;
        ResourceDWORD rdw;

        OK(nfText.WriteS("Hexdump,"));
        OK(nfText.WriteHex(dwLength, 8));
        OK(nfText.WriteS(":"));
        for (i=0; i<dwLength; i++) {
            if (i % 4 == 0) {
                OK(nfText.WriteS(" "));
            }
            if (i % 8 == 0) {
                OK(nfText.WriteS(" "));
            }
            if (i % 16 == 0) {
                if (i>0) {
                    // Append ASCII interpretation
                    for (j=i-16; j<i; j++) {
                        if (pb[j] > 31) {
                            OK(nfText.WriteBytes(pb+j, 1));
                        } else {
                            OK(nfText.WriteS("."));
                        }
                    }
                }
                OK(nfText.WriteS("\r\n   "));
                rdw.dw = i;   OK(rdw.WriteTok(&nfText));
                OK(nfText.WriteS(": "));
            }
            OK(nfText.WriteHex(pb[i], 2));
            OK(nfText.WriteS(" "));
        }

        // Append ANSI interpretation to last line

        if (dwLength % 16 > 0) {
            for (i = dwLength % 16 ; i < 16; i++) {
                if (i % 4 == 0) {
                    OK(nfText.WriteS(" "));
                }
                if (i % 8 == 0) {
                    OK(nfText.WriteS(" "));
                }
                OK(nfText.WriteS("   "));
            }
        }
        OK(nfText.WriteS("  "));

        for (j=dwLength-1 & 0xfffffff0; j<dwLength; j++) {
            if (pb[j] > 31) {
                OK(nfText.WriteBytes(pb+j, 1));
            } else {
                OK(nfText.WriteS("."));
            }
        }

        OK(nfText.WriteLn());
        return S_OK;
    }
};






////    Menu32
//
//


class MenuItem32 {

    ResourceDWORD   rdwType;
    ResourceDWORD   rdwState;
    ResourceDWORD   rdwId;       // Extended ID
    ResourceWORD    rwId;        // Non-extended ID
    ResourceWORD    rwFlags;
    ResourceDWORD   rdwHelpId;
    ResourceString  rsCaption;

    BOOL            fExtended;

public:

    void SetExtended(BOOL f)        {fExtended = f;}
    int  GetWords()          const  {return rsCaption.GetWords();}

    virtual HRESULT ReadTok(TextScanner &mfText) {

        if (!fExtended) {
            OK(rwFlags.ReadTok(&mfText));  OK(mfText.Expect(","));
            if (!(rwFlags.w & MF_POPUP)) {
                OK(rwId   .ReadTok(&mfText));  OK(mfText.Expect(","));
            }
        } else {
            OK(rdwType  .ReadTok(&mfText));  OK(mfText.Expect(","));
            OK(rdwState .ReadTok(&mfText));  OK(mfText.Expect(","));
            OK(rdwId    .ReadTok(&mfText));  OK(mfText.Expect(","));
            OK(rwFlags  .ReadTok(&mfText));  OK(mfText.Expect(","));
            if (rwFlags.w & 1) {
                OK(rdwHelpId.ReadTok(&mfText));  OK(mfText.Expect(","));
            }
        }

        OK(rsCaption.ReadTok(&mfText));

        return S_OK;
    }



    virtual HRESULT ReadBin(Scanner &mfBin) {

        const BYTE *pb;       // For tracking

        pb = mfBin.GetRead();

        if (!fExtended) {
            OK(rwFlags.ReadBin(&mfBin));
            if (!(rwFlags.w & MF_POPUP)) {
                OK(rwId   .ReadBin(&mfBin));
            }
        } else {
            OK(rdwType .ReadBin(&mfBin));
            OK(rdwState.ReadBin(&mfBin));
            OK(rdwId   .ReadBin(&mfBin));
            OK(rwFlags .ReadBin(&mfBin));
        }

        OK(rsCaption.ReadBinZ(&mfBin));

        if (fExtended  &&  rwFlags.w & 1) {

            OK(mfBin.Align(pb, 4));

            OK(rdwHelpId.ReadBin(&mfBin));
        }

        return S_OK;
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {

        if (!fExtended) {
            OK(rwFlags.WriteTok(&nfText));  OK(nfText.WriteS(","));
            if (!(rwFlags.w & MF_POPUP)) {
                OK(rwId   .WriteTok(&nfText));  OK(nfText.WriteS(","));
            }
        } else {
            OK(rdwType  .WriteTok(&nfText));  OK(nfText.WriteS(","));
            OK(rdwState .WriteTok(&nfText));  OK(nfText.WriteS(","));
            OK(rdwId    .WriteTok(&nfText));  OK(nfText.WriteS(","));
            OK(rwFlags  .WriteTok(&nfText));  OK(nfText.WriteS(","));
            if (rwFlags.w & 1) {
                OK(rdwHelpId.WriteTok(&nfText));  OK(nfText.WriteS(","));
            }
        }

        OK(rsCaption.WriteTok(&nfText));

        return S_OK;
    }


    virtual size_t cbBin() const {

        size_t  cb;

        if (!fExtended) {

            cb =   rwFlags.cbBin()
                   + rsCaption.cbBinZ();

            if (!(rwFlags.w & MF_POPUP)) {
                cb += rwId.cbBin();
            }

        } else {

            cb =   rdwType.cbBin()
                   + rdwState.cbBin()
                   + rdwId.cbBin()
                   + rwFlags.cbBin()
                   + rsCaption.cbBinZ();

            if (rwFlags.w & 1) {

                cb = cb + 3 & ~3;
                cb += rdwHelpId.cbBin();
            }
        }

        return cb;
    }



    virtual HRESULT CopyBin  (BYTE **ppb) const {

        const BYTE * pb;

        pb = *ppb;

        if (!fExtended) {
            OK(rwFlags.CopyBin(ppb));
            if (!(rwFlags.w & MF_POPUP)) {
                OK(rwId   .CopyBin(ppb));
            }
        } else {
            OK(rdwType .CopyBin(ppb));
            OK(rdwState.CopyBin(ppb));
            OK(rdwId   .CopyBin(ppb));
            OK(rwFlags .CopyBin(ppb));
        }

        OK(rsCaption.CopyBinZ(ppb));

        if (fExtended  &&  rwFlags.w & 1) {

            while (*ppb - pb & 3) {
                **ppb = 0;
                (*ppb)++;
            }

            OK(rdwHelpId.CopyBin(ppb));
        }

        return S_OK;
    }

};






class Menu32 : public Resource {

    ResourceWORD    rwVer;
    ResourceWORD    rwHdrSize;
    ResourceBinary  rbHeader;
    MenuItem32     *pMnuItm;
    DWORD           cItems;
    BOOL            fExtended;


public:
    virtual HRESULT ReadTok(TextScanner &mfText) {

        DWORD i, iItem;

        OK(mfText.Expect("Mnu32"));
        fExtended = *(char*)mfText.GetRead() == 'X';
        if (fExtended) {
            OK(mfText.Expect("X;"));
        } else {
            OK(mfText.Expect("N;"));
        }

        OK(rwVer    .ReadTok(&mfText));    OK(mfText.Expect(","));
        OK(rwHdrSize.ReadTok(&mfText));    OK(mfText.Expect(","));
        if (fExtended  &&  rwHdrSize.w > 0) {
            OK(rbHeader.ReadTok(mfText));  OK(mfText.Expect(","));
        }
        OK(mfText.ReadHex(&cItems));       OK(mfText.Expect(":"));

        pMnuItm = new MenuItem32 [cItems];
        ASSERT(pMnuItm != NULL);

        for (i=0; i<cItems; i++) {

            OK(mfText.ExpectLn("   "));   OK(mfText.ReadHex(&iItem));
            ASSERT(i == iItem);
            pMnuItm[i].SetExtended(fExtended);
            OK(mfText.Expect(";"));       OK(pMnuItm[i].ReadTok(mfText));
        }

        return S_OK;
    }



    virtual HRESULT ReadBin(Scanner &mfBin, DWORD dwLen) {

        const BYTE *pb;       // For tracking
        MenuItem32  mi;       // For counting menu items
        const BYTE *pbFirstItem;
        int         i;

        cItems = 0;
        pb = mfBin.GetRead();

        OK(rwVer    .ReadBin(&mfBin));
        OK(rwHdrSize.ReadBin(&mfBin));

        ASSERT(rwVer.w == 0  ||  rwVer.w == 1);
        fExtended = rwVer.w;

        if (fExtended  &&  rwHdrSize.w > 0) {
            rbHeader.ReadBin(mfBin, rwHdrSize.w);
        }


        ASSERT(mfBin.GetRead() - pb < dwLen);


        // Count menu items

        if (fExtended) {
            OK(mfBin.Align(pb, 4));
        }

        pbFirstItem = mfBin.GetRead();
        mi.SetExtended(fExtended);
        while (mfBin.GetRead() - pb < dwLen) {

            OK(mi.ReadBin(mfBin));
            cItems++;

            if (fExtended) {
                OK(mfBin.Align(pb, 4));
            }
        }

        pMnuItm = new MenuItem32 [cItems];
        ASSERT(pMnuItm != NULL);


        // Record the menus

        OK(mfBin.SetRead(pbFirstItem));
        for (i=0; i<cItems; i++) {

            if (fExtended) {
                OK(mfBin.Align(pb, 4));
            }

            pMnuItm[i].SetExtended(fExtended);
            OK(pMnuItm[i].ReadBin(mfBin));
        }


        ASSERT(mfBin.GetRead() - pb <= dwLen);

        return S_OK;
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {

        DWORD i;

        OK(nfText.WriteS(fExtended ? "Mnu32X;": "Mnu32N;"));

        OK(rwVer    .WriteTok(&nfText));     OK(nfText.WriteS(","));
        OK(rwHdrSize.WriteTok(&nfText));     OK(nfText.WriteS(","));
        if (fExtended  &&  rwHdrSize.w > 0) {
            OK(rbHeader.WriteTok(nfText));   OK(nfText.WriteS(","));
        }
        OK(nfText.WriteHex(cItems,4));       OK(nfText.WriteS(":"));

        for (i=0; i<cItems; i++) {

            OK(nfText.WriteS("\r\n   "));
            OK(nfText.WriteHex(i, 4));
            OK(nfText.WriteS(";"));
            OK(pMnuItm[i].WriteTok(nfText));
        }

        return S_OK;
    }


    virtual size_t cbBin() const {
        int     i;
        size_t  cb;

        cb =    rwVer.cbBin()
                +  rwHdrSize.cbBin();

        if (fExtended  &&  rwHdrSize.w > 0) {
            cb += rbHeader.cbBin();
        }

        for (i=0; i<cItems; i++) {

            if (fExtended) {
                cb = cb + 3 & ~3;
            }

            cb += pMnuItm[i].cbBin();
        }

        return cb;
    }



    virtual HRESULT CopyBin  (BYTE **ppb) const {

        const BYTE *pb;       // For tracking
        int         i;

        pb = *ppb;

        OK(rwVer    .CopyBin(ppb));
        OK(rwHdrSize.CopyBin(ppb));

        if (fExtended  &&  rwHdrSize.w > 0) {
            rbHeader.CopyBin(ppb);
        }


        for (i=0; i<cItems; i++) {

            if (fExtended) {
                while (*ppb - pb & 3) {
                    **ppb = 0;
                    (*ppb)++;
                }
            }

            OK(pMnuItm[i].CopyBin(ppb));
        }

        return S_OK;
    }

    int GetItems() const {
        return cItems;
    }

    int GetWords() const {
        int i;
        int wc;

        wc = 0;
        for (i=0; i<cItems; i++) {
            wc += pMnuItm[i].GetWords();
        }

        return wc;
    }
};






////    String32
//
//      Strings are represented as a sequence of WCHARS, each string
//      preceeded by its length. Each resource contains 16 strings.


class String32 : public Resource {

    ResourceString rs[16];
    DWORD          cStrings;
    DWORD          cNonEmpty;

public:
    virtual HRESULT ReadTok(TextScanner &mfText) {

        DWORD i, iString, cLoaded;

        OK(mfText.Expect("Str;"));
        OK(mfText.ReadHex(&cStrings));
        OK(mfText.Expect(","));
        OK(mfText.ReadHex(&cNonEmpty));
        OK(mfText.Expect(":"));

        ASSERT(cStrings == 16);
        ASSERT(cNonEmpty <= cStrings);

        i=0;
        cLoaded = 0;
        while (cLoaded < cNonEmpty) {

            OK(mfText.ExpectLn("   "));
            OK(mfText.ReadHex(&iString));
            OK(mfText.Expect(":"));
            ASSERT(iString >= i);
            ASSERT(iString < cStrings);
            while (i<iString) {
                rs[i].SetEmpty();
                i++;
            }
            OK(rs[i].ReadTok(&mfText));
            i++;
            cLoaded++;
        }

        while (i<cStrings) {
            rs[i].SetEmpty();
            i++;
        }

        return S_OK;
    }



    virtual HRESULT ReadBin(Scanner &mfBin, DWORD dwLen) {

        const BYTE *pb;       // For tracking

        cStrings  = 0;
        cNonEmpty = 0;
        pb = mfBin.GetRead();

        while (    cStrings < 16
                   &&  mfBin.GetRead() - pb < dwLen) {

            rs[cStrings].ReadBinL(&mfBin);
            if (rs[cStrings].GetLength() > 0) {
                cNonEmpty++;
            }
            cStrings++;
        }

        ASSERT(mfBin.GetRead() - pb <= dwLen);
        ASSERT(cStrings == 16);

        return S_OK;
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {

        int i;

        ASSERT(cStrings <= 16);

        OK(nfText.WriteS("Str;"));
        OK(nfText.WriteHex(cStrings, 2));
        OK(nfText.WriteS(","));
        OK(nfText.WriteHex(cNonEmpty, 2));
        OK(nfText.WriteS(":"));


        for (i=0; i<cStrings; i++) {
            if (rs[i].GetLength() > 0) {
                OK(nfText.WriteS("\r\n   "));
                OK(nfText.WriteHex(i, 1));
                OK(nfText.WriteS(":"));
                OK(rs[i].WriteTok(&nfText));
            }
        }

        return S_OK;
    }


    virtual size_t cbBin() const {
        int     i;
        size_t  cb;

        cb = 0;

        for (i=0; i<cStrings; i++) {
            cb += rs[i].cbBinL();
        }

        return cb;
    }



    virtual HRESULT CopyBin  (BYTE **ppb) const {
        int i;

        for (i=0; i<cStrings; i++) {
            OK(rs[i].CopyBinL(ppb));
        }

        return S_OK;
    }


    int GetItems() const {
        return cNonEmpty;
    }

    int GetWords() const {

        int i, wc;

        wc = 0;
        for (i=0; i<cStrings; i++) {
            wc += rs[i].GetWords();
        }

        return wc;
    }
};






class DialogHeader32 {

    BOOL             fExtended;

    ResourceDWORD    rdwStyle;
    ResourceDWORD    rdwSignature;
    ResourceDWORD    rdwHelpId;
    ResourceDWORD    rdwExStyle;
    ResourceWORD     rwcDit;        // Count of dialog items
    ResourceWORD     rwX;
    ResourceWORD     rwY;
    ResourceWORD     rwCx;
    ResourceWORD     rwCy;
    ResourceVariant  rvMenu;
    ResourceVariant  rvClass;
    ResourceVariant  rvTitle;
    ResourceWORD     rwPointSize;
    ResourceWORD     rwWeight;
    ResourceBYTE     rbItalic;
    ResourceBYTE     rbCharSet;
    ResourceString   rsFaceName;

public:

    WORD GetItemCount()  const  {return rwcDit.w;}
    BOOL GetExtended()   const  {return fExtended;}
    int  GetWords()      const  {return rvTitle.GetWords();}

    HRESULT ReadTok(TextScanner *pmf) {

        OK(rwcDit      .ReadTok(pmf));  OK(pmf->Expect(","));

        OK(rdwStyle    .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwExStyle  .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwSignature.ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwHelpId   .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwX         .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwY         .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwCx        .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwCy        .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rvMenu      .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rvClass     .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rvTitle     .ReadTok(pmf));
        if (rdwStyle.dw & DS_SETFONT) {
            OK(pmf->Expect(","));
            OK(rwPointSize.ReadTok(pmf));  OK(pmf->Expect(","));
            OK(rwWeight   .ReadTok(pmf));  OK(pmf->Expect(","));
            OK(rbItalic   .ReadTok(pmf));  OK(pmf->Expect(","));
            OK(rbCharSet  .ReadTok(pmf));  OK(pmf->Expect(","));
            OK(rsFaceName .ReadTok(pmf));
        }

        fExtended = rdwSignature.dw != 0;

        return S_OK;
    }



    HRESULT ReadBin(Scanner *pmf) {

        OK(rdwSignature.ReadBin(pmf));

        fExtended = HIWORD(rdwSignature.dw) == 0xFFFF;
        if (!fExtended) {

            rdwStyle.dw = rdwSignature.dw;
            OK(rdwExStyle.ReadBin(pmf));
            rdwSignature.dw = 0;
            rdwHelpId.dw    = 0;

        } else {

            // Extended dialog adds signature and HelpID
            OK(rdwHelpId.ReadBin(pmf));
            OK(rdwExStyle.ReadBin(pmf));
            OK(rdwStyle.ReadBin(pmf));
        }


        OK(rwcDit    .ReadBin(pmf));
        OK(rwX       .ReadBin(pmf));
        OK(rwY       .ReadBin(pmf));
        OK(rwCx      .ReadBin(pmf));
        OK(rwCy      .ReadBin(pmf));
        OK(rvMenu    .ReadBinFFFFZ(pmf));
        OK(rvClass   .ReadBinFFFFZ(pmf));
        OK(rvTitle   .ReadBinFFFFZ(pmf));
        if (rdwStyle.dw & DS_SETFONT) {
            OK(rwPointSize.ReadBin(pmf));
            if (!fExtended) {
                rwWeight.w  = 0;
                rbItalic.b  = 0;
                rbCharSet.b = 0;
            } else {
                OK(rwWeight   .ReadBin(pmf));
                OK(rbItalic   .ReadBin(pmf));
                OK(rbCharSet  .ReadBin(pmf));
            }
            OK(rsFaceName .ReadBinZ(pmf));
        }


        return S_OK;
    }



    size_t cbBin() const {
        size_t cb;
        cb =  rdwStyle     .cbBin()         // Basics for all dialogs
              + rdwExStyle   .cbBin()
              + rwcDit       .cbBin()
              + rwX          .cbBin()
              + rwY          .cbBin()
              + rwCx         .cbBin()
              + rwCy         .cbBin()
              + rvMenu       .cbBinFFFFZ()
              + rvClass      .cbBinFFFFZ()
              + rvTitle      .cbBinFFFFZ();

        if (rdwStyle.dw & DS_SETFONT) {     // Facname additions
            cb +=   rwPointSize  .cbBin()
                    + rsFaceName   .cbBinZ();
        }

        if (fExtended) {                    // Extended dialog addtions
            cb +=   rdwSignature .cbBin()
                    + rdwHelpId    .cbBin();

            if (rdwStyle.dw & DS_SETFONT) {
                cb += rwWeight     .cbBin()
                      + rbItalic     .cbBin()
                      + rbCharSet    .cbBin();
            }
        }

        return cb;
    }



    HRESULT CopyBin(BYTE **ppb) const {

        BYTE *pbOriginal;

        pbOriginal = *ppb;

        if (!fExtended) {

            OK(rdwStyle  .CopyBin(ppb));
            OK(rdwExStyle.CopyBin(ppb));

        } else {

            OK(rdwSignature.CopyBin(ppb));
            OK(rdwHelpId   .CopyBin(ppb));
            OK(rdwExStyle  .CopyBin(ppb));
            OK(rdwStyle    .CopyBin(ppb));
        }
        OK(rwcDit    .CopyBin(ppb));
        OK(rwX       .CopyBin(ppb));
        OK(rwY       .CopyBin(ppb));
        OK(rwCx      .CopyBin(ppb));
        OK(rwCy      .CopyBin(ppb));
        OK(rvMenu    .CopyBinFFFFZ(ppb));
        OK(rvClass   .CopyBinFFFFZ(ppb));
        OK(rvTitle   .CopyBinFFFFZ(ppb));
        if (rdwStyle.dw & DS_SETFONT) {
            OK(rwPointSize.CopyBin(ppb));
            if (fExtended) {
                OK(rwWeight .CopyBin(ppb));
                OK(rbItalic .CopyBin(ppb));
                OK(rbCharSet.CopyBin(ppb));
            }
            OK(rsFaceName .CopyBinZ(ppb));
        }

        return S_OK;
    }



    HRESULT WriteTok(NewFile *pmf) const {

        OK(rwcDit      .WriteTok(pmf));  OK(pmf->WriteS(","));

        OK(rdwStyle    .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwExStyle  .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwSignature.WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwHelpId   .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwX         .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwY         .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwCx        .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwCy        .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rvMenu      .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rvClass     .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rvTitle     .WriteTok(pmf));
        if (rdwStyle.dw & DS_SETFONT) {
            OK(pmf->WriteS(","));
            OK(rwPointSize.WriteTok(pmf));  OK(pmf->WriteS(","));
            OK(rwWeight   .WriteTok(pmf));  OK(pmf->WriteS(","));
            OK(rbItalic   .WriteTok(pmf));  OK(pmf->WriteS(","));
            OK(rbCharSet  .WriteTok(pmf));  OK(pmf->WriteS(","));
            OK(rsFaceName .WriteTok(pmf));
        }
        return S_OK;
    }
};





class DialogItem32 {

    BOOL             fExtended;

    ResourceDWORD    rdwStyle;
    ResourceDWORD    rdwHelpId;
    ResourceDWORD    rdwExStyle;
    ResourceWORD     rwX;
    ResourceWORD     rwY;
    ResourceWORD     rwCx;
    ResourceWORD     rwCy;
    ResourceWORD     rwId;      // Normal
    ResourceDWORD    rdwId;     // Extended
    ResourceVariant  rvClass;
    ResourceVariant  rvTitle;

    ResourceWORD     rwcbRawData;   // Raw data size (extended only)
    ResourceBinary   rbRawData;

    ResourceWORD     rwDummy;       // Replaces raw data on normal dialogs

public:

    void SetExtended(BOOL f)         {fExtended = f;}
    int  GetWords()           const  {return rvTitle.GetWords();}

    HRESULT ReadTok(TextScanner *pmf) {

        if (fExtended) {
            OK(rdwId.ReadTok(pmf));     OK(pmf->Expect(","));
        } else {
            OK(rwId.ReadTok(pmf));      OK(pmf->Expect(","));
        }

        OK(rdwStyle    .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwExStyle  .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwHelpId   .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwX         .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwY         .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwCx        .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwCy        .ReadTok(pmf));  OK(pmf->Expect(","));

        OK(rvClass     .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rvTitle     .ReadTok(pmf));  OK(pmf->Expect(","));

        if (fExtended) {

            OK(rbRawData.ReadTok(*pmf));
            ASSERT(rbRawData.GetLength() < 0x10000);
            rwcbRawData.w = (WORD)rbRawData.GetLength();

        } else {

            OK(rwDummy.ReadTok(pmf));
        }

        return S_OK;
    }



    HRESULT ReadBin(Scanner *pmf) {

        if (!fExtended) {

            OK(rdwStyle.ReadBin(pmf));
            OK(rdwExStyle.ReadBin(pmf));
            rdwHelpId.dw    = 0;

        } else {

            OK(rdwHelpId.ReadBin(pmf));
            OK(rdwExStyle.ReadBin(pmf));
            OK(rdwStyle.ReadBin(pmf));
        }


        OK(rwX .ReadBin(pmf));
        OK(rwY .ReadBin(pmf));
        OK(rwCx.ReadBin(pmf));
        OK(rwCy.ReadBin(pmf));

        if (fExtended) {
            OK(rdwId.ReadBin(pmf));
        } else {
            OK(rwId.ReadBin(pmf));
        }

        OK(rvClass.ReadBinFFFFZ(pmf));
        OK(rvTitle.ReadBinFFFFZ(pmf));

        if (fExtended) {

            OK(rwcbRawData.ReadBin(pmf));
            OK(rbRawData.ReadBin(*pmf, rwcbRawData.w));

        } else {

            OK(rwDummy.ReadBin(pmf));
        }

        return S_OK;
    }



    size_t cbBin() const {
        size_t cb;

        cb =  rdwStyle   .cbBin()
              + rdwExStyle .cbBin()
              + rwX        .cbBin()
              + rwY        .cbBin()
              + rwCx       .cbBin()
              + rwCy       .cbBin()
              + rvClass    .cbBinFFFFZ()
              + rvTitle    .cbBinFFFFZ();

        if (!fExtended) {
            cb += rwId    .cbBin()
                  + rwDummy .cbBin();
        } else {
            cb += rdwId       .cbBin()
                  + rdwHelpId   .cbBin()
                  + rbRawData   .cbBin()
                  + rwcbRawData .cbBin();
        }
        return cb;
    }



    HRESULT CopyBin(BYTE **ppb) const {

        BYTE   *pbOriginal;

        pbOriginal = *ppb;

        if (!fExtended) {

            OK(rdwStyle.CopyBin(ppb));
            OK(rdwExStyle.CopyBin(ppb));

        } else {

            OK(rdwHelpId.CopyBin(ppb));
            OK(rdwExStyle.CopyBin(ppb));
            OK(rdwStyle.CopyBin(ppb));
        }


        OK(rwX .CopyBin(ppb));
        OK(rwY .CopyBin(ppb));
        OK(rwCx.CopyBin(ppb));
        OK(rwCy.CopyBin(ppb));

        if (fExtended) {
            OK(rdwId.CopyBin(ppb));
        } else {
            OK(rwId.CopyBin(ppb));
        }

        OK(rvClass.CopyBinFFFFZ(ppb));
        OK(rvTitle.CopyBinFFFFZ(ppb));

        if (fExtended) {

            OK(rwcbRawData.CopyBin(ppb));
            OK(rbRawData.CopyBin(ppb));

        } else {

            OK(rwDummy.CopyBin(ppb));
        }

        return S_OK;
    }



    HRESULT WriteTok(NewFile *pmf) const {

        if (fExtended) {
            OK(rdwId.WriteTok(pmf));     OK(pmf->WriteS(","));
        } else {
            OK(rwId.WriteTok(pmf));      OK(pmf->WriteS(","));
        }

        OK(rdwStyle    .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwExStyle  .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwHelpId   .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwX         .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwY         .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwCx        .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwCy        .WriteTok(pmf));  OK(pmf->WriteS(","));

        OK(rvClass     .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rvTitle     .WriteTok(pmf));  OK(pmf->WriteS(","));

        if (fExtended) {

            OK(rbRawData.WriteTok(*pmf));

        } else {

            OK(rwDummy.WriteTok(pmf));
        }

        return S_OK;
    }
};







////    Dialog32
//
//


class Dialog32 : public Resource {


    DialogHeader32    DlgHdr;   // Header
    DialogItem32     *pDlgItm;  // Array of items

    BOOL fExtended;
    int  cItems;

public:

    Dialog32() {pDlgItm = NULL;};

    virtual HRESULT ReadTok(TextScanner &mfText) {

        DWORD i, dwSeq;

        OK(mfText.Expect("Dlg32"));
        fExtended = *(char*)mfText.GetRead() == 'X';
        if (fExtended) {
            OK(mfText.Expect("X;"));
        } else {
            OK(mfText.Expect("N;"));
        }

        OK(DlgHdr.ReadTok(&mfText));
        ASSERT(fExtended == DlgHdr.GetExtended());

        cItems = DlgHdr.GetItemCount();

        pDlgItm = new DialogItem32 [cItems];
        ASSERT(pDlgItm != NULL);


        for (i=0; i<cItems; i++) {

            OK(mfText.ExpectLn("   "));
            OK(mfText.ReadHex(&dwSeq));
            ASSERT(dwSeq == i+1);
            OK(mfText.Expect(";"));

            pDlgItm[i].SetExtended(fExtended);
            OK(pDlgItm[i].ReadTok(&mfText));
        }

        return S_OK;
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {

        DWORD i;

        OK(nfText.WriteS(fExtended ? "Dlg32X;": "Dlg32N;"));

        OK(DlgHdr.WriteTok(&nfText));

        for (i=0; i<cItems; i++) {

            OK(nfText.WriteS("\r\n   "));
            OK(nfText.WriteHex(i+1, 4));
            OK(nfText.WriteS(";"));
            OK(pDlgItm[i].WriteTok(&nfText));
        }

        return S_OK;
    }



    virtual HRESULT ReadBin(Scanner &mfBinary, DWORD dwLen) {

        const BYTE *pb;      // File pointer for tracking alignment
        int         i;

        pb = mfBinary.GetRead();

        OK(DlgHdr.ReadBin(&mfBinary));
        fExtended = DlgHdr.GetExtended();
        cItems    = DlgHdr.GetItemCount();

        pDlgItm = new DialogItem32 [cItems];
        ASSERT(pDlgItm != NULL);


        // Read items

        for (i=0; i<cItems; i++) {

            OK(mfBinary.Align(pb, 4));   // Advance over any alignment padding

            pDlgItm[i].SetExtended(fExtended);
            OK(pDlgItm[i].ReadBin(&mfBinary));

            ASSERT(mfBinary.GetRead() - pb <= dwLen);
        }

        return S_OK;
    }



    virtual size_t cbBin() const {

        size_t cb;
        int    i;

        cb = DlgHdr.cbBin();

        for (i=0; i<cItems; i++) {

            cb = cb + 3 & ~3;   // alignment padding

            cb += pDlgItm[i].cbBin();
        }

        return cb;
    }



    virtual HRESULT CopyBin (BYTE **ppb) const {

        BYTE *pb;   // Pointer for tracking alignment
        int   i;

        pb = *ppb;

        DlgHdr.CopyBin(ppb);

        for (i=0; i<cItems; i++) {

            // Insert alignment padding

            while (*ppb - pb & 3) {
                **ppb = 0;
                (*ppb)++;
            }

            pDlgItm[i].CopyBin(ppb);
        }

        return S_OK;
    }

    int GetItems() const {
        return cItems;
    }

    int GetWords() const {

        int i, wc;

        wc = DlgHdr.GetWords();
        for (i=0; i<cItems; i++) {
            wc += pDlgItm[i].GetWords();
        }
        return wc;
    }
};





////    VersionInfo
//
//      The documentation in the Win32 SDK doesn't clearly capture the
//      usage of block headers, or the nesting of blocks in the Version resource.
//
//      Each block has the following format
//
//      wLength         Total length including key, value and subblocks
//      wValueLength    Length of value in bytes or characters according to bText
//      bText           Whether value is in bytes or zero terminated WCHARs
//      szKey           Zero terminated WCHAR key, padded with zeros to next DWORD boundary
//      Value           Size determined by bText and wValueLength, padded to DWORD boundary
//      Sub-blocks      Remaining space (if any, up to wLength) is an array of sub blocks


class VersionInfo : public Resource {

    struct VersionBlock {
        VersionBlock   *pNext;          // Next block at this level
        VersionBlock   *pSub;           // First contained subblock
        int             iDepth;         // Starts at zero
        DWORD           cSub;           // Number of contained subblocks
        BOOL            bValue;         // Set if a vlue is present
        ResourceWORD    rwbText;
        ResourceString  rsKey;
        ResourceString  rsValue;        // Value when a string
        ResourceBinary  rbValue;        // Value when bytes
    };


    VersionBlock *pvb;                  // First root level block
    DWORD         cBlocks;              // Number of root level blocks



    HRESULT ReadBinVersionBlocks(
                                Scanner         &mfBinary,
                                DWORD            dwLength,    // Length of binary to read
                                VersionBlock   **ppvb,
                                int              iDepth,
                                DWORD           *cSub) {

        const BYTE      *pbBlock;
        const BYTE      *pbResource;
        ResourceWORD     rwLength;
        WORD             wValueLength;


        pbResource = mfBinary.GetRead();
        (*cSub) = 0;
        while (mfBinary.GetRead() < pbResource + dwLength) {

            // Read one version block

            pbBlock = mfBinary.GetRead();
            OK(rwLength.ReadBin(&mfBinary));

            ASSERT(pbBlock + rwLength.w <= mfBinary.GetLimit());

            //OK((*ppvb)->rwValueLength.ReadBin(&mfBinary));

            wValueLength = *(WORD*)mfBinary.GetRead();
            OK(mfBinary.Advance(2));

            if (rwLength.w > 0) {

                // Block is not empty

                *ppvb           = new VersionBlock;
                ASSERT(*ppvb != NULL);

                (*ppvb)->pNext  = NULL;
                (*ppvb)->pSub   = NULL;
                (*ppvb)->iDepth = iDepth;

                OK((*ppvb)->rwbText.ReadBin(&mfBinary));
                OK((*ppvb)->rsKey.ReadBinZ(&mfBinary));
                OK(mfBinary.Align(pbResource, 4));

                (*ppvb)->bValue = wValueLength > 0;

                if ((*ppvb)->bValue) {

                    if ((*ppvb)->rwbText.w == 0) {

                        // Binary value

                        OK((*ppvb)->rbValue.ReadBin(mfBinary, wValueLength));

                    } else {

                        // WCHAR string.

                        // Some writers include a zero terminator, some don't.
                        // Some incode zero codepoints  inside the string
                        // Some writers get the length right, some dont.
                        // msvcrt20.dll text lengths are too long.

                        // Choose a length that is min(ValueLength, length remaining),
                        // and then drop any trailing zeros.

                        // Clip ValueLength to length remaining

                        ASSERT(mfBinary.GetRead() < pbBlock + rwLength.w);

                        if (wValueLength > (pbBlock + rwLength.w - mfBinary.GetRead()) / 2) {
                            wValueLength = (pbBlock + rwLength.w - mfBinary.GetRead()) / 2;
                        }

                        // Clip trailing zeros

                        while (    wValueLength > 0
                                   &&  ((WCHAR*)mfBinary.GetRead())[wValueLength-1] == 0) {
                            wValueLength--;
                        }

                        // Extract whatever remains

                        OK((*ppvb)->rsValue.ReadBin(&mfBinary, wValueLength));

                        // Check that there's nothing being lost between the end of
                        // the string and the end of the block.

                        // Note that we assume here that blocks containing text values
                        // cannot have variety of messes that value text is stored in
                        // in exisiting executables.

                        while (mfBinary.GetRead() < pbBlock + rwLength.w) {

                            ASSERT(*(WCHAR*)mfBinary.GetRead() == 0);
                            OK(mfBinary.Advance(2));
                        }
                    }
                    OK(mfBinary.Align(pbResource, 4));
                }

                if (mfBinary.GetRead() - pbBlock < rwLength.w) {

                    ASSERT(mfBinary.GetLimit() > mfBinary.GetRead());

                    // Read subblocks

                    OK(ReadBinVersionBlocks(
                                           mfBinary,
                                           rwLength.w - (mfBinary.GetRead() - pbBlock),
                                           &((*ppvb)->pSub),
                                           iDepth + 1,
                                           &(*ppvb)->cSub));
                }

                if (mfBinary.GetRead() < pbResource + dwLength) {

                    // Prepare to read more blocks at this level

                    ppvb = &((*ppvb)->pNext);
                }
            }

            (*cSub)++;
        }

        return S_OK;
    }


    HRESULT WriteTokVersionBlocks(
                                 NewFile          &nfText,
                                 VersionBlock     *pvb)     const {

        while (pvb) {

            OK(nfText.WriteS("\r\n   "));
            OK(nfText.WriteHex(pvb->iDepth, 2));
            OK(nfText.WriteS(","));
            OK(pvb->rsKey.WriteTok(&nfText));

            if (pvb->bValue) {

                OK(nfText.WriteS("="));

                if (pvb->rwbText.w == 0) {

                    OK(pvb->rbValue.WriteTok(nfText));  // Binary value

                } else {

                    OK(pvb->rsValue.WriteTok(&nfText));  // String value

                }

            }

            if (pvb->pSub) {
                OK(nfText.WriteS(";"));
                OK(nfText.WriteHex(pvb->cSub,4));
                OK(WriteTokVersionBlocks(nfText, pvb->pSub));
            }

            pvb = pvb->pNext;
        }

        return S_OK;
    }

    HRESULT ReadTokVersionBlocks(
                                TextScanner    &mfText,
                                VersionBlock  **ppvb,
                                int             iDepth,
                                DWORD          *pcBlocks) {

        int             i;
        DWORD           dwRecordedDepth;


        OK(mfText.ReadHex(pcBlocks));

        for (i=0; i<*pcBlocks; i++) {
            *ppvb = new VersionBlock;
            ASSERT(*ppvb != NULL);

            (*ppvb)->pNext  = NULL;
            (*ppvb)->pSub   = NULL;
            (*ppvb)->iDepth = iDepth;
            (*ppvb)->cSub   = 0;

            OK(mfText.ExpectLn("   "));
            OK(mfText.ReadHex(&dwRecordedDepth));
            ASSERT(dwRecordedDepth == iDepth);
            OK(mfText.Expect(","));
            OK((*ppvb)->rsKey.ReadTok(&mfText));

            if (*(char*)mfText.GetRead() != '=') {

                // No value

                (*ppvb)->rwbText.w = 1;
                (*ppvb)->bValue = FALSE;

            } else {

                OK(mfText.Expect("="));
                (*ppvb)->bValue = TRUE;


                if (*(char*)mfText.GetRead() == '\"') {

                    // String value

                    (*ppvb)->rwbText.w = 1;
                    OK((*ppvb)->rsValue.ReadTok(&mfText));

                } else {

                    // Binary value

                    (*ppvb)->rwbText.w = 0;
                    OK((*ppvb)->rbValue.ReadTok(mfText));
                }
            }

            if (*(char*)mfText.GetRead() == ';') {

                // Process subkeys

                OK(mfText.Expect(";"));
                OK(ReadTokVersionBlocks(
                                       mfText,
                                       &(*ppvb)->pSub,
                                       iDepth+1,
                                       &(*ppvb)->cSub));
            }

            // Prepare to add another block

            ppvb = &(*ppvb)->pNext;
        }

        return S_OK;
    }


    size_t cbBinVersionBlocks(const VersionBlock *pvb)  const {

        size_t cb;

        cb = 6;    // Header
        cb += pvb->rsKey.cbBinZ();

        cb = cb+3 & ~3;     // DWORD align

        if (pvb->bValue) {

            if (pvb->rwbText.w) {

                cb += pvb->rsValue.cbBinZ();

            } else {

                cb += pvb->rbValue.cbBin();
            }

            cb = cb + 3 & ~3;   // DWORD align
        }

        if (pvb->pSub != NULL) {

            pvb = pvb->pSub;
            while (pvb) {
                cb += cbBinVersionBlocks(pvb);
                pvb = pvb->pNext;
            }
        }

        return cb;
    }


    HRESULT CopyBinVersionBlocks(
                                BYTE               **ppb,
                                const VersionBlock  *pvb)       const {

        const BYTE      *pbResource;
        size_t           cb;

        pbResource = *ppb;


        while (pvb != NULL) {

            cb = cbBinVersionBlocks(pvb);
            ASSERT(cb < 0x1000);

            *((WORD*)(*ppb)) = (WORD)cb;
            (*ppb) += 2;

            // Generate value length

            if (pvb->bValue) {
                if (pvb->rwbText.w) {
                    *((WORD*)(*ppb)) = pvb->rsValue.GetLength()+1;
                } else {
                    *((WORD*)(*ppb)) = pvb->rbValue.GetLength();
                }
            } else {
                *((WORD*)(*ppb)) = 0;
            }
            (*ppb) += 2;

            OK(pvb->rwbText.CopyBin(ppb));
            OK(pvb->rsKey.CopyBinZ(ppb));

            while (*ppb - pbResource & 3) {
                **ppb = 0;
                (*ppb)++;
            }

            if (pvb->bValue) {

                if (pvb->rwbText.w) {
                    OK(pvb->rsValue.CopyBinZ(ppb));
                } else {
                    OK(pvb->rbValue.CopyBin(ppb));
                }

                while (*ppb - pbResource & 3) {
                    **ppb = 0;
                    (*ppb)++;
                }
            }

            if (pvb->pSub) {
                OK(CopyBinVersionBlocks(ppb, pvb->pSub));
            }

            pvb = pvb->pNext;
        }


        return S_OK;
    }


    int GetItemsVersionBlocks(const VersionBlock *pvb) const {

        int iItems = 0;

        while (pvb != NULL) {

            if (    pvb->bValue
                    &&  pvb->rwbText.w != 0) {

                iItems++;
            }

            iItems += GetItemsVersionBlocks(pvb->pSub);

            pvb = pvb->pNext;
        }

        return iItems;
    }


    int GetWordsVersionBlocks(const VersionBlock *pvb) const {

        int iWords = 0;

        while (pvb != NULL) {

            if (    pvb->bValue
                    &&  pvb->rwbText.w != 0) {

                iWords += pvb->rsValue.GetWords();
            }

            iWords += GetWordsVersionBlocks(pvb->pSub);

            pvb = pvb->pNext;
        }

        return iWords;
    }


public:

    virtual HRESULT ReadTok(TextScanner &mfText) {
        OK(mfText.Expect("Ver;"));
        return ReadTokVersionBlocks(mfText, &pvb, 0, &cBlocks);
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {
        OK(nfText.WriteS("Ver;"));
        OK(nfText.WriteHex(cBlocks,4));
        return WriteTokVersionBlocks(nfText, pvb);
    }



    virtual HRESULT ReadBin(Scanner &mfBinary, DWORD dwLen) {
        return ReadBinVersionBlocks(mfBinary, dwLen, &pvb, 0, &cBlocks);
    }



    virtual size_t cbBin() const {

        const VersionBlock  *pvbTop;
        size_t               cb;

        cb     = 0;
        pvbTop = pvb;

        while (pvbTop) {
            cb     += cbBinVersionBlocks(pvbTop);
            pvbTop  = pvbTop->pNext;
        }
        return cb;
    }



    virtual HRESULT CopyBin (BYTE **ppb) const {
        return CopyBinVersionBlocks(ppb, pvb);
    }

    int GetItems() const {
        return GetItemsVersionBlocks(pvb);
    }

    int GetWords() const {
        return GetWordsVersionBlocks(pvb);
    }


    VersionBlock *FindStringFileInfo(WCHAR* pwcStr) const {
        VersionBlock *pvbRider;

        if (    pvb
                &&  pvb->pSub
                &&  pvb->pSub->pSub
                &&  pvb->pSub->pSub->pSub) {

            pvbRider = pvb->pSub->pSub->pSub;
            while (    pvbRider
                       &&  wcscmp(pvbRider->rsKey.GetString(), pwcStr) != 0) {
                pvbRider = pvbRider->pNext;
            }
            return pvbRider;
        } else {
            return NULL;
        }
    }


    ResourceString* GetStringFileInfo(WCHAR *pwcStr) {

        VersionBlock *pvbStringFileInfo;

        pvbStringFileInfo = FindStringFileInfo(pwcStr);

        if (pvbStringFileInfo) {
            return &pvbStringFileInfo->rsValue;
        } else {
            return NULL;
        }
    }


    void SetStringFileInfo(WCHAR *pwcStr, ResourceString *prs) {

        VersionBlock *pvbStringFileInfo;

        pvbStringFileInfo = FindStringFileInfo(pwcStr);

        if (pvbStringFileInfo) {
            pvbStringFileInfo->rsValue = *prs;
        }
    }

    ResourceBinary* GetBinaryInfo() const {
        if (pvb) {
            return &pvb->rbValue;
        }
        return NULL;
    }

    void SetBinaryInfo(const ResourceBinary *prb) {
        if (pvb) {
            pvb->rbValue = *prb;
        }
    }
};






////    Statistic collection
//
//


struct ResourceStats {
    int  cResources;    // Number of resources with this resource type
    int  cItems;        // Number of items with this resource type
    int  cWords;        // Number of words in strings in this resource type
    int  cBytes;        // Number of bytes used by resources of this type
};

typedef map < ResourceVariant, ResourceStats, less<ResourceVariant> > MappedResourceStats;

MappedResourceStats  ResourceStatsMap;



////    Define our own LangId class so that primary languages sort together.
//
//


class LangId {

public:
    DWORD dwLang;

    LangId(DWORD dwL) {dwLang = dwL;};

    bool operator< (LangId li) const {

        if (PRIMARYLANGID(dwLang) != PRIMARYLANGID(li.dwLang)) {

            return PRIMARYLANGID(dwLang) < PRIMARYLANGID(li.dwLang) ? true : false;

        } else {

            return SUBLANGID(dwLang) < SUBLANGID(li.dwLang) ? true : false;
        }
    }
};


typedef map < LangId, ResourceStats, less<LangId> > MappedLanguageStats;

MappedLanguageStats LanguageStatsMap;






////    UpdateStats
//
//


const ResourceStats ZeroStats = {0};


HRESULT UpdateStats(
                   const ResourceKey  &rk,
                   int                 cItems,
                   int                 cWords,
                   int                 cBytes) {


    if (ResourceStatsMap.count(*rk.prvId[0]) == 0) {
        ResourceStatsMap[*rk.prvId[0]] = ZeroStats;
    }

    if (LanguageStatsMap.count(rk.prvId[2]->GetW()) == 0) {
        LanguageStatsMap[rk.prvId[2]->GetW()] = ZeroStats;
    }

    ResourceStatsMap[*rk.prvId[0]].cResources += 1;
    ResourceStatsMap[*rk.prvId[0]].cItems     += cItems;
    ResourceStatsMap[*rk.prvId[0]].cWords     += cWords;
    ResourceStatsMap[*rk.prvId[0]].cBytes     += cBytes;

    LanguageStatsMap[rk.prvId[2]->GetW()].cResources += 1;
    LanguageStatsMap[rk.prvId[2]->GetW()].cItems     += cItems;
    LanguageStatsMap[rk.prvId[2]->GetW()].cWords     += cWords;
    LanguageStatsMap[rk.prvId[2]->GetW()].cBytes     += cBytes;

    return S_OK;
}










////    IsResourceWanted
//
//      Returns whether a given resource key was requested on the command line


BOOL IsResourceWanted(const ResourceKey &rk) {


    if (rk.prvId[0]->GetfString()) {

        return g_dwProcess & PROCESSOTH;

    } else {

        switch (rk.prvId[0]->GetW()) {

            case 1:    return g_dwProcess & PROCESSCUR;
            case 2:    return g_dwProcess & PROCESSBMP;
            case 3:    return g_dwProcess & PROCESSICO;
            case 4:    return g_dwProcess & PROCESSMNU;
            case 5:    return g_dwProcess & PROCESSDLG;
            case 6:    return g_dwProcess & PROCESSSTR;
            case 7:    return g_dwProcess & PROCESSFDR;
            case 8:    return g_dwProcess & PROCESSFNT;
            case 9:    return g_dwProcess & PROCESSACC;
            case 10:   return g_dwProcess & PROCESSRCD;
            case 11:   return g_dwProcess & PROCESSMSG;
            case 16:   return g_dwProcess & PROCESSVER;
            case 240:
            case 1024:
            case 23:
            case 2110: return g_dwProcess & PROCESSBIN;
            case 2200: return g_dwProcess & PROCESSINF;
            default:   return g_dwProcess & PROCESSOTH;
        }
    }

    return FALSE;
}






////    NewResource
//
//      Returns a pointer to a newly allocated subclass of Resource
//      suitable for the given resource type.


Resource *NewResource(const ResourceVariant &rv) {

    if (rv.GetfString()) {

        return new ResourceBinary;

    } else {

        switch (rv.GetW()) {

            case 1:    return new ResourceBinary;
            case 2:    return new ResourceBinary;
            case 3:    return new ResourceBinary;
            case 4:    return new Menu32;
            case 5:    return new Dialog32;
            case 6:    return new String32;
            case 7:    return new ResourceBinary;
            case 8:    return new ResourceBinary;
            case 9:    return new ResourceBinary;
            case 10:   return new ResourceBinary;
            case 11:   return new ResourceBinary;
            case 16:   return new VersionInfo;
            case 240:
            case 1024:
            case 23:
            case 2110: return new ResourceBinary;
            case 2200: return new ResourceBinary;

            default:   return new ResourceBinary;
        }
    }
}






////    Rsrc internal resource directory
//
//      Rsrc stores resources in an STL 'map' structure.




class ResourceValue {

public:

    const BYTE  *pb;           // Pointer into mapped file
    DWORD        cb;           // Count of bytes in the value
    Resource    *pResource;
    DWORD        dwCodePage;   // Codepage from Win32 resource index - not very useful!

    ResourceValue() {pb = NULL; pResource = NULL; cb=0; dwCodePage=0;}

/*
    ~ResourceValue() {}; // Don't destroy content on destruction

    ResourceValue& operator= (const ResourceValue &rv) {
        pb = rv.pb;
        cb = rv.cb;
        pResource = rv.pResource;
        dwCodePage = rv.dwCodePage;
        return *this;
    }

    ResourceValue(const ResourceValue &rv) {
        *this = rv;
    }
*/


    ////    CreateImage
    //
    //      Convert interpreted resource to binary image.
    //      Used to prepare resources read from tokens for
    //      comparison and update.

    HRESULT CreateImage() {

        BYTE *pbBuf;

        ASSERT(pb        == NULL);
        ASSERT(pResource != NULL);

        cb    = pResource->cbBin();
        pbBuf = new BYTE [cb];
        ASSERT(pbBuf != NULL);

        pb = pbBuf;
        OK(pResource->CopyBin(&pbBuf));

        ASSERT(pbBuf - pb == cb);  // This may be too strong? It has not failed yet!
        ASSERT(pbBuf - pb <= cb);  // This must be true - otherwise we wrote past the end of the buffer

        return S_OK;
    }






    ////    InterpretImage
    //
    //      Convert binary image to interpreted resource.
    //      Used to prepare resources read from executable for
    //      writing as tokens.

    HRESULT InterpretImage(const ResourceKey &rk) {

        ASSERT(pb        != NULL);
        ASSERT(pResource == NULL);

        ASSERT(rk.iDepth == 3);
        ASSERT(!rk.prvId[2]->GetfString());


        if (g_dwOptions & OPTHEXDUMP) {

            pResource = new ResourceHexDump;

        } else {

            // This is a resource extraction to tokens so interpret content

            pResource = NewResource(*rk.prvId[0]);
        }

        ASSERT(pResource != NULL);

        OK(pResource->ReadBin(Scanner(pb, cb), cb));

        pb = NULL;
        cb = 0;

        return S_OK;
    }





    ////    Checksum
    //
    //      Returns DWORD checksum of binary content of resource

    DWORD Checksum() {

        DWORD   dw;
        DWORD  *pdw;
        int     i,l;

        ASSERT(pb != NULL);

        l   = cb >> 2;          // Length in whole DWORDS
        pdw = (DWORD*)pb;
        dw  = 0;

        for (i=0; i<l; i++) {

            dw ^= pdw[i];
        }

        l = cb - (l << 2);      // Remaining length in bytes

        if (l>2) dw ^= pb[cb-3] << 16;
        if (l>1) dw ^= pb[cb-2] << 8;
        if (l>0) dw ^= pb[cb-1];

        return dw;
    }
};






class ResourceMap : public map < ResourceKey, ResourceValue*, less<ResourceKey> > {


public:

    ////    AddResource
    //
    //


    HRESULT AddResource(ResourceKey &rk, const BYTE *pb, DWORD cb, DWORD dwCodePage) {

        ResourceValue *prv;


        // Build a resource structure

        prv = new ResourceValue;

        prv->pb         = pb;
        prv->cb         = cb;
        prv->dwCodePage = dwCodePage;
        prv->pResource  = NULL;


        // Process add options

        if (IsResourceWanted(rk)) {

            // Insert resource details into STL map

            if (this->count(rk) != 0) {

                fprintf(stderr, "%s(", g_szExecutable);
                rk.fprint(stderr);
                fprintf(stderr, "): error RSRC500: Corrupt executable - resource appears more than once\n");
                g_fError = TRUE;
                return E_FAIL;
            }

            (*this)[rk] = prv;

        } else {

            g_cResourcesIgnored++;
        }

        return S_OK;
    }




    ////    CopyResources
    //
    //      Takes a copy so the original mapped file can be closed


    HRESULT CopyResources() {

        iterator   rmi;
        BYTE      *pb;

        for (rmi = begin(); rmi != end(); rmi++) {

            pb = new BYTE[rmi->second->cb];
            ASSERT(pb != NULL);

            memcpy(pb, rmi->second->pb, rmi->second->cb);

            rmi->second->pb = pb;
        }

        return S_OK;
    }




    ////    WriteTokens
    //
    //      Writes the content of the map as a token file.
    //
    //      If an unlocalised map is provided, bit for bit identical
    //      resources are written as a reference to the unlocalised
    //      version language, rather than in full.


    HRESULT WriteTokens(NewFile &nfText, ResourceMap *prmUnlocalised) {

        iterator     rmi;
        iterator     rmiUnlocalised;
        ResourceKey  rkUnlocalised;

        for (rmi = begin(); rmi != end(); rmi++) {

            g_cResourcesExtracted++;

            // Write resource key and codepage

            OK(rmi->first.WriteTok(&nfText));
            OK(nfText.WriteS(";"));
            OK(nfText.WriteHex(rmi->second->dwCodePage, 8));


            if (prmUnlocalised) {

                // Add unlocalised checksum and language

                rkUnlocalised = rmi->first;
                rkUnlocalised.SetLanguage(g_liUnlocalized);
                rmiUnlocalised = prmUnlocalised->find(rkUnlocalised);

                if (rmiUnlocalised == prmUnlocalised->end()) {

                    fprintf(stderr, "%s(", g_szResources);
                    rmi->first.fprint(stderr);
                    fprintf(stderr, "): warning RSRC100: Localised resource has no corresponding unlocalised resource in %s\n", g_szUnloc);
                    g_fWarn = TRUE;

                } else {

                    // Put out details of the unlocalised resource

                    OK(nfText.WriteS(","));
                    OK(nfText.WriteHex(rmiUnlocalised->second->Checksum(), 8));
                    OK(nfText.WriteS(","));
                    OK(nfText.WriteHex(g_liUnlocalized, 4));
                }
            }

            OK(nfText.WriteS(";"));


            // Check whether resource needs to be written in full

            if (    prmUnlocalised
                    &&  rmiUnlocalised != prmUnlocalised->end()
                    &&  rmiUnlocalised->second->cb == rmi->second->cb
                    &&  memcmp(rmi->second->pb, rmiUnlocalised->second->pb, rmi->second->cb) == 0) {

                // Bit for bit match with unlocalised executable

                OK(nfText.WriteS("Unloc"));

            } else {

                // Doesn't match - write it in full

                OK(rmi->second->InterpretImage(rmi->first));
                OK(rmi->second->pResource->WriteTok(nfText));
            }

            OK(nfText.WriteLn());
        }

        return S_OK;
    }




    ////    UpdateWin32Executable
    //
    //


    HRESULT UpdateWin32Executable(char *pExecutable) {

        iterator   rmi;
        HANDLE     hUpdate;


        hUpdate = BeginUpdateResourceA(pExecutable, TRUE);  // Will replace all resources
        MUST(hUpdate != NULL ? S_OK : E_FAIL,
             ("RSRC : error RSRC600: BeginUpdateResource failed on %s\n", pExecutable));


        for (rmi = begin(); rmi != end(); rmi++) {

            ASSERT(rmi->first.iDepth == 3);
            ASSERT(!rmi->first.prvId[2]->GetfString());


            // Create binary image of resource if necessary

            if (rmi->second->pb == NULL) {
                OK(rmi->second->CreateImage());
            }


            // Use NT resource API to update resource binary image in executable

            if (!UpdateResourceW(
                                hUpdate,
                                rmi->first.GetResName(0),
                                rmi->first.GetResName(1),
                                rmi->first.prvId[2]->GetW(),
                                (void*)rmi->second->pb,
                                rmi->second->cb)) {

                EndUpdateResourceW(hUpdate, TRUE);  // Discard all requested updates
                g_fError = TRUE;
                fprintf(stderr, "RSRC : error RSRC601: UpdateResourceW failed on %s\n", pExecutable);
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }

        if (!EndUpdateResourceW(hUpdate, FALSE)) { // Apply all requested updates

            fprintf(stderr, "RSRC : error RSRC602: EndUpdateResourceW failed on %s\n", pExecutable);
            g_fError = TRUE;
            return HRESULT_FROM_WIN32(GetLastError());
        }

        return S_OK;
    }
};






class SymbolFile {

    MappedFile                   *m_pmfSymbolFile;
    IMAGE_SEPARATE_DEBUG_HEADER  *m_pDebugHeader;

public:

    DWORD GetChecksum()       const {return m_pDebugHeader->CheckSum;}
    DWORD GetTimeDateStamp()  const {return m_pDebugHeader->TimeDateStamp;}
    DWORD GetImageBase()      const {return m_pDebugHeader->ImageBase;}
    DWORD GetSizeOfImage()    const {return m_pDebugHeader->SizeOfImage;}

    void  SetChecksum      (DWORD dwChecksum)      {m_pDebugHeader->CheckSum      = dwChecksum;}
    void  SetTimeDateStamp (DWORD dwTimeDateStamp) {m_pDebugHeader->TimeDateStamp = dwTimeDateStamp;}
    void  SetImageBase     (DWORD dwImageBase)     {m_pDebugHeader->ImageBase     = dwImageBase;}
    void  SetSizeOfImage   (DWORD dwSizeOfImage)   {m_pDebugHeader->SizeOfImage   = dwSizeOfImage;}

    HRESULT Open(MappedFile *pmfSymbolFile) {

        m_pmfSymbolFile = pmfSymbolFile;
        m_pDebugHeader  = (IMAGE_SEPARATE_DEBUG_HEADER*) pmfSymbolFile->GetFile();

        ASSERT(m_pDebugHeader->Signature == IMAGE_SEPARATE_DEBUG_SIGNATURE);

        return S_OK;
    }

};





class Win32Executable : public MappedFile {

    IMAGE_NT_HEADERS      *m_pNtHeader;
    IMAGE_SECTION_HEADER  *m_pSections;
    int                    m_iSectionRsrc;
    int                    m_iSectionRsrc1;

    // For scanning

    ResourceKey            m_rk;                // Current resource key


    HRESULT MapDirectory(
                        ResourceMap  &rm,
                        const BYTE   *pbRsrc,       // Resource block
                        int           dwOffset,     // Directory offset relative to m_pbRsrc
                        int           iLevel) {     // Directory level being scanned


        IMAGE_RESOURCE_DIRECTORY        *pird;
        IMAGE_RESOURCE_DIRECTORY_ENTRY  *pEntries;
        IMAGE_RESOURCE_DATA_ENTRY       *pirde;
        const BYTE                      *pb;
        int                              i;

        pird     = (IMAGE_RESOURCE_DIRECTORY*)       (pbRsrc+dwOffset);
        pEntries = (IMAGE_RESOURCE_DIRECTORY_ENTRY*) (pird+1);

        for (i=0; i<pird->NumberOfNamedEntries + pird->NumberOfIdEntries; i++) {

            // Read the ID from the directory

            ASSERT(iLevel<3);
            m_rk.iDepth = iLevel+1;

            m_rk.prvId[iLevel] = new ResourceVariant;
            ASSERT(m_rk.prvId[iLevel] != NULL);
            OK(m_rk.prvId[iLevel]->ReadWin32ResDirEntry(this, pbRsrc, pEntries+i));

            if (pEntries[i].DataIsDirectory) {

                // This is a directory node. Recurse to scan that directory.

                OK(MapDirectory(rm, pbRsrc, pEntries[i].OffsetToDirectory, iLevel+1));

            } else {

                // We've reached a leaf node, establish the data address and
                // add the resource to the map.

                pirde = (IMAGE_RESOURCE_DATA_ENTRY*) (pbRsrc + pEntries[i].OffsetToData);

                // Note that even when the resource data is in .rsrc1, the
                // directory entry is usually in .rsrc.

                if (pirde->OffsetToData <   m_pSections[m_iSectionRsrc].VirtualAddress
                    + m_pSections[m_iSectionRsrc].SizeOfRawData) {

                    // Data is in section .rsrc

                    ASSERT(pirde->OffsetToData >= m_pSections[m_iSectionRsrc].VirtualAddress);

                    pb =    GetFile()
                            +  m_pSections[m_iSectionRsrc].PointerToRawData
                            +  pirde->OffsetToData
                            -  m_pSections[m_iSectionRsrc].VirtualAddress;

                } else {

                    //  Data is in section .rsrc1

                    ASSERT(pirde->OffsetToData >=  m_pSections[m_iSectionRsrc1].VirtualAddress);
                    ASSERT(pirde->OffsetToData <   m_pSections[m_iSectionRsrc1].VirtualAddress
                           + m_pSections[m_iSectionRsrc1].SizeOfRawData);

                    pb =    GetFile()
                            +  m_pSections[m_iSectionRsrc1].PointerToRawData
                            +  pirde->OffsetToData
                            -  m_pSections[m_iSectionRsrc1].VirtualAddress;
                }


                OK(rm.AddResource(m_rk, pb, pirde->Size, pirde->CodePage));
            }
        }
        return S_OK;
    }



public:

    DWORD GetChecksum()      const {return m_pNtHeader->OptionalHeader.CheckSum;}
    DWORD GetTimeDateStamp() const {return m_pNtHeader->FileHeader.TimeDateStamp;}
    DWORD GetImageBase()     const {return m_pNtHeader->OptionalHeader.ImageBase;}
    DWORD GetSizeOfImage()   const {return m_pNtHeader->OptionalHeader.SizeOfImage;}
    BOOL  Is64BitImage()     const {return m_pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;}

    void  SetChecksum(DWORD dwChecksum) {m_pNtHeader->OptionalHeader.CheckSum=dwChecksum;}




    HRESULT Open(const char *pcFileName, BOOL fWrite) {

        int i;

        OK(MappedFile::Open(pcFileName, fWrite));


        MUST((    *(WORD*)m_pStart == IMAGE_DOS_SIGNATURE
                  &&  *(WORD*)(m_pStart+0x18) >= 0x40)    // WinVer >= 4
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC501: %s is not an executable file\n", pcFileName));

        m_pNtHeader = (IMAGE_NT_HEADERS*)(m_pStart + *(WORD*)(m_pStart+0x3c));

        MUST((m_pNtHeader->Signature == IMAGE_NT_SIGNATURE)
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC502: %s is not a Win32 executable file\n", pcFileName));

        if (Is64BitImage()) {
            m_pSections     = (IMAGE_SECTION_HEADER*)( (BYTE *) (m_pNtHeader+1) +
                                (IMAGE_SIZEOF_NT_OPTIONAL64_HEADER - IMAGE_SIZEOF_NT_OPTIONAL32_HEADER));
        } else {
            m_pSections     = (IMAGE_SECTION_HEADER*)(m_pNtHeader+1);
        }
        
        m_iSectionRsrc  = -1;
        m_iSectionRsrc1 = -1;

        // Locate the one or two resource sections

        for (i=0; i<m_pNtHeader->FileHeader.NumberOfSections; i++) {

            if (strcmp((char*)m_pSections[i].Name, ".rsrc") == 0) {

                m_iSectionRsrc        = i;

            } else if (strcmp((char*)m_pSections[i].Name, ".rsrc") == 0) {

                m_iSectionRsrc1        = i;
            }
        }

        MUST(m_iSectionRsrc >= 0
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC503: No resources in %s\n", pcFileName));
        ASSERT(m_iSectionRsrc > -1);   // Check for presence of resources

        return S_OK;
    }





    ////    MapResourceDirectory
    //
    //      Extract the resource directory into an STL map.


    HRESULT MapResourceDirectory(ResourceMap &rm) {

        OK(MapDirectory(
                       rm,
                       m_pStart + m_pSections[m_iSectionRsrc].PointerToRawData,
                       0, 0));

        if (m_iSectionRsrc1 >= 0) {
            OK(MapDirectory(
                           rm,
                           m_pStart + m_pSections[m_iSectionRsrc1].PointerToRawData,
                           0, 0));
        }

        return S_OK;
    }
};






////    High level operation
//
//      Controlling routines for the various modes of operation



ResourceMap  rmExecutable;      // Read and/or update
ResourceMap  rmUnlocalised;     // '-u' option - unlocalised resources for comparison






////    ApplyResource
//
//      Applies a given key and value to the executable resource map.
//
//      Tokens are merged with those already loaded from the executable
//      according to the update mode (append or replace).


HRESULT ApplyResource(ResourceKey &rk, ResourceValue *prv) {

    ResourceKey            rkUnloc;
    VersionInfo           *pviLoc;
    VersionInfo           *pviUnloc;
    ResourceMap::iterator  rmiUnloc;


    // Establish equivalent unlocalised key

    rkUnloc = rk;
    rkUnloc.SetLanguage(g_liUnlocalized);


    // First ensure that we keep the unlocalised version info, if we can

    if (    !(g_dwOptions & OPTVERSION)
            &&  !rk.prvId[0]->GetfString()
            &&  rk.prvId[0]->GetW() == 16          // VersionInfo
            &&  (rmiUnloc=rmExecutable.find(rkUnloc)) != NULL
            &&  rmiUnloc != rmExecutable.end()) {

        // Special case - keep unlocalised file and product versions

        if (rmiUnloc->second->pResource == NULL) {
            rmiUnloc->second->InterpretImage(rmiUnloc->first);
        }

        pviLoc   = static_cast<VersionInfo*>(prv->pResource);
        pviUnloc = static_cast<VersionInfo*>(rmiUnloc->second->pResource);
        if (pviLoc && pviUnloc) {
            pviLoc->SetStringFileInfo(L"FileVersion",    pviUnloc->GetStringFileInfo(L"FileVersion"));
            pviLoc->SetStringFileInfo(L"ProductVersion", pviUnloc->GetStringFileInfo(L"ProductVersion"));
            pviLoc->SetBinaryInfo(pviUnloc->GetBinaryInfo());
        }
    }




    if (rk.prvId[2]->GetW() == g_liUnlocalized) {

        // New token is not localized

        fprintf(stderr, "%s(", g_szResources);
        rk.fprint(stderr);

        if (rmExecutable.count(rk) == 0) {

            fprintf(stderr, "): warning RSRC110: Unlocalised resource from token file appended to executable\n");
            g_fWarn = TRUE;
            g_cResourcesAppended++;

        } else {

            fprintf(stderr, "): warning RSRC111: Unlocalised resource from token file replaced unlocalised resource in executable\n");
            g_fWarn = TRUE;
            g_cResourcesUpdated++;
        }

    } else if (rmExecutable.count(rk) > 0) {

        // New token already exists in executable

        fprintf(stderr, "%s(", g_szResources);
        rk.fprint(stderr);
        fprintf(stderr, "): warning RSRC112: Localised resource from token file replaced localised resource already present in executable\n");
        g_fWarn = TRUE;
        g_cResourcesUpdated++;

    } else if (g_dwOptions & OPTREPLACE) {

        // Replace operation
        //
        // Replace unlocalised resource with localised translation

        if (rmExecutable.count(rkUnloc) == 0) {

            fprintf(stderr, "%s(", g_szResources);
            rk.fprint(stderr);
            fprintf(stderr, "): warning RSRC113: Localised resource from token file appended to executable - there was no matching unlocalised resource\n");
            g_fWarn = TRUE;
            g_cResourcesAppended++;

        } else {

            // Normal operation: remove unlocalised resource from executable

            rmExecutable.erase(rkUnloc);

            g_cResourcesTranslated++;
        }

    } else {

        // Append operation

        g_cResourcesAppended++;
    }


    rmExecutable[rk] = prv;

    return S_OK;
}






////    ReadTokens
//
//      Scans the token file.
//
//      Selected resources are passed to ApplyResource


HRESULT ReadTokens(TextScanner &mfText) {

    ResourceKey             rk;
    ResourceValue          *prv;
    ResourceKey             rkUnlocalised;
    DWORD                   dwCodePage;
    DWORD                   dwUnlocChecksum;
    ResourceMap::iterator   rmiUnlocalised;
    DWORD                   liUnlocalised;   // Unlocalised language referenced by token


    while (mfText.GetRead() < mfText.GetLimit()) {

        OK(rk.ReadTok(&mfText));    // Read resource key
        OK(mfText.Expect(";"));


        if (    (    g_LangId != 0xffff
                     &&  rk.prvId[2]->GetW() != g_LangId)
                ||  !IsResourceWanted(rk)) {


            // Ignore this token


            g_cResourcesIgnored++;

            fprintf(stderr, "%s(", g_szResources);
            rk.fprint(stderr);

            if (g_LangId != 0xffff  &&  rk.prvId[2]->GetW() != g_LangId) {

                fprintf(stderr, "): warning RSRC120: Token file resource does not match specified language - ignored\n");
                g_fWarn = TRUE;

            } else {

                fprintf(stderr, "): warning RSRC121: Token file resource is not a requested resource type - ignored\n");
                g_fWarn = TRUE;
            }

            // Skip unwanted resource

            OK(mfText.SkipLn());
            while (*(char*)mfText.GetRead() == ' ') {
                OK(mfText.SkipLn());
            }


        } else {

            rmiUnlocalised = NULL;

            OK(mfText.ReadHex(&dwCodePage));

            if (*(char*)mfText.GetRead() == ',') {

                // There is unlocalised resource information available

                OK(mfText.Expect(","));
                OK(mfText.ReadHex(&dwUnlocChecksum));
                OK(mfText.Expect(","));
                OK(mfText.ReadHex(&liUnlocalised));

                // Check whether the unlocalised resource still exists in the
                // current executable, and has the same checksum,


                rkUnlocalised = rk;
                rkUnlocalised.SetLanguage(liUnlocalised);
                rmiUnlocalised = rmExecutable.find(rkUnlocalised);

                if (   rmiUnlocalised != rmExecutable.end()
                       && dwUnlocChecksum != rmiUnlocalised->second->Checksum()) {

                    fprintf(stderr, "%s: warning RSRC122: executable unlocalised resource checksum does not match checksum recorded in token file for resource ", mfText.GetTextPos());
                    rk.fprint(stderr);
                    fprintf(stderr, "\n");
                    g_fWarn = TRUE;
                }
            }

            OK(mfText.Expect(";"));

            if (*(char*)mfText.GetRead() == 'U') {

                // No resource content provided in token file
                // Use unlocalised resource from executable

                if (rmiUnlocalised == NULL) {

                    fprintf(stderr, "%s: error RSRC230: 'Unloc' token is missing unlocalised resource information for ", mfText.GetTextPos());
                    rk.fprint(stderr);
                    fprintf(stderr, "\n");
                    g_fError = TRUE;
                    return E_FAIL;
                }

                OK(mfText.Expect("Unloc"));
                OK(mfText.ExpectLn(""));

                if (rmiUnlocalised == rmExecutable.end()) {

                    fprintf(stderr, "%s: warning RSRC124: missing executable unlocalised resource for ", mfText.GetTextPos());
                    rk.fprint(stderr);
                    fprintf(stderr, " - localisation skipped\n");
                    g_fWarn = TRUE;

                } else {

                    MUST(ApplyResource(rk, rmiUnlocalised->second), ("%s: error RSRC231: Failed to apply unloc token\n", mfText.GetTextPos()));
                }

            } else {

                // Resource content is provided in token file

                if (rmiUnlocalised == rmExecutable.end()) {

                    fprintf(stderr, "%s: warning RSRC125: executable contains no unlocalised resource corresponding to resource ", mfText.GetTextPos());
                    rk.fprint(stderr);
                    fprintf(stderr, "\n");
                    g_fWarn = TRUE;
                }


                prv = new ResourceValue;
                ASSERT(prv != NULL);

                prv->dwCodePage = dwCodePage;
                prv->pb         = NULL;
                prv->cb         = 0;


                switch (*(char*)mfText.GetRead()) {

                    case 'H':  prv->pResource = new ResourceBinary;   break;
                    case 'D':  prv->pResource = new Dialog32;         break;
                    case 'M':  prv->pResource = new Menu32;           break;
                    case 'S':  prv->pResource = new String32;         break;
                    case 'V':  prv->pResource = new VersionInfo;      break;

                    default:
                        fprintf(stderr, "%s: error RSRC310: Unrecognised resource type for resource ", mfText.GetTextPos());
                        rk.fprint(stderr);
                        fprintf(stderr, "\n");
                        g_fError = TRUE;
                        return E_FAIL;
                }

                ASSERT(prv->pResource != NULL);

                // Parse selected resource

                OK(prv->pResource->ReadTok(mfText));
                OK(mfText.ExpectLn(NULL));

                // Save parsed resource in STL map

                MUST(ApplyResource(rk, prv), ("%s: error RSRC232: Failed to apply token\n", mfText.GetTextPos()));
            }
        }
    }

    return S_OK;
}








////    Stats
//
//


HRESULT Analyse(char *pExecutable) {

    Win32Executable                 w32x;
    NewFile                         nfText;
    ResourceMap::iterator           rmi;
    MappedResourceStats::iterator   mrsi;
    MappedLanguageStats::iterator   mlsi;
    char                            key[100];
    int                             i;
    const WCHAR                    *pwc;
    BOOL                            fLocalizable;


    MUST(w32x.Open(pExecutable, FALSE),
         ("RSRC : error RSRC510: Cannot open executable file %s\n", pExecutable));

    MUST(w32x.MapResourceDirectory(rmExecutable),
         ("RSRC : error RSRC511: cannot find resource directory in %s\n, pExecutable"));


    // Scan through the resources updating the stats

    fLocalizable = FALSE;

    for (rmi = rmExecutable.begin(); rmi != rmExecutable.end(); rmi++) {

        if (    rmi->first.prvId[0]->GetfString()
                ||  rmi->first.prvId[0]->GetW() != 16) {
            fLocalizable = TRUE;
        }

        OK(rmi->second->InterpretImage(rmi->first));

        UpdateStats(rmi->first,
                    rmi->second->pResource->GetItems(),
                    rmi->second->pResource->GetWords(),
                    rmi->second->pResource->cbBin());
    }


    if (!(g_dwOptions & OPTQUIET)) {
        fprintf(stdout, "\n   Resource type Count  Items  Words    Bytes\n");
        fprintf(stdout,   "   ------------ ------ ------ ------ --------\n");

        for (mrsi = ResourceStatsMap.begin(); mrsi != ResourceStatsMap.end(); mrsi++) {

            if (mrsi->first.GetfString()) {

                key[0] = '\"';
                i=0;
                pwc = mrsi->first.GetString();
                while (i < min(10, mrsi->first.GetLength())) {

                    key[i+1] = (char) pwc[i];
                    i++;
                }

                key[i+1] = '\"';
                key[i+2] = 0;

                fprintf(stdout, "   %-12.12s ", key);

            } else {

                switch (mrsi->first.GetW()) {
                    case 1:  fprintf(stdout, "   1  (Cursor)  "); break;
                    case 2:  fprintf(stdout, "   2  (Bitmap)  "); break;
                    case 3:  fprintf(stdout, "   3  (Icon)    "); break;
                    case 4:  fprintf(stdout, "   4  (Menu)    "); break;
                    case 5:  fprintf(stdout, "   5  (Dialog)  "); break;
                    case 6:  fprintf(stdout, "   6  (String)  "); break;
                    case 7:  fprintf(stdout, "   7  (Fnt dir) "); break;
                    case 8:  fprintf(stdout, "   8  (Font)    "); break;
                    case 9:  fprintf(stdout, "   9  (Accel)   "); break;
                    case 10: fprintf(stdout, "   a  (RCDATA)  "); break;
                    case 11: fprintf(stdout, "   b  (Msgtbl)  "); break;
                    case 16: fprintf(stdout, "   10 (Version) "); break;
                    default: fprintf(stdout, "   %-12x ", mrsi->first.GetW());
                }
            }

            fprintf(stdout, "%6d ",  mrsi->second.cResources);

            if (mrsi->second.cItems > 0) {
                fprintf(stdout, "%6d ",  mrsi->second.cItems);
            } else {
                fprintf(stdout, "       ");
            }
            if (mrsi->second.cWords > 0) {
                fprintf(stdout, "%6d ",  mrsi->second.cWords);
            } else {
                fprintf(stdout, "       ");
            }
            fprintf(stdout, "%8d\n",  mrsi->second.cBytes);
        }


        fprintf(stdout, "\n   Language  Resources  Items  Words    Bytes\n");
        fprintf(stdout,   "   --------  --------- ------ ------ --------\n");

        for (mlsi = LanguageStatsMap.begin(); mlsi != LanguageStatsMap.end(); mlsi++) {

            fprintf(stdout, "   %8x  %9d ",
                    mlsi->first, mlsi->second.cResources);

            if (mlsi->second.cItems > 0) {
                fprintf(stdout, "%6d ",  mlsi->second.cItems);
            } else {
                fprintf(stdout, "       ");
            }

            if (mlsi->second.cWords > 0) {
                fprintf(stdout, "%6d ",  mlsi->second.cWords);
            } else {
                fprintf(stdout, "       ");
            }

            fprintf(stdout, "%8d\n",  mlsi->second.cBytes);
        }

        fprintf(stdout, "\n");
    }


    if (!fLocalizable) {
        fprintf(stderr, "RSRC : warning RSRC170: No localizable resources in %s\n", pExecutable);
        g_fWarn = TRUE;
    }


    SHOULD(w32x.Close(), ("RSRC : warning RSRC171: could not close executable\n"));

    return S_OK;
}






HRESULT ExtractResources(char *pExecutable, char *pResources) {

    Win32Executable    w32x;
    Win32Executable    w32xUnloc;
    NewFile            nfText;
    char               str[100];
    DWORD              dw;


    MUST(w32x.Open(g_szExecutable, FALSE),
         ("RSRC : error RSRC510: Cannot open executable file %s\n", g_szExecutable));

    MUST(nfText.OpenWrite(g_szResources),
         ("RSRC : error RSRC512: Cannot create resource token file %s\n", g_szResources));

    // Write header

    if (!(g_dwOptions & OPTHEXDUMP)) {
        OK(nfText.WriteS("\xef\xbb\xbf\r\n"));    // UTF-8 mark for notepad, richedit etc.
    }
    OK(nfText.WriteS("###     "));
    OK(nfText.WriteS(g_szResources));
    OK(nfText.WriteS("\r\n#\r\n#       Extracted:  "));
    GetDateFormatA(
                  MAKELCID(LANG_ENGLISH, SORT_DEFAULT),
                  0, NULL,
                  "yyyy/MM/dd ",
                  str, sizeof(str));
    OK(nfText.WriteS(str));
    GetTimeFormatA(
                  MAKELCID(LANG_ENGLISH, SORT_DEFAULT),
                  0, NULL,
                  "HH:mm:ss\'\r\n#       By:         \'",
                  str, sizeof(str));
    OK(nfText.WriteS(str));
    dw = sizeof(str);
    GetComputerNameA(str, &dw);
    OK(nfText.WriteS(str));
    OK(nfText.WriteS("\r\n#       Executable: "));
    OK(nfText.WriteS(g_szExecutable));

    if (g_LangId != 0xffff) {
        OK(nfText.WriteS("\r\n#       Language:   "));
        OK(nfText.WriteHex(g_LangId, 3));
    }

    if (g_dwProcess != PROCESSALL) {
        OK(nfText.WriteS("\r\n#       Res types:  "));
        OK(nfText.WriteS(g_szTypes));
    }

    OK(nfText.WriteS("\r\n\r\n"));


    MUST(w32x.MapResourceDirectory(rmExecutable),
         ("RSRC : error RSRC511: cannot find resource directory in %s\n, g_szExecutable"));


    if (g_dwOptions & OPTUNLOC) {

        // Write tokens that differ from specified unlocalised executable

        MUST(w32xUnloc.Open(g_szUnloc, FALSE),
             ("RSRC : error RSRC513: Cannot open unlocalised executable file %s\n", g_szUnloc));

        MUST(w32xUnloc.MapResourceDirectory(rmUnlocalised),
             ("RSRC : error RSRC514: cannot find resource directory in unlocalised executable %s\n, g_szUnloc"));

        MUST(rmExecutable.WriteTokens(nfText, &rmUnlocalised),
             ("RSRC : error RSRC515: cannot write delta token file %s\n, g_szResources"));

        w32xUnloc.Close();

    } else {

        MUST(rmExecutable.WriteTokens(nfText, NULL),
             ("RSRC : error RSRC516: cannot write stand alone token file %s\n, g_szResources"));
    }


    if (!(g_dwOptions & OPTQUIET)) {
        fprintf(stdout, "\n%d resource(s) %s.\n", g_cResourcesExtracted, g_dwOptions & OPTHEXDUMP ? "dumped" : "tokenized");

        if (g_cResourcesIgnored) {
            fprintf(stdout, "%d resource(s) ignored.\n", g_cResourcesIgnored);
        }
    }

    OK(w32x.Close());
    OK(nfText.Close());

    return S_OK;
}






////    UpdateResources
//
//      Update resources in executable with tokens from given text
//
//      Processing
//
//      1. Existing resources are loaded into the map as ResourceBinaries.
//      2. Resources are merged in from the token file according to
//         command line selected processing options
//      3. The NT UpdateResource API set is used to replace all the resources
//         in the executable with the merged resources in the map.


HRESULT UpdateResources(char *pExecutable, char *pResources, char* pSymbols) {

    Win32Executable  w32x;
    SymbolFile       symf;
    MappedFile       mfText;
    MappedFile       mfSymbols;
    DWORD            dwCheckSum;

    MUST(w32x.Open(pExecutable, FALSE),
         ("RSRC : error RSRC510: Cannot open executable file %s\n", pExecutable));

    MUST(mfText.Open(pResources, FALSE),
         ("RSRC : error RSRC520: Cannot open resource token file %s\n", pResources));

    MUST(mfText.Expect("\xef\xbb\xbf"),
         ("RSRC : error RSRC521: UTF8 BOM missing from token file\n"));      // UTF-8 mark for notepad, richedit etc.

    OK(mfText.ExpectLn(""));                // Skip over header comments

    if (g_dwOptions & OPTSYMBOLS) {
        if (    SUCCEEDED(mfSymbols.Open(pSymbols, TRUE))
                &&  SUCCEEDED(symf.Open(&mfSymbols))) {

            if (    symf.GetChecksum()  != w32x.GetChecksum()
                    ||  symf.GetImageBase() != w32x.GetImageBase()) {

                time_t tsTime = symf.GetTimeDateStamp();
                time_t teTime = w32x.GetTimeDateStamp();
                char   ssTime[30]; strcpy(ssTime, ctime(&tsTime)); ssTime[19] = 0;
                char   seTime[30]; strcpy(seTime, ctime(&teTime)); seTime[19] = 0;

                fprintf(stderr, "\n   Symbol mismatch:       Executable        Symbol file\n");
                fprintf(stderr,   "      ImageBase:            %8x           %8x\n", w32x.GetImageBase(), symf.GetImageBase());
                fprintf(stderr,   "      Checksum:             %8x           %8x\n", w32x.GetChecksum(), symf.GetChecksum());
                fprintf(stderr,   "      Timestamp:     %-15.15s    %-15.15s\n\n", ssTime+4, seTime+4);

                fprintf(stderr, "RSRC : warning RSRC160: Symbol file does not match exectable\n");
                g_fWarn = TRUE;
            }

        } else {

            fprintf(stderr, "RSRC : warning RSRC161: Symbol file not processed\n");
            g_fWarn = TRUE;
            g_dwOptions &= ~OPTSYMBOLS;
        }

    }

    // Load existing resources

    MUST(w32x.MapResourceDirectory(rmExecutable),
         ("RSRC : error RSRC530: Cannot read executable resources from %s\n", pExecutable));

    OK(rmExecutable.CopyResources()); // Take local copy before closing the mapped file

    OK(w32x.Close());


    // Merge in resources from token file

    MUST(ReadTokens(mfText), ("RSRC : error RSRC531: Failed reading update tokens\n"));

    OK(rmExecutable.UpdateWin32Executable(pExecutable));



    // Update was succesful, Recalculate checksum

    SHOULD(w32x.Open(pExecutable, TRUE),
           ("RSRC : warning RSRC162: Could not reopen executable %s to update checksum\n", pExecutable));

    dwCheckSum = w32x.CalcChecksum();

    w32x.SetChecksum(dwCheckSum);

    if (g_dwOptions & OPTSYMBOLS) {
        symf.SetChecksum(dwCheckSum);
        symf.SetTimeDateStamp(w32x.GetTimeDateStamp());
        symf.SetSizeOfImage(w32x.GetSizeOfImage());
        SHOULD(mfSymbols.Close(), ("RSRC : warning RSRC163: Failed to write updated symbol checksum\n"));
    }

    w32x.Close();


    if (!(g_dwOptions & OPTQUIET)) {

        fprintf(stdout, "\n");

        if (g_cResourcesTranslated) {
            fprintf(stdout, "%d resource(s) translated.\n", g_cResourcesTranslated);
        }

        if (g_cResourcesAppended) {
            fprintf(stdout, "%d resource(s) appended.\n", g_cResourcesAppended);
        }

        if (g_cResourcesUpdated) {
            fprintf(stdout, "%d resource(s) updated.\n", g_cResourcesUpdated);
        }

        if (g_cResourcesIgnored) {
            fprintf(stdout, "%d resource(s) ignored.\n", g_cResourcesIgnored);
        }
    }

    mfText.Close();

    return S_OK;
}





////    Parameter parsing
//
//


char g_cSwitch = '-';   // Switch character is recorded the first time one is seen


void SkipWhitespace(char** p, char* pE) {
    while ((*p<pE) && ((**p==' ')||(**p==9))) (*p)++;
}


void ParseToken(char** p, char* pE, char* s, int l) {

    // Parse up to whitespace into string s
    // Guarantee zero terminator and modify no more than l chars
    // Return with p beyond whitespace


    if (*p < pE  &&  **p == '\"') {

        // Quoted parameter

        (*p)++;  // Skip over leading quote

        while (l>0  &&  *p<pE  &&  **p!='\"') {
            *s=**p;  s++;  (*p)++;  l--;
        }

        // Skip any part of token that didn't fit s

        while (*p<pE  &&  **p!='\"') { // Skip up to terminating quote
            (*p)++;
        }

        if (*p<pE) { // Skip over terminating quote
            (*p)++;
        }

    } else {

        // Unquoted parameter


        while ((l>0) && (*p<pE) && (**p>' ')) {
            *s=**p;  s++;  (*p)++;
            l--;
        }

        // Skip any part of token that didn't fit into s
        while ((*p<pE) && (**p>' ')) (*p)++;
    }


    if (l>0)
        *s++ = 0;
    else
        *(s-1) = 0;

    SkipWhitespace(p, pE);
}


void ParseName(char** p, char* pE, char* s, int l) {

    // Uses ParseToken to parse a name such as a filename.
    // If the name starts with '/' or '-' it is assumed to be
    // an option rather than a filename and ParseName returns
    // a zero length string.

    if (*p<pE  &&  **p==g_cSwitch) {

        // This is an option and should not be treated as a name argument

        s[0] = 0;

    } else {

        ParseToken(p, pE, s, l);
    }
}





void DisplayUsage() {
    fprintf(stdout, "Usage: rsrc -h\n");
    fprintf(stdout, "   or: rsrc  executable [-l LangId] [-i include-opts] [-q]\n");
    fprintf(stdout, "             [   [-t|-d] [text-output] [-c unloc]\n");
    fprintf(stdout, "               | [-a|-r] [text-input]  [-s symbols] ]\n");
}

void DisplayArgs() {
    fprintf(stdout, "\nArguments\n\n");
    fprintf(stdout, "   -h         Help\n");
    fprintf(stdout, "   -q         Quiet (default is to show resource stats)\n");
    fprintf(stdout, "   -t tokens  Write resources in checkin format to token file\n");
    fprintf(stdout, "   -c unloc   Unlocalised executable for comparison\n");
    fprintf(stdout, "   -d tokens  Write resources in hex dump format to token file\n");
    fprintf(stdout, "   -a tokens  Append resources from token file to executable (multi-language update)\n");
    fprintf(stdout, "   -r tokens  Replace executable resources from token file (single language update)\n");
    fprintf(stdout, "   -s symbol  Symbol file whose checksum is to track the executable checksum\n");
    fprintf(stdout, "   -l lang    Restrict processing to language specified in hex\n");
    fprintf(stdout, "   -u unlocl  Unlocalised langauge, default 409\n");
    fprintf(stdout, "   -i opts    Include only resource types specified:\n\n");
    fprintf(stdout, "                 c - Cursors               t - Fonts\n");
    fprintf(stdout, "                 b - Bitmaps               a - Accelerators\n");
    fprintf(stdout, "                 i - Icons                 r - RCDATAs\n");
    fprintf(stdout, "                 m - Menus                 g - Message tables\n");
    fprintf(stdout, "                 d - Dialogs               v - Versions info\n");
    fprintf(stdout, "                 s - Strings               x - Binary data\n");
    fprintf(stdout, "                 f - Font directories      n - INFs\n");
    fprintf(stdout, "                 o - all others            a - All (default)\n\n");
    fprintf(stdout, "   Examples\n\n");
    fprintf(stdout, "       rsrc notepad.exe               - Show resource stats for notepad.exe\n");
    fprintf(stdout, "       rsrc notepad.exe -t            - Extract tokens to notepad.exe.rsrc\n");
    fprintf(stdout, "       rsrc notepad.exe -r -l 401     - Translate from US using Arabic tokens in notepad.exe.rsrc\n");
    fprintf(stdout, "       rsrc notepad.exe -d dmp -i im  - Hexdump of Icons and Menus to dmp\n\n");
}





HRESULT ProcessParameters() {

    char   *p;      // Current command line character
    char   *pE;     // End of command line
    char   *pcStop;

    char    token      [MAXPATH];
    char    arg        [MAXPATH];
    char    symbols    [MAXPATH] = "";

    int     i,j;
    int     cFiles;
    DWORD   cRes;
    BOOL    fArgError;

    p  = GetCommandLine();
    pE = p+strlen((char *)p);


    g_dwOptions  = 0;
    g_dwProcess  = 0;
    cFiles       = 0;
    fArgError    = FALSE;
    g_szResources[0] = 0;


    // Skip command name
    ParseToken(&p, pE, token, sizeof(token));

    while (p<pE) {
        ParseToken(&p, pE, token, sizeof(token));

        if (    token[0] == '-'
                ||  token[0] == '/') {

            // Process command option(s)

            i = 1;
            g_cSwitch = token[0];       // Argument may start with the other switch character
            CharLower((char*)token);
            while (token[i]) {
                switch (token[i]) {
                    case '?':
                    case 'h': g_dwOptions |= OPTHELP;      break;
                    case 'v': g_dwOptions |= OPTVERSION;   break;
                    case 'q': g_dwOptions |= OPTQUIET;     break;

                    case 't': g_dwOptions |= OPTEXTRACT;   ParseName(&p, pE, g_szResources, sizeof(g_szResources));  break;
                    case 'c': g_dwOptions |= OPTUNLOC;     ParseName(&p, pE, g_szUnloc,     sizeof(g_szUnloc));      break;
                    case 'd': g_dwOptions |= OPTHEXDUMP;   ParseName(&p, pE, g_szResources, sizeof(g_szResources));  break;
                    case 'a': g_dwOptions |= OPTAPPEND;    ParseName(&p, pE, g_szResources, sizeof(g_szResources));  break;
                    case 'r': g_dwOptions |= OPTREPLACE;   ParseName(&p, pE, g_szResources, sizeof(g_szResources));  break;
                    case 's': g_dwOptions |= OPTSYMBOLS;   ParseName(&p, pE, symbols,       sizeof(g_szResources));  break;

                    case 'l':
                        ParseToken(&p, pE, arg, sizeof(arg));
                        g_LangId = strtol(arg, &pcStop, 16);
                        if (*pcStop != 0) {
                            fprintf(stderr, "Localized language id contains invalid hex digit '%c'.\n", *pcStop);
                            fArgError = TRUE;
                        }
                        break;

                    case 'u':
                        ParseToken(&p, pE, arg, sizeof(arg));
                        g_liUnlocalized = strtol(arg, &pcStop, 16);
                        if (*pcStop != 0) {
                            fprintf(stderr, "Unlocalized language id contains invalid hex digit '%c'.\n", *pcStop);
                            fArgError = TRUE;
                        }
                        break;

                    case 'i':
                        ParseToken(&p, pE, g_szTypes, sizeof(g_szTypes));
                        g_dwProcess = 0;
                        j = 0;
                        while (g_szTypes[j]) {
                            switch (g_szTypes[j]) {
                                case 'c': g_dwProcess |= PROCESSCUR;  break;
                                case 'b': g_dwProcess |= PROCESSBMP;  break;
                                case 'i': g_dwProcess |= PROCESSICO;  break;
                                case 'm': g_dwProcess |= PROCESSMNU;  break;
                                case 'd': g_dwProcess |= PROCESSDLG;  break;
                                case 's': g_dwProcess |= PROCESSSTR;  break;
                                case 'f': g_dwProcess |= PROCESSFDR;  break;
                                case 't': g_dwProcess |= PROCESSFNT;  break;
                                case 'a': g_dwProcess |= PROCESSACC;  break;
                                case 'r': g_dwProcess |= PROCESSRCD;  break;
                                case 'g': g_dwProcess |= PROCESSMSG;  break;
                                case 'v': g_dwProcess |= PROCESSVER;  break;
                                case 'x': g_dwProcess |= PROCESSBIN;  break;
                                case 'n': g_dwProcess |= PROCESSINF;  break;
                                case 'o': g_dwProcess |= PROCESSOTH;  break;
                                case 'A': g_dwProcess |= PROCESSALL;  break;
                                default:
                                    fprintf(stderr, "Unrecognised resource type '%c'.\n", g_szTypes[j]);
                                    fArgError = TRUE;
                            }
                            j++;
                        }
                        break;

                    default:
                        fprintf(stderr, "Unrecognised argument '%c'.\n", token[i]);
                        fArgError = TRUE;
                        break;
                }
                i++;
            }

        } else {

            // Process filename

            switch (cFiles) {
                case 0:  strcpy(g_szExecutable, token); break;
            }
            cFiles++;
        }
    }


    if (g_dwOptions & OPTHELP) {

        fprintf(stderr, "\nRsrc - Manage Win32 executable resources.\n\n");
        DisplayUsage();
        DisplayArgs();
        return S_OK;

    }



    // Validate option combinations

    if (g_dwOptions & OPTEXTRACT) {

        if (g_dwOptions & (OPTHEXDUMP | OPTAPPEND | OPTREPLACE | OPTSYMBOLS)) {

            fprintf(stderr, "RSRC : error RSRC400: -t (tokenise) option excludes -d, -a, -r, and -s\n");
            fArgError = TRUE;
        }

    } else if (g_dwOptions & OPTHEXDUMP) {

        if (g_dwOptions & (OPTEXTRACT | OPTUNLOC | OPTAPPEND | OPTREPLACE | OPTSYMBOLS)) {

            fprintf(stderr, "RSRC : error RSRC401: -d (dump) option excludes -t, -u, -a, -r, and -s\n");
            fArgError = TRUE;
        }

    } else if (g_dwOptions & OPTAPPEND) {

        if (g_dwOptions & (OPTEXTRACT | OPTHEXDUMP | OPTUNLOC | OPTREPLACE)) {

            fprintf(stderr, "RSRC : error RSRC402: -a (append) option excludes -t, -d, -u, and -r\n");
            fArgError = TRUE;
        }

    } else if (g_dwOptions & OPTREPLACE) {

        if (g_dwOptions & (OPTEXTRACT | OPTHEXDUMP | OPTUNLOC | OPTAPPEND)) {

            fprintf(stderr, "RSRC : error RSRC403: -r (replace) option excludes -t, -d, -u, and -a\n");
            fArgError = TRUE;
        }

        if (g_LangId == 0xFFFF) {

            fprintf(stderr, "RSRC : error RSRC404: -r (replace) option requires -l (LangId)\n");
            fArgError = TRUE;
        }

    } else {

        if (g_dwOptions & (OPTSYMBOLS)) {

            fprintf(stderr, "RSRC : error RSRC405: Analysis excludes -s\n");
            fArgError = TRUE;
        }


    }



    if (fArgError) {

        DisplayUsage();
        DisplayArgs();
        return E_INVALIDARG;

    } else if (cFiles != 1) {

        fprintf(stderr, "\nRsrc : error RSRC406: must specify at least an executable file name.\n\n");
        DisplayUsage();
        return E_INVALIDARG;

    } else {

        // We have valid parameters

        if (g_dwProcess == 0) {
            g_dwProcess = PROCESSALL;
        }

        if (!(g_dwOptions & OPTQUIET)) {
            fprintf(stdout, "\nRsrc - Manage executable resources.\n\n");
            fprintf(stdout, "   Executable file: %s\n", g_szExecutable);

            if (g_szResources[0]) {
                fprintf(stdout, "   Resource file:   %s\n", g_szResources);
            }

            if (symbols[0]) {
                fprintf(stdout, "   Symbol file:     %s\n", symbols);
            }

            if (g_LangId != 0xffff) {
                char szLang[50] = "";
                char szCountry[50] = "";
                GetLocaleInfoA(g_LangId, LOCALE_SENGLANGUAGE, szLang, sizeof(szLang));
                GetLocaleInfoA(g_LangId, LOCALE_SENGCOUNTRY,  szCountry, sizeof(szCountry));
                fprintf(stdout, "   Language:        %x (%s - %s)\n", g_LangId, szLang, szCountry);
            }

            if (g_dwProcess != PROCESSALL) {
                fprintf(stdout, "   Include only:    %s\n", g_szTypes);
            }
        }

        cRes = 0;


        // Handle default token file name

        if (g_szResources[0] == 0) {
            strcpy(g_szResources, g_szExecutable);
            strcat(g_szResources, ".rsrc");
        }


        if (g_dwOptions & (OPTAPPEND | OPTREPLACE)) {

            // Update an executable from tokens

            MUST(UpdateResources(g_szExecutable, g_szResources, symbols), ("RSRC : error RSRC420: Update failed.\n"));

        } else if (g_dwOptions & (OPTEXTRACT | OPTHEXDUMP)) {

            // Generate tokens from an executable

            MUST(ExtractResources(g_szExecutable, g_szResources), ("RSRC : error RSRC421: Token extraction failed.\n"));

        } else {

            // Analyse an executable

            MUST(Analyse(g_szExecutable), ("RSRC : error RSRC422: Analysis failed.\n"));

        }

        return S_OK;
    }
}






int _cdecl main(void) {

    if (SUCCEEDED(ProcessParameters())) {

        if (!g_fWarn) {

            return 0;       // No problems

        } else {

            return 1;       // Warning(s) but no error(s)
        }

    } else {

        return 2;           // Error(s)

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\common\rw32hlpr.cpp ===
//////////////////////////////////////////////
//
// This file has the helper function used in the win32 r/w
// I copied them in this file to share them with the res32 r/w
//
#include <afxwin.h>
#include ".\rwdll.h"
#include ".\rw32hlpr.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
BYTE sizeofByte = sizeof(BYTE);
BYTE sizeofWord = sizeof(WORD);
BYTE sizeofDWord = sizeof(DWORD);
BYTE sizeofDWordPtr = sizeof(DWORD_PTR);

char szCaption[MAXSTR];
char szUpdCaption[MAXSTR];
WCHAR wszUpdCaption[MAXSTR];
CWordArray wIDArray;

#define DIALOGEX_VERION 1

/////////////////////////////////////////////////////////////////////////////
// Global settings, like code page and append options
UINT g_cp = CP_ACP;     // Default to CP_ACP
BOOL g_bAppend = FALSE; // Default to FALSE
BOOL g_bUpdOtherResLang = TRUE; // Default to FALSE
char g_char[] = " ";    // Default char for WideChartoMultiByte

VOID InitGlobals()
{
    // Make sure we are using the right code page and global settings
    // Get the pointer to the function
    HINSTANCE hDllInst = LoadLibrary("iodll.dll");
    if (hDllInst)
    {
        UINT (FAR PASCAL * lpfnGetSettings)(LPSETTINGS);
        // Get the pointer to the function to get the settings
        lpfnGetSettings = (UINT (FAR PASCAL *)(LPSETTINGS))
                     GetProcAddress( hDllInst, "RSGetGlobals" );
        if (lpfnGetSettings!=NULL) {
            SETTINGS settings;
            (*lpfnGetSettings)(&settings);

            g_cp      = settings.cp;
            g_bAppend = settings.bAppend;
            strcpy( g_char, settings.szDefChar );
        }
        FreeLibrary(hDllInst);
    }
}

#define _A_RLT_NULL_ "_RLT32_NULL_"
WCHAR _W_RLT_NULL_[] = L"_RLT32_NULL_";
int   _NULL_TAG_LEN_ = wcslen(_W_RLT_NULL_);
////////////////////////////////////////////////////////////////////////////
// Helper Function Implementation
UINT GetNameOrOrdU( PUCHAR pRes,
            ULONG ulId,
            LPWSTR lpwszStrId,
            DWORD* pdwId )
{

    if (ulId & IMAGE_RESOURCE_NAME_IS_STRING) {
        PIMAGE_RESOURCE_DIR_STRING_U pStrU = (PIMAGE_RESOURCE_DIR_STRING_U)((BYTE *)pRes
            + (ulId & (~IMAGE_RESOURCE_NAME_IS_STRING)));

        for (USHORT usCount=0; usCount < pStrU->Length ; usCount++) {
            *(lpwszStrId++) = LOBYTE(pStrU->NameString[usCount]);
        }
        *(lpwszStrId++) = 0x0000;
        *pdwId = 0;
    } else {
        *lpwszStrId = 0x0000;
        *pdwId = ulId;
    }

    return ERROR_NO_ERROR;
}

UINT _MBSTOWCS( WCHAR * pwszOut, CHAR * pszIn, UINT nLength)
{
    //
    // Check if we have a pointer to the function
    //

    int rc = MultiByteToWideChar(
        g_cp,           // UINT CodePage,
        0,              // DWORD dwFlags,
        pszIn,          // LPCSTR lpMultiByteStr,
        -1,             // int cchMultiByte,
        pwszOut,        // unsigned int far * lpWideCharStr,           // LPWSTR
        nLength );      // int cchWideChar

    return rc;
}

UINT _WCSTOMBS( CHAR* pszOut, WCHAR* pwszIn, UINT nLength)
{
    BOOL Bool = FALSE;

    int rc = WideCharToMultiByte(
        g_cp,           // UINT CodePage,
        0,              // DWORD dwFlags,
        pwszIn,         // const unsigned int far * lpWideCharStr,     // LPCWSTR
        -1,             // int cchWideChar,
        pszOut,         // LPSTR lpMultiByteStr,
        nLength,        // int cchMultiByte,
        g_char,        // LPCSTR lpDefaultChar,
        &Bool);         // BOOL far * lpUsedDefaultChar);              // LPBOOL

    return  rc;
}

UINT _WCSLEN( WCHAR * pwszIn )
{
    UINT n = 0;

    while( *(pwszIn+n)!=0x0000 ) n++;
    return( n + 1 );
}


BYTE
PutByte( BYTE far * far* lplpBuf, BYTE bValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofByte){
        memcpy(*lplpBuf, &bValue, sizeofByte);
        *lplpBuf += sizeofByte;
        *pdwSize -= sizeofByte;
    } else *pdwSize = -1;
    return sizeofByte;
}


UINT
PutNameOrOrd( BYTE far * far* lplpBuf,  WORD wOrd, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if (wOrd) {
        uiSize += PutWord(lplpBuf, 0xFFFF, pdwSize);
        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
    } else {
        uiSize += PutStringW(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


UINT
PutCaptionOrOrd( BYTE far * far* lplpBuf,  WORD wOrd, LPSTR lpszText, LONG* pdwSize,
	WORD wClass, DWORD dwStyle )
{
    UINT uiSize = 0;

    // If this is an ICON then can just be an ID
    // Fix bug in the RC compiler
    /*
    if( (wClass==0x0082) && ((dwStyle & 0xF)==SS_ICON) ) {
    	if (wOrd) {
	    	uiSize += PutWord(lplpBuf, 0xFFFF, pdwSize);
	        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
	        return uiSize;
    	} else {
    		// put nothing
    		return 0;
    	}
    }
    */
    if (wOrd) {
        uiSize += PutWord(lplpBuf, 0xFFFF, pdwSize);
        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
    } else {
        uiSize += PutStringW(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


UINT
PutStringA( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    int iSize = strlen(lpszText)+1;
    if (*pdwSize>=iSize){
        memcpy(*lplpBuf, lpszText, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else *pdwSize = -1;
    return iSize;
}


UINT
PutStringW( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    int iSize = strlen(lpszText)+1;
    if (*pdwSize>=(iSize*2)){
        WCHAR* lpwszStr = new WCHAR[(iSize*2)];
        if (!lpwszStr) *pdwSize =0;
        else {
            SetLastError(0);
            iSize = _MBSTOWCS( lpwszStr, lpszText, iSize*2 );
            // Check for error
            if(GetLastError())
                return ERROR_DLL_LOAD;
            memcpy(*lplpBuf, lpwszStr, (iSize*2));
            *lplpBuf += (iSize*2);
            *pdwSize -= (iSize*2);
            delete lpwszStr;
        }
    } else *pdwSize = -1;
    return (iSize*2);
}



BYTE
PutWord( BYTE far * far* lplpBuf, WORD wValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofWord){
        memcpy(*lplpBuf, &wValue, sizeofWord);
        *lplpBuf += sizeofWord;
        *pdwSize -= sizeofWord;
    } else *pdwSize = -1;
    return sizeofWord;
}


BYTE
PutDWord( BYTE far * far* lplpBuf, DWORD dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWord){
        memcpy(*lplpBuf, &dwValue, sizeofDWord);
        *lplpBuf += sizeofDWord;
        *pdwSize -= sizeofDWord;
    } else *pdwSize = -1;
    return sizeofDWord;
}

BYTE
PutDWordPtr( BYTE far * far* lplpBuf, DWORD_PTR dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWordPtr){
        memcpy(*lplpBuf, &dwValue, sizeofDWordPtr);
        *lplpBuf += sizeofDWordPtr;
        *pdwSize -= sizeofDWordPtr;
    } else *pdwSize = -1;
    return sizeofDWordPtr;
}

 DWORD CalcID( WORD wId, BOOL bFlag )
{
    // We want to calculate the ID Relative to the WORD wId
    // If we have any other ID with the same value then we return
    // the incremental number + the value.
    // If no other Item have been found then the incremental number will be 0.
    // If bFlag = TRUE then the id get added to the present list.
    // If bFlag = FALSE then the list is reseted and the function return

    // Clean the array if needed
    if(!bFlag) {
        wIDArray.RemoveAll();
		wIDArray.SetSize(30, 1);
        return 0;
    }

    // Add the value to the array
    wIDArray.Add(wId);

    // Walk the array to get the number of duplicated ID
    int c = -1; // will be 0 based
    for(INT_PTR i=wIDArray.GetUpperBound(); i>=0 ; i-- ) {
        if (wIDArray.GetAt(i)==wId)
            c++;
    }
    TRACE3("CalcID: ID: %d\tPos: %d\tFinal: %u\n", wId, c, MAKELONG( wId, c ));


    return MAKELONG( wId, c );
}


UINT
ParseAccel( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    typedef struct accelerator {
        WORD fFlags;
        WORD wAscii;
        WORD wId;
        WORD padding;
    } ACCEL, *PACCEL;

    PACCEL pAcc = (PACCEL)lpImage;

    // Reset the IDArray
    CalcID(0, FALSE);
    // get the number of entry in the table
    for( int cNumEntry =(int)(dwImageSize/sizeof(ACCEL)), c=1; c<=cNumEntry ; c++)
    {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a menu
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)pAcc->wAscii, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)pAcc->fFlags, &dwBufSize);
        //Put the MenuId
        dwOverAllSize += PutDWord( &lpBuf, CalcID(pAcc->wId, TRUE), &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);

        // Put the size of the resource
        if (dwBufSize>=0) {
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }

        // Move to the next position
        if (dwBufSize>0)
            lpItem = lpBuf;
        pAcc++;
    }

    return (UINT)(dwOverAllSize);
}

UINT GenerateAccel( LPVOID lpNewBuf, LONG dwNewSize,
                    LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    BYTE * lpNewImage = (BYTE *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE * lpBuf = (BYTE *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    typedef struct accelerator {
        WORD fFlags;
        WORD wAscii;
        WORD wId;
        WORD padding;
    } ACCEL, *PACCEL;

    ACCEL acc;
    BYTE bAccSize = sizeof(ACCEL);

    LONG  dwOverAllSize = 0l;

    while(dwNewSize>0) {
        if (dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            acc.wId = LOWORD(lpResItem->dwItemID);
            acc.fFlags = (WORD)lpResItem->dwFlags;
            acc.wAscii = (WORD)lpResItem->dwStyle;
            acc.padding = 0;
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if (dwNewSize<=0) {
            // Last Item in the accel table, mark it
            acc.fFlags = acc.fFlags | 0x80;
        }
        TRACE3("Accel: wID: %hd\t wAscii: %hd\t wFlag: %hd\n", acc.wId, acc.wAscii, acc.fFlags);

        if(bAccSize<=dwNewImageSize)
        {
            memcpy(lpNewImage, &acc, bAccSize);
            dwNewImageSize -= bAccSize;
            lpNewImage = lpNewImage+bAccSize;
            dwOverAllSize += bAccSize;
        }
        else dwOverAllSize += bAccSize;

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad16((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


UINT
UpdateAccel( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;
    TRACE("Update Accelerators:\n");
    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    WORD wDummy;
    //Old Items
    WORD fFlags = 0;
    WORD wEvent = 0;
    WORD wId = 0;
    WORD wPos = 0;

    // Updated items
    WORD fUpdFlags = 0;
    WORD wUpdEvent = 0;
    WORD wUpdId = 0;
    WORD wUpdPos = 0;

    LONG  dwOverAllSize = 0l;


    while(dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        GetWord( &lpOldImage, &fFlags, &dwOldImageSize );
        GetWord( &lpOldImage, &wEvent, &dwOldImageSize );
        GetWord( &lpOldImage, &wId, &dwOldImageSize );
        GetWord( &lpOldImage, &wDummy, &dwOldImageSize );
        TRACE3("Old: fFlags: %d\t wEvent: %d\t wId: %d\n",fFlags, wEvent, wId);
        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdId = LOWORD(lpResItem->dwItemID);
            wUpdPos = HIWORD(lpResItem->dwItemID);
            fUpdFlags = (WORD)lpResItem->dwFlags;
            wUpdEvent = (WORD)lpResItem->dwStyle;
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }


        if ((wUpdId==wId)) {
            fFlags = fUpdFlags;
            wEvent = wUpdEvent;
            wUpdPos = 0;
        }

        TRACE3("New: fFlags: %d\t wEvent: %d\t wId: %d\n",fFlags, wEvent, wId);
        dwOverAllSize += PutWord( &lpNewImage, fFlags, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, wEvent, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, 0, &dwNewImageSize);
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad4((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}



UINT
ParseMenu( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;
    BOOL bExt = FALSE;
    WORD wlen = 0;

    // Menu Template
    WORD wMenuVer = 0;
    WORD wHdrSize = 0;

    // get the menu header
    GetWord( &lpImage, &wMenuVer, &dwImageSize );
	GetWord( &lpImage, &wHdrSize, &dwImageSize );
	
	// Check if is one of the new extended resource
	if(wMenuVer == 1) {
		bExt = TRUE;
		SkipByte( &lpImage, wHdrSize, &dwImageSize );
	}
		
    // Menu Items
    WORD fItemFlags = 0;
    WORD wMenuId = 0;

    // Extended Menu Items
    DWORD dwType = 0L;
    DWORD dwState = 0L;
    DWORD dwID = 0L;
    DWORD dwHelpID = 0;

    while(dwImageSize>0) {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a menu
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (WORD)-1, &dwBufSize);

        if(bExt) {
        	GetDWord( &lpImage, &dwType, &dwImageSize );
        	GetDWord( &lpImage, &dwState, &dwImageSize );
        	GetDWord( &lpImage, &dwID, &dwImageSize );
        	// Let's get the Menu flags
	        GetWord( &lpImage, &fItemFlags, &dwImageSize );
	
	        // Check if it is a MFR_POPUP 0x0001
	        if (fItemFlags & MFR_POPUP) {
                // convert to the standard value
	        	fItemFlags &= ~(WORD)MFR_POPUP;
	        	fItemFlags |= MF_POPUP;
	        }
	
	        //Put the Flag
	        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fItemFlags, &dwBufSize);
	        //Put the MenuId
	        dwOverAllSize += PutDWord( &lpBuf, dwID, &dwBufSize);
        } else {
	        // Let's get the Menu flags
	        GetWord( &lpImage, &fItemFlags, &dwImageSize );
	        if ( !(fItemFlags & MF_POPUP) )
	            // Get the menu Id
	            GetWord( &lpImage, &wMenuId, &dwImageSize );
	        else wMenuId = (WORD)-1;

	        //Put the Flag
	        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fItemFlags, &dwBufSize);
	        //Put the MenuId
	        dwOverAllSize += PutDWord( &lpBuf, (DWORD)wMenuId, &dwBufSize);
        }

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, (DWORD_PTR)(lpItem+uiOffset), &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);

        // Get the text
        // calculate were the string is going to be
        // Will be the fixed header+the pointer
        wlen = (WORD)GetStringW( &lpImage, &szCaption[0], &dwImageSize, MAXSTR );

		dwOverAllSize += PutStringA( &lpBuf, &szCaption[0], &dwBufSize);
		
		if(bExt) {
			// Do we need padding
			BYTE bPad = (BYTE)Pad4((WORD)(wlen+sizeofWord));
			SkipByte( &lpImage, bPad, &dwImageSize );
			
			if ( (fItemFlags & MF_POPUP) )
	            // Get the Help Id
	            GetDWord( &lpImage, &dwHelpID, &dwImageSize );
		}

        // Put the size of the resource
        uiOffset += strlen(szCaption)+1;
        // Check if we are alligned
        lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += lDummy;
        uiOffset += lDummy;
        lDummy = 4;
        if(dwBufSize>=0)
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        /*
        if (dwBufSize>=0) {
            uiOffset += strlen((LPSTR)(lpItem+uiOffset))+1;
            // Check if we are alligned
            lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
            dwOverAllSize += lDummy;
            uiOffset += lDummy;
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }
        */

        // Move to the next position
        lpItem = lpBuf;
        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
	        if (bPad==dwImageSize) {
					BYTE far * lpBuf = lpImage;
					while (bPad){
						if(*lpBuf++!=0x00)
							break;
						bPad--;
					}
					if (bPad==0)
						dwImageSize = -1;
		    }
		}
    }
    return (UINT)(dwOverAllSize);
}


UINT
UpdateMenu( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    // Menu Items
    WORD fItemFlags;
    WORD wMenuId;
    WORD wPos = 0;

    // Updated items
    WORD wUpdPos = 0;
    WORD fUpdItemFlags;
    WORD wUpdMenuId;

	// Extended Menu Items
    DWORD dwType = 0L;
    DWORD dwState = 0L;
    DWORD dwID = 0L;
    DWORD dwHelpID = 0;

    LONG dwOverAllSize = 0l;
    WORD wlen = 0;
    BOOL bExt = FALSE;
    BYTE bPad = 0;

    // Menu Template
    WORD wMenuVer = 0;
    WORD wHdrSize = 0;

    // get the menu header
    GetWord( &lpOldImage, &wMenuVer, &dwOldImageSize );
	GetWord( &lpOldImage, &wHdrSize, &dwOldImageSize );
	
	// Check if is one of the new extended resource
	if(wMenuVer == 1) {
		bExt = TRUE;
		// Put the header informations
		dwOverAllSize += PutWord( &lpNewImage, wMenuVer, &dwNewImageSize);
		dwOverAllSize += PutWord( &lpNewImage, wHdrSize, &dwNewImageSize);
		
		if(wHdrSize) {
			while(wHdrSize) {
				dwOldImageSize -= PutByte( &lpNewImage, *((BYTE*)lpOldImage), &dwNewImageSize);
			    lpOldImage += sizeofByte;
			    dwOverAllSize += sizeofByte;
				wHdrSize--;
			}
		}
	}
	else {
		// Put the header informations
		dwOverAllSize += PutWord( &lpNewImage, wMenuVer, &dwNewImageSize);
		dwOverAllSize += PutWord( &lpNewImage, wHdrSize, &dwNewImageSize);
	}
	
    while(dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        // Get the menu flag
        if(bExt) {
        	GetDWord( &lpOldImage, &dwType, &dwOldImageSize );
        	GetDWord( &lpOldImage, &dwState, &dwOldImageSize );
        	GetDWord( &lpOldImage, &dwID, &dwOldImageSize );
        	wMenuId = LOWORD(dwID);	// we need to do this since we had no idea the ID could be DWORD
        	// Let's get the Menu flags
	        GetWord( &lpOldImage, &fItemFlags, &dwOldImageSize );
	        // Get the text
        	wlen = (WORD)GetStringW( &lpOldImage, &szCaption[0], &dwOldImageSize, MAXSTR );
        	
	        // Do we need padding
			bPad = (BYTE)Pad4((WORD)(wlen+sizeofWord));
			SkipByte( &lpOldImage, bPad, &dwOldImageSize );
			
			if ( (fItemFlags & MFR_POPUP) )
	            // Get the Help Id
	            GetDWord( &lpOldImage, &dwHelpID, &dwOldImageSize );
        } else {
	        // Let's get the Menu flags
	        GetWord( &lpOldImage, &fItemFlags, &dwOldImageSize );
	        if ( !(fItemFlags & MF_POPUP) )
	            // Get the menu Id
	            GetWord( &lpOldImage, &wMenuId, &dwOldImageSize );
	        else wMenuId = (WORD)-1;
	
        	// Get the text
        	GetStringW( &lpOldImage, &szCaption[0], &dwOldImageSize, MAXSTR );
        }

        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            wUpdMenuId = LOWORD(lpResItem->dwItemID);
            fUpdItemFlags = (WORD)lpResItem->dwFlags;
            strcpy( szUpdCaption, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos) && (wUpdMenuId==wMenuId)) {
        	if ((fItemFlags & MFR_POPUP) && bExt) {
	        	fUpdItemFlags &= ~MF_POPUP;
	        	fUpdItemFlags |= MFR_POPUP;
	        }
	        	
            // check if it is not the last item in the menu
	        if(fItemFlags & MF_END)
	                fItemFlags = fUpdItemFlags | (WORD)MF_END;
	        else fItemFlags = fUpdItemFlags;
	
	        // check it is not a separator
            if((fItemFlags==0) && (wMenuId==0) && !(*szCaption))
                strcpy(szCaption, "");
            else strcpy(szCaption, szUpdCaption);
            wUpdPos = 0;
        }
        if(bExt) {
        	dwOverAllSize += PutDWord( &lpNewImage, dwType, &dwNewImageSize);
        	dwOverAllSize += PutDWord( &lpNewImage, dwState, &dwNewImageSize);
        	dwOverAllSize += PutDWord( &lpNewImage, dwID, &dwNewImageSize);
        	
        	dwOverAllSize += PutWord( &lpNewImage, fItemFlags, &dwNewImageSize);
        	wlen = (WORD)PutStringW( &lpNewImage, &szCaption[0], &dwNewImageSize);
        	dwOverAllSize += wlen;
        	
        	// Do we need padding
			bPad = (BYTE)Pad4((WORD)(wlen+sizeofWord));
			while(bPad) {
				dwOverAllSize += PutByte( &lpNewImage, 0, &dwNewImageSize);
				bPad--;
			}
			
			if ( (fItemFlags & MFR_POPUP) )
	            // write the Help Id
	            dwOverAllSize += PutDWord( &lpNewImage, dwHelpID, &dwNewImageSize);
        }
        else {
	        dwOverAllSize += PutWord( &lpNewImage, fItemFlags, &dwNewImageSize);
	
	        if ( !(fItemFlags & MF_POPUP) ) {
	            dwOverAllSize += PutWord( &lpNewImage, wMenuId, &dwNewImageSize);
	        }
	
	        // Write the text in UNICODE
	        dwOverAllSize += PutStringW( &lpNewImage, &szCaption[0], &dwNewImageSize);
        }

        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwOriginalOldSize-dwOldImageSize));
	        if (bPad==dwOldImageSize) {
				BYTE far * lpBuf = lpOldImage;
				while (bPad){
					if(*lpBuf++!=0x00)
						break;
					bPad--;
				}
				if (bPad==0)
					dwOldImageSize = -1;
			}
		}
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad16((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }
    return uiError;
}


UINT
ParseString( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    // Should be almost impossible for a String to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    LONG dwRead = 0L;

    BYTE bIdCount = 0;

    while( (dwImageSize>0) && (bIdCount<16)  ) {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a string
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the StringId
        dwOverAllSize += PutDWord( &lpBuf, bIdCount++, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ClassName
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // FaceName
        dwOverAllSize += PutDWordPtr( &lpBuf, (DWORD_PTR)(lpItem+uiOffset), &dwBufSize);   // Caption
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ResItem
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // TypeItem

        // Get the text
        GetPascalString( &lpImage, &szCaption[0], MAXSTR, &dwImageSize );
        dwOverAllSize += PutStringA( &lpBuf, &szCaption[0], &dwBufSize);

        // Put the size of the resource
        uiOffset += strlen(szCaption)+1;
        // Check if we are alligned
        lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += lDummy;
        uiOffset += lDummy;
        lDummy = 4;
        if(dwBufSize>=0)
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);

        /*
        if ((LONG)(dwSize-dwOverAllSize)>=0) {
            uiOffset += strlen(szCaption)+1;
            // Check if we are alligned
            lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
            dwOverAllSize += lDummy;
            uiOffset += lDummy;
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }
        */

        // Move to the next position
        lpItem = lpBuf;

        // Check if we are at the end and this is just padding
        if (dwImageSize<=16 && (bIdCount==16)) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            if (bPad==dwImageSize) {
				BYTE far * lpBuf = lpImage;
				while (bPad){
					if(*lpBuf++!=0x00)
						break;
					bPad--;
				}
				if (bPad==0)
					dwImageSize = -1;
			}
		}
    }
    return (UINT)(dwOverAllSize);
}



UINT
UpdateString( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    WORD wLen;
    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    while(dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        GetPascalString( &lpOldImage, &szCaption[0], MAXSTR, &dwOldImageSize );

        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            strcpy( szUpdCaption, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos)) {
            strcpy(szCaption, szUpdCaption);
            wUpdPos = 0;
        }

        wLen = strlen(szCaption);

        // Write the text
        dwOverAllSize += PutPascalStringW( &lpNewImage, &szCaption[0], wLen, &dwNewImageSize );

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad4((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


UINT
UpdateMsgTbl( LPVOID lpNewBuf, LONG dwNewSize,
              LPVOID lpOldI, LONG dwOldImageSize,
              LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    BYTE far * lpStartImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;
    WORD wUpdId = 0;

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    ULONG ulNumofBlock = 0;

    ULONG ulLowId =  0l;
    ULONG ulHighId = 0l;
    ULONG ulOffsetToEntry = 0l;

    USHORT usLength = 0l;
    USHORT usFlags = 0l;

    // we have to calculate the position of the first Entry block in the immage
    // Get number of blocks in the old image
    GetDWord( &lpOldImage, &ulNumofBlock, &dwOldImageSize );

    BYTE far * lpEntryBlock = lpNewImage+(ulNumofBlock*sizeof(ULONG)*3+sizeof(ULONG));

    // Write the number of block in the new image
    dwOverAllSize = PutDWord( &lpNewImage, ulNumofBlock, &dwNewImageSize );
    wPos = 1;
    for( ULONG c = 0; c<ulNumofBlock ; c++) {
        // Get ID of the block
        GetDWord( &lpOldImage, &ulLowId, &dwOldImageSize );
        GetDWord( &lpOldImage, &ulHighId, &dwOldImageSize );

        // Write the Id of the block
        dwOverAllSize += PutDWord( &lpNewImage, ulLowId, &dwNewImageSize );
        dwOverAllSize += PutDWord( &lpNewImage, ulHighId, &dwNewImageSize );

        // Get the offset to the data in the old image
        GetDWord( &lpOldImage, &ulOffsetToEntry, &dwOldImageSize );

        // Write the offset to the data in the new Image
        dwOverAllSize += PutDWord( &lpNewImage, (DWORD)(lpEntryBlock-lpStartImage), &dwNewImageSize );

        BYTE far * lpData = (BYTE far *)lpOldI;
        lpData += ulOffsetToEntry;
        while( ulHighId>=ulLowId ) {

            GetMsgStr( &lpData,
                       &szCaption[0],
                       MAXSTR,
                       &usLength,
                       &usFlags,
                       &dwOldImageSize );


            if ( dwNewSize ) {
                lpResItem = (LPRESITEM) lpBuf;

                wUpdId = LOWORD(lpResItem->dwItemID);
                strcpy( szUpdCaption, lpResItem->lpszCaption );
                lpBuf += lpResItem->dwSize;
                dwNewSize -= lpResItem->dwSize;
            }

            // Check if the item has been updated
            if (wUpdId==wPos++) {
                strcpy(szCaption, szUpdCaption);
            }

            dwOverAllSize += PutMsgStr( &lpEntryBlock,
                                        &szCaption[0],
                                        usFlags,
                                        &dwNewImageSize );

            ulLowId++;
        }
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad4((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}



UINT
ParseDialog( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
    UINT uiOffset = 0;

    char far * lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    LONG dwOverAllSize = 0L;

    WORD wIdCount = 0;
    BOOL bExt = FALSE;		// Extended dialog flag

    // Dialog Elements
    WORD wDlgVer = 0;
    WORD wSign	= 0;
    DWORD dwHelpID = 0L;
    DWORD dwStyle = 0L;
    DWORD dwExtStyle = 0L;
    WORD wNumOfElem = 0;
    WORD wX = 0;
    WORD wY = 0;
    WORD wcX = 0;
    WORD wcY = 0;
    WORD wId = 0;
    DWORD dwId = 0L;
    char szMenuName[128];
    WORD wMenuName;
    char szClassName[128];
    WORD wClassName;
    WORD wOrd = 0;
    WORD wPointSize = 0;
    WORD wWeight = -1;
    BYTE bItalic = -1;
    BYTE bCharSet = DEFAULT_CHARSET;
    char szFaceName[128];
    WORD wRawData = 0;
    WORD wDataSize = 0;
    szCaption[0] = '\0';


    // read the dialog header
    wDataSize = GetDWord( &lpImage, &dwStyle, &dwImageSize );

    // Check for extended dialog style
    if(HIWORD(dwStyle)==0xFFFF)	{
    	bExt = TRUE;
    	wDlgVer = HIWORD(dwStyle);
    	wSign = LOWORD(dwStyle);
		wDataSize += GetDWord( &lpImage, &dwHelpID, &dwImageSize );
	}
    wDataSize += GetDWord( &lpImage, &dwExtStyle, &dwImageSize );
    if(bExt)
    	wDataSize += GetDWord( &lpImage, &dwStyle, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wNumOfElem, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wX, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wY, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wcX, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wcY, &dwImageSize );
    wDataSize += (WORD)GetNameOrOrd( &lpImage, &wMenuName, &szMenuName[0], &dwImageSize );
    wDataSize += (WORD)GetClassName( &lpImage, &wClassName, &szClassName[0], &dwImageSize );
    wDataSize += (WORD)GetCaptionOrOrd( &lpImage, &wOrd, &szCaption[0], &dwImageSize, wClassName, dwStyle );
    if( dwStyle & DS_SETFONT ) {
        wDataSize += GetWord( &lpImage, &wPointSize, &dwImageSize );
        if(bExt) {
        	wDataSize += GetWord( &lpImage, &wWeight, &dwImageSize );
        	wDataSize += GetByte( &lpImage, &bItalic, &dwImageSize );
        	wDataSize += GetByte( &lpImage, &bCharSet, &dwImageSize );
        }
        wDataSize += (WORD)GetStringW( &lpImage, &szFaceName[0], &dwImageSize, 128 );
    }


    // calculate the padding
    BYTE bPad = (BYTE)Pad4((WORD)wDataSize);
    if (bPad)
        SkipByte( &lpImage, bPad, &dwImageSize );

    TRACE("WIN32.DLL ParseDialog\t");
    if(bExt)
    	TRACE("Extended style Dialog - Chicago win32 dialog format\n");
    else TRACE("Standart style Dialog - NT win32 dialog format\n");
    if (bExt){
    	TRACE1("DlgVer: %d\t", wDlgVer);
    	TRACE1("Signature: %d\t", wSign);
    	TRACE1("HelpID: %lu\n", dwHelpID);
    }
    TRACE1("NumElem: %d\t", wNumOfElem);
    TRACE1("X %d\t", wX);
    TRACE1("Y: %d\t", wY);
    TRACE1("CX: %d\t", wcX);
    TRACE1("CY: %d\t", wcY);
    TRACE1("Id: %d\t", wId);
    TRACE1("Style: %lu\t", dwStyle);
    TRACE1("ExtStyle: %lu\n", dwExtStyle);
    TRACE1("Caption: %s\n", szCaption);
    TRACE2("ClassName: %s\tClassId: %d\n", szClassName, wClassName );
    TRACE2("MenuName: %s\tMenuId: %d\n", szMenuName, wMenuName );
    TRACE2("FontName: %s\tPoint: %d\n", szFaceName, wPointSize );
#ifdef _DEBUG
    if(bExt)
    	TRACE2("Weight: %d\tItalic: %d\n", wWeight, bItalic );
#endif

    // Fixed field
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

    dwOverAllSize += PutWord( &lpBuf, wX, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wY, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wcX, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wcY, &dwBufSize);

    // we don't have checksum
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, dwStyle, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, dwExtStyle, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    //Put the Id 0 for the main dialog
    dwOverAllSize += PutDWord( &lpBuf, wIdCount++, &dwBufSize);

    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    dwOverAllSize += PutWord( &lpBuf, wClassName, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wPointSize, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wWeight, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, bItalic, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, bCharSet, &dwBufSize);

    // Let's put null were we don't have the strings
    uiOffset = sizeof(RESITEM);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ClassName
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // FaceName
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // Caption
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ResItem
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // TypeItem

    lpResItem->lpszClassName = strcpy( lpStrBuf, szClassName );
    lpStrBuf += strlen(lpResItem->lpszClassName)+1;

    lpResItem->lpszFaceName = strcpy( lpStrBuf, szFaceName );
    lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

    lpResItem->lpszCaption = strcpy( lpStrBuf, szCaption );
    lpStrBuf += strlen(lpResItem->lpszCaption)+1;

    // Put the size of the resource
    if (dwBufSize>0) {
        uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
        uiOffset += strlen((LPSTR)(lpResItem->lpszFaceName))+1;
        uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
    }

    // Check if we are alligned
    uiOffset += Allign( (LPLPBYTE)&lpStrBuf, &dwBufSize, (LONG)uiOffset);

    dwOverAllSize += uiOffset-sizeof(RESITEM);
    lpResItem->dwSize = (DWORD)uiOffset;

    // Move to the next position
    lpResItem = (LPRESITEM) lpStrBuf;
    lpBuf = (BYTE far *)lpStrBuf;
    lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    while( (dwImageSize>0) && (wNumOfElem>0) ) {
        // Read the Controls
        if(bExt) {
        	wDataSize = GetDWord( &lpImage, &dwHelpID, &dwImageSize );
        	wDataSize += GetDWord( &lpImage, &dwExtStyle, &dwImageSize );
        	wDataSize += GetDWord( &lpImage, &dwStyle, &dwImageSize );
        }
        else {
	        wDataSize = GetDWord( &lpImage, &dwStyle, &dwImageSize );
	        wDataSize += GetDWord( &lpImage, &dwExtStyle, &dwImageSize );
	    }
	    wDataSize += GetWord( &lpImage, &wX, &dwImageSize );
        wDataSize += GetWord( &lpImage, &wY, &dwImageSize );
        wDataSize += GetWord( &lpImage, &wcX, &dwImageSize );
        wDataSize += GetWord( &lpImage, &wcY, &dwImageSize );
        if(bExt) {
        	wDataSize += GetDWord( &lpImage, &dwId, &dwImageSize );
        	wId = LOWORD(dwId);
        }
        else wDataSize += GetWord( &lpImage, &wId, &dwImageSize );
        wDataSize += (WORD)GetClassName( &lpImage, &wClassName, &szClassName[0], &dwImageSize );
        wDataSize += (WORD)GetCaptionOrOrd( &lpImage, &wOrd, &szCaption[0], &dwImageSize, wClassName, dwStyle );
        if (bExt) {
        	wDataSize += GetWord( &lpImage, &wRawData, &dwImageSize );
        	wDataSize += (WORD)SkipByte( &lpImage, wRawData, &dwImageSize );
        } else
        	wDataSize += (WORD)SkipByte( &lpImage, 2, &dwImageSize );

        // Calculate padding
        bPad = (BYTE)Pad4((WORD)wDataSize);
        if (bPad)
            SkipByte( &lpImage, bPad, &dwImageSize );

        wNumOfElem--;

        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        dwOverAllSize += PutWord( &lpBuf, wX, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wY, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wcX, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wcY, &dwBufSize);

        // we don't have checksum and extended style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, dwStyle, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, dwExtStyle, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, wId, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        dwOverAllSize += PutWord( &lpBuf, wClassName, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wPointSize, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wWeight, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, bItalic, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, bCharSet, &dwBufSize);

        // Let's put null were we don't have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ClassName
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // FaceName
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // Caption
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ResItem
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // TypeItem

        lpResItem->lpszClassName = strcpy( lpStrBuf, szClassName );
        lpStrBuf += strlen(lpResItem->lpszClassName)+1;

        lpResItem->lpszFaceName = strcpy( lpStrBuf, szFaceName );
        lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

        lpResItem->lpszCaption = strcpy( lpStrBuf, szCaption );
        lpStrBuf += strlen(lpResItem->lpszCaption)+1;

        // Put the size of the resource
        if (dwBufSize>0) {
            uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszFaceName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
        }

        // Check if we are alligned
        uiOffset += Allign( (LPLPBYTE)&lpStrBuf, &dwBufSize, (LONG)uiOffset);

        dwOverAllSize += uiOffset-sizeof(RESITEM);
        lpResItem->dwSize = (DWORD)uiOffset;

        // Move to the next position
        lpResItem = (LPRESITEM) lpStrBuf;
        lpBuf = (BYTE far *)lpStrBuf;
        lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

        TRACE1("\tControl: X: %d\t", wX);
        TRACE1("Y: %d\t", wY);
        TRACE1("CX: %d\t", wcX);
        TRACE1("CY: %d\t", wcY);
        if (bExt) TRACE1("Id: %lu\t", dwId);
        else TRACE1("Id: %d\t", wId);
        TRACE1("Style: %lu\t", dwStyle);
        TRACE1("ExtStyle: %lu\n", dwExtStyle);
        TRACE1("HelpID: %lu\t", dwHelpID);
        TRACE1("RawData: %d\n", wRawData);
        TRACE1("Caption: %s\n", szCaption);

        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            if (bPad==dwImageSize) {
				BYTE far * lpBuf = lpImage;
				while (bPad){
					if(*lpBuf++!=0x00)
						break;
					bPad--;
				}
				if (bPad==0)
					dwImageSize = -1;
			}
        }
    }

    return (UINT)(dwOverAllSize);
}



UINT
UpdateDialog( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    LONG dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    LONG dwOverAllSize = 0L;

    //WORD    wIdCount = 0;
    BOOL bExt = FALSE;		// Extended dialog flag
    BOOL bUpdExt = FALSE;	// Updated DIALOGEX flag

    // Updated elements
    WORD wUpdX = 0;
    WORD wUpdY = 0;
    WORD wUpdcX = 0;
    WORD wUpdcY = 0;
    DWORD dwUpdStyle = 0l;
    DWORD dwUpdExtStyle = 0L;
    DWORD dwPosId = 0l;
     char szUpdFaceName[128];
    WORD wUpdPointSize = 0;
    BYTE bUpdCharSet = DEFAULT_CHARSET;
    WORD wUpdPos = 0;

    // Dialog Elements
    WORD	wDlgVer = 0;
    WORD	wSign	= 0;
    DWORD	dwHelpID = 0L;
    DWORD	dwID = 0L;
    DWORD   dwStyle = 0L;
    DWORD   dwExtStyle = 0L;
    WORD    wNumOfElem = 0;
    WORD    wX = 0;
    WORD    wY = 0;
    WORD    wcX = 0;
    WORD    wcY = 0;
    WORD    wId = 0;
     char     szMenuName[128];
    WORD    wMenuName;
     char     szClassName[128];
    WORD    wClassName;
    WORD    wPointSize = 0;
    WORD	wWeight = FW_NORMAL;
    BYTE    bItalic = 0;
    BYTE    bCharSet = DEFAULT_CHARSET;
     char    szFaceName[128];
    WORD	wRawData = 0;
    BYTE *	lpRawData = NULL;
    WORD    wDataSize = 0;

    WORD    wPos = 1;
    WORD    wOrd = 0;

    // read the dialog header
    wDataSize = GetDWord( &lpOldImage, &dwStyle, &dwOriginalOldSize );

    // Check for extended dialog style
    if(HIWORD(dwStyle)==0xFFFF)	{
    	bExt = TRUE;
    	wDlgVer = HIWORD(dwStyle);
    	wSign = LOWORD(dwStyle);
		wDataSize += GetDWord( &lpOldImage, &dwHelpID, &dwOriginalOldSize );
	}
    wDataSize += GetDWord( &lpOldImage, &dwExtStyle, &dwOriginalOldSize );
    if(bExt)
    	wDataSize += GetDWord( &lpOldImage, &dwStyle, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wNumOfElem, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wX, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wY, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wcX, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wcY, &dwOriginalOldSize );
    wDataSize += (WORD)GetNameOrOrd( &lpOldImage, &wMenuName, &szMenuName[0], &dwOriginalOldSize );
    wDataSize += (WORD)GetClassName( &lpOldImage, &wClassName, &szClassName[0], &dwOriginalOldSize );
    wDataSize += (WORD)GetCaptionOrOrd( &lpOldImage , &wOrd, &szCaption[0], &dwOriginalOldSize, wClassName, dwStyle  );
    if( dwStyle & DS_SETFONT ) {
        wDataSize += GetWord( &lpOldImage, &wPointSize, &dwOriginalOldSize );
        if(bExt) {
        	wDataSize += GetWord( &lpOldImage, &wWeight, &dwOriginalOldSize );
        	wDataSize += GetByte( &lpOldImage, &bItalic, &dwOriginalOldSize );
        	wDataSize += GetByte( &lpOldImage, &bCharSet, &dwOriginalOldSize );
        }
        wDataSize += (WORD)GetStringW( &lpOldImage, &szFaceName[0], &dwOriginalOldSize, 128 );
    }

    // calculate the padding
    BYTE bPad = (BYTE)Pad4((WORD)wDataSize);
    if (bPad)
        SkipByte( &lpOldImage, bPad, &dwOriginalOldSize );

    TRACE("WIN32.DLL UpdateDialog\n");
    if(bExt)
    	TRACE("Extended style Dialog - Chicago win32 dialog format\n");
    else TRACE("Standart style Dialog - NT win32 dialog format\n");
    if (bExt){
    	TRACE1("DlgVer: %d\t", wDlgVer);
    	TRACE1("Signature: %d\t", wSign);
    	TRACE1("HelpID: %lu\n", dwHelpID);
    }

    TRACE1("NumElem: %d\t", wNumOfElem);
    TRACE1("X %d\t", wX);
    TRACE1("Y: %d\t", wY);
    TRACE1("CX: %d\t", wcX);
    TRACE1("CY: %d\t", wcY);
    TRACE1("Id: %d\t", wId);
    TRACE1("Style: %lu\t", dwStyle);
    TRACE1("ExtStyle: %lu\n", dwExtStyle);
    TRACE1("Caption: %s\n", szCaption);
    TRACE2("ClassName: %s\tClassId: %d\n", szClassName, wClassName );
    TRACE2("MenuName: %s\tMenuId: %d\n", szMenuName, wMenuName );
    TRACE2("FontName: %s\tPoint: %d\n", szFaceName, wPointSize );
#ifdef _DEBUG
    if(bExt)
    	TRACE2("Weight: %d\tItalic: %d\n", wWeight, bItalic );
#endif

    // Get the infrmation from the updated resource
    if ((!wUpdPos) && dwNewSize ) {
        lpResItem = (LPRESITEM) lpBuf;
        wUpdX = lpResItem->wX;
        wUpdY = lpResItem->wY;
        wUpdcX = lpResItem->wcX;
        wUpdcY = lpResItem->wcY;
        wUpdPointSize = lpResItem->wPointSize;
        bUpdCharSet = lpResItem->bCharSet;
        dwUpdStyle = lpResItem->dwStyle;
        dwUpdExtStyle = lpResItem->dwExtStyle;
        dwPosId = lpResItem->dwItemID;
        strcpy( szUpdCaption, lpResItem->lpszCaption );
        strcpy( szUpdFaceName, lpResItem->lpszFaceName );
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
    }

    // check if we have to update the header
    if ((HIWORD(dwPosId)==wPos) && (LOWORD(dwPosId)==wId)) {
        wX = wUpdX;
        wY = wUpdY;
        wcX = wUpdcX;
        wcY = wUpdcY;
        wPointSize = wUpdPointSize;
        bCharSet = bUpdCharSet;
        dwStyle = dwUpdStyle;
        dwExtStyle = dwUpdExtStyle;
        strcpy(szCaption, szUpdCaption);
        strcpy(szFaceName, szUpdFaceName);
    }

    // User changed DIALOG to DIALOGEX by adding charset information.
    if (!bExt && bCharSet != DEFAULT_CHARSET){
        bUpdExt = TRUE;
        wSign = DIALOGEX_VERION;
        wDlgVer = 0xFFFF;
        dwHelpID = 0;
        wWeight = FW_NORMAL;
        bItalic = 0;
    }
    DWORD dwPadCalc = dwOverAllSize;
    // Write the header informations
    if(bExt || bUpdExt) {
    	dwOverAllSize += PutWord( &lpNewImage, wSign, &dwNewImageSize );
    	dwOverAllSize += PutWord( &lpNewImage, wDlgVer, &dwNewImageSize );
    	dwOverAllSize += PutDWord( &lpNewImage, dwHelpID, &dwNewImageSize );
        dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
	    dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
    }
    else {
	    dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
	    dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
	}
    dwOverAllSize += PutWord( &lpNewImage, wNumOfElem, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
    dwOverAllSize += PutNameOrOrd( &lpNewImage, wMenuName, &szMenuName[0], &dwNewImageSize );
    dwOverAllSize += PutClassName( &lpNewImage, wClassName, &szClassName[0], &dwNewImageSize );
    dwOverAllSize += PutCaptionOrOrd( &lpNewImage, wOrd, &szCaption[0], &dwNewImageSize,
    	wClassName, dwStyle );
    if( dwStyle & DS_SETFONT ) {
    	dwOverAllSize += PutWord( &lpNewImage, wPointSize, &dwNewImageSize );
    	if(bExt || bUpdExt) {
    		dwOverAllSize += PutWord( &lpNewImage, wWeight, &dwNewImageSize );
    		dwOverAllSize += PutByte( &lpNewImage, bItalic, &dwNewImageSize );
    		dwOverAllSize += PutByte( &lpNewImage, bCharSet, &dwNewImageSize );
    	}
        dwOverAllSize += PutStringW( &lpNewImage, &szFaceName[0], &dwNewImageSize );
    }

    // Check if padding is needed
    bPad = (BYTE)Pad4((WORD)(dwOverAllSize-dwPadCalc));
    if (bPad) {
        if( (bPad)<=dwNewImageSize )
            memset( lpNewImage, 0x00, bPad );
        dwNewImageSize -= (bPad);
        dwOverAllSize += (bPad);
        lpNewImage += (bPad);
    }

    while( (dwOriginalOldSize>0) && (wNumOfElem>0) ) {
        wPos++;
        // Get the info for the control
        // Read the Controls
        if(bExt) {
        	wDataSize = GetDWord( &lpOldImage, &dwHelpID, &dwOriginalOldSize );
        	wDataSize += GetDWord( &lpOldImage, &dwExtStyle, &dwOriginalOldSize );
        	wDataSize += GetDWord( &lpOldImage, &dwStyle, &dwOriginalOldSize );
        }
        else {
	        wDataSize = GetDWord( &lpOldImage, &dwStyle, &dwOriginalOldSize );
	        wDataSize += GetDWord( &lpOldImage, &dwExtStyle, &dwOriginalOldSize );
	    }
	    wDataSize += GetWord( &lpOldImage, &wX, &dwOriginalOldSize );
        wDataSize += GetWord( &lpOldImage, &wY, &dwOriginalOldSize );
        wDataSize += GetWord( &lpOldImage, &wcX, &dwOriginalOldSize );
        wDataSize += GetWord( &lpOldImage, &wcY, &dwOriginalOldSize );
        if(bExt) {
        	wDataSize += GetDWord( &lpOldImage, &dwID, &dwOriginalOldSize );
        	wId = LOWORD(dwID);
        } else {
            wDataSize += GetWord( &lpOldImage, &wId, &dwOriginalOldSize );
        }

        wDataSize += (WORD)GetClassName( &lpOldImage, &wClassName, &szClassName[0], &dwOriginalOldSize );
        wDataSize += (WORD)GetCaptionOrOrd( &lpOldImage, &wOrd, &szCaption[0], &dwOriginalOldSize, wClassName, dwStyle );
        if (bExt) {
        	wDataSize += GetWord( &lpOldImage, &wRawData, &dwOriginalOldSize );
        	if(wRawData) {
        		lpRawData = (BYTE*)lpOldImage;
        		wDataSize += (WORD)SkipByte( &lpOldImage, wRawData, &dwOriginalOldSize );
        	} else lpRawData = NULL;
        } else
        	wDataSize += (WORD)SkipByte( &lpOldImage, 2, &dwOriginalOldSize );

        // Calculate padding
        bPad = (BYTE)Pad4((WORD)wDataSize);
        if (bPad)
            SkipByte( &lpOldImage, bPad, &dwOriginalOldSize );

        wNumOfElem--;

        if ((!wUpdPos) && dwNewSize ) {
        TRACE1("\t\tUpdateDialog:\tdwNewSize=%ld\n",(LONG)dwNewSize);
            TRACE1("\t\t\t\tlpszCaption=%Fs\n",lpResItem->lpszCaption);
            lpResItem = (LPRESITEM) lpBuf;
            wUpdX = lpResItem->wX;
            wUpdY = lpResItem->wY;
            wUpdcX = lpResItem->wcX;
            wUpdcY = lpResItem->wcY;
            dwUpdStyle = lpResItem->dwStyle;
            dwUpdExtStyle = lpResItem->dwExtStyle;
            dwPosId = lpResItem->dwItemID;
            strcpy( szUpdCaption, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }
        // check if we have to update the header
        if ((HIWORD(dwPosId)==wPos) && (LOWORD(dwPosId)==wId)) {
            wX = wUpdX;
            wY = wUpdY;
            wcX = wUpdcX;
            wcY = wUpdcY;
            dwStyle = dwUpdStyle;
            dwExtStyle = dwUpdExtStyle;
            strcpy(szCaption, szUpdCaption);
        }

        dwPadCalc = dwOverAllSize;
        //write the control
        if(bExt || bUpdExt) {
        	dwOverAllSize += PutDWord( &lpNewImage, dwHelpID, &dwNewImageSize );
        	dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
        	dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
        }
        else {
        	dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
        	dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
        }
        dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
        if (bUpdExt){
            dwID = MAKELONG(wId, 0);
        }
        if(bExt || bUpdExt)
        	 dwOverAllSize += PutDWord( &lpNewImage, dwID, &dwNewImageSize );
        else dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize );
        dwOverAllSize += PutClassName( &lpNewImage, wClassName, &szClassName[0], &dwNewImageSize );
        dwOverAllSize += PutCaptionOrOrd( &lpNewImage, wOrd, &szCaption[0], &dwNewImageSize,
        	wClassName, dwStyle );
        if (bExt) {
        	dwOverAllSize += PutWord( &lpNewImage, wRawData, &dwNewImageSize );
        	while(wRawData) {
        		dwOverAllSize += PutByte( &lpNewImage, *((BYTE*)lpRawData++), &dwNewImageSize );
        		wRawData--;
        	}
        } else
        	dwOverAllSize += PutWord( &lpNewImage, 0, &dwNewImageSize );

        // Check if padding is needed
        bPad = (BYTE)Pad4((WORD)(dwOverAllSize-dwPadCalc));
        if (bPad) {
            if( (bPad)<=dwNewImageSize )
                memset( lpNewImage, 0x00, bPad );
            dwNewImageSize -= (bPad);
            dwOverAllSize += (bPad);
            lpNewImage += (bPad);
        }
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad4((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }


    return uiError;
}


UINT
ParseMsgTbl( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    LONG dwOverAllSize = 0L;

    // Should be almost impossible for a Message table to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwRead = 0L;

    ULONG ulNumofBlock = 0l;

    ULONG ulLowId =  0l;
    ULONG ulHighId = 0l;
    ULONG ulOffsetToEntry = 0l;

    USHORT usLength = 0l;
    USHORT usFlags = 0l;

    WORD wPos = 0;
    // Get number of blocks
    GetDWord( &lpImage, &ulNumofBlock, &dwImageSize );
    wPos = 1;
    for( ULONG c = 0; c<ulNumofBlock ; c++) {
        // Get ID of the block
        GetDWord( &lpImage, &ulLowId, &dwImageSize );
        GetDWord( &lpImage, &ulHighId, &dwImageSize );

        // Get the offset to the data
        GetDWord( &lpImage, &ulOffsetToEntry, &dwImageSize );

        BYTE far * lpData = (BYTE far *)lpImageBuf;
        lpData += ulOffsetToEntry;
        while( ulHighId>=ulLowId ) {

            GetMsgStr( &lpData,
                          &szCaption[0],
                          MAXSTR,
                          &usLength,
                          &usFlags,
                          &dwImageSize );
            // Fixed field
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
            // We don't have the size and pos in a string
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

            // we don't have checksum and style
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            //Put the lowStringId
            //dwOverAllSize += PutDWord( &lpBuf, MAKELONG(ulLowId++, wPos++), &dwBufSize);

            ulLowId++;
            dwOverAllSize += PutDWord( &lpBuf, MAKELONG(wPos, wPos), &dwBufSize);
            wPos++;


            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // we don't have the language
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // Put the flags: if 1 = ANSI if 0 = ASCII(OEM)
            dwOverAllSize += PutDWord( &lpBuf, usFlags , &dwBufSize);

            // we don't have the font name
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
            dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

            // Let's put null were we don;t have the strings
            uiOffset = sizeof(RESITEM);
            dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ClassName
            dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // FaceName
            dwOverAllSize += PutDWordPtr( &lpBuf, (DWORD_PTR)(lpItem+uiOffset), &dwBufSize);   // Caption
            dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ResItem
            dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // TypeItem

            dwOverAllSize += PutStringA( &lpBuf, &szCaption[0], &dwBufSize);

            // Put the size of the resource
            if ((LONG)(dwSize-dwOverAllSize)>=0) {
                uiOffset += strlen((LPSTR)(lpItem+uiOffset))+1;
                // Check if we are alligned
            	lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
            	dwOverAllSize += lDummy;
            	uiOffset += lDummy;
            	lDummy = 8;
                PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
            }

            // Move to the next position
            lpItem = lpBuf;

            // Check if we are at the end and this is just padding
            if (dwImageSize<=16) {
                BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
    	        if (bPad==dwImageSize) {
    				BYTE far * lpBuf = lpImage;
    				while (bPad){
    					if(*lpBuf++!=0x00)
    						break;
    					bPad--;
    				}
    				if (bPad==0)
    					dwImageSize = -1;
    			}
    		}
        }
    }

    return (UINT)(dwOverAllSize);
}


UINT
ParseVerst( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;

    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
    char far * lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    LONG dwOverAllSize = 0L;

     VER_BLOCK VSBlock;
    WORD wPad = 0;
    WORD wPos = 0;

    while(dwImageSize>0) {

        GetVSBlock( &lpImage, &dwImageSize, &VSBlock );

        TRACE1("Key: %s\t", VSBlock.szKey);
        TRACE1("Value: %s\n", VSBlock.szValue);
        TRACE3("Len: %d\tSkip: %d\tType: %d\n", VSBlock.wBlockLen, VSBlock.wValueLen, VSBlock.wType );
        // check if this is the translation block
        if (!strcmp(VSBlock.szKey, "Translation" )){
            // This is the translation block let the localizer have it for now
            DWORD dwCodeLang = 0;
            LONG lDummy = 4;
            GetDWord( &VSBlock.pValue, &dwCodeLang, &lDummy);

            // Put the value in the string value
            wsprintf( &VSBlock.szValue[0], "%#08lX", dwCodeLang );
        }

        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in an accelerator
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        // we will need to calculate the correct ID for mike
        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, wPos++, &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);

        lpResItem->lpszClassName = strcpy( lpStrBuf, VSBlock.szKey );
        lpStrBuf += strlen(lpResItem->lpszClassName)+1;

        lpResItem->lpszCaption = strcpy( lpStrBuf, VSBlock.szValue );
        lpStrBuf += strlen(lpResItem->lpszCaption)+1;


        // Put the size of the resource
        if (dwBufSize>0) {
            uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
        }

        // Check if we are alligned
        uiOffset += Allign( (LPLPBYTE)&lpStrBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += uiOffset-sizeof(RESITEM);
        lpResItem->dwSize = (DWORD)uiOffset;


        // Move to the next position
        lpResItem = (LPRESITEM) lpStrBuf;
        lpBuf = (BYTE far *)lpStrBuf;
        lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));
    }

    return (UINT)(dwOverAllSize);
}

 UINT GetVSBlock( BYTE far * far* lplpBuf, LONG* pdwSize, VER_BLOCK* pBlock )
{
    WORD wPad = 0;
    int  iToRead = 0;
    WORD wLen = 0;
    WORD wHead = 0;

    if(*lplpBuf==NULL)
        return 0;

    pBlock->pValue = *lplpBuf;
    wHead = GetWord( lplpBuf, &pBlock->wBlockLen, pdwSize );
    wHead += GetWord( lplpBuf, &pBlock->wValueLen, pdwSize );
    wHead += GetWord( lplpBuf, &pBlock->wType, pdwSize );

    // Get the Key name
    wHead += (WORD)GetStringW( lplpBuf, &pBlock->szKey[0], pdwSize, 100 );
    if(Pad4(wHead))
        wPad += (WORD)SkipByte( lplpBuf, 2, pdwSize );

    iToRead = pBlock->wValueLen;
    pBlock->wHead = wHead;

    // Check if we are going over the image len
    if (iToRead>*pdwSize) {
        // There is an error
        wPad += (WORD)SkipByte( lplpBuf, (UINT)*pdwSize, pdwSize );
        return wHead+wPad;
    }

    // Save the pointer to the Value field
    pBlock->pValue = (pBlock->pValue+wHead+wPad);

    if(pBlock->wType && iToRead){
        iToRead -= wPad>>1;
        // Get the string
        if (iToRead>MAXSTR) {
            *pdwSize -= iToRead*sizeofWord;
            *lplpBuf += iToRead*sizeofWord;
        } else {
                int n = 0;
                int iBytesRead = 0;
                if ((iToRead*sizeofWord)+wHead+wPad>pBlock->wBlockLen)
                    // Need to fix this up. Bug in the RC compiler?
                    iToRead -= ((iToRead*sizeofWord)+wHead+wPad - pBlock->wBlockLen)>>1;
                iBytesRead = GetStringW(lplpBuf, &pBlock->szValue[0], pdwSize, 256);
                //
                //  Some old version stamp has a NULL char in between
                //  Microsoft Corp. and the year of copyright.  GetString
                //  will return the number of byte read up to the NULL char.
                //  We need to skip the rest.
                //
                if (iBytesRead < iToRead*sizeofWord)
                {
                    iBytesRead += SkipByte(lplpBuf,
                                           iToRead*sizeofWord-iBytesRead,
                                           pdwSize);
                }
                iToRead = iBytesRead;
        }
    } else {
        SkipByte( lplpBuf, iToRead, pdwSize );
        *pBlock->szValue = '\0';
    }

    if (*pdwSize)
    {
        WORD far * lpw = (WORD far *)*lplpBuf;
        while((WORD)*(lpw)==0x0000)
        {
            wPad += (WORD)SkipByte( (BYTE far * far *)&lpw, 2, pdwSize );
            if ((*pdwSize)<=0)
            {
                break;
            }
        }
        *lplpBuf = (BYTE far *)lpw;
    }

    return (wHead+iToRead+wPad);
}

 UINT
PutVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK ver,
            LPSTR lpStr, BYTE far * far * lplpBlockSize, WORD* pwTrash)

{
    // We have to write the info in the VER_BLOCK in the new image
    // We want to remember were the block size field is so we can update it later

    WORD wHead = 0;
    WORD wValue = 0;
    WORD wPad = Pad4(ver.wHead);
    *pwTrash = 0;

    // Get the pointer to the header of the block
    BYTE far * pHead = ver.pValue-ver.wHead-wPad;
    BYTE far * lpNewImage = *lplpImage;
    // Copy the header of the block to the new image
    wHead = ver.wHead;
    if (*pdwSize>=(int)ver.wHead) {
        memcpy( *lplpImage, pHead, ver.wHead );
        *pdwSize -= ver.wHead;
        lpNewImage += ver.wHead;
    }

    // Check if padding is needed
    if ((wPad) && (*pdwSize>=(int)wPad)) {
        memset( *lplpImage+ver.wHead, 0, wPad );
        *pdwSize -= wPad;
        lpNewImage += wPad;
    }

    // Store the pointer to the block size WORD
    BYTE far * pBlockSize = *lplpImage;

    // Check if the value is a string or a BYTE array
    if(ver.wType) {
        // it is a string, copy the updated item
        // Check if we had a string in this field
        if(ver.wValueLen) {
            BYTE far * lpImageStr = *lplpImage+wHead+wPad;
            wValue = (WORD)PutStringW(&lpImageStr, lpStr, pdwSize);
            lpNewImage += wValue;

            // Check if padding is needed
            if ((Pad4(wValue)) && (*pdwSize>=(int)Pad4(wValue))) {
                memset( *lplpImage+ver.wHead+wValue+wPad, 0, Pad4(wValue) );
                *pdwSize -= Pad4(wValue);
                lpNewImage += Pad4(wValue);
            }

            WORD wPad1 = Pad4(wValue);
            WORD wFixUp = wValue/sizeofWord;
            *pwTrash = Pad4(ver.wValueLen);
            wValue += wPad1;
            // Fix to the strange behaviour of the ver.dll
            if((wPad1) && (wPad1>=*pwTrash)) {
                wValue -= *pwTrash;
            } else *pwTrash = 0;
            // Fix up the Value len field. We will put the len of the value without padding
            // The len will be in char so since the string is unicode will be twice the size
            memcpy( pBlockSize+2, &wFixUp, 2);
        }
    } else {
        // it is an array, just copy it in the new image buffer
        wValue = ver.wValueLen;
        if (*pdwSize>=(int)ver.wValueLen) {
            memcpy(*lplpImage+wHead+wPad, ver.pValue, ver.wValueLen);
            *pdwSize -= ver.wValueLen;
            lpNewImage += ver.wValueLen;
        }

        // Check if padding is needed
        if ((Pad4(ver.wValueLen)) && (*pdwSize>=(int)Pad4(ver.wValueLen))) {
            memset( *lplpImage+ver.wHead+ver.wValueLen+wPad, 0, Pad4(ver.wValueLen) );
            *pdwSize -= Pad4(ver.wValueLen);
            lpNewImage += Pad4(ver.wValueLen);
        }
        wPad += Pad4(ver.wValueLen);
    }

    *lplpBlockSize = pBlockSize;
    *lplpImage = lpNewImage;
    return wPad+wValue+wHead;
}


/*
 * Will return the matching LPRESITEM
 */
 LPRESITEM
GetItem( BYTE far * lpBuf, LONG dwNewSize, LPSTR lpStr )
{
    LPRESITEM lpResItem = (LPRESITEM) lpBuf;

    while(strcmp(lpResItem->lpszClassName, lpStr)) {
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
        if (dwNewSize<=0)
            return LPNULL;
        lpResItem = (LPRESITEM) lpBuf;
    }
    return lpResItem;
}


UINT
UpdateVerst( LPVOID lpNewBuf, LONG dwNewSize,
             LPVOID lpOldI, LONG dwOldImageSize,
             LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    /*
     * This Function is a big mess. It is like this because the RC compiler generate
     * some inconsistent code so we have to do a lot of hacking to get the VS working
     * In future, if ever ver.dll and the RC compiler will be fixed will be possible
     * fix some of the bad thing we have to do to get the updated VS as consistent as
     * possible with the old one
     */

    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;
    char szCaption[300];
    char szUpdCaption[300];
    char szUpdKey[100];

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    WORD wPad = 0;

    // Pointer to the block size to fix up later
    BYTE far * lpVerBlockSize = LPNULL;
    BYTE far * lpSFIBlockSize = LPNULL;
    BYTE far * lpTrnBlockSize = LPNULL;
    BYTE far * lpStrBlockSize = LPNULL;
    BYTE far * lpTrnBlockName = LPNULL;
    BYTE far * lpDummy = LPNULL;

    LONG dwDummySize;

    WORD wVerBlockSize = 0;
    WORD wSFIBlockSize = 0;
    WORD wTrnBlockSize = 0;
    WORD wStrBlockSize = 0;
    WORD wTrash = 0;        // we need this to fix a bug in the RC compiler
    WORD wDefaultLang = 0x0409;

    // StringFileInfo
    VER_BLOCK SFI;   // StringFileInfo
    LONG lSFILen = 0;

    // Translation blocks
    VER_BLOCK Trn;
    LONG lTrnLen = 0;
    BOOL bHasTranslation=(NULL != GetItem( lpBuf, dwNewSize, "Translation"));
    BOOL bTrnBlockFilled=FALSE;

    VER_BLOCK Str;   // Strings

    // we read first of all the information from the VS_VERSION_INFO block
    VER_BLOCK VS_INFO; // VS_VERSION_INFO

    int iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &VS_INFO );

    // Write the block in the new image
    wVerBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, VS_INFO,
                                &VS_INFO.szValue[0], &lpVerBlockSize, &wTrash );

    dwOverAllSize = wVerBlockSize+wTrash;

    LONG lVS_INFOLen = VS_INFO.wBlockLen - iHeadLen;

    while(dwOldImageSize>0) {
        //Get the StringFileInfo
        iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &SFI );

        // Check if this is the StringFileInfo field
        if (!strcmp(SFI.szKey, "StringFileInfo")) {
            bTrnBlockFilled=TRUE;
            // Read all the translation blocks
            lSFILen = SFI.wBlockLen-iHeadLen;
            // Write the block in the new image
            wSFIBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, SFI,
                                         &SFI.szValue[0], &lpSFIBlockSize, &wTrash );
            dwOverAllSize += wSFIBlockSize+wTrash;

            while(lSFILen>0) {
                // Read the Translation block
                iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &Trn );
                // Calculate the right key name
                if ((lpResItem = GetItem( lpBuf, dwNewSize, Trn.szKey)) && bHasTranslation)  {
                	// We default to UNICODE for the 32 bit files
                    WORD wLang;
                    if(lpResItem)
                    {
                        if (lpResItem->dwLanguage != 0xffffffff)
                        {
                            wLang = LOWORD(lpResItem->dwLanguage);
                        }
                        else
                        {
                            wLang = wDefaultLang;
                        }
                    }
                    GenerateTransField( wLang, &Trn );

                    // Save the position for later Fixup
                    lpTrnBlockName = lpNewImage;
                }
                // Write the block in the new image
                wTrnBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, Trn,
                                             &Trn.szValue[0], &lpTrnBlockSize, &wTrash );
                dwOverAllSize += wTrnBlockSize+wTrash;
                lTrnLen = Trn.wBlockLen-iHeadLen;
                while(lTrnLen>0) {
                    // Read the Strings in the block
                    iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &Str );
                    lTrnLen -= iHeadLen;
                    TRACE2("Key: %s\tValue: %s\n", Str.szKey, Str.szValue );
                    TRACE3("Len: %d\tValLen: %d\tType: %d\n", Str.wBlockLen, Str.wValueLen, Str.wType );

                    strcpy(szCaption, Str.szValue);
                    // Check if this Item has been updated
                    if ((lpResItem = GetItem( lpBuf, dwNewSize, Str.szKey)))  {
                        strcpy( szUpdCaption, lpResItem->lpszCaption );
                        strcpy( szUpdKey, lpResItem->lpszClassName );
                    }
                    if (!strcmp( szUpdKey, Str.szKey)) {
                        strcpy( szCaption, szUpdCaption );
                        wUpdPos = 0;
                    }

                    // Write the block in the new image
                    wStrBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, Str,
                                                 szCaption, &lpStrBlockSize, &wTrash );
                    dwOverAllSize += wStrBlockSize+wTrash;

                    // Fix up the size of the block
                    if (dwNewImageSize>=0)
                        memcpy( lpStrBlockSize, &wStrBlockSize, 2);

                    wTrnBlockSize += wStrBlockSize + wTrash;
                }
                lSFILen -= Trn.wBlockLen;
                // Fix up the size of the block
                if (dwNewImageSize>=0)
                    memcpy( lpTrnBlockSize, &wTrnBlockSize, 2);

                wSFIBlockSize += wTrnBlockSize;
            }
            lVS_INFOLen -= SFI.wBlockLen;
            // Fix up the size of the block
            if (dwNewImageSize>=0)
                memcpy( lpSFIBlockSize, &wSFIBlockSize, 2);
            wVerBlockSize += wSFIBlockSize;

        } else {
            // this is another block skip it all
            lVS_INFOLen -= SFI.wValueLen+iHeadLen;


            // Check if this block is the translation field
            if (!strcmp(SFI.szKey, "Translation")) {
                // it is calculate the right value to place in the value field
                // We calculate automatically the value to have the correct
                // localized language in the translation field
                //wVerBlockSize += PutTranslation( &lpNewImage, &dwNewImageSize, SFI );
                // check if this is the translation block
                // This is the translation block let the localizer have it for now

                //
                // We do generate the Tranlsation filed from the language
                // We will have to update the block name as well
                //

                DWORD dwCodeLang = 0;
                if ((lpResItem = GetItem( lpBuf, dwNewSize, SFI.szKey)))
                {
                    WORD wLang = 0x0409;
                    if(lpResItem)
                        wLang = (LOWORD(lpResItem->dwLanguage)!=0xffff ? LOWORD(lpResItem->dwLanguage) : 0x0409);
                    dwCodeLang = GenerateTransField(wLang, FALSE);

                    if (bTrnBlockFilled)
                    {
                        // fix up the block name
                        GenerateTransField( wLang, &Trn );

                        // Write the block in the new image
                        dwDummySize = dwNewImageSize;
                        PutVSBlock( &lpTrnBlockName, &dwDummySize, Trn,
                                             &Trn.szValue[0], &lpDummy, &wTrash );

                        // Fix up the block size
                        memcpy( lpTrnBlockSize, &wTrnBlockSize, 2);
                    }
                    else
                    {
                        wDefaultLang = LOWORD(dwCodeLang);
                    }
                } else {
                    // Place the original value here
                    dwCodeLang =(DWORD)*(SFI.pValue);
                }
                LONG lDummy = 4;
                SFI.pValue -= PutDWord( &SFI.pValue, dwCodeLang, &lDummy );
            }

            // Write the block in the new image
            wVerBlockSize += (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, SFI,
                                         &SFI.szValue[0], &lpDummy, &wTrash );
            if (dwNewImageSize>=0)
                memcpy( lpVerBlockSize, &wVerBlockSize, 2);

            dwOverAllSize = wVerBlockSize+wTrash;
        }
    }

    // fix up the block size
    if (dwNewImageSize>=0)
        memcpy( lpVerBlockSize, &wVerBlockSize, 2);

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad16((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}

UINT GetStringU( PWCHAR pwStr, LPSTR pszStr )
{
    PWCHAR pwStart = pwStr;
    while (*pwStr!=0x0000) {
        *(pszStr++) = LOBYTE(*(pwStr++));
    }
    *(pszStr++) = LOBYTE(*(pwStr++));
    return (UINT)(pwStr-pwStart);
}


UINT
SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwSize )
{
    if(*pdwSize>=(int)uiSkip) {
        *lplpBuf += uiSkip;;
        *pdwSize -= uiSkip;
    }
    return uiSkip;
}


BYTE
GetDWord( BYTE far * far* lplpBuf, DWORD* dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWord){
        memcpy( dwValue, *lplpBuf, sizeofDWord);
        *lplpBuf += sizeofDWord;
        *pdwSize -= sizeofDWord;
    } else *dwValue = 0;
    return sizeofDWord;
}


BYTE
GetWord( BYTE far * far* lplpBuf, WORD* wValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofWord){
        memcpy( wValue, *lplpBuf, sizeofWord);
        *lplpBuf += sizeofWord;
        *pdwSize -= sizeofWord;
    } else *wValue = 0;
    return sizeofWord;
}


BYTE
GetByte( BYTE far * far* lplpBuf, BYTE* bValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofByte){
        memcpy(bValue, *lplpBuf, sizeofByte);
        *lplpBuf += sizeofByte;
        *pdwSize -= sizeofByte;
    } else *bValue = 0;
    return sizeofByte;
}


UINT
GetStringW( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize, WORD cLen )
{
    if(*lplpBuf==NULL)
        return 0;

    int cch = _WCSLEN((WCHAR*)*lplpBuf);
    if (*pdwSize>=cch){
    _WCSTOMBS( lpszText, (WCHAR*)*lplpBuf, cLen );
    *lplpBuf += (cch*sizeofWord);
        *pdwSize -= (cch*sizeofWord);
    } else *lplpBuf = '\0';
    return(cch*2);
}


UINT
GetStringA( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    if(*lplpBuf==NULL)
        return 0;

    int iSize = strlen((char*)*lplpBuf)+1;
    if (*pdwSize>=iSize){
        memcpy( lpszText, *lplpBuf, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else *lplpBuf = '\0';
    return iSize;
}


UINT
GetPascalString( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wMaxLen, LONG* pdwSize )
{
    // Get the length of the string
    WORD wstrlen = 0;
    WORD wMBLen = 0;
    GetWord( lplpBuf, &wstrlen, pdwSize );

    if ((wstrlen+1)>wMaxLen) {
        *pdwSize -= wstrlen*2;
        *lplpBuf += wstrlen*2;
    } else {
        if (wstrlen) {
	        WCHAR* lpwszStr = new WCHAR[wstrlen+1];
	        if (!lpwszStr)
	            *pdwSize =-1;
	        else {
	        	memcpy(lpwszStr, *lplpBuf, (wstrlen*2));
	        	*(lpwszStr+wstrlen) = 0;
	        	
                if(lstrlenW(lpwszStr) < wstrlen)
                {
                    // We have at least one \0 in the string.
                    // This is done to convert \0 in the string in to \\0
                    // First pass check how many \0 we have
                    int c = wstrlen;
                    int czero = 0;
                    while(c)
                    {
                        c--;
                        if((WORD)*(lpwszStr+c)==0)
                        {
                            czero++;
                        }
                    }

                    // Now that we have the size reallocate the buffer
                    delete lpwszStr;
                    if ((wstrlen+czero*_NULL_TAG_LEN_+1)>wMaxLen) {
                        *pdwSize -= wstrlen*2;
                        *lplpBuf += wstrlen*2;
                    }
                    else {
                        WCHAR* lpwszStr = new WCHAR[wstrlen+czero*_NULL_TAG_LEN_+1];
                        if (!lpwszStr)
	                        *pdwSize =-1;
	                    else {
                            int clen = 0;
                            c = 0;
                            WCHAR* lpwStr = (WCHAR*)*lplpBuf;
                            WCHAR* lpwStrW = lpwszStr;
                            while(c<wstrlen)
                            {
                                if((WORD)*(lpwStr+c)==0)
                                {
                                    memcpy(lpwStrW, _W_RLT_NULL_, (_NULL_TAG_LEN_*2));
                                    lpwStrW += _NULL_TAG_LEN_;
                                    clen += _NULL_TAG_LEN_-1;
                                }
                                else
                                    *lpwStrW++ = *(lpwStr+c);

                                clen++;
                                c++;
                            }

                            *(lpwszStr+clen) = 0;
                            wMBLen = (WORD)_WCSTOMBS( lpszText, (WCHAR*)lpwszStr, wMaxLen);
                            delete lpwszStr;
                        }
                    }
                }
                else
                {
	            	wMBLen = (WORD)_WCSTOMBS( lpszText, (WCHAR*)lpwszStr, wMaxLen);
                    delete lpwszStr;
                }

	        }
        }
        *(lpszText+wMBLen) = 0;
        *lplpBuf += wstrlen*2;
        *pdwSize -= wstrlen*2;
    }
    return(wstrlen+1);
}


UINT
PutMsgStr( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wFlags, LONG* pdwSize )
{
    // Put the length of the entry
    UINT uiLen = strlen(lpszText)+1;

    //for unicode string;
    WCHAR* lpwszStr = new WCHAR[uiLen*2];

    if(wFlags && uiLen)
         uiLen = _MBSTOWCS(lpwszStr, lpszText, uiLen*sizeofWord)*sizeofWord;

    UINT uiPad = Pad4(uiLen);
    UINT uiWrite = PutWord(lplpBuf, (WORD) uiLen+4+uiPad, pdwSize);

    // Write the flag
    uiWrite += PutWord(lplpBuf, wFlags, pdwSize);

    // Write the string
    if (*pdwSize>=(int) uiLen)
        if (uiLen){
            if (wFlags)
                memcpy(*lplpBuf, lpwszStr, uiLen);
            else
                memcpy(*lplpBuf, lpszText, uiLen);

            *lplpBuf += uiLen;
            *pdwSize -= uiLen;
            uiWrite += uiLen;
        }
     else
        *pdwSize = -1;

    // Padding
    while(uiPad) {
        uiWrite += PutByte(lplpBuf, 0, pdwSize);
        uiPad--;
    }

    delete lpwszStr;
    return uiWrite;
}


UINT
GetMsgStr( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wMaxLen, WORD* pwLen, WORD* pwFlags, LONG* pdwSize )
{

    // Get the length of the entry
    UINT uiRead = GetWord( lplpBuf, pwLen, pdwSize );

    // Get the flag
    uiRead += GetWord( lplpBuf, pwFlags, pdwSize );

    if (!*pwLen)
        return 0;

    // If flags=1 then the string is a unicode str else is ASCII
    // Bug #354 We cannot assume the string is NULL terminated.
    // There is no specification if the string is a NULL terminated string but since
    // the doc say that the format is similar to the stringtable then
    // we have to assume the string is not NULL terminated

    WORD wstrlen = *pwLen-4; // Get the len of the entry and subtract 4 (len + flag)
    WORD wMBLen = 0;
    if ((wstrlen+1)>wMaxLen) {
    } else {
        if (wstrlen && *pwFlags) {
            wMBLen = (WORD)_WCSTOMBS( lpszText, (WCHAR*)*lplpBuf, wMaxLen );
        } else memcpy( lpszText, (char*)*lplpBuf, wstrlen );

        *(lpszText+(wstrlen)) = 0;
        TRACE1("Caption: %Fs\n", (wstrlen<256 ? lpszText : "\n"));
    }
    *lplpBuf += *pwLen-uiRead;
    *pdwSize -= *pwLen-uiRead;

    return(wstrlen);
}



UINT
GetNameOrOrd( BYTE far * far* lplpBuf,  WORD* wOrd, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if(*lplpBuf==NULL)
        return 0;

    *wOrd = (WORD)(((**lplpBuf)<<8)+(*(*lplpBuf+1)));
    if((*wOrd)==0xFFFF) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        *lpszText = '\0';
    } else {
        uiSize += GetStringW( lplpBuf, lpszText, pdwSize, 128 );
        *wOrd = 0;
    }
    return uiSize;
}


UINT
GetCaptionOrOrd( BYTE far * far* lplpBuf,  WORD* wOrd, LPSTR lpszText, LONG* pdwSize,
	WORD wClass, DWORD dwStyle )
{
    UINT uiSize = 0;

    if(*lplpBuf==NULL)
        return 0;

    *wOrd = (WORD)(((**lplpBuf)<<8)+(*(*lplpBuf+1)));
    if((*wOrd)==0xFFFF) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        *lpszText = '\0';
    } else {
        uiSize += GetStringW( lplpBuf, lpszText, pdwSize, MAXSTR );
        *wOrd = 0;
    }
    return uiSize;
}


UINT
GetClassName( BYTE far * far* lplpBuf,  WORD* wClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if(*lplpBuf==NULL)
        return 0;

    *wClass = (WORD)(((**lplpBuf)<<8)+(*(*lplpBuf+1)));
    if( *wClass==0xFFFF ) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wClass, pdwSize );
        uiSize += GetWord( lplpBuf, wClass, pdwSize );
        *lpszText = '\0';
    } else {
        uiSize += GetStringW( lplpBuf, lpszText, pdwSize, 128 );
        *wClass = 0;
    }
    return uiSize;
}

 LONG ReadFile(CFile* pFile, UCHAR * pBuf, LONG lRead)
{
    LONG lLeft = lRead;
    WORD wRead = 0;
    DWORD dwOffset = 0;

    while(lLeft>0){
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!=_lread( (HFILE)pFile->m_hFile, (UCHAR *)pBuf+dwOffset, wRead))
            return 0l;
        lLeft -= wRead;
        dwOffset += wRead;
    }
    return dwOffset;

}

 UINT CopyFile( CFile* pfilein, CFile* pfileout )
{
    LONG lLeft = pfilein->GetLength();
    WORD wRead = 0;
    DWORD dwOffset = 0;
    BYTE far * pBuf = (BYTE far *) new BYTE[32739];

    if(!pBuf)
        return ERROR_NEW_FAILED;

    while(lLeft>0){
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!= pfilein->Read( pBuf, wRead))
            return ERROR_FILE_READ;
        pfileout->Write( pBuf, wRead );
        lLeft -= wRead;
        dwOffset += wRead;
    }

    delete []pBuf;
    return ERROR_NO_ERROR;
}

 UINT GetRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize, DWORD* dwFileOffset )
{
    UINT uiSize = 0l;
	LONG lSize = *puiBufSize;

    uiSize = GetWord( lplpBuffer, wTypeId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszTypeId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, Pad4(uiSize), (LONG*)&lSize );

    uiSize += GetWord( lplpBuffer, wNameId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszNameId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, Pad4(uiSize), (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwLang, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwSize, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwFileOffset, (LONG*)&lSize );

	*puiBufSize = lSize;
    return uiSize;
}

 UINT GetUpdatedRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize )
{
    UINT uiSize = 0l;
	LONG lSize = *puiBufSize;

    uiSize = GetWord( lplpBuffer, wTypeId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszTypeId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, Pad4(uiSize), (LONG*)&lSize );

    uiSize += GetWord( lplpBuffer, wNameId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszNameId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, Pad4(uiSize), (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwLang, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwSize, (LONG*)&lSize );

	*puiBufSize = lSize;

    return 0;
}


UINT
PutClassName( BYTE far * far* lplpBuf,  WORD wClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if( (wClass==0x0080) ||
        (wClass==0x0081) ||
        (wClass==0x0082) ||
        (wClass==0x0083) ||
        (wClass==0x0084) ||
        (wClass==0x0085)
        ) {
        // This is an Ordinal
        uiSize += PutWord(lplpBuf, 0xFFFF, pdwSize);
        uiSize += PutWord(lplpBuf, wClass, pdwSize);
    } else {
        uiSize += PutStringW(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


UINT
PutPascalStringW( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wLen, LONG* pdwSize )
{
	UINT uiSize = 0;
    WCHAR * pWStrBuf = (WCHAR*)&wszUpdCaption;
  	// calculate the necessary lenght
	WORD wWCLen = (WORD)_MBSTOWCS( pWStrBuf, lpszText, 0 );
	
    if(wWCLen>MAXSTR)
    {
        // Allocate a new buffer
        pWStrBuf = new WCHAR[wWCLen+1];
    }

    WCHAR * pWStr = pWStrBuf;

    // convert the string for good
    wLen = _MBSTOWCS( pWStr, lpszText, wWCLen )-1;

    WCHAR * wlpRltNull = pWStr;
    WCHAR * wlpStrEnd = pWStr+wLen;

    // First of all check for _RLT32_NULL_ tag
    while((wlpRltNull = wcsstr(wlpRltNull, _W_RLT_NULL_)) && (wlpStrEnd>=wlpRltNull))
    {
        // remove the null tag and place \0
        *wlpRltNull++ = 0x0000;
        wlpRltNull = (WCHAR*)memmove(wlpRltNull, wlpRltNull+_NULL_TAG_LEN_-1, (short)(wlpStrEnd-(wlpRltNull+_NULL_TAG_LEN_-1))*2 );
        wlpStrEnd -= (_NULL_TAG_LEN_-1);
    }

    wLen = (WORD)(wlpStrEnd-pWStr);

	// We will use the buffer provided by the szUpdCaption string to calculate
	// the necessary lenght
	//wWCLen = _MBSTOWCS( (WCHAR*)&szUpdCaption, lpszText, 0 ) - 1;
	//if (wWCLen>1)
	//	wLen = wWCLen;
	uiSize = PutWord( lplpBuf, wLen, pdwSize );
	
    if (*pdwSize>=(int)(wLen*2)){
        if(wLen) {
        	//wLen = _MBSTOWCS( (WCHAR*)*lplpBuf, lpszText, wWCLen );
            memcpy(*lplpBuf, pWStr, wLen*2);
        }
        *lplpBuf += wLen*2;
        *pdwSize -= wLen*2;
    } else *pdwSize = -1;

    if(pWStrBuf!=(WCHAR*)&wszUpdCaption)
        delete pWStrBuf;

    return uiSize+(wWCLen*2);
}

 void GenerateTransField( WORD wLang, VER_BLOCK * pVer )
{
    // Get the DWORD value
    DWORD dwValue = GenerateTransField( wLang, TRUE );
    char buf[9];


    // Put the value in the string value
    wsprintf( &buf[0], "%08lX", dwValue );

    TRACE3("\t\tGenerateTransField: Old: %s\tNew : %s\t dwValue: %lX\n", pVer->szKey, buf, dwValue );
    // Just check if we are in the right place. Should never have problem
    if(strlen(pVer->szKey)==8) {
        // We have to change the header in the image, not just the szKey field
        // Get the pointer to he begin of the field
        WORD wPad = Pad4(pVer->wHead);
        LONG cbDummy =18;
        BYTE far * pHead = pVer->pValue-pVer->wHead-wPad;
        pHead += 6; // Move at the begin of the string
        PutStringW(&pHead, buf, &cbDummy);
    }
}

 DWORD GenerateTransField(WORD wLang, BOOL bMode)
{
    // we have to generate a table to connect
    // the language with the correct code page

    WORD wCP = 1200;        // Unicode

    if (bMode)
    	return MAKELONG( wCP, wLang );
    else return MAKELONG( wLang, wCP );
}

 LONG Allign( LPLPBYTE lplpBuf, LONG* plBufSize, LONG lSize )
{
   LONG lRet = 0;
   BYTE bPad =(BYTE)PadPtr(lSize);
   lRet = bPad;
   if (bPad && *plBufSize>=bPad) {
      while(bPad && *plBufSize)  {
         **lplpBuf = 0x00;
         *lplpBuf += 1;
         *plBufSize -= 1;
         bPad--;
      }
   }
   return lRet;
}

UINT
ParseEmbeddedFile( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
	// we will return just one item so the iodll will handle this resource as
	// something valid. We will not bother doing anything else. The only thing
	// we are interesed is the raw data in the immage, but if we don't return at
	// least one item IODLL will consider the resource empty.
	BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;
    LONG dwOverAllSize = 0;

	TRACE1("ParseEmbeddedFile: dwISize=%ld\n", dwISize);

	dwOverAllSize += PutDWord( &lpBuf, sizeof(RESITEM), &dwBufSize);

    // We have the size and pos in a cursor but we are not interested now
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

    // we don't have checksum and style
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    //Put the Flag
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // The ID will be just 1
    dwOverAllSize += PutDWord( &lpBuf, 1, &dwBufSize);

    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage or the font name
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

    // Let's put null were we don;t have the strings
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);

    // we just return. This is enough for IODLL
    return (UINT)(dwOverAllSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\inf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\common\helper.cpp ===
//////////////////////////////////////////////
//
// This file has the helper function used in the win32 r/w
// I copied them in this file to share them with the res32 r/w
//
#include <afxwin.h>
#include "..\common\helper.h"

//=============================================================================
// Get functions
//

UINT
GetPascalStringW( BYTE  * * lplpBuf, LPSTR lpszText, WORD wMaxLen, LONG* pdwSize )
{
    // Get the length of the string
    WORD wstrlen = 0;
    WORD wMBLen = 0;
    GetWord( lplpBuf, &wstrlen, pdwSize );

    if ((wstrlen+1)>wMaxLen) {
        *pdwSize -= wstrlen*2;
        *lplpBuf += wstrlen*2;
    } else {
        if (wstrlen) {
	        WCHAR* lpwszStr = new WCHAR[wstrlen+1];
	        if (!lpwszStr) *pdwSize =0;
	        else {
	        	memcpy(lpwszStr, *lplpBuf, (wstrlen*2));
	        	*(lpwszStr+wstrlen) = 0;
	        	wMBLen = (WORD)_WCSTOMBS( lpszText, (WCHAR*)lpwszStr, wMaxLen);
	        	delete lpwszStr;
	        }
        }
        *(lpszText+wMBLen) = 0;
        *lplpBuf += wstrlen*2;
        *pdwSize -= wstrlen*2;
    }
    return(wstrlen+1);
}

UINT
GetPascalStringA( BYTE  * * lplpBuf, LPSTR lpszText, BYTE bMaxLen, LONG* pdwSize )
{
    // Get the length of the string
    BYTE bstrlen = 0;

    GetByte( lplpBuf, &bstrlen, pdwSize );

    if ((bstrlen+1)>bMaxLen) {
        *pdwSize -= bstrlen;
        *lplpBuf += bstrlen;
    } else {
        if (bstrlen)
	        memcpy(lpszText, *lplpBuf, bstrlen);

        *(lpszText+bstrlen) = 0;
        *lplpBuf += bstrlen;
        *pdwSize -= bstrlen;
    }
    return(bstrlen+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\common\m68k.cpp ===
//=============================================================================
//	Mac Reader/Writer functions
//
//	Alessandro Muti - August 25 1994
//=============================================================================

#include <afxwin.h>
#include <limits.h>
#include <iodll.h>
#include "helper.h"
#include "m68k.h"
#include "..\mac\mac.h"

#define MAX_STR 1024

static char szTextBuf[MAX_STR];
static WORD szWTextBuf[MAX_STR];

//=============================================================================
//=============================================================================
//
// PE Header parsing functions
//
//=============================================================================
//=============================================================================

//=============================================================================
// FindMacResourceSection
//
// Will walk the section header searching for ";;resxxx" resource name.
// If pResName is NULL then will return the first section otherwise will
// return the first section matching after the pResName.
// If there are no more resource section will return FALSE.
//=============================================================================

UINT FindMacResourceSection( CFile* pfile, BYTE * * pRes, PIMAGE_SECTION_HEADER * ppSectTbl, int * piNumOfSect )
{
    UINT uiError = ERROR_NO_ERROR;
	LONG lRead = 0;
	PIMAGE_SECTION_HEADER pResSect = NULL;

    // Check all the sections for the ";;resXXX"
    USHORT us =0;
    for (PIMAGE_SECTION_HEADER pSect = *ppSectTbl;
         *piNumOfSect; (*piNumOfSect)-- )     {
        if ( !strncmp((char*)pSect->Name, ";;res", 5) ) {
			// we have a matching
			TRACE("\tFindMacResourceSection: Name: %s\tSize: %d\n", pSect->Name, pSect->SizeOfRawData);
			pResSect = pSect;
			*ppSectTbl = pSect;
			break;
        }
        pSect++;
    }

    if (!pResSect) {
        return ERROR_RW_NO_RESOURCES;
    }

    BYTE * pResources = (BYTE *) malloc((pResSect)->SizeOfRawData);

    if (pResources==LPNULL) {
        return ERROR_NEW_FAILED;
    }

    // We read the data for the first section
    pfile->Seek( (LONG)(pResSect)->PointerToRawData, CFile::begin);
    lRead = ReadFile(pfile, pResources, (LONG)(pResSect)->SizeOfRawData);

    if (lRead!=(LONG)(pResSect)->SizeOfRawData) {
        free(pResources);
        return ERROR_FILE_READ;
    }

    // We want to copy the pointer to the resources
    *pRes = (BYTE*)pResources;
    return 0;
}

//=============================================================================
// ParseResourceFile
//
// pResFile is pointing to the resource file data.
// We will read the resource header to find the resource data and the resource
// map address.
// We will walk the resource map and find the offset to the data for each type
//=============================================================================

UINT ParseResourceFile( BYTE * pResFile, PIMAGE_SECTION_HEADER pResSection, BYTE ** ppBuf, LONG * pBufSize, int iFileNameLen)
{
	MACTOWINDOWSMAP MacToWindows;
	PMACRESHEADER pResHeader = (PMACRESHEADER)pResFile;

	// Move at the beginning of the Resource Map
	PMACRESMAP pResMap = (PMACRESMAP)(pResFile+MacLongToLong(pResHeader->mulOffsetToResMap));

	//Read all the Type in this resource
	WORD wItems = MacWordToWord((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToTypeList))+1;
	BYTE * pStartResTypeList = ((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToTypeList));
	BYTE * pStartNameList = ((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToNameList));
	PMACRESTYPELIST pResTypeList = (PMACRESTYPELIST)(pStartResTypeList+sizeof(WORD));
	
	while(wItems--){
		memcpy(&MacToWindows.szTypeName[0], pResTypeList->szResName, 4);
		MacToWindows.szTypeName[4] = '\0';

		WORD wResItems = MacWordToWord(pResTypeList->mwNumOfThisType)+1;
		TRACE("\t\tType: %s\t Num: %d\n", MacToWindows.szTypeName, wResItems);
		
		// Check if is has a valid Windows Mapping
		MacToWindows.wType = MapToWindowsRes(MacToWindows.szTypeName);

		// For all the items
		PMACRESREFLIST pResRefList = (PMACRESREFLIST)(pStartResTypeList+MacWordToWord(pResTypeList->mwOffsetToRefList));
		while(wResItems && MacToWindows.wType)
		{
			if(MacWordToWord(pResRefList->mwOffsetToResName)==0xFFFF) {
				MacToWindows.wResID = MacWordToWord(pResRefList->mwResID);
				MacToWindows.szResName[0] = '\0';
				TRACE("\t\t\tResId: %d",MacToWindows.wResID);
			}
			else {
				// It is a named resource
				BYTE * pName = pStartNameList+MacWordToWord(pResRefList->mwOffsetToResName);
				memcpy( &MacToWindows.szResName[0], pName+1, *pName );
				MacToWindows.szResName[*pName] = '\0';
                //if(!strcmp("DITL", MacToWindows.szTypeName))
                    MacToWindows.wResID = MacWordToWord(pResRefList->mwResID);
                //else MacToWindows.wResID = 0;
				TRACE("\t\t\tResName: %s (%d)",MacToWindows.szResName, MacWordToWord(pResRefList->mwResID) );
			}

			// Get the offset to the data (relative to the beginning of the section)
			MacToWindows.dwOffsetToData = MacLongToLong(pResHeader->mulOffsetToResData)+MacOffsetToLong(pResRefList->bOffsetToResData);
			
			BYTE * pData = (pResFile + MacToWindows.dwOffsetToData);
			MacToWindows.dwSizeOfData = MacLongToLong(pData);
			
			// add the space for the file name
			MacToWindows.dwSizeOfData += iFileNameLen;

			//Fix up offet to data relative to the beginning of the file
			MacToWindows.dwOffsetToData += pResSection->PointerToRawData+sizeof(DWORD);
			TRACE("\tSize: %d\tOffset: %X\n", MacToWindows.dwSizeOfData, MacToWindows.dwOffsetToData);

			// Write the info in the IODLL buffer
			WriteResInfo(
                 ppBuf, pBufSize,
                 MacToWindows.wType, MacToWindows.szTypeName, 5,
                 MacToWindows.wResID, MacToWindows.szResName, 255,
                 0l,
                 MacToWindows.dwSizeOfData, MacToWindows.dwOffsetToData );

			wResItems--;
			pResRefList++;
		}
		
		// Read next type
		pResTypeList++;
	}

	return 0;
}

//=============================================================================
//	FindResource
//
//	Will find the resource of the specified type and ID in the file.
//	Return a pointer to the resource data. Will need to be freed by the caller
//=============================================================================

DWORD FindMacResource( CFile * pfile, LPSTR pType, LPSTR pName )
{
	DWORD dwOffset = 0;
	////////////////////////////////////
	// Check if it is  a valid mac file
	// Is a Mac Resource file ...
	if(IsMacResFile( pfile )) {
		// load the file in memory
		BYTE * pResources = (BYTE*)malloc(pfile->GetLength());
		if(!pResources) {
			return 0;
		}
		
		pfile->Seek(0, CFile::begin);
		pfile->ReadHuge(pResources, pfile->GetLength());

		IMAGE_SECTION_HEADER Sect;
		memset(&Sect, 0, sizeof(IMAGE_SECTION_HEADER));
		
		dwOffset = FindResourceInResFile(pResources, &Sect, pType, pName);
		free(pResources);

		return dwOffset;
	}
	// or is a PE Mac File ...
	// Read the Windows Header
	WORD w;
	pfile->Seek(0, CFile::begin);
    pfile->Read((WORD*)&w, sizeof(WORD));
    if (w!=IMAGE_DOS_SIGNATURE) return 0;

    pfile->Seek( 0x18, CFile::begin );
    pfile->Read((WORD*)&w, sizeof(WORD));
    if (w<0x0040) {
    	// this is not a Windows Executable
        return 0;
    }

    // get offset to new header
    pfile->Seek( 0x3c, CFile::begin );
    pfile->Read((WORD*)&w, sizeof(WORD));

    // read windows new header
    static IMAGE_NT_HEADERS NTHdr;
    pfile->Seek( w, CFile::begin );
    pfile->Read(&NTHdr, sizeof(IMAGE_NT_HEADERS));

    // Check if the magic word is the right one
    if (!((NTHdr.Signature==IMAGE_NT_SIGNATURE) &&
    	  (NTHdr.FileHeader.Machine==IMAGE_FILE_MACHINE_M68K)))
              return 0;

    // Read the section table
    UINT uisize = sizeof(IMAGE_SECTION_HEADER) * NTHdr.FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER pSectTbl = new IMAGE_SECTION_HEADER[NTHdr.FileHeader.NumberOfSections];

    if (pSectTbl==LPNULL)
    	return 0;

    // Clean the memory we allocated
    memset( (PVOID)pSectTbl, 0, uisize);

    LONG lRead = pfile->Read(pSectTbl, uisize);

    if (lRead!=(LONG)uisize) {
        delete []pSectTbl;
        return LPNULL;
    }
	
    BYTE * pResources = LPNULL;	
	int iNumOfSect = NTHdr.FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER pStartSectTbl = pSectTbl;
	
	// Search all the resource section in the file
	while(!FindMacResourceSection( pfile, &pResources, &pSectTbl, &iNumOfSect))
	{
		if(dwOffset = FindResourceInResFile(pResources, pSectTbl++, pType, pName)) {
			delete []pStartSectTbl;
			return dwOffset;
		}
		iNumOfSect--;
		free(pResources);
	}

	delete []pStartSectTbl;
	
    return 0;
}

//=============================================================================
// FindResourceInResFile
//
// pResFile is pointing to the resource file data.
// We will read the resource header to find the resource data and the resource
// map address.
// We will walk the resource map and find the offset to the data for the res
// we are searching for.
//=============================================================================

DWORD FindResourceInResFile( BYTE * pResFile, PIMAGE_SECTION_HEADER pResSection, LPSTR pResType, LPSTR pResName)
{
	MACTOWINDOWSMAP MacToWindows;
	PMACRESHEADER pResHeader = (PMACRESHEADER)pResFile;

	// Move at the beginning of the Resource Map
	PMACRESMAP pResMap = (PMACRESMAP)(pResFile+MacLongToLong(pResHeader->mulOffsetToResMap));

	//Read all the Type in this resource
	WORD wItems = MacWordToWord((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToTypeList))+1;
	BYTE * pStartResTypeList = ((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToTypeList));
	BYTE * pStartNameList = ((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToNameList));
	PMACRESTYPELIST pResTypeList = (PMACRESTYPELIST)(pStartResTypeList+sizeof(WORD));
	
	while(wItems--){
		memcpy(&MacToWindows.szTypeName[0], pResTypeList->szResName, 4);
		MacToWindows.szTypeName[4] = '\0';

		if(!strcmp(MacToWindows.szTypeName, pResType)) {

			WORD wResItems = MacWordToWord(pResTypeList->mwNumOfThisType)+1;

			// For all the items
			PMACRESREFLIST pResRefList = (PMACRESREFLIST)(pStartResTypeList+MacWordToWord(pResTypeList->mwOffsetToRefList));
			while(wResItems)
			{
				if(!HIWORD(pResName)) {
					if(MacWordToWord(pResRefList->mwResID)==LOWORD(pResName))
						return MacLongToLong(pResHeader->mulOffsetToResData)+
								MacOffsetToLong(pResRefList->bOffsetToResData)+
								pResSection->PointerToRawData;
				}
				else {
					// It is a named resource
					if(HIWORD(pResName)) {
						BYTE * pName = pStartNameList+MacWordToWord(pResRefList->mwOffsetToResName);
						memcpy( &MacToWindows.szResName[0], pName+1, *pName );
						MacToWindows.szResName[*pName] = '\0';
						if(!strcmp(MacToWindows.szResName,pResName))
							return MacLongToLong(pResHeader->mulOffsetToResData)+
								MacOffsetToLong(pResRefList->bOffsetToResData)+
								pResSection->PointerToRawData;
					}
				}

				wResItems--;
				pResRefList++;
			}
		
		}
		// Read next type
		pResTypeList++;
	}


	return 0;
}

//=========================================================================
// Determine heuristicaly whether it is a MAC resource file.
// Resource file has a well-defined format, so this should be reliable.
//=========================================================================

BOOL IsMacResFile ( CFile * pFile )
{
    LONG flen, dataoff, mapoff, datalen, maplen;
	BYTE Buf[4];
	BYTE * pBuf = &Buf[0];

    //  From IM I-128:
    //
    //  Resource file structure:
    //
    //  256 bytes Resource Header (and other info):
    //      4 bytes - Offset from beginning of resource file to resource data
    //      4 bytes - Offset from beginning of resource file to resource map
    //      4 bytes - Length of resource data
    //      4 bytes - Length of resource map
    //  Resource Data
    //  Resource Map

    flen  = pFile->GetLength();
    if (flen < 256) {
        return FALSE;
    }

    pFile->Seek(0, CFile::begin);
	pFile->Read(pBuf, 4);

    dataoff = MacLongToLong(pBuf);
    if (dataoff != 256) {
        return FALSE;
    }
	
	pFile->Read(pBuf, 4);
    mapoff = MacLongToLong(pBuf);
	pFile->Read(pBuf, 4);
    datalen = MacLongToLong(pBuf);
	pFile->Read(pBuf, 4);
    maplen = MacLongToLong(pBuf);

    if (mapoff != datalen + 256) {
        return FALSE;
    }

    if (flen != datalen + maplen + 256) {
        return FALSE;
    }

    return TRUE;
}

//=============================================================================
//=============================================================================
//
// Parsing functions
//
//=============================================================================
//=============================================================================

//=============================================================================
//	ParseWMNU
//
//	
//=============================================================================
UINT ParseWMNU( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	return 0;
}

//=============================================================================
//	ParseMENU
//
//	
//=============================================================================
UINT ParseMENU( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
    PMACMENU pMenu = (PMACMENU)lpImageBuf;
    LPRESITEM pResItem = (LPRESITEM)lpBuffer;

    // fill in the first resitem
    WORD wResItemSize = sizeof(RESITEM)+pMenu->bSizeOfTitle+1;
    // check if is the apple menu
    if(pMenu->bSizeOfTitle==1 && *((BYTE*)&pMenu->bSizeOfTitle+1)==appleMark)
        wResItemSize += strlen(_APPLE_MARK_);

    DWORD dwResItemsSize = wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), (char*)pMenu+sizeof(MACMENU), pMenu->bSizeOfTitle+1);
        *(pResItem->lpszCaption+pMenu->bSizeOfTitle) = '\0';

        // check if is the apple menu
        if(pMenu->bSizeOfTitle==1 && *((BYTE*)&pMenu->bSizeOfTitle+1)==appleMark)
            strcpy(pResItem->lpszCaption, _APPLE_MARK_);
		
        pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(pResItem->lpszCaption), strlen(pResItem->lpszCaption));
		//pResItem->dwStyle = MacLongToLong(pWdlg->dwStyle);    make up a style
		pResItem->dwTypeID = MENU_TYPE;
		pResItem->dwItemID = 0x0000ffff;
		pResItem->dwCodePage = CODEPAGE;
        pResItem->dwFlags = MF_POPUP | MF_END;
        pResItem->dwSize = wResItemSize;
		dwSize -= wResItemSize;
		
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}

    // parse the items in the menu
    BYTE* pMenuText = (BYTE*)pMenu+sizeof(MACMENU)+pMenu->bSizeOfTitle;
    PMACMENUITEM pMenuItem = (PMACMENUITEM)(pMenuText+*pMenuText+1);
    WORD wItem = 1;
    while((BYTE)*pMenuText)
    {
        wResItemSize = sizeof(RESITEM)+*pMenuText+1;
        if(pMenuItem->bKeyCodeId)
            wResItemSize += 3;
        dwResItemsSize += wResItemSize;
    	if(wResItemSize<=dwSize) {
    		memset(pResItem, 0, wResItemSize);
		
    		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), (char*)pMenuText+sizeof(BYTE), *pMenuText);
            *(pResItem->lpszCaption+*pMenuText) = '\0';

            if(*pResItem->lpszCaption=='-')
            {
                *pResItem->lpszCaption = '\0';
                pResItem->dwFlags = 0;
                pResItem->dwItemID = 0;
            }
            else {
                pResItem->dwItemID = wItem++;
                if(pMenuItem->bKeyCodeMark)
                    pResItem->dwFlags |= MF_CHECKED;
                if(pMenuItem->bKeyCodeId) {
                    strcat(pResItem->lpszCaption, "\t&");
                    strncat(pResItem->lpszCaption, (LPCSTR)&pMenuItem->bKeyCodeId, 1 );
                }
            }

            pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(pResItem->lpszCaption), strlen(pResItem->lpszCaption));
            pResItem->dwTypeID = MENU_TYPE;
    		pResItem->dwCodePage = CODEPAGE;
            pResItem->dwSize = wResItemSize;
    		dwSize -= wResItemSize;
		
    		pMenuText = (BYTE*)pMenuText+sizeof(MACMENUITEM)+*pMenuText+1;
            pMenuItem = (PMACMENUITEM)(pMenuText+*pMenuText+1);
            if(!(BYTE)*pMenuText)
                pResItem->dwFlags |= MF_END;
            pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
    	}

    }

	return dwResItemsSize;
}

//=============================================================================
//	ParseMBAR
//
//	
//=============================================================================
UINT ParseMBAR( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	return 0;
}

//=============================================================================
//	ParseSTR
//
//	The STR resource is a plain Pascal string
//=============================================================================
UINT ParseSTR( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	WORD wLen = (WORD)GetPascalStringA( (BYTE**)&lpImageBuf, &szTextBuf[0], (MAX_STR>255?255:MAX_STR), (LONG*)&dwImageSize);
	WORD wResItemSize = sizeof(RESITEM)+wLen;
	if(wResItemSize<=dwSize) {
		LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	
		// Fill the Res Item structure
		memset(pResItem, 0, wResItemSize);

		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(szTextBuf), wLen);
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = STR_TYPE;
		pResItem->dwItemID = 1;
		pResItem->dwCodePage = CODEPAGE;
	}
	return wResItemSize;
}

//=============================================================================
//	ParseSTRNUM
//
//	The STR# is an array of Pascal string
//=============================================================================
UINT ParseSTRNUM( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	UINT uiResItemsSize = 0;
	DWORD dwBufferSize = dwSize;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	WORD wItems = MacWordToWord((BYTE*)lpImageBuf);
	BYTE * pImage = (BYTE*)((BYTE*)lpImageBuf+sizeof(WORD));

	WORD wResItemSize = 0;
	int iCount = 0;

	while(iCount++<wItems)
	{
		BYTE bLen = *((BYTE*)pImage)+1;
		wResItemSize = (WORD)ParseSTR( pImage, bLen, pResItem, dwBufferSize );

		pImage = pImage+bLen;
		uiResItemsSize += wResItemSize;
		if(dwBufferSize>=wResItemSize) {
			dwBufferSize -= wResItemSize;
			pResItem->dwItemID = iCount;
			pResItem->dwTypeID = MSG_TYPE;
			pResItem = (LPRESITEM)((BYTE*)lpBuffer+uiResItemsSize);
		}
		else dwBufferSize = 0;
	}
	return uiResItemsSize;
}

//=============================================================================
//	ParseTEXT
//
//	The TEXT resource is a plain Pascal string
//=============================================================================
UINT ParseTEXT( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	DWORD dwLen = MacLongToLong((BYTE*)lpImageBuf);
	DWORD dwResItemSize = sizeof(RESITEM)+dwLen;
	if(dwResItemSize<=dwSize) {
		LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	
		// Fill the Res Item structure
		memset(pResItem, 0, dwResItemSize);

		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp((char*)lpImageBuf+sizeof(DWORD)), dwLen);
		pResItem->dwSize = dwResItemSize;
		pResItem->dwTypeID = STR_TYPE;
		pResItem->dwItemID = 1;
		pResItem->dwCodePage = CODEPAGE;
	}
	return dwResItemSize;
}

//=============================================================================
//	ParseWDLG
//
//	
//=============================================================================
UINT ParseWDLG( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	// Get the file name
	char * pFileName = (char*)lpImageBuf;
	lpImageBuf = ((BYTE*)lpImageBuf+strlen(pFileName)+1);
	dwImageSize -= strlen(pFileName)+1;

	DWORD dwResItemsSize = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	PMACWDLG pWdlg = (PMACWDLG)lpImageBuf;

	WORD * pWStr = (WORD*)((BYTE*)pWdlg+sizeof(MACWDLG));

	// Check if we have a menu name
	if(*pWStr!=0xffff) {
		// Just skip the string
		while(*pWStr)
			pWStr++;
	}
	else pWStr = pWStr+1;

	// check if we have a class name
	if(*pWStr!=0xffff) {
		// Just skip the string
		while(*pWStr)
			pWStr++;
	}
	else pWStr = pWStr+1;

	// get the caption
	WORD wLen = GetMacWString( &pWStr, &szTextBuf[0], MAX_STR );
	TRACE("\t\t\tWDLG: Caption: %s\n", szTextBuf);
	
	// fill the dialog frame informations
	WORD wResItemSize = sizeof(RESITEM)+wLen+1;
    dwResItemsSize += wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		// convert the coordinate
		pResItem->wX = MacWordToWord(pWdlg->wX);
		pResItem->wY = MacWordToWord(pWdlg->wY);
		pResItem->wcX = MacWordToWord(pWdlg->wcX);
		pResItem->wcY = MacWordToWord(pWdlg->wcY);
		
		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(szTextBuf), wLen+1);
		
		pResItem->dwStyle = MacLongToLong(pWdlg->dwStyle);
		pResItem->dwExtStyle = MacLongToLong(pWdlg->dwExtStyle);
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = DLOG_TYPE;
		pResItem->dwItemID = 0;
		pResItem->dwCodePage = CODEPAGE;
		dwSize -= wResItemSize;
		
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}
	
	if(MacLongToLong(pWdlg->dwStyle) & DS_SETFONT) {
		pWStr = pWStr+1;
		GetMacWString( &pWStr, &szTextBuf[0], MAX_STR );
	}
	
	// check the alignment
	pWStr=(WORD*)((BYTE*)pWStr+Pad4((BYTE)((DWORD_PTR)pWStr-(DWORD_PTR)pWdlg)));
		
	// for all the item in the dialog ...
	WORD wItems = MacWordToWord(pWdlg->wNumOfElem);
	WORD wCount = 0;
	WORD wClassID = 0;
	char szClassName[128] = "";
	PMACWDLGI pItem = (PMACWDLGI)pWStr;
	while(wCount<wItems)
	{
		wLen = 0;
		// check if we have a class name
		pWStr = (WORD*)((BYTE*)pItem+sizeof(MACWDLGI));
		if(*pWStr==0xFFFF) {
			wClassID = MacWordToWord((BYTE*)++pWStr);
			szClassName[0] = 0;
			pWStr++;
		}
		else
			wLen += GetMacWString( &pWStr, &szClassName[0], 128 )+1;
		
		// get the caption
		wLen += GetMacWString( &pWStr, &szTextBuf[0], MAX_STR )+1;
		TRACE("\t\t\t\tWDLGI: Caption: %s\n", szTextBuf);

		// Skip the extra stuff
		if(*pWStr) {
			pWStr = (WORD*)((BYTE*)pWStr+*pWStr);
		}
		pWStr = pWStr+1;

		// check the alignment
		pWStr=(WORD*)((BYTE*)pWStr+Pad4((BYTE)((DWORD_PTR)pWStr-(DWORD_PTR)pItem)));
	
		// Fill the ResItem Buffer
		wResItemSize = sizeof(RESITEM)+wLen;
		dwResItemsSize += wResItemSize;
		if(wResItemSize<=dwSize) {
			memset(pResItem, 0, wResItemSize);
			
			// convert the coordinate
			pResItem->wX = MacWordToWord(pItem->wX);
			pResItem->wY = MacWordToWord(pItem->wY);
			pResItem->wcX = MacWordToWord(pItem->wcX);
			pResItem->wcY = MacWordToWord(pItem->wcY);

			pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(szTextBuf), strlen(szTextBuf)+1);
			if(*szClassName)
				pResItem->lpszClassName = (char*)memcpy((BYTE*)pResItem->lpszCaption+strlen(szTextBuf)+1,
					szClassName, strlen(szClassName)+1);	
			
			pResItem->wClassName = wClassID;
			pResItem->dwSize = wResItemSize;
			pResItem->dwTypeID = DLOG_TYPE;
			pResItem->dwItemID = MacWordToWord(pItem->wID);
			pResItem->dwCodePage = CODEPAGE;
			pResItem->dwStyle = MacLongToLong(pItem->dwStyle);
			pResItem->dwExtStyle = MacLongToLong(pItem->dwExtStyle);

			dwSize -= wResItemSize;
			pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
		}

		pItem = (PMACWDLGI)(BYTE*)pWStr;
		wCount++;
	}


	return dwResItemsSize;
}

//=============================================================================
//	ParseDLOG
//
//	
//=============================================================================
UINT ParseDLOG( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	// Get the file name
	char * pFileName = (char*)lpImageBuf;
	lpImageBuf = ((BYTE*)lpImageBuf+strlen(pFileName)+1);
	dwImageSize -= strlen(pFileName)+1;

	DWORD dwResItemsSize = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	PMACDLOG pDlog = (PMACDLOG)lpImageBuf;
	
	// fill the dialog frame informations
	WORD wResItemSize = sizeof(RESITEM)+pDlog->bLenOfTitle+1;
    dwResItemsSize += wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		// convert the coordinate
		pResItem->wX = MacValToWinVal(pDlog->wLeft);
		pResItem->wY = MacValToWinVal(pDlog->wTop);
		pResItem->wcX = MacValToWinVal(pDlog->wRight) - pResItem->wX;
		pResItem->wcY = MacValToWinVal(pDlog->wBottom) - pResItem->wY;

		// Make up a Style for the dialog
		pResItem->dwStyle = DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION;

		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp((char*)pDlog+sizeof(MACDLOG)), pDlog->bLenOfTitle);
		*(pResItem->lpszCaption+pDlog->bLenOfTitle) = 0;
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = DLOG_TYPE;
		pResItem->dwItemID = 0;
		pResItem->dwCodePage = CODEPAGE;
		dwSize -= wResItemSize;
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}

	// Find the DITL for this Dialog
	LPSTR pResName = (LPSTR)MacWordToWord(pDlog->wRefIdOfDITL);

	CFile file;
	// Open the file and try to read the information on the resource in it.
    if (!file.Open(pFileName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return LPNULL;
	
	DWORD dwOffsetToDITL = FindMacResource(&file, "DITL", pResName );
	TRACE("\t\t\tParseDLOG:\tItemList %d at offset: %X\n", MacWordToWord(pDlog->wRefIdOfDITL), dwOffsetToDITL );
	if(dwOffsetToDITL) {
		BYTE szSize[4];
		file.Seek(dwOffsetToDITL, CFile::begin);
		file.Read(szSize, 4);
		// Parse the Item List
		LONG lSize = MacLongToLong(szSize);

 		BYTE * pData = (BYTE*)malloc(lSize);
		if(!pData)
			return 0;
		file.Read(pData, lSize);

		dwResItemsSize += ParseDITL( pData, lSize, pResItem, dwSize );

		free(pData);
	}
	
	file.Close();
	return dwResItemsSize;
}

//=============================================================================
//	ParseALRT
//
//	
//=============================================================================
UINT ParseALRT( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	// Get the file name
	char * pFileName = (char*)lpImageBuf;
	lpImageBuf = ((BYTE*)lpImageBuf+strlen(pFileName)+1);
	dwImageSize -= strlen(pFileName)+1;

	DWORD dwResItemsSize = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	PMACALRT pAlrt = (PMACALRT)lpImageBuf;
	
	// fill the dialog frame informations
	WORD wResItemSize = sizeof(RESITEM);
    dwResItemsSize += wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		// convert the coordinate
		pResItem->wX = MacValToWinVal(pAlrt->wLeft);
		pResItem->wY = MacValToWinVal(pAlrt->wTop);
		pResItem->wcX = MacValToWinVal(pAlrt->wRight) - pResItem->wX;
		pResItem->wcY = MacValToWinVal(pAlrt->wBottom) - pResItem->wY;

		// Make up a Style for the dialog
		pResItem->dwStyle = DS_MODALFRAME | WS_POPUP | WS_VISIBLE;

		pResItem->lpszCaption = LPNULL;	// ALRT don't have a title
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = DLOG_TYPE;
		pResItem->dwItemID = 0;
		pResItem->dwCodePage = CODEPAGE;
		dwSize -= wResItemSize;
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}

	// Find the DITL for this Dialog
	LPSTR pResName = (LPSTR)MacWordToWord(pAlrt->wRefIdOfDITL);

	CFile file;
	// Open the file and try to read the information on the resource in it.
    if (!file.Open(pFileName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return LPNULL;
	
	DWORD dwOffsetToDITL = FindMacResource(&file, "DITL", pResName );
	TRACE("\t\t\tParseALRT:\tItemList %d at offset: %X\n", MacWordToWord(pAlrt->wRefIdOfDITL), dwOffsetToDITL );
	if(dwOffsetToDITL) {
		BYTE szSize[4];
		file.Seek(dwOffsetToDITL, CFile::begin);
		file.Read(szSize, 4);
		// Parse the Item List
		LONG lSize = MacLongToLong(szSize);

 		BYTE * pData = (BYTE*)malloc(lSize);
		if(!pData)
			return 0;
		file.Read(pData, lSize);

		dwResItemsSize += ParseDITL( pData, lSize, pResItem, dwSize );

		free(pData);
	}
	file.Close();
	return dwResItemsSize;
}

//=============================================================================
//	ParseWIND
//  WIND is the frame window. I simulate this as a dialog itself, even if all
//	the other components will be inside this one.
//=============================================================================
UINT ParseWIND( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	// Get the file name
	char * pFileName = (char*)lpImageBuf;
	lpImageBuf = ((BYTE*)lpImageBuf+strlen(pFileName)+1);
	dwImageSize -= strlen(pFileName)+1;

	DWORD dwResItemsSize = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	PMACWIND pWind = (PMACWIND)lpImageBuf;
	
	// fill the dialog frame informations
	WORD wResItemSize = sizeof(RESITEM)+pWind->bLenOfTitle+1;
    dwResItemsSize += wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		// convert the coordinate
		pResItem->wX = MacValToWinVal(pWind->wLeft);
		pResItem->wY = MacValToWinVal(pWind->wTop);
		pResItem->wcX = MacValToWinVal(pWind->wRight) - pResItem->wX;
		pResItem->wcY = MacValToWinVal(pWind->wBottom) - pResItem->wY;

		// Make up a Style for the dialog
		pResItem->dwStyle = DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION;

		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp((char*)pWind+sizeof(MACWIND)), pWind->bLenOfTitle);
		*(pResItem->lpszCaption+pWind->bLenOfTitle) = 0;
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = STR_TYPE;  // even if is marked as a WIND_TYPE, mark it a s STR here.
		pResItem->dwItemID = 0;
		pResItem->dwCodePage = CODEPAGE;
		dwSize -= wResItemSize;
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}

	return dwResItemsSize;
}

//=============================================================================
//	ParseDITL
//
//	
//=============================================================================
UINT ParseDITL( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	BYTE bDataLen = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	WORD wItems = MacWordToWord(((BYTE*)lpImageBuf))+1;
	WORD wCount = 1;
	PMACDIT pDitem = (PMACDIT)((BYTE*)lpImageBuf+sizeof(WORD));
	BYTE * pData = (BYTE*)pDitem+sizeof(MACDIT);
	dwImageSize -= sizeof(WORD);
	WORD wResItemSize = 0;
	DWORD dwResItemsSize = 0;

	while(wItems--)
	{
		if((bDataLen = pDitem->bSizeOfDataType) % 2)
			bDataLen++;

		switch((pDitem->bType | 128) - 128)
		{
			case 4:		//button
			case 5: 	//checkbox
			case 6: 	//radio button
			case 8: 	//static text
			case 16: 	//edit text
				memcpy(szTextBuf, pData, pDitem->bSizeOfDataType);
				szTextBuf[pDitem->bSizeOfDataType] = 0;
				wResItemSize = sizeof(RESITEM)+pDitem->bSizeOfDataType+1;
			break;
			case 32: 	//icon
			case 64: 	//quick draw
			default:
				szTextBuf[0] = 0;
				wResItemSize = sizeof(RESITEM)+1;
			break;
		}

		// Fill the ResItem Buffer
		dwResItemsSize += wResItemSize;
		if(wResItemSize<=dwSize) {
			memset(pResItem, 0, wResItemSize);
			
			pResItem->dwStyle = WS_CHILD | WS_VISIBLE;

			// set the correct flag
			switch((pDitem->bType | 128) - 128)
			{
				case 0: 	//user defined
					pResItem->wClassName = 0x82;
					pResItem->dwStyle |= SS_GRAYRECT;
				break;
				case 4:		//button
					pResItem->wClassName = 0x80;
				break;
				case 5: 	//checkbox
					pResItem->wClassName = 0x80;
					pResItem->dwStyle |= BS_AUTOCHECKBOX;
				break;
				case 6: 	//radio button
					pResItem->wClassName = 0x80;
					pResItem->dwStyle |= BS_AUTORADIOBUTTON;
				break;
				case 8: 	//static text
					pResItem->wClassName = 0x82;
				break;
				case 16: 	//edit text
					pResItem->wClassName = 0x81;
					pResItem->dwStyle |= ES_AUTOHSCROLL | WS_BORDER;
				break;
				case 32: 	//icon
					pResItem->wClassName = 0x82;
					pResItem->dwStyle |= SS_ICON;
				break;
				case 64: 	//picture
					pResItem->wClassName = 0x82;
					pResItem->dwStyle |= SS_BLACKRECT;
				break;
				default:
				break;
			}
				
			// convert the coordinate
			pResItem->wX = MacValToWinVal(pDitem->wLeft);
			pResItem->wY = MacValToWinVal(pDitem->wTop);
			pResItem->wcX = MacValToWinVal(pDitem->wRight) - pResItem->wX;
			pResItem->wcY = MacValToWinVal(pDitem->wBottom) - pResItem->wY;

			pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(szTextBuf), strlen(szTextBuf)+1);
			pResItem->dwSize = wResItemSize;
			pResItem->dwTypeID = DLOG_TYPE;
			pResItem->dwItemID = wCount++;
			pResItem->dwCodePage = CODEPAGE;
			dwSize -= wResItemSize;

			pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
		}

		
		TRACE("\t\t\tDITL: #%d Type: %d (%d)\tLen: %d\tStr: %s\n", wCount-1,pDitem->bType, ((pDitem->bType | 128) - 128), pDitem->bSizeOfDataType, szTextBuf);

		dwImageSize -= sizeof(MACDIT)+bDataLen;
		pDitem = (PMACDIT)((BYTE*)pDitem+sizeof(MACDIT)+bDataLen);
		pData = (BYTE*)pDitem+sizeof(MACDIT);
	}

	return dwResItemsSize;
}


//=============================================================================
//=============================================================================
//
// Updating functions
//
//=============================================================================
//=============================================================================

//=============================================================================
//	UpdateMENU
//
//=============================================================================
UINT UpdateMENU( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    PMACMENU pMenu = (PMACMENU)((BYTE*)lpOldImage+wLen);
    BYTE* pMenuText = (BYTE*)pMenu+sizeof(MACMENU)+pMenu->bSizeOfTitle;
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // check if is the apple menu
    if(pMenu->bSizeOfTitle==1 && *((BYTE*)&pMenu->bSizeOfTitle+1)==appleMark)
    {
        // write the MENU image
        if(!MemCopy( lpNewImage, pMenu, sizeof(MACMENU)+pMenu->bSizeOfTitle, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(MACMENU)+pMenu->bSizeOfTitle;
            lpNewImage = (BYTE*)lpNewImage + sizeof(MACMENU)+pMenu->bSizeOfTitle;
        }
        lNewSize += sizeof(MACMENU)+pMenu->bSizeOfTitle;
    }
    else {

        // update caption size
        wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));
        pMenu->bSizeOfTitle = LOBYTE(wLen);

        // write the MENU image
        if(!MemCopy( lpNewImage, pMenu, sizeof(MACMENU), dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(MACMENU);
            lpNewImage = (BYTE*)lpNewImage + sizeof(MACMENU);
        }
        lNewSize += sizeof(MACMENU);

        // ... string ...
        if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
        lNewSize += wLen;
    }

    // and now update the menu items
    PMACMENUITEM pMenuItem = (PMACMENUITEM)(pMenuText+*pMenuText+1);
    pResItem = (LPRESITEM)((BYTE*)pResItem+pResItem->dwSize);
    while((BYTE)*pMenuText)
    {
        // update caption size
        wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));

        // check if is a separator
        if(*pMenuText==1 && *(pMenuText+1)=='-') {
            wLen = 1;
            *pResItem->lpszCaption = '-';
        }

        // check if the menu has an Hotkey
        if(pMenuItem->bKeyCodeId) {
            pMenuItem->bKeyCodeId = *(pResItem->lpszCaption+wLen-1);
            *(pResItem->lpszCaption+wLen-3)='\0';
            wLen -=3;
        }

        // ... size of the string ...
        if(!MemCopy( lpNewImage, &wLen, sizeof(BYTE), dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(BYTE);
            lpNewImage = (BYTE*)lpNewImage + sizeof(BYTE);
        }
        lNewSize += sizeof(BYTE);

        // ... string ...
        if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
        lNewSize += wLen;

        // write the MENU ITEM image
        if(!MemCopy( lpNewImage, pMenuItem, sizeof(MACMENUITEM), dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(MACMENUITEM);
            lpNewImage = (BYTE*)lpNewImage + sizeof(MACMENUITEM);
        }
        lNewSize += sizeof(MACMENUITEM);


		pMenuText = (BYTE*)pMenuText+sizeof(MACMENUITEM)+*pMenuText+1;
        pMenuItem = (PMACMENUITEM)(pMenuText+*pMenuText+1);
        pResItem = (LPRESITEM)((BYTE*)pResItem+pResItem->dwSize);
    }


    // add the null at the end of the menu
    wLen = 0;

    // ... menu termination ...
    if(!MemCopy( lpNewImage, &wLen, sizeof(BYTE), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(BYTE);
        lpNewImage = (BYTE*)lpNewImage + sizeof(BYTE);
    }
    lNewSize += sizeof(BYTE);

    *pdwNewImageSize = lNewSize;

    return 0;
}

//=============================================================================
//	UpdateSTR
//
//  Plain old Pascal string
//=============================================================================
UINT UpdateSTR( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // Update the string
    PRESITEM pItem = (PRESITEM)lpNewBuf;
    wLen = strlen(AnsiCpToMacCp(pItem->lpszCaption));
    // ... size ...
    if(!MemCopy( lpNewImage, &wLen, sizeof(BYTE), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(BYTE);
        lpNewImage = (BYTE*)lpNewImage + sizeof(BYTE);
    }
    // ... string ...
    if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pItem->lpszCaption), wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }

    lNewSize += wLen+sizeof(BYTE);

    *pdwNewImageSize = lNewSize;

    return 0;
}

//=============================================================================
//	UpdateSTRNUM
//
//  Array of pascal strings.
//=============================================================================
UINT UpdateSTRNUM( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    LONG lItemsBuf = dwNewSize;
    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;


    // save space for the number of strings
    WORD wItems = 0;
    BYTE * pNumOfItems = LPNULL;
    if(!MemCopy( lpNewImage, &wItems, sizeof(WORD), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(WORD);
        pNumOfItems = (BYTE*)lpNewImage;
        lpNewImage = (BYTE*)lpNewImage + sizeof(WORD);
    }
    lNewSize += sizeof(WORD);

    PRESITEM pItem = (PRESITEM)lpNewBuf;
    while(lItemsBuf)
    {
        wItems++;

        // Update the string
        wLen = strlen(AnsiCpToMacCp(pItem->lpszCaption));
        // ... size ...
        if(!MemCopy( lpNewImage, &wLen, sizeof(BYTE), dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(BYTE);
            lpNewImage = (BYTE*)lpNewImage + sizeof(BYTE);
        }
        // ... string ...
        if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pItem->lpszCaption), wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }

        lNewSize += wLen+sizeof(BYTE);
        lItemsBuf -= pItem->dwSize;
        pItem = (PRESITEM)((BYTE*)pItem+pItem->dwSize);

    }

    // fix up number of items
    if(pNumOfItems)
        memcpy(pNumOfItems, WordToMacWord(wItems), sizeof(WORD));

    *pdwNewImageSize = lNewSize;

    return 0;
}

UINT UpdateWDLG( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
	DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    DWORD dwItemsSize = dwNewSize;
    char * pFileName = (char*)lpOldImage;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

	// Update the DLOG first....
    PMACWDLG pWdlg = (PMACWDLG)((BYTE*)lpOldImage+wLen);
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // Update coordinates
    memcpy(pWdlg->wY,WinValToMacVal(pResItem->wY), sizeof(WORD));
    memcpy(pWdlg->wX,WinValToMacVal(pResItem->wX), sizeof(WORD));
    memcpy(pWdlg->wcY,WinValToMacVal(pResItem->wcY), sizeof(WORD));
    memcpy(pWdlg->wcX,WinValToMacVal(pResItem->wcX), sizeof(WORD));

    // write the DLOG image
    if(!MemCopy( lpNewImage, pWdlg, sizeof(MACWDLG), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(MACWDLG);
        lpNewImage = (BYTE*)lpNewImage + sizeof(MACWDLG);
    }
    lNewSize += sizeof(MACWDLG);

    WORD * pWStr = (WORD*)((BYTE*)pWdlg+sizeof(MACWDLG));
    wLen = 0;
    // ...copy the menu name
    if(*pWStr!=0xffff) {
        wLen = 1;
        WORD * pWOld = pWStr;
        while(*(pWStr++))
            wLen++;

        wLen = wLen*sizeof(WORD);

        if(wLen>=dwNewImageSize)
        {
            memcpy(lpNewImage, pWOld, wLen);
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
    } else {
        wLen = sizeof(WORD)*2;
        if(wLen>=dwNewImageSize)
        {
            memcpy(lpNewImage, pWStr, wLen);
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
            pWStr+=wLen;
        }
    }

    // ...copy the class name
    if(*pWStr!=0xffff) {
        wLen = 1;
        WORD * pWOld = pWStr;
        while(*(pWStr++))
            wLen++;

        wLen = wLen*sizeof(WORD);

        if(wLen>=dwNewImageSize)
        {
            memcpy(lpNewImage, pWOld, wLen);
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
    } else {
        wLen = sizeof(WORD)*2;
        if(wLen>=dwNewImageSize)
        {
            memcpy(lpNewImage, pWStr, wLen);
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
            pWStr+=wLen;
        }
    }

    // convert the string back to "Mac WCHAR".
    wLen = PutMacWString(&szWTextBuf[0], (char*)AnsiCpToMacCp(pResItem->lpszCaption), MAX_STR);

    // ... string ...
    if(!MemCopy( lpNewImage, &szWTextBuf[0], wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // ... skip the caption from the old image ...
    wLen = GetMacWString( &pWStr, &szTextBuf[0], MAX_STR );

    // ... copy the fonts info
    if(MacLongToLong(pWdlg->dwStyle) & DS_SETFONT) {
        wLen = sizeof(WORD);
        if(!MemCopy( lpNewImage, pWStr, wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
        lNewSize += wLen;

        pWStr = pWStr+1;

		GetMacWString( &pWStr, &szTextBuf[0], MAX_STR );
        wLen = PutMacWString(&szWTextBuf[0],  &szTextBuf[0], MAX_STR);

        // ... string ...
        if(!MemCopy( lpNewImage, &szWTextBuf[0], wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
        lNewSize += wLen;
	}
	
	// check the alignment
	pWStr=(WORD*)((BYTE*)pWStr+Pad4((BYTE)((DWORD_PTR)pWStr-(DWORD_PTR)pWdlg)));

    *pdwNewImageSize = lNewSize;



	return 0;
}


//=============================================================================
//	UpdateDLOG
//
//  We will have to update the DITL as well as the DLOG
//  The Mac Dialog have an ID of a DITL for each dialog. In the DITL there
//  are the info on the Items in the dialog. The DLOG hold only the size of
//  the frame and the title of the dialog
//
//=============================================================================
UINT UpdateDLOG( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    DWORD dwItemsSize = dwNewSize;
    char * pFileName = (char*)lpOldImage;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // Update the DLOG first....
    PMACDLOG pDlog = (PMACDLOG)((BYTE*)lpOldImage+wLen);
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // Update coordinates
    memcpy(pDlog->wTop,WinValToMacVal(pResItem->wY), sizeof(WORD));
    memcpy(pDlog->wLeft,WinValToMacVal(pResItem->wX), sizeof(WORD));
    memcpy(pDlog->wBottom,WinValToMacVal(pResItem->wY+pResItem->wcY), sizeof(WORD));
    memcpy(pDlog->wRight,WinValToMacVal(pResItem->wX+pResItem->wcX), sizeof(WORD));

    // update caption size
    wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));
    pDlog->bLenOfTitle = LOBYTE(wLen);

    // write the DLOG image
    if(!MemCopy( lpNewImage, pDlog, sizeof(MACDLOG), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(MACDLOG);
        lpNewImage = (BYTE*)lpNewImage + sizeof(MACDLOG);
    }
    lNewSize += sizeof(MACDLOG);

    // ... string ...
    if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    *pdwNewImageSize = lNewSize;

    // and now update the DITL
    dwItemsSize -= pResItem->dwSize;
    pResItem = (LPRESITEM)((BYTE*)pResItem+pResItem->dwSize);

    if(!InitIODLLLink())
        return ERROR_DLL_LOAD;

    // Find the DITL for this Dialog
	LPSTR pResName = (LPSTR)MacWordToWord(pDlog->wRefIdOfDITL);

    // Get the image from the iodll
    HANDLE hResFile = (*g_lpfnHandleFromName)(pFileName);
    DWORD dwImageSize = (*g_lpfnGetImage)(  hResFile, (LPSTR)DITL_TYPE, pResName, 0, NULL, 0);

    if(dwImageSize)
    {
        BYTE * pOldData = (BYTE*)malloc(dwImageSize);
		if(!pOldData)
			return 0;

        DWORD dwNewSize = dwImageSize*2;
        BYTE * pNewData = (BYTE*)malloc(dwNewSize);
		if(!pNewData)
			return 0;

		(*g_lpfnGetImage)(  hResFile, (LPSTR)DITL_TYPE, pResName, 0, pOldData, dwImageSize);

		UpdateDITL( pResItem, dwItemsSize, pOldData, dwImageSize, pNewData, &dwNewSize );

		// Update the data in the IODLL
        (*g_lpfnUpdateResImage)(hResFile, (LPSTR)DITL_TYPE, pResName, 0, -1, pNewData, dwNewSize);

        free(pOldData);
        free(pNewData);
    }

    return 0;
}

//=============================================================================
//	UpdateALRT
//
//=============================================================================
UINT UpdateALRT( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    DWORD dwItemsSize = dwNewSize;
    char * pFileName = (char*)lpOldImage;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // Update the ALRT first....
    PMACALRT pAlrt = (PMACALRT)((BYTE*)lpOldImage+wLen);
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // Update coordinates
    memcpy(pAlrt->wTop,WinValToMacVal(pResItem->wY), sizeof(WORD));
    memcpy(pAlrt->wLeft,WinValToMacVal(pResItem->wX), sizeof(WORD));
    memcpy(pAlrt->wBottom,WinValToMacVal(pResItem->wY+pResItem->wcY), sizeof(WORD));
    memcpy(pAlrt->wRight,WinValToMacVal(pResItem->wX+pResItem->wcX), sizeof(WORD));

    // write the ALRT image
    if(!MemCopy( lpNewImage, pAlrt, sizeof(MACALRT), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(MACALRT);
        lpNewImage = (BYTE*)lpNewImage + sizeof(MACALRT);
    }
    lNewSize += sizeof(MACALRT);

    *pdwNewImageSize = lNewSize;

    // and now update the DITL
    dwItemsSize -= pResItem->dwSize;
    pResItem = (LPRESITEM)((BYTE*)pResItem+pResItem->dwSize);

    if(!InitIODLLLink())
        return ERROR_DLL_LOAD;

    // Find the DITL for this Dialog
	LPSTR pResName = (LPSTR)MacWordToWord(pAlrt->wRefIdOfDITL);

    // Get the image from the iodll
    HANDLE hResFile = (*g_lpfnHandleFromName)(pFileName);
    DWORD dwImageSize = (*g_lpfnGetImage)(  hResFile, (LPSTR)DITL_TYPE, pResName, 0, NULL, 0);

    if(dwImageSize)
    {
        BYTE * pOldData = (BYTE*)malloc(dwImageSize);
		if(!pOldData)
			return 0;

        DWORD dwNewSize = dwImageSize*2;
        BYTE * pNewData = (BYTE*)malloc(dwNewSize);
		if(!pNewData)
			return 0;

		(*g_lpfnGetImage)(  hResFile, (LPSTR)DITL_TYPE, pResName, 0, pOldData, dwImageSize);

		UpdateDITL( pResItem, dwItemsSize, pOldData, dwImageSize, pNewData, &dwNewSize );

		// Update the data in the IODLL
        (*g_lpfnUpdateResImage)(hResFile, (LPSTR)DITL_TYPE, pResName, 0, -1, pNewData, dwNewSize);

        free(pOldData);
        free(pNewData);
    }

    return 0;
}

//=============================================================================
//	UpdateWIND
//
//
//=============================================================================
UINT UpdateWIND( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    DWORD dwItemsSize = dwNewSize;
    char * pFileName = (char*)lpOldImage;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    PMACWIND pWind = (PMACWIND)((BYTE*)lpOldImage+wLen);
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // Update coordinates
    memcpy(pWind->wTop,WinValToMacVal(pResItem->wY), sizeof(WORD));
    memcpy(pWind->wLeft,WinValToMacVal(pResItem->wX), sizeof(WORD));
    memcpy(pWind->wBottom,WinValToMacVal(pResItem->wY+pResItem->wcY), sizeof(WORD));
    memcpy(pWind->wRight,WinValToMacVal(pResItem->wX+pResItem->wcX), sizeof(WORD));

    // update caption size
    wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));
    pWind->bLenOfTitle = LOBYTE(wLen);

    // write the DLOG image
    if(!MemCopy( lpNewImage, pWind, sizeof(MACWIND), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(MACWIND);
        lpNewImage = (BYTE*)lpNewImage + sizeof(MACWIND);
    }
    lNewSize += sizeof(MACWIND);

    // ... string ...
    if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    *pdwNewImageSize = lNewSize;

    return 0;
}

//=============================================================================
//	UpdateDITL
//
//
//=============================================================================
UINT UpdateDITL( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    LONG lNewSize = 0;
    LONG lItemsBuf = dwNewSize;
    DWORD dwNewImageSize = *pdwNewImageSize;
    BYTE bDataLen = 0;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // save space for the number of items
    WORD wItems = 0;
    BYTE * pNumOfItems = LPNULL;
    if(!MemCopy( lpNewImage, &wItems, sizeof(WORD), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(WORD);
        pNumOfItems = (BYTE*)lpNewImage;
        lpNewImage = (BYTE*)lpNewImage + sizeof(WORD);
    }
    lNewSize += sizeof(WORD);

    PRESITEM pResItem = (PRESITEM)lpNewBuf;
    PMACDIT pDitem = (PMACDIT)((BYTE*)lpOldImage+wLen+sizeof(WORD));
    while(lItemsBuf)
    {
        wItems++;

        if((bDataLen = pDitem->bSizeOfDataType) % 2)
			bDataLen++;

        // Update coordinates
        memcpy(pDitem->wTop,WinValToMacVal(pResItem->wY), sizeof(WORD));
        memcpy(pDitem->wLeft,WinValToMacVal(pResItem->wX), sizeof(WORD));
        memcpy(pDitem->wBottom,WinValToMacVal(pResItem->wY+pResItem->wcY), sizeof(WORD));
        memcpy(pDitem->wRight,WinValToMacVal(pResItem->wX+pResItem->wcX), sizeof(WORD));

        switch((pDitem->bType | 128) - 128)
		{
			case 4:		//button
			case 5: 	//checkbox
			case 6: 	//radio button
			case 8: 	//static text
			case 16: 	//edit text
				// update caption size
                wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));
                pDitem->bSizeOfDataType = LOBYTE(wLen);

                // write the DIT image
                if(!MemCopy( lpNewImage, pDitem, sizeof(MACDIT), dwNewImageSize)) {
                    dwNewImageSize = 0;
                } else {
                    dwNewImageSize -= sizeof(MACDIT);
                    lpNewImage = (BYTE*)lpNewImage + sizeof(MACDIT);
                }
                lNewSize += sizeof(MACDIT);

                // ... string ...
                if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
                    dwNewImageSize = 0;
                } else {
                    dwNewImageSize -= wLen;
                    lpNewImage = (BYTE*)lpNewImage + wLen;
                }
                lNewSize += wLen;

                if(pDitem->bSizeOfDataType % 2) {
                    BYTE b = 0;
			        if(!MemCopy( lpNewImage, &b, 1, dwNewImageSize)) {
                        dwNewImageSize = 0;
                    } else {
                        dwNewImageSize -= wLen;
                        lpNewImage = (BYTE*)lpNewImage + 1;
                    }
                    lNewSize += 1;
                }
			break;
			case 32: 	//icon
			case 64: 	//quick draw
			default:
                wLen = sizeof(MACDIT)+pDitem->bSizeOfDataType;
                if(!MemCopy( lpNewImage, pDitem, wLen, dwNewImageSize)) {
                    dwNewImageSize = 0;
                } else {
                    dwNewImageSize -= wLen;
                    lpNewImage = (BYTE*)lpNewImage + wLen ;
                }
                lNewSize += wLen;

                if(pDitem->bSizeOfDataType % 2) {
                    BYTE b = 0;
			        if(!MemCopy( lpNewImage, &b, 1, dwNewImageSize)) {
                        dwNewImageSize = 0;
                    } else {
                        dwNewImageSize -= wLen;
                        lpNewImage = (BYTE*)lpNewImage + 1;
                    }
                    lNewSize += 1;
                }
			break;
		}

        lItemsBuf -= pResItem->dwSize;
        pResItem = (PRESITEM)((BYTE*)pResItem+pResItem->dwSize);
        pDitem = (PMACDIT)((BYTE*)pDitem+sizeof(MACDIT)+bDataLen);

    }

    // fix up number of items
    if(pNumOfItems)
        memcpy(pNumOfItems, WordToMacWord(wItems-1), sizeof(WORD));

    *pdwNewImageSize = lNewSize;
    return 0;
}

//=============================================================================
//=============================================================================
//
// General helper functions
//
//=============================================================================
//=============================================================================

WORD GetMacWString( WORD ** pWStr, char * pStr, int iMaxLen)
{
	WORD wLen = 0;
	while(**pWStr && wLen<iMaxLen)
	{
		if(LOBYTE(**pWStr)) {
			// This is a DBCS String
			TRACE("WARNING ******** WARNING ******** WARNING ******** WARNING ********\n");
			TRACE("DBCS string in the MAC file not supported yet\n");
			TRACE("WARNING ******** WARNING ******** WARNING ******** WARNING ********\n");
			return 0;	// This is a DBCS String
		}

		*pStr++ = HIBYTE(*(*pWStr)++);
		wLen ++;
	}
	*pStr = HIBYTE(*(*pWStr)++);
	return wLen;
}

WORD PutMacWString( WORD * pWStr, char * pStr, int iMaxLen)
{
	WORD wLen = 0;
	while(*pStr && wLen<iMaxLen)
	{
		*(pWStr++) = *(pStr++);
		wLen ++;
	}
	*(pWStr++) = *(pStr++);
	return wLen;
}

static BYTE b[4];       // used as a buffer for the conversion utils

BYTE * WordToMacWord(WORD w)
{
    BYTE *pw = (BYTE *) &w;		
    BYTE *p = (BYTE *) &b[0];
								
    pw += 1;						
    *p++ = *pw--;				
    *p = *pw;					
								
    return &b[0];
}								

BYTE * LongToMacLong(LONG l)
{
    BYTE *pl = (BYTE *) &l;		
    BYTE *p = (BYTE *) &b[0];
								
    pl += 3;						
    *p++ = *pl--;				
    *p++ = *pl--;				
    *p++ = *pl--;				
    *p = *pl;					
								
    return &b[0];
}								

BYTE * LongToMacOffset(LONG l)
{
    BYTE *pl = (BYTE *) &l;		
    BYTE *p = (BYTE *) &b[0];
								
    pl += 2;						
    *p++ = *pl--;				
    *p++ = *pl--;				
    *p = *pl;					
								
    return &b[0];
}								

BYTE * WinValToMacVal(WORD w)
{
	return WordToMacWord((WORD)(w / COORDINATE_FACTOR));
}

//=============================================================================
// Created a list of updated resource. This list will be used in the
// IsResUpdated funtion to detect if the resource has been updated.

PUPDATEDRESLIST UpdatedResList( LPVOID lpBuf, UINT uiSize )
{
    if(!uiSize)
        return LPNULL;

    BYTE * pUpd = (BYTE*)lpBuf;
    PUPDATEDRESLIST pListHead = (PUPDATEDRESLIST)malloc(uiSize*3);   // this should be enough in all cases
    if(!pListHead)
        return LPNULL;
    memset(pListHead, 0, uiSize*3);

    PUPDATEDRESLIST pList = pListHead;
    BYTE bPad = 0;
    WORD wSize = 0;
    while(uiSize>0) {
        pList->pTypeId = (WORD*)pUpd;
        pList->pTypeName = (BYTE*)pList->pTypeId+sizeof(WORD);
        // check the allignement
        bPad = strlen((LPSTR)pList->pTypeName)+1+sizeof(WORD);
        bPad += Pad4(bPad);
        wSize = bPad;
        pList->pResId = (WORD*)((BYTE*)pUpd+bPad);
        pList->pResName = (BYTE*)pList->pResId+sizeof(WORD);
        bPad = strlen((LPSTR)pList->pResName)+1+sizeof(WORD);
        bPad += Pad4(bPad);
        wSize += bPad;
        pList->pLang = (DWORD*)((BYTE*)pList->pResId+bPad);
        pList->pSize = (DWORD*)((BYTE*)pList->pLang+sizeof(DWORD));
        pList->pNext = (PUPDATEDRESLIST)pList+1;
        wSize += sizeof(DWORD)*2;
        pUpd = pUpd+wSize;
        uiSize -= wSize;
        if(!uiSize)
            pList->pNext = LPNULL;
        else
            pList++;
    }

    return pListHead;
}

PUPDATEDRESLIST IsResUpdated( BYTE* pTypeName, MACRESREFLIST reflist, PUPDATEDRESLIST pList)
{
    if(!pList)
        return LPNULL;

    PUPDATEDRESLIST pLast = pList;
    while(pList)
    {
        if(!strcmp((LPSTR)pList->pTypeName, (LPSTR)pTypeName)) {
            if(MacWordToWord(reflist.mwResID)==*pList->pResId) {
                pLast->pNext = pList->pNext;
                return pList;
            }
        }
        pLast = pList;
        pList = pList->pNext;
    }

    return LPNULL;
}

//=============================================================================
//=============================================================================
//
// Mac to ANSI and back conversion
//
//=============================================================================
//=============================================================================

#define MAXWSTR 8192
static WCHAR szwstr[MAXWSTR];
static CHAR szstr[MAXWSTR];

LPCSTR MacCpToAnsiCp(LPCSTR str)
{
    WORD wLen = strlen(str);
    LPWSTR pwstr = &szwstr[0];
    LPSTR pstr = &szstr[0];

    if(wLen==0)
    //if(1)
        return str;

    if(wLen>MAXWSTR)
    {
        TRACE("MacCpToAnsiCp. String too long. Buffer need to be increased!");
        return NULL;
    }

    // Convert the mac string in to an ANSI wchar
    if(!MultiByteToWideChar(CP_MACCP, MB_PRECOMPOSED | MB_USEGLYPHCHARS, str, wLen, pwstr, MAXWSTR))
    {
        TRACE("MacCpToAnsiCp. MultiByteToWideChar(...) failed.");
        return NULL;
    }
    *(pwstr+wLen) = 0x0000;

    // Convert the WideChar string in to an ANSI CP
    if(!WideCharToMultiByte(CP_ACP, 0, pwstr, MAXWSTR, pstr, MAXWSTR, NULL, NULL))
    {
        TRACE("MacCpToAnsiCp. WideCharToMultiByte(...) failed.");
        return NULL;
    }

    return pstr;
}

LPCSTR AnsiCpToMacCp(LPCSTR str)
{
    WORD wLen = strlen(str);
    LPWSTR pwstr = &szwstr[0];
    LPSTR pstr = &szstr[0];

    if(wLen==0)
        return str;

    if(wLen>MAXWSTR)
    {
        TRACE("AnsiCpToMacCp. String too long. Buffer need to be increased!");
        return NULL;
    }

    // Convert the ANSI string in to a Mac wchar
    if(!MultiByteToWideChar(CP_ACP, 0, str, wLen, pwstr, MAXWSTR))
    {
        TRACE("AnsiCpToMacCp. MultiByteToWideChar(...) failed.");
        return NULL;
    }

    *(pwstr+wLen) = 0x0000;

    // Convert the WideChar string in to an ANSI CP
    if(!WideCharToMultiByte(CP_MACCP, 0, pwstr, MAXWSTR, pstr, MAXWSTR, NULL, NULL))
    {
        TRACE("AnsiCpToMacCp. WideCharToMultiByte(...) failed.");
        return NULL;
    }

    return pstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\common\rw32hlpr.h ===
/////////////////////////////////////////////////////////////////////////////
// Helper Function Declarations for res32/win32 r/w
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define Pad4(x) ((((x+3)>>2)<<2)-x)
#define PadPtr(x) ((((x+(sizeof(PVOID)-1))/sizeof(PVOID))*sizeof(PVOID))-x)
#define Pad16(x) ((((x+15)>>4)<<4)-x)

#define MAXSTR 8192
#define LPNULL 0L
#define MAXLEVELS 3
#define MFR_POPUP (MF_POPUP > 1)    // Chicago file specific 
/////////////////////////////////////////////////////////////////////////////
// General type Declarations
typedef unsigned char UCHAR;

typedef UCHAR * PUCHAR;

typedef BYTE far * far * LPLPBYTE;

typedef struct tagResSectData
{
    ULONG ulOffsetToResources;      //        File offset to the .rsrc
    ULONG ulVirtualAddress;         //... Virtual address of section .rsrc
    ULONG ulSizeOfResources;        //... Size of resources in section .rsrc
    ULONG ulOffsetToResources1;     //        File offset to the .rsrc1
    ULONG ulVirtualAddress1;        //... Virtual address of section .rsrc1
    ULONG ulSizeOfResources1;       //... Size of resources in section .rsrc1
} RESSECTDATA, *PRESSECTDATA;

typedef struct ver_block {
    WORD wBlockLen;
    WORD wValueLen;
    WORD wType;
    WORD wHead;
    BYTE far * pValue;
    char szKey[100];
    char szValue[256];
} VER_BLOCK;

VOID InitGlobals();

UINT GetNameOrOrdU( PUCHAR pRes,
            ULONG ulId,
            LPWSTR lpwszStrId,
            DWORD* pdwId );

 UINT GetStringW( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize, WORD cLen );
 UINT GetStringA( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
 UINT GetPascalString( BYTE far * far* lplpBuf,
                             LPSTR lpszText,
                             WORD wMaxLen,
                             LONG* pdwSize );
 UINT GetMsgStr( BYTE far * far* lplpBuf,
                       LPSTR lpszText,
                       WORD wMaxLen,
                       WORD* pwLen,
                       WORD* pwFlags,
                       LONG* pdwSize );
 UINT PutMsgStr( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wFlags, LONG* pdwSize );

 // Simulate the  WideChar to multibyte
 extern  UINT g_cp/* = CP_ACP*/; // Default to CP_ACP
 extern  BOOL g_bAppend/* = FALSE*/; //Default to FALSE
 extern  BOOL g_bUpdOtherResLang; /* = FALSE*/; //Default to FALSE
 extern  char g_char[2]/* = FALSE*/; //Default to FALSE
 UINT _MBSTOWCS( WCHAR * pwszOut, CHAR * pszIn, UINT nLength);
 UINT _WCSTOMBS( CHAR * pszOut, WCHAR * wszIn, UINT nLength);
 UINT _WCSLEN( WCHAR * pwszIn );

 BYTE PutDWord( BYTE far * far* lplpBuf, DWORD dwValue, LONG* pdwSize );
 BYTE PutDWordPrt( BYTE far * far* lplpBuf, DWORD_PTR dwValue, LONG* pdwSize );
 BYTE PutWord( BYTE far * far* lplpBuf, WORD wValue, LONG* pdwSize );
 BYTE PutByte( BYTE far * far* lplpBuf, BYTE bValue, LONG* pdwSize );
 UINT PutStringA( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
 UINT PutStringW( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
 UINT PutNameOrOrd( BYTE far * far* lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize );
 UINT PutCaptionOrOrd( BYTE far * far* lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize,
							 WORD wClass, DWORD dwStyle );
 UINT PutClassName( BYTE far * far* lplpBuf, WORD bClass, LPSTR lpszText, LONG* pdwSize );
 UINT PutPascalStringW( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wLen, LONG* pdwSize );
 UINT SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwRead );
 BYTE GetDWord( BYTE far * far* lplpBuf, DWORD* dwValue, LONG* pdwSize );
 BYTE GetWord( BYTE far * far* lplpBuf, WORD* wValue, LONG* pdwSize );
 BYTE GetByte( BYTE far * far* lplpBuf, BYTE* bValue, LONG* pdwSize );
 UINT GetNameOrOrd( BYTE far * far* lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize );
 UINT GetCaptionOrOrd( BYTE far * far* lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize,
							 WORD wClass, DWORD dwStyle );
 UINT GetClassName( BYTE far * far* lplpBuf, WORD* bClass, LPSTR lpszText, LONG* pdwSize );
 UINT GetVSBlock( BYTE far * far* lplpBuf, LONG* pdwSize, VER_BLOCK* pBlock );
 UINT PutVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK verBlock,
                        LPSTR lpStr, BYTE far * far * lplpBlockSize, WORD wPad);
 UINT ParseMenu( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseString( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseDialog( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseMsgTbl( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseAccel( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseVerst( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

// These functions will take the image as is and will return just one item
// In this way the IODLL will assume there are items in the immage and will
// procede with the normal function.

 UINT ParseEmbeddedFile( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

 UINT UpdateMenu( LPVOID lpNewBuf, LONG dwNewSize,
                        LPVOID lpOldImage, LONG dwOldImageSize,
                        LPVOID lpNewImage, DWORD* pdwNewImageSize );

 UINT UpdateMsgTbl( LPVOID lpNewBuf, LONG dwNewSize,
                        LPVOID lpOldImage, LONG dwOldImageSize,
                        LPVOID lpNewImage, DWORD* pdwNewImageSize );

 UINT UpdateAccel( LPVOID lpNewBuf, LONG dwNewSize,
                         LPVOID lpOldImage, LONG dwOldImageSize,
                         LPVOID lpNewImage, DWORD* pdwNewImageSize );

 UINT UpdateDialog( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );

 UINT UpdateString( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );

 UINT UpdateVerst( LPVOID lpNewBuf, LONG dwNewSize,
                         LPVOID lpOldI, LONG dwOldImageSize,
                         LPVOID lpNewI, DWORD* pdwNewImageSize );

 UINT GenerateMenu( LPVOID lpNewBuf, LONG dwNewSize,  
						  LPVOID lpNewI, DWORD* pdwNewImageSize );
 UINT GenerateDialog( LPVOID lpNewBuf, LONG dwNewSize,  
						  LPVOID lpNewI, DWORD* pdwNewImageSize );
 UINT GenerateString( LPVOID lpNewBuf, LONG dwNewSize,  
						  LPVOID lpNewI, DWORD* pdwNewImageSize );
 UINT GenerateAccel( LPVOID lpNewBuf, LONG dwNewSize,  
						  LPVOID lpNewI, DWORD* pdwNewImageSize );


 UINT CopyFile( CFile* filein, CFile* fileout );
 DWORD FixCheckSum( LPCSTR ImageName);

 DWORD GenerateTransField( WORD wLang, BOOL bMode );
 void GenerateTransField( WORD wLang, VER_BLOCK * pVer );

 LONG Allign( LPLPBYTE lplpBuf, LONG* plBufSize, LONG lSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\common\rwdll.h ===
//+---------------------------------------------------------------------------
//
//  File:               rwdll.h
//
//  Contents:   Declarations for the reader/writer DLL
//
//  Classes:    none
//
//  History:    31-May-93   alessanm    created
//
//----------------------------------------------------------------------------
#ifndef _RWDLL_H_
#define _RWDLL_H_

//////////////////////////////////////////////////////////////////////////////
// Type declaration, common to all the module in the Reader/Writer
//////////////////////////////////////////////////////////////////////////////
#include <iodll.h>

#define DllExport

//[registration]                                    
extern "C"
DllExport
BOOL
APIENTRY
RWGetTypeString(
	LPSTR lpszTypeName);

extern "C"
DllExport
BOOL
APIENTRY 
RWValidateFileType(
	LPCSTR pszFileName);
	
extern "C"
DllExport
UINT
APIENTRY 
RWReadTypeInfo(
	LPCSTR  lpszFilename,
	LPVOID  lpBuffer,
	UINT*   puiSize
	);      

//[Reading / writing file]
extern "C"
DllExport
DWORD
APIENTRY 
RWGetImage(
	LPCSTR  lpszFilename,
	DWORD   dwImageOffset,
	LPVOID  lpBuffer,
	DWORD   dwSize
	);

extern"C"
DllExport
UINT  
APIENTRY 
RWWriteFile(
	LPCSTR  lpszSrcFilename,
	LPCSTR  lpszTgtFilename,
	HANDLE  hResFileModule,
	LPVOID  lpBuffer,
	UINT    uiSize,
	HINSTANCE   hDllInst,
    LPCSTR  lpszSymbolPath
	);
	
// [Parsing]
extern "C"
DllExport
UINT
APIENTRY 
RWParseImage(
	LPCSTR  lpszType,
	LPVOID  lpImageBuf,
	DWORD   dwImageSize,
	LPVOID  lpBuffer,
	DWORD   dwSize
	);

extern "C"
DllExport
UINT
APIENTRY 
RWParseImageEx(
	LPCSTR  lpszType,
    LPCSTR  lpszResId,
	LPVOID  lpImageBuf,
	DWORD   dwImageSize,
	LPVOID  lpBuffer,
	DWORD   dwSize,
    LPCSTR  lpRCFilename
	);


extern "C"
DllExport
UINT
APIENTRY 
RWUpdateImage(
	LPCSTR  lpszType,
	LPVOID  lpNewBuf,
	DWORD   dwNewSize,
	LPVOID  lpOldImage,
	DWORD   dwOldImageSize,
	LPVOID  lpNewImage,
	DWORD*  pdwNewImageSize
	);

extern "C"
DllExport
UINT
APIENTRY 
RWUpdateImageEx(
	LPCSTR  lpszType,
	LPVOID  lpNewBuf,
	DWORD   dwNewSize,
	LPVOID  lpOldImage,
	DWORD   dwOldImageSize,
	LPVOID  lpNewImage,
	DWORD*  pdwNewImageSize,
    LPCSTR  lpRCFilename
	);

#endif   // _RWDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\mac\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\inf\inf.cpp ===
/******************************************************\
 This file implement the class that will parse an inf
 file.
\******************************************************/
#include "inf.h"

#define MAX_INF_STR 8192*2
#define LanguageSection "[LanguagesSupported]"
#define LanguageSection1 "[LanguageID]"

// Constructors and Destructors
CInfFile::CInfFile()
{
    m_lBufSize = -1;
    m_pfileStart = NULL;
    m_pfilePos = NULL;
    m_pfileLastPos = NULL;
    m_pfileLocalize = NULL;
    m_strLang = "0000000000";
}

CInfFile::CInfFile(LPCTSTR strFileName )
{
    CFileException fe;
    Open(strFileName, CFile::modeRead | CFile::shareDenyWrite, &fe);
}

CInfFile::~CInfFile()
{
    if(m_pfileStart)
    {
        m_file.Close();
        delete m_pfileStart;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
// String functions

BOOL CInfFile::ReadString(CString & str, BOOL bLastFilePos)
{
    if(m_pfilePos==NULL)
        return FALSE;

    // search for the next /n in the file
    BYTE * pEnd = (BYTE*)memchr(m_pfilePos, '\n', (size_t)(m_lBufSize-(m_pfilePos-m_pfileStart)));

    if(!pEnd)
        return FALSE;

    if(bLastFilePos)
        m_pfileLastPos = m_pfilePos;

    int istrSize = (int)((pEnd-m_pfilePos) > MAX_INF_STR ? MAX_INF_STR : (pEnd-m_pfilePos));

    LPSTR pStr = (LPSTR)str.GetBuffer(istrSize);

    memcpy(pStr, m_pfilePos, istrSize-1);

    if(*(pEnd-1)=='\r')
        *(pStr+istrSize-1) = '\0';
    else
        *(pStr+istrSize) = '\0';

    m_pfilePos = pEnd+1;
    str.ReleaseBuffer();
    return TRUE;
}

BOOL CInfFile::ReadSectionString(CString & str, BOOL bRecursive)
{
    CString strNext;
    BYTE * pPos = m_pfilePos;

    while(ReadString(strNext, !bRecursive))
    {
        if(!strNext.IsEmpty())
        {
            if(!bRecursive)
                str = "";

            // Check for a section
            if(strNext.Find('[')!=-1 && strNext.Find(']')!=-1)
                break;

            // remove spaces at the end of the string...
            strNext.TrimRight();

            //
            // Check for multiple line. Assume only last char can be a +
            //
            if(strNext.GetAt(strNext.GetLength()-1)=='+')
            {
                //
                // Remove the +
                //
                if(!str.IsEmpty())
                {
                    strNext.TrimLeft();
                    //strNext = strNext.Mid(1);
                }

                str += strNext.Left(strNext.GetLength()-1);

                ReadSectionString(str, TRUE);
            }
            else
            {
                if(!str.IsEmpty())
                {
                    strNext.TrimLeft();
                }
                str += strNext;
            }

            //
            // Make sure the " are balanced with
            //
            int iPos;
            while((iPos = str.Find("\"\""))!=-1)
            {
                str = str.Left(iPos) + str.Mid(iPos+2);
            }

            return TRUE;
        }
    }

    m_pfilePos = pPos;
    return FALSE;
}

BOOL CInfFile::ReadSectionString(CInfLine & str)
{
    CString strLine;
    if( !ReadSectionString(strLine) )
        return FALSE;

    str = strLine;

    return TRUE;
}

BOOL CInfFile::ReadTextSection(CString & str)
{
    CString strSection;
    while(ReadSection(strSection))
    {
        if(strSection.Find(m_strLang)!=-1)
        {
            str = strSection;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CInfFile::ReadSection(CString & str)
{
    if(m_pfilePos==NULL)
        return 0;

    BYTE * pOpen;
    BYTE * pClose;
    BYTE * pEnd;
    BOOL bFound = FALSE;
    while(!bFound)
    {
        // search for the next [ in the file
        if((pOpen = (BYTE*)memchr(m_pfilePos, '[', (size_t)(m_lBufSize-(m_pfilePos-m_pfileStart))))==NULL)
            return 0;

        if((pClose = (BYTE*)memchr(pOpen, ']', (size_t)(m_lBufSize-(pOpen-m_pfileStart))))==NULL)
            return 0;

        if((pEnd = (BYTE*)memchr(pOpen, '\n', (size_t)(m_lBufSize-(pOpen-m_pfileStart))))==NULL)
            return 0;

        // pClose must be before pEnd
        if((pClose>pEnd) || (*(pOpen-1)!='\n') || (*(pClose+1)!='\r'))
            m_pfilePos = pEnd+1;
        else bFound = TRUE;
    }

    int istrSize = (int)((pEnd-pOpen) > MAX_INF_STR ? MAX_INF_STR : (pEnd-pOpen));

    LPSTR pStr = (LPSTR)str.GetBuffer(istrSize);

    memcpy(pStr, pOpen, istrSize-1);

    if(*(pEnd-1)=='\r')
        *(pStr+istrSize-1) = '\0';
    else
        *(pStr+istrSize) = '\0';

    m_pfilePos = pEnd+1;
    str.ReleaseBuffer();

    return 1;
}

//////////////////////////////////////////////////////////////////////////////////////////
// File functions

LONG CInfFile::Seek( LONG lOff, UINT nFrom )
{
    switch(nFrom)
    {
        case SEEK_SET:
            if(lOff<=m_lBufSize)
                m_pfilePos = m_pfileStart+lOff;
            else return -1;
        break;
        case SEEK_CUR:
            if(lOff<=m_lBufSize-(m_pfilePos-m_pfileStart))
                m_pfilePos = m_pfilePos+lOff;
            else return -1;
        break;
        case SEEK_END:
            if(lOff<=m_lBufSize)
                m_pfilePos = m_pfileStart+(m_lBufSize-lOff);
            else return -1;
        break;
        case SEEK_LOC:
            if(m_pfileLocalize)
                m_pfilePos = m_pfileLocalize;
            else return -1;
        break;
        default:
        break;
    }

    return ((LONG)(m_pfilePos-m_pfileStart));
}

BOOL CInfFile::Open( LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError )
{
    CFileException fe;
    if(!pError)
        pError = &fe;
    if(!m_file.Open(lpszFileName, nOpenFlags, pError))
    {
        AfxThrowFileException(pError->m_cause, pError->m_lOsError);
        return FALSE;
    }

    m_lBufSize = m_file.GetLength()+1;
    m_pfileStart = new BYTE[m_lBufSize];

    if(m_pfileStart==NULL)
    {
        AfxThrowMemoryException();
        return FALSE;
    }

    m_pfileLastPos = m_pfilePos = m_pfileStart;

    m_file.Read(m_pfileStart, m_lBufSize );
    *(m_pfilePos+m_lBufSize) = '\0';

    // find the localization section
    /*************************************************************************************\
     I'm assuming there are no other \0 in the buffer other than the one I've just placed.
     This is a fair assumption since this is a text file and not a binary file.
     I can then use strstr to get to the first occurrence, if any of the localization
     string section and place my current position buffer there.
    \*************************************************************************************/
    m_pfileLocalize = m_pfilePos = (BYTE*)strstr((LPSTR)m_pfileStart, LanguageSection);

    //
    // Check if we have the other language ID tag
    //
    if(!m_pfileLocalize)
        m_pfileLocalize = m_pfilePos = (BYTE*)strstr((LPSTR)m_pfileStart, LanguageSection1);


    // Get the language
    if(m_pfileLocalize)
    {
        BYTE * pStr = ((BYTE*)memchr(m_pfileLocalize, '\n', (size_t)(m_lBufSize-(m_pfileLocalize-m_pfileStart)))+1);
        BYTE * pEnd = ((BYTE*)memchr(pStr, '\n', (size_t)(m_lBufSize-(pStr-m_pfileStart)))-1);

        TRACE("CInfFile::Open =====> pStr = 0X%X, pEnd = 0X%X\n", pStr, pEnd);

        m_strLang = "";

        while( pStr<pEnd )
        {
            TRACE("CInfFile::Open =====> pStr = %c, 0X%X\n", *pStr, pStr);

            if( isalpha(*pStr++) )
                m_strLang += *(pStr-1);
        }
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Buffer functions

const BYTE * CInfFile::GetBuffer(LONG lPos /* = 0 */)
{
    if(lPos>m_lBufSize || lPos<0)
        return NULL;

    return( (const BYTE *)(m_pfileStart+lPos) );
}

/******************************************************************************************\
 CInfLine
 This class will parse the line and separate tag and text
\******************************************************************************************/

CInfLine::CInfLine()
{
    m_strData = "";
    m_strTag  = "";
    m_strText = "";
    m_bMultipleLine = FALSE;
}

CInfLine::CInfLine( LPCSTR lpStr )
{
    m_bMultipleLine = FALSE;
    m_strData = lpStr;
    SetTag();
    SetText();
}

void CInfLine::SetTag()
{
    m_strTag = "";
    // find the = in m_strData
    int iPos = m_strData.Find('=');
    if(iPos==-1)
        return;

    m_strTag = Clean(m_strData.Left( iPos ));
    m_strTag.TrimRight();
    m_strTag.TrimLeft();

}

void CInfLine::SetText()
{
    m_strText = "";
    // find the = in m_strData
    int iPos = m_strData.Find('=');
    if(iPos==-1)
        return;

    m_strText = Clean(m_strData.Right( m_strData.GetLength()-iPos-1 ));
	m_strText = m_strData.Right( m_strData.GetLength()-iPos-1 );
}

void CInfLine::ChangeText(LPCSTR str)
{
    m_strText = str;

    // find the = in m_strData
    int iPos = m_strData.Find('=');
    if(iPos==-1)
        return;

    m_strData = m_strData.Left( iPos+1 );
    m_strData += m_strText;
}

//////////////////////////////////////////////////////////////////////////////////////////
// copy operators

CInfLine& CInfLine::operator=(const CInfLine& infstringSrc)
{
	m_strData = infstringSrc.m_strData;
    m_strTag  = infstringSrc.m_strTag;
    m_strText = infstringSrc.m_strText;
    m_bMultipleLine = infstringSrc.m_bMultipleLine;
	return *this;
}

CInfLine& CInfLine::operator=(LPCTSTR lpsz)
{
    m_bMultipleLine = FALSE;
    m_strData = lpsz;
    SetTag();
    SetText();
    return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// support functions

CString CInfLine::Clean(LPCSTR lpstr)
{
    CString str = lpstr;

    int iPos = str.Find('"');
    if(iPos!=-1)
    {
        str = str.Right( str.GetLength()-iPos-1 );
        iPos = str.ReverseFind('"');
        if(iPos!=-1)
        {
            str = str.Left( iPos );
        }
    }

    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\inf\inf.h ===
/******************************************************\
 This file implement the class that will parse an inf
 file.
\******************************************************/
#ifndef _INF_H_
#define _INF_H_

#include <stdafx.h>

#define SEEK_LOC    4

class CInfLine;

class CInfFile
{
public:
    // Constructors and Destructors
    CInfFile();
    CInfFile( LPCTSTR strFileName );
    ~CInfFile();

    // Strings Functions
    BOOL ReadString(CString & str, BOOL bLastFilePos = TRUE);
    BOOL ReadSectionString(CString & str, BOOL bRecursive = FALSE);
    BOOL ReadSectionString(CInfLine & str);

    BOOL ReadSection(CString & str);        // Generic Section
    BOOL ReadTextSection(CString & str);    // Localizable Section

    CString GetLanguage()
        { return m_strLang; }

    // File Functions
    LONG Seek( LONG lOff, UINT nFrom );
    LONG SeekToBegin()
        { return Seek(0, SEEK_SET);  }
    LONG SeekToEnd()
        { return Seek(0, SEEK_END);  }
    LONG SeekToLocalize()
        { return Seek(0, SEEK_LOC);  }

    LONG GetLastFilePos()
        { return (LONG)(m_pfileLastPos-m_pfileStart); }

    BOOL Open( LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError = NULL );

    // Buffer access
    const BYTE * GetBuffer(LONG lPos = 0);


private:
    BYTE *  m_pfileStart;
    BYTE *  m_pfilePos;
    BYTE *  m_pfileLocalize;
    BYTE *  m_pfileLastPos;
    LONG    m_lBufSize;
    CFile   m_file;

    CString m_strLang;
};

class CInfLine
{
friend class CInfFile;
public:
    CInfLine();
    CInfLine( LPCSTR lpstr );

    // String functions
    LPCSTR GetText()
        { return m_strText; }
    LPCSTR GetTag()
        { return m_strTag; }
    LPCSTR GetData()
        { return m_strData; }

    void ChangeText(LPCSTR str);

    BOOL IsMultiLine()
        { return m_bMultipleLine; }

    LONG GetTextLength()
        { return m_strText.GetLength(); }
    LONG GetTagLength()
        { return m_strTag.GetLength(); }
    LONG GetDataLength()
        { return m_strData.GetLength(); }


    // copy operator
    CInfLine& operator=(const CInfLine& infstringSrc);
    CInfLine& operator=(LPCTSTR lpsz);

private:
    CString m_strData;
    CString m_strTag;
    CString m_strText;
    BOOL    m_bMultipleLine;

    void SetTag();
    void SetText();
    CString Clean(LPCSTR lpstr);
};

#endif //_INF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\inf\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include "..\common\rwdll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\inf\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	rwinf.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\inf\rwinf.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       rwinf.cpp
//
//  Contents:   Implementation for the Windows NT 3.51 inf Read/Write module
//
//  Classes:
//
//  History:    13-Mar-95   alessanm    created
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <afxdllx.h>
#include "inf.h"
#include "..\common\helper.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define RWTAG "INF"

#define INF_TYPE        11
#define MAX_INF_TEXT_LINE    55
#define Pad4(x) ((((x+3)>>2)<<2)-x)

typedef struct tagUpdResList
{
    WORD *  pTypeId;
    BYTE *  pTypeName;
    WORD *  pResId;
    BYTE *  pResName;
    DWORD * pLang;
    DWORD * pSize;
    struct tagUpdResList* pNext;
} UPDATEDRESLIST, *PUPDATEDRESLIST;

class CLoadedFile : public CObject
{
public:
    CLoadedFile(LPCSTR lpfilename);

    CInfFile m_infFile;
    CString  m_strFileName;
};

CLoadedFile::CLoadedFile(LPCSTR lpfilename)
{
    TRY
    {
        m_infFile.Open(lpfilename, CFile::modeRead | CFile::shareDenyNone);
    }
    CATCH(CFileException, pfe)
    {
        AfxThrowFileException(pfe->m_cause, pfe->m_lOsError);
    }
    END_CATCH

    m_strFileName = lpfilename;
}


/////////////////////////////////////////////////////////////////////////////
// Function Declarations

LONG
WriteResInfo(
    BYTE** lplpBuffer, LONG* plBufSize,
    WORD wTypeId, LPCSTR lpszTypeId, BYTE bMaxTypeLen,
    WORD wNameId, LPCSTR lpszNameId, BYTE bMaxNameLen,
    DWORD dwLang,
    DWORD dwSize, DWORD dwFileOffset );

CInfFile * LoadFile(LPCSTR lpfilename);

PUPDATEDRESLIST CreateUpdateResList(BYTE * lpBuffer, UINT uiBufSize);
PUPDATEDRESLIST FindId(LPCSTR pstrId, PUPDATEDRESLIST pList);

/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

CObArray g_LoadedFile;

//[registration]
extern "C"
BOOL    FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
    strcpy( lpszTypeName, RWTAG );
    return FALSE;
}

extern "C"
BOOL    FAR PASCAL RWValidateFileType(LPCSTR lpszFilename)
{
    TRACE("RWINF.DLL: RWValidateFileType()\n");

    // Check file exstension and try to open it
    if(strstr(lpszFilename, ".INF")!=NULL || strstr(lpszFilename, ".inf")!=NULL)
        return TRUE;

    return FALSE;
}

extern "C"
DllExport
UINT
APIENTRY
RWReadTypeInfo(
    LPCSTR lpszFilename,
    LPVOID lpBuffer,
    UINT* puiSize
    )
{
    TRACE("RWINF.DLL: RWReadTypeInfo()\n");
    UINT uiError = ERROR_NO_ERROR;

    if (!RWValidateFileType(lpszFilename))
        return ERROR_RW_INVALID_FILE;
    //
    // Open the file
    //
    CInfFile * pinfFile;
    TRY
    {
        pinfFile = LoadFile(lpszFilename);
    }
    CATCH(CFileException, pfe)
    {
        return pfe->m_cause + IODLL_LAST_ERROR;
    }
    END_CATCH

    //
    // Read the data and fill the iodll buffer
    //
    // Get to the beginning of the localization section
    //
    if(!pinfFile->SeekToLocalize())
        return ERROR_RW_NO_RESOURCES;

    CString strSection;
    CString strLine;
    CString strTag;
    CInfLine infLine;

    BYTE ** pBuf = (BYTE**)&lpBuffer;
    LONG lBufSize = 0;

    while(pinfFile->ReadTextSection(strSection))
    {
        while(pinfFile->ReadSectionString(infLine))
        {
            strTag = strSection + '.' + infLine.GetTag();
            lBufSize += WriteResInfo(
                 pBuf, (LONG*)puiSize,
                 INF_TYPE, "", 0,
                 0, strTag, 255,
                 0l,
                 infLine.GetTextLength()+1, pinfFile->GetLastFilePos() );
        }
    }

    *puiSize = lBufSize;

    return uiError;
}

extern "C"
DllExport
DWORD
APIENTRY
RWGetImage(
    LPCSTR  lpszFilename,
    DWORD   dwImageOffset,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    UINT uiError = ERROR_NO_ERROR;

    //
    // Open the file
    //
    CInfFile * pinfFile;
    TRY
    {
        pinfFile = LoadFile(lpszFilename);

    }
    CATCH(CFileException, pfe)
    {
        return pfe->m_cause + IODLL_LAST_ERROR;
    }
    END_CATCH

    //
    // Seek to the string to retrieve and read it
    //
    CInfLine infLine;

    pinfFile->Seek( dwImageOffset, SEEK_SET );
    pinfFile->ReadSectionString(infLine);

    //
    // Fill the buffer with the string
    //
    if(infLine.GetTextLength()+1<=(LONG)dwSize)
    {
        memcpy(lpBuffer, infLine.GetText(), infLine.GetTextLength()+1);
        uiError = infLine.GetTextLength()+1;
    }
    else
        uiError = 0;

    return (DWORD)uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWParseImage(
    LPCSTR  lpszType,
    LPVOID  lpImageBuf,
    DWORD   dwImageSize,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    UINT uiSizeOfDataStruct = strlen((LPCSTR)lpImageBuf)+sizeof(RESITEM);

    if(uiSizeOfDataStruct<=dwSize)
    {
        //
        // We have to fill the RESITEM Struct
        //
        LPRESITEM pResItem = (LPRESITEM)lpBuffer;
        memset(pResItem, '\0', uiSizeOfDataStruct);

        pResItem->dwSize = uiSizeOfDataStruct;
        pResItem->lpszCaption = (LPSTR)memcpy( ((BYTE*)pResItem)+sizeof(RESITEM), lpImageBuf, dwImageSize);        // Caption
    }

    return uiSizeOfDataStruct;
}

extern"C"
DllExport
UINT
APIENTRY
RWWriteFile(
    LPCSTR          lpszSrcFilename,
    LPCSTR          lpszTgtFilename,
    HANDLE          hResFileModule,
    LPVOID          lpBuffer,
    UINT            uiSize,
    HINSTANCE       hDllInst,
    LPCSTR          lpszSymbolPath
    )
{
    UINT uiError = ERROR_NO_ERROR;

    // Get the handle to the IODLL
    hDllInst = LoadLibrary("iodll.dll");
    if (!hDllInst)
        return ERROR_DLL_LOAD;

    DWORD (FAR PASCAL * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
    // Get the pointer to the function to extract the resources image
    lpfnGetImage = (DWORD (FAR PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
                        GetProcAddress( hDllInst, "RSGetResImage" );
    if (lpfnGetImage==NULL) {
        FreeLibrary(hDllInst);
        return ERROR_DLL_LOAD;
    }

    //
    // Get the handle to the source file
    //
    CInfFile * psrcinfFile;
    TRY
    {
        psrcinfFile = LoadFile(lpszSrcFilename);

    }
    CATCH(CFileException, pfe)
    {
        return pfe->m_cause + IODLL_LAST_ERROR;
    }
    END_CATCH

    //
    // Create the target file
    //
    CFile tgtFile;
    CFileException fe;
    if(!tgtFile.Open(lpszTgtFilename, CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone, &fe))
    {
        return fe.m_cause + IODLL_LAST_ERROR;
    }

    //
    // Copy the part of the file that is not localizable
    //
    LONG lLocalize = psrcinfFile->SeekToLocalize();
    const BYTE * pStart = psrcinfFile->GetBuffer();

    if(lLocalize==-1)
    {
        // the file has no localizable info  in it just copy it
        lLocalize = psrcinfFile->SeekToEnd();
    }

    TRY
    {
        tgtFile.Write(pStart, lLocalize);
    }
    CATCH(CFileException, pfe)
    {
        return pfe->m_cause + IODLL_LAST_ERROR;
    }
    END_CATCH

    //
    // Create the list of updated resources
    //
    PUPDATEDRESLIST pResList = CreateUpdateResList((BYTE*)lpBuffer, uiSize);

    //
    // What we have now is a part that is mized. Part of it has localizable
    // information and part has none.
    // We will read each section and decide if is a localizable section or not.
    // If it is we will update it otherwise just copy it
    //
    CString strSection, str;
    CString strLang = psrcinfFile->GetLanguage();
    LONG lEndPos, lStartPos;
    CInfLine infLine;

    while(psrcinfFile->ReadSection(strSection))
    {
        TRY
        {
            tgtFile.Write(strSection, strSection.GetLength());
            tgtFile.Write("\r\n", 2);
        }
        CATCH(CFileException, pfe)
        {
            return pfe->m_cause + IODLL_LAST_ERROR;
        }
        END_CATCH

        if(strSection.Find(strLang)==-1)
        {
            //
            // This is not a localizable section
            //
            lStartPos = psrcinfFile->Seek(0, SEEK_CUR);

            //
            // Read the next section untill we find a localizable section
            //
            while(psrcinfFile->ReadSection(strSection))
            {
                if(strSection.Find(strLang)!=-1)
                    break;
            }

            //
            // Where are we now?
            //

            lEndPos = psrcinfFile->Seek(0, SEEK_CUR) - strSection.GetLength()-2;

            //
            // Make sure we are not at the end of the file
            //
            if(lEndPos<=lStartPos)
            {
                // we have no more section so copy all is left
                lEndPos = psrcinfFile->Seek(0, SEEK_END) - 1;
            }

            //
            // copy the full block
            //

            pStart = psrcinfFile->GetBuffer(lStartPos);
            TRY
            {
                tgtFile.Write(pStart, lEndPos-lStartPos);
            }
            CATCH(CFileException, pfe)
            {
                return pfe->m_cause + IODLL_LAST_ERROR;
            }
            END_CATCH

            psrcinfFile->Seek(lEndPos, SEEK_SET);
        }
        else
        {
            //
            // This is a localizable section
            // Read all the strings and see if they have been updated
            //
            CString strId;
            PUPDATEDRESLIST pListItem;
            BYTE * pByte;

            lEndPos = psrcinfFile->Seek(0, SEEK_CUR);

            while(psrcinfFile->ReadSectionString(str))
            {
                str += "\r\n";

                infLine = str;

                //
                // Check if we need to update this string
                //
                strId = strSection + "." + infLine.GetTag();

                if(pListItem = FindId(strId, pResList))
                {
                    // allocate the buffer to hold the resource data
                    pByte = new BYTE[*pListItem->pSize];
                    if(!pByte){
                        uiError = ERROR_NEW_FAILED;
                        goto exit;
                    }

                    // get the data from the iodll
                    LPSTR	lpType = NULL;
        			LPSTR	lpRes = NULL;
        			if (*pListItem->pTypeId) {
        				lpType = (LPSTR)((WORD)*pListItem->pTypeId);
        			} else {
        				lpType = (LPSTR)pListItem->pTypeName;
        			}
        			if (*pListItem->pResId) {
        				lpRes = (LPSTR)((WORD)*pListItem->pResId);
        			} else {
        				lpRes = (LPSTR)pListItem->pResName;
        			}

        			DWORD dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
        											lpType,
        											lpRes,
        											*pListItem->pLang,
        											pByte,
        											*pListItem->pSize
        						   					);

                    if(dwImageBufSize!=*pListItem->pSize)
                    {
                        // something is wrong...
                        delete []pByte;
                    }
                    else {

                        infLine.ChangeText((LPCSTR)pByte);

                        //
                        // Now we have the updated image...
                        //

                        //
                        // Check how long is the Data and split it in to lines
                        //
                        if(infLine.GetTextLength()>MAX_INF_TEXT_LINE)
                        {
                            //
                            // First write the tag
                            //
                            str = infLine.GetData();
                            int iSpaceLen = str.Find('=')+1;
                            int iTagLen = 0;

                            TRY
                            {
                                tgtFile.Write(str, iSpaceLen);
                            }
                            CATCH(CFileException, pfe)
                            {
                                return pfe->m_cause + IODLL_LAST_ERROR;
                            }
                            END_CATCH

                            //
                            // Now write the rest
                            //
                            int iExtra, iMaxStr;
                            CString strLine;
                            CString strSpace( ' ', iSpaceLen+1 );
                            BOOL bFirstLine = TRUE;

                            strSpace += '\"';
                            str = infLine.GetText();
                            str.TrimLeft();

                            while(str.GetLength()>MAX_INF_TEXT_LINE)
                            {
                                iMaxStr = str.GetLength();

                                strLine = str.Left(MAX_INF_TEXT_LINE);

                                //
                                // Check if we are in the middle of a word
                                //
                                iExtra = 0;
                                while((iMaxStr>MAX_INF_TEXT_LINE+iExtra) && str.GetAt(MAX_INF_TEXT_LINE+iExtra)!=' ')
                                {
                                    strLine += str.GetAt(MAX_INF_TEXT_LINE+iExtra++);
                                }

                                //
                                // Make sure the spaces are the last thing
                                //
                                while((iMaxStr>MAX_INF_TEXT_LINE+iExtra) && str.GetAt(MAX_INF_TEXT_LINE+iExtra)==' ')
                                {
                                    strLine += str.GetAt(MAX_INF_TEXT_LINE+iExtra++);
                                }

                                str = str.Mid(MAX_INF_TEXT_LINE+iExtra);
                                if(str.IsEmpty())
                                {
                                    //
                                    // This string is all done write it as is, we can't break it
                                    //
                                    strLine += "\r\n";
                                }
                                else strLine += "\"+\r\n";

                                if(bFirstLine)
                                {
                                    strLine = " " + strLine;
                                    bFirstLine = FALSE;

                                } else
                                {
                                    strLine = strSpace + strLine;
                                }

                                TRY
                                {
                                    tgtFile.Write(strLine, strLine.GetLength());
                                }
                                CATCH(CFileException, pfe)
                                {
                                    return pfe->m_cause + IODLL_LAST_ERROR;
                                }
                                END_CATCH

                                //str = str.Mid(MAX_INF_TEXT_LINE+iExtra);
                            }

                            if(bFirstLine)
                            {
                                strLine = " " + str;
                            } else
                            {
                                if(!str.IsEmpty())
                                    strLine = strSpace + str;
                                else strLine = "";
                            }

                            if(!strLine.IsEmpty())
                            {
                                TRY
                                {
                                    tgtFile.Write(strLine, strLine.GetLength());
                                    tgtFile.Write("\r\n", 2);
                                }
                                CATCH(CFileException, pfe)
                                {
                                    return pfe->m_cause + IODLL_LAST_ERROR;
                                }
                                END_CATCH
                            }
                        }
                        else
                        {
                            TRY
                            {
                                tgtFile.Write(infLine.GetData(), infLine.GetDataLength());
                                tgtFile.Write("\r\n", 2);
                            }
                            CATCH(CFileException, pfe)
                            {
                                return pfe->m_cause + IODLL_LAST_ERROR;
                            }
                            END_CATCH
                        }

                        delete []pByte;
                    }
                }
                else
                {
                    TRY
                    {
                        tgtFile.Write(infLine.GetData(), infLine.GetDataLength());
                    }
                    CATCH(CFileException, pfe)
                    {
                        return pfe->m_cause + IODLL_LAST_ERROR;
                    }
                    END_CATCH
                }

                lEndPos = psrcinfFile->Seek(0, SEEK_CUR);
            }
        }
    }

exit:
    tgtFile.Close();

    if(pResList)
        delete []pResList;

    return uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImage(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize
    )
{
    UINT uiError = ERROR_NO_ERROR;

    //
    // Get the new string
    //
    LPCSTR lpNewStr = (LPCSTR)(((LPRESITEM)lpNewBuf)->lpszCaption);

    //
    // Copy the string in the new image buffer
    //

    int iLen = strlen(lpNewStr)+1;
    if(iLen<=(LONG)*pdwNewImageSize)
    {
        memcpy(lpNewImage, lpNewStr, iLen);
    }

    *pdwNewImageSize = iLen;

    return uiError;
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation

//=============================================================================
//  WriteResInfo
//
//  Fill the buffer to pass back to the iodll
//=============================================================================

LONG WriteResInfo(
    BYTE** lplpBuffer, LONG* plBufSize,
    WORD wTypeId, LPCSTR lpszTypeId, BYTE bMaxTypeLen,
    WORD wNameId, LPCSTR lpszNameId, BYTE bMaxNameLen,
    DWORD dwLang,
    DWORD dwSize, DWORD dwFileOffset )
{
    LONG lSize = 0;
    lSize = PutWord( lplpBuffer, wTypeId, plBufSize );
    lSize += PutStringA( lplpBuffer, (LPSTR)lpszTypeId, plBufSize );   // Note: PutStringA should get LPCSTR and not LPSTR
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutWord( lplpBuffer, wNameId, plBufSize );
    lSize += PutStringA( lplpBuffer, (LPSTR)lpszNameId, plBufSize );
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutDWord( lplpBuffer, dwLang, plBufSize );
    lSize += PutDWord( lplpBuffer, dwSize, plBufSize );
    lSize += PutDWord( lplpBuffer, dwFileOffset, plBufSize );

    return (LONG)lSize;
}

CInfFile * LoadFile(LPCSTR lpfilename)
{
    // Check if we have loaded the file before
    int c = (int)g_LoadedFile.GetSize();
    CLoadedFile * pLoaded;
    while(c)
    {
        pLoaded = (CLoadedFile*)g_LoadedFile.GetAt(--c);
        if(pLoaded->m_strFileName==lpfilename)
            return &pLoaded->m_infFile;
    }

    // The file need to be added to the list
    pLoaded = new CLoadedFile(lpfilename);

    g_LoadedFile.Add((CObject*)pLoaded);

    return &pLoaded->m_infFile;
}


PUPDATEDRESLIST CreateUpdateResList(BYTE * lpBuffer, UINT uiBufSize)
{
    //
    // Walk the buffer and count how many resources we have
    //
    int iResCount = 0;
    int iBufSize = uiBufSize;
    int iResSize = 0;
    BYTE * pBuf = lpBuffer;
    while(iBufSize>0)
    {
        iResSize = 2;
        iResSize += strlen((LPSTR)(pBuf+iResSize))+1;
        iResSize += Pad4(iResSize);

        iResSize += 2;
        iResSize += strlen((LPSTR)(pBuf+iResSize))+1;
        iResSize += Pad4(iResSize);

        iResSize += 4*2;

        if(iResSize<=iBufSize)
        {
            iBufSize -= iResSize;
            pBuf = pBuf + iResSize;
            iResCount++;
        }
    }

    //
    // Allocate the buffer that will hold the list
    //
    if(!iResCount)
        return NULL;

    pBuf = lpBuffer;
    iBufSize = uiBufSize;

    PUPDATEDRESLIST pListHead = new UPDATEDRESLIST[iResCount];

    if(pListHead==NULL)
        AfxThrowMemoryException();

    memset(pListHead, 0, sizeof(UPDATEDRESLIST)*iResCount);

    PUPDATEDRESLIST pList = pListHead;
    BYTE bPad = 0;
    WORD wSize = 0;
    while(iBufSize>0) {
        pList->pTypeId = (WORD*)pBuf;
        pList->pTypeName = (BYTE*)pList->pTypeId+sizeof(WORD);
        // check the allignement
        bPad = strlen((LPSTR)pList->pTypeName)+1+sizeof(WORD);
        bPad += Pad4(bPad);
        wSize = bPad;
        pList->pResId = (WORD*)((BYTE*)pBuf+bPad);
        pList->pResName = (BYTE*)pList->pResId+sizeof(WORD);
        bPad = strlen((LPSTR)pList->pResName)+1+sizeof(WORD);
        bPad += Pad4(bPad);
        wSize += bPad;
        pList->pLang = (DWORD*)((BYTE*)pList->pResId+bPad);
        pList->pSize = (DWORD*)((BYTE*)pList->pLang+sizeof(DWORD));
        pList->pNext = (PUPDATEDRESLIST)pList+1;
        wSize += sizeof(DWORD)*2;
        pBuf = pBuf+wSize;
        iBufSize -= wSize;
        if(!iBufSize)
            pList->pNext = NULL;
        else
            pList++;
    }

    return pListHead;
}

PUPDATEDRESLIST FindId(LPCSTR pstrId, PUPDATEDRESLIST pList)
{
    //
    // Note that this function assumes that the type is always right
    // since it is a inf file this is a fair assumption.
    // It could be optimized.
    //
    if(!pList)
        return NULL;

    PUPDATEDRESLIST pLast = pList;
    while(pList)
    {
        if(!strcmp((LPSTR)pList->pResName, pstrId)) {
                return pList;
        }
        pList = pList->pNext;
    }

    return NULL;
}

////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Library init
static AFX_EXTENSION_MODULE rwinfDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("RWINF.DLL Initializing!\n");

        AfxInitExtensionModule(rwinfDLL, hInstance);

        new CDynLinkLibrary(rwinfDLL);

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("RWINF.DLL Terminating!\n");

        // free all the loaded files
        int c = (int)g_LoadedFile.GetSize();
        CLoadedFile * pLoaded;
        while(c)
        {
            pLoaded = (CLoadedFile*)g_LoadedFile.GetAt(--c);
            delete pLoaded;
        }
    }
    return 1;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\res32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\rcdata\kernel32\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include "..\..\common\rwdll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\rcdata\kernel32\krnl32.cpp ===
// kernel32.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <afxdllx.h>
#include "..\..\common\rwdll.h"
#include "..\..\common\rw32hlpr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE kernel32DLL = { NULL, NULL };

UINT ParseRCData( LPCSTR lpszResId, LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize );
UINT UpdateRCData( LPVOID lpNewBuf, LONG dwNewSize, LPVOID lpOldI, LONG dwOldImageSize, LPVOID lpNewI, DWORD* pdwNewImageSize );

extern char szCaption[MAXSTR];

/////////////////////////////////////////////////////////////////////////////
// This file implements the RCDATA handling for the file kernel32.dll

extern "C"
DllExport
UINT
APIENTRY
RWParseImageEx(
    LPCSTR  lpszType,
    LPCSTR  lpszResId,
    LPVOID  lpImageBuf,
    DWORD   dwImageSize,
    LPVOID  lpBuffer,
    DWORD   dwSize,
    LPCSTR  lpDllName
    )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE * lpBuf = (BYTE *)lpBuffer;
    DWORD dwBufSize = dwSize;

    // The Type we can parse are only the standard ones
    // This function should fill the lpBuffer with an array of ResItem structure
    switch ((UINT)LOWORD(lpszType)) {
        case 10:
            uiError = ParseRCData( lpszResId, lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
               
        default:
        break;
    }

    return uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImageEx(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize,
    LPCSTR  lpRCFilename
    )
{
    UINT uiError = ERROR_NO_ERROR;

    // The Type we can parse are only the standard ones
    switch ((UINT)LOWORD(lpszType)) {
        case 10:
            uiError = UpdateRCData( lpNewBuf, dwNewSize,
                                    lpOldImage, dwOldImageSize,
                                    lpNewImage, pdwNewImageSize );
        break;
        default:
            *pdwNewImageSize = 0L;
            uiError = ERROR_RW_NOTREADY;
        break;
    }

    return uiError;
}

/////////////////////////////////////////////////////////////////////////////
// Real implementation of the parsers

UINT
ParseRCData( LPCSTR lpszResId, LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    //
    // The data in the RCDATA is just a string null terminated
    //
    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
     
    //
    // Get the string from the image
    //
    GetStringW( (BYTE**)&lpImageBuf, &szCaption[0], (LONG*)&dwISize, MAXSTR );
    LONG dwOverAllSize = sizeof(RESITEM)+strlen(szCaption);

    if( (LONG)dwSize>dwOverAllSize ) 
    {
        //
        // Clear the resitem buffer
        //
        memset(lpResItem, '\0', dwSize);

        lpResItem->dwSize = dwOverAllSize;
        lpResItem->dwItemID = 1;   
        lpResItem->dwResID = LOWORD(lpszResId);

        lpResItem->dwTypeID = 11;   
        lpResItem->lpszCaption = strcpy((((char*)lpResItem)+sizeof(RESITEM)), &szCaption[0]);
    }

    return (UINT)(dwOverAllSize);
}

UINT
UpdateRCData( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LPRESITEM lpResItem = (LPRESITEM)lpNewBuf;

    if(*pdwNewImageSize>strlen(lpResItem->lpszCaption))
    {
        // Write the text
        *pdwNewImageSize = PutStringW( (BYTE **)&lpNewI, lpResItem->lpszCaption, (LONG*)pdwNewImageSize );

    }

    return uiError;
}

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("RCKERNEL32.DLL Initializing!\n");

        InitGlobals();
		AfxInitExtensionModule(kernel32DLL, hInstance);

		new CDynLinkLibrary(kernel32DLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("RCKERNEL32.DLL Terminating!\n");
	}
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\rcdata\kernel32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by krnl32.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\mac\mac.h ===
/////////////////////////////////////////////////////////////////////////////
// Function Declarations

//=============================================================================
// Header parsing functions
//=============================================================================

WORD MapToWindowsRes( char * pResName );

LONG WriteResInfo(
                 BYTE** lplpBuffer, LONG* plBufSize,
                 WORD wTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
                 WORD wNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
                 DWORD dwLang,
                 DWORD dwSize, DWORD dwFileOffset );

BOOL InitIODLLLink();
//=============================================================================
// IODLL call back functions and HINSTANCE
//=============================================================================

extern HINSTANCE g_IODLLInst;
extern DWORD (PASCAL * g_lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
extern DWORD (PASCAL * g_lpfnUpdateResImage)(HANDLE,	LPSTR, LPSTR, DWORD, DWORD, LPVOID, DWORD);
extern HANDLE (PASCAL * g_lpfnHandleFromName)(LPCSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\rcdata\kernel32\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// kernel32.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\win16\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\win32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\mac\mac.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       mac.cpp
//
//  Contents:   Implementation for the Macintosh Read/Write module
//
//  History:    23-Aug-94   alessanm    created
//
//----------------------------------------------------------------------------

#include <afxwin.h>
#include <limits.h>
#include <malloc.h>
#include "..\common\rwdll.h"
#include "..\common\m68k.h"
#include "..\common\helper.h"
#include "mac.h"


/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define RWTAG "MAC"

static ULONG gType;
static ULONG gLng;
static ULONG gResId;
static WCHAR gwszResId[256];

HINSTANCE g_IODLLInst = 0;
DWORD (PASCAL * g_lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
DWORD (PASCAL * g_lpfnUpdateResImage)(HANDLE,	LPSTR, LPSTR, DWORD, DWORD, LPVOID, DWORD);
HANDLE (PASCAL * g_lpfnHandleFromName)(LPCSTR);


/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

//[registration]
extern "C"
BOOL    FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
    strcpy( lpszTypeName, RWTAG );
    return FALSE;
}

//=============================================================================
//
//	To validate a mac res binary file we will walk the resource header and see
//  if it matches with what we have.
//
//=============================================================================

extern "C"
BOOL    FAR PASCAL RWValidateFileType   (LPCSTR lpszFilename)
{
    BOOL bRet = FALSE;
    TRACE("MAC.DLL: RWValidateFileType()\n");

    CFile file;

    // we Open the file to see if it is a file we can handle
    if (!file.Open( lpszFilename, CFile::typeBinary | CFile::modeRead | CFile::shareDenyNone ))
        return bRet;

	// Check if this is a MAC Resource file ...
	if(IsMacResFile( &file ))
		bRet = TRUE;

    file.Close();
    return bRet;
}

//=============================================================================
//
//  We will walk the resource header, walk the resource map and then normalize
//  the Mac it to Windows id and pass this info to the RW.
//
//=============================================================================

extern "C"
DllExport
UINT
APIENTRY
RWReadTypeInfo(
    LPCSTR lpszFilename,
    LPVOID lpBuffer,
    UINT* puiSize

    )
{
	TRACE("MAC.DLL: RWReadTypeInfo()\n");
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    UINT uiBufSize = *puiSize;
    CFile file;
	int iFileNameLen = strlen(lpszFilename)+1;

    if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return ERROR_FILE_OPEN;

    UINT uiBufStartSize = uiBufSize;

	////////////////////////////////////
	// Check if it is  a valid mac file

	// Is a Mac Resource file ...
	if(IsMacResFile( &file )) {
		// load the file in memory
        // NOTE: WIN16 This might be to expensive in memory allocation
        // on a 16 bit platform
		BYTE * pResources = (BYTE*)malloc(file.GetLength());
		if(!pResources) {
			file.Close();
			return ERROR_NEW_FAILED;
		}
		
		file.Seek(0, CFile::begin);
		file.ReadHuge(pResources, file.GetLength());

		IMAGE_SECTION_HEADER Sect;
		memset(&Sect, 0, sizeof(IMAGE_SECTION_HEADER));
		
		ParseResourceFile(pResources, &Sect, (BYTE**)&lpBuffer, (LONG*)puiSize, iFileNameLen);
		free(pResources);

		*puiSize = uiBufSize - *puiSize;
		file.Close();
	   	return uiError;
	}

    file.Close();
    return uiError;
}

/////////////////////////////////////////////////////////////////////////////
// We will prepend to the image the file name. This will be usefull later on
// to retrive the dialog item list
/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport
DWORD
APIENTRY
RWGetImage(
    LPCSTR  lpszFilename,
    DWORD   dwImageOffset,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
	UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
	int iNameLen = strlen(lpszFilename)+1;
    DWORD dwBufSize = dwSize - iNameLen;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile file;

    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return (DWORD)ERROR_FILE_OPEN;

    if ( dwImageOffset!=(DWORD)file.Seek( dwImageOffset, CFile::begin) )
        return (DWORD)ERROR_FILE_INVALID_OFFSET;

	// copy the file name at the beginning of the buffer
	memcpy((BYTE*)lpBuf, lpszFilename, iNameLen);
	lpBuf = ((BYTE*)lpBuf+iNameLen);

    if (dwBufSize>UINT_MAX) {
        // we have to read the image in different steps
        return (DWORD)0L;
    } else uiError = file.Read( lpBuf, (UINT)dwBufSize)+iNameLen;
    file.Close();

    return (DWORD)uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWParseImage(
    LPCSTR  lpszType,
    LPVOID  lpImageBuf,
    DWORD   dwImageSize,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE * lpBuf = (BYTE *)lpBuffer;
    DWORD dwBufSize = dwSize;

	
	// Remove the filename...
	if( !strcmp(lpszType, "MENU")  	||
	    !strcmp(lpszType, "STR ")  	||
		!strcmp(lpszType, "STR#")	||
		!strcmp(lpszType, "TEXT")
		) {
		int iFileNameLen = strlen((LPSTR)lpImageBuf)+1;
		lpImageBuf = ((BYTE*)lpImageBuf+iFileNameLen);
		dwImageSize -= iFileNameLen;
	}

    //===============================================================
	// Menus
	if( !strcmp(lpszType, "MENU") )
		return ParseMENU( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	//===============================================================
	// Dialogs
	if( !strcmp(lpszType, "WDLG") )
		return ParseWDLG( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	if( !strcmp(lpszType, "DLOG") )
		return ParseDLOG( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	if( !strcmp(lpszType, "ALRT") )
		return ParseALRT( lpImageBuf, dwImageSize, lpBuffer, dwSize );

    //===============================================================
	// Strings
	if( !strcmp(lpszType, "STR ") )
		return ParseSTR( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	if( !strcmp(lpszType, "STR#") )
		return ParseSTRNUM( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	if( !strcmp(lpszType, "TEXT") )
		return ParseTEXT( lpImageBuf, dwImageSize, lpBuffer, dwSize );

    if( !strcmp(lpszType, "WIND") )
		return ParseWIND( lpImageBuf, dwImageSize, lpBuffer, dwSize );
	
    return uiError;
}

extern"C"
DllExport
UINT
APIENTRY
RWWriteFile(
    LPCSTR          lpszSrcFilename,
    LPCSTR          lpszTgtFilename,
    HANDLE          hResFileModule,
    LPVOID          lpBuffer,
    UINT            uiSize,
    HINSTANCE       hDllInst,
    LPCSTR          lpszSymbolPath
    )
{
    TRACE("RWMAC.DLL: Source: %s\t Target: %s\n", lpszSrcFilename, lpszTgtFilename);
    UINT uiError = ERROR_NO_ERROR;
    PUPDATEDRESLIST pUpdList = LPNULL;

    // Get the handle to the IODLL
    if(InitIODLLLink())
  	    hDllInst = g_IODLLInst;
    else return ERROR_DLL_LOAD;

	CFile fileIn;
    CFile fileOut;

    if (!fileIn.Open(lpszSrcFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return (DWORD)ERROR_FILE_OPEN;

    if (!fileOut.Open(lpszTgtFilename, CFile::modeWrite | CFile::typeBinary))
        return (DWORD)ERROR_FILE_OPEN;

    MACRESHEADER fileHeader;
    // Read the header of the file...
    fileIn.Read(&fileHeader, sizeof(MACRESHEADER));

    // allocate a buffer to hold the new resource map
    // The buffer will be as big as the other one since there is no
    // need, for now, to support the adding of resource
    LONG lMapSize = MacLongToLong(fileHeader.mulSizeOfResMap);
    BYTE * pNewMap = (BYTE*)malloc(lMapSize);

    if(!pNewMap) {
        uiError = ERROR_NEW_FAILED;
        goto exit;
    }
{ // This is for the goto. Check error:C2362

    PUPDATEDRESLIST pListItem = LPNULL;
    // Create the list of update resource
    pUpdList = UpdatedResList( lpBuffer, uiSize );

    // set the map buffer to 0 ...
    memset(pNewMap, 0, lMapSize);

    ////////////////////////////////////////////////////////////////////////////////
    // Read each resource from the resource map and check if the resource has been
    // updated. If it has been updated, get the new resource image. Otherwise use
    // the original resource data.
    // Write the resource data in the Tgt file and write the info on the offset etc.
    // in the pNewMap buffer so, when all the resources have been read and written
    // the only thing left is to fix up some sizes and to write the buffer to disk.
    ////////////////////////////////////////////////////////////////////////////////

    // Write the resource header in the Tgt file
    fileOut.Write(&fileHeader, sizeof(MACRESHEADER));

    BYTE * pByte = (BYTE*)malloc(256);
    if(!pByte) {
        uiError = ERROR_NEW_FAILED;
        goto exit;
    }

    // Copy the Reserved and user data
    fileIn.Read(pByte, 240);
    fileOut.Write(pByte, 240);
    free(pByte);

    // store the position of the beginning of the res data
    DWORD dwBeginOfResData = fileOut.GetPosition();

    MACRESMAP resMap;
    // Read the resource map ...
    fileIn.Seek(MacLongToLong(fileHeader.mulOffsetToResMap), CFile::begin);
    fileIn.Read(&resMap, sizeof(MACRESMAP));

    BYTE * pTypeList = pNewMap+28;
    BYTE * pTypeInfo = pTypeList+2;
    BYTE * pRefList = LPNULL;
    BYTE * pNameList = LPNULL;
    BYTE * pName = LPNULL;

    DWORD dwOffsetToTypeList = fileIn.GetPosition();
    WORD wType;
    fileIn.Read(&wType, sizeof(WORD));
    memcpy( pNewMap+sizeof(MACRESMAP), &wType, sizeof(WORD));   // number of types - 1
    wType = MacWordToWord((BYTE*)&wType)+1;

    MACRESTYPELIST TypeList;
    MACRESREFLIST RefList;
    WORD wOffsetToRefList = wType*sizeof(MACRESTYPELIST)+sizeof(WORD);
    DWORD dwOffsetToLastTypeInfo = 0;
    DWORD dwOffsetToLastRefList = 0;
    DWORD dwOffsetToNameList = MacLongToLong(fileHeader.mulOffsetToResMap)+MacWordToWord(resMap.mwOffsetToNameList);
    DWORD dwSizeOfData = 0;

    while(wType) {
        // Read the type info ...
        fileIn.Read(&TypeList, sizeof(MACRESTYPELIST));
        dwOffsetToLastTypeInfo = fileIn.GetPosition();

        // ... and update the newmap buffer
        memcpy( pTypeInfo, &TypeList, sizeof(MACRESTYPELIST));
        // Fix up the offset to the ref list
        memcpy(((PMACRESTYPELIST)pTypeInfo)->mwOffsetToRefList, WordToMacWord(wOffsetToRefList), sizeof(WORD));
        pRefList = pTypeList+wOffsetToRefList;
        pTypeInfo = pTypeInfo+sizeof(MACRESTYPELIST);

        // go to the refence list ...
        fileIn.Seek(dwOffsetToTypeList+MacWordToWord(TypeList.mwOffsetToRefList), CFile::begin);

        WORD wItems = MacWordToWord(TypeList.mwNumOfThisType)+1;
        while(wItems){
            // and read the reference list for this type
            fileIn.Read( &RefList, sizeof(MACRESREFLIST));
            dwOffsetToLastRefList = fileIn.GetPosition();

            // is this a named resource ...
            if(MacWordToWord(RefList.mwOffsetToResName)!=0xffff) {
                // read the string
                fileIn.Seek(dwOffsetToNameList+MacWordToWord(RefList.mwOffsetToResName), CFile::begin);
                BYTE bLen = 0;
                fileIn.Read(&bLen, 1);
                if(!pNameList) {
                    pName = pNameList = (BYTE*)malloc(1024);
                    if(!pNameList) {
                        uiError = ERROR_NEW_FAILED;
                        goto exit;
                    }
                }
                // check the free space we have
                if((1024-((pName-pNameList)%1024))<=bLen+1){
                    BYTE * pNew = (BYTE*)realloc(pNameList, _msize(pNameList)+1024);
                    if(!pNew) {
                        uiError = ERROR_NEW_FAILED;
                        goto exit;
                    }
                    pName = pNew+(pName-pNameList);
                    pNameList = pNew;
                }

                // Update the pointer to the string
                memcpy(RefList.mwOffsetToResName, WordToMacWord((WORD)(pName-pNameList)), 2);

                memcpy(pName++, &bLen, 1);
                // we have room for the string
                fileIn.Read(pName, bLen);

                pName = pName+bLen;
            }

            // check if this item has been updated
            if(pListItem = IsResUpdated(&TypeList.szResName[0], RefList, pUpdList)) {
                // Save the offset to the resource
                DWORD dwOffsetToData = fileOut.GetPosition();
                DWORD dwSize = *pListItem->pSize;

                // allocate the buffer to hold the resource data
                pByte = (BYTE*)malloc(dwSize);
                if(!pByte){
                    uiError = ERROR_NEW_FAILED;
                    goto exit;
                }

                // get the data from the iodll
                LPSTR	lpType = LPNULL;
    			LPSTR	lpRes = LPNULL;
    			if (*pListItem->pTypeId) {
    				lpType = (LPSTR)((WORD)*pListItem->pTypeId);
    			} else {
    				lpType = (LPSTR)pListItem->pTypeName;
    			}
    			if (*pListItem->pResId) {
    				lpRes = (LPSTR)((WORD)*pListItem->pResId);
    			} else {
    				lpRes = (LPSTR)pListItem->pResName;
    			}

    			DWORD dwImageBufSize = (*g_lpfnGetImage)(  hResFileModule,
    											lpType,
    											lpRes,
    											*pListItem->pLang,
    											pByte,
    											*pListItem->pSize
    						   					);

                // Remove the file name from the image
                int iFileNameLen = strlen((LPSTR)pByte)+1;
                dwSize -= iFileNameLen;

                // write the size of the data block
                fileOut.Write(LongToMacLong(dwSize), sizeof(DWORD));
                dwSizeOfData += dwSize+sizeof(DWORD);

    			fileOut.Write((pByte+iFileNameLen), dwSize);

                free(pByte);

                // fix up the offset to the resource in the ref list
                memcpy(RefList.bOffsetToResData, LongToMacOffset(dwOffsetToData-dwBeginOfResData), 3);
            }
            else {
                // Get the data from the Src file
                // get to the data
                fileIn.Seek(MacLongToLong(fileHeader.mulOffsetToResData)+
                    MacOffsetToLong(RefList.bOffsetToResData), CFile::begin);

                // read the size of the data block
                DWORD dwSize = 0;
                fileIn.Read(&dwSize, sizeof(DWORD));

                // Save the offset to the resource
                DWORD dwOffsetToData = fileOut.GetPosition();

                // write the size of the data block
                fileOut.Write(&dwSize, sizeof(DWORD));
                dwSizeOfData += sizeof(DWORD);

                // allocate the buffer to hold the resource data
                dwSizeOfData += dwSize = MacLongToLong((BYTE*)&dwSize);
                pByte = (BYTE*)malloc(dwSize);
                if(!pByte){
                    uiError = ERROR_NEW_FAILED;
                    goto exit;
                }

                // copy the data
                fileIn.Read(pByte, dwSize);
                fileOut.Write(pByte, dwSize);

                free(pByte);

                // fix up the offset to the resource in the ref list
                memcpy(RefList.bOffsetToResData, LongToMacOffset(dwOffsetToData-dwBeginOfResData), 3);

            }

            // return in the right place
            fileIn.Seek(dwOffsetToLastRefList, CFile::begin);

            // copy this data in the new map buffer
            memcpy(pRefList, &RefList, sizeof(MACRESREFLIST));
            wOffsetToRefList+=sizeof(MACRESREFLIST);

            // move to the new ref list
            pRefList = pTypeList+wOffsetToRefList;
            wItems--;
        }

        fileIn.Seek(dwOffsetToLastTypeInfo, CFile::begin);
        wType--;
    }

    // copy the resource map header info
    memcpy( pNewMap, &resMap, sizeof(MACRESMAP));

    // copy the name list at the end of the res map
    dwOffsetToNameList = 0;
    if(pNameList) {
        dwOffsetToNameList = (DWORD)(pRefList-pNewMap);
        // copy the name list
        memcpy(pRefList, pNameList, (size_t)(pName-pNameList));
        free(pNameList);
    }

    // write the resource map
    DWORD dwOffsetToResMap = fileOut.GetPosition();
    fileOut.Write(pNewMap, lMapSize);

    // We need to fix up the file header ...
    fileOut.Seek(4, CFile::begin);
    fileOut.Write(LongToMacLong(dwOffsetToResMap), sizeof(DWORD));
    fileOut.Write(LongToMacLong(dwSizeOfData), sizeof(DWORD));

    // ... and the resource map header
    fileOut.Seek(dwOffsetToResMap+4, CFile::begin);
    fileOut.Write(LongToMacLong(dwOffsetToResMap), sizeof(DWORD));
    fileOut.Write(LongToMacLong(dwSizeOfData), sizeof(DWORD));

    fileOut.Seek(dwOffsetToResMap+26, CFile::begin);
    fileOut.Write(WordToMacWord(LOWORD(dwOffsetToNameList)), sizeof(WORD));


}
exit:
    fileIn.Close();
    fileOut.Close();
    if(pNewMap)
        free(pNewMap);
    if(pUpdList)
        free(pUpdList);

    return (UINT)uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImage(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize
    )
{
    UINT uiError = ERROR_RW_NOTREADY;

    //===============================================================
	// Since all the Type are named in the mac at this stage we need to
    // know the original name of the Type and not the Windows type.
    // Use the typeID stored in the new ites buffer
    LPSTR lpRealType = ((PRESITEM)lpNewBuf)->lpszTypeID;

    if(!HIWORD(lpRealType))     // something is wrong if this is not valid
        return uiError;

    //===============================================================
	// Menus
	if( !strcmp(lpRealType, "MENU") )
		return UpdateMENU( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

    //===============================================================
	// Strings
	if( !strcmp(lpRealType, "STR ") )
		return UpdateSTR( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

    if( !strcmp(lpRealType, "STR#") )
		return UpdateSTRNUM( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

	if( !strcmp(lpRealType, "WIND") )
		return UpdateWIND( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

    //===============================================================
	// Dialogs
	if( !strcmp(lpRealType, "DLOG") )
		return UpdateDLOG( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );
    if( !strcmp(lpRealType, "ALRT") )
		return UpdateALRT( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

	*pdwNewImageSize = 0L;
	return uiError;
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation

//=============================================================================
//	MapToWindowsRes
//
//	Map a Mac resource name to a Windows resource
//=============================================================================
WORD MapToWindowsRes( char * pResName )
{
	if( !strcmp(pResName, "PICT") ||
		!strcmp(pResName, "WBMP"))
		return 2;
	
	if( !strcmp(pResName, "MENU") ||
		!strcmp(pResName, "WMNU"))
		return 4;

	if( !strcmp(pResName, "DLOG") ||
		!strcmp(pResName, "ALRT") ||
        !strcmp(pResName, "WDLG"))
		return 5;

	if( !strcmp(pResName, "STR "))
		return STR_TYPE;

	if( !strcmp(pResName, "STR#") ||
		!strcmp(pResName, "TEXT"))
		return MSG_TYPE;

	if( !strcmp(pResName, "vers") ||
		!strcmp(pResName, "VERS"))
		return 16;

    // For the Item list return 17. This means nothing to windows and will
    // give us the flexibility to update the DITL list from the RW, without user
    // input.
    if( !strcmp(pResName, "DITL"))
		return DITL_TYPE;

	// For the Frame Window Caption mark it as type 18
	if( !strcmp(pResName, "WIND"))
		return WIND_TYPE;

	return 0;
}

//=============================================================================
//	WriteResInfo
//
//	Fill the buffer to pass back to the iodll
//=============================================================================

LONG WriteResInfo(
                 BYTE** lplpBuffer, LONG* plBufSize,
                 WORD wTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
                 WORD wNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
                 DWORD dwLang,
                 DWORD dwSize, DWORD dwFileOffset )
{
    LONG lSize = 0;
    lSize = PutWord( lplpBuffer, wTypeId, plBufSize );
    lSize += PutStringA( lplpBuffer, lpszTypeId, plBufSize );
	 // Check if it is alligned
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutWord( lplpBuffer, wNameId, plBufSize );
    lSize += PutStringA( lplpBuffer, lpszNameId, plBufSize );
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutDWord( lplpBuffer, dwLang, plBufSize );

    lSize += PutDWord( lplpBuffer, dwSize, plBufSize );

    lSize += PutDWord( lplpBuffer, dwFileOffset, plBufSize );

    return (LONG)lSize;
}

BOOL InitIODLLLink()
{
    if(!g_IODLLInst)
    {
        // Init the link with the iodll
        g_IODLLInst = LoadLibrary("iodll.dll");
        if(!g_IODLLInst)
            return FALSE;

        if((g_lpfnGetImage = (DWORD (PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
						    GetProcAddress( g_IODLLInst, "RSGetResImage" ))==NULL)
	        return FALSE;

        if((g_lpfnHandleFromName = (HANDLE (PASCAL *)(LPCSTR))
						    GetProcAddress( g_IODLLInst, "RSHandleFromName" ))==NULL)
	        return FALSE;

        if((g_lpfnUpdateResImage = (DWORD (PASCAL *)(HANDLE, LPSTR, LPSTR, DWORD, DWORD, LPVOID, DWORD))
						    GetProcAddress( g_IODLLInst, "RSUpdateResImage" ))==NULL)
	        return FALSE;

	
    }
    else {
        if(g_lpfnGetImage==NULL || g_lpfnHandleFromName==NULL)
            return FALSE;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation

////////////////////////////////////////////////////////////////////////////
// Library init

////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory
		// here, use the TRACE or ASSERT macros or call MessageBox
		AfxInitExtensionModule(extensionDLL, hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxWinTerm();

        // remove the link with iodll
        if(g_IODLLInst)
            FreeLibrary(g_IODLLInst);

	}

	if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
		return 0;		// CRT term	Failed

	return 1;   // ok
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\res32\res32.cpp ===
//+---------------------------------------------------------------------------
//
//  File:	res32.cpp
//
//  Contents:	Implementation for the Resource 32 Read/Write module
//
//  Classes:    one
//
//  History:	31-May-93   alessanm    created
//----------------------------------------------------------------------------

#include <afxwin.h>

#include "..\common\rwdll.h"
#include "..\common\rw32hlpr.h"

#include <limits.h>

/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define RWTAG "RES32"

/////////////////////////////////////////////////////////////////////////////
// Function Declarations

static UINT GetResInfo(
				 CFile*,
				 WORD* wTypeId, LPSTR lplpszTypeId, BYTE bMaxTypeLen,
				 WORD* wNameId, LPSTR lplpszNameId, BYTE bMaxNameLen,
				 DWORD* pdwDataVersion,
				 WORD* pwFlags, WORD* pwLang,
				 DWORD* pdwVersion, DWORD* pdwCharact,
				 DWORD* dwSize, DWORD* dwFileOffset, DWORD );

static UINT WriteHeader(
				 CFile* pFile,
				 DWORD dwSize,
				 WORD wTypeId, LPSTR lpszwTypeId,
				 WORD wNameId, LPSTR lpszwNameId,
				 DWORD dwDataVersion,
				 WORD wFlags, WORD wLang,
				 DWORD dwVersion, DWORD dwCharact );

static UINT WriteImage(
				 CFile*,
				 LPVOID lpImage, DWORD dwSize );

static UINT GetUpdatedRes(
				 LPVOID far * lplpBuffer,
				 LONG* lSize,
				 WORD* wTypeId, LPSTR lplpszTypeId,
				 WORD* wNameId, LPSTR lplpszNameId,
				 DWORD* dwlang, DWORD* dwSize );

static UINT GenerateFile(
				LPCSTR		lpszTgtFilename,
				HANDLE		hResFileModule,
				LPVOID		lpBuffer,
				UINT		uiSize,
				HINSTANCE   hDllInst );

static UINT GetNameOrOrdFile( CFile* pfile, WORD* pwId, LPSTR lpszId, BYTE bMaxStrLen );


/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

//[registration]
extern "C"
BOOL	FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
	strcpy( lpszTypeName, RWTAG );
	return FALSE;
}

extern "C"
BOOL	FAR PASCAL RWValidateFileType	(LPCSTR lpszFilename)
{
	UINT uiError = ERROR_NO_ERROR;
	CFile file;

	// Open the file and try to read the information on the resource in it.
	if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
		return FALSE;

	WORD wTypeId;
	static char szTypeId[128];

	WORD wNameId;
	static char szNameId[128];
	WORD wDummy;
	DWORD dwDummy;
	WORD wLang;
	DWORD dwSize;
	DWORD dwFileOffset;

	DWORD filelen = file.GetLength();

	// File begins with a null resource entry. Check for signature.
	{  DWORD datasize, headsize;

	   // Filelen to at least 32 bytes, the size of a resource entry with
	   // datasize = 0...  Note: A file consisting of just a null header is accepted.
	   if (filelen < 32) {
	       file.Close();
	       return FALSE;
	       }

	   // datasize to be 0 (although >0 everywhere else)
	   file.Read(&datasize, 4);
	   if (datasize != 0) {
	       file.Close();
	       return FALSE;
	       }

	   // headsize to be 32 (although >=32 everywhere else)
	   file.Read(&headsize, 4);
	   if (headsize != 32) {
	       file.Close();
	       return FALSE;
	       }

	   // Other tests possible here

	   // Skip to end of first (null) resource entry
	   file.Seek(headsize, CFile::begin);
	   }

	// See that rest of file contains recognizable resource entries
	while(filelen - file.GetPosition()>0) {
		if (!GetResInfo( &file,
					  &wTypeId, &szTypeId[0], 128,
					  &wNameId, &szNameId[0], 128,
					  &dwDummy,
					  &wDummy, &wLang,
					  &dwDummy, &dwDummy,
					  &dwSize, &dwFileOffset, filelen) ) {
			// This is not a valid resource file
			file.Close();
			return FALSE;
		}
	}

	file.Close();
	return TRUE;
}


extern "C"
UINT
APIENTRY
RWReadTypeInfo(
	LPCSTR lpszFilename,
	LPVOID lpBuffer,
	UINT* puiSize

	)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = (BYTE far *)lpBuffer;
	LONG lBufSize = (LONG)*puiSize;
	// we can consider the use of a CMemFile so we get the same speed as memory access.
	CFile file;

	if (!RWValidateFileType(lpszFilename))
		return ERROR_RW_INVALID_FILE;
	
    // Make sure we are using the right code page and global settings
    // Get the pointer to the function
	HINSTANCE hDllInst = LoadLibrary("iodll.dll");
    if (hDllInst)
    {
        UINT (FAR PASCAL * lpfnGetSettings)(LPSETTINGS);
        // Get the pointer to the function to get the settings
        lpfnGetSettings = (UINT (FAR PASCAL *)(LPSETTINGS))
                            GetProcAddress( hDllInst, "RSGetGlobals" );
        if (lpfnGetSettings!=NULL) {
            SETTINGS settings;
	        (*lpfnGetSettings)(&settings);

    	    g_cp      = settings.cp;
            g_bAppend = settings.bAppend;
            g_bUpdOtherResLang = settings.bUpdOtherResLang;
            strcpy( g_char, settings.szDefChar );
		}

        FreeLibrary(hDllInst);
    }

    // Open the file and try to read the information on the resource in it.
	if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
		return ERROR_FILE_OPEN;

	// we try to read as much information as we can
	// Because this is a res file we can read all the information we need.

	WORD wTypeId;
	static char szTypeId[128];

	WORD wNameId;
	static char szNameId[128];
	WORD wDummy;
	DWORD dwDummy;
	WORD wLang;
	DWORD dwSize;
	DWORD dwFileOffset;

	UINT uiOverAllSize = 0;

	// The first resource should be: Null. Skipp it
	file.Seek( 32, CFile::begin);
	DWORD filelen =	file.GetLength();
	while(filelen-file.GetPosition()>0) {
		GetResInfo( &file,
					  &wTypeId, &szTypeId[0], 128,
					  &wNameId, &szNameId[0], 128,
					  &dwDummy,
					  &wDummy, &wLang,
					  &dwDummy, &dwDummy,
					  &dwSize, &dwFileOffset, filelen);

		uiOverAllSize += PutWord( &lpBuf, wTypeId, &lBufSize );
		uiOverAllSize += PutStringA( &lpBuf, szTypeId, &lBufSize );
		// Check if it is alligned
 		uiOverAllSize += Allign( &lpBuf, &lBufSize , (LONG)uiOverAllSize);

		uiOverAllSize += PutWord( &lpBuf, wNameId, &lBufSize  );
		uiOverAllSize += PutStringA( &lpBuf, szNameId, &lBufSize );
		// Check if it is alligned
 		uiOverAllSize += Allign( &lpBuf, &lBufSize, (LONG)uiOverAllSize);

		uiOverAllSize += PutDWord( &lpBuf, (DWORD)wLang, &lBufSize );

		uiOverAllSize += PutDWord( &lpBuf, dwSize, &lBufSize  );

		uiOverAllSize += PutDWord( &lpBuf, dwFileOffset, &lBufSize );
	}

	file.Close();
	*puiSize = uiOverAllSize;
	return uiError;
}

extern "C"
DWORD
APIENTRY
RWGetImage(
	LPCSTR	lpszFilename,
	DWORD	dwImageOffset,
	LPVOID	lpBuffer,
	DWORD	dwSize
	)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = (BYTE far *)lpBuffer;
	DWORD dwBufSize = dwSize;
	// we can consider the use of a CMemFile so we get the same speed as memory access.
	CFile file;

	// Open the file and try to read the information on the resource in it.
	if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
		return (DWORD)ERROR_FILE_OPEN;

	if ( dwImageOffset!=(DWORD)file.Seek( dwImageOffset, CFile::begin) )
		return (DWORD)ERROR_FILE_INVALID_OFFSET;
	if (dwSize>UINT_MAX) {
		// we have to read the image in different steps
		return (DWORD)0L;
	} else uiError = file.Read( lpBuf, (UINT)dwSize);
	file.Close();

	return (DWORD)uiError;
}

extern "C"
UINT
APIENTRY
RWParseImage(
	LPCSTR	lpszType,
	LPVOID	lpImageBuf,
	DWORD	dwImageSize,
	LPVOID	lpBuffer,
	DWORD	dwSize
	)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = (BYTE far *)lpBuffer;
	DWORD dwBufSize = dwSize;

	// The Type we can parse are only the standard ones
	// This function should fill the lpBuffer with an array of ResItem structure
	switch ((UINT)LOWORD(lpszType)) {\
		/*
		case 1:
			uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;

		case 3:
			uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;
		*/
		case 4:
			uiError = ParseMenu( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;


		case 5:
			uiError = ParseDialog( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;

        case 6:
			uiError = ParseString( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;

        case 9:
			uiError = ParseAccel( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;
		case 11:
			uiError = ParseMsgTbl( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;
        case 16:
            uiError = ParseVerst( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
		default:
		break;
	}

	return uiError;
}

extern"C"
UINT
APIENTRY
RWWriteFile(
	LPCSTR		lpszSrcFilename,
	LPCSTR		lpszTgtFilename,
	HANDLE		hResFileModule,
	LPVOID		lpBuffer,
	UINT		uiSize,
	HINSTANCE   hDllInst,
    LPCSTR      lpszSymbolPath
	)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = LPNULL;
	UINT uiBufSize = uiSize;
	// we can consider the use of a CMemFile so we get the same speed as memory access.
	CFile fileIn;
	CFile fileOut;
	BOOL  bfileIn = TRUE;

	// Open the file and try to read the information on the resource in it.
	CFileStatus status;
	if (CFile::GetStatus( lpszSrcFilename, status )) {
		// check if the size of the file is not null
		if (!status.m_size)
			CFile::Remove(lpszSrcFilename);
	}

	// Get the handle to the IODLL
  	hDllInst = LoadLibrary("iodll.dll");

	// Get the pointer to the function
	if (!hDllInst)
		return ERROR_DLL_LOAD;

	if (!fileIn.Open(lpszSrcFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
	
		uiError = GenerateFile(lpszTgtFilename,
							hResFileModule,
							lpBuffer,
							uiSize,
							hDllInst
							);

		FreeLibrary(hDllInst);
		return uiError;
	}

	if (!fileOut.Open(lpszTgtFilename, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
		return ERROR_FILE_CREATE;

	DWORD (FAR PASCAL * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
	// Get the pointer to the function to extract the resources image
	lpfnGetImage = (DWORD (FAR PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
						GetProcAddress( hDllInst, "RSGetResImage" );
	if (lpfnGetImage==NULL) {
		FreeLibrary(hDllInst);
		return ERROR_DLL_PROC_ADDRESS;
	}

	// We read the resources from the file and then we check if the resource has been updated
	// or if we can just copy it

	WORD wTypeId;
	char szTypeId[128];

	WORD wNameId;
	char szNameId[128];

	WORD wFlags;
	WORD wLang;
	DWORD dwDataVersion;
	DWORD dwVersion;
	DWORD dwCharact;

	DWORD dwSize;
	DWORD dwFileOffset;

	WORD wUpdTypeId = 0;
	static char szUpdTypeId[128];

	WORD wUpdNameId;
	static char szUpdNameId[128];

	DWORD dwUpdLang;
	DWORD dwUpdSize;



	UINT uiBufStartSize = uiBufSize;
	DWORD dwImageBufSize;
	BYTE far * lpImageBuf;
	DWORD filelen = fileIn.GetLength();
	DWORD dwHeadSize = 0l;
	static BYTE buf[32];
	DWORD pad = 0l;

	// The first resource should be: Null. Skipp it
	fileIn.Read( &buf, 32 );
	fileOut.Write( &buf, 32 );

	while(filelen-fileIn.GetPosition()>0) {
		GetResInfo( &fileIn,
					&wTypeId, &szTypeId[0], 128,
					&wNameId, &szNameId[0], 128,
					&dwDataVersion,
					&wFlags, &wLang,
					&dwVersion, &dwCharact,
					&dwSize, &dwFileOffset, filelen
					);

		if ((!wUpdTypeId) && (uiBufSize))
			GetUpdatedRes( &lpBuffer,
					(LONG*)&uiBufSize,
					&wUpdTypeId, &szUpdTypeId[0],
					&wUpdNameId, &szUpdNameId[0],
					&dwUpdLang,
					&dwUpdSize
					);
		if ( (wUpdTypeId==wTypeId) &&
			 ( (CString)szUpdTypeId==(CString)szTypeId) &&
			 (wUpdNameId==wNameId) &&
			 ( (CString)szUpdNameId==(CString)szNameId)
			 ) {
			// The resource has been updated get the image from the IODLL
			lpImageBuf = new BYTE[dwUpdSize];
			LPSTR	lpType = LPNULL;
			LPSTR	lpRes = LPNULL;
			if (wUpdTypeId) {
				lpType = (LPSTR)((WORD)wUpdTypeId);
			} else {
				lpType = &szUpdTypeId[0];
			}
			if (wUpdNameId) {
				lpRes = (LPSTR)((WORD)wUpdNameId);
			} else {
				lpRes = &szUpdNameId[0];
			}

			dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
											lpType,
											lpRes,
											dwUpdLang,
											lpImageBuf,
											dwUpdSize
						   					);
			if (dwImageBufSize>dwUpdSize ) {
				// The buffer is too small
				delete []lpImageBuf;
				lpImageBuf = new BYTE[dwImageBufSize];
				dwUpdSize = (*lpfnGetImage)(  hResFileModule,
												lpType,
												lpRes,
												dwUpdLang,
												lpImageBuf,
												dwImageBufSize
											   );
				if ((dwUpdSize-dwImageBufSize)!=0 ) {
					delete []lpImageBuf;
					lpImageBuf = LPNULL;
				}
			}

			wUpdTypeId = 0;

		} else {

			// The fileIn is now correctly positioned at next resource. Save posit.
			DWORD dwNextResFilePos = fileIn.GetPosition();

			// The resource hasn't been updated copy the image from the file
			if(!dwSize) {
				FreeLibrary(hDllInst);
				return ERROR_NEW_FAILED;
			}
			lpImageBuf = new BYTE[dwSize];
			if(!lpImageBuf) {
				FreeLibrary(hDllInst);
				return ERROR_NEW_FAILED;
			}
			if ( dwFileOffset!=(DWORD)fileIn.Seek( dwFileOffset, CFile::begin) ) {
				delete []lpImageBuf;
				FreeLibrary(hDllInst);
				return (DWORD)ERROR_FILE_INVALID_OFFSET;
			}
			if (dwSize>UINT_MAX) {
				// we have to read the image in different steps
				delete []lpImageBuf;
				FreeLibrary(hDllInst);
				return (DWORD)ERROR_RW_IMAGE_TOO_BIG;
			} else fileIn.Read( lpImageBuf, (UINT)dwSize);
			dwImageBufSize = dwSize;

			// This moves us past any pad bytes, to start of next resource.
			fileIn.Seek(dwNextResFilePos, CFile::begin);
		}

		dwHeadSize = WriteHeader(&fileOut,
					dwImageBufSize,
					wTypeId, &szTypeId[0],
					wNameId, &szNameId[0],
					dwDataVersion,
					wFlags, wLang,
					dwVersion, dwCharact );

		WriteImage( &fileOut,
					lpImageBuf, dwImageBufSize);

		BYTE bPad = (BYTE)Pad4((DWORD)dwHeadSize+dwImageBufSize);
		if(bPad)
			fileOut.Write( &pad, bPad );

		if (lpImageBuf) delete []lpImageBuf;
	}

	fileIn.Close();
	fileOut.Close();

	FreeLibrary(hDllInst);
	return uiError;
}

extern "C"
UINT
APIENTRY
RWUpdateImage(
	LPCSTR	lpszType,
	LPVOID	lpNewBuf,
	DWORD	dwNewSize,
	LPVOID	lpOldImage,
	DWORD	dwOldImageSize,
	LPVOID	lpNewImage,
	DWORD*	pdwNewImageSize
	)
{
	UINT uiError = ERROR_NO_ERROR;

	// The Type we can parse are only the standard ones
	switch ((UINT)LOWORD(lpszType)) {

		case 4:
			if (lpOldImage)
				uiError = UpdateMenu( lpNewBuf, dwNewSize,
									  lpOldImage, dwOldImageSize,
									  lpNewImage, pdwNewImageSize );
			else uiError = GenerateMenu( lpNewBuf, dwNewSize,
									  lpNewImage, pdwNewImageSize );
		break;
		
		case 5:
			if (lpOldImage)
				uiError = UpdateDialog( lpNewBuf, dwNewSize,
								  lpOldImage, dwOldImageSize,
								  lpNewImage, pdwNewImageSize );
			else uiError = GenerateDialog( lpNewBuf, dwNewSize,
									  lpNewImage, pdwNewImageSize );
		break;
        case 6:
            if (lpOldImage)
                uiError = UpdateString( lpNewBuf, dwNewSize,
                                    lpOldImage, dwOldImageSize,
                                    lpNewImage, pdwNewImageSize );
            else uiError = GenerateString( lpNewBuf, dwNewSize,
									  lpNewImage, pdwNewImageSize );
        break;

        case 9:
            if (lpOldImage)
                uiError = UpdateAccel( lpNewBuf, dwNewSize,
                                   lpOldImage, dwOldImageSize,
                                   lpNewImage, pdwNewImageSize );
        break;

        case 11:
            if (lpOldImage)
                uiError = UpdateMsgTbl( lpNewBuf, dwNewSize,
                                  lpOldImage, dwOldImageSize,
                                  lpNewImage, pdwNewImageSize );
        break;

        case 16:
            if (lpOldImage)
                uiError = UpdateVerst( lpNewBuf, dwNewSize,
                                   lpOldImage, dwOldImageSize,
                                   lpNewImage, pdwNewImageSize );
        break;

		default:
			*pdwNewImageSize = 0L;
			uiError = ERROR_RW_NOTREADY;
		break;
	}

	return uiError;
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation

static UINT GenerateFile( LPCSTR		lpszTgtFilename,
						  HANDLE		hResFileModule,
						  LPVOID		lpBuffer,
						  UINT		uiSize,
						  HINSTANCE   hDllInst
						)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = LPNULL;
	UINT uiBufSize = uiSize;
	// we can consider the use of a CMemFile so we get the same speed as memory access.
	CFile fileOut;

	if (!fileOut.Open(lpszTgtFilename, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
		return ERROR_FILE_CREATE;

	// Get the pointer to the function
	if (!hDllInst)
		return ERROR_DLL_LOAD;

	DWORD (FAR PASCAL * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
	// Get the pointer to the function to extract the resources image
	lpfnGetImage = (DWORD (FAR PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
						GetProcAddress( hDllInst, "RSGetResImage" );
	if (lpfnGetImage==NULL) {
		return ERROR_DLL_PROC_ADDRESS;
	}


	WORD wUpdTypeId = 0;
	static char szUpdTypeId[128];

	WORD wUpdNameId;
	static char szUpdNameId[128];

	DWORD dwUpdLang;
	DWORD dwUpdSize;

	UINT uiBufStartSize = uiBufSize;
	DWORD dwImageBufSize;
	BYTE far * lpImageBuf;

	// First write the NULL resource to make it different from res16
	static BYTE bNullHeader[32] = {0,0,0,0,0x20,0,0,0,0xFF,0xFF,0,0,0xFF,0xFF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

	fileOut.Write(bNullHeader, 32);

	while(uiBufSize>0) {
		if ((!wUpdTypeId) && (uiBufSize))
			GetUpdatedRes( &lpBuffer,
					(LONG*)&uiBufSize,
					&wUpdTypeId, &szUpdTypeId[0],
					&wUpdNameId, &szUpdNameId[0],
					&dwUpdLang,
					&dwUpdSize
					);
					
		// The resource has been updated get the image from the IODLL
		if (dwUpdSize){
			lpImageBuf = new BYTE[dwUpdSize];
			LPSTR	lpType = LPNULL;
			LPSTR	lpRes = LPNULL;
			if (wUpdTypeId) {
				lpType = (LPSTR)((WORD)wUpdTypeId);
			} else {
				lpType = &szUpdTypeId[0];
			}
			if (wUpdNameId) {
				lpRes = (LPSTR)((WORD)wUpdNameId);
			} else {
				lpRes = &szUpdNameId[0];
			}
	
			dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
											lpType,
											lpRes,
											dwUpdLang,
											lpImageBuf,
											dwUpdSize
						   					);
			if (dwImageBufSize>dwUpdSize ) {
				// The buffer is too small			
				delete []lpImageBuf;
				lpImageBuf = new BYTE[dwImageBufSize];
				dwUpdSize = (*lpfnGetImage)(  hResFileModule,
												lpType,
												lpRes,
												dwUpdLang,
												lpImageBuf,
												dwImageBufSize
											   );
				if ((dwUpdSize-dwImageBufSize)!=0 ) {
					delete []lpImageBuf;
					lpImageBuf = LPNULL;
				}
			}
				
				
			WriteHeader(&fileOut,
						dwImageBufSize,
						wUpdTypeId, &szUpdTypeId[0],
						wUpdNameId, &szUpdNameId[0],
						0l, 0, 0, 0l, 0l );
			
			WriteImage( &fileOut,
						lpImageBuf, dwImageBufSize);
						
			if (lpImageBuf) delete []lpImageBuf;
			wUpdTypeId = 0;
			
		} else wUpdTypeId = 0;
		
	}
	
	fileOut.Close();
	
	return uiError;
}

static UINT GetUpdatedRes(
				 LPVOID far * lplpBuffer,
				 LONG* lSize,
				 WORD* wTypeId, LPSTR lpszTypeId,
				 WORD* wNameId, LPSTR lpszNameId,
				 DWORD* dwLang, DWORD* dwSize )
{
    BYTE** lplpBuf = (BYTE**)lplpBuffer;

    UINT uiSize = GetWord( lplpBuf, wTypeId, lSize );
    uiSize += GetStringA( lplpBuf, lpszTypeId, lSize );
    uiSize += Allign( lplpBuf, lSize, (LONG)uiSize);

    uiSize += GetWord( lplpBuf, wNameId, lSize );
    uiSize += GetStringA( lplpBuf, lpszNameId, lSize );
    uiSize += Allign( lplpBuf, lSize, (LONG)uiSize);

    uiSize += GetDWord( lplpBuf, dwLang, lSize );
    uiSize += GetDWord( lplpBuf, dwSize, lSize );

    return uiSize;
}	

static UINT
GetResInfo( CFile* pfile,
			WORD* pwTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
			WORD* pwNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
			DWORD* pdwDataVersion,
			WORD* pwFlags, WORD* pwLang,
			DWORD* pdwVersion, DWORD* pdwCharact,
		 	DWORD* pdwSize, DWORD* pdwFileOffset,
		 	DWORD dwFileSize )
{
	static UINT uiSize;
	static LONG lOfsCheck;
	static DWORD dwSkip;
	static DWORD dwHeadSize;
	//Get the data size
	pfile->Read( pdwSize, 4 );
	if (*pdwSize==0)
		// size id 0 the resource file is corrupted or is not a res file
		return FALSE;
	
	//Get the Header size
	pfile->Read( &dwHeadSize, 4 );
	if (dwHeadSize<32)
		// should never be smaller than 32
		return FALSE;
	
	// get the Type info
	uiSize = GetNameOrOrdFile( pfile, pwTypeId, lpszTypeId, bMaxTypeLen);
	if (!uiSize)
		return FALSE;
		
	// get the Name info
	uiSize = GetNameOrOrdFile( pfile, pwNameId, lpszNameId, bMaxNameLen);
    if (!uiSize)
		return FALSE;
	
	// Skip the Data Version
	pfile->Read( pdwDataVersion, 4 );
	
	// Get the Flags
	pfile->Read( pwFlags, 2 );
	
	// Get the language ID
	pfile->Read( pwLang, 2 );
		
	// Skip the version and the characteristics
	pfile->Read( pdwVersion, 4 );	
	pfile->Read( pdwCharact, 4 );
	
	*pdwFileOffset = pfile->GetPosition();
	
	// calculate if padding nedeed
	BYTE bPad = (BYTE)Pad4((DWORD)((*pdwSize)+dwHeadSize));
	if(bPad)
		pfile->Seek( bPad, CFile::current );
	
	if (*pdwFileOffset>dwFileSize)
		return FALSE;
	// check if the size is valid
	TRY {
		lOfsCheck = pfile->Seek(*pdwSize, CFile::current);
	} CATCH(CFileException, e) {
		// Check is the right exception
		return FALSE;
	} END_CATCH
	if (lOfsCheck!=(LONG)(*pdwFileOffset+*pdwSize+bPad))
			return FALSE;
			
	return TRUE;
}

static UINT WriteHeader(
				 CFile* pFile,
				 DWORD dwSize,
				 WORD wTypeId, LPSTR lpszTypeId,
				 WORD wNameId, LPSTR lpszNameId,
				 DWORD dwDataVersion,
				 WORD wFlags, WORD wLang,
				 DWORD dwVersion, DWORD dwCharact )
{
	UINT uiError = ERROR_NO_ERROR;
	static WCHAR szwName[128];
	static WORD wFF = 0xFFFF;
	DWORD dwHeadSize = 0l;
	static DWORD Pad = 0L;
	
	
	DWORD dwOffset = pFile->GetPosition();
	pFile->Write( &dwSize, 4 );
	// we will have to fix up laxter the size of the resource
	pFile->Write( &dwHeadSize, 4 );
	
	if(wTypeId) {
		// It is an ordinal
		pFile->Write( &wFF, 2 );
		pFile->Write( &wTypeId, 2 );
		dwHeadSize += 4;
	} else {
		WORD wLen = (WORD)((_MBSTOWCS( szwName, lpszTypeId, strlen(lpszTypeId)+1))*sizeof(WORD));
		pFile->Write( szwName, wLen );
		BYTE bPad = (BYTE)Pad4(wLen);
		if(bPad)
			pFile->Write( &Pad, bPad ); 	
		dwHeadSize += wLen+bPad;
	}
	
	if(wNameId) {
		// It is an ordinal
		pFile->Write( &wFF, 2 );
		pFile->Write( &wNameId, 2 );
		dwHeadSize += 4;
	} else {
		WORD wLen = (WORD)((_MBSTOWCS( szwName, lpszNameId, strlen(lpszNameId)+1))*sizeof(WORD));
		pFile->Write( szwName, wLen );
		BYTE bPad = (BYTE)Pad4(wLen);
		if(bPad)
			pFile->Write( &Pad, bPad ); 	
		dwHeadSize += wLen+bPad;
	}
	
	pFile->Write( &dwDataVersion, 4 );
	pFile->Write( &wFlags, 2 );
	pFile->Write( &wLang, 2 );
	pFile->Write( &dwVersion, 4 );
	pFile->Write( &dwCharact, 4 );
	
	dwHeadSize += 24;
	
	// write the size of the resource
	pFile->Seek( dwOffset+4, CFile::begin );
	pFile->Write( &dwHeadSize, 4 );
	pFile->Seek( dwOffset+dwHeadSize, CFile::begin );	
	return (UINT)dwHeadSize;
}				

static DWORD dwZeroPad = 0x00000000;				
static UINT WriteImage(
				 CFile* pFile,
				 LPVOID lpImage, DWORD dwSize )
{
	UINT uiError = ERROR_NO_ERROR;
	if(lpImage)
    {
		pFile->Write( lpImage, (UINT)dwSize );

        // check if we need to have the image alligned
        if(Pad4(dwSize))
            pFile->Write( &dwZeroPad, Pad4(dwSize) );
    }
	
	return uiError;
}

static UINT GetNameOrOrdFile( CFile* pfile, WORD* pwId, LPSTR lpszId, BYTE bMaxStrLen )
{
	UINT uiSize = 0;
	
	*pwId = 0;
	
	// read the first WORD to see if it is a string or an ordinal
	pfile->Read( pwId, sizeof(WORD) );	
	if(*pwId==0xFFFF) {
		// This is an Ordinal
		pfile->Read( pwId, sizeof(WORD) );	
		*lpszId = '\0';
		uiSize = 2;
	} else {
        uiSize++;
	    _WCSTOMBS( lpszId, (PWSTR)pwId, 3);
	    while((*lpszId++) && (bMaxStrLen-2)) {
	    	pfile->Read( pwId, sizeof(WORD) );	
	    	_WCSTOMBS( lpszId, (PWSTR)pwId, 3);
	        uiSize++;
	    	bMaxStrLen--;
	    }
	    if ( (!(bMaxStrLen-2)) && (*pwId) ) {
	    	// Failed
	    	return 0;
	    }
	    // Check padding
		BYTE bPad = Pad4((UINT)(uiSize*sizeof(WORD)));
		if(bPad)
			pfile->Read( pwId, sizeof(WORD) );	
	}
	
	return uiSize;
}   	

////////////////////////////////////////////////////////////////////////////////
// Helper
////////////////////////////////////////////////////////////////////////////////
static char szCaption[MAXSTR];

static UINT GenerateMenu( LPVOID lpNewBuf, LONG dwNewSize,
						  LPVOID lpNewI, DWORD* pdwNewImageSize )
{
	UINT uiError = ERROR_NO_ERROR;
	
	BYTE far * lpNewImage = (BYTE far *) lpNewI;
	LONG dwNewImageSize = *pdwNewImageSize;
	
	BYTE far * lpBuf = (BYTE far *) lpNewBuf;	
	
	LPRESITEM lpResItem = LPNULL;
	
	// We have to read the information from the lpNewBuf
	// Updated items
	WORD wUpdPos = 0;
	WORD fUpdItemFlags;
	WORD wUpdMenuId;
	char szUpdTxt[256];
	
	LONG  dwOverAllSize = 0l;
	
	// invent the menu flags
	dwOverAllSize += PutDWord( &lpNewImage, 0L, &dwNewImageSize);
	
	while(dwNewSize>0) {
		if (dwNewSize ) {
			lpResItem = (LPRESITEM) lpBuf;
			
			wUpdMenuId = LOWORD(lpResItem->dwItemID);
			fUpdItemFlags = (WORD)lpResItem->dwFlags;
			strcpy( szUpdTxt, lpResItem->lpszCaption );
			lpBuf += lpResItem->dwSize;
			dwNewSize -= lpResItem->dwSize;
		}
		
		dwOverAllSize += PutWord( &lpNewImage, fUpdItemFlags, &dwNewImageSize);
		
		if ( !(fUpdItemFlags & MF_POPUP) )
			dwOverAllSize += PutWord( &lpNewImage, wUpdMenuId, &dwNewImageSize);
		
		// Write the text
		// check if it is a separator
		if ( !(fUpdItemFlags) && !(wUpdMenuId) )
			szUpdTxt[0] = 0x00;	
		dwOverAllSize += PutStringW( &lpNewImage, &szUpdTxt[0], &dwNewImageSize);
		
	}
	
	if (dwOverAllSize>(LONG)*pdwNewImageSize) {
		// calc the padding as well
		dwOverAllSize += (BYTE)Pad16((DWORD)(dwOverAllSize));
		*pdwNewImageSize = dwOverAllSize;
		return uiError;
	}
		
	*pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;
	
	if(*pdwNewImageSize>0) {
		// calculate padding
		BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
		if (bPad>dwNewImageSize) {
			*pdwNewImageSize += bPad;
			return uiError;
		}
		memset(lpNewImage, 0x00, bPad);
		*pdwNewImageSize += bPad;
	}
	
	return uiError;
}



static
UINT
GenerateString( LPVOID lpNewBuf, LONG dwNewSize,
			LPVOID lpNewI, DWORD* pdwNewImageSize )
{
	UINT uiError = ERROR_NO_ERROR;
	
	LONG dwNewImageSize = *pdwNewImageSize;
	BYTE far * lpNewImage = (BYTE far *) lpNewI;
	
	BYTE far * lpBuf = (BYTE far *) lpNewBuf;	
	LPRESITEM lpResItem = LPNULL;
	
	// We have to read the information from the lpNewBuf
	WORD wLen;
	WORD wPos = 0;
	
	LONG dwOverAllSize = 0l;
	
	while(dwNewSize>0) {
		if ( dwNewSize ) {
			lpResItem = (LPRESITEM) lpBuf;
				 			
			strcpy( szCaption, lpResItem->lpszCaption );
			lpBuf += lpResItem->dwSize;
			dwNewSize -= lpResItem->dwSize;
		}
		
		wLen = strlen(szCaption);

        // Write the text
        dwOverAllSize += PutPascalStringW( &lpNewImage, &szCaption[0], wLen, &dwNewImageSize );
	}
	
	if (dwOverAllSize>(LONG)*pdwNewImageSize) {
		// calc the padding as well
		dwOverAllSize += (BYTE)Pad16((DWORD)(dwOverAllSize));
		*pdwNewImageSize = dwOverAllSize;
		return uiError;
	}
	
	*pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;
	
	if(*pdwNewImageSize>0) {
		// calculate padding
		BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
		if (bPad>dwNewImageSize) {
			*pdwNewImageSize += bPad;
			return uiError;
		}
		memset(lpNewImage, 0x00, bPad);
		*pdwNewImageSize += bPad;
	}
	
	return uiError;
}

static
UINT
GenerateDialog( LPVOID lpNewBuf, LONG dwNewSize,
			    LPVOID lpNewI, DWORD* pdwNewImageSize )
{
	// Should be almost impossible for a Dialog to be Huge
	UINT uiError = ERROR_NO_ERROR;
	
	BYTE far * lpNewImage = (BYTE far *) lpNewI;
	LONG dwNewImageSize = *pdwNewImageSize;
	
	BYTE far * lpBuf = (BYTE far *) lpNewBuf;	
	LPRESITEM lpResItem = LPNULL;
	
	LONG dwOverAllSize = 0L;
	
	BYTE	bIdCount = 0;
	
	// Dialog Elements
    DWORD 	dwStyle = 0L;
	DWORD 	dwExtStyle = 0L;
	WORD    wNumOfElem = 0;
	WORD	wX = 0;
	WORD	wY = 0;
	WORD	wcX = 0;
	WORD	wcY = 0;
	WORD	wId = 0;
	char	szClassName[128];
	WORD	wClassName;
	//char	szCaption[128];
	WORD	wPointSize = 0;
	char	szFaceName[128];
	WORD	wPos = 1;
	
	// Get the infrmation from the updated resource
	if ( dwNewSize ) {
		lpResItem = (LPRESITEM) lpBuf;
		wX = lpResItem->wX;
		wY = lpResItem->wY;
		wcX = lpResItem->wcX;
		wcY = lpResItem->wcY;
		wId = LOWORD(lpResItem->dwItemID);
		wPointSize = lpResItem->wPointSize;
		dwStyle = lpResItem->dwStyle;
		dwExtStyle = lpResItem->dwExtStyle;
		wClassName = lpResItem->wClassName;
		strcpy( szCaption, lpResItem->lpszCaption );
		strcpy( szClassName, lpResItem->lpszClassName );
		strcpy( szFaceName, lpResItem->lpszFaceName );
		if (*szFaceName != '\0')
		{
			dwStyle |= DS_SETFONT;
		}
		lpBuf += lpResItem->dwSize;
		dwNewSize -= lpResItem->dwSize;
	}
	
	DWORD dwPadCalc = dwOverAllSize;
	// Header info
	dwOverAllSize = PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
	dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
	
    // Store the position of the numofelem for a later fixup
	BYTE far * lpNumOfElem = lpNewImage;
    LONG lSizeOfNum = sizeof(WORD);
	dwOverAllSize += PutWord( &lpNewImage, wNumOfElem, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
    dwOverAllSize += PutNameOrOrd( &lpNewImage, 0, "", &dwNewImageSize );
    dwOverAllSize += PutClassName( &lpNewImage, wClassName, &szClassName[0], &dwNewImageSize );
    dwOverAllSize += PutCaptionOrOrd( &lpNewImage, 0, &szCaption[0], &dwNewImageSize,
    	wClassName, dwStyle );
    if( dwStyle & DS_SETFONT ) {
    	dwOverAllSize += PutWord( &lpNewImage, wPointSize, &dwNewImageSize );
        dwOverAllSize += PutStringW( &lpNewImage, &szFaceName[0], &dwNewImageSize );
    }

    // Check if padding is needed
    BYTE bPad = (BYTE)Pad4((WORD)(dwOverAllSize-dwPadCalc));
    if (bPad) {
        if( (bPad)<=dwNewImageSize )
            memset( lpNewImage, 0x00, bPad );
        dwNewImageSize -= (bPad);
        dwOverAllSize += (bPad);
        lpNewImage += (bPad);
    }

	while( dwNewSize>0 ) {
		wNumOfElem++;
	
	    if ( dwNewSize ) {
	    	TRACE1("\t\tGenerateDialog:\tdwNewSize=%ld\n",(LONG)dwNewSize);
			TRACE1("\t\t\t\tlpszCaption=%Fs\n",lpResItem->lpszCaption);

			lpResItem = (LPRESITEM) lpBuf;
			wX = lpResItem->wX;
			wY = lpResItem->wY;
			wcX = lpResItem->wcX;
			wcY = lpResItem->wcY;
			wId = LOWORD(lpResItem->dwItemID);
			dwStyle = lpResItem->dwStyle;
			dwExtStyle = lpResItem->dwExtStyle;
			wClassName = LOBYTE(lpResItem->wClassName);
			strcpy( szCaption, lpResItem->lpszCaption );
			strcpy( szClassName, lpResItem->lpszClassName );
			lpBuf += lpResItem->dwSize;
			dwNewSize -= lpResItem->dwSize;
		}		 	
				
        dwPadCalc = dwOverAllSize;
        //write the control
       	dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
       	dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );

        dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize );
        dwOverAllSize += PutClassName( &lpNewImage, wClassName, &szClassName[0], &dwNewImageSize );
        dwOverAllSize += PutCaptionOrOrd( &lpNewImage, 0, &szCaption[0], &dwNewImageSize,
        	wClassName, dwStyle );
        dwOverAllSize += PutWord( &lpNewImage, 0, &dwNewImageSize );

        // Check if padding is needed
        bPad = (BYTE)Pad4((WORD)(dwOverAllSize-dwPadCalc));
        if (bPad) {
            if( (bPad)<=dwNewImageSize )
                memset( lpNewImage, 0x00, bPad );
            dwNewImageSize -= (bPad);
            dwOverAllSize += (bPad);
            lpNewImage += (bPad);
        }

	}
	
	if (dwOverAllSize>(LONG)*pdwNewImageSize) {
		// calc the padding as well
		dwOverAllSize += (BYTE)Pad16((DWORD)(dwOverAllSize));
		*pdwNewImageSize = dwOverAllSize;
		return uiError;
	}
		
	*pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;
	
	if(*pdwNewImageSize>0) {
		// calculate padding
		BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
		if (bPad>dwNewImageSize) {
			*pdwNewImageSize += bPad;
			return uiError;
		}
		memset(lpNewImage, 0x00, bPad);
		*pdwNewImageSize += bPad;
	}
	
	// fixup the number of items
	PutWord( &lpNumOfElem, wNumOfElem, &lSizeOfNum );
	
	return uiError;
}						

////////////////////////////////////////////////////////////////////////////
// DLL Specific helpers
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation
////////////////////////////////////////////////////////////////////////////
// Library init

////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory
		// here, use the TRACE or ASSERT macros or call MessageBox
		AfxInitExtensionModule(extensionDLL, hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxWinTerm();
	}

	if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
		return 0;		// CRT term	Failed

	return 1;   // ok
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\win32\checkfix.cpp ===
#include <afxwin.h>

#include "imagehlp.h"
#include "iodll.h"

//... PROTOTYPES

static PIMAGE_NT_HEADERS MyRtlImageNtHeader(
    PVOID pBaseAddress);

static BOOL MyUpdateDebugInfoFileEx(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS NtHeaders,
    DWORD OldCheckSum
    );

//...........................................................................


DWORD QuitA( DWORD err, LPCSTR, LPSTR )
{
    return err;
}

DWORD FixCheckSum( LPCSTR ImageName, LPCSTR OrigFileName, LPCSTR SymbolPath)
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;
    ULONG CheckSum;
    ULONG FileLength;
    ULONG HeaderSum;
    ULONG OldCheckSum;
    DWORD iErr = ERROR_NO_ERROR;


    FileHandle = CreateFileA( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);

    if ( FileHandle == INVALID_HANDLE_VALUE )
    {
        QuitA( 1, ImageName, NULL);
    }

    MappingHandle = CreateFileMapping( FileHandle,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       0,
                                       NULL);

    if ( MappingHandle == NULL )
    {
        CloseHandle( FileHandle );
        QuitA( 22, ImageName, NULL);
    }
    else
    {
        BaseAddress = MapViewOfFile( MappingHandle,
                                     FILE_MAP_READ | FILE_MAP_WRITE,
                                     0,
                                     0,
                                     0);
        CloseHandle( MappingHandle );

        if ( BaseAddress == NULL )
        {
            CloseHandle( FileHandle );
            QuitA( 23, ImageName, NULL);
        }
        else
        {
            //
            // Get the length of the file in bytes and compute the checksum.
            //

            FileLength = GetFileSize( FileHandle, NULL );

            //
            // Obtain a pointer to the header information.
            //

            NtHeaders = MyRtlImageNtHeader( BaseAddress);

            if ( NtHeaders == NULL )
            {
                CloseHandle( FileHandle );
                UnmapViewOfFile( BaseAddress );
                QuitA( 17, ImageName, NULL);
            }
            else
            {
                //
                // Recompute and reset the checksum of the modified file.
                //

                OldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                (VOID) CheckSumMappedFile( BaseAddress,
                                           FileLength,
                                           &HeaderSum,
                                           &CheckSum);

                NtHeaders->OptionalHeader.CheckSum = CheckSum;

                if (SymbolPath && *SymbolPath)
                {
                    TCHAR DebugFilePath[MAX_PATH];

                    SetLastError(0);
                    MyUpdateDebugInfoFileEx((LPSTR)OrigFileName,
                                                (LPSTR)SymbolPath,
                                                DebugFilePath,
                                                NtHeaders,
                                                OldCheckSum);

                        iErr = GetLastError();
                        switch(iErr)
                        {
                            case ERROR_INVALID_DATA:
                                iErr = ERROR_IO_CHECKSUM_MISMATCH;
                                break;
                            case ERROR_FILE_NOT_FOUND:
                                iErr = ERROR_IO_SYMBOLFILE_NOT_FOUND;
                                break;
                            case ERROR_NO_ERROR:
                                break;
                            default:
                                iErr += LAST_ERROR;
                        }

                }

                if ( ! FlushViewOfFile( BaseAddress, FileLength) )
                {
                    QuitA( 24, ImageName, NULL);
                }

                if ( NtHeaders->OptionalHeader.CheckSum != OldCheckSum )
                {
                    if ( ! TouchFileTimes( FileHandle, NULL) )
                    {
                        QuitA( 25, ImageName, NULL);
                    }
                }
                UnmapViewOfFile( BaseAddress );
                CloseHandle( FileHandle );
            }
        }
    }
    return( iErr);
}

//.........................................................................

static PIMAGE_NT_HEADERS MyRtlImageNtHeader( PVOID pBaseAddress)
{
    IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER *)pBaseAddress;

    return( pDosHeader->e_magic == IMAGE_DOS_SIGNATURE
            ? (PIMAGE_NT_HEADERS)(((PBYTE)pBaseAddress) + pDosHeader->e_lfanew)
            : NULL);
}

BOOL
MyUpdateDebugInfoFileEx(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS NtHeaders,
    DWORD OldCheckSum
    )
{
    // UnSafe...

    HANDLE hDebugFile, hMappedFile;
    PVOID MappedAddress;
    PIMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;
    BOOL bRet;

    hDebugFile = FindDebugInfoFile(
                    ImageFileName,
                    SymbolPath,
                    DebugFilePath
                    );
    if ( hDebugFile == NULL ) {
        return FALSE;
    }
    CloseHandle(hDebugFile);

    hDebugFile = CreateFile( DebugFilePath,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_DELETE | FILE_SHARE_READ
                                | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );
    if ( hDebugFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    hMappedFile = CreateFileMapping(
                    hDebugFile,
                    NULL,
                    PAGE_READWRITE,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    MappedAddress = MapViewOfFile(hMappedFile,
                        FILE_MAP_WRITE,
                        0,
                        0,
                        0
                        );
    CloseHandle(hMappedFile);
    if ( !MappedAddress ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    DbgFileHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)MappedAddress;
    if (DbgFileHeader->ImageBase != NtHeaders->OptionalHeader.ImageBase ||
        DbgFileHeader->CheckSum != NtHeaders->OptionalHeader.CheckSum
       ) {
        if (OldCheckSum != DbgFileHeader->CheckSum) {
            DbgFileHeader->Flags |= IMAGE_SEPARATE_DEBUG_MISMATCH;
            SetLastError(ERROR_INVALID_DATA);
        } else {
            SetLastError(ERROR_SUCCESS);
        }
        DbgFileHeader->ImageBase = (DWORD) NtHeaders->OptionalHeader.ImageBase;
        DbgFileHeader->CheckSum = NtHeaders->OptionalHeader.CheckSum;
        DbgFileHeader->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
        bRet = TRUE;
    }
    else
    {
        bRet =  FALSE;
    }

    if (bRet)
        TouchFileTimes(hDebugFile,NULL);

    UnmapViewOfFile(MappedAddress);
    CloseHandle(hDebugFile);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\checkfix.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "imagehlp.h"
#include "restok.h"

//... PROTOTYPES

USHORT ChkSum(

    DWORD   PartialSum,
    PUSHORT Source,
    DWORD   Length);

static PIMAGE_NT_HEADERS MyRtlImageNtHeader(

    PVOID pBaseAddress);



//...........................................................................

DWORD FixCheckSum( LPSTR ImageName)
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;


    FileHandle = CreateFileA( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);

    if ( FileHandle == INVALID_HANDLE_VALUE )
    {
        QuitA( IDS_ENGERR_01, "image", ImageName);
    }

    MappingHandle = CreateFileMapping( FileHandle,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       0,
                                       NULL);

    if ( MappingHandle == NULL )
    {
        CloseHandle( FileHandle );
        QuitA( IDS_ENGERR_22, ImageName, NULL);
    }
    else
    {
        BaseAddress = MapViewOfFile( MappingHandle,
                                     FILE_MAP_READ | FILE_MAP_WRITE,
                                     0,
                                     0,
                                     0);
        CloseHandle( MappingHandle );

        if ( BaseAddress == NULL )
        {
            CloseHandle( FileHandle );
            QuitA( IDS_ENGERR_23, ImageName, NULL);
        }
        else
        {
		    DWORD dwFileLength = 0;

            //
            // Get the length of the file in bytes and compute the checksum.
            //

            dwFileLength = GetFileSize( FileHandle, NULL );

            //
            // Obtain a pointer to the header information.
            //

            NtHeaders = MyRtlImageNtHeader( BaseAddress);

            if ( NtHeaders == NULL )
            {
                CloseHandle( FileHandle );
                UnmapViewOfFile( BaseAddress );
                QuitA( IDS_ENGERR_17, ImageName, NULL);
            }
            else
            {
      			DWORD dwHeaderSum   = 0;
			    DWORD dwCheckSum    = 0;
			    DWORD dwOldCheckSum = 0;
                //
                // Recompute and reset the checksum of the modified file.
                //

                dwOldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                (VOID) MapFileAndCheckSumA( ImageName,
                                            &dwHeaderSum,
                                            &dwCheckSum);

                NtHeaders->OptionalHeader.CheckSum = dwCheckSum;

                if ( ! FlushViewOfFile( BaseAddress, dwFileLength) )
                {
                    QuitA( IDS_ENGERR_24, ImageName, NULL);
                }

                if ( NtHeaders->OptionalHeader.CheckSum != dwOldCheckSum )
                {
                    if ( ! TouchFileTimes( FileHandle, NULL) )
                    {
                        QuitA( IDS_ENGERR_25, ImageName, NULL);
                    }
                }
                UnmapViewOfFile( BaseAddress );
                CloseHandle( FileHandle );
            }
        }
    }
    return( 0);
}

//.........................................................................

static PIMAGE_NT_HEADERS MyRtlImageNtHeader( PVOID pBaseAddress)
{
    IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER *)pBaseAddress;

    return( pDosHeader->e_magic == IMAGE_DOS_SIGNATURE
            ? (PIMAGE_NT_HEADERS)(((PBYTE)pBaseAddress) + pDosHeader->e_lfanew)
            : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\win16\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

#ifdef NEVER
    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
#else
    unsigned char	ne_exetyp;	/* Target Operating system */
    unsigned char	ne_flagsothers;	/* Other .EXE flags */
#endif
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)	(x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004	/* True if handler proc return handle */

#define RNCOMPR     0x0200	/* Resource is compressed in ROM */

/* Resource table */
struct new_rsrc
    {
    unsigned short int rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN	0	/* Unknown (any "new-format" OS) */
#define NE_OS2		1	/* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS	2	/* Microsoft Windows		 */
#define NE_DOS4 	3	/* Microsoft MS-DOS 4.x		 */
#define NE_DEV386	4	/* Microsoft Windows 386	 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\checksum.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checksum.c

Abstract:

    This module implements a function for computing the checksum of an
    image file. It will also compute the checksum of other files as well.

Author:

    David N. Cutler 21-Mar-1993

Revision History:

--*/

#include <windows.h>
#include "checksum.h"
#include "rlmsgtbl.h"

void QuitA( int, LPSTR,  LPSTR);
void QuitW( int, LPWSTR, LPWSTR);

// Helper routines

static PIMAGE_NT_HEADERS ImageNtHeader( PVOID Base);
static USHORT ChkSum( DWORD PartialSum,
    				  PUSHORT Source,
    				  DWORD Length);

static PIMAGE_NT_HEADERS
CheckSumMappedFile (
    LPVOID pBaseAddress,
    DWORD  dwFileLength,
    LPDWORD pdwHeaderSum,
    LPDWORD pdwCheckSum
    );

static BOOL
TouchFileTimes (
    HANDLE hFileHandle,
    LPSYSTEMTIME lpSystemTime
    );



/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

static PIMAGE_NT_HEADERS ImageNtHeader( PVOID pBase)
{
    PIMAGE_NT_HEADERS pNtHeaders = NULL;

    if ( pBase != NULL && pBase != (PVOID)-1 ) 
    {
        if ( ((PIMAGE_DOS_HEADER)pBase)->e_magic == IMAGE_DOS_SIGNATURE ) 
        {
            pNtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)pBase + ((PIMAGE_DOS_HEADER)pBase)->e_lfanew);

            if ( pNtHeaders->Signature != IMAGE_NT_SIGNATURE ) 
            {
                pNtHeaders = NULL;
            }
        }
    }
    return( pNtHeaders);
}


/*++

Routine Description:

    Compute a partial checksum on a portion of an imagefile.

Arguments:

    PartialSum - Supplies the initial checksum value.

    Sources - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

static USHORT ChkSum(

ULONG   PartialSum,
PUSHORT Source,
ULONG   Length)
{

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}


/*++

Routine Description:

    This functions computes the checksum of a mapped file.

Arguments:

    BaseAddress - Supplies a pointer to the base of the mapped file.

    FileLength - Supplies the length of the file in bytes.

    HeaderSum - Suppllies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    None.

--*/


static PIMAGE_NT_HEADERS CheckSumMappedFile(

LPVOID  pBaseAddress,
DWORD   dwFileLength,
LPDWORD pdwHeaderSum,
LPDWORD pdwCheckSum)
{
    USHORT  usPartialSum;
    PUSHORT pusAdjustSum;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;

    //
    // Compute the checksum of the file and zero the header checksum value.
    //

    *pdwHeaderSum = 0;
    usPartialSum = ChkSum(0, (PUSHORT)pBaseAddress, (dwFileLength + 1) >> 1);

    //
    // If the file is an image file, then subtract the two checksum words
    // in the optional header from the computed checksum before adding
    // the file length, and set the value of the header checksum.
    //

	pNtHeaders = ImageNtHeader( pBaseAddress);

    if ( (pNtHeaders != NULL) && (pNtHeaders != pBaseAddress) ) 
    {
        *pdwHeaderSum = pNtHeaders->OptionalHeader.CheckSum;
        pusAdjustSum  = (PUSHORT)(&pNtHeaders->OptionalHeader.CheckSum);
        usPartialSum -= (usPartialSum < pusAdjustSum[0]);
        usPartialSum -= pusAdjustSum[0];
        usPartialSum -= (usPartialSum < pusAdjustSum[1]);
        usPartialSum -= pusAdjustSum[1];
    }

    //
    // Compute the final checksum value as the sum of the paritial checksum
    // and the file length.
    //

    *pdwCheckSum = (DWORD)usPartialSum + dwFileLength;
    return( pNtHeaders);
}

/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/


DWORD MapFileAndFixCheckSumW( PWSTR pszwFilename)
{
    HANDLE hFileHandle    = NULL;
    HANDLE hMappingHandle = NULL;
    LPVOID pBaseAddress   = NULL;
    DWORD  dwFileLength   = 0;
	DWORD  dwHeaderSum    = 0;
	DWORD  dwCheckSum     = 0;
	DWORD  dwOldCheckSum  = 0;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;

    //
    // Open the file for read access
    //

    hFileHandle = CreateFileW( pszwFilename,
                         	   GENERIC_READ | GENERIC_WRITE,
                         	   FILE_SHARE_READ | FILE_SHARE_WRITE,
                         	   NULL,
                         	   OPEN_EXISTING,
                         	   FILE_ATTRIBUTE_NORMAL,
                        	   NULL);

    if ( hFileHandle == INVALID_HANDLE_VALUE ) 
    {
        QuitW( IDS_ENGERR_01, L"image", pszwFilename);
    }

    //
    //  Create a file mapping, map a view of the file into memory,
    //  and close the file mapping handle.
    //

    hMappingHandle = CreateFileMapping( hFileHandle,
                                        NULL,
                                        PAGE_READWRITE,
                                        0,
                                        0,
                                        NULL);

    if ( hMappingHandle == NULL ) 
    {
        CloseHandle( hFileHandle );
        QuitW( IDS_ENGERR_22, pszwFilename, NULL);
    }

    //
    // Map a view of the file
    //

    pBaseAddress = MapViewOfFile( hMappingHandle, 
                                  FILE_MAP_READ | FILE_MAP_WRITE, 
                                  0, 
                                  0, 
                                  0);
    CloseHandle( hMappingHandle);

    if ( pBaseAddress == NULL ) 
    {
        CloseHandle( hFileHandle );
        QuitW( IDS_ENGERR_23, pszwFilename, NULL);
    }

    //
    // Get the length of the file in bytes and compute the checksum.
    //
    dwFileLength = GetFileSize( hFileHandle, NULL );
    pNtHeaders   = CheckSumMappedFile( pBaseAddress, dwFileLength, &dwHeaderSum, &dwCheckSum);

    if ( pNtHeaders == NULL )
    {
        CloseHandle( hFileHandle );
        UnmapViewOfFile( pBaseAddress );
        QuitW( IDS_ENGERR_17, pszwFilename, NULL);
    }

    dwOldCheckSum = pNtHeaders->OptionalHeader.CheckSum;

    pNtHeaders->OptionalHeader.CheckSum = dwCheckSum;
        
    if ( ! FlushViewOfFile( pBaseAddress, dwFileLength) )
    {
        UnmapViewOfFile( pBaseAddress);
        CloseHandle( hFileHandle);
        QuitW( IDS_ENGERR_24, pszwFilename, NULL);
    }    
    UnmapViewOfFile( pBaseAddress);

    if ( dwCheckSum != dwOldCheckSum )
    {
        if ( ! TouchFileTimes( hFileHandle, NULL) )
        {
            CloseHandle( hFileHandle);
            QuitW( IDS_ENGERR_25, pszwFilename, NULL);
        }
    }

    CloseHandle( hFileHandle);
    return( 0);
}


/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/


ULONG MapFileAndFixCheckSumA( LPSTR pszFilename)
{
    WCHAR   szFileNameW[ MAX_PATH ];

    //
    //  Convert the file name to unicode and call the unicode version
    //  of this function.
    //

    if ( MultiByteToWideChar( CP_ACP,
                    		  MB_PRECOMPOSED,
                    		  pszFilename,
                    		  -1,
                    		  szFileNameW,
                    		  MAX_PATH) ) 
    {
        return( MapFileAndFixCheckSumW( szFileNameW));
    }
    return( (ULONG)-1L);
}

//.........................................

static BOOL TouchFileTimes(

HANDLE       FileHandle,
LPSYSTEMTIME lpSystemTime)
{
    SYSTEMTIME SystemTime;
    FILETIME SystemFileTime;

    if ( lpSystemTime == NULL ) 
    {
        lpSystemTime = &SystemTime;
        GetSystemTime( lpSystemTime );
    }

    if ( SystemTimeToFileTime( lpSystemTime, &SystemFileTime ) ) 
    {
        return( SetFileTime( FileHandle, NULL, NULL, &SystemFileTime ));
    }
    else 
    {
        return( FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\win32\win32.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       win32.cpp
//
//  Contents:   Implementation for the Windows 32 Read/Write module
//
//  Classes:    one
//
//  History:    05-Jul-93   alessanm    created
//
//----------------------------------------------------------------------------

#include <afxwin.h>
#include "..\common\rwdll.h"
#include "..\common\rw32hlpr.h"

#include <limits.h>
#include <malloc.h>

/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

/////////////////////////////////////////////////////////////////////////////
// Check sum function

DWORD FixCheckSum( LPCSTR ImageName, LPCSTR OrigFileName, LPCSTR SymbolPath );


/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define RWTAG "WIN32"

static RESSECTDATA ResSectData;
static ULONG gType;
static ULONG gLng;
static ULONG gResId;
static WCHAR gwszResId[256];
static WCHAR gwszTypeId[256];

/////////////////////////////////////////////////////////////////////////////
// Function Declarations
static LONG WriteResInfo(
                 LPLPBYTE lpBuf, LONG* uiBufSize,
                 WORD wTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
                 WORD wNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
                 DWORD dwLang,
                 DWORD dwSize, DWORD dwFileOffset );

static UINT GetUpdatedRes(
                 BYTE far * far* lplpBuffer,
                 UINT* uiSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwlang, DWORD* dwSize );

static UINT GetRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize, DWORD* dwFileOffset );


static UINT FindResourceSection( CFile*, ULONG_PTR * );

static LONG ReadFile(CFile*, UCHAR *, LONG);
static UINT ParseDirectory( CFile*,
                            LPLPBYTE lpBuf, UINT* uiBufSize,
                            BYTE,
                            PIMAGE_RESOURCE_DIRECTORY,
                            PIMAGE_RESOURCE_DIRECTORY );

static UINT ParseDirectoryEntry( CFile*,
                                 LPLPBYTE lpBuf, UINT* uiBufSize,
                                 BYTE,
                                 PIMAGE_RESOURCE_DIRECTORY,
                                 PIMAGE_RESOURCE_DIRECTORY_ENTRY );

static UINT ParseSubDir( CFile*,
                         LPLPBYTE lpBuf, UINT* uiBufSize,
                         BYTE,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY );

static UINT ProcessData( CFile*,
                         LPLPBYTE lpBuf, UINT* uiBufSize,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DATA_ENTRY );


/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

//[registration]
extern "C"
BOOL    FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
    strcpy( lpszTypeName, RWTAG );
    return FALSE;
}

extern "C"
BOOL    FAR PASCAL RWValidateFileType   (LPCSTR lpszFilename)
{
    TRACE("WIN32.DLL: RWValidateFileType()\n");

    CFile file;

    // we Open the file to see if it is a file we can handle
    if (!file.Open( lpszFilename, CFile::typeBinary | CFile::modeRead | CFile::shareDenyNone))
        return FALSE;

    // Read the file signature
    WORD w;
    file.Read((WORD*)&w, sizeof(WORD));
    if (w==IMAGE_DOS_SIGNATURE) {
    file.Seek( 0x18, CFile::begin );
    file.Read((WORD*)&w, sizeof(WORD));
    if (w<0x0040) {
        // this is not a Windows Executable
            file.Close();
        return FALSE;
    }
    // get offset to header
    file.Seek( 0x3c, CFile::begin );
    file.Read((WORD*)&w, sizeof(WORD));
    // get windows magic word
        file.Seek( w, CFile::begin );
    file.Read((WORD*)&w, sizeof(WORD));
    if (w==LOWORD(IMAGE_NT_SIGNATURE)) {
        file.Read((WORD*)&w, sizeof(WORD));
        if (w==HIWORD(IMAGE_NT_SIGNATURE)) {
            // this is a Windows NT Executable
        // we can handle the situation
        file.Close();
        return TRUE;
            }
    }
    }
    file.Close();
    return FALSE;
}

extern "C"
DllExport
UINT
APIENTRY
RWReadTypeInfo(
    LPCSTR lpszFilename,
    LPVOID lpBuffer,
    UINT* puiSize

    )
{
    TRACE("WIN32.DLL: RWReadTypeInfo()\n");
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    UINT uiBufSize = *puiSize;
    CFile file;
    // check if it is  a valid win32 file
    if (!RWValidateFileType(lpszFilename))
        return ERROR_RW_INVALID_FILE;

    // Make sure we are using the right code page and global settings
    // Get the pointer to the function
	HINSTANCE hDllInst = LoadLibrary("iodll.dll");
    if (hDllInst)
    {
        UINT (FAR PASCAL * lpfnGetSettings)(LPSETTINGS);
        // Get the pointer to the function to get the settings
        lpfnGetSettings = (UINT (FAR PASCAL *)(LPSETTINGS))
                            GetProcAddress( hDllInst, "RSGetGlobals" );
        if (lpfnGetSettings!=NULL) {
            SETTINGS settings;
	        (*lpfnGetSettings)(&settings);

    	    g_cp      = settings.cp;
            g_bAppend = settings.bAppend;
            g_bUpdOtherResLang = settings.bUpdOtherResLang;
            strcpy( g_char, settings.szDefChar );
		}

        FreeLibrary(hDllInst);
    }


    // Parse the resource tree and extract the information
    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return ERROR_FILE_OPEN;

    // we try to read as much information as we can
    // Because this is a res file we can read all the information we need.

    UINT uiBufStartSize = uiBufSize;


    UCHAR * pResources = LPNULL;
    uiError = FindResourceSection( &file, (ULONG_PTR *)&pResources );
    if (uiError) {
        file.Close();
        return uiError;
    }
    uiError = ParseDirectory( &file,
                              (LPLPBYTE) &lpBuffer, &uiBufSize,
                              0,
                              (PIMAGE_RESOURCE_DIRECTORY)pResources,
                              (PIMAGE_RESOURCE_DIRECTORY)pResources );

    free(pResources);

    file.Close();
    *puiSize = uiBufStartSize-uiBufSize;
    return uiError;
}

extern "C"
DllExport
DWORD
APIENTRY
RWGetImage(
    LPCSTR  lpszFilename,
    DWORD   dwImageOffset,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    DWORD dwBufSize = dwSize;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile file;

    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return (DWORD)ERROR_FILE_OPEN;

    if ( dwImageOffset!=(DWORD)file.Seek( dwImageOffset, CFile::begin) )
        return (DWORD)ERROR_FILE_INVALID_OFFSET;
    if (dwSize>UINT_MAX) {
        // we have to read the image in different steps
        return (DWORD)0L;
    } else uiError = file.Read( lpBuf, (UINT)dwSize);
    file.Close();

    return (DWORD)uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWParseImageEx(
	LPCSTR  lpszType,
    LPCSTR  lpszResId,
	LPVOID  lpImageBuf,
	DWORD   dwImageSize,
	LPVOID  lpBuffer,
	DWORD   dwSize,
    LPCSTR  lpRCFilename
	)
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    DWORD dwBufSize = dwSize;

    // The Type we can parse are only the standard ones
    // This function should fill the lpBuffer with an array of ResItem structure
    if (HIWORD(lpszType))
    {
        if (strcmp(lpszType, "REGINST") ==0)
        {
            return (ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize ));
        }
    }
    switch ((UINT)LOWORD(lpszType)) {
        case 1:
        case 12:
        	uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 2:
        case 14:
        	uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 3:
        	uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 4:
            uiError = ParseMenu( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 5:
            uiError = ParseDialog( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 6:
            uiError = ParseString( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 9:
            uiError = ParseAccel( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 11:
            uiError = ParseMsgTbl( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 16:
            uiError = ParseVerst( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 23:
        case 240:
        case 2110:
        case 1024:
            uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 7:
        case 8:
        case 13:
        case 15:
        break;
        //
        // To support RCDATA and user defined function we will call back the iodll,
        // get the file name and check if we have a DLL that will handle RCDATA.
        // We expect the DLL name to be RCfilename.dll.
        // This Dll will export a function called RWParseImageEx. This function will
        // be called by the RW to fill the buffer, all this without the iodll knowing.
        //
        case 10:
        default:
            //
            // Get the file name from the iodll
            //
            if(lpRCFilename && strcmp(lpRCFilename, ""))
            {
                // try to Load the dll
                HINSTANCE hRCDllInst = LoadLibrary(lpRCFilename);
                if (hRCDllInst)
                {
                    UINT (FAR PASCAL  * lpfnParseImageEx)(LPCSTR, LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPCSTR);

                    // Get the pointer to the function to extract the resources
                    lpfnParseImageEx = (UINT (FAR PASCAL *)(LPCSTR, LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPCSTR))
                                        GetProcAddress( hRCDllInst, "RWParseImageEx" );

                    if (lpfnParseImageEx)
                    {
                        uiError = (*lpfnParseImageEx)(lpszType,
                                     lpszResId,
                                     lpImageBuf,
                                     dwImageSize,
                                     lpBuffer,
                                     dwSize,
                                     NULL);
                    }

                    FreeLibrary(hRCDllInst);
                }
            }

        break;
    }

    return uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWParseImage(
    LPCSTR  lpszType,
    LPVOID  lpImageBuf,
    DWORD   dwImageSize,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    //
    // Just a wrapper to be compatible...
    //
    return RWParseImageEx(lpszType, NULL, lpImageBuf, dwImageSize, lpBuffer, dwSize, NULL);
}

extern"C"
DllExport
UINT
APIENTRY
RWWriteFile(
    LPCSTR          lpszSrcFilename,
    LPCSTR          lpszTgtFilename,
    HANDLE          hResFileModule,
    LPVOID          lpBuffer,
    UINT            uiSize,
    HINSTANCE       hDllInst,
    LPCSTR          lpszSymbolPath
    )
{
    UINT uiError = ERROR_NO_ERROR;
    UINT uiBufSize = uiSize;
    CFile fileIn;
    CFile fileOut;
    BOOL  bfileIn = TRUE;


    // Open the file and try to read the information on the resource in it.
	CFileStatus status;
    if (CFile::GetStatus( lpszSrcFilename, status )) {
        // check if the size of the file is not null
        if (!status.m_size)
            CFile::Remove(lpszSrcFilename);
    }

    if (!fileIn.Open(lpszSrcFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return ERROR_FILE_OPEN;

    if (!fileOut.Open(lpszTgtFilename, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
        return ERROR_FILE_CREATE;

    // Create a copy of the US file
    uiError = CopyFile( &fileIn, &fileOut );

    fileIn.Close();
    fileOut.Close();

    // Get the pointer to the function
	hDllInst = LoadLibrary("iodll.dll");
    if (!hDllInst)
        return ERROR_DLL_LOAD;

    DWORD (FAR PASCAL * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
    // Get the pointer to the function to extract the resources image
    lpfnGetImage = (DWORD (FAR PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
                        GetProcAddress( hDllInst, "RSGetResImage" );
    if (lpfnGetImage==NULL) {
        FreeLibrary(hDllInst);
        return (UINT)GetLastError()+LAST_ERROR;
    }

    // We read the resources from the file and then we check if the resource has been updated
    // or if we can just copy it

    WORD wTypeId;
    char szTypeId[128];

    WORD wNameId;
    char szNameId[128];

    DWORD dwSize;
    DWORD dwLang;

    WORD wUpdTypeId = 0;
    static char szUpdTypeId[128];

    WORD wUpdNameId;
    static char szUpdNameId[128];

    static WCHAR szwTypeId[128];
    static WCHAR szwNameId[128];

    DWORD dwUpdLang = 0;
    DWORD dwUpdSize = 0;

    UINT uiBufStartSize = uiBufSize;
    DWORD dwImageBufSize;
    DWORD dwLstErr = 0l;
    BYTE * lpImageBuf;
    static WCHAR szwTgtFilename[400];

    SetLastError(0);
    // Convert the Target file name to a unicode name
    _MBSTOWCS(szwTgtFilename, (char *)lpszTgtFilename, 400 );

    // Get the updated resource and replace them
    HANDLE hUpd = BeginUpdateResourceW( (LPCWSTR)&szwTgtFilename[0], !g_bAppend );
    dwLstErr = GetLastError();

    if (!hUpd) {
        FreeLibrary(hDllInst);
        return((UINT)dwLstErr);
    }

    // Parse the original file an get the list of resources

    UINT uiBSize = 100000;
    BYTE far * lpBuf = new far BYTE[uiBSize];
    BYTE far * lpStartBuf = lpBuf;
    if (!lpBuf) {
        FreeLibrary(hDllInst);
        return ERROR_NEW_FAILED;
    }

    uiError = RWReadTypeInfo( lpszSrcFilename, (LPVOID)lpBuf, &uiBSize );
    if (uiError!=ERROR_NO_ERROR) {
        FreeLibrary(hDllInst);
        delete lpBuf;
        return uiError;
    }

    DWORD dwDummy;

    while(uiBSize>0) {
        if (uiBSize)
            GetRes( &lpBuf,
                    &uiBSize,
                    &wTypeId, &szTypeId[0],
                    &wNameId, &szNameId[0],
                    &dwLang,
                    &dwSize,
                    &dwDummy
            );

        dwLang = MAKELONG(LOWORD(dwLang),LOWORD(dwLang));

        if ((!wUpdTypeId) && (uiBufSize))
            GetUpdatedRes( (BYTE**)&lpBuffer,
                    &uiBufSize,
                    &wUpdTypeId, &szUpdTypeId[0],
                    &wUpdNameId, &szUpdNameId[0],
                    &dwUpdLang,
                    &dwUpdSize
                    );

        // check if the resource has been updated or not
        if ( (wUpdTypeId==wTypeId) &&
             ( (CString)szUpdTypeId==(CString)szTypeId) &&
             (wUpdNameId==wNameId) &&
             ( (CString)szUpdNameId==(CString)szNameId) &&
             (LOWORD(dwLang) == LOWORD(dwUpdLang))
           ) {
             dwLang = dwUpdLang;
             dwSize = dwUpdSize;
             wUpdTypeId = 0;
        }


        // all resources of specific language need to be marked
        if (LOWORD(dwLang) == LOWORD(dwUpdLang) && g_bUpdOtherResLang)
        {
            dwLang = dwUpdLang;
        }


        // The resource has been updated get the image from the IODLL
        lpImageBuf = new BYTE[dwSize];

        // convert the Name to unicode
        LPWSTR  lpUpdType = LPNULL;
        LPWSTR  lpUpdRes = LPNULL;
        LPCSTR  lpType = LPNULL;
        LPCSTR  lpRes = LPNULL;

        if (wTypeId) {
            lpUpdType = (LPWSTR) MAKEINTRESOURCE((WORD)wTypeId);
            lpType = MAKEINTRESOURCE((WORD)wTypeId);
        } else {
            SetLastError(0);
            _MBSTOWCS(szwTypeId, szTypeId, 128 );
            // Check for error
            if(GetLastError()) {
                FreeLibrary(hDllInst);
                return ERROR_DLL_LOAD;
            }
            lpUpdType = (LPWSTR) &szwTypeId[0];
            lpType = &szTypeId[0];
        }

        if (wNameId) {
            lpUpdRes = (LPWSTR) MAKEINTRESOURCE((WORD)wNameId);
            lpRes = MAKEINTRESOURCE((WORD)wNameId);
        } else {
            SetLastError(0);
            _MBSTOWCS(szwNameId, szNameId, 128 );
            // Check for error
            if(GetLastError()) {
                FreeLibrary(hDllInst);
                return ERROR_DLL_LOAD;
            }
            lpUpdRes = (LPWSTR) &szwNameId[0];
            lpRes = &szNameId[0];
        }

        dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
                                        lpType,
                                        lpRes,
                                        (DWORD)LOWORD(dwLang),
                                        lpImageBuf,
                                        dwSize
                                        );
        if (dwImageBufSize>dwSize ) {
            // The buffer is too small
            delete []lpImageBuf;
            lpImageBuf = new BYTE[dwImageBufSize];
            dwUpdSize = (*lpfnGetImage)(  hResFileModule,
                                            lpType,
                                            lpRes,
                                            (DWORD)LOWORD(dwLang),
                                            lpImageBuf,
                                            dwImageBufSize
                                           );
            if ((dwUpdSize-dwImageBufSize)!=0 ) {
                delete []lpImageBuf;
                lpImageBuf = LPNULL;
            }
        }else if (dwImageBufSize==0){
             delete []lpImageBuf;
             lpImageBuf = LPNULL;
        }

        SetLastError(0);

        TRACE1("\t\tUpdateResourceW: %d\n", (WORD)dwUpdLang);

        if(!UpdateResourceW( hUpd,
                             lpUpdType,
                             lpUpdRes,
                             HIWORD(dwLang),
                             (LPVOID)lpImageBuf,
                             dwImageBufSize ))
        {
            dwLstErr = GetLastError();
        }

        if (lpImageBuf) delete []lpImageBuf;
    }

    SetLastError(0);
    EndUpdateResourceW( hUpd, FALSE );

    dwLstErr = GetLastError();

    if (dwLstErr)
        dwLstErr +=LAST_ERROR;

    // Fix the check sum
    DWORD error;
    if(error = FixCheckSum(lpszTgtFilename,lpszSrcFilename, lpszSymbolPath))
        dwLstErr = error;

    delete lpStartBuf;
	FreeLibrary(hDllInst);

    return (UINT)dwLstErr;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImageEx(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize,
    LPCSTR  lpRCFilename
    )
{
    UINT uiError = ERROR_NO_ERROR;

    // The Type we can parse are only the standard ones
    switch ((UINT)LOWORD(lpszType)) {

        case 4:
            uiError = UpdateMenu( lpNewBuf, dwNewSize,
                                  lpOldImage, dwOldImageSize,
                                  lpNewImage, pdwNewImageSize );
        break;

        case 5:
            uiError = UpdateDialog( lpNewBuf, dwNewSize,
                                  lpOldImage, dwOldImageSize,
                                  lpNewImage, pdwNewImageSize );
        break;

        case 6:
            uiError = UpdateString( lpNewBuf, dwNewSize,
                                    lpOldImage, dwOldImageSize,
                                    lpNewImage, pdwNewImageSize );
        break;

        case 9:
            uiError = UpdateAccel( lpNewBuf, dwNewSize,
                                   lpOldImage, dwOldImageSize,
                                   lpNewImage, pdwNewImageSize );
        break;

        case 11:
            uiError = UpdateMsgTbl( lpNewBuf, dwNewSize,
                                  lpOldImage, dwOldImageSize,
                                  lpNewImage, pdwNewImageSize );
        break;

        case 16:
            uiError = UpdateVerst( lpNewBuf, dwNewSize,
                                   lpOldImage, dwOldImageSize,
                                   lpNewImage, pdwNewImageSize );
        break;

        default:
            //
            // Get the file name from the iodll
            //
            if(lpRCFilename && strcmp(lpRCFilename, ""))
            {
                // try to Load the dll
                HINSTANCE hRCDllInst = LoadLibrary(lpRCFilename);
                if (hRCDllInst)
                {
                    UINT (FAR PASCAL * lpfnGenerateImageEx)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*, LPCSTR);

                    lpfnGenerateImageEx = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*, LPCSTR))
                                                GetProcAddress( hRCDllInst, "RWUpdateImageEx" );

                    if (lpfnGenerateImageEx)
                    {
                        uiError = (*lpfnGenerateImageEx)( lpszType,
                                            lpNewBuf,
                                            dwNewSize,
                                            lpOldImage,
                                            dwOldImageSize,
                                            lpNewImage,
                                            pdwNewImageSize,
                                            NULL );
                    }
                    else
                    {
                        *pdwNewImageSize = 0L;
                        uiError = ERROR_RW_NOTREADY;
                    }

                    FreeLibrary(hRCDllInst);
                }
                else
                {
                    *pdwNewImageSize = 0L;
                    uiError = ERROR_RW_NOTREADY;
                }
            }
            else
            {
                *pdwNewImageSize = 0L;
                uiError = ERROR_RW_NOTREADY;
            }
        break;
    }

    return uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImage(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize
    )
{
    return RWUpdateImageEx(lpszType, lpNewBuf, dwNewSize,
            lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize,
            NULL);
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation
static UINT
GetResInfo( CFile* pfile,
            WORD* pwTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
            WORD* pwNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
            WORD* pwFlags,
            DWORD* pdwSize, DWORD* pdwFileOffset )
{
    // Here we will parese the win32 file and will extract the information on the
    // resources included in the file.
    // Let's go and get the .rsrc sections
    UINT uiError = ERROR_NO_ERROR;

    return 1;
}

static UINT FindResourceSection( CFile* pfile, ULONG_PTR * pRes )
{
    UINT uiError = ERROR_NO_ERROR;
    LONG lRead;

    // We check again that is a file we can handle
    WORD w;

    pfile->Read((WORD*)&w, sizeof(WORD));
    if (w!=IMAGE_DOS_SIGNATURE) return ERROR_RW_INVALID_FILE;

    pfile->Seek( 0x18, CFile::begin );
    pfile->Read((WORD*)&w, sizeof(WORD));
    if (w<0x0040) {
    // this is not a Windows Executable
        return ERROR_RW_INVALID_FILE;
    }

    // get offset to new header
    pfile->Seek( 0x3c, CFile::begin );
    pfile->Read((WORD*)&w, sizeof(WORD));

    // read windows new header
    static IMAGE_NT_HEADERS NTHdr;
    pfile->Seek( w, CFile::begin );

    pfile->Read(&NTHdr, sizeof(IMAGE_NT_HEADERS));

    // Check if the magic word is the right one
    if (NTHdr.Signature!=IMAGE_NT_SIGNATURE)
                return ERROR_RW_INVALID_FILE;

    // Check if the we have 64-bit image
#ifdef _WIN64
    if (NTHdr.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
        pfile->Seek(IMAGE_SIZEOF_NT_OPTIONAL32_HEADER - 
                    IMAGE_SIZEOF_NT_OPTIONAL64_HEADER, 
                    CFile::current);
#else
    if (NTHdr.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
        pfile->Seek(IMAGE_SIZEOF_NT_OPTIONAL64_HEADER - 
                    IMAGE_SIZEOF_NT_OPTIONAL32_HEADER, 
                    CFile::current);
#endif

    // this is a Windows NT Executable
    // we can handle the situation

    // Later we want to check for the file type

    // Read the section table
    UINT uisize = sizeof(IMAGE_SECTION_HEADER)
          * NTHdr.FileHeader.NumberOfSections;
    PIMAGE_SECTION_HEADER pSectTbl =
            new IMAGE_SECTION_HEADER[NTHdr.FileHeader.NumberOfSections];

    if (pSectTbl==LPNULL)
    return ERROR_NEW_FAILED;

    // Clean the memory we allocated
    memset( (PVOID)pSectTbl, 0, uisize);

    lRead = pfile->Read(pSectTbl, uisize);

    if (lRead!=(LONG)uisize) {
        delete []pSectTbl;
        return ERROR_FILE_READ;
    }

    PIMAGE_SECTION_HEADER pResSect     = NULL;
    PIMAGE_SECTION_HEADER pResSect1    = NULL;
    // Check all the sections for the .rsrc or .rsrc1
    USHORT us =0;
    for (PIMAGE_SECTION_HEADER pSect = pSectTbl;
         us < NTHdr.FileHeader.NumberOfSections; us++ )     {
        if ( !strcmp((char*)pSect->Name, ".rsrc") && (!pResSect)) {
            pResSect = pSect;
        } else if (!strcmp((char*)pSect->Name, ".rsrc1") && (!pResSect1)) {
            // This mean that the binary we are parsing
            // has been already updated using UpdateResource()
            pResSect1 = pSect;
        }
        pSect++;
    }

    if (!pResSect) {
        delete []pSectTbl;
        return ERROR_RW_NO_RESOURCES;
    }
    // Read the resources in memory
    ResSectData.ulOffsetToResources  = pResSect->PointerToRawData;
    ResSectData.ulOffsetToResources1 = pResSect1 ? pResSect1->PointerToRawData
                                       : LPNULL;

    ResSectData.ulVirtualAddress   = pResSect->VirtualAddress;
    ResSectData.ulSizeOfResources  = pResSect->SizeOfRawData;
    ResSectData.ulVirtualAddress1  = pResSect1 ? pResSect1->VirtualAddress
                                           : LPNULL;
    ResSectData.ulSizeOfResources1 = pResSect1 ? pResSect1->SizeOfRawData
                                           : 0L;
    UCHAR * pResources = (UCHAR *) malloc((ResSectData.ulSizeOfResources
                  +ResSectData.ulSizeOfResources1));

    if (pResources==LPNULL) {
        delete []pSectTbl;
        return ERROR_NEW_FAILED;
    }

    // We read the data for the first section
    pfile->Seek( (LONG)ResSectData.ulOffsetToResources, CFile::begin);
    lRead = ReadFile(pfile, pResources, (LONG)ResSectData.ulSizeOfResources);

    if (lRead!=(LONG)ResSectData.ulSizeOfResources) {
        delete []pSectTbl;
        free(pResources);
        return ERROR_FILE_READ;
    }

    // We read the data for the second section
    if (ResSectData.ulSizeOfResources1 > 0L) {
        pfile->Seek( (LONG)ResSectData.ulOffsetToResources1, CFile::begin);
        lRead = ReadFile( pfile, (pResources+ResSectData.ulSizeOfResources),
                              (LONG)ResSectData.ulSizeOfResources1);

        if (lRead!=(LONG)ResSectData.ulSizeOfResources1) {
            delete []pSectTbl;
            free(pResources);
            return ERROR_FILE_READ;
        }
    }

    delete []pSectTbl;
    // We want to copy the pointer to the resources
    *pRes = (ULONG_PTR)pResources;
    return uiError;
}

static UINT ParseDirectory( CFile* pfile,
            LPLPBYTE lplpBuf, UINT* puiBufSize,
            BYTE bLevel,
            PIMAGE_RESOURCE_DIRECTORY pResStart,
            PIMAGE_RESOURCE_DIRECTORY pResDir)
{
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirStart;

    // Get the pointer to the first entry
    pResDirStart = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)
            ((BYTE far *)pResDir + sizeof( IMAGE_RESOURCE_DIRECTORY));

    UINT uiError = 0;
    UINT uiCount = pResDir->NumberOfNamedEntries
             + pResDir->NumberOfIdEntries;

    for ( PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry = pResDirStart;
      pResDirEntry < pResDirStart+uiCount && uiError == 0;
          ++pResDirEntry )
    {
        if (bLevel==0) GetNameOrOrdU( (PUCHAR) pResStart,
                            pResDirEntry->Name,
                            (LPWSTR)&gwszTypeId,
                            &gType );
        if (bLevel==1) GetNameOrOrdU( (PUCHAR) pResStart,
                            pResDirEntry->Name,
                            (LPWSTR)&gwszResId,
                            &gResId );
        if (bLevel==2) gLng = pResDirEntry->Name;

        // Check if the user want to get all the resources
        // or only some of them
        uiError = ParseDirectoryEntry( pfile,
                lplpBuf, puiBufSize,
                bLevel,
            pResStart,
            pResDirEntry );
    }
    return uiError;
}

static UINT ParseDirectoryEntry( CFile * pfile,
            LPLPBYTE lplpBuf, UINT* puiBufSize,
            BYTE bLevel,
            PIMAGE_RESOURCE_DIRECTORY pResStart,
            PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    UINT uiError;

    // Check if it is a SubDir or if it is a final Node
    if (pResDirEntry->OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY) {
        // It is a SubDir
        uiError = ParseSubDir( pfile,
            lplpBuf, puiBufSize,
            bLevel,
            pResStart,
            pResDirEntry );

    } else {
        uiError = ProcessData( pfile,
                    lplpBuf, puiBufSize,
                    pResStart,
                    (PIMAGE_RESOURCE_DATA_ENTRY)((BYTE far *)pResStart
                    + pResDirEntry->OffsetToData));
    }
    return uiError;
}

static UINT ParseSubDir( CFile * pfile,
            LPLPBYTE lplpBuf, UINT* puiBufSize,
            BYTE bLevel,
            PIMAGE_RESOURCE_DIRECTORY pResStart,
            PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    PIMAGE_RESOURCE_DIRECTORY pResDir;

    pResDir = (PIMAGE_RESOURCE_DIRECTORY)((BYTE far *)pResStart
          + (pResDirEntry->OffsetToData &
            (~IMAGE_RESOURCE_DATA_IS_DIRECTORY)));

    return( ++bLevel < MAXLEVELS ? ParseDirectory( pfile,
                                        lplpBuf, puiBufSize,
                        bLevel,
                                    pResStart,
                                    pResDir)
                         : ERROR_RW_TOO_MANY_LEVELS);
}

static UINT ProcessData( CFile * pfile,
                         LPLPBYTE lplpBuf, UINT* puiBufSize,
                         PIMAGE_RESOURCE_DIRECTORY pResStart,
                         PIMAGE_RESOURCE_DATA_ENTRY pResData)
{
    UINT uiError = ERROR_NO_ERROR;

    // Let's calculate the offset to the data
    ULONG ulOffset = pResData->OffsetToData - ResSectData.ulVirtualAddress;

    if ( ulOffset >= ResSectData.ulSizeOfResources ) {
        if ( ResSectData.ulSizeOfResources1 > 0L )      {
            // What we need is in the .rsrc1 segment
            // Recalculate the offset;
            ulOffset = pResData->OffsetToData - ResSectData.ulVirtualAddress1;
            if ( ulOffset >= ResSectData.ulSizeOfResources +
                             ResSectData.ulSizeOfResources1) {
                // There is an error in the offset
                return ERROR_FILE_INVALID_OFFSET;
            } else ulOffset += ResSectData.ulOffsetToResources1;
        } else return ERROR_FILE_INVALID_OFFSET;
    } else ulOffset += ResSectData.ulOffsetToResources;

    // Convert the UNICODE to SB string
    static char szResName[128];
    UINT cch = _WCSLEN(gwszResId);
    _WCSTOMBS( szResName, gwszResId, 128 );

    static char szTypeName[128];
    cch = _WCSLEN(gwszTypeId);
    _WCSTOMBS( szTypeName, gwszTypeId, 128 );


    TRACE("WIN32.DLL:\tType: %ld\tType Name: %s\tLang: %ld\tRes Id: %ld", gType, szTypeName, gLng, gResId);
    TRACE1("\tSize: %d", pResData->Size);
    TRACE2("\tRes Name: %s\tOffset: %lX\n", szResName, ulOffset );

    // fill the buffer

    WriteResInfo(lplpBuf, (LONG*)puiBufSize,
                 (WORD)gType, szTypeName, 128,
                 (WORD)gResId, szResName, 128,
                 (DWORD)gLng,
                 (DWORD)pResData->Size, (DWORD)ulOffset );
    return uiError;
};

static LONG WriteResInfo(
                 LPLPBYTE lplpBuffer, LONG* plBufSize,
                 WORD wTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
                 WORD wNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
                 DWORD dwLang,
                 DWORD dwSize, DWORD dwFileOffset )
{
    LONG lSize = 0;
    lSize = PutWord( lplpBuffer, wTypeId, plBufSize );
    lSize += PutStringA( lplpBuffer, lpszTypeId, plBufSize );
	 // Check if it is alligned
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutWord( lplpBuffer, wNameId, plBufSize );
    lSize += PutStringA( lplpBuffer, lpszNameId, plBufSize );
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutDWord( lplpBuffer, dwLang, plBufSize );

    lSize += PutDWord( lplpBuffer, dwSize, plBufSize );

    lSize += PutDWord( lplpBuffer, dwFileOffset, plBufSize );

    return (LONG)lSize;
}

static UINT GetUpdatedRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize )
{
    UINT uiSize = 0l;
	LONG lSize = *puiBufSize;

    uiSize = GetWord( lplpBuffer, wTypeId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszTypeId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, PadPtr(uiSize), (LONG*)&lSize );

    uiSize += GetWord( lplpBuffer, wNameId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszNameId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, PadPtr(uiSize), (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwLang, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwSize, (LONG*)&lSize );

	*puiBufSize = lSize;

    return 0;
}

static UINT GetRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize, DWORD* dwFileOffset )
{
    UINT uiSize = 0l;
	 LONG lSize = *puiBufSize;

    uiSize = GetWord( lplpBuffer, wTypeId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszTypeId, (LONG*)&lSize );
	 uiSize += SkipByte( lplpBuffer, PadPtr(uiSize), (LONG*)&lSize );

    uiSize += GetWord( lplpBuffer, wNameId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszNameId, (LONG*)&lSize );
	 uiSize += SkipByte( lplpBuffer, PadPtr(uiSize), (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwLang, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwSize, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwFileOffset, (LONG*)&lSize );

	 *puiBufSize = lSize;
    return uiSize;
}

static LONG ReadFile(CFile* pFile, UCHAR * pBuf, LONG lRead)
{
    LONG lLeft = lRead;
    WORD wRead = 0;
    DWORD dwOffset = 0;

    while(lLeft>0){
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!=_lread( (HFILE)pFile->m_hFile, (UCHAR *)pBuf+dwOffset, wRead))
            return 0l;
        lLeft -= wRead;
        dwOffset += wRead;
    }
    return dwOffset;

}


////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation

////////////////////////////////////////////////////////////////////////////
// Library init

////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory
		// here, use the TRACE or ASSERT macros or call MessageBox
		AfxInitExtensionModule(extensionDLL, hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxWinTerm();
	}

	if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
		return 0;		// CRT term	Failed

	return 1;   // ok
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rlt32\rw\win16\win16.cpp ===
//+---------------------------------------------------------------------------
//
//  File:   win16.cpp
//
//  Contents:   Implementation for the Windows 16 Read/Write module
//
//  Classes:    one
//
//  History:    26-July-93   alessanm    created
//
//----------------------------------------------------------------------------

#include <afxwin.h>
#include "..\common\rwdll.h"
#include "newexe.h"
#include <stdio.h>

#include <limits.h>

/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL};

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define MODULENAME "RWWin16.dll"
#define RWTAG "WIN16"

#define LPNULL 0L
#define Pad16(x) ((((x+15)>>4)<<4)-x)
#define Pad4(x) ((((x+3)>>2)<<2)-x)

#define MAXSTR 300
#define MAXID 128
#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_WIN_SIGNATURE                 0x454E      // NE

#define VB					// RCDATA process for VB only - WB
#ifdef VB
static const RES_SIGNATURE = 0xA5;  // identifier for VB entry
#endif


// Code pages
#define CP_ASCII7   0       // 7-bit ASCII
#define CP_JIS      932     // Japan (Shift - JIS X-0208)
#define CP_KSC      949     // Korea (Shift - KSC 5601)
#define CP_GB5      950     // Taiwan (GB5)
#define CP_UNI      1200    // Unicode
#define CP_EE       1250    // Latin-2 (Eastern Europe)
#define CP_CYR      1251    // Cyrillic
#define CP_MULTI    1252    // Multilingual
#define CP_GREEK    1253    // Greek
#define CP_TURK     1254    // Turkish
#define CP_HEBR     1255    // Hebrew
#define CP_ARAB     1256    // Arabic

/////////////////////////////////////////////////////////////////////////////
// General type Declarations
typedef unsigned char UCHAR;

typedef UCHAR * PUCHAR;

typedef struct ver_block {
    WORD wBlockLen;
    WORD wValueLen;
    WORD wType;
    WORD wHead;
    BYTE far * pValue;
    char szKey[100];
    char szValue[300];
} VER_BLOCK;

/////////////////////////////////////////////////////////////////////////////
// Function Declarations

static UINT GetResInfo(
                      CFile*,
                      WORD* wTypeId, LPSTR lplpszTypeId, BYTE bMaxTypeLen,
                      WORD* wNameId, LPSTR lplpszNameId, BYTE bMaxNameLen,
                      WORD* pwFlags,
                      DWORD* dwSize, DWORD* dwFileOffset );

static UINT WriteHeader(
                       CFile*,
                       WORD wTypeId, LPSTR lpszTypeId,
                       WORD wNameId, LPSTR lpszNameId,
                       WORD wFlags );

static UINT WriteImage(
                      CFile*,
                      LPVOID lpImage, DWORD dwSize );

static UINT GetUpdatedRes(
                         LPVOID far * lplpBuffer,
                         UINT* uiSize,
                         WORD* wTypeId, LPSTR lplpszTypeId,
                         WORD* wNameId, LPSTR lplpszNameId,
                         DWORD* dwlang, DWORD* dwSize );

static UINT GetUpdatedItem(
                          LPVOID far * lplpBuffer,
                          LONG* dwSize,
                          WORD* wX, WORD* wY,
                          WORD* wcX, WORD* wcY,
                          DWORD* dwPosId,
                          DWORD* dwStyle, DWORD* dwExtStyle,
                          LPSTR lpszText);

static int GetVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK* pverBlock);
static int PutVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK verBlock,
                       LPSTR lpStr, BYTE far * far * lplpBlockSize, WORD* pwPad);

/////////////////////////////////////////////////////////////////////////////
// Helper Function Declarations
static UINT CopyFile( CFile* filein, CFile* fileout );
static UINT GetNameOrOrdFile( CFile* pfile, WORD* pwId, LPSTR lpszId, BYTE bMaxStrLen );
static UINT ParseMenu( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseString( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseDialog( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseCursor( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseIcon( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseBitmap( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseAccel( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
#ifdef VB
static UINT ParseVBData(  LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
#endif
static UINT ParseVerst( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

static UINT GenerateFile( LPCSTR        lpszTgtFilename,
                          HANDLE        hResFileModule,
                          LPVOID        lpBuffer,
                          UINT      uiSize,
                          HINSTANCE   hDllInst
                        );


static UINT UpdateMenu( LPVOID lpNewBuf, LONG dwNewSize,
                        LPVOID lpOldImage, LONG dwOldImageSize,
                        LPVOID lpNewImage, DWORD* pdwNewImageSize );
static UINT GenerateMenu( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpNewImage, DWORD* pdwNewImageSize );
static UINT UpdateString( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );
static UINT GenerateString( LPVOID lpNewBuf, LONG dwNewSize,
                            LPVOID lpNewImage, DWORD* pdwNewImageSize );

static UINT UpdateDialog( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );
static UINT GenerateDialog( LPVOID lpNewBuf, LONG dwNewSize,
                            LPVOID lpNewImage, DWORD* pdwNewImageSize );

static UINT UpdateAccel(LPVOID lpNewBuf, LONG dwNewSize,
                        LPVOID lpOldImage, LONG dwOldImageSize,
                        LPVOID lpNewImage, DWORD* pdwNewImageSize );
#ifdef VB
static UINT UpdateVBData( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );
#endif

static UINT UpdateVerst( LPVOID lpNewBuf, LONG dwNewSize,
                         LPVOID lpOldI, LONG dwOldImageSize,
                         LPVOID lpNewI, DWORD* pdwNewImageSize );


static BYTE SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwRead );

static BYTE PutDWord( BYTE far * far* lplpBuf, DWORD dwValue, LONG* pdwSize );
static BYTE PutWord( BYTE far * far* lplpBuf, WORD wValue, LONG* pdwSize );
static BYTE PutByte( BYTE far * far* lplpBuf, BYTE bValue, LONG* pdwSize );
static UINT PutString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
static UINT PutPascalString( BYTE far * far* lplpBuf, LPSTR lpszText, BYTE bLen, LONG* pdwSize );
static UINT PutNameOrOrd( BYTE far * far* lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize );
static UINT PutCaptionOrOrd( BYTE far * far* lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize,
                             BYTE bClass, DWORD dwStyle );
static UINT PutClassName( BYTE far * far* lplpBuf, BYTE bClass, LPSTR lpszText, LONG* pdwSize );
static UINT PutControlClassName( BYTE far * far* lplpBuf, BYTE bClass, LPSTR lpszText, LONG* pdwSize );

static BYTE GetDWord( BYTE far * far* lplpBuf, DWORD* dwValue, LONG* pdwSize );
static BYTE GetWord( BYTE far * far* lplpBuf, WORD* wValue, LONG* pdwSize );
static BYTE GetByte( BYTE far * far* lplpBuf, BYTE* bValue, LONG* pdwSize );
static UINT GetNameOrOrd( BYTE far * far* lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize );
static UINT GetCaptionOrOrd( BYTE far * far* lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize,
                             BYTE wClass, DWORD dwStyle );
static UINT GetString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
static UINT GetClassName( BYTE far * far* lplpBuf, BYTE* bClass, LPSTR lpszText, LONG* pdwSize );
static UINT GetControlClassName( BYTE far * far* lplpBuf, BYTE* bClass, LPSTR lpszText, LONG* pdwSize );
static UINT CopyText( BYTE far * far * lplpTgt, BYTE far * far * lplpSrc, LONG* pdwTgtSize, LONG* pdwSrcSize);
static int  GetVSString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize, int cMaxLen );
static LPRESITEM GetItem( BYTE far * lpBuf, LONG dwNewSize, LPSTR lpStr );
static DWORD CalcID( WORD wId, BOOL bFlag );
static DWORD GenerateTransField( WORD wLang, BOOL bReverse );
static void GenerateTransField( WORD wLang, VER_BLOCK * pVer );
static void ChangeLanguage( LPVOID, UINT );
// Allignment helpers
static LONG Allign( BYTE * * lplpBuf, LONG* plBufSize, LONG lSize );

/////////////////////////////////////////////////////////////////////////////
// Global variables
static BYTE sizeofByte = sizeof(BYTE);
static BYTE sizeofWord = sizeof(WORD);
static BYTE sizeofDWord = sizeof(DWORD);
static CWordArray wIDArray;
static DWORD    gLang = 0;
/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

//[registration]
extern "C"
BOOL    FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
    strcpy( lpszTypeName, RWTAG );
    return FALSE;
}

extern "C"
BOOL    FAR PASCAL RWValidateFileType   (LPCSTR lpszFilename)
{
    UINT uiError = ERROR_NO_ERROR;
    CFile file;
    WORD w;

    // we Open the file to see if it is a file we can handle
    if (!file.Open( lpszFilename, CFile::shareDenyNone | CFile::typeBinary | CFile::modeRead ))
        return FALSE;

    // Read the file signature
    file.Read((WORD*)&w, sizeof(WORD));
    if (w==IMAGE_DOS_SIGNATURE) {
        file.Seek( 0x18, CFile::begin );
        file.Read((WORD*)&w, sizeof(WORD));
        if (w<0x0040) {
            // this is not a Windows Executable
            file.Close();
            return FALSE;
        }
        // get offset to header
        file.Seek( 0x3c, CFile::begin );
        file.Read((WORD*)&w, sizeof(WORD));

        // Read header
        new_exe ne;
        file.Seek( w, CFile::begin );
        file.Read(&ne, sizeof(new_exe));
        if (NE_MAGIC(ne)==LOWORD(IMAGE_WIN_SIGNATURE)) {
            // this is a Windows Executable
            // we can handle the situation
            file.Close();
            return TRUE;
        }
    }
    file.Close();
    return FALSE;
}


extern "C"
UINT
APIENTRY
RWReadTypeInfo(
              LPCSTR lpszFilename,
              LPVOID lpBuffer,
              UINT* puiSize

              )
{
    UINT  uiError = ERROR_NO_ERROR;
    BYTE  far * lpBuf = (BYTE far *)lpBuffer;
    DWORD uiBufSize = *puiSize;

    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile file;
    WORD i;
    WORD wAlignShift;
    WORD w, wResCount;
    WORD wWinHeaderOffset, wResTableOffset;
    WORD wCurTypeOffset, wCurNameOffset;
    BYTE nCount;

    WORD wTypeId; DWORD dwTypeId;
    static char szTypeId[128];

    WORD wNameId;
    static char szNameId[128];

    WORD  wSize, wFileOffset;
    DWORD dwSize,dwFileOffset;
    WORD  wResidentOffset;
    DWORD dwVerStampOffset = 0xffffffff;
    DWORD dwVerStampSize = 0;

    UINT uiOverAllSize = 0;


    if (!RWValidateFileType(lpszFilename))
        return ERROR_RW_INVALID_FILE;

    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::shareDenyNone | CFile::modeRead | CFile::typeBinary))
        return ERROR_FILE_OPEN;

    // we try to read as much information as we can
    // Because this is a exe file we can read all the information we need.

    file.Read((WORD*)&w, sizeof(WORD));
    if (w!=IMAGE_DOS_SIGNATURE) return ERROR_RW_INVALID_FILE;

    file.Seek( 0x18, CFile::begin );
    file.Read((WORD*)&w, sizeof(WORD));
    if (w<0x0040) {
        // this is not a Windows Executable
        file.Close();
        return ERROR_RW_INVALID_FILE;
    }

    // Get offset to Windows new header
    file.Seek( 0x3c, CFile::begin );
    file.Read((WORD*)&wWinHeaderOffset, sizeof(WORD));

    // Read and save Windows header Offset
    file.Seek( wWinHeaderOffset, CFile::begin );

    // Read header
    new_exe ne;
    file.Read(&ne, sizeof(new_exe));
    if (NE_MAGIC(ne)!=LOWORD(IMAGE_WIN_SIGNATURE)) {
        // this is not a Windows Executable
        file.Close();
        return ERROR_RW_INVALID_FILE;
    }

    // this is a Windows 16 Executable
    // we can handle the situation
    // Later we want to check for the file type

    // Location 24H inside of the Windows header has the relative offset from
    // the beginning of the Windows header to the beginning of the resource table
    file.Seek (wWinHeaderOffset+0x24, CFile::begin);
    file.Read ((WORD*)&wResTableOffset, sizeof(WORD));
    file.Read ((WORD*)&wResidentOffset, sizeof(WORD));

    // Check if there are resources
    if (wResTableOffset == wResidentOffset) {
        file.Close ();
        return ERROR_RW_NO_RESOURCES;
    }

    // Read the resurce table
    new_rsrc rsrc;
    file.Seek (wWinHeaderOffset+NE_RSRCTAB(ne), CFile::begin);
    file.Read (&rsrc, sizeof(new_rsrc));

    WORD rsrc_size = NE_RESTAB(ne)-NE_RSRCTAB(ne);

    // Read and save alignment shift count
    file.Seek (wWinHeaderOffset+wResTableOffset, CFile::begin);
    file.Read ((WORD*)&wAlignShift, sizeof(WORD));

    // Read the first type ID
    file.Read ((WORD*)&wTypeId, sizeof(WORD));

    // Save the Offset of the current TypeInfo record
    wCurTypeOffset = wWinHeaderOffset + wResTableOffset + 2;

    // reset the global language
    gLang = 0;

    // Process TypeInfo records while there are TypeInfo record left
    while (wTypeId) {
        // Get Name of ord
        if (!(wTypeId & 0x8000)) {
            // It is a Offset to a string
            dwTypeId = (MAKELONG(wTypeId, 0)); //<<wAlignShift;
            file.Seek (wWinHeaderOffset+wResTableOffset+dwTypeId, CFile::begin);
            // Get the character count for the ID string
            file.Read ((BYTE*)&nCount, sizeof(BYTE));
            // Read the ID string
            file.Read (szTypeId, nCount);
            // Put null at the end of the string
            szTypeId[nCount] = 0;

            if (0 == strlen(szTypeId))
                return ERROR_RW_INVALID_FILE;

            // Set wTypeId to zero
            wTypeId = 0;
        } else {
            // It is an ID
            // Turn off the high bit
            wTypeId = wTypeId & 0x7FFF;
            if (0 == wTypeId)
                return ERROR_RW_INVALID_FILE;

            // Set the ID string to null
            szTypeId[0] = 0;
        }

        // Restore the file read point
        file.Seek (wCurTypeOffset+2, CFile::begin);

        // Get the count for this type of resource
        file.Read ((WORD*)&wResCount, sizeof(WORD));

        // Pass the reserved DWORD
        file.Seek (4, CFile::current);

        // Save the Offset of the current NameInfo record
        wCurNameOffset = wCurTypeOffset + 8;

        // Process NameInfo records
        for (i = 0; i < wResCount; i++) {
            file.Read ((WORD*)&wFileOffset, sizeof(WORD));
            file.Read ((WORD*)&wSize, sizeof(WORD));
            // Pass the flags
            file.Seek (2, CFile::current);
            file.Read ((WORD*)&wNameId, sizeof(WORD));

            // Get name of ord
            if (!(wNameId & 0x8000)) {
                // It is a Offset to a string
                file.Seek (wWinHeaderOffset+wResTableOffset+wNameId, CFile::begin);
                // Get the character count for the string
                file.Read ((BYTE*)&nCount, sizeof(BYTE));
                // Read the string
                file.Read (szNameId, nCount);
                // Put null at the end of the string
                szNameId[nCount] = 0;
                // Set wNameId to zero
                wNameId = 0;
            } else {
                // It is an ID
                // Turn off the high bit
                wNameId = wNameId & 0x7FFF;
                if (0 == wNameId)
                    return ERROR_RW_INVALID_FILE;

                // Set the string to null
                szNameId[0] = 0;
            }

            dwSize = (MAKELONG (wSize, 0))<<wAlignShift;
//          dwSize = MAKELONG (wSize, 0);
            dwFileOffset = (MAKELONG (wFileOffset, 0))<<wAlignShift;

            // Put the data into the buffer

            uiOverAllSize += PutWord( &lpBuf, wTypeId, (LONG*)&uiBufSize );
            uiOverAllSize += PutString( &lpBuf, szTypeId, (LONG*)&uiBufSize );
            // Check if it is alligned
            uiOverAllSize += Allign( &lpBuf, (LONG*)&uiBufSize, (LONG)uiOverAllSize);

            uiOverAllSize += PutWord( &lpBuf, wNameId, (LONG*)&uiBufSize );
            uiOverAllSize += PutString( &lpBuf, szNameId, (LONG*)&uiBufSize );
            // Check if it is alligned
            uiOverAllSize += Allign( &lpBuf, (LONG*)&uiBufSize, (LONG)uiOverAllSize);

            uiOverAllSize += PutDWord( &lpBuf, gLang, (LONG*)&uiBufSize );

            uiOverAllSize += PutDWord( &lpBuf, dwSize, (LONG*)&uiBufSize );

            uiOverAllSize += PutDWord( &lpBuf, dwFileOffset, (LONG*)&uiBufSize );

            TRACE("WIN16: Type: %hd\tName: %hd\tOffset: %lX\n", wTypeId, wNameId, dwFileOffset);

            // Check if this is the Version stamp block and save the offset to it
            if (wTypeId==16) {
                dwVerStampOffset = dwFileOffset;
                dwVerStampSize = dwSize;
            }

            // Update the current NameInfo record offset
            wCurNameOffset = wCurNameOffset + 12;
            // Move file pointer to the next NameInfo record
            file.Seek (wCurNameOffset, CFile::begin);
        }

        // Update the current TypeInfo record offset
        wCurTypeOffset = wCurTypeOffset + 8 + wResCount * 12;
        // Move file pointer to the next TypeInfo record
        file.Seek (wCurTypeOffset, CFile::begin);
        // Read the next TypeId
        file.Read ((WORD*)&wTypeId, sizeof(WORD));
    }

    // Now do we have a VerStamp Offset
    if (dwVerStampOffset!=0xffffffff) {
        // Let's get the language ID and touch the buffer with the new information
        file.Seek (dwVerStampOffset, CFile::begin);


        DWORD  dwBuffSize = dwVerStampSize;
        char * pBuff = new char[dwVerStampSize+1];
        char * pTrans = pBuff;
        char * pTrans2;
        file.Read(pBuff, dwVerStampSize);

        while ( pTrans2 = (LPSTR)memchr(pTrans, 'T', dwBuffSize) ) {
            dwBuffSize -= (DWORD)(pTrans2 - pTrans);

            pTrans = pTrans2;
            if (!memcmp( pTrans, "Translation", 11)) {
                pTrans = pTrans + 12;
                gLang = (WORD)*((WORD*)pTrans);
                break;
            }

            ++pTrans;
            dwBuffSize--;
        }

        delete pBuff;

        if (gLang!=0) {
            // walk the buffer and change the language id
            ChangeLanguage(lpBuffer, uiOverAllSize);
        }
    }

    file.Close();
    *puiSize = uiOverAllSize;
    return uiError;
}

extern "C"
DWORD
APIENTRY
RWGetImage(
          LPCSTR  lpszFilename,
          DWORD   dwImageOffset,
          LPVOID  lpBuffer,
          DWORD   dwSize
          )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    DWORD dwBufSize = dwSize;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile file;

    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::shareDenyNone | CFile::modeRead | CFile::typeBinary)) {
        return (DWORD)ERROR_FILE_OPEN;
    }

    if ( dwImageOffset!=(DWORD)file.Seek( dwImageOffset, CFile::begin) )
        return (DWORD)ERROR_FILE_INVALID_OFFSET;
    if (dwSize>UINT_MAX) {
        // we have to read the image in different steps
        return (DWORD)0L;
    } else uiError = file.Read( lpBuf, (UINT)dwSize);
    file.Close();

    return (DWORD)uiError;
}

extern "C"
UINT
APIENTRY
RWParseImage(
            LPCSTR  lpszType,
            LPVOID  lpImageBuf,
            DWORD   dwImageSize,
            LPVOID  lpBuffer,
            DWORD   dwSize
            )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    DWORD dwBufSize = dwSize;

    // The Type we can parse are only the standard ones
    // This function should fill the lpBuffer with an array of ResItem structure
    switch ((UINT)LOWORD(lpszType)) {
        case 1:
            uiError = ParseCursor( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 2:
            uiError = ParseBitmap( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 3:
            uiError = ParseIcon( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 4:
            uiError = ParseMenu( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 5:
            uiError = ParseDialog( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 6:
            uiError = ParseString( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 9:
            uiError = ParseAccel( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;
#ifdef VB
        case 10:
            uiError = ParseVBData(  lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;
#endif


        case 16:
            uiError = ParseVerst( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        default:
            break;
    }

    return uiError;
}

extern"C"
UINT
APIENTRY
RWWriteFile(
           LPCSTR      lpszSrcFilename,
           LPCSTR      lpszTgtFilename,
           HANDLE      hResFileModule,
           LPVOID      lpBuffer,
           UINT        uiSize,
           HINSTANCE   hDllInst,
           LPCSTR      lpszSymbol
           )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = LPNULL;
    UINT uiBufSize = uiSize;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile fileIn;
    CFile fileOut;
    BOOL  bfileIn = TRUE;

    WORD wTypeId;  DWORD dwTypeId;
    char szTypeId[128];

    WORD wNameId;
    char szNameId[128];

    DWORD dwSize;
    DWORD dwFileOffset;

    WORD wUpdTypeId = 0;
    static char szUpdTypeId[128];

    static char szUpdNameId[128];

    UINT uiBufStartSize = uiBufSize;
    DWORD dwImageBufSize = 0L;
    BYTE far * lpImageBuf = 0L;

    WORD wWinHeaderOffset = 0;
    WORD wResTableOffset = 0;
    WORD wCurTypeOffset = 0;
    WORD wFileOffset  = 0;
    WORD wSize = 0;
    WORD wCurNameOffset = 0;
    WORD wAlignShift = 0;
    WORD wResDataOffset = 0;
    WORD wResDataBegin = 0;
    WORD wCurResDataBegin = 0;
    DWORD dwResDataBegin = 0L;
    DWORD dwCurResDataBegin = 0L;
    WORD i = 0; short j = 0L; WORD wResCount = 0L;
    BYTE nCharCount = 0;
    short delta = 0;
    WORD wFlags = 0; WORD wLoadOnCallResDataBegin = 0;
    WORD wNumOfSegments  = 0;
    WORD wSegmentTableOffset = 0;
    WORD wOffset = 0;
    WORD wLoadOnCallCodeBegin = 0;
    DWORD dwLoadOnCallCodeBegin = 0L;
    DWORD (FAR PASCAL    * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);

    // Open the file and try to read the information on the resource in it.
    CFileStatus status;
    if (CFile::GetStatus( lpszSrcFilename, status )) {
        // check if the size of the file is not null
        if (!status.m_size)
            CFile::Remove(lpszSrcFilename);
    }

    if (!fileIn.Open(lpszSrcFilename, CFile::shareDenyNone | CFile::modeRead | CFile::typeBinary))
        return GenerateFile(lpszTgtFilename,
                            hResFileModule,
                            lpBuffer,
                            uiSize,
                            hDllInst
                           );

    if (!fileOut.Open(lpszTgtFilename, CFile::shareDenyNone | CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
        return ERROR_FILE_CREATE;

    // Get the handle to the IODLL
    hDllInst = LoadLibrary("iodll.dll");

    if (!hDllInst)
        return ERROR_DLL_LOAD;

    // Get the pointer to the function to extract the resources image
    lpfnGetImage = (DWORD (FAR PASCAL   *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
                   GetProcAddress( hDllInst, "RSGetResImage" );
    if (lpfnGetImage==NULL) {
        FreeLibrary(hDllInst);
        return ERROR_DLL_PROC_ADDRESS;
    }

    // We read the resources from the file and then we check if the resource has been updated
    // or if we can just copy it

    // Get offset to Windows new header
    fileIn.Seek( 0x3c, CFile::begin );
    fileIn.Read((WORD*)&wWinHeaderOffset, sizeof(WORD));

    // Read and save resource table Offset
    fileIn.Seek( wWinHeaderOffset+0x24, CFile::begin );
    fileIn.Read ((WORD*)&wResTableOffset, sizeof(WORD));

    // Read AlignShift
    fileIn.Seek (wWinHeaderOffset+wResTableOffset, CFile::begin);
    fileIn.Read ((WORD*)&wAlignShift, sizeof(WORD));

    // Get the beginning of the resource data
    wResDataBegin = 0xffff;
    wLoadOnCallResDataBegin = 0xffff;
    fileIn.Read((WORD*)&wTypeId, sizeof(WORD));
    while (wTypeId) {
        fileIn.Read ((WORD*)&wResCount, sizeof(WORD));
        // Pass the reserved DWORD
        fileIn.Seek (4, CFile::current);

        for (i=0; i<wResCount; i++) {
            fileIn.Read ((WORD*)&wResDataOffset, sizeof(WORD));
            fileIn.Seek (2, CFile::current);
            fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
            if (wResDataOffset>0) {
                if (wFlags & 0x0040)
                    wResDataBegin = (wResDataOffset < wResDataBegin) ? wResDataOffset:wResDataBegin;
                else
                    wLoadOnCallResDataBegin = (wResDataOffset < wLoadOnCallResDataBegin) ? wResDataOffset:wLoadOnCallResDataBegin;
            }
            // Get to next NameInfo record
            fileIn.Seek (6, CFile::current);
        }
        fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));
    }

    // Copy data before resource data
    fileIn.SeekToBegin ();
    fileOut.SeekToBegin ();
    CopyFile (&fileIn, &fileOut);

    if (wResDataBegin != 0xffff) { // If there are PreLoad resources
        dwResDataBegin = (MAKELONG (wResDataBegin, 0))<<wAlignShift;

        // Read the first type ID
        fileIn.Seek (wWinHeaderOffset+wResTableOffset+2, CFile::begin);
        fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));

        // Save the Offset of the current TypeInfo record
        wCurTypeOffset = wWinHeaderOffset + wResTableOffset + 2;

        // Save the beginning of current resource data
        dwCurResDataBegin = dwResDataBegin;

        // Loop through the TypeInfo table to write PreLoad resources
        while (wTypeId) {
            // Get Name of ord
            if (!(wTypeId & 0x8000)) {
                // It is a Offset to a string
                dwTypeId = (MAKELONG(wTypeId, 0)); //<<wAlignShift;
                fileIn.Seek (wWinHeaderOffset+wResTableOffset+dwTypeId, CFile::begin);
                // Get the character count for the ID string
                fileIn.Read ((BYTE*)&nCharCount, sizeof(BYTE));
                // Read the ID string
                fileIn.Read (szTypeId, nCharCount);
                // Put null at the end of the string
                szTypeId[nCharCount] = 0;
                // Set wTypeId to zero
                wTypeId = 0;
            } else {
                // It is an ID
                // Turn off the high bit
                wTypeId = wTypeId & 0x7FFF;
                if (0 == wTypeId)
                    return ERROR_RW_INVALID_FILE;

                // Set the ID string to null
                szTypeId[0] = 0;
            }

            // Restore the file read point
            fileIn.Seek (wCurTypeOffset+2, CFile::begin);

            // Get the count for this type of resource
            fileIn.Read ((WORD*)&wResCount, sizeof(WORD));

            // Pass the reserved DWORD
            fileIn.Seek (4, CFile::current);

            // Save the Offset of the current NameInfo record
            wCurNameOffset = wCurTypeOffset + 8;

            // Loop through NameInfo records
            for (i = 0; i < wResCount; i++) {
                // Read resource offset
                fileIn.Read ((WORD*)&wFileOffset, sizeof(WORD));
                // Read resource length
                fileIn.Read ((WORD*)&wSize, sizeof(WORD));
                // Read the flags
                fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
                // Read resource ID
                fileIn.Read ((WORD*)&wNameId, sizeof(WORD));

                if (wFlags & 0x0040) {
                    // Get name of ord
                    if (!(wNameId & 0x8000)) {
                        // It is a Offset to a string
                        fileIn.Seek (wWinHeaderOffset+wResTableOffset+wNameId, CFile::begin);
                        // Get the character count for the string
                        fileIn.Read ((BYTE*)&nCharCount, sizeof(BYTE));
                        // Read the string
                        fileIn.Read (szNameId, nCharCount);
                        // Put null at the end of the string
                        szNameId[nCharCount] = 0;
                        // Set wNameId to zero
                        wNameId = 0;
                    } else {
                        // It is an ID
                        // Turn off the high bit
                        wNameId = wNameId & 0x7FFF;
                        if ( 0 == wNameId)
                            return ERROR_RW_INVALID_FILE;

                        // Set the string to null
                        szNameId[0] = 0;
                    }

                    dwSize = (MAKELONG (wSize, 0))<<wAlignShift;
                    dwFileOffset = (MAKELONG (wFileOffset, 0))<<wAlignShift;

                    // Now we got the Type and Name here and size

                    // Get the image from the IODLL
                    if (dwSize)
                        lpImageBuf = new BYTE[dwSize];
                    else lpImageBuf = LPNULL;
                    LPSTR   lpType = LPNULL;
                    LPSTR   lpRes = LPNULL;

                    if (wTypeId)
                        lpType = (LPSTR)((WORD)wTypeId);
                    else
                        lpType = &szTypeId[0];

                    if (wNameId)
                        lpRes = (LPSTR)((WORD)wNameId);
                    else
                        lpRes = &szNameId[0];

                    dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
                                                       lpType,
                                                       lpRes,
                                                       (DWORD)-1,
                                                       lpImageBuf,
                                                       dwSize
                                                    );

                    if (dwImageBufSize>dwSize ) {
                        // The buffer is too small
                        delete []lpImageBuf;
                        lpImageBuf = new BYTE[dwImageBufSize];
                        dwSize = (*lpfnGetImage)(  hResFileModule,
                                                   lpType,
                                                   lpRes,
                                                   (DWORD)-1,
                                                   lpImageBuf,
                                                   dwImageBufSize
                                                );
                        if ((dwSize-dwImageBufSize)!=0 ) {
                            delete []lpImageBuf;
                            lpImageBuf = LPNULL;
                        }
                    }

                    // Try to see if we have to set the memory to 0
                    if ((int)(dwSize-dwImageBufSize)>0)
                        memset(lpImageBuf+dwImageBufSize, 0, (size_t)(dwSize-dwImageBufSize));

                    // Write the image
                    fileOut.Seek (dwCurResDataBegin, CFile::begin);
                    WriteImage( &fileOut, lpImageBuf, dwSize);


                    // Fix the alignment for resource data
                    delta = (short)((((dwSize+(1<<wAlignShift)-1)>>wAlignShift)<<wAlignShift)-dwSize);
                    BYTE nByte = 0;

                    fileOut.Seek (dwCurResDataBegin+dwSize, CFile::begin);
                    for (j=0; j<delta; j++)
                        fileOut.Write ((BYTE*)&nByte, sizeof(BYTE));

                    dwSize = dwSize + MAKELONG(delta, 0);

                    // Fixup the resource table
                    fileOut.Seek (wCurNameOffset, CFile::begin);
                    wCurResDataBegin = LOWORD(dwCurResDataBegin>>wAlignShift);
                    fileOut.Write ((WORD*)&wCurResDataBegin, sizeof(WORD));
                    wSize = LOWORD (dwSize>>wAlignShift);
                    fileOut.Write ((WORD*)&wSize, sizeof(WORD));

                    if (lpImageBuf) delete []lpImageBuf;

                    // Update the current resource data beginning
                    dwCurResDataBegin = dwCurResDataBegin + dwSize;
                }

                // Update the current NameInfo record offset
                wCurNameOffset = wCurNameOffset + 12;
                // Move file pointer to the next NameInfo record
                fileIn.Seek (wCurNameOffset, CFile::begin);
            }

            // Update the current TypeInfo record offset
            wCurTypeOffset = wCurTypeOffset + 8 + wResCount * 12;
            // Move file pointer to the next TypeInfo record
            fileIn.Seek (wCurTypeOffset, CFile::begin);
            // Read the next TypeId
            fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));
        }
    }

    // Get segment table offset
    fileIn.Seek (wWinHeaderOffset+0x001c, CFile::begin);
    fileIn.Read ((WORD*)&wNumOfSegments, sizeof(WORD));
    fileIn.Seek (wWinHeaderOffset+0x0022, CFile::begin);
    fileIn.Read ((WORD*)&wSegmentTableOffset, sizeof(WORD));

    // Find the beginning of the LoadOnCall code segments in the src exe file
    wLoadOnCallCodeBegin = 0xffff;
    for (i=0; i<wNumOfSegments; i++) {
        fileIn.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i+4, CFile::begin);
        fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
        if (!(wFlags & 0x0040)) {
            fileIn.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i, CFile::begin);
            fileIn.Read ((WORD*)&wOffset, sizeof(WORD));

            // In the file winoa386.mod we have a LoadOnCall segment that doesn't exist.
            // We have to check for this before go on
            if (wOffset)
                wLoadOnCallCodeBegin = (wOffset < wLoadOnCallCodeBegin) ? wOffset:wLoadOnCallCodeBegin;
        }
    }

    // Calculate the delta between the new beginning and the old beginnning
    // of the LoadOnCall code segments
    if (wResDataBegin != 0xffff && wLoadOnCallCodeBegin != 0xffff) { // Both LoadOnCall code and FastLoad
        wCurResDataBegin = LOWORD(dwCurResDataBegin>>wAlignShift);
        delta =  wCurResDataBegin - wLoadOnCallCodeBegin;
    } else if (wResDataBegin != 0xffff && wLoadOnCallResDataBegin != 0xffff) { // Both LoadOnCall and FastLoad Resources
        wCurResDataBegin = LOWORD(dwCurResDataBegin>>wAlignShift);
        delta =  wCurResDataBegin - wLoadOnCallResDataBegin;
    } else if (wResDataBegin != 0xffff) { // Only FastLoad Resources
        wCurResDataBegin = LOWORD((dwCurResDataBegin-dwSize)>>wAlignShift);
        delta =  wCurResDataBegin - wResDataBegin;
    } else delta = 0;

    dwLoadOnCallCodeBegin = MAKELONG (wLoadOnCallCodeBegin, 0) << wAlignShift;

    // Change the length for preload area
    if (wResDataBegin != 0xffff) {
        fileIn.Seek (wWinHeaderOffset+0x003a, CFile::begin);
        fileIn.Read ((WORD*)&wOffset, sizeof(WORD));
        wOffset += delta;

        fileOut.Seek (wWinHeaderOffset+0x003a, CFile::begin);
        fileOut.Write ((WORD*)&wOffset, sizeof(WORD));
    }

    if (wLoadOnCallCodeBegin != 0xffff && delta) {
        // Write LoadOnCall segments
        fileIn.Seek (dwLoadOnCallCodeBegin, CFile::begin);
        fileOut.Seek (dwCurResDataBegin, CFile::begin);
        LONG lLeft;
        if (wLoadOnCallResDataBegin != 0xffff)
            lLeft = MAKELONG (wLoadOnCallResDataBegin - wLoadOnCallCodeBegin, 0) << wAlignShift;
        else
            lLeft = (fileIn.GetLength () - (MAKELONG (wLoadOnCallCodeBegin, 0))) << wAlignShift;

        WORD wRead = 0;
        BYTE far * pBuf = (BYTE far *) new BYTE[32739];

        if (!pBuf) {
            FreeLibrary(hDllInst);
            return ERROR_NEW_FAILED;
        }

        while (lLeft>0) {
            wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
            if (wRead!= fileIn.Read( pBuf, wRead)) {
                delete []pBuf;
                FreeLibrary(hDllInst);
                return ERROR_FILE_READ;
            }
            fileOut.Write( pBuf, wRead );
            lLeft -= wRead;
        }
        delete []pBuf;

        // Fixup the segment table
        for (i=0; i<wNumOfSegments; i++) {
            fileIn.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i+4, CFile::begin);
            fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
            if (!(wFlags & 0x0040)) {
                fileIn.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i, CFile::begin);
                fileIn.Read ((WORD*)&wOffset, sizeof(WORD));
                wOffset = wOffset + delta;
                fileOut.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i, CFile::begin);
                fileOut.Write ((WORD*)&wOffset, sizeof(WORD));
            }
        }
    }

    if (wLoadOnCallResDataBegin != 0xffff) {
        // Read the first type ID again
        fileIn.Seek (wWinHeaderOffset+wResTableOffset+2, CFile::begin);
        fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));

        // Save the Offset of the current TypeInfo record
        wCurTypeOffset = wWinHeaderOffset + wResTableOffset + 2;

        // Calc the beginning of the LoadOnCall resources
        dwCurResDataBegin = (MAKELONG (wLoadOnCallResDataBegin + delta, 0))<<wAlignShift;

        // Loop through the TypeInfo table again to write LoadOnCall resources
        while (wTypeId) {
            // Get Name of ord
            if (!(wTypeId & 0x8000)) {
                // It is a Offset to a string
                dwTypeId = (MAKELONG(wTypeId, 0)); //<<wAlignShift;
                fileIn.Seek (wWinHeaderOffset+wResTableOffset+dwTypeId, CFile::begin);
                // Get the character count for the ID string
                fileIn.Read ((BYTE*)&nCharCount, sizeof(BYTE));
                // Read the ID string
                fileIn.Read (szTypeId, nCharCount);
                // Put null at the end of the string
                szTypeId[nCharCount] = 0;
                // Set wTypeId to zero
                wTypeId = 0;
            } else {
                // It is an ID
                // Turn off the high bit
                wTypeId = wTypeId & 0x7FFF;
                if ( 0 == wTypeId)
                    return ERROR_RW_INVALID_FILE;

                // Set the ID string to null
                szTypeId[0] = 0;
            }

            // Restore the file read point
            fileIn.Seek (wCurTypeOffset+2, CFile::begin);

            // Get the count for this type of resource
            fileIn.Read ((WORD*)&wResCount, sizeof(WORD));

            // Pass the reserved DWORD
            fileIn.Seek (4, CFile::current);

            // Save the Offset of the current NameInfo record
            wCurNameOffset = wCurTypeOffset + 8;

            // Loop through NameInfo records
            for (i = 0; i < wResCount; i++) {
                // Read resource offset
                fileIn.Read ((WORD*)&wFileOffset, sizeof(WORD));
                // Read resource length
                fileIn.Read ((WORD*)&wSize, sizeof(WORD));
                // Read the flags
                fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
                // Read resource ID
                fileIn.Read ((WORD*)&wNameId, sizeof(WORD));

                if (!(wFlags & 0x0040)) {
                    // Get name of ord
                    if (!(wNameId & 0x8000)) {
                        // It is a Offset to a string
                        fileIn.Seek (wWinHeaderOffset+wResTableOffset+wNameId, CFile::begin);
                        // Get the character count for the string
                        fileIn.Read ((BYTE*)&nCharCount, sizeof(BYTE));
                        // Read the string
                        fileIn.Read (szNameId, nCharCount);
                        // Put null at the end of the string
                        szNameId[nCharCount] = 0;
                        // Set wNameId to zero
                        wNameId = 0;
                    } else {
                        // It is an ID
                        // Turn off the high bit
                        wNameId = wNameId & 0x7FFF;
                        if (0 == wNameId)
                            return ERROR_RW_INVALID_FILE;

                        // Set the string to null
                        szNameId[0] = 0;
                    }

                    dwSize = (MAKELONG (wSize, 0))<<wAlignShift;
                    dwFileOffset = (MAKELONG (wFileOffset, 0))<<wAlignShift;

                    // Now we got the Type and Name here and size

                    // Get the image from the IODLL
                    if (dwSize)
                        lpImageBuf = new BYTE[dwSize];
                    else lpImageBuf = LPNULL;
                    LPSTR   lpType = LPNULL;
                    LPSTR   lpRes = LPNULL;

                    if (wTypeId)
                        lpType = (LPSTR)((WORD)wTypeId);
                    else
                        lpType = &szTypeId[0];

                    if (wNameId)
                        lpRes = (LPSTR)((WORD)wNameId);
                    else
                        lpRes = &szNameId[0];

                    dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
                                                       lpType,
                                                       lpRes,
                                                       (DWORD)-1,
                                                       lpImageBuf,
                                                       dwSize
                                                    );

                    if (dwImageBufSize>dwSize ) {
                        // The buffer is too small
                        delete []lpImageBuf;
                        lpImageBuf = new BYTE[dwImageBufSize];
                        dwSize = (*lpfnGetImage)(  hResFileModule,
                                                   lpType,
                                                   lpRes,
                                                   (DWORD)-1,
                                                   lpImageBuf,
                                                   dwImageBufSize
                                                );
                        if ((dwSize-dwImageBufSize)!=0 ) {
                            delete []lpImageBuf;
                            lpImageBuf = LPNULL;
                        }
                    }

                    // Try to see if we have to set the memory to 0
                    if ((int)(dwSize-dwImageBufSize)>0)
                        memset(lpImageBuf+dwImageBufSize, 0, (size_t)(dwSize-dwImageBufSize));

                    // Write the image
                    fileOut.Seek (dwCurResDataBegin, CFile::begin);
                    WriteImage( &fileOut, lpImageBuf, dwSize);

                    // Fix the alignment for resource data
                    DWORD dwTmp = 1;
                    delta = (short)((((dwSize+(dwTmp<<wAlignShift)-1)>>wAlignShift)<<wAlignShift)-dwSize);
                    BYTE nByte = 0;

                    fileOut.Seek (dwCurResDataBegin+dwSize, CFile::begin);
                    for (j=0; j<delta; j++)
                        fileOut.Write ((BYTE*)&nByte, sizeof(BYTE));

                    dwSize = dwSize + MAKELONG(delta, 0);

                    // Fixup the resource table
                    fileOut.Seek (wCurNameOffset, CFile::begin);
                    wCurResDataBegin = LOWORD(dwCurResDataBegin>>wAlignShift);
                    fileOut.Write ((WORD*)&wCurResDataBegin, sizeof(WORD));
                    wSize = LOWORD (dwSize>>wAlignShift);
                    fileOut.Write ((WORD*)&wSize, sizeof(WORD));

                    if (lpImageBuf) delete []lpImageBuf;

                    // Update the current resource data beginning
                    dwCurResDataBegin = dwCurResDataBegin + dwSize;
                }

                // Update the current NameInfo record offset
                wCurNameOffset = wCurNameOffset + 12;
                // Move file pointer to the next NameInfo record
                fileIn.Seek (wCurNameOffset, CFile::begin);
            }

            // Update the current TypeInfo record offset
            wCurTypeOffset = wCurTypeOffset + 8 + wResCount * 12;
            // Move file pointer to the next TypeInfo record
            fileIn.Seek (wCurTypeOffset, CFile::begin);
            // Read the next TypeId
            fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));
        }
    }

    fileIn.Close();
    fileOut.Close();
    FreeLibrary(hDllInst);

    return uiError;
}

extern "C"
UINT
APIENTRY
RWUpdateImage(
             LPCSTR  lpszType,
             LPVOID  lpNewBuf,
             DWORD   dwNewSize,
             LPVOID  lpOldImage,
             DWORD   dwOldImageSize,
             LPVOID  lpNewImage,
             DWORD*  pdwNewImageSize
             )
{
    UINT uiError = ERROR_NO_ERROR;

    // The Type we can parse are only the standard ones
    switch ((UINT)LOWORD(lpszType)) {
        case 4:
            if (lpOldImage)
                uiError = UpdateMenu( lpNewBuf, dwNewSize,
                                      lpOldImage, dwOldImageSize,
                                      lpNewImage, pdwNewImageSize );
            else uiError = GenerateMenu( lpNewBuf, dwNewSize,
                                         lpNewImage, pdwNewImageSize );
            break;
        case 5:
            if (lpOldImage)
                uiError = UpdateDialog( lpNewBuf, dwNewSize,
                                        lpOldImage, dwOldImageSize,
                                        lpNewImage, pdwNewImageSize );
            else uiError = GenerateDialog( lpNewBuf, dwNewSize,
                                           lpNewImage, pdwNewImageSize );
            break;
        case 6:
            if (lpOldImage)
                uiError = UpdateString( lpNewBuf, dwNewSize,
                                        lpOldImage, dwOldImageSize,
                                        lpNewImage, pdwNewImageSize );
            else uiError = GenerateString( lpNewBuf, dwNewSize,
                                           lpNewImage, pdwNewImageSize );
            break;
        case 9:
            if (lpOldImage)
                uiError = UpdateAccel( lpNewBuf, dwNewSize,
                                       lpOldImage, dwOldImageSize,
                                       lpNewImage, pdwNewImageSize );
            else {
                *pdwNewImageSize = 0L;
                uiError = ERROR_RW_NOTREADY;
            }
            break;
#ifdef VB
        case 10:
            if (lpOldImage)
                uiError = UpdateVBData( lpNewBuf, dwNewSize,
                                        lpOldImage, dwOldImageSize,
                                        lpNewImage, pdwNewImageSize );
            else {
                *pdwNewImageSize = 0L;
                uiError = ERROR_RW_NOTREADY;
            }
            break;
#endif

        case 16:
            if (lpOldImage)
                uiError = UpdateVerst( lpNewBuf, dwNewSize,
                                       lpOldImage, dwOldImageSize,
                                       lpNewImage, pdwNewImageSize );
            else {
                *pdwNewImageSize = 0L;
                uiError = ERROR_RW_NOTREADY;
            }
            break;
        default:
            *pdwNewImageSize = 0L;
            uiError = ERROR_RW_NOTREADY;
            break;
    }

    return uiError;
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation

static UINT GenerateFile( LPCSTR        lpszTgtFilename,
                          HANDLE        hResFileModule,
                          LPVOID        lpBuffer,
                          UINT      uiSize,
                          HINSTANCE   hDllInst
                        )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = LPNULL;
    UINT uiBufSize = uiSize;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile fileOut;

    if (!fileOut.Open(lpszTgtFilename, CFile::shareDenyNone | CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
        return ERROR_FILE_CREATE;

    // Get the pointer to the function
    if (!hDllInst)
        return ERROR_DLL_LOAD;

    DWORD (FAR PASCAL    * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
    // Get the pointer to the function to extract the resources image
    lpfnGetImage = (DWORD (FAR PASCAL   *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
                   GetProcAddress( hDllInst, "RSGetResImage" );
    if (lpfnGetImage==NULL) {
        return ERROR_DLL_PROC_ADDRESS;
    }


    WORD wUpdTypeId = 0;
    static char szUpdTypeId[128];

    WORD wUpdNameId;
    static char szUpdNameId[128];

    DWORD dwUpdLang;
    DWORD dwUpdSize;

    UINT uiBufStartSize = uiBufSize;
    DWORD dwImageBufSize;
    BYTE far * lpImageBuf;
    while (uiBufSize>0) {
        if ((!wUpdTypeId) && (uiBufSize))
            GetUpdatedRes( &lpBuffer,
                           &uiBufSize,
                           &wUpdTypeId, &szUpdTypeId[0],
                           &wUpdNameId, &szUpdNameId[0],
                           &dwUpdLang,
                           &dwUpdSize
                         );

        // The resource has been updated get the image from the IODLL
        if (dwUpdSize) {
            lpImageBuf = new BYTE[dwUpdSize];
            LPSTR   lpType = LPNULL;
            LPSTR   lpRes = LPNULL;
            if (wUpdTypeId) {
                lpType = (LPSTR)((WORD)wUpdTypeId);
            } else {
                lpType = &szUpdTypeId[0];
            }
            if (wUpdNameId) {
                lpRes = (LPSTR)((WORD)wUpdNameId);
            } else {
                lpRes = &szUpdNameId[0];
            }

            dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
                                               lpType,
                                               lpRes,
                                               dwUpdLang,
                                               lpImageBuf,
                                               dwUpdSize
                                            );
            if (dwImageBufSize>dwUpdSize ) {
                // The buffer is too small
                delete []lpImageBuf;
                lpImageBuf = new BYTE[dwImageBufSize];
                dwUpdSize = (*lpfnGetImage)(  hResFileModule,
                                              lpType,
                                              lpRes,
                                              dwUpdLang,
                                              lpImageBuf,
                                              dwImageBufSize
                                           );
                if ((dwUpdSize-dwImageBufSize)!=0 ) {
                    delete []lpImageBuf;
                    lpImageBuf = LPNULL;
                }
            }


            WriteHeader(&fileOut,
                        wUpdTypeId, &szUpdTypeId[0],
                        wUpdNameId, &szUpdNameId[0],
                        0l);

            WriteImage( &fileOut,
                        lpImageBuf, dwImageBufSize);

            if (lpImageBuf) delete []lpImageBuf;
            wUpdTypeId = 0;

        } else wUpdTypeId = 0;

    }

    fileOut.Close();

    return uiError;
}

static UINT CopyFile( CFile* pfilein, CFile* pfileout )
{
    LONG lLeft = pfilein->GetLength();
    WORD wRead = 0;
    DWORD dwOffset = 0;
    BYTE far * pBuf = (BYTE far *) new BYTE[32739];

    if (!pBuf)
        return ERROR_NEW_FAILED;

    while (lLeft>0) {
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!= pfilein->Read( pBuf, wRead)) {
            delete []pBuf;
            return ERROR_FILE_READ;
        }
        pfileout->Write( pBuf, wRead );
        lLeft -= wRead;
        dwOffset += wRead;
    }
    delete []pBuf;
    return ERROR_NO_ERROR;
}

static UINT GetUpdatedRes(
                         LPVOID far * lplpBuffer,
                         UINT* uiSize,
                         WORD* wTypeId, LPSTR lplpszTypeId,
                         WORD* wNameId, LPSTR lplpszNameId,
                         DWORD* dwLang, DWORD* dwSize )
{
    BYTE far * lpBuf = (BYTE far *)*lplpBuffer;

    *wTypeId = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    strcpy( lplpszTypeId, (char *)lpBuf);
    lpBuf += strlen(lplpszTypeId)+1;

    *wNameId = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    strcpy( lplpszNameId, (char *)lpBuf);
    lpBuf += strlen(lplpszNameId)+1;

    *dwLang = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    *dwSize = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    *uiSize -= (UINT)((lpBuf-(BYTE far *)*lplpBuffer));
    *lplpBuffer = (LPVOID)lpBuf;
    return 0;
}

static
UINT
GetUpdatedItem(
              LPVOID far * lplpBuffer,
              LONG* dwSize,
              WORD* wX, WORD* wY,
              WORD* wcX, WORD* wcY,
              DWORD* dwPosId,
              DWORD* dwStyle, DWORD* dwExtStyle,
              LPSTR lpszText)
{
    BYTE far * far * lplpBuf = (BYTE far * far *)lplpBuffer;
    UINT uiSize = GetWord( lplpBuf, wX, dwSize );

    uiSize += GetWord( lplpBuf, wY, dwSize );
    uiSize += GetWord( lplpBuf, wcX, dwSize );
    uiSize += GetWord( lplpBuf, wcY, dwSize );
    uiSize += GetDWord( lplpBuf, dwPosId, dwSize );
    uiSize += GetDWord( lplpBuf, dwStyle, dwSize );
    uiSize += GetDWord( lplpBuf, dwExtStyle, dwSize );
    uiSize += GetString( lplpBuf, lpszText, dwSize );

    return uiSize;

    /*
    *wX = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    *wY = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    *wcX = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    *wcY = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    *dwPosId = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    *dwStyle = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    *dwExtStyle = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    strcpy( lpszText, (char *)lpBuf);
    lpBuf += strlen(lpszText)+1;

    *dwSize -= (lpBuf-(BYTE far *)*lplpBuffer);
    *lplpBuffer = lpBuf;
    return 0;*/
}


static UINT
GetResInfo( CFile* pfile,
            WORD* pwTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
            WORD* pwNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
            WORD* pwFlags,
            DWORD* pdwSize, DWORD* pdwFileOffset )
{
    static UINT uiSize;
    static LONG lOfsCheck;
    // get the Type info
    uiSize = GetNameOrOrdFile( pfile, pwTypeId, lpszTypeId, bMaxTypeLen);
    if (!uiSize)
        return 0;

    // get the Name info
    uiSize = GetNameOrOrdFile( pfile, pwNameId, lpszNameId, bMaxNameLen);
    if (!uiSize)
        return 0;

    // Skip the Flag
    pfile->Read( pwFlags, 2 );

    // get the size
    pfile->Read( pdwSize, 4 );
    if (*pdwSize==0)
        // size id 0 the resource file is corrupted or is not a res file
        return 0;

    *pdwFileOffset = pfile->GetPosition();

    // check if the size is valid
    TRY {
        lOfsCheck = pfile->Seek(*pdwSize, CFile::current);
    } CATCH(CFileException, e) {
        // Check is the right exception
        return 0;
    } END_CATCH
    if (lOfsCheck!=(LONG)(*pdwFileOffset+*pdwSize))
        return 0;
    return 1;
}

static UINT WriteHeader(
                       CFile* pFile,
                       WORD wTypeId, LPSTR lpszTypeId,
                       WORD wNameId, LPSTR lpszNameId,
                       WORD wFlags )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE bFF = 0xFF;
    if (wTypeId) {
        // It is an ordinal

        pFile->Write( &bFF, 1 );
        pFile->Write( &wTypeId, 2 );
    } else {
        pFile->Write( lpszTypeId, strlen(lpszTypeId)+1 );
    }

    if (wNameId) {
        // It is an ordinal
        pFile->Write( &bFF, 1 );
        pFile->Write( &wNameId, 2 );
    } else {
        pFile->Write( lpszNameId, strlen(lpszNameId)+1 );
    }

    pFile->Write( &wFlags, 2 );

    return uiError;
}

static UINT WriteImage(
                      CFile* pFile,
                      LPVOID lpImage, DWORD dwSize )
{
    UINT uiError = ERROR_NO_ERROR;
    if (lpImage) {
//      pFile->Write( &dwSize, sizeofDWord );
        pFile->Write( lpImage, (UINT)dwSize );
    }
    return uiError;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function Implementation
static UINT GetNameOrOrdFile( CFile* pfile, WORD* pwId, LPSTR lpszId, BYTE bMaxStrLen )
{
    UINT uiSize = 0;

    *pwId = 0;

    // read the first BYTE to see if it is a string or an ordinal
    pfile->Read( pwId, sizeof(BYTE) );
    if (LOBYTE(*pwId)==0xFF) {
        // This is an Ordinal
        pfile->Read( pwId, sizeofWord );
        *lpszId = '\0';
        uiSize = 2;
    } else {
        uiSize++;
        *lpszId = LOBYTE(*pwId);
        while ((*lpszId++) && (bMaxStrLen-2)) {
            pfile->Read( pwId, sizeof(BYTE) );
            *lpszId = LOBYTE(*pwId);
            uiSize++;
            bMaxStrLen--;
        }
        if ( (!(bMaxStrLen-2)) && (*pwId) ) {
            // Failed
            return 0;
        }
    }
    return uiSize;
}

static
UINT
ParseCursor( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for a Cursor to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;

    LONG dwOverAllSize = 0L;

    // Cursor Items
    WORD wWidth = 0;
    WORD wHeight = 0;
    WORD wPlanes = 0;
    WORD wBitCount = 0;
    DWORD dwBytesInRes = 0;
    WORD wImageIndex = 0;

    // Get the CURSOR DIR ENTRY
    GetWord( &lpImage, &wWidth, &dwImageSize );
    GetWord( &lpImage, &wHeight, &dwImageSize );
    GetWord( &lpImage, &wPlanes, &dwImageSize );
    GetWord( &lpImage, &wBitCount, &dwImageSize );
    GetDWord( &lpImage, &dwBytesInRes, &dwImageSize );
    GetWord( &lpImage, &wImageIndex, &dwImageSize );

    //SkipByte( &lpImage, 4, &dwImageSize );
    //BITMAPINFO
    BITMAPINFOHEADER* pBmpInfHead = (BITMAPINFOHEADER*) lpImage;
    UINT uiSize = sizeof(BITMAPINFOHEADER);
    SkipByte( &lpImage, uiSize, &dwImageSize );
    /*

    // Get the Width
    SkipByte( &lpImage, 4, &dwImageSize );


    // Menu Items
    WORD fItemFlags;
    WORD wMenuId;
    CString szCaption;

    while(dwImageSize>0) {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a menu
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);

        // Let's get the Menu flags
        GetWord( &lpImage, &fItemFlags, &dwImageSize );

        if ( !(fItemFlags & MF_POPUP) )
            // Get the menu Id
            GetWord( &lpImage, &wMenuId, &dwImageSize );
        else wMenuId = -1;

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fItemFlags, &dwBufSize);
        //Put the MenuId
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)wMenuId, &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)(lpItem+uiOffset), &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        // Get the text
        // calculate were the string is going to be
        // Will be the fixed header+the pointer
        dwOverAllSize += CopyText( &lpBuf, &lpImage, &dwBufSize, &dwImageSize );

        // Put the size of the resource
        if (dwBufSize>=0) {
            uiOffset += strlen((LPSTR)(lpItem+uiOffset))+1;
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }

        // Move to the next position
        lpItem = lpBuf;
        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==(dwImageSize))
                dwImageSize = -1;
        }
    }
    */

    return (UINT)(dwOverAllSize);
}

static
UINT
ParseBitmap( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    // we will return just one item so the iodll will handle this resource as
    // something valid. We will not bother doing anything else. The only thing
    // we are interesed is the raw data in the immage, but if we don't return at
    // least one item IODLL will consider the resource empty.
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;
    LONG dwOverAllSize = 0;

    TRACE1("ParseBitmap: dwISize=%ld\n", dwISize);

    dwOverAllSize += PutDWord( &lpBuf, sizeof(RESITEM), &dwBufSize);

    // We have the size and pos in a cursor but we are not interested now
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

    // we don't have checksum and style
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    //Put the Flag
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // The ID will be just 1
    dwOverAllSize += PutDWord( &lpBuf, 1, &dwBufSize);

    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage or the font name
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

    // Let's put null were we don;t have the strings
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

    // we just return. This is enough for IODLL
    return (UINT)(dwOverAllSize);
}

static
UINT
ParseIcon( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for an Icon to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    BITMAPINFOHEADER* pBmpInfo = (BITMAPINFOHEADER*) lpImage;
    // difficult it will be bigger than UINT_MAX
    SkipByte( &lpImage, (UINT)pBmpInfo->biSize, &dwImageSize );

    RGBQUAD* pRgbQuad = (RGBQUAD*) lpImage;
    SkipByte( &lpImage, sizeof(RGBQUAD), &dwImageSize );

    // Calculate CheckSum on the image
    DWORD dwCheckSum = 0l;
    BYTE * hp = (BYTE *) lpImage;

    for ( DWORD dwLen = pBmpInfo->biSizeImage; dwLen; dwLen--)
        dwCheckSum = (dwCheckSum << 8) | *hp++;


    // Fixed field
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

    // We don't have the size and pos in a menu
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)pBmpInfo->biWidth, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)pBmpInfo->biHeight, &dwBufSize);

    // we don't have checksum and style
    dwOverAllSize += PutDWord( &lpBuf, dwCheckSum, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);


    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage or the font name
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

    // Let's put null were we don;t have the strings
    uiOffset = sizeof(RESITEM);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);


    // Put the size of the resource
    if (dwBufSize>=0) {
        lDummy = 8;
        PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
    }


    return (UINT)(dwOverAllSize);
}

static int
GetVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK* pver)
{
    // We have to hard code the language filed because otherwise, due to some
    // inconsistent RC compiler, the Image are not following any standard.
    // We assume that all the block but the one hard-coded here are binary and
    // we just skip them
    WORD wHead = 0;
    WORD wPad = 0;
    WORD wValue = 0;
    pver->pValue = *lplpImage;

    // Read the header of the block
    wHead = GetWord( lplpImage, &pver->wBlockLen, pdwSize );
    wHead += GetWord( lplpImage, &pver->wValueLen, pdwSize );
    // The Key name is all the time a NULL terminated string
    wHead += (WORD)GetString( lplpImage, &pver->szKey[0], pdwSize );
    pver->wHead = wHead;

    // See if we have padding after the header. We can check on wHead because
    // we need an allignment on a DWORD boundary and we have 2 WORD+the string.
    wPad = SkipByte( lplpImage, Pad4(wHead), pdwSize );

    // Fix the pointer to the value
    pver->pValue = (pver->pValue+wHead+wPad);

    if ((int)pver->wValueLen>*pdwSize) {
        // There is an error
        wPad += SkipByte( lplpImage, (UINT)*pdwSize, pdwSize );
        return wHead+wPad;
    }

    // Now we check the key name and if is one of the one we accept as good
    // we read the string. Otherwise we just skip the value field
    if ( !strcmp(pver->szKey,"Comments") ||
         !strcmp(pver->szKey,"CompanyName") ||
         !strcmp(pver->szKey,"FileDescription") ||
         !strcmp(pver->szKey,"FileVersion") ||
         !strcmp(pver->szKey,"InternalName") ||
         !strcmp(pver->szKey,"LegalCopyright") ||
         !strcmp(pver->szKey,"LegalTrademarks") ||
         !strcmp(pver->szKey,"OriginalFilename") ||
         !strcmp(pver->szKey,"PrivateBuild") ||
         !strcmp(pver->szKey,"ProductName") ||
         !strcmp(pver->szKey,"ProductVersion") ||
         !strcmp(pver->szKey,"SpecialBuild") ||
         !strcmp(pver->szKey,"StringFileInfo")  // found in a Borland Version resource
       ) {
        if (!strcmp(pver->szKey,"StringFileInfo") && !pver->wValueLen) {
            pver->wType = 0;
            wValue=0;
        } else {
            // It is a standard key name read the string.
            // Set the flag to show it is a string
            pver->wType = 1;
            wValue = (WORD)GetVSString( lplpImage, &pver->szValue[0], pdwSize, pver->wValueLen );
        }

        // check if this is the LegalCopyright block.
        // If it is then there might be a null in the middle of the string
        if (!strcmp(pver->szKey,"LegalCopyright")) {
            // we just skip the rest. This need to be fixed in the RC, not here
            if ((int)(pver->wValueLen-wValue)>0)
                wValue += SkipByte( lplpImage, pver->wValueLen-wValue, pdwSize );
        }

    } else {
        // It isn't a string, or if is is not a standard key name, skip it
        pver->wType = 0;
        *pver->szValue = '\0';
        wValue = SkipByte( lplpImage, pver->wValueLen, pdwSize );
    }

    // Check the padding
    wPad += SkipByte( lplpImage, Pad4(wValue), pdwSize );

    // Even if it look what we have done should be enough we have to walk the image
    // skiping the NULL char that sometimes the comipler place there.
    // Do this only if it is not the translation field.
    // The translation field is the last so we might have some image padding
    if (strcmp(pver->szKey, "Translation")) {
        WORD wSkip = 0;
        BYTE far * lpTmp = *lplpImage;

        if (*lplpImage)
            while (!**lplpImage && *pdwSize) {
                wSkip += SkipByte(lplpImage, 1, pdwSize);
            }

        if (Pad4(wSkip)) {
            *lplpImage = lpTmp;
            *pdwSize += wSkip;
        } else wPad += wSkip;
    }

    return wHead+wValue+wPad;
}

static int
GetVSBlockOld( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK* pver)
{
    WORD wHead = 0;
    WORD wPad = 0;
    WORD wValue = 0;
    LONG lValueLen = 0;
    pver->pValue = *lplpImage;
    wHead = GetWord( lplpImage, &pver->wBlockLen, pdwSize );
    wHead += GetWord( lplpImage, &pver->wValueLen, pdwSize );
    wHead += (WORD)GetString( lplpImage, &pver->szKey[0], pdwSize );

    pver->wHead = wHead;

    wPad = SkipByte( lplpImage, Pad4(wHead), pdwSize );

    lValueLen = pver->wValueLen;
    if (lValueLen>*pdwSize) {
        // There is an error
        wPad += SkipByte( lplpImage, (UINT)*pdwSize, pdwSize );
        return wHead+wPad;
    }

    pver->wType = 0;
    pver->pValue = (pver->pValue+wHead+wPad);
    if (pver->wValueLen) {
        wValue = (WORD)GetString( lplpImage, &pver->szValue[0], &lValueLen );
        *pdwSize -= wValue;
        pver->wType = 1;
    }
    if (wValue!=pver->wValueLen) {
        // Just skip the value. It isn't a string, is a value
        if (pver->wValueLen-wValue!=1) {
            *pver->szValue = '\0';
            pver->wType = 0;
        }
        wPad += SkipByte( lplpImage, pver->wValueLen-wValue, pdwSize );
    }

    wPad += SkipByte( lplpImage, Pad4(pver->wValueLen), pdwSize );

    return wHead+wPad+wValue;
}

static int
PutVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK ver,
            LPSTR lpStr, BYTE far * far * lplpBlockSize, WORD* pwTrash)

{
    // We have to write the info in the VER_BLOCK in the new image
    // We want to remember were the block size field is so we can update it later

    WORD wHead = 0;
    WORD wValue = 0;
    WORD wPad = Pad4(ver.wHead);
    *pwTrash = 0;

    // Get the pointer to the header of the block
    BYTE far * pHead = ver.pValue-ver.wHead-wPad;
    BYTE far * lpNewImage = *lplpImage;

    // Copy the header of the block to the new image
    wHead = ver.wHead;
    if (*pdwSize>=(int)ver.wHead) {
        memcpy( *lplpImage, pHead, ver.wHead );
        *pdwSize -= ver.wHead;
        lpNewImage += ver.wHead;
    } else *pdwSize = -1;

    // Check if padding is needed
    if (*pdwSize>=(int)wPad) {
        memset( *lplpImage+ver.wHead, 0, wPad );
        *pdwSize -= wPad;
        lpNewImage += wPad;
    } else *pdwSize = -1;

    // Store the pointer to the block size WORD
    BYTE far * pBlockSize = *lplpImage;

    // Check if the value is a string or a BYTE array
    if (ver.wType) {
        // it is a string, copy the updated item
        wValue = strlen(lpStr)+1;
        if (*pdwSize>=(int)wValue) {
            memcpy(*lplpImage+wHead+wPad, lpStr, wValue);
            *pdwSize -= wValue;
            lpNewImage += wValue;
        } else *pdwSize = -1;

        // Check if padding is needed
        int wPad1 = Pad4(wValue);
        if (*pdwSize>=wPad1) {
            memset( *lplpImage+ver.wHead+wValue+wPad, 0, wPad1 );
            *pdwSize -= wPad1;
            lpNewImage += wPad1;
        } else *pdwSize = -1;

        *pwTrash = Pad4(ver.wValueLen);
        wValue += (WORD)wPad1;

        // Fix to the strange behaviour of the ver.dll
        if ((wPad1) && (wPad1>=(int)*pwTrash)) {
            wValue -= *pwTrash;
        } else *pwTrash = 0;
        // Fix up the Value len field. We will put the len of the value + padding
        if (*pdwSize>=0)
            memcpy( pBlockSize+2, &wValue, 2);

    } else {
        // it is an array, just copy it in the new image buffer
        wValue = ver.wValueLen;
        if (*pdwSize>=(int)ver.wValueLen) {
            memcpy(*lplpImage+wHead+wPad, ver.pValue, ver.wValueLen);
            *pdwSize -= ver.wValueLen;
            lpNewImage += ver.wValueLen;
        } else *pdwSize = -1;

        // Check if padding is needed
        if (*pdwSize>=(int)Pad4(ver.wValueLen)) {
            memset( *lplpImage+ver.wHead+ver.wValueLen+wPad, 0, Pad4(ver.wValueLen) );
            *pdwSize -= Pad4(ver.wValueLen);
            lpNewImage += Pad4(ver.wValueLen);
        } else *pdwSize = -1;
        wPad += Pad4(ver.wValueLen);
    }

    *lplpBlockSize = pBlockSize;
    *lplpImage = lpNewImage;
    return wPad+wValue+wHead;
}

static
UINT ParseVerst( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    TRACE("ParseVersion Stamp: \n");
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
    char far * lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));
    LONG dwOverAllSize = 0L;

    WORD wPos = 0;

    static VER_BLOCK verBlock;

    while (dwImageSize>0) {
        wPos++;
        GetVSBlock( &lpImage, &dwImageSize, &verBlock);

        // check if this is the translation block
        if (!strcmp(verBlock.szKey, "Translation" )) {
            // This is the translation block let the localizer have it for now
            DWORD dwCodeLang = 0;
            LONG lDummy = 4;
            GetDWord( &verBlock.pValue, &dwCodeLang, &lDummy);

            // Put the value in the string value
            wsprintf( &verBlock.szValue[0], "%#08lX", dwCodeLang );
        }

        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in an accelerator
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        // we will need to calculate the correct ID for mike
        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, wPos, &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        lpResItem->lpszClassName = strcpy( lpStrBuf, verBlock.szKey );
        lpStrBuf += strlen(lpResItem->lpszClassName)+1;

        lpResItem->lpszCaption = strcpy( lpStrBuf, verBlock.szValue );
        lpStrBuf += strlen(lpResItem->lpszCaption)+1;


        // Put the size of the resource
        if (dwBufSize>0) {
            uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
        }

        // Check if we are alligned
        uiOffset += Allign( (BYTE**)&lpStrBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += uiOffset-sizeof(RESITEM);
        lpResItem->dwSize = (DWORD)uiOffset;


        // Move to the next position
        lpResItem = (LPRESITEM) lpStrBuf;
        lpBuf = (BYTE far *)lpStrBuf;
        lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==(dwImageSize))
                dwImageSize = -1;
        }
    }
    return (UINT)(dwOverAllSize);
}

static void GenerateTransField( WORD wLang, VER_BLOCK * pVer )
{
    // Get the DWORD value
    DWORD dwValue = GenerateTransField( wLang, TRUE );
    char buf[9];

    // Put the value in the string value
    wsprintf( &buf[0], "%08lX", dwValue );

    // Just check if we are in the right place. Should never have problem
    if (strlen(pVer->szKey)==8) {
        //strcpy( pVer->szKey, buf );
        // We have to change the header in the image, not just the
        // szKey field
        // Get the pointer to he begin of the filed
        WORD wPad = Pad4(pVer->wHead);
        BYTE far * pHead = pVer->pValue-pVer->wHead-wPad;
        pHead += 4; // Move at the begin of the string
        strcpy( (char*)pHead, buf );
    }
}

static DWORD GenerateTransField(WORD wLang, BOOL bReverse)
{
    // we have to generate a table to connect
    // the language with the correct code page

    WORD wCP = 0;
    DWORD dwRet = 0;
    switch (wLang) {
        // Just have a big switch to assign the codepage
        case 0x1401: wCP =  1256;   break;      //    Algeria
        case 0x1801: wCP =  1256;   break;      //    Morocco
        case 0x1C01: wCP =  1256;   break;      //    Tunisia
        case 0x2001: wCP =  1256;   break;      //    Oman
        case 0x2401: wCP =  1256;   break;      //    Yemen
        case 0x2801: wCP =  1256;   break;      //    Syria
        case 0x2C01: wCP =  1256;   break;      //    Jordan
        case 0x3001: wCP =  1256;   break;      //    Lebanon
        case 0x3401: wCP =  1256;   break;      //    Kuwait
        case 0x3801: wCP =  1256;   break;      //    U.A.E.
        case 0x3C01: wCP =  1256;   break;      //    Bahrain
        case 0x4001: wCP =  1256;   break;      //    Qatar
        case 0x0423: wCP =  1251;   break;      //    Byelorussia
        case 0x0402: wCP =  1251;   break;      //    Bulgaria
        case 0x0403: wCP =  1252;   break;      //    Catalan
        case 0x0404: wCP =  950;    break;      //    Taiwan
        case 0x0804: wCP =  936;    break;      //    PRC
        case 0x0C04: wCP =  950;    break;      //    Hong Kong
        case 0x1004: wCP =  936;    break;      //    Singapore
        case 0x0405: wCP =  1250;   break;      //    Czech
        case 0x0406: wCP =  1252;   break;      //    Danish
        case 0x0413: wCP =  1252;   break;      //    Dutch (Standard)
        case 0x0813: wCP =  1252;   break;      //    Dutch (Belgian)
        case 0x0409: wCP =  1252;   break;      //    English (American)
        case 0x0809: wCP =  1252;   break;      //    English (British)
        case 0x1009: wCP =  1252;   break;      //    English (Canadian)
        case 0x1409: wCP =  1252;   break;      //    English (New Zealand)
        case 0x0c09: wCP =  1252;   break;      //    English (Australian)
        case 0x1809: wCP =  1252;   break;      //    English (Ireland)
        case 0x0425: wCP =  1257;   break;      //    Estonia
            //case 0x0429: wCP =       Farsi
        case 0x040b: wCP =  1252;   break;      //    Finnish
        case 0x040c: wCP =  1252;   break;      //    French (Standard)
        case 0x080c: wCP =  1252;   break;      //    French (Belgian)
        case 0x100c: wCP =  1252;   break;      //    French (Swiss)
        case 0x0c0c: wCP =  1252;   break;      //    French (Canadian)
        case 0x0407: wCP =  1252;   break;      //    German (Standard)
        case 0x0807: wCP =  1252;   break;      //    German (Swiss)
        case 0x0c07: wCP =  1252;   break;      //    German (Austrian)
        case 0x0408: wCP =  1253;   break;      //    Greek
        case 0x040D: wCP =  1255;   break;      //    Israel
        case 0x040e: wCP =  1250;   break;      //    Hungarian
        case 0x040f: wCP =  1252;   break;      //    Icelandic
        case 0x0421: wCP =  1252;   break;      //    Indonesia
        case 0x0410: wCP =  1252;   break;      //    Italian (Standard)
        case 0x0810: wCP =  1252;   break;      //    Italian (Swiss)
        case 0x0411: wCP =  932;    break;      //    Japanese
        case 0x0412: wCP =  949;    break;      //    Korea
        case 0x0426: wCP =  1257;   break;      //    Latvia
        case 0x0427: wCP =  1257;   break;      //    Lithuania
        case 0x0414: wCP =  1252;   break;      //    Norwegian (Bokmal)
        case 0x0814: wCP =  1252;   break;      //    Norwegian (Nynorsk)
        case 0x0415: wCP =  1250;   break;      //    Polish
        case 0x0816: wCP =  1252;   break;      //    Portuguese (Standard)
        case 0x0416: wCP =  1252;   break;      //    Portuguese (Brazilian)
        case 0x0417: wCP =  1252;   break;      //    Rhaeto-Romanic
        case 0x0818: wCP =  1250;   break;      //    Moldavia
        case 0x0418: wCP =  1250;   break;      //    Romanian
        case 0x0419: wCP =  1251;   break;      //    Russian
        case 0x041b: wCP =  1250;   break;      //    Slovak
        case 0x0424: wCP =  1250;   break;      //    Slovenian
        case 0x042e: wCP =  1250;   break;      //    Germany
        case 0x080a: wCP =  1252;   break;      //    Spanish (Mexican)
        case 0x040a: wCP =  1252;   break;      //    Spanish (Castilian)
        case 0x0c0a: wCP =  1252;   break;      //    Spanish (Modern)
        case 0x041d: wCP =  1252;   break;      //    Swedish
        case 0x041E: wCP =  874;    break;      //    Thailand
        case 0x041f: wCP =  1254;   break;      //    Turkish
        case 0x0422: wCP =  1251;   break;      //    Ukraine
        default: wCP =  1252;       break;      //    Return standard US English CP.
    }
    if (bReverse)
        dwRet = MAKELONG( wCP, wLang );
    else dwRet = MAKELONG( wLang, wCP );
    return dwRet;
}

#ifdef VB
static
UINT
UpdateVBData( LPVOID lpNewBuf, LONG dwNewSize,
              LPVOID lpOldI, LONG dwOldImageSize,
              LPVOID lpNewI, DWORD* pdwNewImageSize )
{
// The following special format is used by VB for international messages
// The code here is mostly copied from the UpdateMenu routine
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    // Data Items
    WORD wDataId;
    char szTxt[256];
    WORD wPos = 0;

    // Updated items
    WORD wUpdPos = 0;
    WORD wUpdDataId;
    char szUpdTxt[256];

    LONG  dwOverAllSize = 0l;


    // Copy the language specifier
    dwOldImageSize -= PutDWord( &lpNewImage, *((DWORD*)lpOldImage), &dwNewImageSize);
    lpOldImage += sizeofDWord;
    dwOverAllSize += sizeofDWord;
    GetString( &lpOldImage, &szTxt[0], &dwOldImageSize );
    dwOverAllSize += PutString( &lpNewImage, &szTxt[0], &dwNewImageSize);

    // Now copy the strings
    while (dwOldImageSize>0) {
        wPos++;
        // Check for only padding remaining and exit
        if ( *(WORD *)lpOldImage != RES_SIGNATURE )
            if ( dwOldImageSize < 16 && *(BYTE *)lpOldImage == 0 )
                break;
            else
                return ERROR_RW_INVALID_FILE;
        // This copies signature and ID
        wDataId = *(WORD *)(lpOldImage + sizeof(WORD));
        dwOldImageSize -= PutDWord( &lpNewImage, *((DWORD*)lpOldImage), &dwNewImageSize);
        lpOldImage += sizeofDWord;
        dwOverAllSize += sizeofDWord;

        // Get the untranslated string
        GetString( &lpOldImage, &szTxt[0], &dwOldImageSize );

        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            wUpdDataId = LOWORD(lpResItem->dwItemID);
            strcpy( szUpdTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos) && (wUpdDataId==wDataId)) {
            strcpy(szTxt, szUpdTxt);
            wUpdPos = 0;
        }
        // Write the text
        dwOverAllSize += PutString( &lpNewImage, &szTxt[0], &dwNewImageSize);

        // Check for padding
        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((dwOriginalOldSize-dwOldImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwOldImageSize, bPad );
            if (bPad==dwOldImageSize) {
                BYTE far * lpBuf = lpOldImage;
                while (bPad) {
                    if (*lpBuf++!=0x00)
                        break;
                    bPad--;
                }
                if (bPad==0)
                    dwOldImageSize = -1;
            }
        }

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}
#endif


static
UINT
UpdateVerst( LPVOID lpNewBuf, LONG dwNewSize,
             LPVOID lpOldI, LONG dwOldImageSize,
             LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    /*
     * This Function is a big mess. It is like this because the RC compiler generate
     * some inconsistent code so we have to do a lot of hacking to get the VS working
     * In future, if ever ver.dll and the RC compiler will be fixed will be possible
     * fix some of the bad thing we have to do to get the updated VS as consistent as
     * possible with the old one
     */

    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;
    static char szCaption[300];
    static char szUpdCaption[300];
    static char szUpdKey[100];

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    WORD wPad = 0;

    // Pointer to the block size to fix up later
    BYTE far * lpVerBlockSize = LPNULL;
    BYTE far * lpSFIBlockSize = LPNULL;
    BYTE far * lpTrnBlockSize = LPNULL;
    BYTE far * lpStrBlockSize = LPNULL;
    BYTE far * lpDummy = LPNULL;

    WORD wVerBlockSize = 0;
    WORD wSFIBlockSize = 0;
    WORD wTrnBlockSize = 0;
    WORD wStrBlockSize = 0;
    WORD wTrash = 0;        // we need this to fix a bug in the RC compiler

    // StringFileInfo
    static VER_BLOCK SFI;   // StringFileInfo
    LONG lSFILen = 0;

    // Translation blocks
    static VER_BLOCK Trn;
    LONG lTrnLen = 0;

    static VER_BLOCK Str;   // Strings

    // we read first of all the information from the VS_VERSION_INFO block
    static VER_BLOCK VS_INFO; // VS_VERSION_INFO

    int iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &VS_INFO );

    // Write the block in the new image
    wVerBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, VS_INFO, &VS_INFO.szValue[0], &lpVerBlockSize, &wTrash );

    dwOverAllSize = wVerBlockSize+wTrash;

    // we have to check the len of the full block for padding.
    // For some wild reasons the RC compiler place a wrong value there
    LONG lVS_INFOLen = VS_INFO.wBlockLen - iHeadLen - Pad4(VS_INFO.wBlockLen);

    while (dwOldImageSize>0 && lVS_INFOLen>0) {
        //Get the StringFileInfo
        iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &SFI );

        // Check if this is the StringFileInfo field
        if (!strcmp(SFI.szKey, "StringFileInfo")) {
            // Read all the translation blocks
            lSFILen = SFI.wBlockLen-iHeadLen-Pad4(SFI.wBlockLen);
            // Write the block in the new image
            wSFIBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, SFI, &SFI.szValue[0], &lpSFIBlockSize, &wTrash );
            dwOverAllSize += wSFIBlockSize+wTrash;

            while (lSFILen>0) {
                // Read the Translation block
                iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &Trn );

                // Calculate the right key name
                if ((lpResItem = GetItem( lpBuf, dwNewSize, Trn.szKey))) {
                    // Find the Translation ResItem
                    LPRESITEM lpTrans = GetItem( lpBuf, dwNewSize, "Translation");
                    WORD wLang = (lpTrans ? LOWORD(lpTrans->dwLanguage) : 0xFFFF);
                    GenerateTransField( wLang, &Trn );
                }

                // Write the block in the new image
                wTrnBlockSize = (WORD) PutVSBlock( &lpNewImage, &dwNewImageSize, Trn, &Trn.szValue[0], &lpTrnBlockSize, &wTrash );
                dwOverAllSize += wTrnBlockSize+wTrash;
                lTrnLen = Trn.wBlockLen-iHeadLen-Pad4(Trn.wBlockLen);
                while (lTrnLen>0) {
                    // Read the Strings in the block
                    iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &Str );
                    lTrnLen -= iHeadLen;
                    TRACE2("Key: %s\tValue: %s\n", Str.szKey, Str.szValue );
                    TRACE3("Len: %hd\tValLen: %hd\tType: %hd\n", Str.wBlockLen, Str.wValueLen, Str.wType );

                    strcpy(szCaption, Str.szValue);
                    // Check if this Item has been updated
                    if ((lpResItem = GetItem( lpBuf, dwNewSize, Str.szKey))) {
                        strcpy( szUpdCaption, lpResItem->lpszCaption );
                        strcpy( szUpdKey, lpResItem->lpszClassName );
                    }
                    if (!strcmp( szUpdKey, Str.szKey)) {
                        strcpy( szCaption, szUpdCaption );
                        wUpdPos = 0;
                    }

                    // Write the block in the new image
                    wStrBlockSize = (WORD) PutVSBlock( &lpNewImage, &dwNewImageSize, Str, szCaption, &lpStrBlockSize, &wTrash );
                    dwOverAllSize += wStrBlockSize+wTrash;

                    // Fix up the size of the block
                    if (dwNewImageSize>=0)
                        memcpy( lpStrBlockSize, &wStrBlockSize, 2);

                    wTrnBlockSize += wStrBlockSize + wTrash;
                }
                lSFILen -= Trn.wBlockLen;
                // Fix up the size of the block
                if (dwNewImageSize>=0)
                    memcpy( lpTrnBlockSize, &wTrnBlockSize, 2);

                wSFIBlockSize += wTrnBlockSize;
            }
            lVS_INFOLen -= SFI.wBlockLen;
            // Fix up the size of the block
            if (dwNewImageSize>=0)
                memcpy( lpSFIBlockSize, &wSFIBlockSize, 2);
            wVerBlockSize += wSFIBlockSize;

        } else {
            // this is another block skip it all
            lVS_INFOLen -= SFI.wValueLen+iHeadLen;

            // Check if this block is the translation field
            if (!strcmp(SFI.szKey, "Translation")) {
                // it is calculate the right value to place in the value field
                // We calculate automatically the value to have the correct
                // localized language in the translation field
                //wVerBlockSize += PutTranslation( &lpNewImage, &dwNewImageSize, SFI );
                // check if this is the translation block
                // This is the translation block let the localizer have it for now
                /*
                if ((lpResItem = GetItem( lpBuf, dwNewSize, SFI.szKey)))
                    strcpy( szUpdCaption, lpResItem->lpszCaption );
                // Convert the value back in numbers
                DWORD dwCodeLang = strtol( szUpdCaption, '\0', 16);
                */

                //
                // We do generate the Tranlsation filed from the language
                // We will have to update the block name as well
                //

                DWORD dwCodeLang = 0;
                if ((lpResItem = GetItem( lpBuf, dwNewSize, SFI.szKey)))
                    dwCodeLang = GenerateTransField((WORD)LOWORD(lpResItem->dwLanguage), FALSE);

                else {
                    // Place the original value here
                    dwCodeLang =(DWORD)*(SFI.pValue);
                }
                LONG lDummy = 4;
                SFI.pValue -= PutDWord( &SFI.pValue, dwCodeLang, &lDummy );

            }

            // Write the block in the new image
            wVerBlockSize += (WORD) PutVSBlock( &lpNewImage, &dwNewImageSize, SFI, &SFI.szValue[0], &lpDummy, &wTrash );
            if (dwNewImageSize>=0)
                memcpy( lpVerBlockSize, &wVerBlockSize, 2);

            dwOverAllSize = wVerBlockSize+wTrash;

        }
    }

    // fix up the block size
    if (dwNewImageSize>=0)
        memcpy( lpVerBlockSize, &wVerBlockSize, 2);

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


static
UINT ParseAccel( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    TRACE("ParseAccelerator: \n");
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;
    LONG dwOverAllSize = 0L;
    WORD wPos = 0;
    BYTE fFlags = 0;
    WORD wEvent = 0;
    WORD wId = 0;

    // Reset the IDArray
    CalcID(0, FALSE);
    while (dwImageSize>0) {
        wPos++;
        GetByte( &lpImage, &fFlags, &dwImageSize );
        GetWord( &lpImage, &wEvent, &dwImageSize );
        GetWord( &lpImage, &wId, &dwImageSize );
        if (fFlags & 0x80)
            dwImageSize = 0;

        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in an accelerator
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)wEvent, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fFlags, &dwBufSize);
        // we will need to calculate the correct ID for mike
        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, CalcID(wId, TRUE), &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        // Put the size of the resource
        if (dwBufSize>=0) {
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }

        // Move to the next position
        lpItem = lpBuf;
        /*
        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==(dwImageSize))
                dwImageSize = -1;
        }
        */
    }
    return (UINT)(dwOverAllSize);
}

#ifdef VB
static
UINT ParseVBData( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
// The following special format is used by VB for international messages
// The code here is mostly copied from the ParseMenu routine

    // UGLY!!  The following values are taken from GLOBALS.C in TMSB.
    // I have added a couple not in use by VB in hopes not to re-build
    // when they decide to add additionals
    enum LOCALE {
        FRENCH = 0x040C,
        GERMAN = 0x0407,
        SPANISH = 0X040A,
        DANISH = 0X0406,
        ITALIAN = 0X0410,
        RUSSIAN = 0X0419,
        JAPANESE = 0X0411,
        PORTUGUESE = 0X0816,
        DUTCH = 0X0413};
//		       {3,0x041D,850,"Swedish",""},
//		       {4,0x0414,850,"Norwegian Bokml","NOB"},
//		       {5,0x0814,850,"Norwegian Nynorsk","NON"},
//		       {6,0x040B,850,"Finnish","FIN"},
//		       {7,0x0C0C,863,"French Canadian","FRC"},
//		       {9,0x0416,850,"Portuguese (Brazilian)","BPO"},
//		       {10,0x0816,850,"Portuguese (Portugal)","PPO"},
//		       {17,0x0415,850,"Polish","POL"},
//		       {18,0x040E,850,"Hungarian","HUN"},
//		       {19,0x0405,850,"Czech","CZE"},
//		       {20,0x0401,864,"Arabic","ARA"},
//		       {21,0x040D,862,"Hebrew","HBR"},
//		       {23,0x0412,934,"Korean","KOR"},
//		       {24,0x041E,938,"Thai","THA"},
//		       {25,0x0404,936,"Chinese (Traditional)","CHI (Tra)"},
//		       {26,0x0404,936,"Chinese (Simplified)","CHI (Sim)"},
    WORD wSig, wID;
    LONG dwImageSize = dwISize;
    LONG dwOverAllSize = 0L;
    LONG lDummy;
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    static char szWork[MAXSTR];
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;

    GetWord( &lpImage, &wSig, &dwImageSize);
    if ( wSig != RES_SIGNATURE )    // Not a VB resource
        return 0;
    GetWord( &lpImage, &wSig, &dwImageSize);
    if ( wSig != 0 )                // Header should have zero ID
        return 0;
    GetString( &lpImage, &szWork[0], &dwImageSize );
    LOCALE locale = (LOCALE)GetPrivateProfileInt("AUTOTRANS","Locale", 0, "ESPRESSO.INI");
    if (( lstrcmp(szWork, "VBINTLSZ_FRENCH") == 0 && locale == FRENCH) ||
        ( lstrcmp(szWork, "VBINTLSZ_GERMAN") == 0 && locale == GERMAN) ||
        ( lstrcmp(szWork, "VBINTLSZ_ITALIAN") == 0 && locale == ITALIAN) ||
        ( lstrcmp(szWork, "VBINTLSZ_JAPANESE") == 0 && locale == JAPANESE) ||
        ( lstrcmp(szWork, "VBINTLSZ_SPANISH") == 0 && locale == SPANISH) ||
        ( lstrcmp(szWork, "VBINTLSZ_DANISH") == 0 && locale == DANISH) ||
        ( lstrcmp(szWork, "VBINTLSZ_DUTCH") == 0 && locale == DUTCH) ||
        ( lstrcmp(szWork, "VBINTLSZ_PORTUGUESE") == 0 && locale == PORTUGUESE)
       ) {
        while ( dwImageSize > 0 ) {
            GetWord( &lpImage, &wSig, &dwImageSize);
            // Check for only padding remaining and exit
            if ( wSig != RES_SIGNATURE )
                if ( dwImageSize < 16 && *(BYTE *)lpImage == 0 )
                    break;
                else
                    return ERROR_RW_INVALID_FILE;
            GetWord( &lpImage, &wID, &dwImageSize); // ID
            // Fixed field
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
            // We don't have the size and pos in a string
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

            // we don't have checksum and style
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // We'll save the string's "resource" ID as an Item ID
            dwOverAllSize += PutDWord( &lpBuf, wID, &dwBufSize);

            // Don't save a resource ID or  Type Id
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // we don't display the language
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // we don't have the codepage or the font name
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
            dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

            // Let's put null were we don;t have the strings
            uiOffset = sizeof(RESITEM);
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ClassName
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // FaceName
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)(DWORD_PTR)(lpItem+uiOffset), &dwBufSize);   // Caption
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ResItem
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // TypeItem

            // Get the text
            GetString( &lpImage, &szWork[0], &dwImageSize );    // Text string
            dwOverAllSize += PutString( & lpBuf, &szWork[0], &dwBufSize);
            // Put the size of the resource
            if (dwBufSize>=0) {
                uiOffset += strlen((LPSTR)(lpItem+uiOffset))+1;
                lDummy = 8;
                PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
            }

            // Move to the next position
            lpItem = lpBuf;
            if (dwImageSize<=16) {
                // Check if we are at the end and this is just padding
                BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
                //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
                if (bPad==(dwImageSize))
                    dwImageSize = -1;
            }
        }
        return (UINT)(dwOverAllSize);
    }
    return 0;

}
#endif


static
UINT
UpdateAccel( LPVOID lpNewBuf, LONG dwNewSize,
             LPVOID lpOldI, LONG dwOldImageSize,
             LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    TRACE("UpdateAccel\n");

    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;


    //Old Items
    BYTE fFlags = 0;
    WORD wEvent = 0;
    WORD wId = 0;
    WORD wPos = 0;

    // Updated items
    BYTE fUpdFlags = 0;
    WORD wUpdEvent = 0;
    WORD wUpdId = 0;
    WORD wUpdPos = 0;

    LONG  dwOverAllSize = 0l;


    while (dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        GetByte( &lpOldImage, &fFlags, &dwOldImageSize );
        GetWord( &lpOldImage, &wEvent, &dwOldImageSize );
        GetWord( &lpOldImage, &wId, &dwOldImageSize );
        if (fFlags & 0x80)
            dwOldImageSize = 0;


        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdId = LOWORD(lpResItem->dwItemID);
            wUpdPos = HIWORD(lpResItem->dwItemID);
            fUpdFlags = (BYTE)lpResItem->dwFlags;
            wUpdEvent = (WORD)lpResItem->dwStyle;
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        TRACE3("Old Accel: wID: %hd\t wEvent: %hd\t wFlag: %hd\n", wId, wEvent, fFlags);
        TRACE3("New Accel: wID: %hd\t wEvent: %hd\t wFlag: %hd\n", wUpdId, wUpdEvent, fUpdFlags);


        if ((wPos==wUpdPos) && (wUpdId==wId)) {

            if (fFlags & 0x80)
                fFlags = fUpdFlags | 0x80;
            else fFlags = fUpdFlags;
            wEvent = wUpdEvent;
            wUpdPos = 0;
        }

        dwOverAllSize += PutByte( &lpNewImage, fFlags, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, wEvent, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize);

        /*
        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwOriginalOldSize-dwOldImageSize));
            if (bPad==dwOldImageSize)
                dwOldImageSize = 0;

        }
        */
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


static
UINT
ParseMenu( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for a Menu to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    // skip the menu header
    SkipByte( &lpImage, 4, &dwImageSize );

    // Menu Items
    WORD fItemFlags;
    WORD wMenuId;
    static char    szCaption[MAXSTR];

    int iter = 1;
    while (dwImageSize>0) {

        // Let's get the Menu flags
        GetWord( &lpImage, &fItemFlags, &dwImageSize );

        if ( !(fItemFlags & MF_POPUP) )
            // Get the menu Id
            GetWord( &lpImage, &wMenuId, &dwImageSize );
        else wMenuId = (WORD)-1;

        // Get the text
        GetString( &lpImage, &szCaption[0], &dwImageSize );

        // Check if is not a separator or padding
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a menu
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fItemFlags, &dwBufSize);
        //Put the MenuId
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)wMenuId, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)(DWORD_PTR)(lpItem+uiOffset), &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        // Get the text
        // calculate were the string is going to be
        // Will be the fixed header+the pointer
        dwOverAllSize += PutString( &lpBuf, &szCaption[0], &dwBufSize);

        TRACE("Menu: Iteration %d size %d\n", iter++, dwOverAllSize);
        // Put the size of the resource
        uiOffset += strlen(szCaption)+1;
        // Check if we are alligned
        lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += lDummy;
        uiOffset += lDummy;
        lDummy = 4;
        if (dwBufSize>=0)
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);

        // Move to the next position
        lpItem = lpBuf;

        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==dwImageSize) {
                BYTE far * lpBuf = lpImage;
                while (bPad) {
                    if (*lpBuf++!=0x00)
                        break;
                    bPad--;
                }
                if (bPad==0)
                    dwImageSize = -1;
            }
        }
    }


    return (UINT)(dwOverAllSize);
}

static
UINT
UpdateMenu( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    // Menu Items
    WORD fItemFlags;
    WORD wMenuId;
    char szTxt[256];
    WORD wPos = 0;

    // Updated items
    WORD wUpdPos = 0;
    WORD fUpdItemFlags;
    WORD wUpdMenuId;
    char szUpdTxt[256];

    LONG  dwOverAllSize = 0l;


    // Copy the menu flags
    dwOldImageSize -= PutDWord( &lpNewImage, *((DWORD*)lpOldImage), &dwNewImageSize);
    lpOldImage += sizeofDWord;
    dwOverAllSize += sizeofDWord;

    while (dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        // Get the menu flag
        GetWord( &lpOldImage, &fItemFlags, &dwOldImageSize );

        if ( !(fItemFlags & MF_POPUP) )
            GetWord( &lpOldImage, &wMenuId, &dwOldImageSize );
        else wMenuId = (WORD)-1;

        // Get the text
        GetString( &lpOldImage, &szTxt[0], &dwOldImageSize );

        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            wUpdMenuId = LOWORD(lpResItem->dwItemID);
            fUpdItemFlags = (WORD)lpResItem->dwFlags;
            strcpy( szUpdTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos) && (wUpdMenuId==wMenuId)) {
            // check if it is not the last item in the menu
            if (fItemFlags & MF_END)
                fItemFlags = fUpdItemFlags | (WORD)MF_END;
            else fItemFlags = fUpdItemFlags;

            wMenuId = wUpdMenuId;

            // check it is not a separator
            if ((fItemFlags==0) && (wMenuId==0))
                strcpy(szTxt, "");
            else strcpy(szTxt, szUpdTxt);
            wUpdPos = 0;
        }
        dwOverAllSize += PutWord( &lpNewImage, fItemFlags, &dwNewImageSize);

        if ( !(fItemFlags & MF_POPUP) ) {
            dwOverAllSize += PutWord( &lpNewImage, wMenuId, &dwNewImageSize);
        }

        // Write the text
        dwOverAllSize += PutString( &lpNewImage, &szTxt[0], &dwNewImageSize);

        // Check for padding
        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((dwOriginalOldSize-dwOldImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwOldImageSize, bPad );
            if (bPad==dwOldImageSize) {
                BYTE far * lpBuf = lpOldImage;
                while (bPad) {
                    if (*lpBuf++!=0x00)
                        break;
                    bPad--;
                }
                if (bPad==0)
                    dwOldImageSize = -1;
            }
        }

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}

static UINT GenerateMenu( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    // Updated items
    WORD wUpdPos = 0;
    WORD fUpdItemFlags;
    WORD wUpdMenuId;
    char szUpdTxt[256];

    LONG  dwOverAllSize = 0l;

    // invent the menu flags
    dwOverAllSize += PutDWord( &lpNewImage, 0L, &dwNewImageSize);

    while (dwNewSize>0) {
        if (dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdMenuId = LOWORD(lpResItem->dwItemID);
            fUpdItemFlags = (WORD)lpResItem->dwFlags;
            strcpy( szUpdTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        dwOverAllSize += PutWord( &lpNewImage, fUpdItemFlags, &dwNewImageSize);

        if ( !(fUpdItemFlags & MF_POPUP) )
            dwOverAllSize += PutWord( &lpNewImage, wUpdMenuId, &dwNewImageSize);

        // Write the text
        // check if it is a separator
        if ( !(fUpdItemFlags) && !(wUpdMenuId) )
            szUpdTxt[0] = 0x00;
        dwOverAllSize += PutString( &lpNewImage, &szUpdTxt[0], &dwNewImageSize);

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}

static
UINT
ParseString( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for a String to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    LONG dwRead = 0L;

    BYTE bIdCount = 0;

    while ( (dwImageSize>0) && (bIdCount<16)  ) {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a string
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the StringId
        dwOverAllSize += PutDWord( &lpBuf, bIdCount++, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ClassName
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // FaceName
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)(DWORD_PTR)(lpItem+uiOffset), &dwBufSize);   // Caption
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ResItem
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // TypeItem

        // Get the text
        BYTE bstrlen = *lpImage++;
        dwImageSize -= 1;
        TRACE1("StrLen: %hd\t", bstrlen);
        if ((bstrlen+1)>dwBufSize) {
            dwOverAllSize += bstrlen+1;
            dwImageSize -= bstrlen;
            lpImage += bstrlen;
            dwBufSize -= bstrlen+1;
            TRACE1("BufferSize: %ld\n", dwBufSize);
        } else {
            if (bstrlen)
                memcpy( (char*)lpBuf, (char*)lpImage, bstrlen );

            *(lpBuf+(bstrlen)) = 0;
            TRACE1("Caption: %Fs\n", lpBuf);
            lpImage += bstrlen;
            lpBuf += bstrlen+1;
            dwImageSize -= bstrlen;
            dwBufSize -= bstrlen+1;
            dwOverAllSize += bstrlen+1;
        }


        // Put the size of the resource
        uiOffset += bstrlen+1;
        // Check if we are alligned
        lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += lDummy;
        uiOffset += lDummy;
        lDummy = 4;
        if (dwBufSize>=0)
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);

        // Move to the next position
        lpItem = lpBuf;
        if ((dwImageSize<=16) && (bIdCount==16)) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==dwImageSize)
                dwImageSize = -1;
        }
    }


    return (UINT)(dwOverAllSize);
}

static
UINT
UpdateString( LPVOID lpNewBuf, LONG dwNewSize,
              LPVOID lpOldI, LONG dwOldImageSize,
              LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    BYTE bLen;
    char szTxt[MAXSTR];
    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;
    char szUpdTxt[MAXSTR];

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    while (dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        GetByte( &lpOldImage, &bLen, &dwOldImageSize );

        // Copy the text
        if (bLen>MAXSTR) {

        } else {
            memcpy( szTxt, (char*)lpOldImage, bLen );
            lpOldImage += bLen;
            dwOldImageSize -= bLen;
            szTxt[bLen]='\0';
        }

        if ((!wUpdPos) && dwNewSize ) {
            /*
            GetUpdatedItem(
                            &lpNewBuf, &dwNewSize,
                            &wDummy, &wDummy,
                            &wDummy, &wDummy,
                            &dwPosId,
                            &dwDummy, &dwDummy,
                            &szUpdTxt[0]);

            wUpdPos = HIWORD(dwPosId);
            */
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            strcpy( szUpdTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos)) {
            strcpy(szTxt, szUpdTxt);
            wUpdPos = 0;
        }

        bLen = strlen(szTxt);
        //dwOverAllSize += PutByte( &lpNewImage, (BYTE)bLen, &dwNewImageSize);

        // Write the text
        dwOverAllSize += PutPascalString( &lpNewImage, &szTxt[0], bLen, &dwNewImageSize );

        if ((dwOldImageSize<=16) && (wPos==16)) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwOriginalOldSize-dwOldImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==dwOldImageSize)
                dwOldImageSize = -1;
        }
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}

static
UINT
GenerateString( LPVOID lpNewBuf, LONG dwNewSize,
                LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    BYTE bLen;
    static char szTxt[MAXSTR];
    WORD wPos = 0;

    LONG dwOverAllSize = 0l;

    while (dwNewSize>0) {
        if ( dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            strcpy( szTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        bLen = strlen(szTxt);

        // Write the text
        dwOverAllSize += PutPascalString( &lpNewImage, &szTxt[0], bLen, &dwNewImageSize );
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


static
UINT
ParseDialog( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for a Dialog to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
    UINT uiOffset = 0;

    char far * lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    LONG dwOverAllSize = 0L;

    BYTE    bIdCount = 0;

    // Dialog Elements
    DWORD   dwStyle = 0L;
    BYTE    bNumOfElem = 0;
    WORD    wX = 0;
    WORD    wY = 0;
    WORD    wcX = 0;
    WORD    wcY = 0;
    WORD    wId = 0;
    static char    szMenuName[MAXID];
    WORD    wMenuName;
    static char    szClassName[MAXID];
    BYTE    bClassName, bControlClassName;
    static char    szCaption[MAXSTR];
    WORD    wOrd;
    WORD    wPointSize = 0;
    static char    szFaceName[MAXID];

    // read the dialog header
    GetDWord( &lpImage, &dwStyle, &dwImageSize );
    GetByte( &lpImage, &bNumOfElem, &dwImageSize );
    GetWord( &lpImage, &wX, &dwImageSize );
    GetWord( &lpImage, &wY, &dwImageSize );
    GetWord( &lpImage, &wcX, &dwImageSize );
    GetWord( &lpImage, &wcY, &dwImageSize );
    GetNameOrOrd( &lpImage, &wMenuName, &szMenuName[0], &dwImageSize );
    GetClassName( &lpImage, &bClassName, &szClassName[0], &dwImageSize );
    GetCaptionOrOrd( &lpImage, &wOrd, &szCaption[0], &dwImageSize,
                     bClassName, dwStyle );
    if ( dwStyle & DS_SETFONT ) {
        GetWord( &lpImage, &wPointSize, &dwImageSize );
        GetString( &lpImage, &szFaceName[0], &dwImageSize );
    }

    TRACE("Win16.DLL ParseDialog\t");
    TRACE1("NumElem: %hd\t", bNumOfElem);
    TRACE1("X %hd\t", wX);
    TRACE1("Y: %hd\t", wY);
    TRACE1("CX: %hd\t", wcX);
    TRACE1("CY: %hd\t", wcY);
    TRACE1("Id: %hd\t", wId);
    TRACE1("Style: %lu\n", dwStyle);
    TRACE1("Caption: %s\n", szCaption);
    TRACE2("ClassName: %s\tClassId: %hd\n", szClassName, bClassName );
    TRACE2("MenuName: %s\tMenuId: %hd\n", szMenuName, wMenuName );
    TRACE2("FontName: %s\tPoint: %hd\n", szFaceName, wPointSize );

    // Fixed field
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

    dwOverAllSize += PutWord( &lpBuf, wX, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wY, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wcX, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wcY, &dwBufSize);

    // we don't have checksum and extended style
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, dwStyle, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    //Put the Id 0 for the main dialog
    dwOverAllSize += PutDWord( &lpBuf, bIdCount++, &dwBufSize);

    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    dwOverAllSize += PutWord( &lpBuf, bClassName, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wPointSize, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)DEFAULT_CHARSET, &dwBufSize);

    // Let's put null were we don;t have the strings
    uiOffset = sizeof(RESITEM);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ClassName
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // FaceName
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // Caption
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ResItem
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // TypeItem

    lpResItem->lpszClassName = strcpy( lpStrBuf, szClassName );
    lpStrBuf += strlen(lpResItem->lpszClassName)+1;

    lpResItem->lpszFaceName = strcpy( lpStrBuf, szFaceName );
    lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

    lpResItem->lpszCaption = strcpy( lpStrBuf, szCaption );
    lpStrBuf += strlen(lpResItem->lpszCaption)+1;

    // Put the size of the resource
    if (dwBufSize>0) {
        uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
        uiOffset += strlen((LPSTR)(lpResItem->lpszFaceName))+1;
        uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
    }

    // Check if we are alligned
    uiOffset += Allign( (BYTE**)&lpStrBuf, &dwBufSize, (LONG)uiOffset);

    dwOverAllSize += uiOffset-sizeof(RESITEM);
    lpResItem->dwSize = (DWORD)uiOffset;

    // Move to the next position
    lpResItem = (LPRESITEM) lpStrBuf;
    lpBuf = (BYTE far *)lpStrBuf;
    lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    while ( (dwImageSize>0) && (bNumOfElem>0) ) {
        // Read the COntrols
        GetWord( &lpImage, &wX, &dwImageSize );
        GetWord( &lpImage, &wY, &dwImageSize );
        GetWord( &lpImage, &wcX, &dwImageSize );
        GetWord( &lpImage, &wcY, &dwImageSize );
        GetWord( &lpImage, &wId, &dwImageSize );
        GetDWord( &lpImage, &dwStyle, &dwImageSize );
        GetControlClassName( &lpImage, &bControlClassName, &szClassName[0], &dwImageSize );
        GetCaptionOrOrd( &lpImage, &wOrd, &szCaption[0], &dwImageSize,
                         bControlClassName, dwStyle );
        SkipByte( &lpImage, 1, &dwImageSize );
        bNumOfElem--;
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        dwOverAllSize += PutWord( &lpBuf, wX, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wY, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wcX, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wcY, &dwBufSize);

        // we don't have checksum and extended style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, dwStyle, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, wId, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        dwOverAllSize += PutWord( &lpBuf, bControlClassName, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wPointSize, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, DEFAULT_CHARSET, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ClassName
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // FaceName
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // Caption
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ResItem
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // TypeItem

        lpResItem->lpszClassName = strcpy( lpStrBuf, szClassName );
        lpStrBuf += strlen(lpResItem->lpszClassName)+1;

        lpResItem->lpszFaceName = strcpy( lpStrBuf, szFaceName );
        lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

        lpResItem->lpszCaption = strcpy( lpStrBuf, szCaption );
        lpStrBuf += strlen(lpResItem->lpszCaption)+1;

        // Put the size of the resource
        if (dwBufSize>0) {
            uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszFaceName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
        }

        // Check if we are alligned
        uiOffset += Allign( (BYTE**)&lpStrBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += uiOffset-sizeof(RESITEM);
        lpResItem->dwSize = (DWORD)uiOffset;

        // Move to the next position
        lpResItem = (LPRESITEM) lpStrBuf;
        lpBuf = (BYTE far *)lpStrBuf;
        lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

        TRACE1("\tControl: X: %hd\t", wX);
        TRACE1("Y: %hd\t", wY);
        TRACE1("CX: %hd\t", wcX);
        TRACE1("CY: %hd\t", wcY);
        TRACE1("Id: %hd\t", wId);
        TRACE1("Style: %lu\n", dwStyle);
        TRACE1("Caption: %s\n", szCaption);

        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==dwImageSize)
                dwImageSize = -1;
        }
    }


    return (UINT)(dwOverAllSize);
}

static
UINT
UpdateDialog( LPVOID lpNewBuf, LONG dwNewSize,
              LPVOID lpOldI, LONG dwOldImageSize,
              LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    // Should be almost impossible for a Dialog to be Huge
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    LONG dwOverAllSize = 0L;

    BYTE    bIdCount = 0;

    // Dialog Elements
    DWORD   dwStyle = 0L;
    BYTE    bNumOfElem = 0;
    WORD    wX = 0;
    WORD    wY = 0;
    WORD    wcX = 0;
    WORD    wcY = 0;
    WORD    wId = 0;
    static char    szMenuName[MAXID];
    WORD    wMenuName;
    static char    szClassName[MAXID];
    BYTE    bClassName, bControlClassName;
    static char    szCaption[MAXSTR];
    WORD    wOrd = 0;
    WORD    wPointSize = 0;
    static char    szFaceName[MAXID];
    WORD    wPos = 1;

    // Updated elements
    WORD    wUpdX = 0;
    WORD    wUpdY = 0;
    WORD    wUpdcX = 0;
    WORD    wUpdcY = 0;
    DWORD   dwUpdStyle = 0l;
    DWORD   dwPosId = 0l;
    static char    szUpdCaption[MAXSTR];
    static char    szUpdFaceName[MAXID];
    WORD    wUpdPointSize = 0;
    WORD    wUpdPos = 0;

    // read the dialog header
    GetDWord( &lpOldImage, &dwStyle, &dwOldImageSize );
    GetByte( &lpOldImage, &bNumOfElem, &dwOldImageSize );
    GetWord( &lpOldImage, &wX, &dwOldImageSize );
    GetWord( &lpOldImage, &wY, &dwOldImageSize );
    GetWord( &lpOldImage, &wcX, &dwOldImageSize );
    GetWord( &lpOldImage, &wcY, &dwOldImageSize );
    GetNameOrOrd( &lpOldImage, &wMenuName, &szMenuName[0], &dwOldImageSize );
    GetClassName( &lpOldImage, &bClassName, &szClassName[0], &dwOldImageSize );
    GetCaptionOrOrd( &lpOldImage, &wOrd, &szCaption[0], &dwOldImageSize,
                     bClassName, dwStyle );
    if ( dwStyle & DS_SETFONT ) {
        GetWord( &lpOldImage, &wPointSize, &dwOldImageSize );
        GetString( &lpOldImage, &szFaceName[0], &dwOldImageSize );
    }

    // Get the infrmation from the updated resource
    if ((!wUpdPos) && dwNewSize ) {
        lpResItem = (LPRESITEM) lpBuf;
        wUpdX = lpResItem->wX;
        wUpdY = lpResItem->wY;
        wUpdcX = lpResItem->wcX;
        wUpdcY = lpResItem->wcY;
        wUpdPointSize = lpResItem->wPointSize;
        dwUpdStyle = lpResItem->dwStyle;
        dwPosId = lpResItem->dwItemID;
        strcpy( szUpdCaption, lpResItem->lpszCaption );
        strcpy( szUpdFaceName, lpResItem->lpszFaceName );
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
    }
    // check if we have to update the header
    if ((HIWORD(dwPosId)==wPos) && (LOWORD(dwPosId)==wId)) {
        wX = wUpdX;
        wY = wUpdY;
        wcX = wUpdcX;
        wcY = wUpdcY;
        wPointSize = wUpdPointSize;
        dwStyle = dwUpdStyle;
        strcpy(szCaption, szUpdCaption);
        strcpy(szFaceName, szUpdFaceName);
    }

    // Write the header informations
    dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
    dwOverAllSize += PutByte( &lpNewImage, bNumOfElem, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
    dwOverAllSize += PutNameOrOrd( &lpNewImage, wMenuName, &szMenuName[0], &dwNewImageSize );
    dwOverAllSize += PutClassName( &lpNewImage, bClassName, &szClassName[0], &dwNewImageSize );
    dwOverAllSize += PutCaptionOrOrd( &lpNewImage, wOrd, &szCaption[0], &dwNewImageSize,
                                      bClassName, dwStyle );
    if ( dwStyle & DS_SETFONT ) {
        dwOverAllSize += PutWord( &lpNewImage, wPointSize, &dwNewImageSize );
        dwOverAllSize += PutString( &lpNewImage, &szFaceName[0], &dwNewImageSize );
    }

    while ( (dwOldImageSize>0) && (bNumOfElem>0) ) {
        wPos++;
        // Get the info for the control
        // Read the COntrols
        GetWord( &lpOldImage, &wX, &dwOldImageSize );
        GetWord( &lpOldImage, &wY, &dwOldImageSize );
        GetWord( &lpOldImage, &wcX, &dwOldImageSize );
        GetWord( &lpOldImage, &wcY, &dwOldImageSize );
        GetWord( &lpOldImage, &wId, &dwOldImageSize );
        GetDWord( &lpOldImage, &dwStyle, &dwOldImageSize );
        GetControlClassName( &lpOldImage, &bControlClassName, &szClassName[0], &dwOldImageSize );
        GetCaptionOrOrd( &lpOldImage, &wOrd, &szCaption[0], &dwOldImageSize,
                         bControlClassName, dwStyle );
        SkipByte( &lpOldImage, 1, &dwOldImageSize );
        bNumOfElem--;

        if ((!wUpdPos) && dwNewSize ) {
            TRACE1("\t\tUpdateDialog:\tdwNewSize=%ld\n",(LONG)dwNewSize);
            TRACE1("\t\t\t\tlpszCaption=%Fs\n",lpResItem->lpszCaption);
            lpResItem = (LPRESITEM) lpBuf;
            wUpdX = lpResItem->wX;
            wUpdY = lpResItem->wY;
            wUpdcX = lpResItem->wcX;
            wUpdcY = lpResItem->wcY;
            dwUpdStyle = lpResItem->dwStyle;
            dwPosId = lpResItem->dwItemID;
            strcpy( szUpdCaption, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        // check if we have to update the header
        if ((HIWORD(dwPosId)==wPos) && (LOWORD(dwPosId)==wId)) {
            wX = wUpdX;
            wY = wUpdY;
            wcX = wUpdcX;
            wcY = wUpdcY;
            dwStyle = dwUpdStyle;
            strcpy(szCaption, szUpdCaption);
        }

        //write the control
        dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize );
        dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
        dwOverAllSize += PutControlClassName( &lpNewImage, bControlClassName, &szClassName[0], &dwNewImageSize );
        dwOverAllSize += PutCaptionOrOrd( &lpNewImage, wOrd, &szCaption[0], &dwNewImageSize,
                                          bControlClassName, dwStyle );
        dwOverAllSize += PutByte( &lpNewImage, 0, &dwNewImageSize );

        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwOriginalOldSize-dwOldImageSize));
            if (bPad==dwOldImageSize)
                dwOldImageSize = 0;
        }
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


static
UINT
GenerateDialog( LPVOID lpNewBuf, LONG dwNewSize,
                LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    // Should be almost impossible for a Dialog to be Huge
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    LONG dwOverAllSize = 0L;

    BYTE    bIdCount = 0;

    // Dialog Elements
    DWORD   dwStyle = 0L;
    BYTE    bNumOfElem = 0;
    WORD    wX = 0;
    WORD    wY = 0;
    WORD    wcX = 0;
    WORD    wcY = 0;
    WORD    wId = 0;
    char    szClassName[128];
    BYTE    bClassName='\0', bControlClassName='\0';
    char    szCaption[128];
    WORD    wPointSize = 0;
    char    szFaceName[128];
    WORD    wPos = 1;

    // Get the infrmation from the updated resource
    if ( dwNewSize ) {
        lpResItem = (LPRESITEM) lpBuf;
        wX = lpResItem->wX;
        wY = lpResItem->wY;
        wcX = lpResItem->wcX;
        wcY = lpResItem->wcY;
        wId = LOWORD(lpResItem->dwItemID);
        wPointSize = lpResItem->wPointSize;
        dwStyle = lpResItem->dwStyle;
        bClassName = LOBYTE(lpResItem->wClassName);
        strcpy( szCaption, lpResItem->lpszCaption );
        strcpy( szClassName, lpResItem->lpszClassName );
        strcpy( szFaceName, lpResItem->lpszFaceName );
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
    }

    // Write the header informations
    dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );

    // Store the position of the numofelem for a later fixup
    BYTE far * lpNumOfElem = lpNewImage;
    dwOverAllSize += PutByte( &lpNewImage, bNumOfElem, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
    dwOverAllSize += PutNameOrOrd( &lpNewImage, 0, "", &dwNewImageSize );
    dwOverAllSize += PutClassName( &lpNewImage, bClassName, &szClassName[0], &dwNewImageSize );
    dwOverAllSize += PutCaptionOrOrd( &lpNewImage, 0, &szCaption[0], &dwNewImageSize,
                                      bClassName, dwStyle );
    if ( dwStyle & DS_SETFONT ) {
        dwOverAllSize += PutWord( &lpNewImage, wPointSize, &dwNewImageSize );
        dwOverAllSize += PutString( &lpNewImage, &szFaceName[0], &dwNewImageSize );
    }

    while ( dwNewSize>0 ) {
        bNumOfElem++;

        if ( dwNewSize ) {
            /*
            TRACE1("\t\tGenerateDialog:\tdwNewSize=%ld\n",(LONG)dwNewSize);
            TRACE1("\t\t\t\tlpszCaption=%Fs\n",lpResItem->lpszCaption);
            */
            lpResItem = (LPRESITEM) lpBuf;
            wX = lpResItem->wX;
            wY = lpResItem->wY;
            wcX = lpResItem->wcX;
            wcY = lpResItem->wcY;
            wId = LOWORD(lpResItem->dwItemID);
            dwStyle = lpResItem->dwStyle;
            bClassName = LOBYTE(lpResItem->wClassName);
            strcpy( szCaption, lpResItem->lpszCaption );
            strcpy( szClassName, lpResItem->lpszClassName );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        //write the control
        dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize );
        dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
        dwOverAllSize += PutControlClassName( &lpNewImage, bControlClassName, &szClassName[0], &dwNewImageSize );
        dwOverAllSize += PutCaptionOrOrd( &lpNewImage, 0, &szCaption[0], &dwNewImageSize,
                                          bControlClassName, dwStyle );
        dwOverAllSize += PutByte( &lpNewImage, 0, &dwNewImageSize );
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    // fixup the number of items
    PutByte( &lpNumOfElem, bNumOfElem, &dwNewImageSize );

    return uiError;
}


static
BYTE
SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwSize )
{
    if (*pdwSize>=(int)uiSkip) {
        *lplpBuf += uiSkip;;
        *pdwSize -= uiSkip;
    }
    return (BYTE)uiSkip;
}

static
BYTE
PutDWord( BYTE far * far* lplpBuf, DWORD dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWord && (*pdwSize != -1)) {
        memcpy(*lplpBuf, &dwValue, sizeofDWord);
        *lplpBuf += sizeofDWord;
        *pdwSize -= sizeofDWord;
    } else *pdwSize = -1;
    return sizeofDWord;
}

static
BYTE
GetDWord( BYTE far * far* lplpBuf, DWORD* dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWord) {
        memcpy( dwValue, *lplpBuf, sizeofDWord);
        *lplpBuf += sizeofDWord;
        *pdwSize -= sizeofDWord;
    }
    return sizeofDWord;
}

static
BYTE
PutWord( BYTE far * far* lplpBuf, WORD wValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofWord && (*pdwSize != -1)) {
        memcpy(*lplpBuf, &wValue, sizeofWord);
        *lplpBuf += sizeofWord;
        *pdwSize -= sizeofWord;
    } else *pdwSize = -1;
    return sizeofWord;
}

static
BYTE
GetWord( BYTE far * far* lplpBuf, WORD* wValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofWord) {
        memcpy( wValue, *lplpBuf, sizeofWord);
        *lplpBuf += sizeofWord;
        *pdwSize -= sizeofWord;
    }
    return sizeofWord;
}

static
BYTE
PutByte( BYTE far * far* lplpBuf, BYTE bValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofByte && (*pdwSize != -1)) {
        memcpy(*lplpBuf, &bValue, sizeofByte);
        *lplpBuf += sizeofByte;
        *pdwSize -= sizeofByte;
    } else *pdwSize = -1;
    return sizeofByte;
}

static
BYTE
GetByte( BYTE far * far* lplpBuf, BYTE* bValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofByte) {
        memcpy(bValue, *lplpBuf, sizeofByte);
        *lplpBuf += sizeofByte;
        *pdwSize -= sizeofByte;
    }
    return sizeofByte;
}

static
UINT
GetCaptionOrOrd( BYTE far * far* lplpBuf,  WORD* wOrd, LPSTR lpszText, LONG* pdwSize,
                 BYTE bClass, DWORD dwStyle )
{
    UINT uiSize = 0;

    // Icon might not have an ID so check first
    *wOrd = 0;
    // read the first BYTE to see if it is a string or an ordinal
    uiSize += GetByte( lplpBuf, (BYTE*)wOrd, pdwSize );
    if (LOBYTE(*wOrd)==0xFF) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        *lpszText = '\0';
        uiSize = 3;
    } else {
        *lpszText++ = LOBYTE(*wOrd);
        if (LOBYTE(*wOrd))
            uiSize += GetString( lplpBuf, lpszText, pdwSize);
        *wOrd = 0;
    }
    return uiSize;
}

static
UINT
GetNameOrOrd( BYTE far * far* lplpBuf,  WORD* wOrd, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    *wOrd = 0;
    // read the first BYTE to see if it is a string or an ordinal
    uiSize += GetByte( lplpBuf, (BYTE*)wOrd, pdwSize );
    if (LOBYTE(*wOrd)==0xFF) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        *lpszText = '\0';
        uiSize = 3;
    } else {
        *lpszText++ = LOBYTE(*wOrd);
        if (LOBYTE(*wOrd))
            uiSize += GetString( lplpBuf, lpszText, pdwSize);
        *wOrd = 0;
    }
    return uiSize;
}

static
UINT
PutCaptionOrOrd( BYTE far * far* lplpBuf,  WORD wOrd, LPSTR lpszText, LONG* pdwSize,
                 BYTE bClass, DWORD dwStyle )
{
    UINT uiSize = 0;

    // If this is an ICON then can just be an ID
    if (wOrd) {
        uiSize += PutByte(lplpBuf, 0xFF, pdwSize);
        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
    } else {
        uiSize += PutString(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


static
UINT
PutNameOrOrd( BYTE far * far* lplpBuf,  WORD wOrd, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if (wOrd) {
        uiSize += PutByte(lplpBuf, 0xFF, pdwSize);
        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
    } else {
        uiSize += PutString(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


static
UINT
GetClassName( BYTE far * far* lplpBuf,  BYTE* bClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    *bClass = 0;
    // read the first BYTE to see if it is a string or an ordinal
    uiSize += GetByte( lplpBuf, bClass, pdwSize );

    if ( !(*bClass)) {
        // This is an Ordinal
        *lpszText = '\0';
    } else {
        *lpszText++ = *bClass;
        if (*bClass)
            uiSize += GetString( lplpBuf, lpszText, pdwSize);
        *bClass = 0;
    }
    return uiSize;
}

static
UINT
GetControlClassName( BYTE far * far* lplpBuf,  BYTE* bClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    *bClass = 0;
    // read the first BYTE to see if it is a string or an ordinal
    uiSize += GetByte( lplpBuf, bClass, pdwSize );

    if ( (*bClass) & 0x80) {
        // This is an Ordinal
        *lpszText = '\0';
    } else {
        *lpszText++ = *bClass;
        if (*bClass)
            uiSize += GetString( lplpBuf, lpszText, pdwSize);
        *bClass = 0;
    }
    return uiSize;
}

static
UINT
PutClassName( BYTE far * far* lplpBuf,  BYTE bClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if ( !(lpszText[0])) {
        // This is an Ordinal
        uiSize += PutByte(lplpBuf, bClass, pdwSize);
    } else {
        uiSize += PutString(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}

static
UINT
PutControlClassName( BYTE far * far* lplpBuf,  BYTE bClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if ( bClass & 0x80) {
        // This is an Ordinal
        uiSize += PutByte(lplpBuf, bClass, pdwSize);
    } else {
        uiSize += PutString(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


static
UINT
PutString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    int iSize = strlen(lpszText)+1;
    if (*pdwSize>=iSize && (*pdwSize != -1)) {
        memcpy(*lplpBuf, lpszText, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else *pdwSize = -1;
    return iSize;
}

static
UINT
PutPascalString( BYTE far * far* lplpBuf, LPSTR lpszText, BYTE bLen, LONG* pdwSize )
{
    BYTE bSize = PutByte( lplpBuf, bLen, pdwSize );
    if (*pdwSize>=bLen && (*pdwSize != -1)) {
        memcpy(*lplpBuf, lpszText, bLen);
        *lplpBuf += bLen;
        *pdwSize -= bLen;
    } else *pdwSize = -1;
    return bSize+bLen;
}


static
UINT
GetString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    int iSize = strlen((char*)*lplpBuf)+1;
    if (*pdwSize>=iSize) {
        memcpy( lpszText, *lplpBuf, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else {
        *lplpBuf = '\0';
        *lpszText = '\0';
    }
    return iSize;
}

static
int
GetVSString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize, int cMaxLen )
{
    // We have to stop at Maxlen to avoid read too much.
    // This is to fix a bug where some string that are supposed to be NULL
    // terminated are not.
    int iSize = strlen((char*)*lplpBuf)+1;
    if (iSize>cMaxLen)
        iSize = cMaxLen;
    if (*pdwSize>=iSize) {
        memcpy( lpszText, *lplpBuf, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else *lplpBuf = '\0';
    *(lpszText+iSize) = '\0';
    return iSize;
}

static
UINT
CopyText( BYTE far * far * lplpTgt, BYTE far * far * lplpSrc, LONG* pdwTgtSize, LONG* pdwSrcSize)
{
    if (!*lplpSrc) return 1;
    int uiStrlen = strlen((char*)*lplpSrc)+1;
    TRACE("Len: %d\tTgtSize: %ld\tImageSize: %ld", uiStrlen, *pdwTgtSize, *pdwSrcSize);
    if (uiStrlen>*pdwTgtSize) {
        TRACE("\n");
        *pdwTgtSize = -1;
        return uiStrlen;
    } else {
        strcpy( (char*)*lplpTgt, (char*)*lplpSrc);
        TRACE1("\tCaption: %Fs\n", (char*)*lplpTgt);
        if (*pdwSrcSize>=uiStrlen) {
            *lplpSrc += uiStrlen;
            *pdwSrcSize -= uiStrlen;
        }
        *lplpTgt += uiStrlen;
        *pdwTgtSize -= uiStrlen;
        return uiStrlen;
    }
}

static LPRESITEM
GetItem( BYTE far * lpBuf, LONG dwNewSize, LPSTR lpStr )
{
    LPRESITEM lpResItem = (LPRESITEM) lpBuf;

    while (strcmp(lpResItem->lpszClassName, lpStr)) {
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
        if (dwNewSize<=0)
            return LPNULL;
        lpResItem = (LPRESITEM) lpBuf;
    }
    return lpResItem;
}

static DWORD CalcID( WORD wId, BOOL bFlag )
{
    // We want to calculate the ID Relative to the WORD wId
    // If we have any other ID with the same value then we return
    // the incremental number + the value.
    // If no other Item have been found then the incremental number will be 0.
    // If bFlag = TRUE then the id get added to the present list.
    // If bFlag = FALSE then the list is reseted and the function return

    // Clean the array if needed
    if (!bFlag) {
        wIDArray.RemoveAll();
        return 0;
    }

    // Add the value to the array
    wIDArray.Add(wId);

    // Walk the array to get the number of duplicated ID
    short c = -1; // will be 0 based
    for (short i=(short)wIDArray.GetUpperBound(); i>=0 ; i-- ) {
        if (wIDArray.GetAt(i)==wId)
            c++;
    }
    TRACE3("CalcID: ID: %hd\tPos: %hd\tFinal: %lx\n", wId, c, MAKELONG( wId, c ));
    return MAKELONG( wId, c );
}

static LONG Allign( BYTE** lplpBuf, LONG* plBufSize, LONG lSize )
{
    LONG lRet = 0;
    BYTE bPad = (BYTE)Pad4(lSize);
    lRet = bPad;
    if (bPad && *plBufSize>=bPad) {
        while (bPad && *plBufSize) {
            **lplpBuf = 0x00;
            *lplpBuf += 1;
            *plBufSize -= 1;
            bPad--;
        }
    }
    return lRet;
}

static void ChangeLanguage( LPVOID lpBuffer, UINT uiBuffSize )
{
    BYTE * pBuf = (BYTE*)lpBuffer;
    LONG lSize = 0;

    while (uiBuffSize) {
        // Skip
        lSize += SkipByte( &pBuf, 2, (LONG*)&uiBuffSize );
        lSize += SkipByte( &pBuf, strlen((LPCSTR)pBuf)+1, (LONG*)&uiBuffSize );
        lSize += SkipByte( &pBuf, Pad4(lSize), (LONG*)&uiBuffSize );

        lSize += SkipByte( &pBuf, 2, (LONG*)&uiBuffSize );
        lSize += SkipByte( &pBuf, strlen((LPCSTR)pBuf)+1, (LONG*)&uiBuffSize );
        lSize += SkipByte( &pBuf, Pad4(lSize), (LONG*)&uiBuffSize );

        lSize += PutDWord( &pBuf, gLang, (LONG*)&uiBuffSize );

        lSize += SkipByte( &pBuf, 4, (LONG*)&uiBuffSize );

        lSize += SkipByte( &pBuf, 4, (LONG*)&uiBuffSize );
    }


}

////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation

////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        // NOTE: global/static constructors have already been called!
        // Extension DLL one-time initialization - do not allocate memory
        // here, use the TRACE or ASSERT macros or call MessageBox
        AfxInitExtensionModule(extensionDLL, hInstance);
    } else if (dwReason == DLL_PROCESS_DETACH) {
        // Terminate the library before destructors are called
        AfxWinTerm();
    }

    if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
        return 0;       // CRT term	Failed

    return 1;   // ok
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\commbase.c ===
#ifdef RLWIN32
#include <windows.h>
#else
#ifdef RLWIN16
#include <windows.h>
//#include <ntimage.h>
//#else // DOS BUILD
//#include <ntimage.h>
#endif
#endif


// CRT includes
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <io.h>
#include <time.h>
//#include <sys\types.h>
//#include <sys\stat.h>

#ifdef RLDOS
    #include "dosdefs.h"
#else
    #include "windefs.h"
#endif


#include "commbase.h"
#include "restok.h"
#include "tokenapi.h"

extern UCHAR szDHW[];


/**
  *  Function: StripNewLine
  *    Replaces new line characters with nulls
  *
  *  Arguments:
  *    sz, string to be stripped
  *
  *  Returns:
  *    nothing
  *
  *  Error Codes:
  *    none
  *
  *  History:
  *    2/92, Implemented    SteveBl
  *   10/92, Simplified to only check last char in non-empty string - DaveWi
  */

void StripNewLineA( CHAR *sz)
{
    int i;

    if ( sz && (i = lstrlenA( sz)) > 0 )
    {
        if ( sz[ --i] == '\n' )
        {
            sz[i] = 0;
        }
    }
}


//.....................................................
//...
//... A Unicode NewLine is TEXT("\r\n") - two separate characters

void StripNewLineW(  LPWSTR sz)
{
    int i = lstrlenW( sz);

    if ( i > 0 && sz[ --i] == TEXT('\n') )
    {
        sz[i] = TEXT('\0');

        if ( i > 0 && sz[ --i] == TEXT('\r') )
        {
            sz[i] = TEXT('\0');
        }
    }
}

//+-------------------------------------------------------------------------
//
// Function:    IsExe, Public
//
// Synopsis:    Determines if the specified file is an executable image file
//
//
// Arguments:   [szFileName]    The name of the file to determine whether it is an exe
//
//
// Effects:
//
// Returns:     -1  Error Condition
//              NOTEXE     File is not an exe
//              WIN16EXE   File is a Win 16 exe
//              NTEXE      File is a win 32 exe
//              UNKNOWEXE  File is not a valid exe
//
// Modifies:
//
// History:
//              10-Oct-92   Created     TerryRu
//
//
// Notes:
//
//--------------------------------------------------------------------------

int IsExe( CHAR *szFileName )
{
    static IMAGE_DOS_HEADER        DosHeader;
    static IMAGE_OS2_HEADER        ImageNeFileHdr;
    static IMAGE_FILE_HEADER       ImageFileHdr;
    static IMAGE_OPTIONAL_HEADER   ImageOptionalHdr;
    DWORD   neSignature;
    FILE    *fIn = NULL;
    WORD    rc;


    if ( (fIn = FOPEN( szFileName, "rb")) == NULL )
    {
        return ( -1 );
    }

    if ( ResReadBytes( fIn,
               (char *)&DosHeader,
               sizeof( IMAGE_DOS_HEADER),
               NULL) == FALSE
      || (DosHeader.e_magic != IMAGE_DOS_SIGNATURE ))
    {
        FCLOSE( fIn);
        return( NOTEXE);
    }

    // 1st byte was a valid signature, and we were able to read a DOS Hdr

    // now seek to address of new exe header


    if ( fseek( fIn, DosHeader.e_lfanew, SEEK_SET))
    {
        FCLOSE( fIn);
        return( NOTEXE);
    }

    // assume file is a Win 16 file,

    // Read the NT signature
    neSignature = (WORD) GetWord( fIn, NULL );

    if ( neSignature == IMAGE_OS2_SIGNATURE )
    {
        // return signature into input stream,
        // and read ne header as a whole
        UnGetWord( fIn, (WORD) neSignature, NULL );

    if ( ResReadBytes( fIn,
               (char *)&ImageNeFileHdr,
               sizeof( IMAGE_OS2_HEADER),
               NULL) == FALSE )
        {
            FCLOSE( fIn);
            return( NOTEXE);
        }

        // determine if file is a WIN 16 Image File
        if ( ImageNeFileHdr.ne_ver >= 4 && ImageNeFileHdr.ne_exetyp == 2 )
        {
            FCLOSE( fIn);
            return( WIN16EXE);
        }
    }

    // not a win 16 exe, check for a NT exe.
    UnGetWord( fIn, (WORD) neSignature, NULL );
    neSignature =  GetdWord( fIn, NULL );

    if ( neSignature == IMAGE_NT_SIGNATURE )
    {
        if ( ResReadBytes( fIn,
               (char *)&ImageFileHdr,
               sizeof( IMAGE_FILE_HEADER),
               NULL) == FALSE )
        {
            FCLOSE( fIn);
            return( NOTEXE);
        }


        if ( ImageFileHdr.SizeOfOptionalHeader )
        {

            // read the optional header  only to validate the ImageFileHeader
            // we currently don\'t use any info in the Optional Header

            if ( ImageFileHdr.SizeOfOptionalHeader
                 > sizeof( IMAGE_OPTIONAL_HEADER ) )
            {
                FCLOSE( fIn);
                return( NOTEXE);
            }

            if ( ResReadBytes( fIn,
                   (char *)&ImageOptionalHdr,
                   (size_t)min( sizeof( IMAGE_OPTIONAL_HEADER),
                                            ImageFileHdr.SizeOfOptionalHeader),
                   NULL) == FALSE )
            {
                FCLOSE( fIn);
                return( NOTEXE);
            }
        }

        // determine if file is an executable image file
        if ( (ImageFileHdr.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) ||
	     (ImageFileHdr.Characteristics & IMAGE_FILE_DLL) )
        {
            FCLOSE( fIn);
            return( NTEXE);
        }
        else
        {
            FCLOSE( fIn);
            return( NOTEXE);
        }
    }
    FCLOSE( fIn);

    // did not regonize signature type

    return( NOTEXE);
}




BOOL IsWin32Res( CHAR * szFileName)
{
    BOOL fRC = FALSE;

    if ( IsRes( szFileName) )
    {
        FILE *pF = fopen( szFileName, "rb");

        if ( pF )
        {
            DWORD dwSize = GetdWord( pF, NULL);
            fclose( pF);

            fRC = (dwSize == 0L) ? TRUE : FALSE;
        }
        else
        {
            fRC = FALSE;
        }
    }
    else
    {
        fRC = FALSE;
    }
    return( fRC);
}



//+-------------------------------------------------------------------------
//
// Function:    IsRes, Public
//
// Synopsis:    Determines if the specified file has a .RES extention.
//
//
// Arguments:   [szFileName]    The name of the file to determine whether it is a res
//
//
// Effects:
//
// Returns:     TRUE, File has a .RES extention
//              FALSE, File does not have a .RES extention
//
// Modifies:
//
// History:
//              16-Oct-92   Created     TerryRu
//
//
// Notes:
//
//--------------------------------------------------------------------------

BOOL IsRes( CHAR *szFileName)
{
    int i = lstrlenA( szFileName);

    return( (i > 4 && lstrcmpiA( szFileName + i - 4, ".RES") == 0) ? TRUE : FALSE );
}




/**
  * Function TranslateFileTime
  *    Translates a Win32 filetime structure into a useful string
  *    representation.
  *
  *  Arguments:
  *    sz, destination buffer (ANSI string)
  *    ft, file time structure
  *
  *  Returns:
  *    sring representation of date/time in sz
  *
  *  History:
  *    7/92 implemented SteveBl
  */
#ifdef RLWIN32
void TranslateFileTime(CHAR *sz, FILETIME ft)
{
    sprintf(sz,"FILETIME STRUCTURE: %Lu:%Lu",ft.dwHighDateTime,ft.dwLowDateTime);
}
#endif

/**
  *  Function: SzDateFromFileName
  *    Returns a string containing the time and date stamp on a file.
  *
  *  Arguments:
  *   sz, destination buffer
  *   szFile, path to file
  *
  *  Returns:
  *   date and time in sz
  *
  *  Error Codes:
  *   none (but leaves sz empty)
  *
  *  Comments:
  *   Assumes sz is large enough for date string.
  *
  *  History:
  *   2/92, Implemented       SteveBl
  */
void SzDateFromFileName(CHAR *sz,CHAR *szFile)
{

#ifdef RLWIN32

    HANDLE hFile;
    WCHAR szt[MAXFILENAME];

    _MBSTOWCS( szt,
               szFile,
               WCHARSIN( sizeof( szt)),
               ACHARSIN( lstrlenA( szFile) + 1));

    hFile = CreateFile( szt,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL);

    if ( hFile != (HANDLE)-1 )
    {
        FILETIME ft;

        GetFileTime( hFile, NULL, NULL, &ft);
        TranslateFileTime( sz, ft);
        CloseHandle( hFile);
    }
#else //RLWIN32
    struct _stat s;

    if (!_stat(szFile,&s))
    {
        sprintf(sz,"%s",ctime(&s.st_atime));
        StripNewLine(sz);
    }
    else
    {
        sz[0] = 0;
    }
#endif
}


//..........................................................................

#ifdef _DEBUG
FILE * MyFopen( char * pszFileName, char * pszMode, char * pszFile, int nLine)
#else
FILE * MyFopen( char * pszFileName, char * pszMode)
#endif
{
    FILE *pfRC = NULL;

//#ifdef _DEBUG
//    fprintf( stderr, "fopening \"%s\" at %d in %s",
//                     pszFileName,
//                     nLine,
//                     pszFile);
//#endif
    pfRC = fopen( pszFileName, pszMode);

//#ifdef _DEBUG
//    fprintf( stderr, ": FILE ptr = %p\n", pfRC);
//#endif
    return( pfRC);
}

//..........................................................................
#ifdef _DEBUG
int MyClose( FILE **pf, char * pszFile, int nLine)
#else
int MyClose( FILE **pf)
#endif
{
	int nRC = 0;

//#ifdef _DEBUG
//    fprintf( stderr, "\tclosing %p at %d in %s\n", *pf, nLine, pszFile);
//#endif

	if ( *pf )
	{
		nRC = fclose( *pf);
		*pf = NULL;
	}
    return( nRC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\checksum.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    imagehlp.h

Abstract:

    This module defines the prptotypes and constants required for the image
    help routines.

Revision History:

--*/

#ifndef _IMAGEHLP_
#define _IMAGEHLP_

DWORD MapFileAndFixCheckSumA( LPSTR Filename);
DWORD MapFileAndFixCheckSumW( PWSTR Filename);

#ifdef UNICODE
#define MapFileAndFixCheckSum MapFileAndFixCheckSumW
#else
#define MapFileAndFixCheckSum MapFileAndFixCheckSumA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\commbase.h ===
#ifndef _COMMBASE_H_
#define _COMMBASE_H_

void StripNewLineA(  LPSTR sz);
void StripNewLineW( LPWSTR sz);

#ifdef UNICODE
#define StripNewLine StripNewLineW
#else
#define StripNewLine StripNewLineA
#endif

void SzDateFromFileName( char *sz, char *szFile);

#endif // _COMMBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\custres.h ===
/* CustRes.h
 *
 * Header file for CustRes.c
 */

#ifndef _CUSTRES_H_
#define _CUSTRES_H_

#include <stdio.h>

#ifndef BYTELN
#include "restok.h"
#endif

#ifndef CHAR
#define CHAR char
#endif

typedef struct Custom_Resource
{
    void far *pData;
    struct Custom_Resource far* pNext;
} CUSTOM_RESOURCE;

typedef CUSTOM_RESOURCE far * FPCUSTOM_RESOURCE;
int  ParseResourceDescriptionFile(FILE *ResourceDescriptionFile,
                                  int *piErrorLine);

void ClearResourceDescriptions(void);

int  GetCustomResource(FILE *inResFile, DWORD *lSize,
                       FPCUSTOM_RESOURCE *ppCustomResource,
                       RESHEADER ResHeader);

void TokCustomResource(FILE *TokFile, RESHEADER ResHeader,
                       FPCUSTOM_RESOURCE*ppCustomResource);

void PutCustomResource(FILE *OutResFile, FILE *TokFile,
                       RESHEADER ResHeader,
                       FPCUSTOM_RESOURCE *ppCustomResource);

void ClearCustomResource(FPCUSTOM_RESOURCE *ppCustomResource);

int  ParseResourceDescriptionFile(FILE *,int *);
int  LoadCustResDescriptions( CHAR *);

WCHAR * BinToTextW( WCHAR rgc[], int cSource);
char  * BinToTextA(  CHAR rgc[], int cSource);

int     TextToBinW( TCHAR rgc[], TCHAR sz[], int l);
int     TextToBinA(  CHAR rgc[],  CHAR sz[], int l);

#ifdef RLRES32
#define TextToBin TextToBinW
#define BinToText BinToTextW
#else  //RLRES32
#define TextToBin TextToBinA
#define BinToText BinToTextA
#endif //RLRES32

int atoihex( CHAR szStr[]);

#endif // _CUSTRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\dosdefs.h ===
/* DOS macros and globals */

#ifndef _DOSDEFS_H_
#define _DOSDEFS_H_

#pragma message("Using the DOS translation of the common macros.")

#ifndef RLDOS
#pragma message("\n****************************************************************************\n")
#pragma message("Hey!  I think you meant to use the Windows translation of the common macros!")
#pragma message("\n****************************************************************************\n")
#endif

#include "fcntl.h"
#include "dos.h"

#ifndef NULL
   #if (_MSC_VER >= 600)
      #define NULL   ((void *)0)
   #elif (defined(M_I86SM) || defined(M_I86MM))
      #define NULL   0
   #else
      #define NULL   0L
   #endif
#endif

#define FALSE     0
#define TRUE      1

#define FAR       far
#define NEAR      near
#define LONG      long
#define VOID      void
#define PASCAL	  pascal
#define WINAPI

#define MAKELONG(a,b)  ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)      ((BYTE)(w))
#define HIBYTE(w)	   (((WORD)(w) >> 8) & 0xFF)
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
typedef unsigned char   BYTE;
typedef unsigned char  *PBYTE;
typedef unsigned long	DWORD;
typedef unsigned int	UINT;
typedef unsigned	WORD;
typedef int             BOOL;
typedef char           *PSTR;
typedef char NEAR      *NPSTR;
typedef char FAR       *LPSTR;
typedef int  FAR       *LPINT;
#define  CHAR           char
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#define WCHAR wchar_t
typedef WCHAR *PWCHAR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef LPSTR PTSTR, LPTSTR;
#define TEXT(quote) quote
typedef unsigned char UCHAR;
typedef char *PCHAR;
#define UNALIGNED
#define DS_SETFONT 0x40L
int         _ret;
unsigned    _error;

/* These macros are for near heap only */

#define FOPEN(sz)                ((_ret=-1),(_error=_dos_open(sz,O_RDONLY,&_ret)),_ret)
#define FCREATE(sz)              ((_ret=-1),(_error=_dos_creat(sz,_A_NORMAL,&_ret)),_ret)
#define FCLOSE(fh)               ((_error=_dos_close(fh)))
#define FREAD(fh,buf,len)        ((_error=_dos_read(fh,buf,len,&_ret)),_ret)
#define FWRITE(fh,buf,len)       ((_error=_dos_write(fh,buf,len,&_ret)),_ret)
#define FSEEK(fh,off,i)          lseek(fh,(long)(off),i)
#define FERROR()		 _error

#define __FCLOSE(fp)  {fflush(fp);fclose(fp);}	// NT 348 bug workaround DHW
#define ALLOC(n)                 malloc(n)
#define FREE(p)                  free(p)
#define SIZE(p)                  _msize(p)
#define REALLOC(p,n)             realloc(p,n)
#define FMEMMOVE( szDst, szSrc, uSize)  _fmemmove( szDst, szSrc, uSize )
#define FSTRNCPY( szDst, szSrc, uSize)  _fstrncpy( szDst, szSrc, uSize )


#define _MBSTOWCS(ds,ss,dc,sc) mbstowcs(ds,ss,sc)
#define _WCSTOMBS(ds,ss,dc,sc) wcstombs(ds,ss,sc)

/* here are some macros for allocating and freeing far heap space */

#define FALLOC(n)                _fmalloc(n)
#define FFREE(n)                 _ffree(n)
#define FREALLOC(p,n)            _frealloc(p,n)

/* Some common translations macros                                */
#define SPRINTF                  sprintf
#define STRUPR                   strupr

#endif // _DOSDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\custres.c ===
/** CustRes.c
  *
  * Custom resource handler module for TOKRES.
  *
  * Written by SteveBl
  *
  * Exported Functions:
  * int  ParseResourceDescriptionFile(FILE *ResourceDescriptionFile);
  *
  * int  GetCustomResource(FILE *inResFile, DWORD *lsize,
  *                CUSTOM_RESOURCE *pCustomResource,
  *                WORD wTypeId);
  *
  * void TokCustomResource(FILE *TokFile, RESHEADER ResHeader,
  *                CUSTOM_RESOURCE *pCustomResource);
  *
  * void PutCustomResource(FILE *OutResFile, FILE *TokFile,
  *                RESHEADER ResHeader,
  *                CUSTOM_RESOURCE *pCustomResource);
  *
  * void ClearCustomResource(CUSTOM_RESOURCE *pCustomResource);
  *
  * History:
  * Initial version written January 21, 1992.  -- SteveBl
  *
  * 01/21/93 - Changes to allow arb length token texts.  Also, fix
  *             some latent bugs.  MHotchin
  **/

#include <stdio.h>

#include <string.h>
#include <stdlib.h>
#include <tchar.h>

#ifdef RLDOS
#include "dosdefs.h"
#else
#include <windows.h>
#include "windefs.h"
#endif

#include "custres.h"
#include "restok.h"
#include "resread.h"


extern PROJDATA gProj;          //... Fields filled in main (UI)


extern BOOL  gbMaster;
extern UCHAR szDHW[];

enum LOCALIZABLE_TYPES  // determines data storage, reading, and printing method
{
    NOTLOCALIZABLE, // not to be stored
    NOTLOCALIZABLESZ,   // unlocalizable null terminated string
    NOTLOCALIZABLEWSZ,  // unlocalizable null terminated Unicode string
    LT_INTEGER,     // store as a long integer
    LT_FLOAT,       // store as a double preceision floating point number
    LT_CHAR,        // store as a single character
    LT_STRING,      // an array of char
    LT_SZ,          // a null terminated array of characters
    LT_WCHAR,       // store as a single Unicode character
    LT_WSTRING,     // an array of Unicode char
    LT_WSZ,         // a null terminated array of Unicode characters
    LT_UNSIGNED=16  // add with the others
};

typedef struct typesizes
{
    CHAR                  *szType;
    enum LOCALIZABLE_TYPES iType;
    int                    iShortSize;
    int                    iLongSize;
} TYPESIZES;

TYPESIZES rgTypeSizes[] =
{
#ifdef RLWIN32
    "WCHAR",    LT_WCHAR,       2,  2,
    "TCHAR",    LT_WCHAR,       2,  2,
    "INT",      LT_INTEGER,     4,  4,
    "SIGNED",   LT_INTEGER,     4,  4,
    "UNSIGNED", LT_INTEGER,     4,  4,
    "ENUM",     LT_INTEGER,     4,  4,
#else  //RLWIN32
    "TCHAR",    LT_CHAR,        1,  1,
    "INT",      LT_INTEGER,     2,  4,
    "SIGNED",   LT_INTEGER,     2,  4,
    "UNSIGNED", LT_INTEGER,     2,  4,
    "ENUM",     LT_INTEGER,     2,  2,
#endif //RLWIN32
    "CHAR",     LT_CHAR,        1,  1,
    "BYTE",     LT_INTEGER,     1,  1,
    "WORD",     LT_INTEGER,     2,  2,
    "SHORT",    LT_INTEGER,     2,  2,
    "FLOAT",    LT_FLOAT,       4,  4,
    "LONG",     LT_INTEGER,     4,  4,
    "DOUBLE",   LT_FLOAT,       8,  8,
    "DWORD",    LT_INTEGER,     4,  4
};

typedef struct resourcetypes
{
    CHAR *szType;
    int   iType;
} RESOURCETYPES;

RESOURCETYPES rgResourceTypes[] =
{
    "CURSOR",        1,
    "BITMAP",        2,
    "ICON",          3,
    "MENU",          4,
    "DIALOG",        5,
    "STRING",        6,
    "FONTDIR",       7,
    "FONT",          8,
    "ACCELERATORS",  9,
    "RCDATA",       10,
    "ERRTABLE",     11,
    "GROUP_CURSOR", 12,
    "GROUP_ICON",   14,
    "NAMETABLE",    15,
    "VERSION",      16
};

typedef struct CustResTemplate
{
    enum LOCALIZABLE_TYPES      iType;
    unsigned                    uSize;
    struct CustResTemplate far *pNext;
} CUSTRESTEMPLATE;

typedef struct CustResNode
{
    BYTE    bTypeFlag;      /* Indicat's if ID or string */
    BYTE    bNameFlag;      /* Indicat's if ID or string */
    WORD    wTypeID;
    WORD    wNameID;
    TCHAR    *pszType;
    TCHAR    *pszName;
    CUSTRESTEMPLATE far *pTemplate;
    struct CustResNode far *pNext;
} CUSTRESNODE;

typedef CUSTRESTEMPLATE far * FPCUSTRESTEMPLATE;
typedef CUSTRESNODE far * FPCUSTRESNODE;

CUSTRESNODE far *pCustResList = NULL;

#define SYMBOLSIZE 255

int  fUseSavedSymbol = FALSE;
int *piLineNumber    = NULL;
CHAR szSavedSymbol[ SYMBOLSIZE];

/*
 * Function Predefinitions:
 */
static int GetResourceType( CHAR sz[]);
static int AddStructureElement( int iType,
                                int nSize,
                                FPCUSTRESTEMPLATE *ppCRT,
                                int fMerge);
#ifdef RLWIN32
static void AddToW( TCHAR *sz, int *c, int lTarget, TCHAR ch);
static TCHAR *CheckBufSizeW(
    int   *lTarget,     //... Length of output buffer
    int    cOutBufLen,  //... Bytes already used in output buffer
    int    cDelta,      //... # characters we want to add to output buffer
    TCHAR *szOutBuf);   //... ptr to output buffer
#endif

static CHAR *CheckBufSize(
    int  *lTarget,      //... Length of output buffer
    int   cOutBufLen,   //... Bytes already used in output buffer
    int   cDelta,       //... # characters we want to add to output buffer
    CHAR *szOutBuf);    //... ptr to output buffer
static void AddTo( CHAR *sz, int *c, int lTarget, CHAR ch);
static int  UngetSymbol( CHAR sz[]);
static int  GetNextSymbol( CHAR sz[], unsigned n, FILE *f);
static int  ParseBlock( FILE *f, FPCUSTRESTEMPLATE  *ppCRT);
static CUSTRESNODE far * MatchResource( RESHEADER Resheader);
static void far * GetResData( enum LOCALIZABLE_TYPES wType,
                              unsigned uSize,
                              FILE *f,
                              DWORD *lSize);
static int PutResData( void far *pData,
                       enum LOCALIZABLE_TYPES wType,
                       unsigned uSize,
                       FILE *f);
static void far * GetTextData( enum LOCALIZABLE_TYPES wType,
                               unsigned uSize,
                               TCHAR sz[]);
static int PutTextData( void far *pData,
                        enum LOCALIZABLE_TYPES wType,
                        unsigned uSize,
                        TCHAR sz[],
                        int l);
int  atoihex( CHAR sz[]);

/** Function: GetResourceType
  * Returns the value of the number or resource type in sz.
  *
  * Arguments:
  * sz, string containing either a positive number or a resource type
  *
  * Returns:
  * value in resource
  *
  * Error Codes:
  * -1 if illegal value
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  **/
static int GetResourceType( CHAR sz[])
{
    int i;

    if (sz[0] >= '0' && sz[0] <= '9')
    {
        return atoi(sz);
    }

    for (i = sizeof(rgResourceTypes)/sizeof(RESOURCETYPES);i--;)
    {
        if ( ! lstrcmpiA( sz, rgResourceTypes[i].szType) )
        {
            return rgResourceTypes[i].iType;
        }
    }
    return -1;
}

/** Function: AddStructureElement
  * Adds an element's type and size to the Template list.
  * If this element can be merged with the last element do so.
  *
  * Arguments:
  * iType, how the data is interpreted
  * nSize, number of bytes used by the data
  * ppCRT, pointer to the next Custom Resource Template pointer
  * fMerge, if true then NOTLOCALIZABLE data will be merged.
  *
  * Returns:
  * 0 - if successful
  * !0 - if unsuccessful
  *
  * Error Codes:
  * 1 - out of memory
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  **/

static int AddStructureElement(

int                iType,
int                nSize,
FPCUSTRESTEMPLATE *ppCRT,
int                fMerge)
{
    if ( fMerge
      && ((iType == NOTLOCALIZABLE    && (*ppCRT)->iType == NOTLOCALIZABLE)
       || (iType == NOTLOCALIZABLESZ  && (*ppCRT)->iType == NOTLOCALIZABLESZ)
       || (iType == NOTLOCALIZABLEWSZ && (*ppCRT)->iType == NOTLOCALIZABLEWSZ)))
    {
        // combine this with the last one
        (*ppCRT)->uSize+=nSize;
        return 0;
    }
    // can't be combined with previous element
    (*ppCRT)->pNext = (CUSTRESTEMPLATE far *)FALLOC( sizeof( CUSTRESTEMPLATE));
    (*ppCRT) = (*ppCRT)->pNext;
    if (!*ppCRT)
    {
        return 1;
    }
    (*ppCRT)->iType = iType;
    (*ppCRT)->uSize = nSize;
    (*ppCRT)->pNext = NULL;
    return 0;
}

/**
 * Function: UngetSymbol
 * Causes GetNextSymbol to get this symbol next time.
 *
 * Arguments:
 * sz, string buffer for symbol
 *
 * Returns:
 * 0 - if successful
 * 1 - if unsuccessful
 *
 * Error Codes:
 * 1 - tried to unget two symbols in a row
 *
 * History:
 * 1/92 - initial implementation -- SteveBl
 *
 **/

static int UngetSymbol( CHAR sz[])
{
    if ( fUseSavedSymbol )
    {
        return 1;   // can only unget one symbol
    }
    fUseSavedSymbol = 1;     
    CopyMemory( szSavedSymbol, sz, min( sizeof( szSavedSymbol) - 1, lstrlenA( sz)));
    szSavedSymbol[ sizeof( szSavedSymbol) - 1] = '\0';
    return( 0);
}

/**
 * Function: GetNextSymbol
 * Retrieves the next symbol from the file f.
 * Whitespace and comments are removed.
 * Comments are delimited by either c type comments or
 * # (in which case comment extends until end of line)
 * If the fUseSavedSymbol flag is set then it gets its symbol
 * from szSavedSymbol instead of the file.
 *
 * Arguments:
 * sz - string buffer for next symbol
 * n  - size of buffer
 * f  - handle to the input file
 *
 * Returns:
 * 0 if successful with symbol in sz
 * 1 if unsuccessful (sz undefined)
 *
 * Error Codes:
 * 1 - eof
 *
 * History:
 * 1/92 - initial implementation -- SteveBl
 **/

static int GetNextSymbol( CHAR sz[], unsigned n, FILE *f)
{
    unsigned c = 0;
    CHAR ch, chLast;

    if ( fUseSavedSymbol )
    {
        CopyMemory( sz, szSavedSymbol, min( (int)n, lstrlenA( szSavedSymbol) + 1));
        sz[ n == 0 ? 0 : n - 1] = '\0';
        fUseSavedSymbol = FALSE;
        return 0;
    }

    do
    {
        if (feof(f)) return 1;
            ch = (CHAR) getc(f);
        if (ch == '\n')
            ++*piLineNumber;
    }
    while ((ch == ' ') ||
           (ch == '\n') ||
           (ch == '\t') ||
           (ch == '\f') ||
           (ch == '\r') ||
           (ch == (CHAR)-1));

    if (ch == '#') // commented rest of line
    {
        do
        {
            if (feof(f))
            {
                return 1;
            }
        ch = (CHAR) getc(f);
        } while (ch != '\n');

        ++*piLineNumber;
        return GetNextSymbol( sz, n, f);
    }

    if (ch == '"') // it is a label, parse to the next quote
    {
        do
        {
            if (c<n)
            {
                sz[c++]=ch; // write all but the last quote
            }

            if (feof(f))
            {
                return 1;
            }
            ch = (CHAR)getc(f);

            if (ch == '\n')
            {
                return 1;
            }
        } while (ch != '"');

        if (c<n)
        {
            sz[ c++] = '\0';
        }
        else
        {
            sz[ n == 0 ? 0 : n - 1] = '\0';
        }
        return 0;
    }

    if (ch == '/') // possible comment
    {
        if (feof(f))
        {
            return 1;
        }
        ch = (CHAR) getc(f);

        if (ch == '/') // commented rest of line
        {
            do
            {
                if (feof(f))
                {
                    return 1;
                }
                ch = (CHAR) getc(f);
            } while (ch != '\n');

            ++*piLineNumber;
            return( GetNextSymbol( sz, n, f));
        }

        if (ch == '*') // commented until */
        {
            if (feof(f))
            {
                return 1;
            }
            ch = (CHAR) getc(f);

            if (ch == '\n')
            {
                ++*piLineNumber;
            }

            do
            {
                chLast = ch;
                if (feof(f))
                {
                    return 1;
                }
                ch = (CHAR) getc(f);

                if (ch == '\n')
                    ++*piLineNumber;
            } while (!(chLast == '*' && ch == '/'));
            return( GetNextSymbol( sz, n, f));
        }
        ungetc(ch, f);
    }
    // finally found the beginning of a symbol
    if (ch < '0' || (ch > '9' && ch < '@')
        || (ch > 'Z' && ch < 'a') || ch > 'z')
    {
        if (c<n)
        {
            sz[c++] = ch;
        }
        if (c<n)
        {
            sz[c] = '\0';
        }
        else
        {
            sz[ n == 0 ? 0 : n - 1] = 0;
        }
        return 0;
    }

    do
    {
        if (c<n)
        {
            sz[c++]=ch;
        }
        if (feof(f))
        {
            return 0;
        }
        ch = (CHAR) getc(f);
    } while((ch >= '0' && ch <= '9') ||
            (ch >= '@' && ch <= 'Z') ||
            (ch >= 'a' && ch <= 'z'));
    ungetc(ch, f);

    if (c<n)
    {
        sz[c] = '\0';
    }
    else
    {
        sz[ n == 0 ? 0 : n - 1] = '\0';
    }
    return 0;
}

/**
 * Function: ParseBlock
 *    Parses a block of a custom resource description from just after the
 *    first curly braces { to just after the closing curly braces } .
 *    It returns the size of the block it just parsed (in bytes).
 *
 * Arguments:
 * f, handle to an open description file
 * ppCRT, pointer to a pointer to the next Custom Resource Template node.
 *
 * Returns:
 * Updated pointer to the next Custom Resource Template node.
 * Number of bytes in this block.
 * (<0 if there was an error)
 *
 * Error Codes:
 * -1 - Syntax error
 * -2 - Unexpected end of file
 * -3 - out of memory
 *
 * History:
 * 1/92 - initial implementation -- SteveBl
 */

static int ParseBlock( FILE *f, FPCUSTRESTEMPLATE   * ppCRT)
{
    int c = 0; // size of the whole block
    int n = 0; // size of the current item
    int i;  //scratch variable
    int fUnsigned;
    int fLong;
    int iType; // type of the current item
    int nElements; // size of the array (if one exists)
    CHAR szSymbol[SYMBOLSIZE], sz[SYMBOLSIZE];
    CUSTRESTEMPLATE far *  pFirst,
        // saves the first one so we know where to count
        // from in case of an array
        far *pTemp, far *pEnd;
    int fMerge = 0;
        // it's only ok to merge after the first element has been written

    while (1)
    {
        pFirst = *ppCRT;

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
        {
            return -2;
        }

        if (szSymbol[0] == '}')
        {
            return c;
        }

        if ( ! lstrcmpiA( "near", szSymbol) )
        { // near * type
            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
            {
                return -2;
            }

            if (szSymbol[0]!='*')
            {
                return -1;
            }
            // may want to check for a legal type here
            do
            {
                if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                {
                    return -2;
                }
            } while ((szSymbol[0] != '[') &&
                     (szSymbol[0] != '}') &&
                     (szSymbol[0] != ','));

            UngetSymbol(szSymbol);
            n = 2;
            iType = NOTLOCALIZABLE;

            if (AddStructureElement(iType, n, ppCRT, fMerge))
            {
                return -3;
            }
        }
        else
        {
            if ( ! lstrcmpiA( "far", szSymbol) )
            { // far * type
                if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                {
                    return -2;
                }

                if (szSymbol[0] != '*')
                {
                    return -1;
                }
                // may want to check for a legal type here
                do
                {
                    if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                    {
                        return -2;
                    }
                } while ((szSymbol[0] != '[') &&
                         (szSymbol[0] != '}') &&
                         (szSymbol[0] != ','));

                UngetSymbol(szSymbol);
                n = 4;
                iType = NOTLOCALIZABLE;

                if(AddStructureElement(iType, n, ppCRT, fMerge))
                {
                    return -3;
                }
            }
            else
            {
        
                if (szSymbol[0] == '*')
                { // * type
                    // may want to check for a legal type here
                    do
                    {
                        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                        {
                            return -2;
                        }
                    } while ((szSymbol[0] != '[') &&
                             (szSymbol[0] != '}') &&
                             (szSymbol[0] != ','));

                    UngetSymbol(szSymbol);
                    n = 2;
                    iType = NOTLOCALIZABLE;

                    if(AddStructureElement(iType, n, ppCRT, fMerge))
                    {
                        return -3;
                    }
                }
                else
                {
                    if (szSymbol[0] == '{')
                    {
                        n = ParseBlock(f, ppCRT);

                        if (n<0)
                        {
                            return n;
                        }
                    }
                    else
                    { //it must be in our list of types
                        fUnsigned = 0;
                        fLong = 0;

                        if ( ! lstrcmpiA( "UNSIGNED", szSymbol) )
                        { // unsigned
                            if ( GetNextSymbol( sz, sizeof( sz), f) )
                            {
                                return -2;
                            }

                            if (sz[0] == '[' || sz[0] == ',')
                            {
                                UngetSymbol(sz);
                            }
                            else
                            {
                                lstrcpyA( szSymbol, sz);

                                if ( lstrcmpiA( sz, "SHORT")
                                  && lstrcmpiA( sz, "LONG")  
                                  && lstrcmpiA( sz, "CHAR")  
                                  && lstrcmpiA( sz, "TCHAR") 
                                  && lstrcmpiA( sz, "INT") )
                                {
                                    // must be followed by one of these
                                    return -1;
                                }
                            }
                            fUnsigned = 1;
                        }
                        else
                        {
                            if ( ! lstrcmpiA( "SIGNED", szSymbol) )
                            { // signed
                                if ( GetNextSymbol( sz, sizeof( sz), f) )
                                {
                                    return -2;
                                }

                                if (sz[0] == '[' || sz[0] == ',')
                                {
                                    UngetSymbol(sz);
                                }
                                else
                                {
                                    lstrcpyA( szSymbol, sz);

                                    if ( lstrcmpiA( sz, "SHORT") 
                                      && lstrcmpiA( sz, "LONG")  
                                      && lstrcmpiA( sz, "CHAR")  
                                      && lstrcmpiA( sz, "TCHAR") 
                                      && lstrcmpiA( sz, "INT") )
                                    {
                                        // must be followed by one of these
                                        return -1;
                                    }
                                }
                            }
                        }

                        if ( ! lstrcmpiA( "SHORT", szSymbol) )
                        { // short
                            if ( GetNextSymbol( sz, sizeof( sz), f) )
                            {
                                return -2;
                            }

                            if (sz[0] == '[' || sz[0] == ',')
                            {
                                UngetSymbol(sz);
                            }
                            else
                            {
                                lstrcpyA( szSymbol, sz);
                
                                if ( lstrcmpiA( sz, "INT") )
                                {
                                    // must be followed by one of these
                                    return -1;
                                }
                            }
                        }
                        else
                        {
                            if ( ! lstrcmpiA( "LONG", szSymbol) )
                            { // long
                                if ( GetNextSymbol( sz, sizeof( sz), f) )
                                {
                                    return -2;
                                }

                                if (sz[0] == '[' || sz[0] == ',')
                                {
                                    UngetSymbol(sz);
                                }
                                else
                                {
                                    lstrcpyA( szSymbol, sz);

                                    if ( lstrcmpiA( sz, "INT") 
                                      && lstrcmpiA( sz, "DOUBLE"))
                                    {
                                        // must be followed by one of these
                                        return -1;
                                    }
                                }
                                // BUG! - this code allows UNSIGNED LONG DOUBLE
                                // which is an illegal type in c.  But it's not
                                // a serious bug so I'll leave it.
                                fLong = 1;
                            }
                        }

                        i = sizeof(rgTypeSizes)/sizeof(TYPESIZES);

                        do
                        {
                            --i;
                        } while ( lstrcmpiA( szSymbol, rgTypeSizes[i].szType) && i);

                        if ( lstrcmpiA( szSymbol, rgTypeSizes[i].szType) )
                        {
                            return -1; // type not found in the list
                        }

                        if (fLong)
                        {
                            n = rgTypeSizes[i].iLongSize;
                        }
                        else
                        {
                            n = rgTypeSizes[i].iShortSize;
                        }

                        iType = rgTypeSizes[i].iType;

                        if (fUnsigned)
                        {
                            iType+=LT_UNSIGNED;
                        }

                        if ( lstrcmpA( szSymbol, rgTypeSizes[i].szType) )
                        {
                            iType = NOTLOCALIZABLE;  // type was not in all caps
                        }

                        if ( lstrcmpiA( szSymbol, "CHAR")  == 0
                          || lstrcmpiA( szSymbol, "TCHAR") == 0
                          || lstrcmpiA( szSymbol, "WCHAR") == 0 )
                        { // check for a string

                            lstrcpyA( szDHW, szSymbol);   // So can be used later

                            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                            {
                                return -2;
                            }

                            if (szSymbol[0] == '[') // we have a string
                            {
                                if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                                {
                                    return -2;
                                }

                                if (szSymbol[0] == ']') // null terminated string
                                {
                                    n = 0;

                                    if (iType != NOTLOCALIZABLE)
                                    {
                                        if ( lstrcmpiA( szDHW, "CHAR") == 0 )
                                        {
                                            iType += LT_SZ-LT_CHAR;
                                        }
                                        else if ( lstrcmpiA( szDHW,
                                                             "WCHAR") == 0 )
                                        {
                                            iType += LT_WSZ-LT_WCHAR;
                                        }
                                        else
                                        {
#ifdef RLRES32
                                            iType += LT_WSZ-LT_WCHAR;
#else
                                            iType += LT_SZ-LT_CHAR;
#endif
                                        }
                                    }
                                    else
                                    {
                                        if ( lstrcmpiA( szDHW, "CHAR") == 0 )
                                        {
                                            iType = NOTLOCALIZABLESZ;
                                        }
                                        else if ( lstrcmpiA( szDHW,
                                                             "WCHAR") == 0 )
                                        {
                                            iType = NOTLOCALIZABLEWSZ;
                                        }
                                        else
                                        {
#ifdef RLWIN32
                                            iType = NOTLOCALIZABLEWSZ;
#else
                                            iType = NOTLOCALIZABLESZ;
#endif
                                        }
                                    }
                                }
                                else
                                {
                                    i = atoi(szSymbol);

                                    if (i<1)
                                    {
                                        return -1;
                                    }
                                    n *= i;

                                    if (iType != NOTLOCALIZABLE)
                                    {
                                        if ( lstrcmpiA( szDHW, "CHAR") == 0 )
                                        {
                                            iType += LT_STRING-LT_CHAR;
                                        }
                                        else if ( lstrcmpiA( szDHW,
                                                           "WCHAR") == 0 )
                                        {
                                            iType += LT_WSTRING-LT_WCHAR;
                                        }
                                        else
                                        {
#ifdef RLRES32
                                            iType += LT_WSTRING-LT_WCHAR;
#else
                                            iType += LT_STRING-LT_CHAR;
#endif
                                        }
                                    }

                                    if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                                    {
                                        return -2;
                                    }

                                    if (szSymbol[0] != ']')
                                    {
                                        return -1;
                                    }
                                }
                            }
                            else
                            {
                                UngetSymbol(szSymbol);
                            }
                        }

                        if(AddStructureElement(iType, n, ppCRT, fMerge))
                        {
                            return -3;
                        }
                    }
                }
            }
        }

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
        {
            return -2;
        }

        while (szSymbol[0] == '[')
        {// we have an array
            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
            {
                return -2;
            }

            if ((szSymbol[0] < '0' || szSymbol[0] > '9') && szSymbol[0] != ']')
            {
                return -1;
            }

            nElements = atoi(szSymbol);

            if (nElements < 1)
            {
                return -1;
            }

            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
            {
                return -2;
            }

            if (szSymbol[0] != ']')
            {
                return -1;
            }

            pEnd = *ppCRT;

            if (pEnd != pFirst)
            {
                for (i=nElements-1;i--;)
                {
                    pTemp = pFirst;

                    do
                    {
                        pTemp = pTemp->pNext;
                        AddStructureElement(pTemp->iType,
                                            pTemp->uSize,
                                            ppCRT,
                                            0);
                    } while (pTemp != pEnd);
                }
            }

            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
            {
                return -2;
            }
        }
        c += n;

        if (szSymbol[0] == '}')
        {
            return c;
        }

        if (szSymbol[0] != ',')
        {
            return -1;
        }
        fMerge = 1;
    }
}

//+-------------------------------------------------------------------------
//
// Function:    LoadCustResDescriptions, Public
//
// Synopsis:    Loads the Cusutom Resource Descriptions defined in the RDF
//              files, to all the tokenize to parse them.
//
//
// Arguments:   [szFileName]    The RDF file containing the resource
//              descriptions.
//
//
// Effects:     The custom resources are loaded into a global list of
//              resource descriptions, and used by ReadWinRes to tokenize
//              the particular custom resources
//
// Returns:     -1  Error Condition
//               1   Resource descrptions loaded
//
//
//
//
// Modifies:    [pCustResList]  Global list of Custom resource descriptions.
//
// History:
//              16-Oct-92   Created     TerryRu
//
//
// Notes:       ParseResourceDescriptionFile is the function called to
//              actually load the descriptions resources.
//
//--------------------------------------------------------------------------

int LoadCustResDescriptions( CHAR *szRDFs)
{
    FILE  *fRdf = NULL;
    CHAR   szCurRDF[MAXFILENAME] = "";
    int    i1, i2;

    if (szRDFs && *szRDFs)    //... resource description file name given?
    {
        i1 = 0;

        while (szRDFs[i1] == ' ' && szRDFs[i1] != 0)
        {
            ++i1;
        }

        while (szRDFs[i1] != 0)
        {
            i2 = 0;

            while (szRDFs[i1] != ' ' && szRDFs[i1] != 0)
            {
                szCurRDF[i2++] = szRDFs[i1++];
            }
            szCurRDF[i2] = 0;

            while (szRDFs[i1] == ' ' && szRDFs[i1] != 0)
            {
                ++i1;
            }

            if (fRdf = FOPEN( szCurRDF, "rt"))
            {
                ParseResourceDescriptionFile(fRdf, &i2);
                FCLOSE(fRdf);
            }
            else
            {
                return(-1);
            }
        }
    }
    return(1);     //... Success
}



/**
  * Function: ParseResourceDescriptionFile
  * Parses a resource description block creating a structure definining
  * all recognized custom resources.
  *
  * Arguments:
  * ResourceDescriptionFile, handle to an open description file
  *              (or the beginning of a description block)
  * piErrorLine, pointer to an integer that will hold the line number
  *     an error occured at in the event that a parsing error is
  *     encountered.
  *
  * Returns:
  * 0 if successful
  *    !0 if some error was encountered
  * *piErrorLine will hold the line number for the error
  *
  * Error Codes:
  * -1 - Syntax error
  * -2 - Unexpected end of file
  * -3 - out of memory
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  *
  **/

int  ParseResourceDescriptionFile(

FILE *pfResourceDescriptionFile,
int  *piErrorLine)
{
    CUSTRESNODE far * lpCustResNode = NULL;
    CUSTRESTEMPLATE far * pCustResTemplate;
    static CHAR szSymbol[SYMBOLSIZE];
/*************************************************************************
    TCHAR *szResourceType;
*************************************************************************/
    int iResourceType;
    int r;
    BOOL fBeginList = TRUE;

    // position lpCustResNode at end of the custom reosource list.
    if ( lpCustResNode == NULL )
    {
        pCustResList = lpCustResNode =
            (CUSTRESNODE far *)FALLOC( sizeof( CUSTRESNODE));
    }
    else
    {
        fBeginList    = FALSE;
        lpCustResNode = pCustResList;

        while ( lpCustResNode->pNext )
        {
            lpCustResNode = lpCustResNode->pNext;
        }
    }
    piLineNumber  = piErrorLine;
    *piLineNumber = 1;


    if ( GetNextSymbol( szSymbol, 
                        sizeof( szSymbol), 
                        pfResourceDescriptionFile) )
    {
        return 0; // file is empty
    }

    while ( lstrcmpiA( szSymbol, "END") )
    {
        if ( szSymbol[0] != '<' )
        {
            return -1; // must begin with a resource number
        }

        if ( fBeginList == FALSE )
        {
            lpCustResNode->pNext =
                (CUSTRESNODE far *)FALLOC( sizeof( CUSTRESNODE));
            lpCustResNode  = lpCustResNode->pNext;
        }
        fBeginList = FALSE;

        // intialize nodes fields to Zero defaults.

        memset( lpCustResNode, 0, sizeof( CUSTRESNODE));

                                //... Next symbol will be the resource type

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), pfResourceDescriptionFile) )
        {
            return -2; // need a number
        }
                                //... Is type a string or a number?
        if ( szSymbol[0] != '"' )
        {                       //... number
            iResourceType = GetResourceType( szSymbol);

            if ( iResourceType < 0 )
            {
                return -1;
            }
            lpCustResNode->wTypeID   = (WORD)iResourceType;
            lpCustResNode->bTypeFlag = TRUE;
        }
        else                    //... string
        {
            UINT uChars = lstrlenA( szSymbol+1) + 1;

            lpCustResNode->pszType = (TCHAR *)FALLOC( MEMSIZE( uChars));

            if ( lpCustResNode->pszType == NULL )
            {
                return -3;
            }
            _MBSTOWCS( lpCustResNode->pszType, szSymbol+1, uChars, (UINT)-1);
            lpCustResNode->bTypeFlag = FALSE;
        }

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), pfResourceDescriptionFile) )
        {
            return -2;
        }
/*************************************************************************
                                //... Is a name provided?

        if (szSymbol[0] != '>' && szSymbol[0] != ',')
        {
            return -1; // must have closing symbol for resource id #
        }

        if (szSymbol[0] == ',')
        {                       //... Yes, name is provided
            if (iResourceType >= 0)
            {
                lpCustResNode->wNameID = (WORD)iResourceType;
                lpCustResNode->bNameFlag = TRUE;
            }
            else
            {
                lpCustResNode->wTypeID = 0;
                lpCustResNode->wNameID = IDFLAG;
                lpCustResNode->pszType = szResourceType;
                lpCustResNode->bTypeFlag = 0;
            }
        }
        else
        {
            if (iResourceType >= 0)
            {
                lpCustResNode->wNameID = iResourceType;
            }
            else
            {
                lpCustResNode->wNameID = 0;
                lpCustResNode->pszName = szResourceType;
                lpCustResNode->bNameFlag = 0xff;
            }

            if (GetNextSymbol(szSymbol, sizeof( szSymbol), pfResourceDescriptionFile))
            {
                return -2;
            }

            if (szSymbol[0] != '"')
            {
                r = GetResourceType(szSymbol);
                lpCustResNode->wTypeID = (WORD)r;
            }
            else
            {
                lpCustResNode->wTypeID = 0;
                lpCustResNode->bTypeFlag = 0;
        szResourceType = (TCHAR *)FALLOC(
                                       MEMSIZE( (strlen( szSymbol + 1) + 1)));
        strcpy((PCHAR)szResourceType, szSymbol+1);
                lpCustResNode->pszType = szResourceType;
            }
            if (GetNextSymbol(szSymbol, sizeof( szSymbol), pfResourceDescriptionFile))
            {
                return -2;
            }
            if (szSymbol[0] != '>')
            {
                return -1;
            }
        }
*************************************************************************/

        // Start the template by creating a single empty node
        // This is necessary for handling recursive arrays.
        // There might be a way around it but this works and it is easy.
        lpCustResNode->pTemplate=
                       (FPCUSTRESTEMPLATE)FALLOC( sizeof( CUSTRESTEMPLATE));

        if (!lpCustResNode->pTemplate)
        {
            return -3;
        }

        pCustResTemplate = (lpCustResNode->pTemplate);
        pCustResTemplate->iType = NOTLOCALIZABLE;
        pCustResTemplate->uSize = 0;
        pCustResTemplate->pNext = NULL;

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), pfResourceDescriptionFile) )
        {
            return -2;
        }

        if (szSymbol[0] != '{')
        {
            return -1; // must have at least one block
        }

        r = ParseBlock( pfResourceDescriptionFile,
                       (FPCUSTRESTEMPLATE *)&pCustResTemplate);
        if (r < 0)
        {
            return r;
        }

        // Now remove that initial empty node (not necessary but cleaner)
        pCustResTemplate = lpCustResNode->pTemplate;
        lpCustResNode->pTemplate = pCustResTemplate->pNext;
        RLFREE( pCustResTemplate);

        // the last thing the ParseBlock routine should have read in was a
        // closing brace to close the block.  The next thing we read should
        // either be "end", the end of file, or a new resource definition.

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), pfResourceDescriptionFile) )
        {
            return 0; // reached end of file
        }
    }
    return 0;
}

/**
  * Function: GetCustomResource
  * Reads a custom resource from the resource file and returns a pointer
  * to the resource data.
  *
  * Arguments:
  * inResFile, handle to an open resource file
  * lSize, size in bytes of the resource
  * ppCustomResource, address of a pointer to an empty custom resource
  *           structure
  * ResHeader, resource header for this resource
  *
  * Returns:
  * if resource has a definition:
  *     returns 0 and
  *     inResFile containing a linked list of the localizable resource data
  * else
  *     returns 1
  *
  * Error Codes:
  * 0 - no error -- resource was retrieved
  * 1 - resource is not an understood custom resource (use another method
  *     or ignore the resource)
  * 2 - some error occured parsing the resource
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  *
  **/

int  GetCustomResource(

FILE              *inResFile,
DWORD             *plSize,
FPCUSTOM_RESOURCE *ppCustomResource,
RESHEADER          ResHeader)
{
    CUSTOM_RESOURCE far *lpCustomResource;
    CUSTRESNODE     far *pCRN;
    CUSTRESTEMPLATE far *pCRT;
    void            far * pData;
    BOOL            fBeginList = TRUE;


    if ( ! (pCRN = MatchResource( ResHeader)) )
    {
        return 1; // resource doesn't have a match
    }

    *ppCustomResource = lpCustomResource =
                     (CUSTOM_RESOURCE far *)FALLOC( sizeof( CUSTOM_RESOURCE));
    pCRT = pCRN->pTemplate;

    while ( *plSize )
    {
        // allocate new custome resrouce structure

        if ( fBeginList == FALSE )
        {
            lpCustomResource->pNext =
                     (CUSTOM_RESOURCE far *)FALLOC( sizeof( CUSTOM_RESOURCE));
            lpCustomResource = lpCustomResource->pNext;
        }

        if ( ! lpCustomResource )
        {
            return 2; // no memory
        }
        pData = GetResData( pCRT->iType, pCRT->uSize, inResFile, plSize);

        if ( ! pData )
        {
            return 2; //GetResData crapped out
        }
        lpCustomResource->pData = pData;
        lpCustomResource->pNext = NULL;
        fBeginList = FALSE;

        pCRT = pCRT->pNext;

        if (!pCRT)
        {
            pCRT = pCRN->pTemplate; //begin next structure
        }
    }
    return 0;
}

/**
  * Function: TokCustomResource
  * Writes custom resource information to the token file.
  *
  * Arguments:
  * TokFile, handle to the token file
  * ResHeader, resource header for this resource
  * ppCustomResource, address of a pointer to a filled out
  *           custom resource structure
  *
  * Returns:
  * Data written to TokFile
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  *
  * 01/93 - Add support for var length Token texts      MHotchin
  *
  **/

void TokCustomResource(

FILE              *TokFile,
RESHEADER          ResHeader,
FPCUSTOM_RESOURCE *ppCustomResource)
{
    CUSTRESNODE     far *pCRN;
    CUSTRESTEMPLATE far *pCRT;
    CUSTOM_RESOURCE far *lpCustomResource;
    TCHAR       sz[ MAXTEXTLEN];
    TOKEN               Token;
    WORD                wID = 0;
    int                 l;


    lpCustomResource = *ppCustomResource;

    if (!(pCRN = MatchResource(ResHeader)))
    {
        QuitT( IDS_ENGERR_09, (LPTSTR)IDS_NOCUSTRES, NULL);
    }

    pCRT = pCRN->pTemplate;

    while ( lpCustomResource )
    {
        if ( pCRT->iType != NOTLOCALIZABLE
          && pCRT->iType != NOTLOCALIZABLESZ
          && pCRT->iType != NOTLOCALIZABLEWSZ )
        {
            if ( PutTextData( lpCustomResource->pData,
                              pCRT->iType,
                              pCRT->uSize,
                              sz,
                              sizeof( sz)) )
            {
                QuitT( IDS_ENGERR_09, (LPTSTR)IDS_CUSTRES, NULL);
            }
            /* UNCOMMENT THIS WHEN STRING TYPES ARE SUPPORTED IN TOKENS
             **********
             Token.szType[0] = '\0';
             if (!ResHeader.bTypeFlag)
             {
             Token.wType = IDFLAG;
             _tcscpy( Token.szType, ResHeader.pszType);
             }
             else
             **********
             */
            Token.wType = ResHeader.wTypeID;
            Token.wName = ResHeader.wNameID;

            if ( ResHeader.bNameFlag == IDFLAG )
            {
                lstrcpy( Token.szName, ResHeader.pszName);
            }
            else
            {
                Token.szName[0] = '\0';
            }
            Token.wID = wID++;
            Token.wReserved = (gbMaster ? ST_NEW : ST_TRANSLATED);
            Token.wFlag = 0;

            if ( (pCRT->iType == LT_UNSIGNED + LT_STRING)
              || (pCRT->iType == LT_STRING)
              || (pCRT->iType == LT_WSTRING) )
            {
                l = pCRT->uSize;
                while( l > 1 && ! sz[l-1])
                {
                    --l; // skip any trailing nulls
                }
                Token.szText = BinToText( sz, l);
            }
            else
            {
                Token.szText = BinToText( sz, lstrlen( sz));
            }
            PutToken( TokFile, &Token);
            RLFREE( Token.szText);                                                 
        }
        pCRT = pCRT->pNext;

        if ( ! pCRT )
        {
            pCRT = pCRN->pTemplate; //begin next structure
        }
        lpCustomResource = lpCustomResource->pNext;
    }
}

/**
  * Function: PutCustomResource
  * Writes custom resource information to the output resource
  * file.  If the information is localizable it is retrieved from the
  * indicated token file.
  *
  * Arguments:
  * OutResFile, handle to the target resource file
  * TokFile, handle to the token file
  * ResHeader, resource header for this resource
  * ppCustomResource, address of a pointer to a filled out
  *           custom resource structure
  *
  * Returns:
  * CustomResource written to OutResFile
  *
  * Error Codes:
  * none
  *
  * History:
  * ??/??       Created by ???
  *
  * 01/93       Added support for var length token texts.       MHotchin
  *
  **/

void PutCustomResource(

FILE              *OutResFile,
FILE              *TokFile,
RESHEADER          ResHeader,
FPCUSTOM_RESOURCE *ppCustomResource)
{
    CUSTRESNODE     far *pCRN = NULL;
    CUSTRESTEMPLATE far *pCRT = NULL;
    CUSTOM_RESOURCE far *lpCustomResource = NULL;
    TCHAR       sz[ MAXTEXTLEN] = TEXT("");
    void            far *pData = NULL;
    TOKEN           Token;
    DWORD           lSize = 0;
    fpos_t          ResSizePos;
    WORD            wID=0;
    unsigned n;


    lpCustomResource = *ppCustomResource;

    if ( ! (pCRN = MatchResource( ResHeader)) )
    {
        QuitT( IDS_ENGERR_09, (LPTSTR)IDS_NOCUSTRES, NULL);
    }

    if ( PutResHeader( OutResFile, ResHeader, &ResSizePos, &lSize) )
    {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_CUSTRES, NULL);
    }

    lSize = 0;

    pCRT = pCRN->pTemplate;

    while ( lpCustomResource )
    {
        BOOL fAlloced = FALSE;

        if ( pCRT->iType != NOTLOCALIZABLE
          && pCRT->iType != NOTLOCALIZABLESZ
          && pCRT->iType != NOTLOCALIZABLEWSZ )
        {
            /* UNCOMMENT THIS WHEN STRING TYPES ARE SUPPORTED IN TOKENS
             *
             Token.szwType[0] = '\0';
             if (!ResHeader.bTypeFlag)
             {
             Token.wType = IDFLAG;
             _tcscpy(Token.szwType, ResHeader.pszType);
             }
             else
             *
             */
            Token.wType = ResHeader.wTypeID;
            Token.wName = ResHeader.wNameID;

            if ( ResHeader.bNameFlag == IDFLAG )
            {
                lstrcpy( Token.szName, ResHeader.pszName);
            }
            else
            {
                Token.szName[0] = '\0';
            }
            Token.wID = wID++;
            Token.wFlag = 0;
            Token.wReserved =(gbMaster ? ST_NEW : ST_TRANSLATED);
            Token.szText = NULL;                                                

            if ( ! FindToken( TokFile, &Token, ST_TRANSLATED) )                      
            {
                QuitT( IDS_ENGERR_06, (LPTSTR)IDS_NOCUSTRES, NULL);
            }
            n = TextToBin( sz, Token.szText, sizeof( sz));
            RLFREE( Token.szText);                                                 

            while ( n < pCRT->uSize )
            {
                sz[n++]='\0';   // padd additional space with nulls
            }
            pData = GetTextData( pCRT->iType, pCRT->uSize, sz);

            if ( ! pData)
            {
                QuitT( IDS_ENGERR_09, (LPTSTR)IDS_CUSTRES, NULL);
            }
            fAlloced = TRUE;
        }
        else
        {
            pData = lpCustomResource->pData;
            fAlloced = FALSE;
        }

        lSize += PutResData( pData, pCRT->iType, pCRT->uSize, OutResFile);

        if ( fAlloced )
        {
            RLFREE( pData);
        }
        pCRT = pCRT->pNext;

        if ( ! pCRT )
        {
            pCRT = pCRN->pTemplate; //begin next structure
        }
        lpCustomResource = lpCustomResource->pNext;
    }

    if( ! UpdateResSize( OutResFile, &ResSizePos, lSize) )
    {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_CUSTRES, NULL);
    }
}

/**
  * Function: ClearCustomResource
  * Frees memory allocated to a custom resource list.
  *
  * Arguments:
  * ppCustomResource, address of a pointer to a filled out
  *           custom resource structure
  *
  * Returns:
  * Memory allocatd to pCustomResource is freed.
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

void ClearCustomResource( FPCUSTOM_RESOURCE *ppCustomResource)
{
    CUSTOM_RESOURCE far *pCR;
    CUSTOM_RESOURCE far *lpCustomResource;

    lpCustomResource = *ppCustomResource;

    while ( lpCustomResource )
    {
        pCR = lpCustomResource;

        RLFREE( pCR->pData);
        
        lpCustomResource = pCR->pNext;
        RLFREE( pCR);
    }
}

/**
  * Function:
  * Tries to find a custom resource that matches the resource specified
  * in the resource header.
  *
  * Arguments:
  * Resheader, resource header.
  *
  * Returns:
  * pointer to the resource template (or null)
  *
  * Error Codes:
  * null -- resource not found
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static CUSTRESNODE far * MatchResource( RESHEADER Resheader)
{
    CUSTRESNODE far *pCR = pCustResList;


    while ( pCR )
    {
        if ( (0==pCR->bTypeFlag) == (0==Resheader.bTypeFlag) )
        {
            if ( ((!pCR->bTypeFlag) && ! _tcscmp( pCR->pszType,
                                                  Resheader.pszType)) 
              || ((pCR->bTypeFlag) && pCR->wTypeID == Resheader.wTypeID))
            { // TYPES MATCH
/*************************************************************************

                if (pCR->wNameID == IDFLAG)
                {
                    pCRTypeMatch = pCR;
                }
                else
                {
                    if ((0==pCR->bNameFlag) == (0==Resheader.bNameFlag))
                    {
                        if (((!pCR->bNameFlag) 
                          && ! _tcscmp(pCR->pszName, Resheader.pszName)) ||
                            ((pCR->bNameFlag) &&
                             pCR->wNameID == Resheader.wNameID))
                        { // NAMES MATCH
*************************************************************************/
                            return( pCR); // an exact match
/*************************************************************************
                        }
                    }
                }
*************************************************************************/
            }
        }
        pCR = pCR->pNext;
    }
    return( NULL); // either only the type matched or nothing matched
}

/**
  * Function: GetResData
  * Reads data of the specified type and size from a resource file.
  *
  * Arguments:
  * wType, type of this resource (from resource template)
  * uSize, size in bytes of resource (ignored for null terminated strings)
  * f, resource file
  * lSize, pointer to the number of bytes left in the resource
  *
  * Returns:
  * pointer to the data, lSize is updated
  *
  * Error Codes:
  * null pointer on error
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static void far * GetResData(

enum LOCALIZABLE_TYPES wType,
unsigned uSize,
FILE    *f,
DWORD   *lSize)
{
    BYTE *pData = NULL;
    int   i     = 0;
    

    if ( wType % LT_UNSIGNED == LT_SZ
      || wType == NOTLOCALIZABLESZ
      || wType % LT_UNSIGNED == LT_WSZ
      || wType == NOTLOCALIZABLEWSZ )
    { // read in the null terminated string
        TCHAR ch = IDFLAG;


        pData = FALLOC( MEMSIZE(*lSize) );

        while ( *lSize && ch != TEXT('\0') )
        {
#ifdef RLWIN32

            if ( wType % LT_UNSIGNED == LT_WSZ
              || wType == NOTLOCALIZABLEWSZ )
            {
                ((TCHAR *)pData)[i] = ch = GetWord( f, lSize);
            }
            else
            {
                char  chTmp[2];


                chTmp[0] = GetByte( f, lSize);

                if ( IsDBCSLeadByte( chTmp[0]) )
                {
                    chTmp[1] = GetByte( f, lSize);
                    _MBSTOWCS( &((TCHAR *)pData)[i], chTmp, 1, 2);
                }
                else
                {
                    _MBSTOWCS( &((TCHAR *)pData)[i], chTmp, 1, 1);
                }
                ch = ((TCHAR *)pData)[i];
            }
#else  //RLWIN32

            *(pData+i) = ch = GetByte( f, lSize);

#endif //RLWIN32

            i++;

        } // END while( *lSize ...
    }
    else
    {
        pData = FALLOC( uSize);

        if ( ! pData )
        {
            QuitA( IDS_ENGERR_11, NULL, NULL);
        }

        while (uSize-- && *lSize)
        {
            *(pData+i) = GetByte(f, lSize);
            i++;
        }
    }
    return( pData);
}

/**
  * Function: PutResData
  * Writes data of the specified type to a resource file.
  *
  * Arguments:
  * pData, pointer to data
  * wType, type of this resource (from resource template)
  * uSize, size in bytes of resource (ignored for null terminated strings)
  * f, resource file
  *
  * Returns:
  * Number of bytes written.
  *
  * Error Codes:
  * -1 - error
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static int PutResData(

void far *pData,
enum LOCALIZABLE_TYPES wType,
unsigned  uSize,
FILE     *f)
{
    DWORD dw = 0;

    if ( wType % LT_UNSIGNED == LT_SZ
      || wType == NOTLOCALIZABLESZ
      || wType % LT_UNSIGNED == LT_WSZ
      || wType == NOTLOCALIZABLEWSZ )
    {
        // write the null terminated string

#ifdef RLWIN32

        TCHAR *pChar = (TCHAR *)pData;

        if ( wType % LT_UNSIGNED == LT_WSZ
          || wType == NOTLOCALIZABLEWSZ )
        {
            while( *pChar )
            {
                PutWord( f, *pChar, &dw);
                pChar++;
            }
            PutWord( f, 0, &dw);
        }
        else
        {
            _WCSTOMBS( szDHW, pChar, DHWSIZE, lstrlen( pChar) + 1);

            while( szDHW[ dw] )
            {
                PutByte( f, szDHW[ dw], &dw);
            }
            PutByte( f, 0, &dw);
        }

#else  //RLWIN32

        while( *((BYTE far *)pData+i) )
        {
            PutByte( f, *((BYTE far *)pData+dw), &dw);
        }
        PutByte( f, 0, &dw);

#endif //RLWIN32

    }
    else
    {
        while( dw < uSize)
        {
            PutByte( f, *((BYTE far *)pData+dw), &dw);
        }
    }
    return( (int)dw);
}

/**
  * Function: GetTextData
  * Reads data of the specified type and size from a string.
  *
  * Arguments:
  * wType, type of this resource (from resource template)
  * uSize, size in bytes of resource (ignored for null terminated strings)
  * sz,    source string (always in Unicode if in NT version of tool)
  *
  * Returns:
  * pointer to the data
  *
  * Error Codes:
  * null pointer on error
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static void far * GetTextData(

enum LOCALIZABLE_TYPES wType,
unsigned uSize,
TCHAR    sz[])
{
    PBYTE pData = NULL;
    int   i = 0;


    if ( wType % LT_UNSIGNED == LT_WSZ
      || wType % LT_UNSIGNED == LT_SZ )
    {
        pData = FALLOC( MEMSIZE( MAXTEXTLEN));
    }
    else if ( wType % LT_UNSIGNED == LT_WSTRING
           || wType % LT_UNSIGNED == LT_STRING )

    {
        pData = FALLOC( MEMSIZE( uSize));
    }
    else
    {
        pData = FALLOC( uSize);
    }

    switch (wType)
    {
    case LT_CHAR:
    case LT_UNSIGNED+LT_CHAR:

        *pData = (BYTE) sz[0];
        break;

    case LT_WCHAR:
    case LT_UNSIGNED+LT_WCHAR:

        *((TCHAR *)pData) = sz[0];
        break;

    case LT_INTEGER:

        if ( uSize == 2 )
        {
            sscanf( (PCHAR)sz, "%Fhi", pData);
        }
        else
        {
            sscanf( (PCHAR)sz, "%Fli", pData);
        }
        break;

    case LT_UNSIGNED+LT_INTEGER:

        if ( uSize == 2 )
        {
            sscanf( (PCHAR)sz, "%Fhu", pData);
        }
        else
        {
            sscanf( (PCHAR)sz, "%Flu", pData);
        }
        break;

    case LT_FLOAT:
    case LT_UNSIGNED+LT_FLOAT:

        if ( uSize == 4 )
        {
            sscanf( (PCHAR)sz, "%Ff", pData);
        }
        else
        {
            sscanf( (PCHAR)sz, "%Flf", pData);
        }
        break;

    case LT_STRING:
    case LT_UNSIGNED+LT_STRING:
    case LT_WSTRING:
    case LT_UNSIGNED+LT_WSTRING:

        for ( i = uSize; i--; )
        {
            *((TCHAR far *)pData + i) = sz[i];
        }
        break;

    case LT_SZ:
    case LT_UNSIGNED+LT_SZ:
    case LT_WSZ:
    case LT_UNSIGNED+LT_WSZ:

#ifdef RLWIN32
        CopyMemory( pData, sz, MEMSIZE( min( lstrlen( sz) + 1, MAXTEXTLEN)));      
#else
        FSTRNCPY( (CHAR far *)pData, sz, MAXTEXTLEN);
#endif
        break;

    default:

        RLFREE( pData);
    }
    return( pData);
}

/**
  * Function: PutTextData
  * Writes data of the specified type to a string.
  *
  * Arguments:
  * pData, pointer to data
  * wType, type of this resource (from resource template)
  * uSize, size in bytes of resource (ignored for null terminated strings)
  * sz,    destination string
  * l,     length of destination string (in bytes)
  *
  * Returns:
  * 0 - no errors
  *
  * Error Codes:
  * 1 - error
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static int PutTextData(

void far *pData,
enum LOCALIZABLE_TYPES wType,
unsigned uSize,
TCHAR    sz[],
int      l)
{
    switch (wType)
    {
    case LT_CHAR:
    case LT_UNSIGNED+LT_CHAR:
    case LT_WCHAR:
    case LT_UNSIGNED+LT_WCHAR:

        CopyMemory( sz, pData, min( uSize, (UINT)l));
        break;

    case LT_INTEGER:

        if ( uSize == 2 )
        {
            wsprintf( sz, TEXT("%Fhi"), pData);
        }
        else
        {
            wsprintf( sz, TEXT("%Fli"), pData);
        }
        break;

    case LT_UNSIGNED+LT_INTEGER:

        if ( uSize == 2 )
        {
            wsprintf( sz, TEXT("%Fhu"), pData);
        }
        else
        {
            wsprintf( sz, TEXT("%Flu"), pData);
        }
        break;

    case LT_FLOAT:
    case LT_UNSIGNED+LT_FLOAT:

        if ( uSize == 4 )
        {
            wsprintf( sz, TEXT("%Ff"), pData);
        }
        else
        {
            wsprintf( sz, TEXT("%Flf"), pData);
        }
        break;

    case LT_STRING:
    case LT_UNSIGNED+LT_STRING:
    case LT_WSTRING:
    case LT_UNSIGNED+LT_WSTRING:

        CopyMemory( sz, pData, uSize);
        break;

    case LT_SZ:
    case LT_UNSIGNED+LT_SZ:

        CopyMemory( sz, pData, MEMSIZE(min( lstrlen( pData) + 1, l)));
        ((LPSTR)sz)[ l - 1] = '\0';
        break;

    case LT_WSZ:
    case LT_UNSIGNED+LT_WSZ:

        CopyMemory( sz, pData, min( MEMSIZE( lstrlen( pData) + 1), WCHARSIN( l)));
        sz[ WCHARSIN( l) - 1] = TEXT('\0');
        break;

//#ifdef RLWIN32
//    CopyMemory( sz, pData, l > 0 ? l * sizeof( TCHAR) : 0);
//#else
//    FSTRNCPY( (CHAR far *) sz, (CHAR far *)pData, l);
//#endif
        break;

    default:

        return( 1);
    }
    return( 0);
}

/**
  * Function: AddTo
  * Adds a character to a string at position c.
  * c is then incremented only if it is still less than the maximum
  * length of the target string.  This is to prevent runover.
  *
  * Arguments:
  * sz, target string
  * c,  pointer to current position value
  * lTarget, maximum length of the target string
  * ch, character to be added to the string
  */

void AddTo( CHAR *sz, int *c, int lTarget, CHAR ch)
{
    sz[*c] = ch;

    if (*c < lTarget)
    {
        (*c)++;
    }
}


#ifdef RLWIN32


void AddToW( TCHAR *sz, int *c, int lTarget, TCHAR ch)
{
    sz[*c] = ch;

    if (*c < lTarget)
    {
        (*c)++;
    }
}

/**
  * Function: BinToTextW
  * Converts a binary string to it's c representation
  * (complete with escape sequences).  If the target string is NULL,
  * space will be allocated for it.
  *
  * Arguments:
  * rgc, source string
  * lSource, length of source string
  *
  * Returns:
  * nothing
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  * 01/21/93  MHotchin - Made changes to allow this function to allocate
  *             the memory for the destination string.  If the target string
  *             is NULL, then space will be allocated for it.  The target
  *             string is returned to the caller.
  **/


UINT _MBSTOWCS( WCHAR wszOut[], CHAR szIn[], UINT cOut, UINT cIn)
{
    UINT n;


    n = MultiByteToWideChar( gProj.uCodePage,
                             MB_PRECOMPOSED,
                             szIn,
                             cIn,
                             wszOut,
                             cOut);

    return( n > 0 ? n - 1 : 0);
}

UINT _WCSTOMBS( CHAR szOut[], WCHAR wszIn[], UINT cOut, UINT cIn)
{
    UINT n;


    n = WideCharToMultiByte( gProj.uCodePage,
                             0,
                             wszIn,
                             cIn,
                             szOut,
                             cOut,
                             NULL,
                             NULL);

    return( (cIn > 0 ) ? cIn - 1 : 0);
}


WCHAR * BinToTextW(

TCHAR *szInBuf,    //... Input, binary, string
int    lSource)    //... Length of szInBuf
{
    int i;
    int cOutBufLen = 0;
    int lTarget    = 0;         //... Max length of szOutBuf
    TCHAR *szOutBuf  = NULL;    //... Output string with escape sequences


    // If the target is NULL, allocate some memory.  We set aside
    // 5% more than the source length.  MHotchin
    // chngd to 5% or 5 chars if 10% is less than 50    davewi

    lTarget = (lSource == 0) ? 0 : lSource + 1;
        
    szOutBuf = (TCHAR *)FALLOC( MEMSIZE( lTarget));

    for ( i = 0; i < lSource; i++ )
    {
        switch( szInBuf[i] )
        {
            case TEXT('\a'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('a'));
                break;

            case TEXT('\b'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('b'));
                break;

            case TEXT('\f'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('f'));
                break;

            case TEXT('\n'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('n'));
                break;

            case TEXT('\r'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('r'));
                break;

            case TEXT('\t'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('t'));
                break;

            case TEXT('\v'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('v'));
                break;

            case TEXT('\\'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                break;

            default:
            {
                TCHAR wTmp = szInBuf[i];

                if ( wTmp == 0 )
                {
                    szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                    AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('0'));
                }
                else if ( (wTmp >= 0 && wTmp < 32)
                  || wTmp == 0x7f
                  || wTmp == 0xa9
                  || wTmp == 0xae )
                {
                    CHAR szt[5];

                    szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 4, szOutBuf);
                    sprintf( szt, "%#04hx", wTmp);
                    AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, (TCHAR)(szt[0]));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, (TCHAR)(szt[1]));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, (TCHAR)(szt[2]));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, (TCHAR)(szt[3]));
                }
                else
                {
                    szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 1, szOutBuf);
                    AddToW( szOutBuf, &cOutBufLen, lTarget, wTmp);
                }
                break;
            }
        }
    }
    szOutBuf[ cOutBufLen] = TEXT('\0');

    return( szOutBuf);
}


#endif //RLWIN32



/** Function: atoihex
  * Converts a string containing hex digits to an integer.  String is
  * assumed to contain nothing but legal hex digits.  No error checking
  * is performed.
  *
  * Arguments:
  * sz, null terminated string containing hex digits
  *
  * Returns:
  * value of hex digits in sz
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  */

int atoihex( CHAR sz[])
{
    int r = 0;
    int i = 0;
    CHAR ch;

    while (sz[i])
    {
        r *= 16;
        ch = (CHAR)toupper(sz[i++]);

        if (ch<='9' && ch>='0')
        {
            r += ch - '0';
        }
        else
        {
            if (ch <= 'F' && ch >= 'A')
            {
                r += ch - 'A' + 10;
            }
        }
    }
    return r;
}


#ifdef RLRES32

/**
  * Function: TextToBinW
  * Converts a string with c escape sequences to a true binary string.
  *
  * Arguments:
  * rgc, target string
  * sz, source string
  * l, maximum length of target string
  *
  * Returns:
  * length of target string
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  * 9/92 -- changed to UNICODE-only version -- davewi
  * 01/21/93 -- Changed to allow arb length strings     MHotchin.
  *
  **/

int TextToBinW(

WCHAR szOutBuf[],   //... Output, binary, string
WCHAR szInBuf[],    //... Input string with escape sequences
int   lTarget)      //... Max length of szOutBuf
{
    int  i = 0;
    int  c = 0;


    while ( szInBuf[ c] )
    {
        if ( szInBuf[ c] == TEXT('\\') )
        {           // escape sequence!
            c++;

            switch ( szInBuf[ c++] )
            {
                case TEXT('a'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\a'));
                    break;

                case TEXT('b'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\b'));
                    break;

                case TEXT('f'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\f'));
                    break;

                case TEXT('n'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\n'));
                    break;

                case TEXT('r'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\r'));
                    break;

                case TEXT('t'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\t'));
                    break;

                case TEXT('v'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\v'));
                    break;

                case TEXT('\''):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\''));
                    break;

                case TEXT('\"'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\"'));
                    break;

                case TEXT('\\'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\\'));
                    break;

                case TEXT('0'):
                case TEXT('1'):
                case TEXT('2'):
                {
                    CHAR szt[4];


                    szt[0] = szt[1] = szt[2] = szt[3] = '\0';

                    if ( szInBuf[c-1] == TEXT('0')
                      && (szInBuf[c]  < TEXT('0') || szInBuf[c] > TEXT('9'))
                      && szInBuf[c] != TEXT('x') && szInBuf[c] != TEXT('X') )
                    {
                                //  Must be '\0'
                        AddToW( szOutBuf, &i, lTarget, (TCHAR)0);
                    }
                    else if ( szInBuf[c] >= TEXT('0') && szInBuf[c] <= TEXT('9') )
                    {
                        szt[0] = (CHAR)(szInBuf[c-1]);
                        szt[1] = (CHAR)(szInBuf[c++]);

                        if ( szInBuf[c] >= TEXT('0') && szInBuf[c] <= TEXT('9'))
                        {
                            szt[2] = (CHAR)(szInBuf[c++]);
                        }
                        AddToW( szOutBuf, &i, lTarget, (TCHAR)atoi( szt));
                    }
                    else if ( szInBuf[c] == TEXT('X')
                           || szInBuf[c] == TEXT('x') )
                    {
                        c++;
                        szt[0] = (CHAR)(szInBuf[c++]);
                        szt[1] = (CHAR)(szInBuf[c++]);
                        AddToW( szOutBuf, &i, lTarget, (TCHAR)atoihex( szt));
                    }
                    else
                    {
                        QuitT( IDS_INVESCSEQ, &szInBuf[c-2], NULL);
                    }
                    break;
                }
                case TEXT('x'):
                case TEXT('X'):
                {
                    CHAR szt[4];


                    szt[0] = szt[1] = szt[2] = szt[3] = '\0';

                    if ( (szInBuf[c] <= TEXT('9') && szInBuf[c] >= TEXT('0'))
                      || (szInBuf[c] >= TEXT('A') && szInBuf[c] <= TEXT('F'))
                      || (szInBuf[c] >= TEXT('a') && szInBuf[c] <= TEXT('f')) )
                    {
                        szt[0] = (CHAR)(szInBuf[c++]);

                        if (  (szInBuf[c] <= TEXT('9')
                            && szInBuf[c] >= TEXT('0'))
                          ||  (szInBuf[c] >= TEXT('A')
                            && szInBuf[c] <= TEXT('F'))
                          ||  (szInBuf[c] >= TEXT('a')
                            && szInBuf[c] <= TEXT('f')) )
                        {
                            szt[1] = (CHAR)(szInBuf[c++]);

                            if (  (szInBuf[c] <= TEXT('9')
                                && szInBuf[c] >= TEXT('0'))
                              ||  (szInBuf[c] >= TEXT('A')
                                && szInBuf[c] <= TEXT('F'))
                              ||  (szInBuf[c] >= TEXT('a')
                                && szInBuf[c] <= TEXT('f')) )
                            {
                                szt[2] = (CHAR)(szInBuf[c++]);
                            }
                        }
                    }
                    AddToW( szOutBuf, &i, lTarget, (TCHAR)atoihex( szt));
                    break;
                }
                default:

                    AddToW( szOutBuf, &i, lTarget, szInBuf[c-1]);
                    break;
            }                   //... END switch
        }
        else
        {
            AddToW( szOutBuf, &i, lTarget, szInBuf[c++]);
        }
    }                           //... END while
    szOutBuf[i++] = TEXT('\0');

    return(i);
}


#endif

void ClearResourceDescriptions( void)
{
    CUSTRESNODE far *pCR          = pCustResList;
    CUSTRESNODE far *pCRNext      = NULL;
    CUSTRESTEMPLATE far *pCRT     = NULL;
    CUSTRESTEMPLATE far *pCRTNext = NULL;
    CUSTRESTEMPLATE far *pCRTTmp  = NULL;

    while ( pCR )
    {
        pCRNext = pCR->pNext;

        if ( pCR->pszType )
        {
            RLFREE(pCR->pszType);
        }
        if ( pCR->pszName )
        {
            RLFREE(pCR->pszName);
        }
        pCRT = pCR->pTemplate;
        while ( pCRT )
        {
            pCRTTmp = pCRT->pNext;
            RLFREE( pCRT);
            pCRT=pCRTTmp;
        }
        RLFREE( pCR);
        pCR = pCRNext;
    }
    pCustResList = NULL;
}

// Check to see if we need more room.  If we have less that 5 bytes
// left, grow the target by another 5%.         MHotchin
// chngd to 10% or 10 chars if 10% is less than 10 davewi

static CHAR *CheckBufSize(

int  *lTarget,      //... Length of output buffer
int   cOutBufLen,   //... Bytes already used in output buffer
int   cDelta,       //... # characters we want to add to output buffer
CHAR *szOutBuf)     //... ptr to output buffer
{
                                //... add 1 to allow for trailing nul

    if ( *lTarget - cOutBufLen < cDelta + 1 )
    {
        *lTarget += cDelta;

        szOutBuf = (CHAR *)FREALLOC( (BYTE *)szOutBuf, *lTarget);
    }
    return( szOutBuf);
}

#ifdef RLWIN32

static TCHAR *CheckBufSizeW(

int   *lTarget,     //... Length of output buffer
int    cOutBufLen,  //... Bytes already used in output buffer
int    cDelta,      //... # characters we want to add to output buffer
TCHAR *szOutBuf)    //... ptr to output buffer
{
                                //... add 1 to allow for trailing nul

    if ( *lTarget - cOutBufLen < (int)(MEMSIZE( cDelta + 1)) )
    {
        *lTarget += MEMSIZE( cDelta);

        szOutBuf = (TCHAR *)FREALLOC( (BYTE *)szOutBuf, MEMSIZE(*lTarget));
    }
    return( szOutBuf);
}

#endif //RLWIN32


/**
  * Function: BinToTextA
  * Converts a binary string to it's c representation
  * (complete with escape sequences)
  *
  * Arguments:
  * rgc, source string
  * lSource, length of source string
  *
  * Returns:
  * nothing
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  * 9/92 -- made this ANSII version-- DaveWi
  *     because err msg tables in NT are not UNICODE
  * 01/19/93 -- Removed the string copies.  They were not needed, and
  * MHotchin    broke anything that had embedded nulls in it.
  *             Also added support for allocating memory as needed.
  **/

PCHAR BinToTextA(

PCHAR szInBuf,     //... Input, binary, string
int   lSource)     //... Length of szInBuf
{
    int   i;
    int   cOutBufLen  = 0;
    int   lTarget     = 0;      //... Max length of szOutBuf
    PCHAR szOutBuf    = NULL;   //... Output string with escape sequences


    // If the target is NULL, allocate some memory.  We set aside
    // 5% more than the source length.  MHotchin
    // chngd to 5% or 5 chars if 10% is less than 50    davewi

    lTarget = (lSource == 0) ? 0 : lSource + 1;
    
    szOutBuf = (PCHAR)FALLOC( lTarget);

    for ( i = 0; i < lSource; i++ )
    {
        switch( szInBuf[i] )
        {
            case '\a':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'a');
                break;

            case '\b':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'b');
                break;

            case '\f':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'f');
                break;

            case '\n':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'n');
                break;

            case '\r':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'r');
                break;

            case '\t':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 't');
                break;

            case '\v':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'v');
                break;

            case '\\':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                break;

            default:
            {
                unsigned char ucTmp = szInBuf[i];

                if ( (ucTmp >= 0 && ucTmp < 32)
                  || ucTmp == 0x7f
                  || ucTmp == 0xa9
                  || ucTmp == 0xae )
                {
                    CHAR szt[5];

                    szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 4, szOutBuf);
                    sprintf( szt, "%#04hx", (unsigned short)ucTmp);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szt[0]);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szt[1]);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szt[2]);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szt[3]);
                }
                else
                {
                    szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 1, szOutBuf);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szInBuf[i]);
                }
                break;
            }
        }
    }
    szOutBuf[ cOutBufLen] = '\0';

    return( szOutBuf);
}



/**
  * Function: TextToBinA
  * Converts a string with c escape sequences to a true binary string.
  *
  * Arguments:
  * rgc, target string
  * sz, source string
  * l, maximum length of target string
  *
  * Returns:
  * length of target string
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  * 9/92 -- made this ANSII version-- DaveWi
  *     because msg resource table strings are not UNICODE
  * 01/21/93 - Removed the string copies - it breaks on embedded NULL's,
  *             and they aren't needed anyways.        MHotchin
  *
  **/

int TextToBinA(

CHAR szOutBuf[],    //... Output, binary, string
CHAR szInBuf[],     //... Input string with escape sequences
int  lTarget)       //... Max length of szOutBuf
{
    int  i = 0;
    int  c = 0;


    while (szInBuf[c])
    {
        if (szInBuf[c] == '\\')
        {           // escape sequence!
            c++;

            switch (szInBuf[c++])
            {
                case 'a':

                    AddTo(szOutBuf, &i, lTarget, '\a');
                    break;

                case 'b':

                    AddTo(szOutBuf, &i, lTarget, '\b');
                    break;

                case 'f':

                    AddTo(szOutBuf, &i, lTarget, '\f');
                    break;

                case 'n':

                    AddTo(szOutBuf, &i, lTarget, '\n');
                    break;

                case 'r':

                    AddTo(szOutBuf, &i, lTarget, '\r');
                    break;

                case 't':

                    AddTo(szOutBuf, &i, lTarget, '\t');
                    break;

                case 'v':

                    AddTo(szOutBuf, &i, lTarget, '\v');
                    break;

                case '\'':

                    AddTo(szOutBuf, &i, lTarget, '\'');
                    break;

                case '\"':

                    AddTo(szOutBuf, &i, lTarget, '\"');
                    break;

                case '\\':

                    AddTo(szOutBuf, &i, lTarget, '\\');
                    break;

                case '0':
                case '1':
                case '2':
                {
                    CHAR szt[4];


                    szt[0] = szt[1] = szt[2] = szt[3] = '\0';

                    if ( szInBuf[c] >= '0' && szInBuf[c] <= '9' )
                    {
                        szt[0] = szInBuf[c-1];
                        szt[1] = szInBuf[c++];

                        if ( szInBuf[c] >= '0' && szInBuf[c] <= '9' )
                        {
                        szt[2] = (CHAR)szInBuf[c++];
                        }
                        AddTo(szOutBuf, &i, lTarget, (CHAR)atoi( szt));
                    }
                    else if ( toupper( szInBuf[c]) == 'X' )
                    {
                        c++;
                        szt[0] = szInBuf[c++];
                        szt[1] = szInBuf[c++];
                        AddTo(szOutBuf, &i, lTarget, (CHAR)atoihex( szt));
                    }
                    else
                    {
                        QuitA( IDS_INVESCSEQ, &szInBuf[c-2], NULL);
                    }
                    break;
                }
                case 'x':
                {
                    CHAR szt[4];


                    // Changed letters we were comparing to - it used
                    // to be lower case.  MHotchin

                    szt[0] = szt[1] = szt[2] = szt[3] = '\0';

                    if ((szInBuf[c] <= '9' && szInBuf[c] >= '0')
                        || (toupper(szInBuf[c]) >= 'A'
                            && toupper(szInBuf[c]) <= 'F'))
                    {
                szt[0] = (CHAR)szInBuf[c++];

                        if ((szInBuf[c] <= '9' && szInBuf[c] >= '0')
                            || (toupper(szInBuf[c]) >= 'A'
                                && toupper(szInBuf[c]) <= 'F'))
                        {
                            szt[1] = szInBuf[c++];

                            if ((szInBuf[c] <= '9' && szInBuf[c] >= '0')
                                || (toupper(szInBuf[c]) >= 'A'
                                    && toupper(szInBuf[c]) <= 'F'))
                            {
                                szt[2] = szInBuf[c++];
                            }
                        }
                    }
                AddTo(szOutBuf, &i, lTarget, (CHAR)atoihex(szt));
                    break;
                }
                default:

                    AddTo(szOutBuf, &i, lTarget, szInBuf[c-1]);
                    break;
            }                   //... END switch
        }
        else
        {
        AddTo(szOutBuf, &i, lTarget, (CHAR)szInBuf[c++]);
        }
    }                           //... END while
    szOutBuf[i++] = '\0';

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\exentres.h ===
#define  IDERR_SUCCESS   0

int   ExtractResFromExe32A( char *, char *, WORD);
int   BuildExeFromRes32A(   char *, char *, char *);
ULONG GetListOfResLangIDs( char *szExeName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\langlist.h ===
// This file will get used when the "list of languages" feature is added.

#define ID_LANGID_LIST  1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\exe2res.h ===
#ifndef _EXE2RES_H_
#define _EXE2RES_H_

#define BUFSIZE 2048

/* error codes for file handling functions */
#define  IDERR_SUCCESS          0
#define  IDERR_BASE         255
#define  IDERR_ALLOCFAIL        (IDERR_BASE+1)
#define  IDERR_LOCKFAIL         (IDERR_BASE+2)
#define  IDERR_OPENFAIL         (IDERR_BASE+3)
#define  IDERR_READFAIL         (IDERR_BASE+4)
#define  IDERR_WINFUNCFAIL      (IDERR_BASE+5)
#define  IDERR_INVALIDPARAM     (IDERR_BASE+6)
#define  IDERR_FILETYPEBAD      (IDERR_BASE+7)
#define  IDERR_EXETYPEBAD       (IDERR_BASE+8)
#define  IDERR_WINVERSIONBAD    (IDERR_BASE+9)
#define  IDERR_RESTABLEBAD      (IDERR_BASE+10)
#define  IDERR_ICONBAD          (IDERR_BASE+11)
#define  IDERR_NOICONS          (IDERR_BASE+12)
#define  IDERR_ARRAYFULL        (IDERR_BASE+13)



#ifdef  RLDOS
/* Predefined resource types */
#define RT_NEWRESOURCE  0x2000
#define RT_ERROR        0x7fff

#define RT_CURSOR       1
#define RT_BITMAP       2
#define RT_ICON         3
#define RT_MENU         4
#define RT_DIALOG       5
#define RT_STRING       6
#define RT_FONTDIR      7
#define RT_FONT         8
#define RT_ACCELERATORS 9
#define RT_RCDATA       10
/* Error tables were never implemented and can be removed from RC */
/* #define RT_ERRTABLE     11 (done for 3.1) */
#define RT_GROUP_CURSOR 12
/* The value 13 is unused */
#define RT_GROUP_ICON   14
/* Name Tables no longer exist (this change made for 3.1) */
#define RT_NAMETABLE    15
#define RT_VERSION      16

#endif //RLDOS

#ifndef RLWIN32
typedef unsigned short USHORT;
typedef short SHORT;
#endif


typedef struct resinfo
{
    struct resinfo *next;
    SHORT flags;
    WORD nameord;
    PSTR name;
    LONG BinOffset;
    LONG size;
    WORD *poffset;
} RESINFO;



typedef struct typinfo
{
    struct typinfo *next;
    WORD typeord;
    PSTR type;
    SHORT nres;
    struct resinfo *pres;
} TYPINFO;


/* ----- Function prototypes ----- */

int ExtractResFromExe16A( CHAR *szInputExe,
                          CHAR *szOutputRes,
                          WORD   wFilter);

int BuildExeFromRes16A( CHAR *szTargetExe,
                        CHAR *szSourceRes,
                        CHAR *szSourceExe);

/* ----- Symbols ----- */

#define PRELOAD_ALIGN   5
#define PRELOAD_MINPADDING 16
#define DO_PRELOAD  1
#define DO_LOADONCALL   2
#define NUMZEROS 512
#define RESTABLEHEADER  4

#define MAXCODE     8192
#define MAXFARCODE  65500

#define WINDOWSEXE    2

#define OLDEXESIGNATURE       0x5A4D
#define NEWEXESIGNATURE       0x454E
#define ORDINALFLAG   0x8000

#define CV_OLD_SIG      0x42524e44L /* Old Signature is 'DNRB' */
#define CV_SIGNATURE    0x424e      /* New signature is 'NBxx' (x = digit) */

/* local typedefs */

typedef struct {      /* DOS 1, 2, 3, 4 .EXE header */
    WORD   ehSignature; /* signature bytes */
    WORD   ehcbLP;      /* bytes on last page of file */
    WORD   ehcp;        /* pages in file */
    WORD   ehcRelocation; /* count of relocation table entries*/
    WORD   ehcParagraphHdr; /* size of header in paragraphs */
    WORD   ehMinAlloc;      /* minimum extra paragraphs needed */
    WORD   ehMaxAlloc;      /* maximum extra paragraphs needed */
    WORD   ehSS;            /* initial \(relative\) SS value */
    WORD   ehSP;            /* initial SP value */
    WORD   ehChecksum;      /* checksum */
    WORD   ehIP;            /* initial IP value */
    WORD   ehCS;            /* initial \(relative\) CS value */
    WORD   ehlpRelocation;  /* file address of relocation table */
    WORD   ehOverlayNo;     /* overlay number */
    WORD   ehReserved[16];  /* reserved words */
    LONG ehPosNewHdr;       /* file address of new exe header */
} EXEHDR;                   /* eh */

typedef struct {            /* new .EXE header */
    WORD nhSignature;       /* signature bytes */
    char   nhVer;           /* LINK version number */
    char   nhRev;           /* LINK revision number */
    WORD nhoffEntryTable;   /* offset of Entry Table */
    WORD nhcbEntryTable;    /* number of bytes in Entry Table */
    LONG nhCRC;             /* checksum of whole file */
    WORD nhFlags;           /* flag word */
    WORD nhAutoData;        /* automatic data segment number */
    WORD nhHeap;            /* initial heap allocation */
    WORD nhStack;           /* initial stack allocation */
    LONG nhCSIP;            /* initial CS:IP setting */
    LONG nhSSSP;            /* initial SS:SP setting */
    WORD nhcSeg;            /* count of file segments */
    WORD nhcMod;            /* entries in Module Reference Table*/
    WORD nhcbNonResNameTable; /* size of non-resident name table */
    WORD nhoffSegTable;       /* offset of Segment Table */
    WORD nhoffResourceTable;  /* offset of Resource Table */
    WORD nhoffResNameTable;   /* offset of Resident Name Table */
    WORD nhoffModRefTable;    /* offset of Module Reference Table */
    WORD nhoffImpNameTable;   /* offset of Imported Names Table */
    LONG nhoffNonResNameTable; /* offset of Non-resident Names Tab */
    WORD nhcMovableEntries;    /* count of movable entries */
    WORD nhcAlign;             /* segment alignment shift count */
    WORD nhCRes;               /* count of resource segments */
    BYTE nhExeType;            /* target OS \(OS/2=1, Windows=2\) */
    BYTE nhFlagsOther;         /* additional exe flags */
    WORD nhGangStart;          /* offset to gangload area */
    WORD nhGangLength;         /* length of gangload area */
    WORD nhSwapArea;           /* minimum code swap area size*/
    WORD nhExpVer;             /* expected Windows version number */
} NEWHDR;                      /* nh */

typedef struct {
    WORD rtType;
    WORD rtCount;
    LONG rtProc;
} RESTYPEINFO;

typedef struct {            /* Resource name information block */
    WORD   rnOffset;        /* file offset to resource data */
    WORD   rnLength;        /* length of resource data */
    WORD   rnFlags;         /* resource flags */
    WORD   rnID;            /* resource name id */
    WORD   rnHandle;        /* reserved for runtime use */
    WORD   rnUsage;         /* reserved for runtime use */
} RESNAMEINFO;              /* rn */


/* ----- CodeView types and symbols ----- */

typedef struct
{
    char signature[4];
    long secTblOffset;
} CVINFO;

typedef struct
{
    long secOffset[5];
    unsigned version;
} CVSECTBL;

#endif // _EXE2RES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\ntmsgtbl.h ===
#ifndef _NTMSGTBL_H_
#define _NTMSGTBL_H_

VOID  *GetResMessage( FILE *, DWORD *);
void   PutResMessage( FILE *, FILE *, RESHEADER, VOID *);
void   TokResMessage( FILE *, RESHEADER, VOID *);
void   ClearResMsg(   VOID **);


#endif	 //... _NTMSGTBL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\exe2res.c ===
#include <dos.h>
#include <stdio.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
//#include <tchar.h>


#ifdef RLDOS
    #include "dosdefs.h"
#else
    #include <windows.h>
    #include "windefs.h"
#endif

#include "restok.h"
#include "exe2res.h"
#include "newexe.h"


/* ----- Function prototypes ----- */

static void  PrepareFiles(         PSTR, PSTR, PSTR);
static void  ReadSegmentTable(     void);
static void  ComputeResTableSize(  void);
static void  ComputeStringOffsets( void);
static void  BuildResTable(        void);
static void  SegsWrite(            WORD);
static DWORD RelocCopy(            WORD);
static void  ResWrite(             WORD);
static void  SetEXEHeaderFlags(    void);
static void  RewriteTables(        void);
static void  CopyCodeViewInfo(     FILE *, FILE *);
static void  OutPutError(          char *);
static void  ResTableBufferInit(   WORD);
static void  ResTableBufferFree(   void);
static WORD  GetAlign(             DWORD,  WORD);
static LONG  MoveFilePos(          FILE *, WORD, WORD);
static WORD  RoundUp(              LONG,   WORD);
static WORD  AlignFilePos(         FILE *, WORD, BOOL);
static WORD  ReadExeOldHeader(     FILE *, LONG, LONG *) ;
static WORD  ReadExeNewHeader(     FILE *, LONG, LONG, LONG *);
static WORD  ExtractExeResources(  FILE *, FILE *, LONG , LONG);
static void  ExtractString(        FILE *, FILE *, LONG);
static WORD  WriteResFromExe(      FILE *,
                                   FILE *,
                                   LONG,
                                   RESNAMEINFO,
                                   RESTYPEINFO,
                                   WORD);

static TYPINFO *AddResType(      CHAR *, WORD);
static PSTR  MyMakeStr(          PSTR);
static SHORT MyRead(             FILE *, PSTR, WORD);
static SHORT MyWrite(            FILE *, PSTR, WORD);
static LONG  MySeek(             FILE *, LONG, WORD);
static void  MyCopy(             FILE *, FILE *, DWORD);
static int   ProcessBinFile(     void);
static PSTR  RcAlloc(            WORD);
static void  AddResToResFile(    TYPINFO *, RESINFO *);
static void  AddDefaultTypes(    void);
static void  GetOrdOrName(       unsigned int *, unsigned char *);

/* ----- Version functions (added for 3.1) ----- */

static void RcPutWord(   unsigned int);
static int  RcPutString( char *);



/* ----- Module variables ----- */

static struct exe_hdr  OldExe;
static struct new_exe  NewExe;
static struct new_seg *pSegTable;
static PSTR   pResTable;
static PSTR   pResNext;
static FILE * fhInput;
static FILE * fhOutput;
static FILE * fhBin;
static DWORD  dwMaxFilePos;
static DWORD  dwNewExe;
static WORD   wPreloadOffset;
static WORD   wPreloadLength;
static WORD   wResTableOffset;
static WORD   wSegTableLen;
static WORD   wResTableLen;
static BYTE   zeros[ NUMZEROS] = "";
static DWORD  dwExeEndFile;
static WORD   fMultipleDataSegs;



//.........................................................................

int ExtractResFromExe16A( CHAR *szInputExe, CHAR *szOutputRes, WORD wFilter)
{
    QuitT( IDS_NO16RESWINYET, NULL, NULL);

#ifdef 0
    WORD    wResult = (WORD)-1;
    LONG    lPosNewHdr;
    LONG    lPosResourceTable;
    LONG    lFileLen;
    FILE    *fExeFile;
    FILE    *fResFile;
    struct     _stat ExeStats;
    /* initialize */
    wResult      = IDERR_SUCCESS;



    /* open file for reading */
    if ((fExeFile = FOPEN(szInputExe, "rb" )) == NULL ) {
        wResult = IDERR_OPENFAIL;
    }

    if ((fResFile = FOPEN(szOutputRes, "wb" )) == NULL ) {
        wResult = IDERR_OPENFAIL;
    }

    /* get file length */
    if (wResult == IDERR_SUCCESS) {
        _stat(szInputExe , &ExeStats );
        lFileLen = ExeStats.st_size;
    }

    /* read old header, verify contents, and get positon of new header */
    if (wResult == IDERR_SUCCESS) {
        wResult = ReadExeOldHeader( fExeFile, lFileLen, &lPosNewHdr );
    }

    /* read new header, verify contents, &  get position of resource table */
    if (wResult == IDERR_SUCCESS)
        wResult = ReadExeNewHeader(
                                  fExeFile,
                                  lFileLen,
                                  lPosNewHdr,
                                  &lPosResourceTable
                                  );

    wResult = ExtractExeResources( fExeFile , fResFile, lPosResourceTable , lFileLen);
    return ( wResult);
#endif // 0
}

//....................................................................

int BuildExeFromRes16A(

                      CHAR *pstrDest,
                      CHAR *pstrRes,
                      CHAR *pstrSource )
{
    QuitT( IDS_NO16WINRESYET, NULL, NULL);

#ifdef 0
    SHORT nResTableDelta;

    fSortSegments = TRUE;
    /* Get a memory block to use for MyCopy\(\) */


    PrepareFiles(pstrSource, pstrDest, pstrRes);

    ProcessBinFile();

    /* Read the segment table */
    ReadSegmentTable();

    /* Compute the length of the resource table */
    ComputeResTableSize();

    /* Compute string offsets for non-ordinal type and resource names */
    ComputeStringOffsets();

    /* Build the resource table */
    BuildResTable();

    /* Now go back to the beginning */
    MySeek(fhInput, 0L, 0);

    /* Copy from input to output up to the segment table */
    MyCopy(fhInput, fhOutput, dwNewExe + (DWORD)NewExe.ne_segtab);

    /* Copy the segment table */
    MyCopy(fhInput, fhOutput, (long)wSegTableLen);

    /* Save a pointer to the start of the resource table */
    wResTableOffset = (unsigned)(MySeek(fhOutput, 0L, 1) - dwNewExe);

    /* Write our resource table out */
    if (wResTableLen) {
        MyWrite(fhOutput, pResTable, wResTableLen);
    }

    /* Now we\'re looking at the beginning of the resident name table */
    MySeek(fhInput, (LONG)NewExe.ne_restab + dwNewExe, 0);

    /* Copy all the other tables \(they must fall between the resident
     *  names table and the non-resident names table.
     */
    MyCopy(fhInput, fhOutput,
           NewExe.ne_nrestab - (LONG)NewExe.ne_restab - dwNewExe);

    /* Copy the nonresident name table as well */
    MyCopy(fhInput, fhOutput, (LONG)NewExe.ne_cbnrestab);

    /* Compute new pointers in new exe header */
    NewExe.ne_rsrctab = wResTableOffset;
    nResTableDelta = wResTableOffset + wResTableLen - NewExe.ne_restab;
    NewExe.ne_restab += nResTableDelta;
    NewExe.ne_modtab += nResTableDelta;
    NewExe.ne_imptab += nResTableDelta;
    NewExe.ne_enttab += nResTableDelta;
    NewExe.ne_nrestab += nResTableDelta;
    #ifdef VERBOSE
    /* Tell the user what we\'re doing */
    if (fVerbose && fSortSegments) {
        fprintf(errfh, "Sorting preload segments and"
                " resources into fast-load section\n");
        if (fBootModule)
            fprintf(errfh,"This is a boot module; the .DEF file"
                    " is assumed to be correct!\n");
    }
    #endif

    /* If we\'re sorting segments, write preload segments and resources
     *  into a section separate from the load on call stuff.
     */
    if (fSortSegments) {
        /* Save the start of the preload section */
        wPreloadOffset = AlignFilePos(fhOutput, NewExe.ne_align, TRUE);

        /* Write PRELOAD segments and resources */
        SegsWrite(DO_PRELOAD);
        ResWrite(DO_PRELOAD);

        /* Compute the properly aligned length of the preload section */
        wPreloadLength = AlignFilePos(fhOutput, NewExe.ne_align, TRUE) -
                         wPreloadOffset;

        /* Now do the LOADONCALL segs and resources */
        SegsWrite(DO_LOADONCALL);
        ResWrite(DO_LOADONCALL);
    }

    /* If we\'re not sorting segments, just write them into a common block */
    else {
        /* Write the segs and resources */
        SegsWrite(DO_PRELOAD | DO_LOADONCALL);
        ResWrite(DO_PRELOAD | DO_LOADONCALL);
    }

    #ifdef SETEXEFLAGS
    /* Set flags and other values in the EXE header */
    SetEXEHeaderFlags();
    #endif

    /* Rewrite the new exe header, segment table and resource table */
    RewriteTables();
    ResTableBufferFree();

    /* Handle CodeView info */
    CopyCodeViewInfo(fhInput, fhOutput);

    /* Seek to end of output file and issue truncating write */
    MySeek(fhOutput, 0L, 2);
    MyWrite(fhOutput, zeros, 0);
    fclose(fhInput);
    fclose(fhOutput);
    fclose(fhBin);
    FreePTypInfo(pTypInfo);
    pTypInfo=NULL;
    MyFree(pSegTable);
    pSegTable=NULL;
    return TRUE;
#endif // 0
}

/*
 *
 * ReadExeOldHeader\( fExeFile, lFileLen, plPosNewHdr \) : WORD;
 *
 *    fExeFile        file handle of .exe file being read
 *    lFileLen         length of file
 *    plPosNewHdr      pointer to file position of new header
 *
 *     This function reads the old header from an executable file, checks to be
 * sure that it is a valid header, and saves the position of the file\'s
 * new header.
 *
 * This function returns IDERR_SUCCESS if there are no errors, or a non-zero
 * error code if there are.
 *
 */

static WORD ReadExeOldHeader(

                            FILE  *fExeFile,
                            LONG   lFileLen,
                            LONG  *plPosNewHdr )
{
    LONG  lPos;
    WORD    cb;
    EXEHDR        ehOldHeader;
    WORD  wResult;

    /* initialize */
    wResult = IDERR_SUCCESS;

    lPos = fseek( fExeFile, 0L, SEEK_SET );


    if (lPos != 0L)
        wResult = IDERR_READFAIL;

    if (wResult == IDERR_SUCCESS) {
        cb = fread(  (void *) &ehOldHeader, sizeof( EXEHDR) , 1, fExeFile );

        if (cb != 1 ) {
            wResult = IDERR_READFAIL;
        } else if (ehOldHeader.ehSignature != OLDEXESIGNATURE) {
            wResult = IDERR_FILETYPEBAD;
        } else if (ehOldHeader.ehPosNewHdr < sizeof(EXEHDR)) {
            wResult = IDERR_EXETYPEBAD;
        } else if ( ehOldHeader.ehPosNewHdr > (LONG)(lFileLen - sizeof(NEWHDR)) ) {
            wResult = IDERR_EXETYPEBAD;
        } else {
            *plPosNewHdr = ehOldHeader.ehPosNewHdr;
        }
    }

    return wResult;
}

/*
 *
 * ReadExeNewHeader\( fExeFile, lFileLen, lPosNewHdr, plPosResourceTable \) : WORD;
 *
 *    fExeFile        file handle of .exe file being read
 *    lFileLen         length of file
 *    lPosNewHdr       file position of new header
 *    plPosResourceTable   pointer to file position of resource table
 *
 *     This function reads the new header from an executable file, checks to be
 * sure that it is a valid header, and saves the position of the file\'s
 * resource table.
 *
 * This function returns IDERR_SUCCESS if there are no errors, or a non-zero
 * error code if there are.
 *
 */

static WORD ReadExeNewHeader(

                            FILE *fExeFile,
                            LONG  lFileLen,
                            long  lPosNewHdr,
                            LONG *plPosResourceTable )
{
    WORD wResult;
    WORD cb;
    LONG lPos;
    NEWHDR       nhNewHeader;

    /* initialize */
    wResult = IDERR_SUCCESS;

    fseek( fExeFile, lPosNewHdr, SEEK_SET );
    lPos = ftell( fExeFile );

    if (lPos == (long) -1 || lPos > lFileLen || lPos != lPosNewHdr) {
        wResult = IDERR_READFAIL;
    } else {
        cb = fread( ( void *)&nhNewHeader, sizeof(nhNewHeader) , 1, fExeFile );

        if (cb != 1 ) {
            wResult = IDERR_READFAIL;
        } else if (nhNewHeader.nhSignature != NEWEXESIGNATURE) {
            wResult = IDERR_FILETYPEBAD;
        } else if (nhNewHeader.nhExeType != WINDOWSEXE) {
            wResult = IDERR_EXETYPEBAD;
        } else if (nhNewHeader.nhExpVer < 0x0300) {
            wResult = IDERR_WINVERSIONBAD;
        } else if (nhNewHeader.nhoffResourceTable == 0) {
            wResult = IDERR_RESTABLEBAD;
        } else {
            *plPosResourceTable = lPosNewHdr + nhNewHeader.nhoffResourceTable;
        }
    }

    return wResult;
}

/*
 *
 * ReadExeTable\( fExeFile , lPosResourcTable \) : WORD;
 *
 *    fExeFile      file handle of .exe file being read
 *
 * This function reads through the entries in an .exe file\'s resource table,
 * identifies any icons in that table, and saves the file offsets of the data
 * for those icons. This function expects the initial file position to point
 * to the first entry in the resource table.
 *
 * This function returns IDERR_SUCCESS if there are no errors, or a non-zero
 * error code if there are.
 *
 */

static WORD ExtractExeResources(

                               FILE  *fExeFile,
                               FILE  *fResFile,
                               LONG   lPosResourceTable,
                               LONG   lFileLen )
{
    BOOL    fLoop;
    WORD    wResult;
    WORD    cb;
    LONG    lPos;
    WORD    wShiftCount;
    wResult = IDERR_SUCCESS;


    // posistion file pointer at resource table
    fseek( fExeFile, lPosResourceTable, SEEK_SET );
    lPos = ftell(fExeFile);

    if (lPos == (LONG) -1 || lPos > lFileLen || lPos != lPosResourceTable) {
        return  IDERR_READFAIL ;
    }

    if (wResult == IDERR_SUCCESS) {
        cb = fread( (void *) &wShiftCount, sizeof(wShiftCount), 1 , fExeFile );
    }

    if (cb != 1 ) {
        return IDERR_READFAIL;
    }

    if (wShiftCount > 16) {
        return IDERR_RESTABLEBAD;
    }

    /* initialize */
    wResult       = IDERR_SUCCESS;
    fLoop         = TRUE;


    /* loop through entries in resource table */
    while (fLoop == TRUE) {
        WORD    cb;
        WORD    iFile;
        RESTYPEINFO   rt;

        /* read RESTYPEINFO */
        cb = fread( (void *)&rt, sizeof(rt), 1, fExeFile );

        if (cb != 1 ) {
            wResult = IDERR_READFAIL;
            break;
        }

        if ( rt.rtType == 0 )
            break;

        // now get all the resource of this type
        for (
            iFile = 0;
            iFile<rt.rtCount && wResult==IDERR_SUCCESS;
            iFile++
            ) {
            RESNAMEINFO rn;

            cb = fread(  (void *) &rn, sizeof(rn) , 1 , fExeFile );

            if (cb != 1 ) {
                wResult = IDERR_READFAIL;
            }

            WriteResFromExe( fExeFile, fResFile,lPos, rn, rt, wShiftCount );

        }
        fLoop = (rt.rtType != 0) && (wResult == IDERR_SUCCESS);
    }
    FCLOSE(fExeFile);
    FCLOSE(fResFile);
    return wResult;
}

//.................................................................

static WORD WriteResFromExe(

                           FILE        *fExeFile,
                           FILE        *fResFile,
                           LONG         lPos,
                           RESNAMEINFO  ResNameInfo,
                           RESTYPEINFO  ResTypeInfo,
                           WORD         wShiftCount )
{
    LONG lCurPos;
    LONG lResPos;
    LONG wLength;
    LONG wTmpLength;

    wLength =  (LONG) ResNameInfo.rnLength << wShiftCount;

    lCurPos = ftell( fExeFile );
    // position file pointer at resouce location
    lResPos = (LONG) ResNameInfo.rnOffset << wShiftCount;
    fseek( fExeFile, lResPos, SEEK_SET );

    if ( ResTypeInfo.rtType & 0x8000) {
        PutByte( fResFile, (BYTE) 0xff, NULL );
        PutWord( fResFile, (WORD)(ResTypeInfo.rtType & 0x7FFF), NULL);
    } else {
        ExtractString(fExeFile,fResFile,lPos+ResTypeInfo.rtType);
    }

    if ( ResNameInfo.rnID & 0x8000 ) {
        PutByte( fResFile, (BYTE) 0xff, NULL );
        PutWord( fResFile, (WORD)(ResNameInfo.rnID & 0x7fFF), NULL);
    } else {
        ExtractString(fExeFile,fResFile,lPos+ResNameInfo.rnID);
    }

    PutWord( fResFile, ResNameInfo.rnFlags , NULL );
    PutdWord( fResFile, (LONG) wLength, NULL );
    wTmpLength = wLength;
    // now write the actual data

    fseek( fExeFile, lResPos, SEEK_SET );
    ReadInRes( fExeFile, fResFile, &wTmpLength );
    fseek( fExeFile, lCurPos, SEEK_SET );

    return 0;
}

//..................................................................

static void ExtractString( FILE *fExeFile, FILE *fResFile, LONG lPos)
{
    BYTE n,b;

    fseek(fExeFile, lPos, SEEK_SET);

    n=GetByte(fExeFile, NULL);
    for (;n--; ) {
        b=GetByte(fExeFile, NULL);
        PutByte(fResFile, (CHAR) b, NULL);
    }
    PutByte(fResFile, (CHAR) 0, NULL);
}


// Modifications for RLTOOLS

// Currently we dont support any dynamic flags
BOOL    fBootModule   = FALSE;
BOOL    fSortSegments = TRUE;

TYPINFO *pTypInfo = NULL;

static void FreePTypInfo( TYPINFO *pTypInfo)
{
    RESINFO * pRes, *pRTemp;
    TYPINFO * pTItemp;

    while (pTypInfo) {
        pRes = pTypInfo->pres;
        while (pRes) {
            pRTemp = pRes->next;
            MyFree(pRes->name);
            MyFree(pRes);
            pRes = pRTemp;
        }
        pTItemp = pTypInfo->next;
        MyFree(pTypInfo->type);
        MyFree(pTypInfo);
        pTypInfo = pTItemp;
    }
}

/* ----- Helper functions ----- */


/*  PrepareFiles
 *  Prepares the EXE files \(new and old\) for writing and verifies
 *  that all is well.
 *  Exits on error, returns if processing should continue.
 */

static void PrepareFiles(

                        PSTR pstrSource,
                        PSTR pstrDest,
                        PSTR pstrRes )
{
    /* Open the .EXE file the linker gave us */
    if ( (fhInput = FOPEN(pstrSource, "rb" )) == NULL ) {
        OutPutError("Unable to open Exe Source  File");
    }

    if ((fhBin = FOPEN(pstrRes, "rb")) == NULL ) {
        OutPutError("Unable to open Resource File");
    }

    /* Read the old format EXE header */
    MyRead(fhInput, (PSTR)&OldExe, sizeof (OldExe));

    /* Make sure its really an EXE file */
    if (OldExe.e_magic != EMAGIC) {
        OutPutError("Invalid .EXE file" );
    }

    /* Make sure theres a new EXE header floating around somewhere */
    if (!(dwNewExe = OldExe.e_lfanew)) {
        OutPutError("Not a Microsoft Windows format .EXE file");
    }

    /* Go find the new .EXE header */
    MySeek(fhInput, dwNewExe, 0);
    MyRead(fhInput, (PSTR)&NewExe, sizeof (NewExe));

    /* Check version numbers */
    if (NewExe.ne_ver < 4) {
        OutPutError("File not created by LINK");
    }

    /* Were there linker errors? */
    if (NewExe.ne_flags & NEIERR) {
        OutPutError("Errors occurred when linking file.");
    }

    /* Make sure that this program\'s EXETYPE is WINDOWS \(2\) not OS/2 \(1\) */
    if (NewExe.ne_exetyp != 2)
        OutPutError("The EXETYPE of the program is not WINDOWS.\n"
                    "(Make sure the .DEF file is correct.");
#ifdef VERBOSE
    if (fVerbose) {
        fprintf(errfh, "\n");
    }
#endif

    /* Open the all new executable file */
    if ( (fhOutput = FOPEN( pstrDest, "wb")) == NULL ) {
        OutPutError("Unable to create destination");
    }
}


/*  ReadSegmentTable
 *  Reads the segment table from the file.
 */

static void ReadSegmentTable( void)
{
    struct new_seg* pSeg;
    WORD i;

    MySeek(fhInput, (LONG)NewExe.ne_segtab + dwNewExe, 0);
    if ((wSegTableLen = NewExe.ne_cseg * sizeof (struct new_seg)) > 0) {
        pSegTable = (struct new_seg *)RcAlloc   (wSegTableLen);
        MyRead(fhInput, (PSTR)pSegTable, wSegTableLen);

        /* See if we have more than one data segment */
        fMultipleDataSegs = 0;
        for (pSeg = pSegTable, i = NewExe.ne_cseg ; i ; --i, ++pSeg) {
            if ((pSeg->ns_flags & NSTYPE) == NSDATA) {
                ++fMultipleDataSegs;
            }
        }
        if (fMultipleDataSegs) {
            --fMultipleDataSegs;
        }
    } else {
        pSegTable = NULL;
    }
}

/*  ComputeResTableSize
 *  Computes the size of the resource table by enumerating all the
 *  resources currently in the linked lists.
 */

static void ComputeResTableSize( void)
{
    TYPINFO **pPrev;
    TYPINFO *pType;
    RESINFO *pRes;

    /* Start with the minimum overhead size of the resource table.  This
     *  is the resource alignment count and the zero WORD terminating the
     *  table.  This is necessary so that we put the correct file offset
     *  in for the string offsets to named resources.
     */
    wResTableLen = RESTABLEHEADER;

    /* Loop over type table, computing the fixed length of the
     *  resource table, removing unused type entries.
     */
    pPrev = &pTypInfo;
    dwMaxFilePos = 0L;
    while (pType = *pPrev) {
        if (pRes = pType->pres) {
            /* Size of type entry */
            wResTableLen += sizeof (struct rsrc_typeinfo);
            while (pRes) {
                /* Size of resource entry */
                wResTableLen += sizeof (struct rsrc_nameinfo);
                if (pType->next || pRes->next) {
                    dwMaxFilePos += pRes->size;
                }
                pRes = pRes->next;
            }
            pPrev = &pType->next;
        } else {
            *pPrev = pType->next;
            MyFree(pType->type);
            MyFree(pType);
        }
    }
}


/*  ComputeStringOffsets
 *  Computes offsets to strings from named resource and types.
 */

static void ComputeStringOffsets( void)
{
    TYPINFO *pType;
    RESINFO *pRes;

    /* Loop over type table, computing string offsets for non-ordinal
     *  type and resource names.
     */
    pType = pTypInfo;
    while (pType) {
        pRes = pType->pres;

        /* Is there an ordinal? */
        if (pType->typeord) {
            /* Mark the ordinal */
            pType->typeord |= RSORDID;

            /* Flush the string name */
            MyFree(pType->type);
            pType->type = NULL;
        } else if (pType->type) {           /* is there a type string? */
            /* Yes, compute location of the type string */
            pType->typeord = wResTableLen;
            wResTableLen += strlen(pType->type) + 1;
        }

        while (pRes) {
            /* Is there an ordinal? */
            if (pRes->nameord) {
                /* Mark the ordinal */
                pRes->nameord |= RSORDID;

                /* Flush the string name */
                MyFree(pRes->name);
                pRes->name = NULL;
            }

            /* Is there a resource name? */
            else if (pRes->name) {
                /* Yes, compute location of the resource string */
                pRes->nameord = wResTableLen;
                wResTableLen += strlen(pRes->name) + 1;
            }
            pRes = pRes->next;
        }
        pType = pType->next;
    }
}


/*  BuildResTable
 *  Builds the local memory image of the resource table.
 */

static void BuildResTable( void)
{
    TYPINFO *pType;
    RESINFO *pRes;

    /* Check to see if we have any resources.  If not, just omit the table */
    if (wResTableLen > RESTABLEHEADER) {

        /* Set up the temporary resource table buffer */
        ResTableBufferInit(wResTableLen);

        /* Alignment shift count
         *  \(we default here to the segment alignment count\)
         */
        RcPutWord(NewExe.ne_align);

        pType = pTypInfo;
        while (pType) {
            /* output the type and number of resources */
            RcPutWord(pType->typeord); /* DW type id */
            RcPutWord(pType->nres);    /* DW #resources for this type */
            RcPutWord(0);              /* DD type procedure */
            RcPutWord(0);

            /* output flags and space for the file offset for each resource */
            pRes = pType->pres;
            while (pRes) {
                pRes->poffset = (WORD *)pResNext;
                RcPutWord(0);           /* DW file offset */
                RcPutWord(0);           /* DW resource size */
                pRes->flags |= NSDPL;
                RcPutWord(pRes->flags ); /* DW flags */
                RcPutWord(pRes->nameord ); /* DW name id */
                RcPutWord(0);              /* DW handle */
                RcPutWord(0);              /* DW usage or minalloc */
                pRes = pRes->next;
            }
            pType = pType->next;
        }

        /* Null entry terminates table */
        RcPutWord(0);

        /* Output type and name strings for non-ordinal resource types
         *  and names */
        pType = pTypInfo;
        while (pType) {
            /* Dump out any strings for this type */
            if (pType->type && !(pType->typeord & RSORDID)) {
                RcPutString(pType->type);
            }

            pRes = pType->pres;
            while (pRes) {
                if (pRes->name && !(pRes->nameord & RSORDID))
                    RcPutString(pRes->name);

                pRes = pRes->next;
            }

            pType = pType->next;
        }
    } else
        wResTableLen = 0;
}


/*  SegsWrite
 *  Copies segments to the file.  This routine will do only preload,
 *  only the load on call, or both types of segments depending on
 *  the flags.
 */

static void SegsWrite( WORD wFlags)
{
    WORD wExtraPadding;
    WORD i;
    static struct new_seg *pSeg;
    DWORD dwSegSize;
    DWORD dwWriteSize;
    WORD wTemp;
    WORD wcbDebug;

    /* We only need extra padding in the preload section.
     *  Note that when wFlags == DO_PRELOAD | DO_LOADONCALL, we DON\'T
     *  need extra padding because this is NOT a preload section.
     *  \(hence the \'==\' instead of an \'&\'\)
     */
    wExtraPadding = (wFlags == DO_PRELOAD);

    /* Copy segment data for each segment, fixed and preload only */
    for (i = 1, pSeg = pSegTable; i <= NewExe.ne_cseg; i++, pSeg++) {
        /* If there\'s no data in segment, skip it here */
        if (!pSeg->ns_sector) {
            continue;
        }

        /* Force some segments to be preload if doing preload resources */
        if ((wFlags & DO_PRELOAD) && !fBootModule) {
            char *reason = NULL;

            /* Check various conditions that would force preloading */
            if (i == (unsigned)(NewExe.ne_csip >> 16)) {
                reason = "Entry point";
            }
            if (!(pSeg->ns_flags & NSMOVE)) {
                reason = "Fixed";
            }
            if (pSeg->ns_flags & NSDATA) {
                reason = "Data";
            }
            if (!(pSeg->ns_flags & NSDISCARD)) {
                reason = "Non-discardable";
            }

            /* If this segment must be preload and the segment is not already
             *  marked as such, warn the user and set it.
             */
            if (reason && !(pSeg->ns_flags & NSPRELOAD)) {
#ifdef VERBOSE
                fprintf(errfh,
                        "RC: warning RW4002: %s segment %d set to PRELOAD\n",
                        reason, i);
#endif
                pSeg->ns_flags |= NSPRELOAD;
            }
        }

        /* Skip this segment if it doesn\'t match the current mode */
        wTemp = pSeg->ns_flags & NSPRELOAD ? DO_PRELOAD : DO_LOADONCALL;
        if (!(wTemp & wFlags)) {
            continue;
        }

        /* Get the true segment length.  A zero length implies 64K */
        if (pSeg->ns_cbseg) {
            dwSegSize = pSeg->ns_cbseg;
        } else {
            dwSegSize = 0x10000L;
        }

#ifdef VERBOSE

        if (fVerbose)
            fprintf(errfh, "Copying segment %d (%lu bytes)\n", i, dwSegSize);
#endif

        /* Align the segment correctly and pad the file to match */
        MoveFilePos(fhInput, pSeg->ns_sector, NewExe.ne_align);
        pSeg->ns_sector = AlignFilePos(fhOutput, NewExe.ne_align,
                                       wExtraPadding);

        /* Copy the segment */
        MyCopy(fhInput, fhOutput, dwSegSize);

        /* Pad out all segments in the preload area to their minimum
         *  memory allocation size so that KERNEL doesn\'t have to realloc
         *  the segment.
         */
        if (wExtraPadding && pSeg->ns_cbseg != pSeg->ns_minalloc) {
            /* A minalloc size of zero implies 64K */
            if (!pSeg->ns_minalloc) {
                dwWriteSize = 0x10000L - pSeg->ns_cbseg;
            } else {
                dwWriteSize = pSeg->ns_minalloc - pSeg->ns_cbseg;
            }

            /* Add in to total size of segment */
            dwSegSize += dwWriteSize;

            /* Set the segment table size to this new size */
            pSeg->ns_cbseg = pSeg->ns_minalloc;

            /* Pad the file */
            while (dwWriteSize) {
                dwWriteSize -= MyWrite(fhOutput,
                                       zeros,
                                       (WORD)(dwWriteSize > (DWORD) NUMZEROS
                                              ? NUMZEROS : dwWriteSize));
            }
        }

        /* Copy the relocation information */
        if (pSeg->ns_flags & NSRELOC) {
            /* Copy the relocation stuff */
            dwSegSize += RelocCopy(i);

            /* Segment + padding + relocations can\'t be >64K for preload
             *  segments.
             */
            if (fSortSegments && (pSeg->ns_flags & NSPRELOAD) &&
                dwSegSize > 65536L) {
#ifdef VERBOSE
                fprintf(errfh,
                        "RC : fatal error RW1031: Segment %d and its\n"
                        "     relocation information is too large for load\n"
                        "     optimization. Make the segment LOADONCALL or\n"
                        "     rerun RC using the -K switch if the segment must\n"
                        "     be preloaded.\n", i);
#endif
            }
        }

        /* Copy any per-segment debug information */
        if (pSeg->ns_flags & NSDEBUG) {
            MyRead(fhInput, (PSTR)&wcbDebug, sizeof (WORD));
            MyWrite(fhOutput, (PSTR)&wcbDebug, sizeof (WORD));
            MyCopy(fhInput, fhOutput, (LONG)wcbDebug);
        }
    }
}


/*  RelocCopy
 *  Copys all the relocation records for a given segment.
 *  Also checks for invalid fixups.
 */

static DWORD RelocCopy( WORD wSegNum)
{
    WORD wNumReloc;
    struct new_rlc RelocRec;
    WORD i;
    BYTE byFixupType;
    BYTE byFixupFlags;
    WORD wDGROUP;

    /* Get the number of relocations */
    MyRead(fhInput, (PSTR)&wNumReloc, sizeof (WORD));
    MyWrite(fhOutput, (PSTR)&wNumReloc, sizeof (WORD));

    /* Get the automatic data segment */
    wDGROUP = NewExe.ne_autodata;

    /* Copy and verify all relocations */
    for (i = 0 ; i < wNumReloc ; ++i) {
        /* Copy the record */
        MyRead(fhInput, (PSTR)&RelocRec, sizeof (RelocRec));
        MyWrite(fhOutput, (PSTR)&RelocRec, sizeof (RelocRec));

        /* Validate it only if necessary */
        if ((NewExe.ne_flags & (NENOTP | NESOLO)) ||
            wSegNum == wDGROUP || fMultipleDataSegs) {
            continue;
        }

        /* Bad fixups are fixups to DGROUP in code segments in apps
         *  that can be multi-instanced.  Since we can\'t fix up locations
         *  that are different from instance to instance in shared code
         *  segments, we have to warn the user.  We only warn because this
         *  may be allowable if the app only allows a single instance of
         *  itself to run.
         */
        byFixupType = (BYTE) (RelocRec.nr_stype & NRSTYP);
        byFixupFlags = (BYTE) (RelocRec.nr_flags & NRRTYP);
#ifdef VERBOSE
        if ((byFixupType == NRSSEG || byFixupType == NRSOFF) &&
            byFixupFlags == NRRINT &&
            RelocRec.nr_union.nr_intref.nr_segno == wDGROUP)

            fprintf(errfh,
                    "RC : warning RW4005: Segment %d (offset %04X) contains a\n"
                    "     relocation record pointing to the automatic\n"
                    "     data segment.  This will cause the program to crash\n"
                    "     if the instruction being fixed up is executed in a\n"
                    "     multi-instance application.  If this fixup is\n"
                    "     necessary, the program should be restricted to run\n"
                    "     only a single instance.\n", wSegNum, RelocRec.nr_soff);
#endif
    }

    return wNumReloc * sizeof (struct new_rlc);
}


/*  ResWrite
 *  Copies resources to the file.  This routine will do only the preload,
 *  only the load on call, or both types of resources depending on the
 *  flags.
 */

static void ResWrite( WORD wFlags)
{
    WORD wExtraPadding;
    WORD wTemp;
    WORD wResAlign;
    TYPINFO *pType;
    RESINFO *pRes;

    /* If we have no resource table, just ignore this */
    if (!wResTableLen) {
        return;
    }

    /* We only need extra padding in the preload section.
     *  Note that when wFlags == DO_PRELOAD | DO_LOADONCALL, we DON\'T
     *  need extra padding because this is NOT a preload section.
     *  \(hence the \'==\' instead of an \'&\'\)
     */
    wExtraPadding = (wFlags == DO_PRELOAD);

    /* Compute resource alignment.  Note that the alignment is not the
     *  same as the segment alignment ONLY IF there is no segment sorting
     *  and some resources cannot be reached with the current segment
     *  align count.
     */
    wResAlign = NewExe.ne_align;

    if (!fSortSegments) {
        /* Compute the needed alignment */
        dwMaxFilePos += MySeek(fhOutput, 0L, 2);
        wResAlign = GetAlign(dwMaxFilePos, NewExe.ne_align);

#ifdef VERBOSE
        if (fVerbose)
            fprintf(errfh, "Resources will be aligned on %d byte boundaries\n",
                    1 << wResAlign);
#endif

        /* Point back to the start of the local memory resource table */
        pResNext = pResTable;
        RcPutWord(wResAlign);
    }

    /* Output contents associated with each resource */
    for (pType = pTypInfo ; pType; pType = pType->next) {
        for (pRes = pType->pres ; pRes ; pRes = pRes->next) {
            /* Make sure this is the right kind of resource */
            wTemp = pRes->flags & RNPRELOAD ? DO_PRELOAD : DO_LOADONCALL;
            if (!(wTemp & wFlags)) {
                continue;
            }

            /* Give some info to the user */
#ifdef VERBOSE
            if (fVerbose) {
                fprintf(errfh, "Writing resource ");
                if (pRes->name && !(pRes->nameord & RSORDID)) {
                    fprintf(errfh, "%s", pRes->name);
                } else {
                    fprintf(errfh, "%d", pRes->nameord & 0x7FFF);
                }

                if (pType->type && !(pType->typeord & RSORDID)) {
                    fprintf(errfh, ".%s", pType->type);
                } else {
                    fprintf(errfh, ".%d", pType->typeord & 0x7FFF);
                }

                fprintf(errfh, " (%lu bytes)\n", pRes->size);
                fflush(errfh);
            }
#endif

            /* Copy the resource from the RES file to the EXE file */
            MySeek(fhBin, (long)pRes->BinOffset, 0);
            *(pRes->poffset)++ =
            AlignFilePos(fhOutput, wResAlign, wExtraPadding);
            *(pRes->poffset) = RoundUp(pRes->size, wResAlign);
            MyCopy(fhBin, fhOutput, pRes->size);
        }
    }

    /* Compute the end of the EXE file thus far for the CV info */
    dwExeEndFile = AlignFilePos(fhOutput, wResAlign, wExtraPadding);
}

#ifdef SETEXEFLAGS
/*  SetEXEHeaderFlags
 *  Sets necessary flags and values in the EXE header.
 */

static void SetEXEHeaderFlags( void)
{
    /* Tell loader we initialized previously unused fields */
    if (NewExe.ne_ver == 4) {
        NewExe.ne_rev = 2;
    }

    /* Set command line values into the header */
    NewExe.ne_expver   = expWinVer;
    NewExe.ne_swaparea = swapArea;

    /* Set the preload section values */
    if (fSortSegments) {
        /* Set the new fastload section values */
        NewExe.ne_gangstart = wPreloadOffset;
        NewExe.ne_ganglength = wPreloadLength;
    #ifdef VERBOSE
        if (fVerbose)
            fprintf(errfh, "Fastload area is %ld bytes at offset 0x%lX.\n",
                    (LONG)wPreloadLength << NewExe.ne_align,
                    (LONG)wPreloadOffset << NewExe.ne_align);
    }
    #endif

    /* Clear all the flags */
    NewExe.ne_flags &=
    ~(NELIM32|NEMULTINST|NEEMSLIB|NEPRIVLIB|NEPRELOAD);

    /* Set appropriate flags */
    if (fLim32) {
        NewExe.ne_flags |= NELIM32;
    }
    if (fMultInst) {
        NewExe.ne_flags |= NEMULTINST;
    }
    if (fEmsLibrary) {
        NewExe.ne_flags |= NEEMSLIB;
    }
    if (fPrivateLibrary) {
        NewExe.ne_flags |= NEPRIVLIB;
    }
    if (fProtOnly) {
        NewExe.ne_flags |= NEPROT;
    }

    if (fSortSegments && wPreloadLength) {
        NewExe.ne_flagsother |= NEPRELOAD;
    }

    NewExe.ne_flags |= NEWINAPI;
}
#endif

/*  RewriteTables
 *  Rewrites the EXE header and the resource and segment tables
 *  with their newly-updated information.
 */

static void RewriteTables( void)
{
    /* Write the new EXE header */
    MySeek(fhOutput, (LONG)dwNewExe, 0);
    MyWrite(fhOutput, (PSTR)&NewExe, sizeof (NewExe));

    /* Seek to the start of the segment table */
    MySeek(fhOutput, dwNewExe + (LONG)NewExe.ne_segtab, 0);
    MyWrite(fhOutput, (PSTR)pSegTable, wSegTableLen);

    /* Seek to and write the resource table */
    if (wResTableLen) {
        MySeek(fhOutput, dwNewExe + (LONG)NewExe.ne_rsrctab, 0);
        MyWrite(fhOutput, pResTable, wResTableLen);
    }
}



/*  CopyCodeViewInfo
 *  Copies CodeView info to the new EXE file and relocates it if
 *  necessary.  This routine is designed to work with the
 *  DNRB-style info as well as NBxx info where x is a digit.
 */

static void CopyCodeViewInfo( FILE *fhInput, FILE *fhOutput)
{
    unsigned long dwcb;
    unsigned int i;
    CVINFO cvinfo;
    CVSECTBL cvsectbl;

    /* See if old format \(DNRB\) symbols present at end of input file
     *  If they are, relocate the table to the new file position and
     *  fix up the file-position dependent offsets.
     */
    dwcb = MySeek( fhInput, -(signed long)sizeof (CVINFO), 2);
    MyRead( fhInput, (char *)&cvinfo, sizeof (cvinfo));

    if (*(unsigned long *)cvinfo.signature == CV_OLD_SIG) {
        dwcb -= cvinfo.secTblOffset;
        MySeek( fhInput, cvinfo.secTblOffset, 0);
        MyRead( fhInput, (char *)&cvsectbl, sizeof (cvsectbl));
        dwcb -= sizeof (cvsectbl);

        for (i = 0 ; i < 5 ; ++i) {
            cvsectbl.secOffset[i] -= cvinfo.secTblOffset;
        }

        cvinfo.secTblOffset = dwExeEndFile;

        for (i = 0 ; i < 5 ; ++i) {
            cvsectbl.secOffset[i] += cvinfo.secTblOffset;
        }

        MySeek( fhOutput, cvinfo.secTblOffset, 0);
        MyWrite( fhOutput, (char *)&cvsectbl, sizeof (cvsectbl));
        MyCopy( fhInput, fhOutput, dwcb);
        MyWrite( fhOutput, (char *)&cvinfo, sizeof (cvinfo));
    }

    /* Check for new format \(NBxx\) symbols.  Since these symbols are
     *  file-position independent, just copy them over; no need to
     *  fix them up as with the old format symbols.
     */
    else if (*(unsigned short int *)cvinfo.signature == CV_SIGNATURE &&
             isdigit(cvinfo.signature[2]) && isdigit(cvinfo.signature[3])) {
        MySeek( fhOutput, 0L, 2);
        MySeek( fhInput, -cvinfo.secTblOffset, 2);
        MyCopy( fhInput, fhOutput, cvinfo.secTblOffset);
    }
}

/*  OutPutError
 *  Outputs a fatal error message and exits.
 */

static void OutPutError( char *szMessage)
{
    QuitA( 0, szMessage, NULL);
}


/*  ResTableBufferInit
 *  Creates the resource table buffer and points global pointers
 *  to it.  This table is written to so that we can modifiy it
 *  before writing it out to the EXE file.
 */

static void ResTableBufferInit( WORD wLen)
{
    /* Allocate local storage for resource table */
    pResTable = RcAlloc   (wLen);

    /* Point to the start of the table for the PutXXXX\(\) */
    pResNext = pResTable;
}

/*  ResTableBufferFree
 *  Frees the temporary storage for resource table
 */

static void ResTableBufferFree( void)
{
    /* Nuke the table */
    MyFree(pResTable);
}



/*  GetAlign
 *  Computes the alignment value needed for the given maximum file
 *  position passed in.  This is done by computing the number of
 *  bits to be shifted left in order to represent the maximum
 *  file position in 16 bits.
 */

static WORD GetAlign( DWORD dwMaxpos, WORD wAlign)
{
    DWORD dwMask;
    WORD i;

    /* Compute the initial mask based on the input align value */
    dwMask = 0xFFFFL;
    for (i = 0; i < wAlign ; ++i) {
        dwMask <<= 1;
        dwMask |= 1;
    }

    /* See if we need to increase the default mask to reach the maximum
     *  file position.
     */
    while (dwMaxpos > dwMask) {
        dwMask <<= 1;
        dwMask |= 1;
        ++wAlign;
    }

    /* Return the new alignment */
    return wAlign;
}


/*  MoveFilePos
 *  Moves the file pointer to the position indicated by wPos, using the
 *  align shift count wAlign.  This converts the WORD value wPos
 *  into a LONG value by shifting left wAlign bits.
 */

static LONG MoveFilePos( FILE *fh, WORD wPos, WORD wAlign)
{
    return MySeek(fh, ((LONG)wPos) << wAlign, 0);
}


/*  RoundUp
 *  Computes the value that should go into a 16 bit entry in an EXE
 *  table by rounding up to the next boundary determined by the
 *  passed in alignment value.
 */

static WORD RoundUp( LONG lValue, WORD wAlign)
{
    LONG lMask;

    /* Get all the default mask of all ones except in the bits below the
     *  alignment value.
     */
    lMask = -1L;
    lMask <<= wAlign;

    /* Now round up using this mask */
    lValue += ~lMask;
    lValue &= lMask;

    /* Return as a 16 bit value */
    return ((WORD) (lValue >> (LONG) wAlign));
}


/*  AlignFilePos
 *  Computes a correctly aligned file position based on the current
 *  alignment.
 */

static WORD AlignFilePos( FILE *fh, WORD wAlign, BOOL fPreload)
{
    LONG lCurPos;
    LONG lNewPos;
    LONG lMask;
    WORD nbytes;
    WORD wNewAlign;

    /* If we\'re in the preload section, we have tougher alignment
     *  restrictions:  We have to be at least 32-byte aligned and have
     *  at least 32 bytes between objects for arena headers.  It turns
     *  out that this feature is not really used in KERNEL but could be
     *  implemented someday.
     */
    if (fPreload && wAlign < PRELOAD_ALIGN) {
        wNewAlign = PRELOAD_ALIGN;
    } else {
        wNewAlign = wAlign;
    }

    /* Get the current file position */
    lCurPos = MySeek(fh, 0L, 1);

    /* Compute the new position by rounding up to the align value */
    lMask = -1L;
    lMask <<= wNewAlign;
    lNewPos = lCurPos + ~lMask;
    lNewPos &= lMask;

    /* We have to have at least 32 bytes between objects in the preload
     *  section.
     */
    if (fPreload) {
        while (lNewPos - lCurPos < PRELOAD_MINPADDING) {
            lNewPos += 1 << wNewAlign;
        }
    }

    /* Check to see if it\'s representable in 16 bits */
    if (lNewPos >= (0x10000L << wAlign)) {
        OutPutError(".EXE file too large; relink with higher /ALIGN value");
    }

    /* Write stuff out to file until new position reached */
    if (lNewPos > lCurPos) {
        /* Compute number of bytes to write out and write them out */
        nbytes = (WORD) (lNewPos - lCurPos);
        while (nbytes) {
            nbytes -= MyWrite( fh,
                               zeros,
                               (WORD)(nbytes > NUMZEROS ? NUMZEROS : nbytes));
        }
    }

    /* Seek to and return this new position */
    return (WORD)(MySeek(fh, lNewPos, (WORD) 0) >> (LONG) wAlign);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  AddResType\(\) -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

static TYPINFO *AddResType( CHAR *s, WORD n )
{
    TYPINFO *pType;

    if (pType = pTypInfo) {
        while (TRUE) {
            /* search for resource type, return if already exists */
            if ((s && !strcmp(s, pType->type)) || (!s && n && pType->typeord == n)) {
                return (pType);
            } else if (!pType->next) {
                break;
            } else {
                pType = pType->next;
            }
        }

        /* if not in list, add space for it */
        pType->next = (TYPINFO *) RcAlloc(sizeof(TYPINFO));
        pType = pType->next;
    } else {
        /* allocate space for resource list */
        pTypInfo = (TYPINFO *)RcAlloc   (sizeof(TYPINFO));
        pType = pTypInfo;
    }

    /* fill allocated space with name and ordinal, and clear the resources
       of this type */
    pType->type = MyMakeStr(s);
    pType->typeord = n;
    pType->nres = 0;
    pType->pres = NULL;
    pType->next = NULL;

    return (pType);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetOrdOrName\(\) -                                */
/*                                      */
/*--------------------------------------------------------------------------*/

static void GetOrdOrName( unsigned int *pint, unsigned char *szstr)
{
    unsigned char c1;

    /* read the first character of the identifier */
    MyRead(fhBin, &c1, sizeof(unsigned char));

    /* if the first character is 0xff, the id is an ordinal, else a string */
    if (c1 == 0xFF) {
        MyRead(fhBin, (PSTR)pint, sizeof (int));
    } else {                                   /* string */
        *pint = 0;
        *szstr++ = c1;
        do {
            MyRead( fhBin, szstr, 1);
        }
        while (*szstr++ != 0);
    }
}



/*--------------------------------------------------------------------------*/
/*                                      */
/*  AddDefaultTypes\(\) -                             */
/*                                      */
/*--------------------------------------------------------------------------*/

static void AddDefaultTypes( void)
{
    AddResType( "CURSOR",       ID_RT_GROUP_CURSOR);
    AddResType( "ICON",         ID_RT_GROUP_ICON);
    AddResType( "BITMAP",       ID_RT_BITMAP);
    AddResType( "MENU",         ID_RT_MENU);
    AddResType( "DIALOG",       ID_RT_DIALOG);
    AddResType( "STRINGTABLE",  ID_RT_STRING);
    AddResType( "FONTDIR",      ID_RT_FONTDIR);
    AddResType( "FONT",         ID_RT_FONT);
    AddResType( "ACCELERATORS", ID_RT_ACCELERATORS);
    AddResType( "RCDATA",       ID_RT_RCDATA);
    AddResType( "VERSIONINFO",  ID_RT_VERSION);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  ProcessBinFile\(\) -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

static int ProcessBinFile( void)
{
    unsigned int  ord;
    unsigned char tokstr[64];
    RESINFO   *pRes;
    TYPINFO   *pType;
    long      curloc;
    long      eofloc;
    WORD wResType;

    /* initialize for reading .RES file */
    AddDefaultTypes();
    eofloc = MySeek(fhBin, 0L, 2);      /* get file size */
    curloc = MySeek(fhBin, 0L, 0);      /* go to beginning of file */

    /* while there are more resources in the .RES file */
    while (curloc < eofloc) {

#ifdef VERBOSE
        if (fVerbose) {
            fprintf(errfh, ".");
            fflush(errfh);
        }
#endif

        /* find the resource type of the next resource */
        GetOrdOrName(&ord, tokstr);

        if (!ord) {
            pType = AddResType(tokstr, 0);
        } else {
            pType = AddResType(NULL, (WORD)ord);
        }

        if (!pType) {
            break;
        }

        /* Save the type number so we can see if we want to skip it later */
        wResType = ord;

        /* find the identifier \(name\) of the resource */
        GetOrdOrName(&ord, tokstr);
        pRes = (RESINFO *)RcAlloc   (sizeof(RESINFO));
        if (!ord) {
            pRes->name = MyMakeStr(tokstr);
        } else {
            pRes->nameord = ord;
        }

        /* read the flag bits */
        MyRead(fhBin, (PSTR)&pRes->flags, sizeof(int));

        /* Clear the old DISCARD bits. */
        pRes->flags &= 0x1FFF;

        /* find the size of the resource */
        MyRead(fhBin, (PSTR)&pRes->size, sizeof(long));

        /* save the position of the resource for when we add it to the .EXE */
        pRes->BinOffset = (long)MySeek(fhBin, 0L, 1);

        /* skip the resource to the next resource header */
        curloc = MySeek(fhBin, (long)pRes->size, 1);

        /* add the resource to the resource lists.  We don\'t add name
         *  tables.  They are an unnecessary 3.0 artifact.
         */
        if (wResType != ID_RT_NAMETABLE) {
            AddResToResFile(pType, pRes);
        } else {
            MyFree(pRes->name);
            MyFree(pRes);
        }
    }

    return 1;
}



/*--------------------------------------------------------------------------*/
/*                                      */
/*  AddResToResFile\(pType, pRes\)          */
/*                                      */
/*  Parameters:                                 */
/*  pType  : Pointer to Res Type                        */
/*  pRes   : Pointer to resource                        */
/*                                      */
/*--------------------------------------------------------------------------*/

static void AddResToResFile( TYPINFO *pType, RESINFO *pRes)
{
    RESINFO *p;

    p = pType->pres;

    /* add resource to end of resource list for this type */
    if (p) {
        while (p->next) {
            p = p->next;
        }

        p->next = pRes;
        p->next->next = NULL;
    } else {
        pType->pres = pRes;
        pType->pres->next = NULL;
    }
    /* keep track of number of resources and types */
    pType->nres++;
}



/*  MyMakeStr
 *  Makes a duplicate string from the string passed in.  The new string
 *  should be freed when it is no longer useful.
 */

static PSTR MyMakeStr( PSTR s)
{
    PSTR s1;

    if (s) {
        s1 = RcAlloc( (WORD)(strlen(s) + 1)); /* allocate buffer */
        strcpy(s1, s);                  /* copy string */
    } else {
        s1 = s;
    }

    return s1;
}




static SHORT MyRead( FILE *fh, PSTR p, WORD n)
{
    size_t n1;

    if ( (n1 = fread( p, 1, n, fh)) != n )
        ;                               //  quit\("RC : fatal error RW1021: I/O error reading file."\);
    else
        return ( n1);
}


/*  MyWrite
 *  Replaces calls to write\(\) and does error checking.
 */

static SHORT MyWrite( FILE *fh, PSTR p, WORD n)
{
    size_t n1;

    if ( (n1 = fwrite( p, 1, n, fh)) != n )
        ;                               // quit\("RC : fatal error RW1022: I/O error writing file."\);
    else
        return ( n1);
}



/*  MySeek
 *  Replaces calls to lseek\(\) and does error checking
 */

static LONG MySeek( FILE *fh, LONG pos, WORD cmd)
{

    if ( (pos = fseek( fh, pos, cmd)) != 0 ) {
        OutPutError ("RC : fatal error RW1023: I/O error seeking in file");
    }
    return ( pos);
}


/*  MyCopy
 *  Copies dwSize bytes from source to dest in fixed size chunks.
 */

static void MyCopy( FILE *srcfh, FILE *dstfh, DWORD dwSize)
{
    WORD n;
    static char  chCopyBuffer[ BUFSIZE];

    while ( dwSize ) {
        n = MyRead( srcfh, chCopyBuffer, sizeof( chCopyBuffer));
        MyWrite( dstfh, chCopyBuffer, n);
        dwSize -= n;
    }
}


static void RcPutWord( unsigned int w)
{
    *((WORD *)pResNext) = w;
    pResNext++;
    pResNext++;
}


/*  PutStringWord
 *  Writes a string to the static resource buffer pointed to by pResNext.
 *  The string is stored in Pascal-format \(leading byte first\).
 *  Returns the number of characters written.
 */

static int RcPutString( char *pstr)
{
    int i;

    /* Make sure we have a valid string */
    if (!pstr || !(i = strlen(pstr))) {
        return 0;
    }

    /* Write the length byte */
    *pResNext++ = (char) i;

    /* Write all the characters */
    while (*pstr) {
        *pResNext++ = *pstr++;
    }

    /* Return the length */
    return (i + 1);
}


static PSTR RcAlloc( WORD nbytes)
{
    PSTR ps = NULL;

    if ( ps = (PSTR)MyAlloc( nbytes)) {
        return ( ps);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\exentres.c ===
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>

#include "windefs.h"
#include "restok.h"
#include "exentres.h"
#include "resread.h"
#include "checksum.h"

#define SAME        0   //... Used in string compares
#define MAXLEVELS   3   //... Max # of levels in resource directory

typedef struct tagResSectData {
    ULONG ulVirtualAddress; //... Virtual address of section .rsrc
    ULONG ulSizeOfResources;    //... Size of resources in section .rsrc
    ULONG ulVirtualSize;        //... Virtual Size of resources in .rsrc
    ULONG ulVirtualAddressX;    //... Virtual address of section .rsrc1
    ULONG ulSizeOfResourcesX;   //... Size of resources in section .rsrc1
    ULONG ulVirtualSizeX;       //... Virtual Size of resources in .rsrc1
} RESSECTDATA, *PRESSECTDATA;

WORD  gwFilter = 0;

int   InsertResourcesInExe( FILE *, HANDLE);
LONG  GetFileResources(     FILE *, FILE *, ULONG);
ULONG MoveFilePos(          FILE *, ULONG);
ULONG MyWrite(              FILE *, PUCHAR, ULONG);
ULONG MyRead(               FILE *, PUCHAR, ULONG);
WCHAR *GetDirNameU(        WCHAR *, PIMAGE_RESOURCE_DIR_STRING_U);
ULONG ReadResources(        FILE *, ULONG, ULONG, PUCHAR);
DWORD AddToLangIDList( DWORD);

ULONG ProcessDirectory(  FILE *,
                         USHORT,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY);

ULONG ProcessDirEntry(   FILE *,
                         USHORT,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY);

ULONG ProcessSubDir(     FILE *,
                         USHORT,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY);

ULONG ProcessNamedEntry( FILE *,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY);

ULONG ProcessIdEntry(    FILE *,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY);

ULONG ProcessDataEntry(  FILE *,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DATA_ENTRY);

int FindNewExeHdr( FILE *, ULONG *);

IMAGE_DOS_HEADER ExeDosHdr;//... Exe's DOS header
IMAGE_NT_HEADERS NTHdrs;   //... Exe's NT headers

struct tagLevelData  //... Holds ID or name for each directory level
{
    //... level [0] is for resource type
    ULONG dwID;                     //... level [1] is for resource name
    WCHAR wszName[128];             //... level [2] is for resource language
}
LevelData[ MAXLEVELS] = { 0L, TEXT(""), 0L, TEXT(""), 0L, TEXT("")};

BOOL fGetResLangIDs = FALSE;

extern BOOL      fInThirdPartyEditer;//.. Are we in a 3rd-party resource editor?

extern MSTRDATA gMstr;              //... Data from Master Project file (MPJ)
extern PROJDATA gProj;              //... Data from Language Project file (PRJ)
extern UCHAR    szDHW[];


PLANGLIST pLangIDList = NULL;


//..........................................................................

void FreeLangIDList( void)
{
    PLANGLIST pID = NULL;

    while ( pLangIDList ) {
        pID = pLangIDList->pNext;
        RLFREE( pLangIDList);
        pLangIDList = pID;
    }
}

//..........................................................................

ULONG GetListOfResLangIDs( char *szExeName)
{
    ULONG ulRC     = SUCCESS;
    ULONG ulOffset = 0;
    static RESHEADER ResHeader;         // Structure contain Resource Header info.


    if ( IsExe( szExeName) ) {                                //.. open the original exe file
        FILE *fpExe = FOPEN( szExeName, "rb");

        if ( fpExe != NULL ) {
            //... Get list of languages in exe file

            ulRC = (ULONG)FindNewExeHdr( fpExe, &ulOffset);

            if ( ulRC == SUCCESS ) {
                fGetResLangIDs = TRUE;

                ulRC = (ULONG)GetFileResources( fpExe, NULL, ulOffset);

                fGetResLangIDs = FALSE;
            }
            FCLOSE( fpExe);
        } else {
            ulRC = ERROR_OPEN_FAILED;
        }
    } else if ( IsWin32Res( szExeName) ) {
        FILE *fpRes = FOPEN( szExeName, "rb");

        if ( fpRes != NULL ) {
            LONG  lEndOffset = 0L;


            //... How large is the res file?
            fseek( fpRes, 0L, SEEK_END);
            lEndOffset = ftell( fpRes);

            rewind( fpRes);
            //... Get list of languages in .RES file

            while ( ulRC == SUCCESS && ! feof( fpRes) ) {
                LONG lCurrOffset = 0L;


                lCurrOffset = (LONG)ftell( fpRes);

                if ( (lCurrOffset + (LONG)sizeof( RESHEADER)) >= lEndOffset ) {
                    break;
                }

                if ( GetResHeader( fpRes, &ResHeader, NULL) == -1 ) {
                    ulRC = 1L;
                    break;
                }
                //... Is this the dummy, res32-identifying, res?

                if ( ResHeader.lSize == 0L ) {
                    continue;
                }
                ulRC = AddToLangIDList( (DWORD)ResHeader.wLanguageId);

                SkipBytes( fpRes, (DWORD *)&ResHeader.lSize);
                ClearResHeader( ResHeader);

                DWordUpFilePointer( fpRes, MYREAD, ftell( fpRes), NULL);

            }   // END while ( ! feof( InResFile)
            FCLOSE( fpRes);
        } else {
            ulRC = ERROR_OPEN_FAILED;
        }
    }

    if ( ulRC != SUCCESS ) {
        FreeLangIDList();
    }
    return ( ulRC);
}

//..........................................................................

int ExtractResFromExe32A(

                        char *szExeName,
                        char *szResName,
                        WORD  wFilter)
{
    FILE *fpExe = NULL;        //... Handle of input .EXE file
    FILE *fpRes = NULL;        //... Handle of output .RES file
    ULONG ulRC     = 0;
    ULONG ulOffset = 0;
    int nRC = SUCCESS;


    gwFilter = wFilter;

    //.. open the original exe file

    fpExe = FOPEN( szExeName, "rb");

    if ( fpExe == NULL ) {
        return ( ERROR_OPEN_FAILED);
    }
    nRC = FindNewExeHdr( fpExe, &ulOffset);

    if ( nRC != SUCCESS ) {
        FCLOSE( fpExe);
        return ( nRC);
    }
    fpRes = FOPEN( (CHAR *)szResName, "wb");

    if ( fpRes != NULL ) {
        //... First, write the dummy 32bit identifier

        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x20, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);

        PutWord( fpRes, 0xffff, NULL);
        PutWord( fpRes, 0x00,   NULL);
        PutWord( fpRes, 0xffff, NULL);
        PutWord( fpRes, 0x00,   NULL);

        PutdWord( fpRes, 0L, NULL);
        PutdWord( fpRes, 0L, NULL);

        PutdWord( fpRes, 0L, NULL);
        PutdWord( fpRes, 0L, NULL);

        ulRC = (ULONG)GetFileResources( fpExe, fpRes, ulOffset);

        FCLOSE( fpRes);
    } else {
        ulRC = GetLastError();
    }
    FCLOSE( fpExe);
    return ( ulRC);
}

//..........................................................................

int BuildExeFromRes32A(

                      char * szOutExe,    //... Output EXE file's name
                      char * szRes,       //... File of replacement resources
                      char * szInExe )    //... Intput EXE file's name
{
    HANDLE  hExeFile = NULL;
    FILE    *fpRes = NULL;
    DWORD   dwRC = 0;
    WORD    wRC  = 0;


    //... Copy Input exe to out put exe

    if ( CopyFileA( szInExe, szOutExe, FALSE) == FALSE ) {
        QuitA( IDS_COPYFILE_FAILED, szInExe, szOutExe);
    }

    if ( (fpRes = FOPEN( szRes, "rb")) == NULL ) {
        return -2;
    }

    SetLastError(0);

//if Source file was set attributes READ-ONLY, CopyFile sets temp file also.
//And BeginUpdateResourceA returns ERROR.

    SetFileAttributesA(szOutExe, FILE_ATTRIBUTE_NORMAL);

    hExeFile = BeginUpdateResourceA( szOutExe, TRUE);

    dwRC = GetLastError();

    if ( ! hExeFile ) {
        FCLOSE( fpRes);
        return ( -3);
    }

    wRC = (WORD)InsertResourcesInExe( fpRes, hExeFile);

    FCLOSE( fpRes);

    if ( wRC != 1 ) {
        return ( wRC);
    }

    SetLastError(0);    // needed only to see if EndUpdateResource
    // sets last error value.

    dwRC = EndUpdateResource( hExeFile, FALSE);

    if ( dwRC == FALSE ) {
        return ( -4);
    }
    MapFileAndFixCheckSumA( szOutExe); //... This func always calls QuitT or returns 0

    return (1);
}

//..........................................................................

int FindNewExeHdr( FILE *fpExe, ULONG *ulOffset)
{
    ULONG ulRC     = 0;

    //... read the old format EXE header

    ulRC = MyRead( fpExe, (void *)&ExeDosHdr, sizeof( ExeDosHdr));

    if ( ulRC != 0L && ulRC != sizeof( ExeDosHdr) ) {
        return ( ERROR_READ_FAULT);
    }

    //... make sure its really an EXE file

    if ( ExeDosHdr.e_magic != IMAGE_DOS_SIGNATURE ) {
        return ( ERROR_INVALID_EXE_SIGNATURE);
    }

    //... make sure theres a new EXE header
    //... floating around somewhere

    if ( ! (*ulOffset = ExeDosHdr.e_lfanew) ) {
        return ( ERROR_BAD_EXE_FORMAT);
    }
    return ( SUCCESS);
}

//..........................................................................

int InsertResourcesInExe(

                        FILE *fpRes,
                        HANDLE hExeFile )
{
    PVOID   pResData   = NULL;
    LONG    lEndOffset = 0L;
    BOOL    bUpdRC     = FALSE;
    LANGID  wLangID    = 0;
    int nResCnt = 0;
    int nResOut = 0;
    static RESHEADER    ResHeader;

    //... How big is the .RES file?

    fseek( fpRes, 0L, SEEK_END);
    lEndOffset = ftell( fpRes);

    rewind( fpRes);

    //... Update all resources, found in the .RES,
    //... to the .EXE
    while ( ! feof( fpRes) ) {
        DWordUpFilePointer( fpRes, MYREAD, ftell( fpRes), NULL);
        RLFREE( pResData);

        if (  ftell( fpRes) >= lEndOffset ) {
            return (1);
        }
        ZeroMemory( &ResHeader, sizeof( ResHeader));

        // Read in the resource header

        if ( ( GetResHeader( fpRes, &ResHeader, (DWORD *) NULL) == -1 ) ) {
            return ( -1);
        }

        if ( ResHeader.lSize > 0L ) {
            wLangID = ResHeader.wLanguageId;

            // Allocate Memory to hold resource data

            pResData = (PVOID)FALLOC( ResHeader.lSize);

            // Read it into the buffer

            if ( ResReadBytes( fpRes,
                               pResData,
                               (size_t)ResHeader.lSize,
                               NULL ) == FALSE ) {
                RLFREE( pResData);
                return (-1);
            }

            nResCnt++;   // Increment # resources read

            DWordUpFilePointer( fpRes, MYREAD, ftell( fpRes), NULL);
        } else {
            continue;
        }

        // now write the data

        if ( ResHeader.bTypeFlag == IDFLAG ) {
            if ( ResHeader.bNameFlag == IDFLAG ) {
                SetLastError(0);

                bUpdRC = UpdateResource( hExeFile,
                                         MAKEINTRESOURCE( ResHeader.wTypeID),
                                         MAKEINTRESOURCE( ResHeader.wNameID),
                                         wLangID,
                                         pResData,
                                         ResHeader.lSize);

                if ( ! bUpdRC ) {
                    RLFREE( pResData);
                    return (-1);
                }
            } else {
                SetLastError(0);

                bUpdRC = UpdateResource( hExeFile,
                                         MAKEINTRESOURCE( ResHeader.wTypeID),
                                         ResHeader.pszName,
                                         wLangID,
                                         pResData,
                                         ResHeader.lSize);

                if ( ! bUpdRC ) {
                    RLFREE( pResData);
                    return (-1);
                }
            }
        } else {
            if (ResHeader.bNameFlag == IDFLAG) {
                SetLastError(0);//BUGUG

                bUpdRC = UpdateResource( hExeFile,
                                         ResHeader.pszType,
                                         MAKEINTRESOURCE( ResHeader.wNameID),
                                         wLangID,
                                         pResData,
                                         ResHeader.lSize);

                if ( ! bUpdRC ) {
                    RLFREE( pResData);
                    return (-1);
                }
            } else {
                SetLastError(0);

                bUpdRC = UpdateResource( hExeFile,
                                         ResHeader.pszType,
                                         ResHeader.pszName,
                                         wLangID,
                                         pResData,
                                         ResHeader.lSize);

                if ( ! bUpdRC ) {
                    RLFREE( pResData);
                    return (-1);
                }
            }
        }
        ClearResHeader( ResHeader);
        RLFREE( pResData);
    }               //... END WHILE ( ! feof...
    return (1);
}

//............................................................

LONG GetFileResources(

                     FILE *fpExe,
                     FILE *fpRes,
                     ULONG ulHdrOffset)
{
    ULONG  ulOffsetToResources;
    ULONG  ulOffsetToResourcesX;
    ULONG  ulRead;
    ULONG  ulToRead;
    ULONG  ulRC = SUCCESS;
    PUCHAR pResources = NULL;  //... Ptr to start of resource directory table

    PIMAGE_SECTION_HEADER pSectTbl     = NULL;
    PIMAGE_SECTION_HEADER pSectTblLast = NULL;
    PIMAGE_SECTION_HEADER pSect        = NULL;
    PIMAGE_SECTION_HEADER pResSect     = NULL;
    PIMAGE_SECTION_HEADER pResSectX    = NULL;
    static RESSECTDATA ResSectData;

    //... Read the NT image headers into memory

    ulRC = MoveFilePos( fpExe, ulHdrOffset);

    if ( ulRC != 0L ) {
        return ( -1L);
    }
    ulRead = MyRead( fpExe, (PUCHAR)&NTHdrs, sizeof( IMAGE_NT_HEADERS));

    if ( ulRead != 0L && ulRead != sizeof( IMAGE_NT_HEADERS) ) {
        return ( -1L);
    }
    //... Check for valid exe

    if ( *(PUSHORT)&NTHdrs.Signature != IMAGE_NT_SIGNATURE ) {
        return ( ERROR_INVALID_EXE_SIGNATURE);
    }

    if ((NTHdrs.FileHeader.Characteristics&IMAGE_FILE_EXECUTABLE_IMAGE) == 0 &&
        (NTHdrs.FileHeader.Characteristics&IMAGE_FILE_DLL) == 0) {
        return ( ERROR_EXE_MARKED_INVALID);
    }
    //... Where is resource section in file
    //... and how big is it?

    //... First, read section table

    ulToRead = NTHdrs.FileHeader.NumberOfSections
               * sizeof( IMAGE_SECTION_HEADER);
    pSectTbl = (PIMAGE_SECTION_HEADER)FALLOC( ulToRead);

    memset( (PVOID)pSectTbl, 0, ulToRead);

    ulHdrOffset += sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) +
                   NTHdrs.FileHeader.SizeOfOptionalHeader;
    MoveFilePos( fpExe, ulHdrOffset);
    ulRead = MyRead( fpExe, (PUCHAR)pSectTbl, ulToRead);

    if ( ulRead != 0L && ulRead != ulToRead ) {
        SetLastError(ERROR_BAD_FORMAT);
        RLFREE( pSectTbl);
        return ( -1L);
    }
    pSectTblLast = pSectTbl + NTHdrs.FileHeader.NumberOfSections;

    for ( pSect = pSectTbl; pSect < pSectTblLast; ++pSect ) {
        if ( lstrcmpA( (CHAR *)pSect->Name, ".rsrc") == SAME && pResSect==NULL ) {
            pResSect = pSect;
        } else if ( lstrcmpA( (CHAR *)pSect->Name, ".rsrc1") == SAME && pResSectX==NULL ) {
            pResSectX = pSect;
        }
    }

    if ( pResSect == NULL ) {
        RLFREE( pSectTbl);
        QuitA( IDS_NO_RES_SECTION, gMstr.szSrc, NULL);
    }

    ulOffsetToResources  = pResSect->PointerToRawData;
    ulOffsetToResourcesX = pResSectX ? pResSectX->PointerToRawData : 0L;

    ResSectData.ulVirtualAddress   = pResSect->VirtualAddress;
    ResSectData.ulSizeOfResources  = pResSect->SizeOfRawData;
    ResSectData.ulVirtualSize      = pResSect->Misc.VirtualSize;
    ResSectData.ulVirtualAddressX  = pResSectX ? pResSectX->VirtualAddress : 0L;
    ResSectData.ulSizeOfResourcesX = pResSectX ? pResSectX->SizeOfRawData  : 0L;
    ResSectData.ulVirtualSizeX   = pResSectX ? pResSectX->Misc.VirtualSize : 0L;

    //... Read resource section into memory

    pResources = (PUCHAR)FALLOC((ulToRead =
                                 (max(ResSectData.ulVirtualSize,  ResSectData.ulSizeOfResources) +
                                  max(ResSectData.ulVirtualSizeX, ResSectData.ulSizeOfResourcesX))));
    memset( (PVOID)pResources, 0, ulToRead);

    ulRC = ReadResources( fpExe,
                          ulOffsetToResources,
                          ResSectData.ulSizeOfResources,
                          pResources);

    if ( ulRC != 0L ) {
        RLFREE( pSectTbl);
        RLFREE( pResources);
        return ( ulRC);
    } else if ( ResSectData.ulSizeOfResourcesX > 0L ) {
        ulRC = ReadResources( fpExe,
                              ulOffsetToResourcesX,
                              ResSectData.ulSizeOfResourcesX,
                              &pResources[ ResSectData.ulVirtualSize]);
        if ( ulRC != 0L ) {
            RLFREE( pSectTbl);
            RLFREE( pResources);
            return ( ulRC);
        }
    }
    //... Now process the resource table

    ulRC = ProcessDirectory( fpRes,
                             0,
                             &ResSectData,
                             (PIMAGE_RESOURCE_DIRECTORY)pResources,
                             (PIMAGE_RESOURCE_DIRECTORY)pResources);

    RLFREE( pSectTbl);
    RLFREE( pResources);

    return ( (LONG)ulRC);
}

//......................................................................

ULONG ProcessDirectory(

                      FILE *fpRes,
                      USHORT usLevel,
                      PRESSECTDATA pResSectData,
                      PIMAGE_RESOURCE_DIRECTORY pResStart,
                      PIMAGE_RESOURCE_DIRECTORY pResDir)
{
    ULONG ulRC = SUCCESS;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirStart;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEnd;


    pResDirStart = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)
                   ((PBYTE)pResDir + sizeof( IMAGE_RESOURCE_DIRECTORY));

    pResDirEnd = pResDirStart
                 + pResDir->NumberOfNamedEntries
                 + pResDir->NumberOfIdEntries;

    for ( pResDirEntry = pResDirStart, ulRC = 0L;
        pResDirEntry < pResDirEnd && ulRC == 0L;
        ++pResDirEntry ) {
        ulRC = ProcessDirEntry( fpRes,
                                usLevel,
                                pResSectData,
                                pResStart,
                                pResDirEntry);
    }
    return ( ulRC);
}

//......................................................................

ULONG ProcessDirEntry(

                     FILE *fpRes,
                     USHORT usLevel,
                     PRESSECTDATA pResSectData,
                     PIMAGE_RESOURCE_DIRECTORY pResStart,
                     PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    ULONG ulRC = SUCCESS;

    if ( pResDirEntry->Name & IMAGE_RESOURCE_NAME_IS_STRING ) {
        GetDirNameU( LevelData[ usLevel].wszName,
                     (PIMAGE_RESOURCE_DIR_STRING_U)((PBYTE)pResStart
                                                    + (pResDirEntry->Name & (~IMAGE_RESOURCE_NAME_IS_STRING))));
        LevelData[ usLevel].dwID = IMAGE_RESOURCE_NAME_IS_STRING;
    } else {
        LevelData[ usLevel].wszName[0] = TEXT('\0');
        LevelData[ usLevel].dwID = pResDirEntry->Name;
    }

    if ( pResDirEntry->OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY ) {
        ulRC = ProcessSubDir( fpRes,
                              usLevel,
                              pResSectData,
                              pResStart,
                              pResDirEntry);
    } else if ( pResDirEntry->Name & IMAGE_RESOURCE_NAME_IS_STRING ) {
        ulRC = ProcessNamedEntry( fpRes, pResSectData, pResStart, pResDirEntry);
    } else {
        ulRC = ProcessIdEntry( fpRes, pResSectData, pResStart, pResDirEntry);
    }
    return ( ulRC);
}

//......................................................................

ULONG ProcessSubDir(

                   FILE *fpRes,
                   USHORT usLevel,
                   PRESSECTDATA pResSectData,
                   PIMAGE_RESOURCE_DIRECTORY pResStart,
                   PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    PIMAGE_RESOURCE_DIRECTORY pResDir;

    pResDir = (PIMAGE_RESOURCE_DIRECTORY)((PBYTE)pResStart
                                          + (pResDirEntry->OffsetToData & (~IMAGE_RESOURCE_DATA_IS_DIRECTORY)));

    return ( ++usLevel < MAXLEVELS ? ProcessDirectory( fpRes,
                                                       usLevel,
                                                       pResSectData,
                                                       pResStart,
                                                       pResDir)
             : -1L);
}

//......................................................................

ULONG ProcessIdEntry(

                    FILE *fpRes,
                    PRESSECTDATA pResSectData,
                    PIMAGE_RESOURCE_DIRECTORY pResStart,
                    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    return ( ProcessDataEntry( fpRes,
                               pResSectData,
                               pResStart,
                               (PIMAGE_RESOURCE_DATA_ENTRY)((PBYTE)pResStart
                                                            + pResDirEntry->OffsetToData)));
}


//......................................................................

ULONG ProcessNamedEntry(

                       FILE *fpRes,
                       PRESSECTDATA pResSectData,
                       PIMAGE_RESOURCE_DIRECTORY pResStart,
                       PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    return ( ProcessDataEntry( fpRes,
                               pResSectData,
                               pResStart,
                               (PIMAGE_RESOURCE_DATA_ENTRY)((PBYTE)pResStart
                                                            + pResDirEntry->OffsetToData)));
}

//......................................................................

ULONG ProcessDataEntry(

                      FILE *fpRes,
                      PRESSECTDATA pResSectData,
                      PIMAGE_RESOURCE_DIRECTORY  pResStart,
                      PIMAGE_RESOURCE_DATA_ENTRY pResData)
{
    ULONG  ulOffset;
    ULONG  ulCopied;
    DWORD  dwHdrSize = 0L;
    fpos_t HdrSizePos;


    if ( fGetResLangIDs ) {      //... Are we just looking for LANG IDs?
        return ( AddToLangIDList( (WORD)(LevelData[2].dwID)));
    }

    if ( gwFilter != 0 ) {        //... Filtering turned on?
        //... Yes, is this a resource we want?
        if ( LevelData[0].dwID == IMAGE_RESOURCE_NAME_IS_STRING
             || LevelData[0].dwID != (DWORD)gwFilter ) {
            return ( 0L);        //... Not a resource we want
        }
    }

    //... Are we in the dialog editor?
    if ( fInThirdPartyEditer ) {                           //... Is the language we want?
        if ( LevelData[2].dwID != gMstr.wLanguageID ) {
            return ( 0L);        //... Not the language we want
        }
    }


    ulOffset = pResData->OffsetToData - pResSectData->ulVirtualAddress;

    if ( ulOffset >= pResSectData->ulVirtualSize ) {
        if ( pResSectData->ulVirtualSizeX > 0L ) {
            ulOffset = pResData->OffsetToData
                       + pResSectData->ulVirtualSize
                       - pResSectData->ulVirtualAddressX;

            if ( ulOffset >= pResSectData->ulVirtualSize
                 + pResSectData->ulSizeOfResourcesX ) {
                return ( (ULONG)-1L);
            }
        } else {
            return ( (ULONG)-1L);
        }
    }
    //... write out the resource header info
    //... First, write the resource's size

    PutdWord( fpRes, pResData->Size, &dwHdrSize);

    //... Remember where to write real hdr size and
    //... write out bogus hdr size, fix up later

    fgetpos( fpRes, &HdrSizePos);
    PutdWord( fpRes, 0, &dwHdrSize);

    //... Write resource type

    if ( LevelData[0].dwID == IMAGE_RESOURCE_NAME_IS_STRING ) {
        PutString( fpRes, (TCHAR *)LevelData[0].wszName, &dwHdrSize);
    } else {
        PutWord( fpRes, IDFLAG, &dwHdrSize);
        PutWord( fpRes, LOWORD( LevelData[0].dwID), &dwHdrSize);
    }

    //... Write resource name
    //... dbl-null-terminated if string

    if ( LevelData[1].dwID == IMAGE_RESOURCE_NAME_IS_STRING ) {
        PutString( fpRes, (TCHAR *)LevelData[1].wszName, &dwHdrSize);
    } else {
        PutWord( fpRes, IDFLAG, &dwHdrSize);
        PutWord( fpRes, LOWORD( LevelData[1].dwID), &dwHdrSize);
    }

    DWordUpFilePointer( fpRes, MYWRITE, ftell( fpRes), &dwHdrSize);

    //... More Win32 header stuff

    PutdWord( fpRes, 0, &dwHdrSize);        //... Data version
    PutWord( fpRes, 0x1030, &dwHdrSize);    //... MemoryFlags (WORD)

    //... language is always a number (WORD)

    PutWord( fpRes, LOWORD( LevelData[2].dwID), &dwHdrSize);

    //... More Win32 header stuff

    PutdWord( fpRes, 0, &dwHdrSize);        //... Version
    PutdWord( fpRes, 0, &dwHdrSize);        //... Characteristics

    //... Now, fix up the resource header size

    UpdateResSize( fpRes, &HdrSizePos, dwHdrSize);

    //... Copy the resource data to the res file

    ulCopied = MyWrite( fpRes, (PUCHAR)pResStart + ulOffset, pResData->Size);

    if ( ulCopied != 0L && ulCopied != pResData->Size ) {
        return ( (ULONG)-1);
    }
    DWordUpFilePointer( fpRes, MYWRITE, ftell( fpRes), NULL);
    return ( 0L);
}

//......................................................................

/*
 * Utility routines
 */


ULONG ReadResources(

                   FILE  *fpExe,
                   ULONG  ulOffsetToResources,
                   ULONG  ulSizeOfResources,
                   PUCHAR pResources)
{
    ULONG ulRC = SUCCESS;
    ULONG ulRead;


    ulRC = MoveFilePos( fpExe, ulOffsetToResources);

    if ( ulRC != 0L ) {
        return ( (ULONG)-1L);
    }
    ulRead = MyRead( fpExe, pResources, ulSizeOfResources);

    if ( ulRead != 0L && ulRead != ulSizeOfResources ) {
        return ( (ULONG)-1L);
    }
    return ( 0L);
}

//......................................................................

WCHAR * GetDirNameU(

                   WCHAR *pszDest,
                   PIMAGE_RESOURCE_DIR_STRING_U pDirStr)
{
    CopyMemory( pszDest, pDirStr->NameString, MEMSIZE( pDirStr->Length));
    pszDest[ pDirStr->Length] = L'\0';
    return ( pszDest);
}

//......................................................................

ULONG MoveFilePos( FILE *fp, ULONG pos)
{
    return ( fseek( fp, pos, SEEK_SET));
}

//......................................................................

ULONG MyWrite( FILE *fp, UCHAR *p, ULONG ulToWrite)
{
    size_t  cWritten;



    cWritten = fwrite( p, 1, (size_t)ulToWrite, fp);

    return ( (ULONG)(cWritten == ulToWrite ? 0L : cWritten));
}

//......................................................................

ULONG MyRead( FILE *fp, UCHAR*p, ULONG ulRequested )
{
    size_t  cRead;


    cRead = fread( p, 1, (size_t)ulRequested, fp);

    return ( (ULONG)(cRead == ulRequested ? 0L : cRead));
}

//......................................................................

DWORD AddToLangIDList( DWORD dwLangID)
{
    WORD wLangID = (WORD)dwLangID;

    if ( pLangIDList ) {
        PLANGLIST pID;

        for ( pID = pLangIDList; pID; pID = pID->pNext ) {
            if ( pID->wLang == wLangID ) {
                break;          //... LANGID already in list
            } else if ( pID->pNext == NULL ) {
                pID->pNext = (PLANGLIST)FALLOC( sizeof( LANGLIST));
                pID = pID->pNext;
                pID->pNext = NULL;
                pID->wLang = wLangID;
                //... LANGID now added to list
            }
        }
    } else {
        pLangIDList = (PLANGLIST)FALLOC( sizeof( LANGLIST));
        pLangIDList->pNext = NULL;
        pLangIDList->wLang = wLangID;
    }
    return ( SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

#ifdef NEVER
    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
#else
    unsigned char	ne_exetyp;	/* Target Operating system */
    unsigned char	ne_flagsothers;	/* Other .EXE flags */
#endif
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)	(x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004	/* True if handler proc return handle */

#define RNCOMPR     0x0200	/* Resource is compressed in ROM */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN	0	/* Unknown (any "new-format" OS) */
#define NE_OS2		1	/* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS	2	/* Microsoft Windows		 */
#define NE_DOS4 	3	/* Microsoft MS-DOS 4.x		 */
#define NE_DEV386	4	/* Microsoft Windows 386	 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\projdata.c ===
#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <errno.h>
#include <stdlib.h>

#include "windefs.h"
#include "restok.h"
#include "projdata.h"
#include "showerrs.h"
#include "rlmsgtbl.h"
#include "commbase.h"
#include "custres.h"
#include "rlstrngs.h"
#include "resource.h"
#include "resourc2.h"
#include "resread.h"
#include "langlist.h"
#include "exentres.h"

extern MSTRDATA  gMstr;
extern PROJDATA  gProj;
extern UCHAR     szDHW[];
extern BOOL      fCodePageGiven;
extern BOOL      gfReplace;
extern HWND      hMainWnd;

BOOL   bRLGui;			//FALSE=RLMan TRUE=RLAdmin RLEdit RLquiked

#ifdef RLRES32
extern PLANGLIST pLangIDList;
#endif

static PLANGDATA pLangList = NULL;



//............................................................

                                //...RLtools are localized so we would like
                                //...to get correct locale's Version stamp
BOOL MyVerQueryValue(
LPVOID pBlock,
LPTSTR lpSubBlock,
LPVOID *lplpBuffer,
PUINT  puLen)
{

    LPWORD lpXlate;         // ptr to translations data

    DWORD cbValueTranslation=0;
    TCHAR szVersionKey[60]; // big enough for anything we need

    if( VerQueryValue( pBlock, TEXT("\\VarFileInfo\\Translation"),
       (LPVOID*)&lpXlate, &cbValueTranslation) )
    {

        wsprintf( szVersionKey, TEXT("\\StringFileInfo\\%04X04B0\\%s"),
            *lpXlate, lpSubBlock );

        if( VerQueryValue ( pBlock, szVersionKey, lplpBuffer, puLen) )
            return TRUE;

    }

    wsprintf( szVersionKey, TEXT("\\StringFileInfo\\%04X04B0\\%s"),
        LANGIDFROMLCID(GetThreadLocale()), lpSubBlock );

    if( !VerQueryValue (pBlock, szVersionKey, lplpBuffer, puLen) )
    {

        wsprintf( szVersionKey, TEXT("\\StringFileInfo\\040904B0\\%s"),
            lpSubBlock );

        if( !VerQueryValue (pBlock, szVersionKey, lplpBuffer, puLen) )
            return FALSE;
    }

    return TRUE;

}


int GetMasterProjectData(

CHAR * pszMasterFile,   //... Master Project file name
CHAR * pszSrc,          //... Resource source file name or NULL
CHAR * pszMtk,          //... Master token file name or NULL
BOOL   fLanguageGiven)
{
    int nRC = SUCCESS;  //... Return code

                                //... check for the special case where Master
                                //... Project File does not exist. If it doesn't
                                //... go ahead and create it.

    memset(&gMstr, '\0', sizeof(gMstr));

    if ( _access( pszMasterFile, 0) != 0 )
    {
        if ( ! (pszSrc && pszMtk) )
        {
            ShowErr( IDS_ERR_03, pszMasterFile, NULL);
            nRC = IDS_ERR_03;
        }
        else
        {
                                //... Get source resource file name

            if ( _fullpath( gMstr.szSrc, pszSrc, sizeof( gMstr.szSrc)-1) )
            {
                                //... Get Master token file name and its
                                //... modification date. Use that same date as
                                //... the initial date the master project was
                                //... last updated.

                if ( _fullpath( gMstr.szMtk, pszMtk, sizeof( gMstr.szMtk)-1) )
                {
                    SzDateFromFileName( gMstr.szSrcDate, gMstr.szSrc);
                    lstrcpyA( gMstr.szMpjLastRealUpdate, gMstr.szSrcDate);

                                //... Create the new Master Project file.

                    nRC = PutMasterProjectData( pszMasterFile);
                }
                else
                {
                    ShowErr( IDS_ERR_13, pszMtk, NULL);
                    nRC = IDS_ERR_13;
                }
            }
            else
            {
                ShowErr( IDS_ERR_13, pszSrc, NULL);
                nRC = IDS_ERR_13;
            }
        }
    }
    else
    {
        FILE *pfMpj = NULL;


        if ( (pfMpj = fopen( pszMasterFile, "rt")) == NULL )
        {
            ShowErr( IDS_ERR_07, pszMasterFile, NULL);
            nRC = IDS_ERR_07;
        }
        else
        {
                                //... Get resource source file name
                                //... and master token file name

            if ( fgets( gMstr.szSrc, sizeof( gMstr.szSrc), pfMpj)
              && fgets( gMstr.szMtk, sizeof( gMstr.szMtk), pfMpj) )
            {
								//... Make sure these two files exist
                if ( pszSrc )
                {
				    if ( !_fullpath(gMstr.szSrc,pszSrc,sizeof( gMstr.szSrc)-1) )
					{
                        ShowErr( IDS_ERR_07, pszSrc, NULL);
                        fclose( pfMpj );
						return( IDS_ERR_07 );
					}
                }

                if ( pszMtk )
				{
				    if ( !_fullpath(gMstr.szMtk,pszMtk,sizeof( gMstr.szMtk)-1) )
					{
                        ShowErr( IDS_ERR_07, pszMtk, NULL);
                        fclose( pfMpj );
						return( IDS_ERR_07 );
                    }
                }
                                //... If -c flag not given, get RDF file name
                                //... from master project file, else use name
                                //... from the -c cmd line arg.

                if ( gMstr.szRdfs[0] == '\0' )
                {
                    if ( ! fgets( gMstr.szRdfs, sizeof( gMstr.szRdfs), pfMpj) )
                    {
                        ShowErr( IDS_ERR_21,
                                 "Master Project",
                                 pszMasterFile);
                        nRC = IDS_ERR_21;
                    }
                }
                else
                {
                    if ( ! fgets( szDHW, DHWSIZE, pfMpj) )
                    {
                        ShowErr( IDS_ERR_21,
                                 "Master Project",
                                 pszMasterFile);
                        nRC = IDS_ERR_21;
                    }
                }
                                //... Get stored date of source file and
                                //... date of last master token file update

                if ( nRC == 0
                  && fgets( gMstr.szSrcDate, sizeof( gMstr.szSrcDate), pfMpj)
                  && fgets( gMstr.szMpjLastRealUpdate,
                            sizeof( gMstr.szMpjLastRealUpdate),
                            pfMpj) )
                {
                    WORD  wPriID = 0;
                    WORD  wSubID = 0;
                    UINT  uTmpCP = 0;

                                //... Strip any trailing new-lines from data

                    StripNewLineA( gMstr.szSrc);
                    StripNewLineA( gMstr.szMpjLastRealUpdate);
                    StripNewLineA( gMstr.szMtk);
                    StripNewLineA( gMstr.szRdfs);
                    StripNewLineA( gMstr.szSrcDate);

                                //... Try to get the.MPJ file's Language line.
                                //... If we find it and the -i arg was not
                                //... given, use the one found in the file.

                    if ( fgets( szDHW, DHWSIZE, pfMpj) != NULL //... CP line
                      && sscanf( szDHW, "Language %hx %hx", &wPriID, &wSubID) == 2 )
                    {
                        WORD  wTmpID = 0;

                        wTmpID = MAKELANGID( wPriID, wSubID);

                        if ( ! fLanguageGiven )
                        {
                            gMstr.wLanguageID = wTmpID;
                        }
                    }
                                //... Try to get the.MPJ file's Code Page line.
                                //... If we find it and the -p arg was not
                                //... given, use the one found in the file.

                    if ( fgets( szDHW, DHWSIZE, pfMpj) != NULL //... CP line
                      && sscanf( szDHW, "CodePage %u", &uTmpCP) == 1 )
                    {
                        if ( uTmpCP != gProj.uCodePage && ! fCodePageGiven )
                        {
                            gMstr.uCodePage = uTmpCP;
                        }
                    }
                    nRC = SUCCESS;
                }
                else
                {
                    ShowErr( IDS_ERR_21,
                             "Master Project",
                             pszMasterFile);
                    nRC = IDS_ERR_21;
                }
            }
            else
            {
                ShowErr( IDS_ERR_22, pszMasterFile, NULL);
                nRC = IDS_ERR_22;
            }
            fclose( pfMpj);
        }
    }
    return( nRC);
}

//............................................................

int PutMasterProjectData(

CHAR *pszMasterFile)    //... Master Project File name
{
    int   nRC   = SUCCESS;
    FILE *pfMpj = NULL;


    if ( (pfMpj = fopen( pszMasterFile, "wt")) == NULL )
    {
        ShowErr( IDS_ERR_06, pszMasterFile, NULL);
        nRC = -1;
    }
    else
    {
        fprintf( pfMpj, "%s\n%s\n%s\n%s\n%s\nLanguage %#04hx %#04hx\nCodePage %u",
                        gMstr.szSrc,
                        gMstr.szMtk,
                        gMstr.szRdfs,
                        gMstr.szSrcDate,
                        gMstr.szMpjLastRealUpdate,
                        PRIMARYLANGID( gMstr.wLanguageID),
                        SUBLANGID( gMstr.wLanguageID),
                        gMstr.uCodePage);

        fclose( pfMpj);
    }
    return( nRC);
}


//............................................................

int GetProjectData(

CHAR *pszPrj,       //... Project file name
CHAR *pszMpj,       //... Master Project file name or NULL
CHAR *pszTok,       //... Project token file name or NULL
BOOL  fCodePageGiven,
BOOL  fLanguageGiven)
{
    int nRC     = SUCCESS;
	int	iUpdate = 0;


    if ( _access( pszPrj, 0) != 0 )
    {
        if ( ! (pszMpj && pszTok) )
        {
            ShowErr( IDS_ERR_19, pszPrj, NULL);
            Usage();
            nRC = IDS_ERR_19;
        }
        else if ( ! fLanguageGiven )
        {
            ShowErr( IDS_ERR_24, pszPrj, NULL);
            Usage();
            nRC = IDS_ERR_24;
        }
        else
        {
            if ( _fullpath( gProj.szMpj,
                            pszMpj,
                            sizeof( gProj.szMpj)-1) )
            {
                if ( _fullpath( gProj.szTok,
                                pszTok,
                                sizeof( gProj.szTok)-1) )
                {
                    nRC = SUCCESS;
                }
                else
                {
                    ShowErr( IDS_ERR_13, pszTok, NULL);
                    nRC = IDS_ERR_13;
                }
            }
            else
            {
                ShowErr( IDS_ERR_13, pszMpj, NULL);
                nRC = IDS_ERR_13;
            }
        }
    }
    else
    {
        FILE *fpPrj = fopen( pszPrj, "rt");

        if ( fpPrj != NULL )
        {
            if ( fgets( gProj.szMpj,     sizeof( gProj.szMpj),     fpPrj)
              && fgets( gProj.szTok,     sizeof( gProj.szTok),     fpPrj)
              && fgets( gProj.szGlo,     sizeof( gProj.szGlo),     fpPrj)
              && fgets( gProj.szTokDate, sizeof( gProj.szTokDate), fpPrj) )
            {
                UINT  uTmpCP = 0;
                WORD  wPriID = 0;
                WORD  wSubID = 0;
								//... If named, make sure MPJ and TOK files exist
                if ( pszMpj )
                {
				    if ( !_fullpath( gProj.szMpj, pszMpj, sizeof( gProj.szMpj)-1) )
					{
                        ShowErr( IDS_ERR_21, pszMpj, NULL);
                        fclose( fpPrj );
						return( IDS_ERR_21);
                     }
				}

                if ( pszTok )
                {
                    if ( !_fullpath( gProj.szTok, pszTok, sizeof( gProj.szTok)-1) )
					{
                        ShowErr( IDS_ERR_21, pszTok, NULL);
                        fclose( fpPrj );
						return( IDS_ERR_21);
                    }
				}

                StripNewLineA( gProj.szMpj);
                StripNewLineA( gProj.szTok);
                StripNewLineA( gProj.szGlo);
                StripNewLineA( gProj.szTokDate);

                                //... Try to get the.PRJ file's Code Page line.
                                //... If we find it and the -p arg was not
                                //... given, use the one found in the file.

                if ( ! fgets( szDHW, DHWSIZE, fpPrj) )	//... CP line
				{
					iUpdate++;
				}
				else if ( sscanf( szDHW, "CodePage %u", &uTmpCP) == 1 )
                {
                    if ( uTmpCP != gProj.uCodePage && ! fCodePageGiven )
                    {
                        gProj.uCodePage = uTmpCP;
                    }
                }
                                //... Try to get the.PRJ file's Language line.
                                //... If we find it and the -i arg was not
                                //... given, use the one found in the file.

                if ( ! fgets( szDHW, DHWSIZE, fpPrj) ) //... LANGID line
				{
					iUpdate++;
				}
				else if ( sscanf( szDHW, "Language %hx %hx", &wPriID, &wSubID) == 2 )
                {
                    WORD  wTmpID = 0;

                    wTmpID = MAKELANGID( wPriID, wSubID);

                    if ( ! fLanguageGiven )
                    {
                        gProj.wLanguageID = wTmpID;
                    }
                }
                                //... Try to get the.PRJ file's Target File line

                if ( fgets( szDHW, DHWSIZE, fpPrj) != NULL )
                {
                    lstrcpyA( gProj.szBld, szDHW);
                    StripNewLineA( gProj.szBld);
                }
                                //... Try to get the.PRJ file's append/replace line

                if ( fgets( szDHW, DHWSIZE, fpPrj) != NULL )
                {
                    gfReplace = (*szDHW == 'R') ? TRUE : FALSE;
                }
                else
                {
                    gfReplace = TRUE;
                }
                nRC = SUCCESS;

				if ( iUpdate )
				{
					static TCHAR title[50];
					static TCHAR szMes[100];

					if ( bRLGui )
					{
								//Ask Update prj for 1.7? //RLadmin RLedit RLquiked

						LoadString( NULL,
									IDS_UPDATE_YESNO,
									szMes,
									TCHARSIN( sizeof( szMes)) );
						LoadString( NULL,
									IDS_UPDATE_TITLE,
									title,
									TCHARSIN( sizeof( title)) );
						
						if ( MessageBox( hMainWnd,
										 szMes,title,
										 MB_ICONQUESTION|MB_YESNO) == IDNO )
						{
								//User says no, then finish the job.
							LoadString( NULL,
										IDS_UPDATE_CANCEL,
										szMes,
										TCHARSIN( sizeof( szMes)) );
											
							MessageBox( hMainWnd,
										szMes,
										title,
										MB_ICONSTOP|MB_OK);
								//bye!
							nRC = IDS_UPDATE_CANCEL;
						}
						else
						{
								//replace Glossary <=> Bins
  	    	          		lstrcpyA( szDHW, gProj.szGlo );
							lstrcpyA( gProj.szGlo, gProj.szBld );
							lstrcpyA( gProj.szBld, szDHW );
						}
					}
					else		//For RLMan
					{
								//Update Message
						RLMessageBoxA( "Updating 1.0 files..." );
								//replace Glossary <=> Bins
              			lstrcpyA( szDHW, gProj.szGlo );
						lstrcpyA( gProj.szGlo, gProj.szBld );
						lstrcpyA( gProj.szBld, szDHW );
					}
				}
            }
            else
            {
                ShowErr( IDS_ERR_21, pszPrj, NULL);
                nRC = IDS_ERR_21;
            }
            fclose( fpPrj);
        }
        else
        {
            ShowErr( IDS_ERR_19, pszPrj, NULL);
            nRC = IDS_ERR_19;
        }
    }
    return( nRC);
}

//............................................................

int PutProjectData(

CHAR *pszPrj)       //... Project file name
{
    int   nRC   = 0;
    FILE *fpPrj = NULL;


    fpPrj = fopen( pszPrj, "wt");

    if ( fpPrj != NULL )
    {
        fprintf( fpPrj,
                 "%s\n%s\n%s\n%s\nCodePage %u\nLanguage %#04x %#04x\n%s\n%s",
                 gProj.szMpj,                       // Master Project file
                 gProj.szTok,                       // Project Token file
                 gProj.szGlo,                       // Project Glossary file
                 gProj.szTokDate,                   // Date token file changed
                 gProj.uCodePage,                   // Code Page of token file
                 PRIMARYLANGID( gProj.wLanguageID), // Project resource language
                 SUBLANGID( gProj.wLanguageID),
                 gProj.szBld,                       // Project target file
                 gfReplace ? "Replace" : "Append"); // Replace master lang?

        fclose( fpPrj);

        _fullpath( gProj.szPRJ, pszPrj, sizeof( gProj.szPRJ)-1);
    }
    else
    {
        ShowErr( IDS_ERR_21, pszPrj, NULL);
        nRC = IDS_ERR_21;
    }
    return( nRC);
}

//............................................................

WORD GetCopyright(

CHAR *pszProg,      //... Program name (argv[0])
CHAR *pszOutBuf,    //... Buffer for results
WORD  wBufLen)      //... Length of pszOutBuf
{
    BOOL    fRC       = FALSE;
    DWORD   dwRC      = 0L;
    DWORD   dwVerSize = 0L;         //... Size of file version info buffer
    LPSTR  *plpszFile = NULL;
    LPSTR   pszExt    = NULL;
    WCHAR  *pszVer    = NULL;
    PVOID   lpVerBuf  = NULL;       //... Version info buffer
    static CHAR  szFile[  MAXFILENAME+3] = "";

                                //... Figure out the full-path name of prog
                                //... so GetFileVersionInfoSize() will work.

    dwRC = lstrlenA( pszProg);

    if ( dwRC < 4 || lstrcmpiA( &pszProg[ dwRC - 4], ".exe") != 0 )
    {
        pszExt = ".exe";
    }

    dwRC = SearchPathA( NULL, pszProg, pszExt, sizeof( szFile), szFile, plpszFile);

    if ( dwRC == 0 )
    {
        return( IDS_ERR_25);
    }
    else if ( dwRC > sizeof( szFile) )
    {
        return( IDS_ERR_27);
    }

    // append the extension since SearchPath will not return it
    // if we have no extensio then a directory with the same name was returned
    // try to append the ext and hope that file will be there
    if ( lstrcmpiA( &szFile[dwRC - 4], ".exe") != 0 )
    {
        lstrcatA( szFile, pszExt );
    }


    //... Get # bytes in file version info

    if ( (dwVerSize = GetFileVersionInfoSizeA( szFile, &dwRC)) == 0L )
    {
        return( IDS_ERR_26);
    }
    lpVerBuf = (LPVOID)FALLOC( dwVerSize);

                                //... Retrieve version info
                                //... and get the file description

    if ( (dwRC = GetFileVersionInfoA( szFile, 0L, dwVerSize, lpVerBuf)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }

    if ( (fRC = MyVerQueryValue( lpVerBuf,
                               TEXT("FileDescription"),
                               &pszVer,
                               &dwVerSize)) == FALSE
      || (dwRC = WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszVer,
                                      dwVerSize,
                                      pszOutBuf,
                                      dwVerSize,
                                      NULL,
                                      NULL)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }

    strcat( pszOutBuf, " ");

                                //... Get the file version

    if ( (fRC = MyVerQueryValue( lpVerBuf,
                                 TEXT("ProductVersion"),
                                 &pszVer,
                                 &dwVerSize)) == FALSE
    || (dwRC = WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszVer,
                                      dwVerSize,
                                      &pszOutBuf[ lstrlenA( pszOutBuf)],
                                      dwVerSize,
                                      NULL,
                                      NULL)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }

    strcat( pszOutBuf, "\n");

                                //... Get the copyright statement

    if ( (fRC = MyVerQueryValue( lpVerBuf,
                                 TEXT("LegalCopyright"),
                                 &pszVer,
                                 &dwVerSize)) == FALSE
      || (dwRC = WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszVer,
                                      dwVerSize,
                                      &pszOutBuf[ lstrlenA( pszOutBuf)],
                                      dwVerSize,
                                      NULL,
                                      NULL)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }
    RLFREE( lpVerBuf);
    return( SUCCESS);
}

//............................................................

WORD GetInternalName(

CHAR *pszProg,      //... Program name (argv[0])
CHAR *pszOutBuf,    //... Buffer for results
WORD  wBufLen)      //... Length of pszOutBuf
{
    BOOL    fRC       = FALSE;
    DWORD   dwRC      = 0L;
    DWORD   dwVerSize = 0L;         //... Size of file version info buffer
    LPSTR  *plpszFile = NULL;
    LPSTR   pszExt    = NULL;
    WCHAR  *pszVer    = NULL;
    PVOID   lpVerBuf  = NULL;       //... Version info buffer
    static CHAR  szFile[  MAXFILENAME+3] = "";

                                //... Figure out the full-path name of prog
                                //... so GetFileVersionInfoSize() will work.

    dwRC = lstrlenA( pszProg);

    if ( dwRC < 4 || lstrcmpiA( &pszProg[ dwRC - 4], ".exe") != 0 )
    {
        pszExt = ".exe";
    }

    dwRC = SearchPathA( NULL, pszProg, pszExt, sizeof( szFile), szFile, plpszFile);

    if ( dwRC == 0 )
    {
        return( IDS_ERR_25);
    }
    else if ( dwRC > sizeof( szFile) )
    {
        return( IDS_ERR_27);
    }

                                //... Get # bytes in file version info

    if ( (dwVerSize = GetFileVersionInfoSizeA( szFile, &dwVerSize)) == 0L )
    {
        return( IDS_ERR_26);
    }
    lpVerBuf = (LPVOID)FALLOC( dwVerSize);

                               //... Retrieve version info
                                //... and get the file description

    if ( (dwRC = GetFileVersionInfoA( szFile, 0L, dwVerSize, lpVerBuf)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }

    if ( (fRC = MyVerQueryValue( lpVerBuf,
                                 TEXT("InternalName"),
                                 &pszVer,
                                 &dwVerSize)) == FALSE
      || (dwRC = WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszVer,
                                      dwVerSize,
                                      pszOutBuf,
                                      dwVerSize,
                                      NULL,
                                      NULL)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }
    RLFREE( lpVerBuf);
    return( SUCCESS);
}


//............................................................

int MyAtoi( CHAR *pStr)
{
    if ( lstrlenA( pStr) > 2
      && pStr[0] == '0'
      && tolower( pStr[1]) == 'x' )
    {
        return( atoihex( &pStr[2]));    //... in custres.c
    }
    else
    {
        return( atoi( pStr));
    }
}



//DWORD GetLanguageID( HWND hDlg, PMSTRDATA pMaster, PPROJDATA pProject)
//{
//    DWORD dwRC = SUCCESS;       //... Assume success
//    WORD wPriLangID = 0;
//    WORD wSubLangID = 0;
//
//
//    if ( pMaster )
//    {
//        GetDlgItemTextA( hDlg, IDD_PRI_LANG_ID, szDHW, DHWSIZE);
//        wPriLangID = MyAtoi( szDHW);
//
//        GetDlgItemTextA( hDlg, IDD_SUB_LANG_ID, szDHW, DHWSIZE);
//        wSubLangID = MyAtoi( szDHW);
//
//        pMaster->wLanguageID = MAKELANGID( wPriLangID, wSubLangID);
//    }
//
//    if ( pProject )
//    {
//        GetDlgItemTextA( hDlg, IDD_PROJ_PRI_LANG_ID, szDHW, DHWSIZE);
//        wPriLangID = MyAtoi( szDHW);
//
//        GetDlgItemTextA( hDlg, IDD_PROJ_SUB_LANG_ID, szDHW, DHWSIZE);
//        wSubLangID = MyAtoi( szDHW);
//
//        pProject->wLanguageID = MAKELANGID( wPriLangID, wSubLangID);
//    }
//    return( dwRC);
//}

//.................................................................
//... Set the language component names into the dlg box fields
//
//DWORD SetLanguageID( HWND hDlg, PMSTRDATA pMaster, PPROJDATA pProject)
//{
//    DWORD  dwRC = SUCCESS;      //... Assume success
//    WORD   wPriLangID  = 0;
//    WORD   wSubLangID  = 0;
//    LPTSTR pszLangName = NULL;
//
//                                //... Did we already load the data from
//                                //... the resources? If not, do so now.
//    if ( ! pLangList )
//    {
//        pLangList = GetLangList();
//    }
//
//    if ( pMaster )
//    {
//        wPriLangID = PRIMARYLANGID( pMaster->wLanguageID);
//        wSubLangID = SUBLANGID(     pMaster->wLanguageID);
//
//        if ( (pszLangName = GetLangName( wPriLangID, wSubLangID)) )
//        {
//            SetDlgItemText( hDlg, IDD_MSTR_LANG_NAME, pszLangName);
//        }
//        sprintf( szDHW, "%#04x", wPriLangID);
//        SetDlgItemTextA( hDlg, IDD_PRI_LANG_ID, szDHW);
//
//        sprintf( szDHW, "%#04x", wSubLangID);
//        SetDlgItemTextA( hDlg, IDD_SUB_LANG_ID, szDHW);
//    }
//
//    if ( pProject )
//    {
//        wPriLangID = PRIMARYLANGID( pProject->wLanguageID);
//        wSubLangID = SUBLANGID(     pProject->wLanguageID);
//
//        if ( (pszLangName = GetLangName( wPriLangID, wSubLangID)) )
//        {
//            SetDlgItemText( hDlg, IDD_PROJ_LANG_NAME, pszLangName);
//        }
//        sprintf( szDHW, "%#04x", wPriLangID);
//        SetDlgItemTextA( hDlg, IDD_PROJ_PRI_LANG_ID, szDHW);
//
//        sprintf( szDHW, "%#04x", wSubLangID);
//        SetDlgItemTextA( hDlg, IDD_PROJ_SUB_LANG_ID, szDHW);
//    }
//    return( dwRC);
//}

//...............................................................
//...
//... Build the list of Language names and component ID values

PLANGDATA GetLangList( void)
{
    PLANGDATA pRC = NULL;
    HRSRC hResource = FindResourceEx( NULL,
                                      (LPCTSTR)RT_RCDATA,
                                      (LPCTSTR)ID_LANGID_LIST,
                                      MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL));

    if ( hResource )
    {
        HGLOBAL hRes = LoadResource( NULL, hResource);

        if ( hRes )
        {
            PBYTE pRes = (PBYTE)LockResource( hRes);

            if ( pRes )
            {
                int nNameLen   = 0;
                PLANGDATA pTmp = NULL;

                nNameLen = lstrlenA( (LPSTR)pRes);
                pRC  = (PLANGDATA)FALLOC( sizeof( LANGDATA));
                pTmp = pRC;

                while ( nNameLen )
                {
                    MultiByteToWideChar( CP_ACP,
                                         MB_PRECOMPOSED,
                                         (LPSTR)pRes,
                                         -1,
                                         pTmp->szLangName,
                                         NAMELENBUFSIZE - 1);
                    pRes += ++nNameLen;

                    pTmp->wPriLang = MAKEWORD( *pRes, *(pRes+1) );
                    pRes += sizeof(WORD);
                    pTmp->wSubLang = MAKEWORD( *pRes, *(pRes+1) );
                    pRes += sizeof(WORD);

                    if ( (nNameLen = lstrlenA( (LPSTR)pRes)) )
                    {
                        PLANGDATA pNew = (PLANGDATA)FALLOC( sizeof( LANGDATA));
                        pTmp->pNext = pNew;
                        pTmp = pNew;
                    }
                }       //... END while( nNameLen )
            }           //... END if ( pRes )
            else
            {
                DWORD dwErr = GetLastError();
            }
        }               //... END if ( hRes )
        else
        {
            DWORD dwErr = GetLastError();
        }
    }                   //... END if ( hSrc )
    else
    {
        DWORD dwErr = GetLastError();
    }
    return( pRC);
}


//...............................................................
//...
//... Return the name of a language based on the given components

LPTSTR GetLangName( WORD wPriLangID, WORD wSubLangID)
{
    LPTSTR    pszRC = NULL;
    PLANGDATA pLang = NULL;

    if ( ! pLangList )
    {
        pLangList = GetLangList();
    }

    for ( pLang = pLangList; pLang && ! pszRC; pLang = pLang->pNext )
    {
        if ( pLang->wPriLang == wPriLangID && pLang->wSubLang == wSubLangID )
        {
            pszRC = pLang->szLangName;
        }
    }
    return( pszRC);
}

//...............................................................
//...
//... Return the language ID components based on the given name

BOOL GetLangIDs( LPTSTR pszName, PWORD pwPri, PWORD pwSub )
{
    BOOL fRC = FALSE;
    PLANGDATA pLang = NULL;

    if ( ! pLangList )
    {
        pLangList = GetLangList();
    }

    for ( pLang = pLangList; pLang && ! fRC; pLang = pLang->pNext )
    {
        if ( lstrcmp( pLang->szLangName, pszName) == 0 )
        {
            *pwPri = pLang->wPriLang;
            *pwSub = pLang->wSubLang;

            fRC = TRUE;
        }
    }
    return( fRC);
}


//...............................................................
//...
//... Fill the given combobox with the names of supported the languages.

LONG FillLangNameBox( HWND hDlg, int nControl)
{
    PLANGDATA pLang = NULL;
    PLANGLIST pID   = NULL;
    LONG lRC = -1;
    BOOL fListIt = TRUE;
    WORD wAddLang = 0;


    if ( nControl == IDD_MSTR_LANG_NAME )
    {
        if ( GetListOfResLangIDs( gMstr.szSrc) != SUCCESS )
        {
            return( lRC);
        }
    }

    if ( ! pLangList )
    {
        pLangList = GetLangList();
    }

    for ( pLang = pLangList; pLang; pLang = pLang->pNext )
    {
        fListIt = TRUE;

        if ( nControl == IDD_MSTR_LANG_NAME )
        {
            wAddLang = MAKELANGID( pLang->wPriLang, pLang->wSubLang);

            fListIt = FALSE;

            for ( pID = pLangIDList; pID; pID = pID->pNext )
            {
                if ( pID->wLang == wAddLang )
                {
                    fListIt = TRUE;
                    break;
                }
            }
        }

        if ( fListIt )
        {
            lRC = (LONG)SendDlgItemMessage( hDlg,
                                      nControl,
                                      CB_ADDSTRING,
                                      0,
                                      (LPARAM)pLang->szLangName);

            if ( lRC == CB_ERR || lRC == CB_ERRSPACE )
            {
                QuitT( IDS_ERR_16, NULL, NULL);
            }
        }
    }

    if ( nControl == IDD_MSTR_LANG_NAME )
    {
        FreeLangIDList();
    }
    return( lRC);
}


void FreeLangList( void)
{
    PLANGDATA pTmp = NULL;

    while ( pLangList )
    {
        pTmp = pLangList->pNext;
        RLFREE( pLangList);
        pLangList = pTmp;
    }

#ifdef RLRES32

    FreeLangIDList();

#endif

}


//...................................................................

void FillListAndSetLang(

HWND  hDlg,
WORD  wLangNameList,    //... IDD_MSTR_LANG_NAME or IDD_PROJ_LANG_NAME
WORD *pLangID,          //... Ptr to gMstr.wLanguageID or gProj.wLanguageID
BOOL *pfSelected)       //... Did we select a language here? (Can be NULL)
{
    int nSel =  FillLangNameBox( hDlg, wLangNameList);

    if ( nSel > 0L )
    {
        LPTSTR pszLangName = NULL;
                                //... See if the default master language is in the list

        if ( (pszLangName = GetLangName( (WORD)(PRIMARYLANGID( *pLangID)),
                                         (WORD)(SUBLANGID( *pLangID)))) != NULL )
        {
            if ( (nSel = (int)SendDlgItemMessage( hDlg,
                                             wLangNameList,
                                             CB_FINDSTRINGEXACT,
                                             (WPARAM)-1,
                                             (LPARAM)pszLangName)) != CB_ERR )
            {
                                //... default master language is in  list

                SendDlgItemMessage( hDlg,
                                    wLangNameList,
                                    CB_SETCURSEL,
                                    (WPARAM)nSel,
                                    (LPARAM)0);

                if ( pfSelected )
                {
                    *pfSelected = TRUE;
                }
            }
        }
    }
    else if ( nSel == 0 )
    {
                                //... Use first entry in the list

        SendDlgItemMessage( hDlg,
                            wLangNameList,
                            CB_SETCURSEL,
                            (WPARAM)nSel,
                            (LPARAM)0);

        if ( (nSel = (int)SendDlgItemMessage( hDlg,
                                         wLangNameList,
                                         CB_GETLBTEXT,
                                         (WPARAM)nSel,
                                         (LPARAM)(LPTSTR)szDHW)) != CB_ERR )
        {
            WORD wPri = 0;
            WORD wSub = 0;

            if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) )
            {
                *pLangID   = MAKELANGID( wPri, wSub);

                if ( pfSelected )
                {
                    *pfSelected = TRUE;
                }
            }
            else
            {
                nSel = CB_ERR;
            }
        }
    }

    if ( nSel == CB_ERR )
    {
        SetDlgItemText( hDlg, wLangNameList, TEXT("UNKNOWN"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\resourc2.h ===
#ifndef _RESOURC2_H_
#define _RESOURC2_H_

#define IDC_STATIC           -1

// DIALOG ID's
#define IDD_TOKFILE         101
#define IDD_RESFILE         102
#define IDD_BROWSE          103
#define IDD_EXEFILE         104

#define IDD_INRESFILE       202
#define IDD_OUTRESFILE      203

#define IDD_TOKEDIT         500
#define IDD_TOKTYPE         505
#define IDD_TOKNAME         506
#define IDD_TOKID           507
#define IDD_TOKTEXT         508

#define IDD_TOKCURTRANS     509
#define IDD_TOKPREVTRANS    510
#define IDD_TOKCURTEXT      511
#define IDD_TOKPREVTEXT     512
#define IDD_ADD             513
#define IDD_SKIP            514
#define IDD_STATUS          515
#define IDD_TRANSLATE       516
#define IDD_UNTRANSLATE     517

#define IDD_TRANSTOK        610
#define IDD_TRANSGLOSS      620

#define IDD_TYPELST         700
#define IDD_READONLY        703
#define IDD_CHANGED         704
#define IDD_DIRTY           705

#define IDD_FINDTOK         710
#define IDD_FINDUP          711
#define IDD_FINDDOWN        712


#define IDD_SOURCERES       110
#define IDD_MTK             111
#define IDD_RDFS            112
#define IDD_MPJ             113
#define IDD_TOK             114
#define IDD_BUILTRES        115
#define IDD_GLOSS           116

#define IDD_PROJ_PRI_LANG_ID 130
#define IDD_PROJ_SUB_LANG_ID 131
#define IDD_PROJ_TOK_CP     132

#define IDD_PRI_LANG_ID     133
#define IDD_SUB_LANG_ID     134
#define IDD_TOK_CP          135
#define IDD_MSTR_LANG_NAME  136
#define IDD_PROJ_LANG_NAME  137

#define IDD_VIEW_SOURCERES  206
#define IDD_VIEW_MTK        207
#define IDD_VIEW_RDFS       208
#define IDD_VIEW_MPJ        209
#define IDD_VIEW_TOK        210
#define IDD_VIEW_TARGETRES  211
#define IDD_VIEW_GLOSSTRANS 212

#define IDD_LANGUAGES       300
#define IDC_REPLACE         301
#define IDC_APPEND          302

// MENU ID's
#define IDM_PROJECT         1000
#define IDM_P_NEW           1050
#define IDM_P_OPEN          1100
#define IDM_P_VIEW          1112
#define IDM_P_EDIT          1114
#define IDM_P_CLOSE         1125
#define IDM_P_SAVE          1150
#define IDM_P_SAVEAS        1200
#define IDM_P_EXIT          1250

#define IDM_EDIT            2000
#define IDM_E_COPYTOKEN     2050
#define IDM_E_COPY          2060
#define IDM_E_PASTE         2070
#define IDM_E_FIND          2090
#define IDM_E_FINDDOWN      2091
#define IDM_E_FINDUP        2092
#define IDM_E_REVIEW        2100
#define IDM_E_ALLREVIEW     2101

#define IDM_OPERATIONS      3000
#define IDM_O_UPDATE        3010
#define IDM_O_GENERATE      3020

#define IDM_G_GLOSS         3050

// 3100-3109 are reserved by RLEDIT for resource editing tools.
// A resource is given a menu item that passes this value for it's
// command parameter.  A corresponding string must exist in the string
// table indicating the name of the editer to be invoked.
//
// When the user selects the menu item, it generates the appropriate command.
// When RLEDIT recieves a command in the IDM_FIRST_EDIT and IDM_LAST_EDIT range
// it saves all the tokens and builds a temporary resource file.
// RLEDIT then retrieves the name of the editer from the string table and
// performs a WinExec command on the temporary resource file.
// When control is returned to RLEDIT (the user closes the resource editor)
// the token file is rebuilt from the edited resource file, the temporary
// resource file is deleted, and the tokens are loaded back into the system.

#define IDM_FIRST_EDIT      3100
#define IDM_LAST_EDIT       3109

#define IDM_HELP            4000
#define IDM_H_CONTENTS      4010
#define IDM_H_ABOUT         4030

// Control IDs
#define IDC_EDIT            401
#define IDC_LIST            402
#define IDC_COPYRIGHT       403

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        7001
#define _APS_NEXT_COMMAND_VALUE         6001
#define _APS_NEXT_CONTROL_VALUE         5001
#define _APS_NEXT_SYMED_VALUE           8001
#endif
#endif


#endif // _RESOURC2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\projdata.h ===
#ifndef _PROJDATA_H_
#define _PROJDATA_H_

#define NAMELENBUFSIZE 32

typedef struct _tagLangData
{
    struct _tagLangData * pNext;
    WORD   wPriLang;
    WORD   wSubLang;
    TCHAR  szLangName[ NAMELENBUFSIZE];
} LANGDATA, * PLANGDATA;        

int MyAtoi( CHAR *pStr);

int GetMasterProjectData(
        CHAR * pszMasterFile,   //... Master Project file name
        CHAR * pszSrc,          //... Resource source file name or NULL
        CHAR * pszMtk,          //... Master token file name or NULL
        BOOL   fLanguageGiven);

int PutMasterProjectData(
        CHAR *pszMasterFile);   //... Master Project File name

int GetProjectData(
        CHAR *pszPrj,           //... Project file name
        CHAR *pszMpj,           //... Master Project file name or NULL
        CHAR *pszTok,           //... Project token file name or NULL
        BOOL  fCodePageGiven,
        BOOL  fLanguageGiven);

int PutProjectData(
        CHAR *pszPrj);          //... Project file name

WORD GetCopyright(
        CHAR *pszProg,          //... Program name
        CHAR *pszOutBuf,        //... Buffer for results
        WORD  wBufLen);         //... Length of pszOutBuf

WORD GetInternalName(
        CHAR *pszProg,          //... Program name
        CHAR *pszOutBuf,        //... Buffer for results
        WORD  wBufLen);         //... Length of pszOutBuf

//DWORD GetLanguageID( HWND hDlg, PMSTRDATA pMaster, PPROJDATA pProject);
//DWORD SetLanguageID( HWND hDlg, PMSTRDATA pMaster, PPROJDATA pProject);

LPTSTR    GetLangName( WORD wPriLangID, WORD wSubLangID);
PLANGDATA GetLangList( void);    
BOOL      GetLangIDs( LPTSTR pszName, PWORD pwPri, PWORD pwSub);
LONG      FillLangNameBox( HWND hDlg, int nControl);
void      FreeLangList( void);

void FillListAndSetLang( 
    HWND  hDlg,
    WORD  wLangNameList,    //... IDD_MSTR_LANG_NAME or IDD_PROJ_LANG_NAME
    WORD *pLangID,          //... Ptr to gMstr.wLanguageID or gProj.wLanguageID
    BOOL *pfSelected);      //... Did we select a language here? (Can be NULL)

#endif // _PROJDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\ntmsgtbl.c ===
//.....................................................................
//...
//... NTMSGTBL.C
//...
//... Contains functions for handling strings found in NT's Message
//... Resource Tables.  This recource type is not present in Win 3.1.
//...
//... Author - David Wilcox (davewi@microsoft)
//...
//... NOTES:  Created with tabstop set to 8
//...
//.....................................................................
//...
//... History:
//... Original - 10/92
//...            11/92 - Fixed to handle ULONG msg ID#'s - davewi
//...
//.....................................................................

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windef.h>
#include <tchar.h>
#include <winver.h>

#include "windefs.h"
#include "restok.h"
#include "custres.h"
#include "ntmsgtbl.h"
#include "resread.h"


typedef PMESSAGE_RESOURCE_ENTRY PMRE;

extern BOOL  gbMaster;
extern UCHAR szDHW[];

static PBYTE *pBlockEntries = NULL;

VOID  *pResMsgData = NULL;      // NT-specific Message Table resource


//.........................................................................
//...
//... Get Message Table from .res file
//...
//... This form of a message table, not found in Win 16, allows very long
//... strings and the text is stored as an ASCIIZ string in the .res file.


VOID *GetResMessage(

FILE  *pInResFile,      //... The file containing the resources
DWORD *plSize)          //... The size of this resource from GetResHeader
{
    ULONG  ulNumBlocks = 0L;            //... # of Message Table resource blocks
    ULONG  ulStartMsgDataPos = 0L;      //... Start of message data in file
    ULONG  ulBlock;                     //... Current message block number
    USHORT usCurrBlockSize  = 0;        //... Current size of temp block buffer
    USHORT usDeltaBlockSize = 4096;     //... Amount to increase usCurrBlockSize
    DWORD  dwNumMsgs = 0;               //... Count of msgs in the resource
    PBYTE  pMsgBlock = NULL;            //... Temp message block buffer

    PMESSAGE_RESOURCE_DATA  pMsgResData;//... Returned as ptr to the resource
    PMESSAGE_RESOURCE_BLOCK pMRB;       //... ptr to a block of messages



                                //... The resource header was read prior to
                                //... entring this function, so the current
                                //... file position should now be the start
                                //... of the resource data.

    ulStartMsgDataPos = ftell( pInResFile);

                                //... Get the number of message blocks and
                                //... allocate enough memory for the array.

    ulNumBlocks = GetdWord( pInResFile, plSize);

                                //... Allocate space for the array of
                                //... pointers to entries.  This array is used
                                //... to store pointers to the first entry
                                //... in each block of message entries.

    pBlockEntries = (PBYTE *)FALLOC( ulNumBlocks * sizeof( PBYTE));

    if ( ! pBlockEntries )
    {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }

    pMsgResData = (PMESSAGE_RESOURCE_DATA)FALLOC( sizeof( ULONG) + ulNumBlocks
                                                   * sizeof( MESSAGE_RESOURCE_BLOCK));

    if ( ! pMsgResData )
    {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }
    pResMsgData = pMsgResData;
    pMsgResData->NumberOfBlocks = ulNumBlocks;

                                //... Read the array of message block structs,
                                //... and initialize block entry pointer array.

    for ( ulBlock = 0L, pMRB = pMsgResData->Blocks;
          ulBlock < ulNumBlocks;
          ++ulBlock, ++pMRB )
    {
        pMRB->LowId           = GetdWord( pInResFile, plSize);
        pMRB->HighId          = GetdWord( pInResFile, plSize);
        pMRB->OffsetToEntries = GetdWord( pInResFile, plSize);

        if ( pMRB->HighId < pMRB->LowId )
        {
            ClearResMsg( &pResMsgData);
            QuitT( IDS_ENGERR_16, (LPTSTR)IDS_INVMSGRNG, NULL);
        }
        dwNumMsgs += (pMRB->HighId - pMRB->LowId + 1);

        pBlockEntries[ ulBlock] = NULL;
    }

                                //... Read in the MESSAGE_RESOURCE_ENTRY

    usCurrBlockSize = usDeltaBlockSize;

    for ( ulBlock = 0L, pMRB = pMsgResData->Blocks;
          ulBlock < ulNumBlocks;
          ++ulBlock, ++pMRB )
    {
        ULONG   ulCurrID;       //... Current message ID # in this block
        ULONG   ulEndID;        //... Last message ID # in this block + 1
        USHORT  usLen;          //... For length of a message - MUST BE USHORT
        USHORT  usMsgBlkLen;    //... Length of a block of messages


        usMsgBlkLen = 0;

                                //... Move to start of block of message entries
                                //... then read all the messages in this block.

        fseek( pInResFile,
               ulStartMsgDataPos + pMRB->OffsetToEntries,
               SEEK_SET);

        for ( ulCurrID = pMRB->LowId, ulEndID = pMRB->HighId + 1;
              ulCurrID < ulEndID;
              ++ulCurrID, --dwNumMsgs )
        {
                                //... Get Msg Resource entry length
                                //... (Length is in bytes and includes
                                //...  .Length and .Flags fields and any
                                //...  padding that may exist after the text.)

            usLen = GetWord( pInResFile, plSize);

            if ( usLen >= 2 * sizeof( USHORT) )
            {
                PMRE   pMRE;
                PUCHAR puchText;

                                //... Create, or expand size of, pMsgBlkData
                                //... so we can append this entry.
                                //... Always resave ptr to the message block
                                //... (it may have moved).

                if ( pMsgBlock )
                {
                    if ( (USHORT)(usMsgBlkLen + usLen) > usCurrBlockSize )
                    {
                        usCurrBlockSize += __max(usDeltaBlockSize, (USHORT)(usMsgBlkLen + usLen));
                        pMsgBlock = (PBYTE)FREALLOC( pMsgBlock,
                                                      usCurrBlockSize);
                    }
                }
                else
                {
                    pMsgBlock = FALLOC( usCurrBlockSize);
                }

                                //... If the malloc worked, read this msg entry.
                                //... The section assumes there is one WORD
                                //... per USHORT and one WORD per WCHAR.

                pMRE = (PMRE)(pMsgBlock + usMsgBlkLen);

                                //... Store the .Length field value (USHORT)

                pMRE->Length = usLen;
                usMsgBlkLen += usLen;

                                //... Get the .Flags field value (USHORT)

                pMRE->Flags = GetWord( pInResFile, plSize);

                                //... Check to make sure this message is stored
                                //... either in ASCII in the current code page
                                //... or in Unicode, else fail.

                if ( pMRE->Flags != 0                           //... ASCII
                  && pMRE->Flags != MESSAGE_RESOURCE_UNICODE )  //... Unicode
                {
                    if ( pMsgBlock != NULL )
                    {
                        RLFREE( pMsgBlock);
                    }
                    ClearResMsg( &pResMsgData);
                    QuitA( IDS_NON0FLAG, NULL, NULL);
                }

                                //... Get the .Text field string

                usLen -= (2 * sizeof( WORD));

                for ( puchText = (PUCHAR)pMRE->Text; usLen; ++puchText, --usLen )
                {
                    *puchText = (UCHAR)GetByte( pInResFile, plSize);
                }
                DWordUpFilePointer( pInResFile,
                                    MYREAD,
                                    ftell( pInResFile),
                                    plSize);
            }
            else
            {
                if ( pMsgBlock != NULL )
                {
                    RLFREE( pMsgBlock);
                }
                ClearResMsg( &pResMsgData);
                QuitT( IDS_ENGERR_05, (LPTSTR)IDS_INVMSGTBL, NULL);
            }
        }                       //... END FOR(each message entry in this block)

        if ( pMsgBlock != NULL && usMsgBlkLen > 0 )
        {
            pBlockEntries[ ulBlock] = FALLOC( usMsgBlkLen);

            memcpy( pBlockEntries[ ulBlock], pMsgBlock, usMsgBlkLen);
        }
    }                           //... END FOR(each message block)

    if ( pMsgBlock != NULL )
    {
        RLFREE( pMsgBlock);
    }

    DWordUpFilePointer( pInResFile, MYREAD, ftell( pInResFile), plSize);

    return( (VOID *)pMsgResData);
}




//.........................................................................
//...
//... Put localized Message Table into .res
//...
//... 01/93 - changes for var length Token text.  MHotchin
//... 02/93 - stripped out code that split msgs into multiple tokens.  davewi

void PutResMessage(

FILE *fpOutResFile,     //... File to which localized resources are written
FILE *fpInTokFile,      //... Output token file
RESHEADER ResHeader,    //... Resource header data
VOID *pMsgResData)      //... message table data built in GetResMessage
{
    WORD   wcCount = 0;
    fpos_t ulResSizePos   = 0L; //... File position for fixed up resource size
    fpos_t ulBlocksStartPos=0L; //... File position of start of message blocks
    ULONG  ulNumBlocks    = 0L; //... Number of Message Blocks
    ULONG  ulCurrOffset   = 0L; //... Offset to current msg block
    ULONG  ulResSize      = 0L; //... Size of this resource
    ULONG  ulBlock;             //... Temporary counter
    USHORT usEntryLen = 0;      //... Length of current message entry
    PMESSAGE_RESOURCE_DATA pData; //. Message table data from InResFile
    static TOKEN  Tok;          //... Token from localized token file


    if ( pMsgResData == NULL)
    {
        QuitT( IDS_ENGERR_05, (LPTSTR)IDS_NULMSGDATA, NULL);
    }
    memset( (void *)&Tok, 0, sizeof( Tok));
    pData = (PMESSAGE_RESOURCE_DATA)pMsgResData;

    if ( PutResHeader( fpOutResFile, ResHeader, &ulResSizePos, &ulResSize))
    {
        ClearResMsg( &pResMsgData);
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_MSGTBLHDR, NULL);
    }

    ulResSize = 0L;             //... Reset to zero (hdr len not to be included)

    ulNumBlocks = pData->NumberOfBlocks;

                                //... Write number of msg blocks

    PutdWord( fpOutResFile, ulNumBlocks, &ulResSize);

                                //... Remember this file position so we can
                                //... come back here and update the
                                //... OffsetToEntries field in each struct.

    ulBlocksStartPos = ftell( fpOutResFile);

                                //... Write the array of message block structs

    for ( ulBlock = 0L; ulBlock < ulNumBlocks; ++ulBlock )
    {
        PutdWord( fpOutResFile, pData->Blocks[ ulBlock].LowId,  &ulResSize);
        PutdWord( fpOutResFile, pData->Blocks[ ulBlock].HighId, &ulResSize);
        PutdWord( fpOutResFile, 0L, &ulResSize);  //... Will get fixed up later
    }
                                // Prep for find token call

    Tok.wType = ResHeader.wTypeID;
    Tok.wName = ResHeader.wNameID;
    Tok.wID   = 0;
    Tok.wFlag = 0;

    if ( ResHeader.bNameFlag == IDFLAG )
    {
        lstrcpy( Tok.szName, ResHeader.pszName);
    }
                                //... Write the MESSAGE_RESOURCE_ENTRY's. First
                                //... note offset from start of this resource's
                                //... data to first msg res entry struct which
                                //... starts right after the array of
                                //... RESOURCE_MESSAGE_BLOCK structs.

    ulCurrOffset = sizeof( ULONG) + ulNumBlocks*sizeof( MESSAGE_RESOURCE_BLOCK);

    for ( ulBlock = 0L; ulBlock < ulNumBlocks; ++ulBlock )
    {
        ULONG   ulCurrID;       //... Current message ID # in this block
        ULONG   ulEndID;        //... Last message ID # in this block + 1
        fpos_t  ulEntryPos;     //... Start of the current msg entry struct
        PBYTE   pMRE;           //... Ptr to a MESSAGE_RESOURCE_ENTRY
        PMESSAGE_RESOURCE_BLOCK pMRB;


                                //... Retrieve ptr to block of messages.  The
                                //... ptr was stored in the pBlockEntries array
                                //... in GetResMessage function above.

        pMRB = (PMESSAGE_RESOURCE_BLOCK)( &pData->Blocks[ ulBlock]);
        pMRE = pBlockEntries[ ulBlock];

                                //... Note offset to start of block's entries

        pData->Blocks[ ulBlock].OffsetToEntries = ulCurrOffset;

        for ( ulCurrID = pMRB->LowId, ulEndID = pMRB->HighId + 1;
              ulCurrID < ulEndID;
              ++ulCurrID )
        {
            static UCHAR szString[ 64] = "";
            static TCHAR szwTmp[ 4096] = TEXT("");
            USHORT usCnt = 0;
            BOOL   fFound = FALSE;
            ULONG  ulEntrySize = 0;


            ulEntryPos  = ftell( fpOutResFile);
            ulEntrySize = 0L;

                                //... Write dummy entry length.
                                //... Value gets corrected later.
                                //... Write the .Flags field's value (USHORT).

            PutWord( fpOutResFile, ((PMRE)pMRE)->Length, &ulEntrySize);
            PutWord( fpOutResFile, ((PMRE)pMRE)->Flags,  &ulEntrySize);

                                //... Get localized token then the length of
                                //... that token's new text.  Add to that length
                                //... the length of the two USHORTs and use this
                                //... combined length as the value to store in
                                //... the msg res entry's .Length field.

                                //... Put low word of ID# in .wID and
                                //... the high word in .szName

            Tok.wID = LOWORD( ulCurrID);
            _itoa( HIWORD( ulCurrID), szString, 10);
            _MBSTOWCS( Tok.szName,
                       szString,
                       TOKENSTRINGBUFFER,
                       lstrlenA( szString) + 1);

                                //... Always reset .wReserved because the code
                                //... in FindTokenText will change its value.

            Tok.wReserved = ST_TRANSLATED;

            Tok.szText = NULL;
            *szwTmp  = TEXT('\0');

            for ( fFound = FALSE, Tok.wFlag = 0;
                  fFound = FindToken( fpInTokFile, &Tok, ST_TRANSLATED);
                  Tok.wFlag++ )
            {
                TextToBin( szwTmp, Tok.szText, lstrlen( Tok.szText) + 1);

                                //... Write out localized message text. It may
                                //... be stored as ASCII or Unicode string.

                if ( ((PMRE)pMRE)->Flags == 0 )  //... ASCII message
                {
                    _WCSTOMBS( szDHW,
                               szwTmp,
                               DHWSIZE,
                               lstrlen( szwTmp) + 1);

                    for ( usCnt = 0; szDHW[ usCnt]; ++usCnt )
                    {
                        PutByte( fpOutResFile, szDHW[ usCnt], &ulEntrySize);
                    }
                }
                else                            //... Unicode message
                {
                    for ( usCnt = 0; szwTmp[ usCnt]; ++usCnt )
                    {
                        PutWord( fpOutResFile, szwTmp[ usCnt], &ulEntrySize);
                    }
                }
                *szwTmp  = TEXT('\0');
                RLFREE( Tok.szText);

                                //... Always reset .wReserved because the code
                                //... in FindTokenText will change its value.

                Tok.wReserved = ST_TRANSLATED;
            }

                                //... Did we find the token?

            if ( Tok.wFlag == 0 && ! fFound )
            {
                static TCHAR szToken[ 4160];


                ParseTokToBuf( szToken, &Tok);

                ClearResMsg( &pResMsgData);
                QuitT( IDS_ENGERR_05, szToken, NULL);
            }
                                //... nul-terminate the text

            if ( ((PMRE)pMRE)->Flags == 0 )  //... ASCII message
            {
                PutByte( fpOutResFile , '\0', (DWORD *)&ulEntrySize);
            }
            else                            //... Unicode message
            {
                PutWord( fpOutResFile , TEXT('\0'), (DWORD *)&ulEntrySize);
            }
            DWordUpFilePointer( fpOutResFile,
                                MYWRITE,
                                ftell( fpOutResFile),
                                &ulEntrySize);

                                //... Also, use this length in later updating
                                //... next msg block's OffsetToEntries value.

            ulResSize    += ulEntrySize;
            ulCurrOffset += ulEntrySize;

                                //... Write Msg Resource entry length
                                //... (Length is in bytes and includes
                                //...  .Length and .Flags fields and any
                                //...  padding needed after the text.)
                                //...
                                //... NOTE: Msg text is currently stored as
                                //... an ASCIIZ string.
            fseek( fpOutResFile, (long)ulEntryPos, SEEK_SET);

            PutWord( fpOutResFile, (WORD)ulEntrySize, NULL);

            fseek( fpOutResFile, 0L, SEEK_END);

                                //... Move pMRE to point to start of next
                                //... Message Resource Entry in memory.

            pMRE += ((PMRE)pMRE)->Length;

        }                       //... END FOR(each message entry in this block)

        ulCurrOffset = DWORDUP( ulCurrOffset);
        DWordUpFilePointer( fpOutResFile,
                            MYWRITE,
                            ftell( fpOutResFile),
                            &ulResSize);

    }                           //... END FOR(each message block)

                                //... Update resource size field in res header

    if ( UpdateResSize( fpOutResFile, &ulResSizePos, ulResSize) == 0L )
    {
        ClearResMsg( &pResMsgData);
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_MSGRESTBL, NULL);
    }
                                //... Now, update the OffsetToEntries fields.

    fseek( fpOutResFile, (long)ulBlocksStartPos, SEEK_SET);

    for ( ulBlock = 0L; ulBlock < ulNumBlocks; ++ulBlock )
    {
        PutdWord( fpOutResFile, pData->Blocks[ulBlock].LowId,           NULL);
        PutdWord( fpOutResFile, pData->Blocks[ulBlock].HighId,          NULL);
        PutdWord( fpOutResFile, pData->Blocks[ulBlock].OffsetToEntries, NULL);
    }
    fseek( fpOutResFile, 0L, SEEK_END);

}       //... END PutResMessage()




//.........................................................................
//...
//... Write Message Table to the token file
//...
//... This function assumes that, in each message block, the message ID's are
//... contiguouse within the range given in the fields LowId and HighId in a
//... MESSAGE_RESOURCE_BLOCK.
//
// 01/93 - Changes for var length token text strings.  Mhotchin
//

void TokResMessage(

FILE      *pfTokFile,       //... Output token file
RESHEADER  ResHeader,       //... Resource header data
VOID      *pMsgResData)     //... Data to tokenize (from GetResMessage call)
{
    static TOKEN Tok;
    ULONG  ulBlock;                 //... Message resource block number
    PMESSAGE_RESOURCE_DATA  pData;  //... Data to tokenize
    PMESSAGE_RESOURCE_BLOCK pMRB;   //... ptr to a message block struct


    pData = (PMESSAGE_RESOURCE_DATA)pMsgResData;
    memset( (void *)&Tok, 0, sizeof( Tok));

    Tok.wType = ResHeader.wTypeID;
    Tok.wName = ResHeader.wNameID;

    Tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);

    if ( ResHeader.bNameFlag == IDFLAG )
    {
        lstrcpy( Tok.szName, ResHeader.pszName);
    }

    for ( ulBlock = 0L; ulBlock < pData->NumberOfBlocks; ++ulBlock )
    {
        ULONG  ulCurrID  = 0L;  //... ID # of current msg being processed
        ULONG  ulEndID;         //... Last message ID # in this block + 1
        USHORT usLineNum = 0;   //... Count of lines in a message text
        PCHAR  pMRE;            //... ptr to a message entry struct


                                //... Get ptr to this message block struct

        pMRB = &pData->Blocks[ ulBlock];

                                //... Get ptr to first entry in
                                //... this block of messages

        pMRE = (PCHAR)pBlockEntries[ ulBlock];

                                //... Tokenize entries in this block of messages

        for ( ulCurrID = pMRB->LowId, ulEndID = pMRB->HighId + 1;
              ulCurrID < ulEndID;
              ++ulCurrID )
        {
            usLineNum = 0;

                                //... inclusive of .Length and .Flags fields so
                                //... we need get the real length of the text.

            if ( ((PMRE)pMRE)->Length >= 2 * sizeof( WORD) )
            {
                USHORT usLen        = 0;
                USHORT usTokTextLen = 0;
                PWCHAR pszwStart = NULL;
                                // This is really ugly.  This code was
                                // originally to get around the problem
                                // that tokens could hold only 260 chars.
                                // Now, it's whatever you want.
                                // Temp hack - assume each line will be
                                // less than 4k in size. (mhotchin)
                static TCHAR szwString[ 32768 ];

                                //... Put low word of ID# in .wID and
                                //... the high word in .szName

                Tok.wID = LOWORD( ulCurrID);
                _itoa( HIWORD( ulCurrID), szDHW, 10);
                _MBSTOWCS( Tok.szName,
                           szDHW,
                           TOKENSTRINGBUFFER,
                           lstrlenA( szDHW) +1);

                                //... The err msg table strings may be stored
                                //... in the resources as ANSI or Unicode.
                                //... If the pMRE->Flags field in the
                                //... table entry struct is 0, the text is a
                                //... ANSI striing so we need to convert it to
                                //... UNICODE (WCHAR).

                if ( ((PMRE)pMRE)->Flags == 0 ) //... ASCII message
                {
                    PUCHAR puchStart = (PUCHAR)((PMRE)pMRE)->Text;

                    usLen = (USHORT)_MBSTOWCS( szwString,
                                       puchStart,
                                       WCHARSIN( sizeof( szwString)),
                                       ACHARSIN( lstrlenA( puchStart) + 1));

                    if (usLen == 0)
                        QuitT( IDS_ENGERR_10, szwString, NULL);

                    pszwStart = szwString;
                }
                else                            //... Unicode message
                {
                    pszwStart = (WCHAR *)(((PMRE)pMRE)->Text);
                    usLen = (USHORT)lstrlen( pszwStart) /*+ 1*/;
                }
                                //... We need to split the token text at \r\n

                for ( Tok.wFlag = 0;
                      usLen > 0;
                      usLen -= usTokTextLen, Tok.wFlag++ )
                {
                    WCHAR wcTmp;


                    for ( usTokTextLen = 0, wcTmp = TEXT('\0');
                          usTokTextLen < usLen;
                        ++usTokTextLen )
                    {
                        if ( pszwStart[ usTokTextLen]   == TEXT('\r')
                          && pszwStart[ usTokTextLen+1] == TEXT('\n') )
                        {
                            usTokTextLen += 2;
                            wcTmp = pszwStart[ usTokTextLen];
                            pszwStart[ usTokTextLen] = TEXT('\0');

                            break;
                        }
                    }

                    Tok.szText = BinToTextW( pszwStart, usTokTextLen);

                    PutToken( pfTokFile, &Tok);

                    RLFREE( Tok.szText);

                    pszwStart += usTokTextLen;
                    *pszwStart = wcTmp;
                }
                //... Set up to move to start of next msg entry

                pMRE += ((PMRE)pMRE)->Length;
            }
            else
            {
                ClearResMsg( &pResMsgData);
                QuitT( IDS_ENGERR_05, (LPTSTR)IDS_MSGTOOSHORT, NULL);
            }
        }                       //... END FOR processing a msg block
    }                           //... END FOR processing all msg blocks
}





//.........................................................................
//...
//... Clear memory created in GetResMessage()

void ClearResMsg(

VOID **pData)      //... ptr to ptr to start of memory to free
{
    if ( pData != NULL && *pData != NULL )
    {
        ULONG                   ulBlock;
        PMESSAGE_RESOURCE_DATA  pMRD;   //... ptr to a message data struct
        PMESSAGE_RESOURCE_BLOCK pMRB;   //... ptr to a message block struct


        pMRD = (PMESSAGE_RESOURCE_DATA)*pData;
        pMRB = pMRD->Blocks;

        if ( pBlockEntries != NULL )
        {
            for ( ulBlock = 0L; ulBlock < pMRD->NumberOfBlocks; ++ulBlock )
            {
                if ( pBlockEntries[ ulBlock] )
                {
                    RLFREE( pBlockEntries[ ulBlock]);
                }
            }
            RLFREE( (PBYTE)pBlockEntries);
        }
        RLFREE( *pData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RLSTRNGS.RC
//
#define IDS_UPDATE_YESNO                3101
#define IDS_UPDATE_TITLE                3102
#define IDS_UPDATE_CANCEL               3103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\resread.h ===
//... Prototypes of functions in resread.c that are used in other modules

#ifndef _RESREAD_H_
#define _RESREAD_H_

int   MyStrLen( TCHAR *psz);

#ifdef _DEBUG
PBYTE MyAlloc( DWORD size, LPSTR pszFile, WORD wLine);
PBYTE MyReAlloc( BYTE *p, DWORD n, LPSTR pszFile, WORD wLine);
#else
PBYTE MyAlloc( DWORD n);
PBYTE MyReAlloc( BYTE *p, DWORD n);
#endif

void  MyFree( void *UNALIGNED*p);
int   InsDlgToks( CHAR * s1, CHAR * s2, WORD n);
void  FreeLangIDList( void);

typedef struct _tagLangList
{
    WORD wLang;
    struct _tagLangList *pNext;
} LANGLIST, * PLANGLIST;



#ifdef _DEBUG

typedef struct _tagMemList
{
    char szMemFile[ _MAX_PATH];
    WORD wMemLine;
    PBYTE  pMem;
    struct _tagMemList *pNext;
} MEMLIST, * PMEMLIST;

void FreeMemList( FILE *pfFile);
void FreeMemListItem( void *p, FILE *pfFile);

#endif // _DEBUG

#endif // _RESREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\resread.c ===
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
//#include <malloc.h>
#include <tchar.h>
//#include <assert.h>
//#include <sys\types.h>
//#include <sys\stat.h>
#include <fcntl.h>

#ifdef RLDOS
    #include "dosdefs.h"
#else  //RLDOS
    #include <windows.h>
    #include "windefs.h"
#endif //RLDOS

#include "resread.h"
#include "restok.h"
#include "custres.h"
#ifdef RLRES32
    #include "exentres.h"
    #include "reswin16.h"
#else  //RLRES32
    #include "exe2res.h"
#endif //RLRES32


UCHAR szDHW[ DHWSIZE];         //... Common temporary buffer

char * gszTmpPrefix = "$RLT";   //... Temporary name prefix

BOOL gbMaster       = FALSE;    //... TRUE if Working in Master project
BOOL gfReplace      = TRUE;     //... FALSE if appending new language to exe
BOOL gbShowWarnings = FALSE;    //... Display warnining messages if TRUE

#ifdef _DEBUG
PMEMLIST pMemList = NULL;
#endif


static BOOL ShouldBeAnExe( CHAR *);
static BOOL NotExistsOrIsEmpty( PCHAR szTargetTokFile);


/**
  *
  *
  *  Function: DWORDfpUP
  * Move the file pointer to the next 32 bit boundary.
  *
  *
  *  Arguments:
  * Infile: File pointer to seek
  * plSize: Address of Resource size var
  *
  *  Returns:
  * Number of padding to next 32 bit boundary, and addjusts resource size var
  *
  *  Errors Codes:
  * -1, fseek failed
  *
  *  History:
  * 10/11/91    Implemented      TerryRu
  *
  *
  **/


DWORD DWORDfpUP(FILE * InFile, DWORD *plSize)
{
    DWORD tPos;
    DWORD Align;
    tPos = (ftell(InFile));
    Align = DWORDUP(tPos);

    *plSize -= (Align - tPos);
    fseek( InFile, Align,   SEEK_SET);

    return ( Align - tPos);
}

/*
 *
 * Function GetName,
 *  Copies a name from the OBJ file into the ObjInfo Structure.
 *
 */
void GetName( FILE *infile, TCHAR *szName , DWORD *lSize)
{
    WORD i = 0;

    do {

#ifdef RLRES16

        szName[ i ] = GetByte( infile, lSize);

#else

        szName[ i ] = GetWord( infile, lSize);

#endif

    } while ( szName[ i++ ] != TEXT('\0') );
}



/*
 *
 * Function MyAlloc:
 *  Memory allocation routine with error checking.
 *
 */

#ifdef _DEBUG
PBYTE MyAlloc( DWORD dwSize, LPSTR pszFile, WORD wLine)
#else
PBYTE MyAlloc( DWORD dwSize)
#endif
{
    PBYTE   ptr  = NULL;
    HGLOBAL hMem = GlobalAlloc( GMEM_MOVEABLE | GMEM_ZEROINIT,
                                (size_t)((dwSize > 0) ? dwSize : sizeof( TCHAR)));

    if ( hMem == NULL ) {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    } else {
        ptr = GlobalLock( hMem);
    }

#ifdef _DEBUG
    {
        PMEMLIST pTmpMem = (PMEMLIST)GlobalAlloc( GPTR, sizeof( MEMLIST));

        pTmpMem->pNext = pMemList;
        pMemList = pTmpMem;

        lstrcpyA( pMemList->szMemFile, pszFile);
        pMemList->wMemLine = wLine;
        pMemList->pMem     = ptr;
    }

#endif // _DEBUG

    return ( ptr);   // memory allocation okay.
}

//..........................................................................

//ppc cause access violation
void MyFree( void *UNALIGNED*p)
{
    if ( p && *p ) {

#ifdef _DEBUG

        FreeMemListItem( *p, NULL);
#else
        HGLOBAL hMem = GlobalHandle( (HANDLE)*p);
        GlobalUnlock( hMem);
        GlobalFree( hMem);

#endif // _DEBUG

        *p = NULL;
    }
}


#ifdef _DEBUG

void FreeMemList( FILE *pfMemFile)
{
    while ( pMemList ) {
        FreeMemListItem( pMemList->pMem, pfMemFile);
    }
}


void FreeMemListItem( void *p, FILE *pfMemFile)
{
    if ( pMemList && p ) {
        PMEMLIST pThisMem = NULL;
        PMEMLIST pNextMem = NULL;
        PMEMLIST pPrevMem = NULL;

        for ( pThisMem = pMemList; pThisMem; pThisMem = pNextMem ) {
            pNextMem = pThisMem->pNext;

            if ( pThisMem->pMem == p ) {
                HGLOBAL hMem = NULL;

                if ( pfMemFile ) {
                    fprintf( pfMemFile,
                             "%u\t%s\n",
                             pThisMem->wMemLine,
                             pThisMem->szMemFile);
                }
                hMem = GlobalHandle( p);
                GlobalUnlock( hMem);
                GlobalFree( hMem);

                GlobalFree( pThisMem);

                if ( pPrevMem ) {
                    pPrevMem->pNext = pNextMem;
                } else {
                    pMemList = pNextMem;
                }
                break;
            }
            pPrevMem = pThisMem;
        }
    }
}

#endif // _DEBUG

/*
 *
 * Function MyReAlloc
 *
 * Re-allocate memory with error checking.
 *
 * History:
 *      01/21/93  MHotchin      Implemented.
 *
 */

#ifdef _DEBUG
PBYTE MyReAlloc(
               PBYTE pOldMem,  //... Current ptr to buffer
               DWORD cSize,    //... New size for buffer
               LPSTR pszFile,
               WORD wLine)
#else
PBYTE MyReAlloc(
               PBYTE pOldMem,  //... Current ptr to buffer
               DWORD cSize)    //... New size for buffer
#endif // _DEBUG
{
    PBYTE    ptr      = NULL;
    HGLOBAL  hMem     = NULL;


    hMem = GlobalHandle( pOldMem);

    if ( hMem == NULL ) {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }

    if ( GlobalUnlock( hMem) || GetLastError() != NO_ERROR ) {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }
    hMem = GlobalReAlloc( hMem, cSize, GMEM_MOVEABLE | GMEM_ZEROINIT);

    if ( hMem == NULL ) {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }
    ptr = GlobalLock( hMem);

#ifdef _DEBUG

    if ( ptr != pOldMem ) {
        PMEMLIST pThisMem = NULL;
        PMEMLIST pNextMem = NULL;

        for ( pThisMem = pMemList; pThisMem; pThisMem = pThisMem->pNext ) {
            if ( pThisMem->pMem == pOldMem ) {
                pThisMem->pMem = ptr;
                break;
            }
        }
    }

#endif // _DEBUG

    return ( ptr);
}


/*
 *
 * Function GetByte:
 *  Reads a byte from the input file stream, and checks for EOF.
 *
 */
BYTE GetByte(FILE *pInFile, DWORD *pdwSize)
{
    register int n;

    if ( pdwSize ) {
        (*pdwSize)--;
    }
    n = fgetc( pInFile);

    if ( n == EOF ) {
        if ( feof( pInFile) ) {
            exit(-1);
        }
    }
    return ( (BYTE)n);
}


/*
 *
 * Function UnGetByte:
 *
 *   Returns the character C into the input stream, and updates the Record Length.
 *
 * Calls:
 *   ungetc, To return character
 *   DiffObjExit, If unable to insert the character into the input stream
 *
 * Caller:
 *   GetFixUpP,
 *
 */

void UnGetByte(FILE *infile, BYTE c, DWORD *lSize)
{
    if (lSize) {
        (*lSize)++;
    }


    if (ungetc(c, infile)== EOF) {
        exit (-1);
    }

    // c put back into input stream
}

/*
 *
 * Function UnGetWord:
 *
 *   Returns the word C into the input stream, and updates the Record Length.
 *
 * Calls:
 *
 * Caller:
 *
 */

void UnGetWord(FILE *infile, WORD c, DWORD *lSize)
{
    long lCurrentOffset;

    if (lSize) {
        (*lSize) += 2;
    }

    lCurrentOffset = ftell(infile);

    if (fseek(infile, (lCurrentOffset - 2L) , SEEK_SET)) {
        exit (-1);
    }
}


/*
 *
 * Function SkipBytes:
 *  Reads and ignores n bytes from the input stream
 *
 */


void SkipBytes(FILE *infile, DWORD *pcBytes)
{
    if (fseek(infile, (DWORD) *pcBytes, SEEK_CUR) == -1L) {
        exit (-1);
    }
    *pcBytes=0;
}



/*
 * Function GetWord:
 *  Reads a WORD from the RES file.
 *
 */

WORD GetWord(FILE *infile, DWORD *lSize)
{
    // Get low order byte
    register WORD lobyte;

    lobyte = GetByte(infile, lSize);
    return (lobyte + (GetByte(infile, lSize) << BYTELN));
}


/*
 *
 * Function GetDWORD:
 *   Reads a Double WORD from the OBJ file.
 *
 */

DWORD GetdWord(FILE *infile, DWORD *lSize)
{
    DWORD dWord = 0;

    dWord = (DWORD) GetWord(infile, lSize);
    // Get low order word
    // now get high order word, shift into upper word and or in low order word
    dWord |= ((DWORD) GetWord(infile, lSize) << WORDLN);

    return (dWord);
    // return complete double word
}



void  PutByte(FILE *Outfile, TCHAR b, DWORD *plSize)
{
    if (plSize) {
        (*plSize) ++;
    }

    if (fputc(b, Outfile) == EOF) {
        exit(-1);
    }
}

void PutWord(FILE *OutFile, WORD w, DWORD *plSize)
{
    PutByte(OutFile, (BYTE) LOBYTE(w), plSize);
    PutByte(OutFile, (BYTE) HIBYTE(w), plSize);
}

void PutdWord (FILE *OutFile, DWORD l, DWORD *plSize)
{
    PutWord(OutFile, LOWORD(l), plSize);
    PutWord(OutFile, HIWORD(l), plSize);
}


void PutString( FILE *OutFile, TCHAR *szStr , DWORD *plSize)
{
    WORD i = 0;


    do {

#ifdef RLRES16

        PutByte( OutFile , szStr[ i ], plSize);

#else

        PutWord( OutFile , szStr[ i ], plSize);

#endif

    } while ( szStr[ i++ ] != TEXT('\0') );
}


/**
  *  Function: MyGetTempFileName
  *    Generic funciton to create a unique file name,
  *    using the API GetTempFileName. This
  *    function is necessary because of the parameters
  *    differences betweenLWIN16, and WIN32.
  *
  *
  *  Arguments:
  *    BYTE   hDriveLetter
  *    LPCSTR lpszPrefixString
  *    UINT   uUnique
  *    LPSTR  lpszTempFileName
  *
  *  Returns:
  *    lpszFileNameTempFileName
  *
  *
  *  Error Codes:
  *    0 - invalid path returned
  *    1 - valid path returned
  *
  *  History:
  *    3/92, Implemented    TerryRu
  */


int MyGetTempFileName(BYTE    hDriveLetter,
                      LPSTR   lpszPrefixString,
                      WORD    wUnique,
                      LPSTR   lpszTempFileName)
{

#ifdef RLWIN16

    return (GetTempFileName(hDriveLetter,
                            (LPCSTR)lpszPrefixString,
                            (UINT)wUnique,
                            lpszTempFileName));
#else //RLWIN16
    #ifdef RLWIN32

    UINT uRC;
    CHAR szPathName[ MAX_PATH+1];

    if (! GetTempPathA((DWORD)sizeof(szPathName), (LPSTR)szPathName)) {
        szPathName[0] = '.';
        szPathName[1] = '\0';
    }

    uRC = GetTempFileNameA((LPSTR)szPathName,
                           lpszPrefixString,
                           wUnique,
                           lpszTempFileName);
    return ((int)uRC);

    #else  //RLWIN32

    return (tmpnam(lpszTempFileName) == NULL ? 0 : 1);

    #endif // RLWIN32
#endif // RLWIN16
}



/**
  *  Function GenerateImageFile:
  *     builds a resource from the token and rdf files
  *
  *  History:
  *     2/92, implemented       SteveBl
  *     7/92, modified to always use a temporary file   SteveBl
  */


int GenerateImageFile(

                     CHAR * szTargetImage,
                     CHAR * szSrcImage,
                     CHAR * szTOK,
                     CHAR * szRDFs,
                     WORD   wFilter)
{
    CHAR szTmpInRes[ MAXFILENAME];
    CHAR szTmpOutRes[ MAXFILENAME];
    CHAR szTmpTargetImage[ MAXFILENAME];
    BOOL bTargetExe = FALSE;
    BOOL bSrcExe  = FALSE;
    int  nExeType = NOTEXE;
    int  rc;
    FILE *fIn  = NULL;
    FILE *fOut = NULL;


    if ( IsRes( szTOK) ) {
        // The given szTOK file is really a localized resource file,
        // place these resources into outputimage file

        MyGetTempFileName( 0, "TMP", 0, szTmpTargetImage);

        if ( IsWin32Res( szTOK) ) {
            rc = BuildExeFromRes32A( szTmpTargetImage, szTOK, szSrcImage);
        } else {
            rc = BuildExeFromRes16A( szTmpTargetImage, szTOK, szSrcImage);
        }

        if ( rc != 1 ) {
            remove( szTmpTargetImage);
            QuitT( IDS_ENGERR_16, (LPTSTR)IDS_NOBLDEXERES, NULL);
        }

        if ( ! CopyFileA( szTmpTargetImage, szTargetImage, FALSE) ) {
            remove( szTmpTargetImage);
            QuitA( IDS_COPYFILE_FAILED, szTmpTargetImage, szTargetImage);
        }
        remove( szTmpTargetImage);
        return ( rc);
    }


    // We're going to now do this EVERY time.  Even if the target doesn't
    // exist.  This will enable us to always work, even if we get two different
    // paths that resolve to the same file.

    MyGetTempFileName(0, "TMP", 0, szTmpTargetImage);

    rc = IsExe( szSrcImage);

    if ( rc == NTEXE || rc == WIN16EXE ) {
        //... resources contained in image file
        nExeType = rc;
        MyGetTempFileName( 0, "RES", 0, szTmpInRes);

        if ( nExeType == NTEXE ) {
            ExtractResFromExe32A( szSrcImage, szTmpInRes, wFilter);
        } else {
            ExtractResFromExe16A( szSrcImage, szTmpInRes, wFilter);
        }
        bSrcExe = TRUE;
    } else if ( rc == -1 ) {
        QuitA( IDS_ENGERR_01, "original source", szSrcImage);
    } else if ( rc == NOTEXE ) {
        if ( ShouldBeAnExe( szSrcImage) ) {
            QuitA( IDS_ENGERR_18, szSrcImage, NULL);
        }
    } else {
        QuitA( IDS_ENGERR_18, szSrcImage, NULL);
    }

    if ( IsRes( szTargetImage) ) {
        bTargetExe = FALSE;
    } else {
        bTargetExe = TRUE;
    }

    // check for valid input files

    if ( bSrcExe == TRUE && bTargetExe == FALSE ) {
        if ( nExeType == NTEXE ) {
            GenerateRESfromRESandTOKandRDFs( szTargetImage,
                                             szTmpInRes,
                                             szTOK,
                                             szRDFs,
                                             FALSE);
            return 1;
        } else {
            return -1;  //... Can not generate a win16 .RES  (yet)
        }
    }

    if ( bSrcExe == FALSE && bTargetExe == TRUE ) {
        // can not go from res to exe
        return -1;
    }

    // okay we have valid file inputs, generate image file

    if ( bSrcExe ) {
        // create name for temporary localized resource file
        MyGetTempFileName(0, "RES", 0, szTmpOutRes);

        GenerateRESfromRESandTOKandRDFs( szTmpOutRes,
                                         szTmpInRes,
                                         szTOK,
                                         szRDFs,
                                         FALSE);

        // now szTmpOutRes file is a localized resource file,
        // place these resources into outputimage file

        if ( nExeType == NTEXE ) {
            rc = BuildExeFromRes32A( szTmpTargetImage, szTmpOutRes, szSrcImage);
        } else {
//            rc = BuildExeFromRes16A( szTmpTargetImage, szTmpOutRes, szSrcImage);

            remove( szTmpInRes);
            remove( szTmpOutRes);
            remove( szTmpTargetImage);

            QuitT( IDS_ENGERR_16, (LPTSTR)IDS_NOBLDEXERES, NULL);
        }

        // now clean up temporary files
        remove( szTmpInRes);
        remove( szTmpOutRes);

        if ( rc != 1 ) {
            remove( szTmpTargetImage);
            QuitT( IDS_ENGERR_16, (LPTSTR)IDS_NOBLDEXERES, NULL);
        }

        if ( ! CopyFileA( szTmpTargetImage, szTargetImage, FALSE) ) {
            remove( szTmpTargetImage);
            QuitA( IDS_COPYFILE_FAILED, szTmpTargetImage, szTargetImage);
        }
        remove( szTmpTargetImage);

        // szTargetImage is now generated,
        return 1;
    }

    if ( ! bSrcExe ) {
        // image files are resource files
        if ( szTmpTargetImage[0] ) {
            GenerateRESfromRESandTOKandRDFs( szTmpTargetImage,
                                             szSrcImage,
                                             szTOK,
                                             szRDFs,
                                             FALSE);
        }

        if ( ! CopyFileA( szTmpTargetImage, szTargetImage, FALSE) ) {
            remove( szTmpTargetImage);
            QuitA( IDS_COPYFILE_FAILED, szTmpTargetImage, szTargetImage);
        }
        remove( szTmpTargetImage);

        // sztarget Image is now generated,

        return 1;
    }
    return 1;
}




/**
  *  Function GenerateRESfromRESandTOKandRDFs:
  * builds a resource from the token and rdf files
  *
  *  History:
  * 2/92, implemented       SteveBl
  */
void GenerateRESfromRESandTOKandRDFs(

                                    CHAR * szTargetRES,     //... Output exe/res file name
                                    CHAR * szSourceRES,     //... Input  exe/res file name
                                    CHAR * szTOK,           //... Input token file name
                                    CHAR * szRDFs,          //... Custom resource definition file name
                                    WORD wFilter)
{
    FILE * fTok       = NULL;
    FILE * fSourceRes = NULL;
    FILE * fTargetRes = NULL;

    LoadCustResDescriptions( szRDFs);

    if ( (fTargetRes = FOPEN( szTargetRES, "wb")) != NULL ) {
        if ( (fSourceRes = FOPEN( szSourceRES, "rb")) != NULL ) {
            if ( (fTok = FOPEN( szTOK, "rt")) != NULL ) {
                ReadWinRes( fSourceRes,
                            fTargetRes,
                            fTok,
                            TRUE,        //... Building res/exe file
                            FALSE,       //... Not building token file
                            wFilter);

                FCLOSE( fTok);
                FCLOSE( fSourceRes);
                FCLOSE( fTargetRes);

                ClearResourceDescriptions();
            } else {
                FCLOSE( fSourceRes);
                FCLOSE( fTargetRes);

                ClearResourceDescriptions();
                QuitA( IDS_ENGERR_01, "token", szTOK);
            }
        } else {
            FCLOSE( fTargetRes);

            ClearResourceDescriptions();
            QuitA( IDS_ENGERR_20, (LPSTR)IDS_INPUT, szSourceRES);
        }
    } else {
        ClearResourceDescriptions();
        QuitA( IDS_ENGERR_20, (LPSTR)IDS_OUTPUT, szSourceRES);
    }
}




int GenerateTokFile(

                   char *szTargetTokFile,      //... Target token file, created or updated here
                   char *szSrcImageFile,       //... File from which tokens are to be made
                   BOOL *pbTokensChanged,      //... Set TRUE here if any token changes
                   WORD  wFilter)
{
    BOOL  bExeFile    = FALSE;
    int   rc          = 0;
    FILE *fTokFile    = NULL;
    FILE *fResFile    = NULL;
    FILE *fTmpTokFile = NULL;
    FILE *fCurTokFile = NULL;
    FILE *fNewTokFile = NULL;
    static char *pchTRes   = NULL;
    static char *pchTTok   = NULL;
    static char *pchTMerge = NULL;


    *pbTokensChanged = FALSE;   //... Assume nothing is changed

    rc = IsExe( szSrcImageFile);

    if ( rc == NOTEXE ) {
        if ( ShouldBeAnExe( szSrcImageFile) ) {
            QuitA( IDS_ENGERR_18, szSrcImageFile, NULL);
        } else {                       //... Src file must be a .RES file
            bExeFile = FALSE;
            pchTRes  = szSrcImageFile;
        }
    } else {
        if ( rc == NTEXE || rc == WIN16EXE ) {
            //... Resources are stored in a exe file
            //... extract resources out of exe file into
            //... a temporary file.

            pchTRes = _tempnam( "", gszTmpPrefix);

            if ( rc == NTEXE ) {
                rc = ExtractResFromExe32A( szSrcImageFile,
                                           pchTRes,
                                           wFilter);
            } else {
                QuitA( IDS_ENGERR_19, szSrcImageFile, "16");
//                rc = ExtractResFromExe16A( szSrcImageFile,
//                                           pchTRes,
//                                           wFilter);
            }

            if ( rc  != 0 ) {
                return ( 1);
            }
            bExeFile = TRUE;
        } else if ( rc == -1 ) {
            QuitA( IDS_ENGERR_01, "source image", szSrcImageFile);
        } else {
            QuitA( IDS_ENGERR_18, szSrcImageFile, NULL);
        }
    }

    //... now extract tokens out of resource file

    //... Open res file

    if ( (fResFile = FOPEN( pchTRes, "rb")) == NULL ) {
        QuitA( IDS_ENGERR_01,
               bExeFile ? "temporary resource" : "resource",
               pchTRes);
    }
    //... Does the token file already exist?

    if ( NotExistsOrIsEmpty( szTargetTokFile) ) {
        //... No, token file does not exist.

        if ( (fTokFile = FOPEN( szTargetTokFile, "wt")) == NULL ) {
            FCLOSE( fResFile);
            QuitA( IDS_ENGERR_02, szTargetTokFile, NULL);
        }
        ReadWinRes( fResFile,
                    NULL,
                    fTokFile,
                    FALSE,      //... Not building res/exe file
                    TRUE,       //... Building token file
                    wFilter);

        FCLOSE( fResFile);
        FCLOSE( fTokFile);
    } else {
        //... token file exists
        //... create a temporary file, and try to
        //... merge with existing one

        pchTTok   = _tempnam( "", gszTmpPrefix);
        pchTMerge = _tempnam( "", gszTmpPrefix);

        //... open temporary file name

        if ( (fTmpTokFile = FOPEN( pchTTok, "wt")) == NULL ) {
            FCLOSE( fResFile);
            QuitA( IDS_ENGERR_02, pchTTok, NULL);
        }

        //... write tokens to temporary file

        ReadWinRes( fResFile,
                    NULL,
                    fTmpTokFile,
                    FALSE,      //... Not building res/exe file
                    TRUE,       //... Building token file
                    wFilter);

        FCLOSE( fResFile);
        FCLOSE( fTmpTokFile);

        //... now merge temporary file with existing
        //... file open temporary token file

        if ( (fTmpTokFile = FOPEN( pchTTok, "rt")) == NULL ) {
            QuitA( IDS_ENGERR_01, "temporary token", pchTTok);
        }

        //... open current token file

        if ( (fCurTokFile = FOPEN( szTargetTokFile, "rt")) == NULL ) {
            FCLOSE( fTmpTokFile);
            QuitA( IDS_ENGERR_01, "current token", szTargetTokFile);
        }

        //... open new tok file name

        if ( (fNewTokFile = FOPEN( pchTMerge, "wt")) == NULL ) {
            FCLOSE( fTmpTokFile);
            FCLOSE( fCurTokFile);
            QuitA( IDS_ENGERR_02, pchTMerge, NULL);
        }

        //... Merge current tokens with temporary tokens

        *pbTokensChanged = MergeTokFiles( fNewTokFile,
                                          fCurTokFile,
                                          fTmpTokFile);

        FCLOSE( fNewTokFile);
        FCLOSE( fTmpTokFile);
        FCLOSE( fCurTokFile);

        //... bpTokensChanged, only valid if creating
        //... master token files so force it to be
        //... always true if building proj token files.

        if ( gbMaster == FALSE ) {
            *pbTokensChanged = TRUE;
        }

        if ( *pbTokensChanged ) {
            if ( ! CopyFileA( pchTMerge, szTargetTokFile, FALSE) ) {
                remove( pchTTok);
                remove( pchTMerge);
                RLFREE( pchTMerge);

                QuitA( IDS_COPYFILE_FAILED, pchTMerge, szTargetTokFile);
            }
        }
        remove( pchTTok);
        remove( pchTMerge);

        RLFREE( pchTTok);
        RLFREE( pchTMerge);
    }
    //... now szTargetTokFile contains latest
    //... tokens form szImageFile
    //... Clean up if we made a temp .RES file
    if ( bExeFile ) {
        rc = remove( pchTRes);
        RLFREE( pchTRes);
    }
    return ( 0);
}



BOOL ResReadBytes(

                 FILE   *InFile,     //... File to read from
                 CHAR   *pBuf,       //... Buffer to write to
                 size_t  dwSize,     //... # bytes to read
                 DWORD  *plSize)     //... bytes-read counter (or NULL)
{
    size_t dwcRead = 0;


    dwcRead = fread( pBuf, 1, dwSize, InFile);

    if ( dwcRead == dwSize ) {
        if ( plSize ) {
            *plSize -= dwcRead;
        }
        return ( TRUE);
    }
    return ( FALSE);
}


int InsDlgToks( PCHAR szCurToks, PCHAR szDlgToks, WORD wFilter)
{
    CHAR szMrgToks[MAXFILENAME];

    FILE * fCurToks = NULL;
    FILE * fDlgToks = NULL;
    FILE * fMrgToks = NULL;
    TOKEN Tok1, Tok2;

    MyGetTempFileName(0,"TOK",0,szMrgToks);

    fMrgToks = FOPEN(szMrgToks, "w");
    fCurToks = FOPEN(szCurToks, "r");
    fDlgToks = FOPEN(szDlgToks, "r");

    if (! (fMrgToks && fCurToks && fDlgToks)) {
        return -1;
    }

    while (!GetToken(fCurToks, &Tok1)) {
        if (Tok1.wType != wFilter) {
            PutToken(fMrgToks, &Tok1);
            RLFREE(Tok1.szText);
            continue;
        }

        Tok2.wType  = Tok1.wType;
        Tok2.wName  = Tok1.wName;
        Tok2.wID    = Tok1.wID;
        Tok2.wFlag  = Tok1.wFlag;
        Tok2.wLangID    = Tok1.wLangID;
        Tok2.wReserved  =  0 ;
        lstrcpy( Tok2.szType, Tok1.szType);
        lstrcpy( Tok2.szName, Tok1.szName);
        Tok2.szText = NULL;

        if (FindToken(fDlgToks, &Tok2, 0)) {
            Tok2.wReserved  =  Tok1.wReserved ;
            PutToken(fMrgToks, &Tok2);
            RLFREE(Tok2.szText);
        } else {
            PutToken(fMrgToks, &Tok1);
        }
        RLFREE(Tok1.szText);
    }
    FCLOSE (fMrgToks);
    FCLOSE (fCurToks);

    if ( ! CopyFileA( szMrgToks, szCurToks, FALSE) ) {
        remove( szDlgToks);
        remove( szMrgToks);
        QuitA( IDS_COPYFILE_FAILED, szMrgToks, szCurToks);
    }
    remove(szMrgToks);

    return 1;
}


//+-----------------------------------------------------------------------
//
// MergeTokFiles
//
// Returns: TRUE if a token changed, was added, or was deleted else FALSE
//
// History:
//      7-22-92     stevebl     added return value
//      9-8-92      terryru     changed order of translation/delta tokens
//      01-25-93    MHotchin    Added changes to handle var length token
//                              text.
//------------------------------------------------------------------------

BOOL MergeTokFiles(

                  FILE *fNewTokFile,      //... Final product of the merge process
                  FILE *fCurTokFile,      //... The soon-to-be-old current token file
                  FILE *fTmpTokFile)      //... The token file generated from the updated .EXE
{
    TOKEN Tok1, Tok2;
    BOOL bChangesDetected = FALSE;  //... Set TRUE if any token changes found
    BOOL bChangedText     = FALSE;  //... TRUE if a token's text has changed
    WORD cTokenCount = 0;       //... Count of tokens in the new token file

                                //... Scan through the new token file.  For
                                //... every token in the new token file, find
                                //... the corresponding token in the current
                                //... token file. This process will make sure
                                //... tokens that are no longer in the .EXE
                                //... will not be in the final token file.


    while ( GetToken( fTmpTokFile, &Tok1) == 0 ) {
        ++cTokenCount;          //... Used in checking for deleted tokens
        bChangedText = FALSE;   //... assume the token did not change

                                //... Copy pertanent data to use in search
        Tok2.wType  = Tok1.wType;
        Tok2.wName  = Tok1.wName;
        Tok2.wID    = Tok1.wID;
        Tok2.wFlag  = Tok1.wFlag;
        Tok2.wLangID    = Tok1.wLangID;
        Tok2.wReserved  = 0;
        Tok2.szText = NULL;

        lstrcpy( Tok2.szType, Tok1.szType);
        lstrcpy( Tok2.szName, Tok1.szName);

        //... Now look for the corresponding token

        //If token is Version stamp and szTexts is "Translation",
        //it is 1.0 version format. So ignore it.
        IGNORETRANSLATION:

        if ( FindToken( fCurTokFile, &Tok2, 0) ) {
            if ( gbMaster && !(Tok2.wReserved & ST_READONLY) ) {
                if ( _tcscmp( (TCHAR *)Tok2.szText, (TCHAR *)Tok1.szText) ) {
                    //... Token text changed

                    //If the changes are only align info, translate it to the "unchanged" status.
                    int l1, r1, t1, b1, l2, r2, t2, b2;
                    TCHAR   a1[20], a2[20];

                    //Cordinates token?
                    if ( (Tok1.wType==ID_RT_DIALOG) && (Tok1.wFlag&ISCOR)
                         //Including align info?
                         && _stscanf(Tok1.szText,TEXT("%d %d %d %d %s"),
                                     &l1,&r1,&t1,&b1,a1) == 5
                         //Not including align info?
                         && _stscanf(Tok2.szText,TEXT("%d %d %d %d %s"),
                                     &l2,&r2,&t2,&b2,a2) == 4
                         //Cordinates are same?
                         && l1==l2 && r1==r2 && t1==t2 && b1==b2 ) {
                        Tok1.wReserved = 0;
                    } else {
                        //If token is Version stamp and szTexts is "Translation",
                        //it is 1.0 version format. So ignore it.
                        if ( Tok1.wType == ID_RT_VERSION
                             && !_tcscmp( Tok2.szText, TEXT("Translation")) ) {
                            if ( Tok2.szText != NULL ) {
                                RLFREE( Tok2.szText);
                            }
                            Tok2.szText = NULL;
                            Tok2.wFlag = 1;
                            goto IGNORETRANSLATION;
                        }
                        bChangedText = bChangesDetected = TRUE;

                        Tok1.wReserved = ST_CHANGED|ST_NEW;
                        Tok2.wReserved = ST_CHANGED;
                    }
                } else {
                    Tok1.wReserved = 0;
                }
            } else {
                Tok1.wReserved = Tok2.wReserved;
            }
        } else {
            //... Must be a new token (not in current token file)

            //If token is Version stump, and old mtk is 1.0 data file, convert it.
            if ( Tok1.wType==ID_RT_VERSION ) {
                Tok2.szText = NULL;
                Tok2.wFlag = 1;
                _tcscpy( Tok2.szName, TEXT("VALUE") );

                if ( FindToken( fCurTokFile, &Tok2, 0)
                     && ! lstrcmp( Tok1.szText, Tok2.szText) ) {
                    Tok1.wReserved = Tok2.wReserved;
                } else
                    Tok1.wReserved = ST_TRANSLATED | ST_DIRTY;
            } else {
                Tok1.wReserved = ST_TRANSLATED | ST_DIRTY;
            }
            bChangesDetected = TRUE;
        }

        //... Copy token from new token file to final token
        //... file.  If a change was detected, then copy the
        //... original token (from the "current" token file
        //... into the final token file.

        PutToken( fNewTokFile, &Tok1);
        RLFREE( Tok1.szText);

        if ( bChangedText ) {
            PutToken( fNewTokFile, &Tok2);
            // now delta tokens follow translation tokens
        }

        if ( Tok2.szText != NULL ) {
            RLFREE( Tok2.szText);
        }
    }

    if ( ! bChangesDetected ) {
        // We have to test to be sure that no tokens were deleted
        // since we know that none changed.

        rewind( fCurTokFile);

        //... Look for tokens that exist in the current
        //... token file that do not exist in the token
        //... file created from the updated .EXE.

        while ( GetToken( fCurTokFile, &Tok1) == 0 ) {
            --cTokenCount;
            RLFREE( Tok1.szText);
        }

        if ( cTokenCount != 0 ) {
            bChangesDetected = TRUE;
        }
    }
    return ( bChangesDetected);
}


void MakeNewExt(char *NewName, char *OldName, char *ext)
{

    char drive[_MAX_DRIVE];
    char dir[_MAX_DIR];
    char fname[_MAX_FNAME];  // dummy vars to hold file name info
    char dext[_MAX_EXT];


    // Split obj file name into filename and extention
    _splitpath(OldName, drive, dir, fname, dext);

    // Make new file name with new ext extention
    _makepath(NewName, drive, dir, fname, ext);
}


//......................................................................
//...
//... Check to see if the given file name *should* be an EXE
//...
//... Return: TRUE if it should, else FALSE.


static BOOL ShouldBeAnExe( PCHAR szFileName)
{
    PCHAR psz;


    if ( (psz = strrchr( szFileName, '.')) != NULL ) {
        if ( IsRes( szFileName) ) {
            return ( FALSE);
        } else if ( lstrcmpiA( psz, ".exe") == 0
                    || lstrcmpiA( psz, ".dll") == 0
                    || lstrcmpiA( psz, ".com") == 0
                    || lstrcmpiA( psz, ".scr") == 0
                    || lstrcmpiA( psz, ".cpl") == 0 ) {
            return ( TRUE);
        }
        //... Because we think this case of filename
        //... would be not executable file rather than res file.
        else if ( lstrcmpiA( psz, ".tmp") == 0 ) { //for tmp file created by Dlgedit
            return ( FALSE );
        } else {
            return ( TRUE );
        }
    }
    return ( FALSE);
}

//.........................................................
//...
//... If the named file exists and is not empty, return FALSE, else TRUE.

static BOOL NotExistsOrIsEmpty( PCHAR pszFileName)
{
    BOOL fRC = TRUE;
    int  hFile = -1;

    //... Does file not exist?

    if ( _access( pszFileName, 0) == 0 ) {
        //... No, file exists.  Open it.

        if ( (hFile = _open( pszFileName, _O_RDONLY)) != -1 ) {
            //... Is it Empty?

            if ( _filelength( hFile) == 0L ) {
                fRC = TRUE;     //... Yes, file is empty.
            } else {
                fRC = FALSE;    //... No, file is not empty.
            }
            _close( hFile);
        } else {
            QuitA( IDS_ENGERR_01, "non-empty", pszFileName);
        }
    } else {
        fRC = TRUE;             //... Yes, file does not exist.
    }
    return ( fRC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\restok.h ===
#ifndef _RESTOK_H_
#define _RESTOK_H_

#include "tokenapi.h"
#include "rlmsgtbl.h"
#include "toklist.h"

/*--------------------------------------------------------------------------*/
/*  General Purpose Defines             */
/*--------------------------------------------------------------------------*/

#define SUCCESS     0

#define FALSE       0
#define TRUE        1

#define  BYTELN     8
#define  WORDLN     16

#define  NOTEXE     0
#define  WIN16EXE   1
#define  NTEXE      2
#define  UNKNOWNEXE 10
#define  DHWSIZE  4096  //... # Bytes in szDHW global buffer

#ifdef RLRES16
#define  IDFLAG     0xFF
#define  HIBITVALUE 0x80
#else
#define  IDFLAG     0xFFFF
#define  HIBITVALUE 0x8000
#endif

#ifdef D262
#define STRINGSIZE( x ) ((x) * sizeof( TCHAR))
#else
#define STRINGSIZE( x ) ((x) * sizeof(CHAR))
#endif

#define MEMSIZE( x ) ((x) * sizeof( TCHAR))

        //... How many chars will fit in a buffer? (
#define WCHARSIN( x) ((x) / sizeof( WCHAR))
#define ACHARSIN( x) (x)

#ifdef UNICODE
#define TCHARSIN( x) WCHARSIN( x)
#else
#define TCHARSIN( x) ACHARSIN( x)
#endif

// String Resource IDs  (see rlquiked.h, rledit.h, rladmin.h)
#define IDS_READONLY        11
#define IDS_CLEAN           12
#define IDS_DIRTY           13
#define IDS_RESOURCENAMES   15// IDs 16-31 are reserved for resource names

// Resource types ID

#define ID_RT_CURSOR        1
#define ID_RT_BITMAP        2
#define ID_RT_ICON          3
#define ID_RT_MENU          4
#define ID_RT_DIALOG        5
#define ID_RT_STRING        6
#define ID_RT_FONTDIR       7
#define ID_RT_FONT          8
#define ID_RT_ACCELERATORS  9
#define ID_RT_RCDATA       10
#define ID_RT_ERRTABLE     11
#define ID_RT_GROUP_CURSOR 12
#define ID_RT_GROUP_ICON   14
#define ID_RT_NAMETABLE    15
#define ID_RT_VERSION      16
#define ID_RT_DLGINIT     240

// Important MENU flags
#define POPUP       0x0010
#define ENDMENU     0x0080

#define MFR_POPUP   0x0001

#define MYREAD   1
#define MYWRITE  2

#ifndef NOMINMAX

#ifndef max
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */


#define AllocateName( ptr, buf) (ptr) = (TCHAR *)FALLOC( MEMSIZE( lstrlen( (buf)) + 1))

typedef struct _tagMast
{
    CHAR szSrc[  MAXFILENAME];              //... Source resource file
    CHAR szMtk[  MAXFILENAME];              //... Master token file
    CHAR szRdfs[ MAXFILENAME];              //... Cust Res Descr file name
    CHAR szSrcDate[           MAXFILENAME]; //... Date stamp of szSrc
    CHAR szMpjLastRealUpdate[ MAXFILENAME]; //... Date of last update
    WORD wLanguageID;                       //... Language ID for master project
    UINT uCodePage;                         //... CP used to create tok file
} MSTRDATA, * PMSTRDATA;

typedef struct _tagProj
{
    CHAR szPRJ[ MAXFILENAME];               //... This project's Project File name
    CHAR szMpj[ MAXFILENAME];               //... Master project file
    CHAR szTok[ MAXFILENAME];               //... Project token file
    CHAR szBld[ MAXFILENAME];               //... Resource file to be built
    CHAR szGlo[ MAXFILENAME];               //... Glosary file for this project
    CHAR szTokDate[ MAXFILENAME];           //... Date of last update
    UINT uCodePage;                         //... CP used to create tok file
    WORD wLanguageID;                       //... Language ID for this project
    BOOL fSourceEXE;
    BOOL fTargetEXE;
} PROJDATA, * PPROJDATA;


#pragma pack(1)

typedef struct ResHeader
{
#ifdef RLRES32
    DWORD   lHeaderSize;
    DWORD   lDataVersion;
    WORD    wLanguageId;
    DWORD   lVersion;
    DWORD   lCharacteristics;
#endif
    BOOL    bTypeFlag;      /* Indicat's if ID or string */
    BOOL    bNameFlag;      /* Indicat's if ID or string */
    WORD    wTypeID;
    WORD    wNameID;
    TCHAR   *pszType;
    TCHAR   *pszName;
    WORD    wMemoryFlags;
    DWORD   lSize;

} RESHEADER;

typedef struct ControlData
{
    WORD    x;
    WORD    y;
    WORD    cx;
    WORD    cy;
    DWORD   dwID;
    DWORD   lStyle;
    BOOL    bClass_Flag;    /* Indicat's if ID or string */
    WORD    bClass;
    TCHAR   *pszClass;
    BOOL    bID_Flag;       /* Indicat's if ID or string */
    WORD    wDlgTextID;
    TCHAR   *pszDlgText;
#ifdef RLRES16
    WORD    unDefined;
#else
    WORD    wExtraStuff;
    DWORD   lExtendedStyle;
#endif
#ifdef PDK2
    WORD    wUnKnow;
    DWORD   dwExtra;
#endif
    DWORD   dwHelpID;
    BYTE    *pExtraStuff;
} CONTROLDATA;

typedef struct DialogHeader
{
    DWORD   lStyle;
    WORD    wNumberOfItems;
    WORD    x;
    WORD    y;
    WORD    cx;
    WORD    cy;
    BOOL    bClassFlag;    /* Indicat's if ID or string */
    WORD    wDlgClassID;
    TCHAR   *pszDlgClass;
    BOOL    bMenuFlag;      /* Indicat's if ID or string */
    WORD    wDlgMenuID;
    TCHAR   *pszDlgMenu;
    TCHAR   *pszCaption;
    WORD    wPointSize;
    TCHAR   *pszFontName;
    CONTROLDATA *pCntlData;
#ifdef RLRES32
    DWORD   lExtendedStyle;
    BOOL    bNameFlag;
    WORD    wDlgNameID;
    TCHAR   *pszDlgName;
#endif
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    short   wWeight;
    short   wItalic;
    BOOL    fDialogEx;

} DIALOGHEADER;


typedef struct MenuItem
{
    DWORD   dwType;
    DWORD   dwState;
    DWORD   dwMenuID;
    DWORD   dwHelpID;
    WORD    fItemFlags;
    TCHAR   *szItemText;
    struct  MenuItem *pNextItem;
} MENUITEM;

typedef struct MenuHeader
{
    WORD        wVersion;
    WORD        cbHeaderSize;
    MENUITEM    *pMenuItem;
    BOOL    fMenuEx;
    BYTE    *pExtraStuff;
} MENUHEADER;         

typedef struct StringHeader
{
	WORD   wChars[16];		    // # of characters in each string in this block
    TCHAR *pszStrings[16];      // Strings in this block
} STRINGHEADER;

// Version structures taken from ver.h and ver.dll code.

#ifndef RLRES32
#ifndef RLWIN32
typedef struct VS_FIXEDFILEINFO
{
    DWORD   dwSignature;    /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion; /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;    /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;    /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS; /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS; /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;    /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;    /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;       /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;     /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;  /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;   /* e.g. 0 */
    DWORD   dwFileDateLS;   /* e.g. 0 */
} VS_FIXEDFILEINFO;

#endif
#endif

typedef struct VERBLOCK
{
#ifdef RLRES32
    WORD  wLength;
    WORD  wValueLength;
    WORD  wType;
    WCHAR szKey[1];
#else
    int nTotLen;
    int nValLen;
    TCHAR szKey[1];
#endif
} VERBLOCK ;

typedef VERBLOCK * PVERBLOCK;



#define DWORDUP(x) (((x)+3)&~03)
#define DWORDUPOFFSET(x) (  (DWORDUP(x)) - (x) )


#define WORDUP(x) (((x)+1)&~01)
#define WORDUPOFFSET(x) (  (WORDUP(x)) - (x) )


typedef struct VERHEAD
{
    WORD wTotLen;
    WORD wValLen;
#ifdef RLRES32
    WORD wType;
#endif
    TCHAR szKey[( sizeof( TEXT("VS_VERSION_INFO" )) +3 )&~03];
    VS_FIXEDFILEINFO vsf;

} VERHEAD ;


typedef struct AccelTableEntry
{
    WORD fFlags;
    WORD wAscii;
    WORD wID;
#ifdef RLRES32
    WORD wPadding;
#endif
} ACCELTABLEENTRY;

typedef struct _tagDlgInitData
{
    struct _tagDlgInitData *pNext;
    WORD     wControlID;
    WORD     wMessageNumber;
    DWORD    dwStringLen;
    PCHAR    pszString;
} DLGINITDATA, * PDLGINITDATA;


#pragma pack()

// Menu item types

#define POPUP 0x0010

// function prototypes

DWORD             DWORDfpUP( FILE *, DWORD * );
void              ClearAccelTable ( ACCELTABLEENTRY * , WORD);
void              ClearMenu ( MENUHEADER * );
void              ClearDialog ( DIALOGHEADER * );
void              ClearResHeader ( RESHEADER );
void              ClearString ( STRINGHEADER * );
int               IsExe( char * );
int               IsRes( char * );
BOOL              IsWin32Res( CHAR *);
ACCELTABLEENTRY * GetAccelTable( FILE *, WORD *, DWORD * );
BYTE              GetByte ( FILE *, DWORD * );
void              GetBytes ( FILE *, DWORD * );
DWORD             GetdWord ( FILE *, DWORD * );
DIALOGHEADER    * GetDialog( FILE *, DWORD * );
void              GetName  ( FILE *, TCHAR *, DWORD * );
int               MyGetTempFileName(BYTE  , LPSTR, WORD, LPSTR);
WORD              GetWord  ( FILE *, DWORD * );
void              GetResMenu  ( FILE *, DWORD * , MENUHEADER *);
int               GenerateImageFile( char *, char *, char *, char *, WORD );
int               GenerateTokFile( char *, char *, BOOL *, WORD);
void              GenStatusLine( TOKEN * );
int               GetResHeader( FILE *, RESHEADER UNALIGNED *, DWORD *);
STRINGHEADER    * GetString( FILE *, DWORD * );
BOOL              isdup ( WORD, WORD *, WORD );
FILE            * OpenGlossary( CHAR *, CHAR);
int               MakeGlossIndex( long *);
int               TransString( TCHAR *, TCHAR *, TRANSLIST **, LONG *);
void              AddTranslation( TCHAR *szKey,
                                  TCHAR *szTranslation,
                                  LONG *lFilePointer);
void              ParseTokCrd( TCHAR *, 
                               WORD UNALIGNED *, 
                               WORD UNALIGNED *, 
                               WORD UNALIGNED *, 
                               WORD UNALIGNED * );
void              ParseTok( TCHAR *, TOKEN * );
void              PutAccelTable( FILE *,
                                 FILE *,
                                 RESHEADER,
                                 ACCELTABLEENTRY *,
                                 WORD );
void              PutByte ( FILE *, TCHAR, DWORD * );
void              PutDialog( FILE * , FILE *, RESHEADER , DIALOGHEADER *);
void              PutMenu( FILE * , FILE *, RESHEADER , MENUHEADER *);
void              PutMenuItem( FILE * , MENUITEM *, DWORD *, BOOL);
void              PutMenuRes( FILE * , MENUITEM *, DWORD *);
void              PutOrd( FILE *, WORD , TCHAR * , DWORD *);
int               PutResHeader( FILE *, RESHEADER , fpos_t * , DWORD * );
void              PutWord ( FILE *, WORD, DWORD * );
void              PutString ( FILE *, TCHAR *, DWORD * );
void              PutStrHdr ( FILE *, FILE *, RESHEADER, STRINGHEADER *);
void              PutdWord( FILE *, DWORD  , DWORD * );
BOOL              MergeTokFiles( FILE *, FILE *, FILE * );
void              DoExit( int nErrCode);
void              QuitA( int, LPSTR, LPSTR);

#ifdef UNICODE

void              QuitW( int, LPWSTR, LPWSTR);

#define QuitT QuitW

#else  // UNICODE

#define QuitT QuitA

#endif // UNICODE

void              GenerateRESfromRESandTOKandRDFs(CHAR * szTargetRES,
                                                  CHAR * szSourceRES,
                                                  CHAR * szTOK,
                                                  CHAR * szRDFs,
                                                  WORD wFilter);
void              SkipBytes( FILE *, DWORD * );
WORD              ReadHeaderField( FILE * , DWORD * );
void              ReadInRes( FILE *, FILE *, DWORD *);
BOOL              ResReadBytes( FILE *, char *, size_t, DWORD *);
int               ReadWinRes( FILE *, FILE *, FILE *, BOOL, BOOL, WORD );
void              ShowEngineErr( int, void *, void *);
void              TokAccelTable ( FILE *, RESHEADER, ACCELTABLEENTRY *, WORD);
void              TokDialog( FILE *, RESHEADER, DIALOGHEADER  *);
void              TokMenu( FILE *, RESHEADER, MENUHEADER * );
void              TokString( FILE *, RESHEADER, STRINGHEADER * );
WORD              UpdateResSize( FILE *, fpos_t *, DWORD );
void              UnGetByte( FILE *, BYTE, DWORD * );
void              UnGetWord( FILE *, WORD, DWORD * );
void              WordUpFilePointer( FILE *, BOOL, LONG, LONG, LONG *);
void              DWordUpFilePointer( FILE *, BOOL, LONG, DWORD *);

#ifdef RLRES32

WORD              GetResVer( FILE *, DWORD *, VERHEAD *, VERBLOCK **);
int       TokResVer( FILE *, RESHEADER, VERBLOCK *, WORD);
DWORD             FixCheckSum( LPSTR);

#else

int       GetResVer( FILE *, DWORD *, VERHEAD *, VERBLOCK **);
int       TokResVer( FILE *, RESHEADER, VERBLOCK *);

#endif

int       PutResVer( FILE *, FILE * , RESHEADER, VERHEAD *, VERBLOCK *);

PDLGINITDATA  GetDlgInit( FILE *, DWORD *);
void          TokDlgInit( FILE *, RESHEADER, PDLGINITDATA);
void          PutDlgInit( FILE *, FILE *, RESHEADER, PDLGINITDATA);
void          ClearDlgInitData( PDLGINITDATA);

#endif // _RESTOK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\reswin16.h ===
int ExtractResFromExe16A( CHAR *szInputExe,
                          CHAR *szOutputRes,
                          WORD   wFilter);

int BuildExeFromRes16A( CHAR *szTargetExe,
                        CHAR *szSourceRes,
                        CHAR *szSourceExe);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\reswin16.c ===
#include <windows.h>
#include <stdio.h>

#include "restok.h"
#include "reswin16.h"
#include "rlmsgtbl.h"


//.............................................................................

int ExtractResFromExe16A(

CHAR *szInputExe, 
CHAR *szOutputRes, 
WORD wFilter)
{
    szInputExe;
    szOutputRes; 
    wFilter;

    QuitT( IDS_NO16RESWINYET, NULL, NULL);

    return(-1);
}

//.............................................................................

int BuildExeFromRes16A(

CHAR *pstrDest,
CHAR *pstrRes,
CHAR *pstrSource )
{
    pstrDest;
    pstrRes;
    pstrSource;

    QuitT( IDS_NO16WINRESYET, NULL, NULL);

    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\showerrs.c ===
#include <windows.h>

#include <stdio.h>

#include "restok.h"
#include "showerrs.h"


extern UCHAR szDHW[];
extern CHAR  szAppName[];

//............................................................

void ShowEngineErr( int n, void *p1, void *p2)
{
    CHAR *pMsg = NULL;
    CHAR *pArg[2];


    pArg[0] = p1;
    pArg[1] = p2;


    if ( B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                        | FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         NULL,
                         (DWORD)n,
                         szDHW,
                         DHWSIZE,
                         (va_list *)pArg) )
    {
        RLMessageBoxA( szDHW);
    }
    else
    {

        sprintf( szDHW,
                 "Internal error: FormatMessage call failed: msg %d: err %Lu",
                 n,
                 GetLastError());

        RLMessageBoxA( szDHW);

    }
}

//...................................................................

void ShowErr( int n, void *p1, void *p2)
{
    CHAR *pMsg = NULL;
    CHAR *pArg[2];

    pArg[0] = p1;
    pArg[1] = p2;

    pMsg = GetErrMsg( n);

    if ( ! pMsg )
    {
        pMsg = "Internal error: UNKNOWN ERROR MESSAGE id# %1!d!";
        pArg[0] = IntToPtr(n);
    }

    if ( pMsg )
    {
        if ( FormatMessageA( FORMAT_MESSAGE_MAX_WIDTH_MASK | 72
                            | FORMAT_MESSAGE_FROM_STRING
                            | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                             pMsg,
                             0,
                             0,
                             szDHW,
                             DHWSIZE,
                             (va_list *)pArg) )
        {
            RLMessageBoxA( szDHW);
        }
        else
        {
            RLMessageBoxA( "Internal error: FormatMessage call failed");
        }
    }
    else
    {
        RLMessageBoxA( "Internal error: GetErrMsg call failed");
    }
}

//............................................................

CHAR *GetErrMsg( UINT uErrID)
{
    static CHAR szBuf[ 1024];

    int n = LoadStringA( NULL, uErrID, szBuf, sizeof( szBuf));

    return( n ? szBuf : NULL);
}

//.......................................................
//...
//... Bi-Lingual FormatMessage

DWORD B_FormatMessage(

DWORD    dwFlags,
LPCVOID  lpSource,
DWORD    dwMessageId,
LPSTR    lpBuffer,
DWORD    nSize,
va_list *Arguments )
{

    DWORD ret;
                                //... Look for message in current locale
    if ( !(ret = FormatMessageA( dwFlags,
                                 lpSource,
                                 dwMessageId,
	                             LOWORD( GetThreadLocale()),
	                             lpBuffer,
	                             nSize,
	                             Arguments)) )
    {
                                //... Not found, so look for US English message

        if ( GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND )
        {
            return( FormatMessageA( dwFlags,
                                    lpSource,
                                    dwMessageId,
                                    0x0409L,
                                    lpBuffer,
                                    nSize,
                                    Arguments) );
        }
    }
    return( ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\rlstrngs.h ===
#ifndef _RLSTRNGS_H_
#define _RLSTRNGS_H_

// String IDs
#define IDS_ERR_REGISTER_CLASS  1
#define IDS_ERR_CREATE_WINDOW   2
#define IDS_ERR_NO_HELP     3
#define IDS_ERR_NO_MEMORY   4
#define IDS_NOT_IMPLEMENTED 5
#define IDS_GENERALFAILURE  6
#define IDS_MPJ             7
#define IDS_RES_SRC         8
#define IDS_RES_BLD         9
#define IDS_TOK             10
#define IDS_READONLY        11
#define IDS_CLEAN           12
#define IDS_DIRTY           13
#define IDS_FILENOTFOUND    14
#define IDS_FILESAVEERR     15
#define IDS_RESOURCENAMES   15  // Incremented by res type # in rlstrngs.rc
                     // 16-31 used for Resource Type names
#define IDS_ERR_00  32
#define IDS_ERR_01  33
#define IDS_ERR_02  34
#define IDS_ERR_03  35
#define IDS_ERR_04  36
#define IDS_ERR_05  37
#define IDS_ERR_06  38
#define IDS_ERR_07  39
#define IDS_ERR_08  40
#define IDS_ERR_09  41
#define IDS_ERR_10  42
#define IDS_ERR_11  43
#define IDS_ERR_12  44
#define IDS_ERR_13  45
#define IDS_ERR_14  46
#define IDS_ERR_15  47
#define IDS_ERR_16  48
#define IDS_ERR_17  49
#define IDS_ERR_18  50
#define IDS_ERR_19  51
#define IDS_ERR_20  52
#define IDS_ERR_21  53
#define IDS_ERR_22  54
#define IDS_ERR_23  55
#define IDS_ERR_24  56
#define IDS_ERR_25  57
#define IDS_ERR_26  58
#define IDS_ERR_27  59
#define IDS_ERR_28  60


#define IDS_RLE_APP_NAME        64
#define IDS_RLQ_APP_NAME        65
#define IDS_RLA_APP_NAME        66
#define IDS_ERR_NO_GLOSSARY     70
#define IDS_ERR_NO_TOKEN        71
#define IDS_ERR_TMPFILE         72

#define IDS_RDF                 80
#define IDS_MTK                 81
#define IDS_GLOSS               86
#define IDS_RDFSPEC             87
#define IDS_PRJSPEC             88
#define IDS_RESSPEC             89
#define IDS_EXESPEC             90
#define IDS_TOKSPEC             91
#define IDS_MTKSPEC             92
#define IDS_MPJSPEC             93
#define IDS_DLLSPEC             94
#define IDS_CPLSPEC             95
#define IDS_GLOSSSPEC           96

#define IDS_MPJERR              112
#define IDS_MPJOUTOFDATE        113
#define IDS_UPDATETOK           114
#define IDS_REBUILD_TOKENS      115
#define IDS_TOKEN_FOUND         116
#define IDS_TOKEN_NOT_FOUND     117
#define IDS_FIND_TOKEN          118
#define IDS_OPENTITLE           119
#define IDS_SAVETITLE           120
#define IDS_ADDGLOSS            121
#define IDS_RLE_CANTSAVEASEXE   122
#define IDS_SAVECHANGES         123
#define IDS_NOCHANGESYET        124
#define IDS_CHANGED             125
#define IDS_UNCHANGED           126
#define IDS_NEW                 127
#define IDS_DRAGMULTIFILE       129
#define IDS_CANTSAVEASRES       130
#define IDS_RLQ_CANTSAVEASEXE   131
#define IDS_RLQ_CANTSAVEASRES   132

// 3100-3109 are reserved by RLQuikEd and RLRdit for resource editing tools.
// A resource is given a menu item that passes this value for it's
// command parameter.  A corresponding string must exist in the string
// table indicating the name of the editer to be invoked.
//
// When the user selects the menu item, it generates the appropriate command.
// When RLQuikEd recieves a command in the IDM_FIRST_EDIT and IDM_LAST_EDIT range
// it saves all the tokens and builds a temporary resource file.
// RLQuikEd then retrieves the name of the editer from the string table and
// performs a WinExec command on the temporary resource file.
// When control is returned to RLQuikEd (the user closes the resource editor)
// the token file is rebuilt from the edited resource file, the temporary
// resource file is deleted, and the tokens are loaded back into the system.

#define IDM_FIRST_EDIT  3100
#define IDM_LAST_EDIT   3109


#endif //_RLSTRNGS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\restok.c ===
//#include <assert.h>
#include <ctype.h>
#include <malloc.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
//#include <string.h>

#include <tchar.h>

#ifdef RLDOS
    #include "dosdefs.h"

#else
    #include <windows.h>
    #include "windefs.h"
#endif

#include "restok.h"
#include "custres.h"
#include "ntmsgtbl.h"
#include "rlmsgtbl.h"
#include "resread.h"
#include "projdata.h"

//B_FormatMessage prototype
#include "showerrs.h"

#define SAME  0     //... Used in string comparisons

#define STRINGFILEINFO (TEXT("StringFileInfo"))
#define VARFILEINFO    (TEXT("VarFileInfo"))
#define TRANSLATION    (TEXT("Translation"))
#define LANGUAGEINFO   (TEXT("Language Info"))

#define STRINGFILEINFOLEN  (lstrlen( (TCHAR *)STRINGFILEINFO) + 1)
#define VARFILEINFOLEN     (lstrlen( (TCHAR *)VARFILEINFO) + 1)
#define TRANSLATIONLEN     (lstrlen( (TCHAR *)TRANSLATION) + 1)

#define LANGSTRINGLEN  8    //... # WCHARs in string denoting language
//... and code page in a Version resource.

#define TRANSDATALEN   2    //... # bytes in a Translation value

#define VERTYPEBINARY  0    //... Version data value is binary
#define VERTYPESTRING  1    //... Version data value is a string
#define VERMEM      2048    //... Fixed size of buffer for new version stamp

//... Decrement WORD at *pw by given amount w
#define DECWORDBY( pw,w) if (pw) { *(pw) = (*(pw) > (w)) ? *(pw) - (w) : 0;}

//... Increment WORD at *pw by given amount w
#define INCWORDBY( pw,w) if (pw) { *(pw) += (w);}

//... How many BYTES in the given string?
#define BYTESINSTRING(s) (lstrlen( (TCHAR *)s) * sizeof( TCHAR))

//... Dialog box controls (from RC.H)
#define BUTTON  0x80
#define EDIT    0x81
#define STATIC  0x82



PVERBLOCK MoveAlongVer( PVERBLOCK, WORD *, WORD *, WORD *);
BOOL      FilterRes( WORD, RESHEADER *);
TCHAR    *GetVerValue( PVERBLOCK);
void      PutNameOrd( FILE *, BOOL, WORD , TCHAR *, DWORD *);
void      GetNameOrd( FILE *,
                      BOOL UNALIGNED*,
                      WORD UNALIGNED*,
                      TCHAR *UNALIGNED*,
                      DWORD *);
void  CopyRes( FILE      *fpInResFile,
               FILE      *fpOutResFile,
               RESHEADER *pResHeader,
               fpos_t    *pResSizePos);

BOOL fInThirdPartyEditer = FALSE;//.. Are we in a 3rd-party resource editor?
BOOL fInQuikEd   = FALSE;       //... Are we in RLQuiked? (see rlquiked.c)
BOOL gfShowClass = FALSE;       //... Set TRUE to put dlg box elemnt class
                                //... in token file
#if defined(DBCS)
BOOL gfExtendedTok = TRUE;     //... Set TRUE if -x is choosen
#else
BOOL gfExtendedTok = FALSE;     //... Set TRUE if -x is choosen
#endif

#ifdef _DEBUG
extern PMEMLIST pMemList;
#endif

#ifdef RLRES32
    #ifndef CAIRO
extern VOID *pResMsgData;       // NT-specific Message Table resource
    #endif //RLRES32
#endif //CAIRO
extern BOOL  gbMaster;          //... TRUE if we are working on a Master Project
extern BOOL  gfReplace;         //... FALSE if appending new language to existing resources
extern BOOL  gbShowWarnings;    //... Display warnining messages if TRUE
extern UCHAR szDHW[];

extern char * gszTmpPrefix;

MSTRDATA gMstr =                //... Data from Master Project file (MPJ)
{                               //... Fields filled in main (UI)
    "",
    "",
    "",
    "",
    "",
    MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US),
    CP_ACP                      //... System default Windows code page
};

PROJDATA gProj =                //... Data from Project file (PRJ)
{                               //... Fields filled in main (UI)
    "",
    "",
    "",
    "",
    "",
    "",
    CP_ACP,     //... System default Windows code page
    MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US),
    FALSE,
    FALSE
};


/**
  * Function: ReadWinRes
  *
  * The main resource Read/Writer function to process  the resource file to be
  * localzied.
  *
  * ReadWinRes reads the resource header to determine the current resource type,
  * then executes the corresponding Get/Put resource functions to extract and
  * insert localized information contained in the resource file.  ReadWinRes, is
  * excuted in two modes, Tokenize, and Generate. During Tokenize mode,
  * ReadWinRes writes all the localized information contained in the resouce to
  * a token file.  During Generate mode, ReadWinRes, replaces all the localized
  * information in the input resource file, with the corresponding information
  * in the token file to gernerate a localized resource file.
  *
  * Currently the following resouce types are supported.
  *
  *     Version Stamping.
  *     Menus.
  *     Dialogs.
  *     Accelerators.
  *     String Tables.
  *     Version Stamps
  *     Message Tables (NT)
  *
  * Arguments:
  *
  * InResFile,  Handle to binary input resource file.
  * OutFesFile, Handle to binary output resouce file. Not used during tokenize
  *             mode.
  * TokFile,    Handle to  text token file.
  * BOOL,       flag to indicate whether to build output resource file.
  * BOOL,       flag to indicate whether to build token file.
  *
  *
  *  Returns:
  * ???
  *
  *  Errors Codes:
  * ???
  *
  *  History:
  * 10/91  Added Version stamping support.                          TerryRu
  * 11/91, Completed Version stamping support.                      TerryRu
  *
  *
  **/


int ReadWinRes(

              FILE *InResFile,
              FILE *OutResFile,
              FILE *TokFile,
              BOOL  fBuildRes,
              BOOL  fBuildTok,
              WORD  wFilter)
{
    BOOL             fDoAccel = TRUE;   // set FALSE to not build accelerators
    MENUHEADER      *pMenuHdr = NULL;   // Linked list of Menu info.
    static RESHEADER ResHeader;         // Structure contain Resource Header info.
    VERBLOCK        *pVerBlk = NULL;    // Memory block containing Version Stamping String File Block,
    static VERHEAD   VerHdr;            // Memory block containing Version Stamping Header info
    DIALOGHEADER    *pDialogHdr = NULL; // Linked list of Dialog info
    STRINGHEADER    *pStrHdr = NULL;    // Array of String Tables.
    ACCELTABLEENTRY *pAccelTable = NULL;// Array of Accelerator Keys
    WORD            wcTableEntries = 0; // Number of Accelerator tables
    fpos_t          ResSizePos = 0;     // Position of lSize field in the
                                        //   Resource Header, used to fixup
                                        //   the Header once the size of the
                                        //   localized information is determined.
    CUSTOM_RESOURCE *pCustomResource = NULL;
    LONG            lEndOffset = 0L;


    //... How large is the res file?
    fseek( InResFile, 0L, SEEK_END);
    lEndOffset = ftell( InResFile);

    rewind( InResFile);

    //... process until end of input file

    while ( ! feof( InResFile) ) {
        LONG lCurrOffset = 0L;


        lCurrOffset = (LONG)ftell( InResFile);

        if ( (lCurrOffset + (LONG)sizeof( RESHEADER)) >= lEndOffset ) {
            return 0;
        }

        if ( GetResHeader( InResFile, &ResHeader, (DWORD *) NULL) == -1 ) {
            return (1);
        }
        //... Is this the dummy, res32-identifying, res?

        if ( ResHeader.lSize == 0L ) {                       //... Yes, we so simply copy the header if we
                                                             //... are building a res file.
            if ( fBuildRes ) {
                CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
            }

#ifdef RLRES32

            else {
                if ( gbShowWarnings && OutResFile && ftell( OutResFile) != 0L ) {
                    lstrcpyA( szDHW, "type");

                    if ( ResHeader.wTypeID == IDFLAG ) {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " \"%s\"",
                                 ResHeader.pszType);
                    } else {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " %hu,",
                                 ResHeader.wTypeID);
                    }
                    strcat( szDHW, " name");

                    if ( ResHeader.wNameID == IDFLAG ) {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " \"%s\"",
                                 ResHeader.pszName);
                    } else {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " %hu,",
                                 ResHeader.wNameID);
                    }
                    sprintf( &szDHW[ lstrlenA( szDHW)],
                             " pri-lang %#hx sub-lang %#hx",
                             PRIMARYLANGID( ResHeader.wLanguageId),
                             SUBLANGID( ResHeader.wLanguageId));

                    ShowEngineErr( IDS_ZERO_LEN_RES, szDHW, NULL);
                }
                DWordUpFilePointer( InResFile, MYREAD, ftell( InResFile), NULL);

                if (OutResFile != NULL) {
                    DWordUpFilePointer( OutResFile,
                                        MYWRITE,
                                        ftell(OutResFile),
                                        NULL);
                }
            }
#endif
            ClearResHeader( ResHeader);
            continue;           //... Ship this dummy header
        }
        //... Check to see if we want to filter out this
        //... resource type.

        if ( FilterRes( wFilter, &ResHeader) ) {
            //... skip this resource type

            SkipBytes( InResFile, (DWORD *)&ResHeader.lSize);

#ifdef RLRES32

            DWordUpFilePointer( InResFile, MYREAD, ftell( InResFile), NULL);

#endif
            ClearResHeader( ResHeader);
            continue;
        }

        if ( fBuildTok ) {
            if ( ResHeader.wLanguageId != (fInThirdPartyEditer
                                           ? gProj.wLanguageID
                                           : gMstr.wLanguageID) ) {
                //... Skip this resource (wrong lanugage)

                if ( gbShowWarnings ) {
                    lstrcpyA( szDHW, "type");

                    if ( ResHeader.wTypeID == IDFLAG ) {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " \"%s\"",
                                 ResHeader.pszType);
                    } else {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " %u,",
                                 ResHeader.wTypeID);
                    }
                    strcat( szDHW, " name");

                    if ( ResHeader.wNameID == IDFLAG ) {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " \"%s\"",
                                 ResHeader.pszName);
                    } else {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " %u,",
                                 ResHeader.wNameID);
                    }
                    sprintf( &szDHW[ lstrlenA( szDHW)],
                             " pri-lang %#x sub-lang %#x",
                             PRIMARYLANGID( ResHeader.wLanguageId),
                             SUBLANGID( ResHeader.wLanguageId));

                    ShowEngineErr( IDS_SKIP_RES,
                                   LongToPtr(ResHeader.lSize),
                                   szDHW);
                }
                SkipBytes( InResFile, (DWORD *)&ResHeader.lSize);

#ifdef RLRES32

                DWordUpFilePointer( InResFile, MYREAD, ftell(InResFile), NULL);

#endif
                ClearResHeader( ResHeader);
                continue;
            }
        } else if ( fBuildRes ) {
            if ( gfReplace ) {
                if ( ResHeader.wLanguageId == gMstr.wLanguageID ) {
                    ResHeader.wLanguageId = gProj.wLanguageID;
                } else {
                    //... Copy this resource

                    CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
                    ClearResHeader( ResHeader);
                    continue;
                }
            } else {    //... ! gfReplace
                if ( ResHeader.wLanguageId == gMstr.wLanguageID ) {
                    fpos_t lFilePos = 0L;
                    DWORD  lTmpSize = 0L;

                    lFilePos = ftell( InResFile);   //... Save file position
                    lTmpSize = ResHeader.lSize;     //... and resource size

                    //... Duplicate this resource

                    CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
                    fseek( InResFile, (long)lFilePos, SEEK_SET);
                    ResHeader.wLanguageId = gProj.wLanguageID;
                    ResHeader.lSize       = lTmpSize;
                } else {
                    //... Simply copy this resource if not target language

                    if ( ResHeader.wLanguageId == gProj.wLanguageID ) {
                        SkipBytes( InResFile, (DWORD *)&ResHeader.lSize);

#ifdef RLRES32
                        DWordUpFilePointer( InResFile, MYREAD, ftell( InResFile), NULL);
#endif
                    } else {
                        CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
                    }
                    ClearResHeader( ResHeader);
                    continue;
                }
            }
        }

        switch ( ResHeader.wTypeID ) {
            case ID_RT_ACCELERATORS:

                pAccelTable = GetAccelTable(InResFile,
                                            &wcTableEntries,
                                            (DWORD *)&ResHeader.lSize);
                if (fBuildTok) {
                    TokAccelTable(TokFile,
                                  ResHeader,
                                  pAccelTable,
                                  wcTableEntries);
                }

                if (fBuildRes) {
                    PutAccelTable(OutResFile,
                                  TokFile,
                                  ResHeader,
                                  pAccelTable,
                                  wcTableEntries);
                }

                ClearAccelTable (pAccelTable , wcTableEntries);
                break;

            case ID_RT_DIALOG:

                pDialogHdr = GetDialog(InResFile, (DWORD *)&ResHeader.lSize);

                if (fBuildTok == TRUE) {
                    TokDialog(TokFile, ResHeader, pDialogHdr);
                }

                if (fBuildRes == TRUE) {
                    PutDialog(OutResFile, TokFile, ResHeader, pDialogHdr);
                }
                ClearDialog (pDialogHdr);

                break;

            case ID_RT_DLGINIT:
                {
                    PDLGINITDATA pDlgInit = GetDlgInit( InResFile, (DWORD *)&ResHeader.lSize);

                    if ( fBuildTok ) {
                        TokDlgInit( TokFile, ResHeader, pDlgInit);
                    }

                    if ( fBuildRes ) {
                        PutDlgInit( OutResFile, TokFile, ResHeader, pDlgInit);
                    }
                    ClearDlgInitData( pDlgInit);
                    break;
                }
            case ID_RT_MENU:
                // allocate space for a new header

                pMenuHdr = (MENUHEADER *)FALLOC( sizeof( MENUHEADER));
                GetResMenu(InResFile, (DWORD *)&ResHeader.lSize, pMenuHdr);

                if (fBuildTok == TRUE) {
                    TokMenu(TokFile, ResHeader, pMenuHdr);
                }

                if (fBuildRes == TRUE) {
                    PutMenu(OutResFile, TokFile, ResHeader, pMenuHdr);
                }

                ClearMenu(pMenuHdr);

                break;

            case ID_RT_STRING:

                pStrHdr = GetString(InResFile, (DWORD *)&ResHeader.lSize);

                if (fBuildTok == TRUE) {
                    TokString(TokFile, ResHeader, pStrHdr);
                }

                if (fBuildRes == TRUE) {
                    PutStrHdr(OutResFile, TokFile, ResHeader, pStrHdr);
                }

                ClearString(pStrHdr);

                break;

#ifdef RLRES32
    #ifndef CAIRO
                // we currently only do Error tables under NT,
                // under CAIRO we ignore them

            case ID_RT_ERRTABLE:    //... NT-specific Message Table resource

                pResMsgData = GetResMessage(InResFile, (DWORD *)&ResHeader.lSize);

                if (! pResMsgData) {
                    QuitT( IDS_ENGERR_13, (LPTSTR)IDS_MSGRESTBL, NULL);
                }

                if (fBuildTok == TRUE) {
                    TokResMessage(TokFile, ResHeader, pResMsgData);
                }

                if (fBuildRes == TRUE) {
                    PutResMessage(OutResFile, TokFile, ResHeader, pResMsgData);
                }

                ClearResMsg( &pResMsgData);

                break;
    #endif
#endif

#ifndef CAIRO

            case ID_RT_VERSION:
                {
                    WORD wRead = 0;


                    wRead = GetResVer(InResFile,
                                      (DWORD *)&ResHeader.lSize,
                                      &VerHdr,
                                      &pVerBlk);

    #ifdef RLRES32
                    if (wRead == (WORD)-1)
    #else
                    if (wRead == FALSE)
    #endif
                    {
                        QuitT( IDS_ENGERR_14, (LPTSTR)IDS_VERBLOCK, NULL);
                    }

                    // Building Tok file ?
                    // but only tokenize it if it contains a Version Block

                    if ( pVerBlk && fBuildTok == TRUE ) {
    #ifdef RLRES32
                        TokResVer( TokFile, ResHeader, pVerBlk, wRead);
    #else
                        TokResVer( TokFile, ResHeader, pVerBlk);
    #endif
                    }

                    // Building Res file ?

                    if ( fBuildRes == TRUE ) {
                        PutResVer( OutResFile, TokFile, ResHeader,&VerHdr, pVerBlk);
                    }
                    RLFREE( pVerBlk);
                }
                break;
#else
            case ID_RT_VERSION:
#endif

            case ID_RT_CURSOR:
            case ID_RT_BITMAP:
            case ID_RT_ICON:
            case ID_RT_FONTDIR:
            case ID_RT_FONT:
            case ID_RT_RCDATA:
#ifndef RLRES32
            case ID_RT_ERRTABLE:    //... NT-specific Message Table resourc
#endif
            case ID_RT_GROUP_CURSOR:
            case ID_RT_GROUP_ICON:
            case ID_RT_NAMETABLE:
            default:

                if (GetCustomResource(InResFile,
                                      (DWORD *)&ResHeader.lSize,
                                      &pCustomResource,
                                      ResHeader)) {
                    // Non localized resource type, skip or copy it

                    if (fBuildTok == TRUE) {
                        if ( gbShowWarnings
                             && ( ResHeader.wTypeID == ID_RT_RCDATA
                                  || ResHeader.wTypeID >  16) ) {
                            static CHAR szType[256];
                            static CHAR szName[256];

                            if ( ResHeader.bTypeFlag == IDFLAG )
                                sprintf( szType, "%u", ResHeader.wTypeID);
                            else {
                                _WCSTOMBS( &szType[1], ResHeader.pszType, sizeof( szType), (UINT)-1);
                                szType[0] = '\"';
                                szType[ lstrlenA( szType)] = '\"';
                            }

                            if ( ResHeader.bNameFlag == IDFLAG )
                                sprintf( szName, "%u", ResHeader.wNameID);
                            else {
                                _WCSTOMBS( &szName[1], ResHeader.pszName, sizeof( szName), (UINT)-1);
                                szName[0] = '\"';
                                szName[ lstrlenA( szName)] = '\"';
                            }
                            ShowEngineErr( IDS_UNK_CUST_RES, (void *)szType, (void *)szName);
                        }
                        SkipBytes(InResFile, (DWORD *)&ResHeader.lSize);
                    } else if ( fBuildRes ) {
                        CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
                    }
                } else {
                    if (fBuildTok == TRUE) {
                        TokCustomResource(TokFile, ResHeader, &pCustomResource);
                    }

                    if (fBuildRes == TRUE) {
                        PutCustomResource(OutResFile,
                                          TokFile,
                                          ResHeader,
                                          &pCustomResource);
                    }
                    ClearCustomResource(&pCustomResource);
                }

#ifdef RLRES32
                DWordUpFilePointer(InResFile, MYREAD, ftell(InResFile), NULL);

                if (OutResFile != NULL) {
                    DWordUpFilePointer(OutResFile,
                                       MYWRITE,
                                       ftell(OutResFile),
                                       NULL);
                }
#endif
                break;
        }   //... END SWITCH

#ifndef RLRES32
        // skip any extra bytes (Win 3.1 exes have
        // alot of extra stuff!).
        // No extra stuff in res extracted from NT exes

        SkipBytes(InResFile, (DWORD *)&ResHeader.lSize);
#endif

        ClearResHeader(ResHeader);

#ifdef RLRES32

        DWordUpFilePointer(InResFile, MYREAD, ftell(InResFile), NULL);

        if (OutResFile != NULL) {
            DWordUpFilePointer(OutResFile, MYWRITE, ftell(OutResFile), NULL);
        }
#endif

    }   // END while ( ! feof( InResFile)

    return 0;
}



/**
  *
  *
  *  Function:ClearAccelTable
  * Removes the accelerator table array from memory.
  *
  *  Arguments:
  * pAccelTable, pointer to arary of accelerators
  * wctablesEntries, number of accelerators in arrary
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented               Terryru
  *
  *
  **/

void ClearAccelTable(ACCELTABLEENTRY *pAccelTable, WORD wcTableEntries)
{
    RLFREE( pAccelTable);
}


/**
  *
  *
  *  Function: ClearDialog
  * Remove Dialog defintions from memory.
  *
  *  Arguments:
  * pDilaogHdr, Linked list of dialog information.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented               TerryRu
  *
  *
  **/


void ClearDialog (DIALOGHEADER * pDialogHdr)
{
    BYTE i;

    for (i = 0; i < (BYTE) pDialogHdr->wNumberOfItems; i ++) {
        if (pDialogHdr->pCntlData[i].pszClass) {
            RLFREE( pDialogHdr->pCntlData[i].pszClass);
        }

        if ( pDialogHdr->pCntlData[i].pExtraStuff ) {
            RLFREE( pDialogHdr->pCntlData[i].pExtraStuff );
        }

        RLFREE( pDialogHdr->pCntlData[i].pszDlgText);
    }
    // now RLFREE fields in dialog header
    RLFREE( pDialogHdr->pszDlgClass);
    RLFREE( pDialogHdr->pszFontName);
    RLFREE( pDialogHdr->pszDlgMenu);
    RLFREE( pDialogHdr->pszCaption);
    RLFREE( pDialogHdr->pCntlData);

    // and finally clear header
    RLFREE( pDialogHdr);
}



/**
  *
  *
  *  Function: ClearMenu
  * Removes Menu defintions from memory.
  *
  *  Arguments:
  * pMenuHdr, linked list of Menu info
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented.              TerryRu
  *
  *
  **/

void ClearMenu(MENUHEADER *pMenuHdr)
{
    MENUITEM *pMenuItem;
    MENUITEM *pMenuHead;

    pMenuItem = pMenuHead = pMenuHdr->pMenuItem;

    // remove all the menu items from the list
    while (pMenuItem) {
        pMenuItem = pMenuHead->pNextItem;
        RLFREE( pMenuHead->szItemText);
        RLFREE( pMenuHead);
        pMenuHead = pMenuItem;
    }

    // now remove the menuheader
    if (pMenuHdr->pExtraStuff)
        RLFREE( pMenuHdr->pExtraStuff );

    RLFREE( pMenuHdr);
}



/**
  *
  *
  *  Function: ClearResHeader
  * Remove resheader name, and type fields from memory.
  *
  *  Arguments:
  * ResHdr, structure containing resheader info.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented               TerryRu.
  *
  *
  **/

void ClearResHeader(RESHEADER ResHdr)
{
    RLFREE( ResHdr.pszType);
    RLFREE( ResHdr.pszName);
}




/**
  *
  *
  *  Function: ClearString
  * Removes the StringTable Defintions from memory.
  *
  *  Arguments:
  * pStrHdr, pointer to array of 16 string tables.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented.              TerryRu
  *
  *
  **/

void ClearString( STRINGHEADER *pStrHdr)
{
    BYTE i;

    for (i = 0; i < 16; i++) {
        RLFREE( pStrHdr->pszStrings[i]);
    }
    RLFREE( pStrHdr);
}


/**
  *
  *
  *  Function: quit
  * quit, Error Handling routine used to display error code and terminate program
  *
  *  Arguments:
  * error, number of error.
  * pszError, descriptive error message.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  *
  *
  *  History:
  * 7/91, Implemented                   TerryRu
  * 10/91, Hacked to work under windows         TerryRu
  * ??? Need to add better win/dos support
  *
  **/

void QuitA( int error, LPSTR pszArg1, LPSTR pszArg2)
{
    char  szErrStr1[2048] = "*?*";
    char  szErrStr2[2048] = "*?*";
    char *psz1 = pszArg1;
    char *psz2 = pszArg2;

    //... clean up after error and exit,
    //... returning error code
    _fcloseall();

    if ( pszArg1 != NULL && pszArg1 <= (LPSTR)0x0000ffff ) {

        B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | FORMAT_MESSAGE_FROM_HMODULE,
                         NULL,
                         (DWORD)(DWORD_PTR)pszArg1,
                         szErrStr1,
                         sizeof( szErrStr1),
                         NULL);
        psz1 = szErrStr1;
    }

    if ( pszArg2 != NULL && pszArg2 < (LPSTR)0x0000ffff ) {

        B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | FORMAT_MESSAGE_FROM_HMODULE,
                         NULL,
                         (DWORD)(DWORD_PTR)pszArg2,
                         szErrStr2,
                         sizeof( szErrStr2),
                         NULL);
        psz2 = szErrStr2;
    }
    ShowEngineErr( error, psz1, psz2);
    FreeLangList();

#ifdef _DEBUG
    FreeMemList( NULL);
#endif // _DEBUG

    DoExit( (error == 4) ? 0 : error);
}


#ifdef UNICODE

/* Handles errors, in UNICODE environments*/

LPSTR MakeMBMsgW(

                LPWSTR pszArg,      //... Msg ID# or msg text
                LPSTR  szBuf,       //... Buffer for converted msg
                USHORT usBufLen)    //... #bytes in szBuf
{
    char *pszRet = NULL;


    if ( pszArg ) {
        if ( pszArg >= (LPTSTR)0x0400 ) {
            _WCSTOMBS( szBuf,
                       (WCHAR *)pszArg,
                       usBufLen,
                       lstrlen( pszArg ) + 1 );
        } else {
            B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                             | FORMAT_MESSAGE_IGNORE_INSERTS
                             | FORMAT_MESSAGE_FROM_HMODULE,
                             NULL,
                             (DWORD)(DWORD_PTR)pszArg,
                             szBuf,
                             usBufLen,
                             NULL);
        }
        pszRet = szBuf;
    }
    return ( pszRet);
}

//...............................................................

void QuitW( int error, LPWSTR pszArg1, LPWSTR pszArg2)
{
    char  szErrStr1[2048] = "*?*";
    char  szErrStr2[2048] = "*?*";


    QuitA( error,
           MakeMBMsgW( pszArg1, szErrStr1, sizeof( szErrStr1)),
           MakeMBMsgW( pszArg2, szErrStr2, sizeof( szErrStr2)));
}


#endif



/**
  *
  *
  *  Function: GetAccelTable,
  * Reads the Accelerator key defintions from the resource file
  *
  *  Arguments:
  * InResFile, Handle to Resource file.
  * pwcTableEntries, pointer to an array of accelerator key defintions.
  * plSize, address of size of Resource.
  *
  *  Returns:
  * pwcTableEntries containing all the key defintions.
  *
  *  Errors Codes:
  *
  *  History:
  * 8/91    Implemented                 TerryRu
  * 4/92    Added RLRES32 support             TerryRu
  *
  *
  *
  **/

ACCELTABLEENTRY * GetAccelTable(FILE  *InResFile,
                                WORD  *pwcTableEntries,
                                DWORD *plSize)
{
    ACCELTABLEENTRY *pAccelTable;
    BOOL quit = FALSE;


    // need to use sizeof operator in memory
    // allocation because of structure packing.

    *pwcTableEntries = (WORD) 0;

    pAccelTable = (ACCELTABLEENTRY *) FALLOC( ((WORD)*plSize * sizeof( WORD)));

    while (*plSize && !quit) {

#ifdef RLRES32
        pAccelTable[ *pwcTableEntries].fFlags = (WORD) GetWord( InResFile,
                                                                plSize);
#else
        pAccelTable[ *pwcTableEntries].fFlags = (BYTE) GetByte( InResFile,
                                                                plSize);
#endif

        pAccelTable[*pwcTableEntries].wAscii = GetWord (InResFile, plSize);
        pAccelTable[*pwcTableEntries].wID = GetWord (InResFile, plSize);

#ifdef RLRES32
        pAccelTable[ *pwcTableEntries].wPadding =  GetWord( InResFile, plSize);
#endif

        if ( pAccelTable[ *pwcTableEntries].fFlags & HIBITVALUE ) {
            quit = TRUE;
        }
        ++*pwcTableEntries;
    }

    if ( (long)*plSize <= 0 ) {
        *plSize = 0;
    }
    return pAccelTable;
}



/**
  *
  *
  *  Function: GetDialog,
  * Reads the dialog defintions from the res file, and places the info
  * into a linked list.
  *
  *
  *  Arguments:
  * InResFile, Handle to input resource handle, posistioned to begining
  * of dialog defintion.
  * plSize, pointer to size in bytes of the dialog information.
  *
  *  Returns:
  * pointer to DIALOGHEADER type containing the dialog information,
  *
  *
  *  Errors Codes:
  * None ???
  *
  *  History:
  * 12/91, Cleaned up comments.             TerryRu
  * 04/92, Added RLRES32 support.             TerryRu
  *
  *
  **/

DIALOGHEADER *GetDialog( FILE *InResFile, DWORD * plSize)
{
    DIALOGHEADER  *pDialogHdr;
    TCHAR   *UNALIGNED*ptr;
    WORD    i;
    LONG    lStartingOffset;
    static TCHAR szBuf[ 255];
    LONG    lExtra;
    WORD    j;



    lStartingOffset = ftell(InResFile);

    pDialogHdr = (DIALOGHEADER *)FALLOC( sizeof( DIALOGHEADER));

    // lstyle
    pDialogHdr->lStyle = GetdWord(InResFile, plSize);

#ifdef RLRES32
    pDialogHdr->fDialogEx = (HIWORD(pDialogHdr->lStyle)==0xffff);

    if (pDialogHdr->fDialogEx) {
        pDialogHdr->wDlgVer        = LOWORD(pDialogHdr->lStyle);
        pDialogHdr->wSignature     = HIWORD(pDialogHdr->lStyle);
        pDialogHdr->dwHelpID       = GetdWord(InResFile, plSize);
        pDialogHdr->lExtendedStyle = GetdWord(InResFile, plSize);
        pDialogHdr->lStyle         = GetdWord(InResFile, plSize);
    } else {
        pDialogHdr->lExtendedStyle = GetdWord(InResFile, plSize);
    }

    pDialogHdr->wNumberOfItems = GetWord(InResFile, plSize);
#else
    pDialogHdr->wNumberOfItems = (BYTE) GetByte(InResFile, plSize);
#endif

    // allocate space to hold wNumberOfItems of pointers
    // to Control Data structures
    pDialogHdr->pCntlData = (CONTROLDATA *)
                            FALLOC( pDialogHdr->wNumberOfItems * sizeof( CONTROLDATA));


    // read x, y, cx, cy dialog cordinates
    pDialogHdr->x  = GetWord(InResFile, plSize);
    pDialogHdr->y  = GetWord(InResFile, plSize);
    pDialogHdr->cx = GetWord(InResFile, plSize);
    pDialogHdr->cy = GetWord(InResFile, plSize);

    //... Dialog Menu Name
    GetNameOrd( InResFile,
                (BOOL UNALIGNED *)&pDialogHdr->bMenuFlag,     // 9/11/91 (PW)
                (WORD UNALIGNED *)&pDialogHdr->wDlgMenuID,
                (TCHAR *UNALIGNED*)&pDialogHdr->pszDlgMenu,
                plSize);

    //... Dialog Class Name
    GetNameOrd( InResFile,
                (BOOL UNALIGNED *)&pDialogHdr->bClassFlag,     // 9/11/91 (PW)
                (WORD UNALIGNED *)&pDialogHdr->wDlgClassID,
                (TCHAR *UNALIGNED*)&pDialogHdr->pszDlgClass,
                plSize);

    // Dialog caption name
    GetName( InResFile, szBuf, plSize);
    ptr =  (TCHAR *UNALIGNED*)&pDialogHdr->pszCaption;
    AllocateName( *ptr, szBuf);
    lstrcpy( (TCHAR *)*ptr, (TCHAR *)szBuf);

    // does dialog define a font.

    if ( pDialogHdr->lStyle & DS_SETFONT ) {
        // extract this info.
        pDialogHdr->wPointSize = GetWord( InResFile, plSize);
        if (pDialogHdr->fDialogEx) {
            pDialogHdr->wWeight = GetWord( InResFile, plSize);
            pDialogHdr->wItalic = GetWord( InResFile, plSize);
        }
        GetName( InResFile, szBuf, plSize);
        ptr =  (TCHAR *UNALIGNED*)&pDialogHdr->pszFontName;
        AllocateName(*ptr, szBuf);

        lstrcpy( (TCHAR *)*ptr, (TCHAR *)szBuf);

    } else {
        pDialogHdr->pszFontName = (TCHAR*)FALLOC( 0);
    }

#ifdef RLRES32

    DWordUpFilePointer( InResFile, MYREAD, ftell(InResFile), plSize);

#endif

    //... read each dialog control

    for (i = 0; i < pDialogHdr->wNumberOfItems ; i++) {

#ifdef RLRES32

        if (pDialogHdr->fDialogEx) {
            pDialogHdr->pCntlData[i].dwHelpID = GetdWord(InResFile, plSize);
            pDialogHdr->pCntlData[i].lExtendedStyle = GetdWord(InResFile, plSize);
            pDialogHdr->pCntlData[i].lStyle = GetdWord(InResFile, plSize);
        } else {
            pDialogHdr->pCntlData[i].lStyle = GetdWord(InResFile, plSize);
            pDialogHdr->pCntlData[i].lExtendedStyle = GetdWord(InResFile, plSize);
        }

#endif // RLRES32

        pDialogHdr->pCntlData[i].x = GetWord(InResFile, plSize);
        pDialogHdr->pCntlData[i].y = GetWord(InResFile, plSize);
        pDialogHdr->pCntlData[i].cx = GetWord(InResFile, plSize);
        pDialogHdr->pCntlData[i].cy = GetWord(InResFile, plSize);

        // wId
        if (pDialogHdr->fDialogEx)
            pDialogHdr->pCntlData[i].dwID = GetdWord (InResFile, plSize);
        else
            pDialogHdr->pCntlData[i].dwID = (DWORD)GetWord (InResFile, plSize);

#ifdef RLRES16
        // lStyle
        pDialogHdr->pCntlData[i].lStyle = GetdWord(InResFile, plSize);


        pDialogHdr->pCntlData[i].bClass = (BYTE) GetByte(InResFile, plSize);

        // does dialog have a class?
        if (!(pDialogHdr->pCntlData[i].bClass & 0x80)) {
            GetName(InResFile, szBuf, plSize);
            ptr =  &pDialogHdr->pCntlData[i].pszClass;
            AllocateName(*ptr, szBuf);
            lstrcpy ((TCHAR *)*ptr, (TCHAR *)szBuf);
        } else {
            pDialogHdr->pCntlData[i].pszClass = NULL;
        }

#else
        GetNameOrd (InResFile,
                    (BOOL UNALIGNED *)&pDialogHdr->pCntlData[i].bClass_Flag,  // 9/11/91 (PW)
                    (WORD UNALIGNED *)&pDialogHdr->pCntlData[i].bClass,
                    (TCHAR *UNALIGNED*)&pDialogHdr->pCntlData[i].pszClass,
                    plSize);

#endif
        GetNameOrd (InResFile,
                    (BOOL UNALIGNED *)&pDialogHdr->pCntlData[i].bID_Flag, // 9/11/91 (PW)
                    (WORD UNALIGNED *)&pDialogHdr->pCntlData[i].wDlgTextID,
                    (TCHAR *UNALIGNED*)&pDialogHdr->pCntlData[i].pszDlgText,
                    plSize);

#ifdef RLRES16
        pDialogHdr->pCntlData[i].unDefined = (BYTE) GetByte(InResFile, plSize);

#else
        pDialogHdr->pCntlData[i].wExtraStuff = (WORD) GetWord(InResFile, plSize);
        if (pDialogHdr->fDialogEx && pDialogHdr->pCntlData[i].wExtraStuff) {
            lExtra = pDialogHdr->pCntlData[i].wExtraStuff;
            j = 0;
            pDialogHdr->pCntlData[i].pExtraStuff = (BYTE *)FALLOC( pDialogHdr->pCntlData[i].wExtraStuff );
            while ( lExtra-- )
                pDialogHdr->pCntlData[i].pExtraStuff[j++] = GetByte( InResFile, plSize );
        } else
            pDialogHdr->pCntlData[i].pExtraStuff = NULL;

#endif // RLRES16


#ifdef RLRES32

        DWordUpFilePointer( InResFile, MYREAD, ftell(InResFile), plSize);

#endif // RLRES32

    }

    // watch for overflow of plsize
    if ((long)  *plSize <= 0) {
        *plSize = 0;
    }
    return (pDialogHdr);
}




/**
  *
  *
  *  Function: GetResMenu,
  *   Reads the Menu defintions from the resrouce file, and insert the info
  *   into a linked list..
  *
  *  Arguments:
  *   InResFile, Input res handle, positioned at being of Menu Definition.
  *   lSize, pointer to size of Menu Defintion.
  *   pMenuHeader, pointer to structure to contain menu info.
  *
  *  Returns:
  *   pMenuHeader containing linkd list of Menu info.
  *
  *  Errors Codes:
  *   None.
  *
  *  History:
  *   7/91, implemented                           Terryru
  *   12/91, cleaned up comments                      Terryru
  *   4/92,  Added PDK2 support                       Terryru
  *   4/92,  Added RLRES32 support                      Terryru
  *
  **/

void GetResMenu(FILE *InResFile, DWORD *lSize , MENUHEADER *pMenuHeader)
{
    static TCHAR   szItemText[255];
    BOOL    fStart = TRUE;
    BOOL    fQuit = FALSE;
    LONG    lExtra = 0;
    WORD    i = 0;
    WORD    wPopItems = 0, wMenuID = 0;
    MENUITEM    * pcMenuItem;
    TCHAR   *UNALIGNED*ptr;
    WORD    wNestingLevel = 0;
    WORD    wFlags;
    LONG    lStartingOffset;    // used to dword align file

    lStartingOffset = ftell(InResFile);

    pMenuHeader->wVersion = GetWord(InResFile, lSize);
    pMenuHeader->cbHeaderSize = GetWord(InResFile, lSize);


    pMenuHeader->fMenuEx =  (pMenuHeader->wVersion == 1);

    if (pMenuHeader->fMenuEx && pMenuHeader->cbHeaderSize) {
        lExtra = pMenuHeader->cbHeaderSize;
        pMenuHeader->pExtraStuff = (BYTE *)FALLOC( pMenuHeader->cbHeaderSize );
        while ( lExtra-- )
            pMenuHeader->pExtraStuff[i++] = GetByte( InResFile, lSize);
    } else
        pMenuHeader->pExtraStuff = NULL;


    // add all the items to the list

    while ( (((signed long) *lSize) >= 0) && !fQuit) {
        if (fStart) {
            // start the menu item list
            pcMenuItem = pMenuHeader->pMenuItem =
                         (MENUITEM *)FALLOC( sizeof( MENUITEM));
            pcMenuItem->pNextItem = NULL;
            fStart = FALSE;
        } else {
            // add space to the menu list
            // allocate space for next Item
            pcMenuItem->pNextItem = (MENUITEM *)FALLOC (sizeof( MENUITEM));

            pcMenuItem = pcMenuItem->pNextItem;
            pcMenuItem->pNextItem = NULL;

        }


        if (pMenuHeader->fMenuEx) {
            pcMenuItem->dwType   = GetdWord( InResFile, lSize);
            pcMenuItem->dwState  = GetdWord( InResFile, lSize);
            pcMenuItem->dwMenuID = GetdWord( InResFile, lSize);

            pcMenuItem->fItemFlags = wFlags  = GetWord(InResFile,lSize); // read type of menu item
            if ( (wFlags & MFR_POPUP) ) {
                wFlags &= ~MFR_POPUP;           // Normalize the menu
                wFlags |= MF_POPUP;
            }
            //pcMenuItem->fItemFlags = wFlags;
        } else {
            wFlags = GetWord(InResFile,lSize); // read type of menu item
            pcMenuItem->fItemFlags = wFlags;

            // is it a popup?

            if ( ! (pcMenuItem->fItemFlags & POPUP) ) {
                pcMenuItem->dwMenuID = (DWORD)GetWord( InResFile, lSize);
            }
        }

        GetName( InResFile, szItemText, lSize);

        ptr  = (TCHAR *UNALIGNED*)&pcMenuItem->szItemText;
        * ptr = (TCHAR *)FALLOC( MEMSIZE( lstrlen( szItemText) + 1));

        lstrcpy( (TCHAR *)*ptr, (TCHAR *)szItemText);


        if (pMenuHeader->fMenuEx) {
            DWordUpFilePointer( InResFile, MYREAD, ftell(InResFile), lSize);

            if ( (wFlags & POPUP) ) {
                pcMenuItem->dwHelpID = GetdWord( InResFile, lSize);
            }
        }

        if (wFlags & POPUP) {
            ++wNestingLevel;
        }

        if (wFlags & ENDMENU) {
            if (wNestingLevel) {
                --wNestingLevel;
            } else {
                fQuit = TRUE;
            }
        }
    }

#ifdef RLRES32

    WordUpFilePointer( InResFile,
                       MYREAD,
                       lStartingOffset,
                       ftell( InResFile), lSize);
#endif

}



int MyEOF(FILE *fPtr)
{
#ifdef RLRES32
    LONG lCurOffset;
    LONG lEndOffset;

    lCurOffset = ftell(fPtr);
    lEndOffset = fseek(fPtr, SEEK_END, 0);

    // reset file pointer
    fseek( fPtr, lCurOffset, SEEK_SET);

    return ((lEndOffset - lCurOffset) < sizeof (DWORD));
#else
    return ( feof(fPtr));
#endif
}


void WordUpFilePointer(FILE *fPtr,
                       BOOL bMode,
                       LONG lStartingOffset,
                       LONG lCurrentOffset ,
                       LONG *plPos)
{

    LONG lDelta;
    LONG lOffset;
    char buffer[]="\0\0\0\0\0\0\0\0";

    lDelta = lCurrentOffset - lStartingOffset ;
    lOffset = WORDUPOFFSET( lDelta);

    if ( bMode == MYREAD ) {
        fseek( fPtr, lOffset , SEEK_CUR);
        *plPos -= lOffset;
    } else {
        fwrite( buffer, 1, (size_t) lOffset, fPtr);
        *plPos += lOffset;
    }
}


void DWordUpFilePointer(

                       FILE  *fPtr,
                       BOOL   bMode,
                       LONG   lCurrentOffset,
                       DWORD *plPos)    //... New file position
{
    LONG lOffset;

    lOffset = DWORDUPOFFSET( lCurrentOffset);

    if ( bMode == MYREAD ) {
        fseek( fPtr, lOffset, SEEK_CUR);

        if ( plPos != NULL ) {
            *plPos -= lOffset;
        }
    } else {
        char buffer[]="\0\0\0\0\0\0\0";

        fwrite( buffer, 1, (size_t)lOffset, fPtr);

        if ( plPos != NULL ) {
            *plPos += lOffset;
        }
    }
}



//
// Function:    FilterRes, Public
//
// Synopsis:    Determine whether the resource type is to be filtered
//              The non filtered resource are OR together, thus several
//              resource types can pass through the filter.  Zero indicates
//              no resources are to be filterd, 0xFFFF indicates to not filter
//              custom resource.
//
//
// Arguments:   [wFilter]   Indicates the resources which we are to pass thru.
//              [pRes]      Ptr to Resource header struct
//
//
// Effects:
//
// Returns:     TRUE       Skip the current resource
//              FALSE      Use the current resource
//
// Modifies:
//
// History:
//              18-Oct-92   Created     TerryRu
//
//
// Notes:
//

BOOL FilterRes( WORD wFilter, RESHEADER *pRes)
{
    WORD wCurRes;


    wCurRes = pRes->wTypeID;

    if ( wFilter == 0 ) {
        return ( FALSE);
    }

    if ( wCurRes == 0 ) {
        return ( FALSE);
    }

    // check for special case for custom resources

    if ( wFilter == (WORD)0xFFFF ) {
        if ( wCurRes > 16) {
            return ( FALSE);
        } else {
            return ( TRUE);
        }
    }

    return ( ! (wFilter == wCurRes));
}




/**

  *
  *
  *  Function: GetResVer
  *
  * Extracts the version stamping information that
  * requires loclization from the resource file. The resource
  * information is containd is a USER defined resource
  * (ID = 16, Type = 1).
  *
  * The resource block format:
  * WORD wTotLen
  * WORD wValLen
  * BYTE szKey
  * BYTE szVal
  *
  * All information in the version stampling is contained in
  * repeating patters of this block type.   All Key, and Value
  * fields  are padded to start on DWORD boundaries. The
  * padding necessary to allign the blocks is not included in
  * the wTotLen field, but the padding to allign the fields inside
  * the block is.
  *
  * The following information in the Resource block needs to be
  * tokenized:
  *
  *
  * Key Field in StringFileInfo Block
  * Value Fields in StringFileInfo String Blocks.
  * Code Page and Language ID Fields of VarFileInfo
  * Standard Var Blocks.
  *
  * By defintion, any value string contained in the String requires
  * in be localized.  It is assumed that there will be two
  * StringFileInfo Blocks in each international resource. The first
  * one, is to remain in English, while the second Block, is to be
  * localized in the language specified by the StingFileInfo Key Field.
  * The VarFileInfo Code Page and Language ID Fields localized to
  * indicate which StringFileInfo block the file supports.
  *
  *
  *  Arguments:
  * FILE *InResFile
  * File to extracte version stamping from
  *
  * DWORD *lSize
  * Size of version stamping information
  *
  * VERHEADER *pVerHeader
  * pointer to structure to contain parsed version info.
  *
  *  Returns:
  *
  * pVerHead  Buffer contain version stamping resource
  * pVerBlock starting location of children blocks
  *
  *  Errors Codes:
  * TRUE,  Read of Resource sucessfull.
  * FALSE, Read of Resource failed.
  *
  *  History:
  *
  * 11/91.  Created                                         TerryRu.
  * 10/92.  Added Support for NULL Version Blocks       TerryRu
  * 10/92.  Added RLRES32 version                 DaveWi
  **/

#ifdef RLRES32

WORD GetResVer(

              FILE      *InResFile,
              DWORD     *plSize,
              VERHEAD   *pVerHead,
              VERBLOCK **pVerBuf)
{
    WORD wVerHeadSize;
    WORD wcRead;


    *pVerBuf = NULL;

    //... Read the fixed info that will not change

    wVerHeadSize = (WORD)(3 * sizeof(WORD)
                   + MEMSIZE( lstrlen( TEXT( "VS_VERSION_INFO")) + 1)
                   + sizeof( VS_FIXEDFILEINFO));
    wVerHeadSize = DWORDUP(wVerHeadSize);

    if ( ResReadBytes( InResFile,
                       (CHAR *)pVerHead,
                       (size_t)wVerHeadSize,
                       plSize) == FALSE ) {
        return ( (WORD)-1);
    }
    //... check for the special case where
    //... there is no version block.

    if ( wVerHeadSize >= pVerHead->wTotLen) {
        return ( 0);
    }
    //... Version header information read okay
    //... so make a buffer for the rest of the res.

    *pVerBuf = (VERBLOCK *)FALLOC( DWORDUP( pVerHead->wTotLen) - wVerHeadSize);

    //... Now Read Value Information

    wcRead = DWORDUP( pVerHead->wTotLen) - wVerHeadSize;

    return ( ResReadBytes( InResFile,
                           (CHAR *)*pVerBuf,
                           (size_t)wcRead,
                           plSize) == FALSE ? (WORD)-1 : wcRead);
}


#else //... RLRES32


BOOL GetResVer(

              FILE      *InResFile,
              DWORD     *plSize,
              VERHEAD   *pVerHead,
              VERBLOCK **pVerBuf)
{
    size_t wcRead = sizeof( VERHEAD);


    if ( ResReadBytes( InResFile, (CHAR *) pVerHead, wcRead, plSize) == FALSE ) {
        return ( FALSE);
    }

    // check for the special case where there is no version block

    if ( (size_t)pVerHead->wTotLen == wcRead ) {
        *pVerBuf = NULL;
        return ( TRUE);
    }

    // Version header information read okay.

    *pVerBuf = (VERBLOCK *)FALLOC( DWORDUP( pVerHead->wTotLen) - wcRead);

    // Now Read Value Information


    return ( ResReadBytes( InResFile,
                           (CHAR *) *pVerBuf,
                           (size_t)(DWORDUP( pVerHead->wTotLen) - wcRead),
                           plSize));
}

#endif //... RLRES32


/**
  *
  *
  *  Function: GetNameOrd
  * Function to read either the string name, or ordinal number of a
  * resource ID.  If the ID begins with a 0xff, the resource ID
  * is a ordinal number, otherwise the ID is a string.
  *
  *
  *  Arguments:
  * InResFile, File handle positioned to location of resource
  * ID information.
  * cFlag, pointer to flag indicating which ID type is used.
  * pwID, pointer of ordinal ID number
  * pszText pointer, to address of ID string.
  *
  *  Returns:
  * cFlag to indicate if ID is string or ordinal number.
  * pwID, pszText containing actual ID info.
  *
  *  Errors Codes:
  *
  *  History:
  *
  *    7/91, Implemented                    TerryRu
  *    9/91, Inserted cFlag as a indicator for ID or string PeterW
  *    4/92, Added RLRES32 support                TerryRu
  **/


void GetNameOrd(

               FILE   *fpInResFile,       //... File to retrieve header from
               BOOL   UNALIGNED*pbFlag,//... For IDFLAG or 1st byte (WORD in RLRES32) of name/ord
               WORD   UNALIGNED*pwID,  //... For retrieved resource ID (if not a string)
               TCHAR  *UNALIGNED*pszText, // For retrieved resource name if it is a string
               DWORD  *plSize)            // Keeps count of bytes read (or NULL)
{
    WORD fFlag;

    //... get type info

#ifdef RLRES16

    fFlag = GetByte( fpInResFile, plSize);

#else

    fFlag = GetWord( fpInResFile, plSize);

#endif

    *pbFlag = fFlag;

    if ( fFlag == IDFLAG ) {
        //... field is a numbered item
#ifdef RLRES16
        *pwID    = GetByte( fpInResFile , plSize);
#else
        *pwID    = GetWord( fpInResFile , plSize);
#endif
        *pszText = (TCHAR *)FALLOC( 0);
    } else {
        static TCHAR szBuf[ 255];

        //... field is a named item.
        //... put fFlag byte(s) back into stream
        //... because it is part of the name.
        *pwID = IDFLAG;

#ifdef RLRES16

        UnGetByte( fpInResFile, (BYTE) fFlag, plSize);
#else

        UnGetWord( fpInResFile, (WORD) fFlag, plSize);
#endif
        GetName( fpInResFile, szBuf, plSize);
        *pszText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( szBuf) + 1));

        lstrcpy( (TCHAR *)*pszText, (TCHAR *)szBuf);
    }
}




/**
  *
  *
  *  Function: GetResHeader
  * Reads the Resource Header information, and stores it in a structure.
  *
  *  Arguments:
  * InResFile, File handle positioned to location of Resource Header.
  * pResHeader, pointer to Resource Header structure.
  *
  *  Returns:
  * pResHeader, containing resource header info.
  * plSize, contining size of remaining resource info.
  *
  *  Errors Codes:
  * -1, Read of resource header failed.
  *
  *  History:
  * 7/91, Implemented               TerryRu
  * 4/92, Added RLRES32 Support               Terryru
  *
  *
  **/

int GetResHeader(

                FILE      *InResFile,   //... File to get header from
                RESHEADER UNALIGNED*pResHeader,  //... buffer for the retrieved header
                DWORD     *plSize)      //... keeps track of the bytes read from the file
{

#ifdef RLRES32

    pResHeader->lSize       = GetdWord( InResFile, plSize);
    pResHeader->lHeaderSize = GetdWord( InResFile, plSize);

#endif

    //... get name ID and type ID

    GetNameOrd( InResFile,
                (BOOL UNALIGNED*)&pResHeader->bTypeFlag,
                (WORD UNALIGNED*)&pResHeader->wTypeID,
                (TCHAR *UNALIGNED*)&pResHeader->pszType,
                plSize);

    GetNameOrd( InResFile,
                (BOOL UNALIGNED*)&pResHeader->bNameFlag,
                (WORD UNALIGNED*)&pResHeader->wNameID,
                (TCHAR *UNALIGNED*)&pResHeader->pszName,
                plSize);

#ifdef RLRES32

    DWordUpFilePointer( InResFile, MYREAD, ftell( InResFile), plSize);

    pResHeader->lDataVersion = GetdWord( InResFile, plSize);

#endif

    pResHeader->wMemoryFlags = GetWord( InResFile, plSize);

#ifdef RLRES32

    pResHeader->wLanguageId      = GetWord(  InResFile, plSize);
    pResHeader->lVersion         = GetdWord( InResFile, plSize);
    pResHeader->lCharacteristics = GetdWord( InResFile, plSize);

#else // RLRES32

    pResHeader->lSize = (DWORD)GetdWord( InResFile, plSize);

#endif // RLRES32

    return ( 0);
}


/**
  *
  *
  *  Function: isdup
  * Used to determine if the current dialog control id is a duplicate
  * of an earlyier control id. If so, isdup returns a flag indicating the
  * ID is a duplicate.
  *
  *  Arguments:
  * wcCurrent, ID of current dialog control.
  * wpIdBuf, array of dialog control ID's processed so far.
  * wcItems, number of ID's in wpIdBuf
  *
  *  Returns:
  * TRUE, ID is a duplicate
  * FALSE, ID is not a duplicate
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented               TerryRu
  *
  *
  **/

BOOL isdup(WORD wCurrent, WORD *wpIdBuf, WORD wcItems)
{
    WORD i;


    for (i = 0; i < wcItems; i++) {
        if (wCurrent == wpIdBuf[i]) {
            return TRUE;
        }
    }
    return FALSE;
}


/**
  *
  *
  *  Function: ParseTokCrd
  * Places dialog coordinates into a buffer.
  *
  *  Arguments:
  * pszCrd, buffer to hold dialog control cordinates.
  * pwX, pwY, pwCX, pwCY, dialog control cordiantes.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, implemented               TerryRu
  *
  *
  **/

void ParseTokCrd(
                TCHAR *pszCrd,
                WORD UNALIGNED * pwX,
                WORD UNALIGNED * pwY,
                WORD UNALIGNED * pwCX,
                WORD UNALIGNED * pwCY)
{
#ifdef RLRES32

    int x  = 0;
    int y  = 0;
    int cx = 0;
    int cy = 0;

    _stscanf( pszCrd, TEXT("%d %d %d %d"), &x, &y, &cx, &cy);
    *pwX  = (WORD) x;
    *pwY  = (WORD) y;
    *pwCX = (WORD) cx;
    *pwCY = (WORD) cy;

#else  //RLRES32

    sscanf( pszCrd, "%hd %hd %hd %hd", pwX, pwY, pwCX, pwCY);

#endif //RLRES32
}

int GetAlignFromString( TCHAR *pszStr)
{
    TCHAR   *pStyle;

    if ( !(pStyle = _tcschr( pszStr, TEXT('('))) ) {
        return (-1);
    }

    while ( *pStyle ) {
        if ( *pStyle == TEXT('L') ) {
            if ( ! _tcsnicmp( pStyle, TEXT("LEFT"), 4) ) {
                return (0);
            }
        } else if ( *pStyle == TEXT('C') ) {
            if ( ! _tcsnicmp( pStyle, TEXT("CENTER"), 6)) {
                return (1);
            }
        } else if ( *pStyle == TEXT('R') ) {
            if ( ! _tcsnicmp( pStyle, TEXT("RIGHT"), 5) ) {
                return (2);
            }
        }
        pStyle++;
    }
    return ( -1 );           //none
}


void ParseTokCrdAndAlign(
                        TCHAR       *pszCrd,
                        CONTROLDATA *pCntrl)
{
    int     align = 0;

    if ( (pCntrl->bClass_Flag == IDFLAG)
         && ((pCntrl->bClass == STATIC)
             || (pCntrl->bClass == EDIT)) ) {

        if ( (align = GetAlignFromString( pszCrd)) >= 0 ) {

            if ( pCntrl->bClass == STATIC ) {
                pCntrl->lStyle &= ~(SS_LEFT|SS_RIGHT|SS_CENTER);

                if ( align == 2 )
                    pCntrl->lStyle |= SS_RIGHT;
                else if ( align == 1 )
                    pCntrl->lStyle |= SS_CENTER;
                else
                    pCntrl->lStyle |= SS_LEFT;
            } else {
                pCntrl->lStyle &= ~(ES_LEFT|ES_RIGHT|ES_CENTER);

                if ( align == 2 )
                    pCntrl->lStyle |= ES_RIGHT;
                else if ( align == 1 )
                    pCntrl->lStyle |= ES_CENTER;
                else
                    pCntrl->lStyle |= ES_LEFT;
            }
        }
    }
    ParseTokCrd( pszCrd,
                 (WORD UNALIGNED *)&pCntrl->x,
                 (WORD UNALIGNED *)&pCntrl->y,
                 (WORD UNALIGNED *)&pCntrl->cx,
                 (WORD UNALIGNED *)&pCntrl->cy);
}


/**
  *
  *
  *  Function: PutResHeader
  * Writes Resource Header information contained in the ResHeader structure
  * to the ouput resfile. Note, the value of the size field, is not yet
  * know, so it is left blank, to be fixed up once the size resource
  * determined.
  *
  *  Arguments:
  * OutResFile, File handle to Output Resource File.
  * ResHeader, Structure containing resource header information.
  * pResSizePos, file position buffer
  *
  *  Returns:
  * pResSizePos, position at localization of the OutResFile to insert
  * the resource size.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented                       Terryru
  * 9/91, Added bTypeFlag to handle case where ID is 255.   Peterw
  * 4/92, Added RLRES32 support                   Terryru
  *
  *
  **/

int PutResHeader(

                FILE     *OutResFile,   //... File to write to
                RESHEADER ResHeader,    //... Header to be written out
                fpos_t   *pResSizePos,  //... For offset at which to write the adjusted res size
                DWORD    *plSize)       //... Keeps track of bytes written
{
    int   rc;
    DWORD ltSize = *plSize;


#ifdef RLRES32
    //... save position to res size

    rc = fgetpos( OutResFile, pResSizePos);

    //... this size is bogus, will fill in later
    //... unless we are called in the mail loop

    PutdWord( OutResFile, ResHeader.lSize,       plSize);
    PutdWord( OutResFile, ResHeader.lHeaderSize, plSize);

#endif // RLRES32

    PutNameOrd( OutResFile,
                ResHeader.bTypeFlag,
                ResHeader.wTypeID,
                ResHeader.pszType,
                plSize);

    PutNameOrd( OutResFile,
                ResHeader.bNameFlag,
                ResHeader.wNameID,
                ResHeader.pszName,
                plSize);

#ifdef RLRES32

    DWordUpFilePointer( OutResFile, MYWRITE, ftell( OutResFile), plSize);

    PutdWord( OutResFile, ResHeader.lDataVersion, plSize);

#endif // RLRES32


    PutWord( OutResFile, ResHeader.wMemoryFlags, plSize);

#ifdef RLRES32

    PutWord(  OutResFile, ResHeader.wLanguageId,      plSize);
    PutdWord( OutResFile, ResHeader.lVersion,         plSize);
    PutdWord( OutResFile, ResHeader.lCharacteristics, plSize);

#else // RLRES32
    //... save position to res size

    rc = fgetpos( OutResFile, pResSizePos);

    //... this size is bogus, will fill in later
    //... unless we are called in the mail loop

    PutdWord( OutResFile, ltSize, plSize);

#endif // RLRES32

/////////////////// ??????? why?    *plSize = ltSize;

    return ( rc);
}



/**
  *
  *
  *  Function: PutDialog
  * PutDialog writes dialog information to the output resource file as
  * it traveres through the linked list of dialog info.  If the info
  * is of the type that needs to be localized, the corresponding translated
  * info is read from the token file, and writen to the resource file.
  *
  *  Arguments:
  * OutResFile, The file handle of the res file being generated.
  * TokFile, The file handle of the token file containing tokenized dialog info,
  *     typically this file has been localized.
  * ResHeader, Structure containg Dialog resource header information.
  * pDialogHdr, Linked list of unlocalized Dialog information.
  *
  *  Returns:
  * Translated dialog information written to the Output Resource file.
  *
  *  Errors Codes:
  * None,
  *
  *  History:
  *     7/91, Implemented.                                      TerryRu
  *     1/93, Now tokenize dlg fontnames                        TerryRu
  *     01/93 Support for var length token text                 MHotchin
  *
  **/

void PutDialog(FILE         *OutResFile,
               FILE         *TokFile,
               RESHEADER     ResHeader,
               DIALOGHEADER *pDialogHdr)
{
    static TOKEN   tok;
    int found = 0;
    WORD    wcDup = 0;
    WORD    *pwIdBuf;
    static TCHAR   pErrBuf[MAXINPUTBUFFER];
    WORD    i, j = 0, k = 0;
    fpos_t  ResSizePos;
    CONTROLDATA *pCntlData = pDialogHdr->pCntlData;
    DWORD   lSize = 0;
    LONG    lStartingOffset;    // used to dword align file
    WORD    y = 0;
    LONG    lExtra = 0;

    lStartingOffset = ftell(OutResFile);

    // Prep for find token call
    tok.wType     = ResHeader.wTypeID;
    tok.wName     = ResHeader.wNameID;
    tok.wID       = 0;
    tok.wReserved = ST_TRANSLATED;


    lstrcpy( (TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);
    tok.szText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( pDialogHdr->pszCaption) + 1));
    lstrcpy( (TCHAR *)tok.szText, (TCHAR *)pDialogHdr->pszCaption);

    // write the Dialog Res Header
    if ( PutResHeader( OutResFile, ResHeader , &ResSizePos, &lSize)) {
        RLFREE( tok.szText);
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_DLGBOX, NULL);
    }
    // write the dialog header

    lSize = 0L;

#ifdef RLRES32

    if (pDialogHdr->fDialogEx) {
        PutWord( OutResFile, pDialogHdr->wDlgVer, &lSize);
        PutWord( OutResFile, pDialogHdr->wSignature, &lSize);
        PutdWord( OutResFile, pDialogHdr->dwHelpID, &lSize);
        PutdWord( OutResFile, pDialogHdr->lExtendedStyle, &lSize);
        PutdWord( OutResFile, pDialogHdr->lStyle, &lSize);
    } else {
        PutdWord( OutResFile, pDialogHdr->lStyle, &lSize);
        PutdWord( OutResFile, pDialogHdr->lExtendedStyle, &lSize);
    }

    PutWord( OutResFile, pDialogHdr->wNumberOfItems, &lSize);

#else // RLRES32

    PutdWord( OutResFile, pDialogHdr->lStyle, &lSize);
    PutByte( OutResFile, (BYTE)pDialogHdr->wNumberOfItems, &lSize);

#endif // RLRES32

    // check to see if caption was localized
    // but don't put it in the res file yet
    // order of token is caption, cordinates,
    // while in res its cordinates, caption

    tok.wFlag = ISCAP;

    if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
        // can not find token, terminate
        ParseTokToBuf( pErrBuf, &tok);
        RLFREE( tok.szText);
        QuitT( IDS_ENGERR_05, pErrBuf, NULL);
    }

    tok.wReserved = ST_TRANSLATED;

    // token found, continue
    RLFREE( pDialogHdr->pszCaption);
    pDialogHdr->pszCaption =
    (TCHAR *)FALLOC( MEMSIZE( lstrlen( tok.szText) + 1));

    TextToBin( pDialogHdr->pszCaption,
               tok.szText,
               lstrlen( tok.szText));
    RLFREE( tok.szText);

    // Now get the cordinates of the token
    tok.wFlag = (ISCAP) | (ISCOR);

    if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
        // token not found, terminate
        ParseTokToBuf(pErrBuf, &tok);
        RLFREE( tok.szText);
        QuitT( IDS_ENGERR_05, pErrBuf, NULL);
    }
    tok.wReserved = ST_TRANSLATED;

    // token found continue

    ParseTokCrd( tok.szText,
                 (WORD UNALIGNED *)&pDialogHdr->x,
                 (WORD UNALIGNED *)&pDialogHdr->y,
                 (WORD UNALIGNED *)&pDialogHdr->cx,
                 (WORD UNALIGNED *)&pDialogHdr->cy);

    RLFREE( tok.szText);

    // put cordindates in new res file
    PutWord(OutResFile, pDialogHdr->x , &lSize);
    PutWord(OutResFile, pDialogHdr->y , &lSize);
    PutWord(OutResFile, pDialogHdr->cx , &lSize);
    PutWord(OutResFile, pDialogHdr->cy , &lSize);

    PutNameOrd(OutResFile,
               pDialogHdr->bMenuFlag,   // 9/11/91 (PW)
               pDialogHdr->wDlgMenuID,
               pDialogHdr->pszDlgMenu,
               &lSize);

    PutNameOrd( OutResFile,
                pDialogHdr->bClassFlag,  // 9/11/91 (PW)
                pDialogHdr->wDlgClassID,
                pDialogHdr->pszDlgClass,
                &lSize);

    PutString(OutResFile, pDialogHdr->pszCaption, &lSize);

    if ( pDialogHdr->lStyle & DS_SETFONT ) {

        if (gfExtendedTok) {

            static CHAR   szTmpBuf[30];

            // find dialog font size
            tok.wFlag = ISDLGFONTSIZE;
            tok.wReserved = ST_TRANSLATED;

            if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
                // token not found, terminate
                ParseTokToBuf(pErrBuf, &tok);
                RLFREE( tok.szText);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }

#ifdef RLRES32

            _WCSTOMBS( szTmpBuf,
                       tok.szText,
                       sizeof( szTmpBuf),
                       lstrlen( tok.szText) + 1);
            PutWord (OutResFile, (WORD) atoi(szTmpBuf), &lSize);

            if (pDialogHdr->fDialogEx) {
                PutWord(   OutResFile, pDialogHdr->wWeight , &lSize);
                PutWord(   OutResFile, pDialogHdr->wItalic , &lSize);
            }

#else // RLRES32

            PutWord( OutResFile, (WORD) atoi( tok.szText), &lSize);

#endif // RLRES32

            RLFREE( tok.szText);

            // find dialog font name
            tok.wFlag = ISDLGFONTNAME;
            tok.wReserved = ST_TRANSLATED;

            if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
                // token not found, terminate
                ParseTokToBuf(pErrBuf, &tok);
                RLFREE( tok.szText);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }
            PutString( OutResFile, tok.szText, &lSize);
            RLFREE( tok.szText);

        } else {
            PutWord(   OutResFile, pDialogHdr->wPointSize , &lSize);

            if (pDialogHdr->fDialogEx) {
                PutWord(   OutResFile, pDialogHdr->wWeight , &lSize);
                PutWord(   OutResFile, pDialogHdr->wItalic , &lSize);
            }

            PutString( OutResFile, pDialogHdr->pszFontName, &lSize);

        }

    }

#ifdef RLRES32

    DWordUpFilePointer( OutResFile, MYWRITE, ftell(OutResFile), &lSize);

#endif // RLRES32

    //... That was the end of the DialogBoxHeader
    //... Now we start with the ControlData's

    pwIdBuf = (WORD *)FALLOC( (DWORD)pDialogHdr->wNumberOfItems
                              * sizeof( WORD));

    tok.wReserved = ST_TRANSLATED;

    // now place each of the dialog controls in the new res file
    for (i = 0; i < pDialogHdr->wNumberOfItems; i ++) {
        if (isdup ((WORD)pDialogHdr->pCntlData[i].dwID, pwIdBuf, (WORD)j)) {
            tok.wID = (USHORT)wcDup++;
            tok.wFlag = ISDUP;
        } else {
            // wid is unique so store in buffer for dup check
            pwIdBuf[j++] = (USHORT)pDialogHdr->pCntlData[i].dwID;

            tok.wID = (USHORT)pDialogHdr->pCntlData[i].dwID;
            tok.wFlag = 0;
        }

        if (pDialogHdr->pCntlData[i].pszDlgText[0]) {
            tok.szText = NULL;

            if (!FindToken(TokFile, &tok, ST_TRANSLATED)) {
                // can not find the token, terminate program
                ParseTokToBuf(pErrBuf, &tok);
                RLFREE( tok.szText);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }

            tok.wReserved = ST_TRANSLATED;

            // token found, continue
            RLFREE( pDialogHdr->pCntlData[i].pszDlgText);
            pDialogHdr->pCntlData[i].pszDlgText =
            (TCHAR *)FALLOC( MEMSIZE( lstrlen( tok.szText) + 1));

            if ( pDialogHdr->pCntlData[i].pszDlgText ) {
                TextToBin(pDialogHdr->pCntlData[i].pszDlgText,
                          (TCHAR *)tok.szText,
                          lstrlen((TCHAR *)tok.szText) + 1);
            }
            RLFREE( tok.szText);
        }

        tok.wFlag |= ISCOR;

        if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
            ParseTokToBuf( pErrBuf, &tok);
            RLFREE( tok.szText);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }
        tok.wReserved = ST_TRANSLATED;

        ParseTokCrdAndAlign( tok.szText, &pDialogHdr->pCntlData[i] );

        RLFREE( tok.szText);

#ifdef RLRES32

        if (pDialogHdr->fDialogEx) {
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].dwHelpID, &lSize);
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].lExtendedStyle, &lSize);
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].lStyle, &lSize);
        } else {
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].lStyle, &lSize);
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].lExtendedStyle, &lSize);
        }

#endif // RLRES32
        // now put control info into res file
        PutWord (OutResFile, pDialogHdr->pCntlData[i].x , &lSize);
        PutWord (OutResFile, pDialogHdr->pCntlData[i].y , &lSize);
        PutWord (OutResFile, pDialogHdr->pCntlData[i].cx , &lSize);
        PutWord (OutResFile, pDialogHdr->pCntlData[i].cy , &lSize);

        if (pDialogHdr->fDialogEx)
            PutdWord (OutResFile, pDialogHdr->pCntlData[i].dwID , &lSize);
        else
            PutWord (OutResFile, (WORD)pDialogHdr->pCntlData[i].dwID , &lSize);

#ifdef RLRES16

        // lStyle
        PutdWord (OutResFile, pDialogHdr->pCntlData[i].lStyle , &lSize);


        PutByte(OutResFile, (BYTE) pDialogHdr->pCntlData[i].bClass, &lSize);

        if (! (pDialogHdr->pCntlData[i].bClass & 0x80)) {
            PutString (OutResFile, pDialogHdr->pCntlData[i].pszClass , &lSize);
        }

#else // RLRES16

        PutNameOrd(OutResFile,
                   pDialogHdr->pCntlData[i].bClass_Flag, // 9/11/91 (PW)
                   pDialogHdr->pCntlData[i].bClass,
                   pDialogHdr->pCntlData[i].pszClass,
                   &lSize);

#endif // RLRES16

        PutNameOrd(OutResFile,
                   pDialogHdr->pCntlData[i].bID_Flag, // 9/11/91 (PW)
                   pDialogHdr->pCntlData[i].wDlgTextID,
                   pDialogHdr->pCntlData[i].pszDlgText,
                   &lSize);


#ifdef RLRES16

        PutByte(OutResFile, (BYTE) pDialogHdr->pCntlData[i].unDefined, &lSize);
#else
        PutWord(OutResFile, (WORD)pDialogHdr->pCntlData[i].wExtraStuff, &lSize);

        if (pDialogHdr->fDialogEx && pDialogHdr->pCntlData[i].wExtraStuff) {
            lExtra = pDialogHdr->pCntlData[i].wExtraStuff;
            y = 0;
            while ( lExtra-- )
                PutByte (OutResFile, pDialogHdr->pCntlData[i].pExtraStuff[y++] , &lSize);
        }

        if ( i < pDialogHdr->wNumberOfItems - 1 ) {
            DWordUpFilePointer( OutResFile, MYWRITE, ftell(OutResFile), &lSize);
        }

#endif // RLRES16

    }

    RLFREE( pwIdBuf );

    if (!UpdateResSize (OutResFile, &ResSizePos , lSize)) {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_DLGBOX, NULL);
    }
    DWordUpFilePointer( OutResFile, MYWRITE, ftell( OutResFile), NULL);
}



/**
  *
  *
  *  Function:  PutMenu
  * Traveres through the linked list of Menu information and writes the info to the
  * output resource file. If the infortion is the type that requires localization,
  * the translated info is read from the token file and writen to the resource.
  * call PutMenuItem to do the actual write of the menu info to the resource.
  *
  *  Arguments:
  * OutResFile, File handle of output resource file.
  * TokFile, File handle of token file.
  * ResHeader, Sturcture contain Menu Resource header information.
  * pMenuHdr, Linked list of menu info.
  *
  *  Returns:
  * Translated Menu Info written to output resource file.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.              TerryRu.
  * 01/93 Changes to allow var length token text.  MHotchin
  *
  **/

void PutMenu(FILE *OutResFile,
             FILE *TokFile,
             RESHEADER ResHeader,
             MENUHEADER *pMenuHdr)
{
    DWORD lSize = 0;
    static TOKEN tok;
    static WORD    wcPopUp = 0;
    fpos_t ResSizePos;
    MENUITEM *pMenuItem = pMenuHdr->pMenuItem;
    static TCHAR pErrBuf[ MAXINPUTBUFFER];
    LONG    lExtra = 0;
    WORD    i = 0;


    // write the Menu Res header
    if ( PutResHeader (OutResFile, ResHeader , &ResSizePos, &lSize)) {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_MENU, NULL);
    }

    lSize = 0;

    // write the Menu header
    PutWord (OutResFile, pMenuHdr->wVersion, &lSize);
    PutWord (OutResFile, pMenuHdr->cbHeaderSize , &lSize);

    if (pMenuHdr->fMenuEx && pMenuHdr->cbHeaderSize) {
        lExtra = pMenuHdr->cbHeaderSize;
        while ( lExtra-- )
            PutByte (OutResFile, pMenuHdr->pExtraStuff[i++] , &lSize);
    }

    // prep for findtoken call
    tok.wType     = ResHeader.wTypeID;
    tok.wName     = ResHeader.wNameID;
    tok.wReserved = ST_TRANSLATED;

    // for all menu items,
    // find translated token if item was tokenized
    // write out that menu item, using new translation if available.


    while (pMenuItem) {
        // if Menu Item is a seperator skip it
        if ( *pMenuItem->szItemText ) {
            // check for the popup menu items
            if ((pMenuItem->fItemFlags & MFR_POPUP) && pMenuHdr->fMenuEx) {
                tok.wID = (pMenuItem->dwMenuID == 0 ||
                           pMenuItem->dwMenuID == 0x0000ffff) ?
                          (USHORT)pMenuItem->dwMenuID : 0x8000 + wcPopUp++;
                tok.wFlag = ISPOPUP;
            } else if (pMenuItem->fItemFlags & POPUP) {
                tok.wID = wcPopUp++;
                tok.wFlag = ISPOPUP;
            } else {
                tok.wID = (USHORT)pMenuItem->dwMenuID;
                tok.wFlag = 0;
            }
            lstrcpy((TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);
            tok.szText = NULL;

            if ( ! FindToken( TokFile, &tok,ST_TRANSLATED) ) {
                // can not find token, terminate
                ParseTokToBuf(pErrBuf, &tok);
                RLFREE( tok.szText);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }
            tok.wReserved = ST_TRANSLATED;

            // token found, continue
            RLFREE( pMenuItem->szItemText);
            pMenuItem->szItemText=
            (TCHAR *)FALLOC( MEMSIZE( lstrlen( tok.szText) + 1));

            TextToBin(pMenuItem->szItemText,
                      (TCHAR *)tok.szText,
                      lstrlen((TCHAR *)tok.szText)+1);
            RLFREE( tok.szText);
        }

        PutMenuItem (OutResFile, pMenuItem , &lSize, pMenuHdr->fMenuEx);

        pMenuItem = pMenuItem->pNextItem;
    }

    if (!UpdateResSize (OutResFile, &ResSizePos , lSize)) {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_MENU, NULL);
    }
}



/**
  *
  *
  *  Function: PutMenuItem
  * Called by PutMenu to write a menu item info to the ouput resoruce file.
  *
  *
  *  Arguments:
  * OutResFile, File handle of output resfile, positioned at location to
  *     write menu item info.
  * pMenuItem, pointer to struture containing menu item info.
  * plSize, pointer of variable to count the number of bytes written to
  * the resource file. Used later to fixup the resource field in the
  * header.
  *
  *
  *
  *  Returns:
  * OutReFile, containing translated menu item info, and plSize containing
  * number of bytes written to resource file.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7//91, Implemented           TerryRu
  *
  *
  **/

void   PutMenuItem(FILE * OutResFile, MENUITEM * pMenuItem, DWORD * plSize, BOOL fMenuEx)
{
    if (fMenuEx) {
        PutdWord( OutResFile, pMenuItem->dwType, plSize);
        PutdWord( OutResFile, pMenuItem->dwState, plSize);
        PutdWord( OutResFile, pMenuItem->dwMenuID, plSize);
        PutWord( OutResFile, pMenuItem->fItemFlags, plSize);
    } else {
        PutWord( OutResFile, pMenuItem->fItemFlags, plSize);

        if ( ! (pMenuItem->fItemFlags & POPUP) ) {
            PutWord( OutResFile, (WORD)pMenuItem->dwMenuID, plSize);
        }
    }

    PutString( OutResFile, pMenuItem->szItemText, plSize);

    if (fMenuEx) {
        DWordUpFilePointer( OutResFile, MYWRITE, ftell(OutResFile), plSize);

        if (pMenuItem->fItemFlags & MFR_POPUP) {
            PutdWord( OutResFile, pMenuItem->dwHelpID, plSize);
        }
    }

}


/**
  *
  *
  *  Function: PutNameOrd
  * Writes either the string or ordinal ID of the resource class or type.
  *
  *
  *  Arguments:
  * OutResFile, File handle of resource file being generated.
  * bFlag,      Flag indicating whether ID is a string or ordinal.
  * pszText,    string ID, if used.
  * wId,        Ordinal ID if used.
  * pLsize,     pointer to DWORD counter var.
  *
  *  Returns:
  * OutResFile, containing ID info, and plSize containing the number of
  * bytes written to the file.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.          TerryRu.
  *
  *
  **/

void PutNameOrd(

               FILE  *fpOutResFile,
               BOOL   bFlag,
               WORD   wID,
               TCHAR *pszText,
               DWORD *plSize)
{
    if ( bFlag == IDFLAG ) {

#ifdef RLRES16

        PutByte( fpOutResFile, (BYTE)IDFLAG, plSize);

#else

        PutWord( fpOutResFile, (WORD)IDFLAG, plSize);

#endif

        PutWord( fpOutResFile, wID, plSize);
    } else {
        PutString( fpOutResFile, pszText, plSize);
    }
}



/**
  *
  *
  *  Function: MyAtow,
  * Special Ascii to WORD function that works on 4 digit, hex strings.
  *
  *
  *  Arguments:
  * pszNum, 4 digit hex string to convert to binary.
  *
  *
  *  Returns:
  * Binary value of pszNumString
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 12//91, Implemented.            TerryRu.
  *
  *
  **/

WORD MyAtoX(

           CHAR *pszNum,   //... array of bytes to scan
           int nLen)       //... # oc bytes in pszNum to scan
{
    WORD wNum = 0;
    WORD i;
    WORD nPower = 1;

    if ( nLen > 4 ) {
        QuitT( IDS_ENGERR_16, (LPTSTR)IDS_CHARSTOX, NULL);
    }

    for ( i = 0; i < nLen; i++, nPower *= 16 ) {
        if ( isdigit( pszNum[ i]) ) {
            wNum +=  nPower * (pszNum[i] - '0');
        } else {
            wNum +=  nPower * (toupper( pszNum[i]) - 'A' + 10);
        }
    }
    return ( wNum);
}


WORD MyAtoW( CHAR *pszNum)
{
    return ( MyAtoX( pszNum, 4));
}





/**
  *
  *
  *  Function: PutResVer.
  * Writes the Version stamping info to the Resourc file. Unlike most
  * put functions, PutResVer writes all the localized version stamping info
  * into a memory block, then writes the complete version stamping info to
  * the resource file.  This was done because of large number of size
  * fixups needed for the version stamping info.
  *
  *
  *  Arguments:
  * OutResFile, file pointer of resource file being generated.
  * TokeFile, file pointer of input token file containing localized info.
  * ResHeader, Structure containing Resource Header info of the
  * version stamping block.
  * pVerHdr, address of Version Header. Note this is different the ResHdr.
  * pVerBlk, address of Version stamping info, which is contained in
  * a series of StringFile, and VarFile info blocks. The number of
  * such blocks is determined by the size fields.
  *
  *  Returns:
  * OutResFile, containing localized version stamping info.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 11/91, Implemented.                                         TerryRu.
  * 12/91, Various fixes to work with different padding.        TerryRu.
  * 01/92, Size of Version block updated                        PeterW.
  * 10/92, Now handles NULL Version Blocks                      TerryRu.
  * 10/92, Added RLRES32 version                                  DaveWi
  * 01/93, Added var length token text support.                 MHotchin
  **/

#ifdef RLRES32

int PutResVer(

             FILE     *fpOutResFile,
             FILE     *fpTokFile,
             RESHEADER ResHeader,
             VERHEAD  *pVerHdr,
             VERBLOCK *pVerBlk)
{
    TOKEN  Tok;
    BOOL   fInStringInfo = FALSE;   //... TRUE if reading StringFileInfo
    WORD   wTokNum = 0;             //... Put into Tok.wID field
    WORD   wTokContinueNum = 0;     //... Put into Tok.wFlag field
    WORD   wDataLen = 0;            //... Length of old resource data
    WORD   wVerHeadSize;            //... Sizeof of the VERHEAD struct
    fpos_t lResSizePos;
    DWORD  lSize = 0L;
    int    nWritten = 0;
    int    nNewVerBlockSize = 0;
    PVERBLOCK pNewVerStamp = NULL;
    PVERBLOCK pNewBlk      = NULL;


    wVerHeadSize = (WORD)(3 * sizeof(WORD)
                   + MEMSIZE( lstrlen( TEXT( "VS_FIXEDFILEINFO")) + 1)
                   + sizeof( VS_FIXEDFILEINFO));
    wVerHeadSize = DWORDUP(wVerHeadSize);

    //... write the Version resouce header

    if ( PutResHeader(fpOutResFile, ResHeader, &lResSizePos, &lSize) ) {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_VERSTAMP, NULL);
    }

    lSize = 0L;

    if ( pVerBlk == NULL ) {
        //... We have no version block to write
        //... just write the version header and return

        nWritten = fwrite((void *)pVerHdr,
                          sizeof(char),
                          wVerHeadSize,
                          fpOutResFile);

        if (! UpdateResSize(fpOutResFile, &lResSizePos, (DWORD)nWritten)) {
            QuitT( IDS_ENGERR_07, (LPTSTR)IDS_VERSTAMP, NULL);
        }
        return (1);
    }

    wDataLen = pVerHdr->wTotLen;

    if ( wDataLen == 0 || wDataLen == (WORD)-1 ) {
        return (-1);             //... No resource data
    }
    //... Allocate buffer to hold New Version
    //... Stamping Block (make ne buffer large to
    //... account for expansion of strings during
    //... localization).

    pNewVerStamp = (PVERBLOCK)FALLOC( (nNewVerBlockSize = wDataLen * 4));

    //... Fill new memory block with zeros

    memset((void *)pNewVerStamp, 0, nNewVerBlockSize);

    //... Copy version header into buffer

    memcpy((void *)pNewVerStamp, (void *)pVerHdr, wVerHeadSize);
    pNewVerStamp->wLength = wVerHeadSize;

    //... Move to start of new version info block

    pNewBlk = (PVERBLOCK)((PBYTE)pNewVerStamp + wVerHeadSize);

    wDataLen -= wVerHeadSize;

    //... Fill in static part of TOKEN struct

    Tok.wType = ResHeader.wTypeID;
    Tok.wName = IDFLAG;
    Tok.szName[0] = TEXT('\0');
    Tok.szType[0] = TEXT('\0');
    Tok.wReserved = ST_TRANSLATED;

    //... Get a token for each string found in res

    while (wDataLen > 0) {
        WORD wRC;

        //... Start of a StringFileInfo block?
    #ifdef UNICODE
        wRC = (WORD)CompareStringW( MAKELCID( MAKELANGID( LANG_ENGLISH,
                                                          SUBLANG_ENGLISH_US),
                                              SORT_DEFAULT),
                                    0,
                                    pVerBlk->szKey,
                                    min( wDataLen, (WORD)STRINGFILEINFOLEN),
                                    STRINGFILEINFO,
                                    min( wDataLen, (WORD)STRINGFILEINFOLEN));
        if ( wRC == 2 )
    #else
        wRC = strncmp( pVerBlk->szKey,
                       STRINGFILEINFO,
                       min( wDataLen, (WORD)STRINGFILEINFOLEN));

        if ( wRC == SAME )
    #endif
        {
            WORD  wStringInfoLen = 0;   //... # of bytes in StringFileInfo
            WORD  wLen = 0;
            PVERBLOCK pNewStringInfoBlk; //... Start of this StringFileInfo blk


            pNewStringInfoBlk = pNewBlk;

            pNewStringInfoBlk->wLength    = 0; //... Gets fixed up later
            pNewStringInfoBlk->wValueLength = 0;
            pNewStringInfoBlk->wType      = pVerBlk->wType;

            lstrcpy( (TCHAR *)pNewStringInfoBlk->szKey, (TCHAR *)pVerBlk->szKey);

            //... Get # of bytes in this StringFileInfo
            //... (Length of value is always 0 here)

            wStringInfoLen = pVerBlk->wLength;

            //... Move to start of first StringTable blk.

            wLen = (WORD)(DWORDUP(sizeof(VERBLOCK)
                           - sizeof(TCHAR)
                           + MEMSIZE( STRINGFILEINFOLEN)));

            pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
            pNewBlk = (PVERBLOCK)((PBYTE)pNewStringInfoBlk + wLen);

            DECWORDBY(&wDataLen,       wLen);
            DECWORDBY(&wStringInfoLen, wLen);

            INCWORDBY(&pNewVerStamp->wLength,      wLen);
            INCWORDBY(&pNewStringInfoBlk->wLength, wLen);

            while (wStringInfoLen > 0) {
                WORD      wStringTableLen = 0;
                PVERBLOCK pNewStringTblBlk = NULL;

                //... Get # of bytes in this StringTable
                //... (Length of value is always 0 here)

                wStringTableLen = pVerBlk->wLength;

                //... Copy StringFileInfo key into Token name

                Tok.wID = wTokNum++;
                Tok.wFlag = wTokContinueNum = 0;
                lstrcpy((TCHAR *)Tok.szName, (TCHAR *)LANGUAGEINFO);
                Tok.szText = NULL;

                //... Find token for this

                if ( ! FindToken( fpTokFile, &Tok, ST_TRANSLATED) ) {
                    //... token not found, flag error and exit.

                    ParseTokToBuf( (TCHAR *)szDHW, &Tok);
                    RLFREE( pNewVerStamp);
                    RLFREE( Tok.szText);
                    QuitT( IDS_ENGERR_05, (TCHAR *)szDHW, NULL);
                }
                Tok.wReserved = ST_TRANSLATED;

                //... Copy lang string into buffer

                pNewStringTblBlk = pNewBlk;

                pNewStringTblBlk->wLength      = 0; //... fixed up later
                pNewStringTblBlk->wValueLength = 0;
                pNewStringTblBlk->wType        = pVerBlk->wType;

                CopyMemory( pNewStringTblBlk->szKey,
                            Tok.szText,
                            MEMSIZE( LANGSTRINGLEN));

                RLFREE( Tok.szText);

                //... Move to start of first String.

                wLen = DWORDUP( sizeof(VERBLOCK)
                                - sizeof(TCHAR)
                                + MEMSIZE( LANGSTRINGLEN));

                pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
                pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + wLen);

                DECWORDBY(&wDataLen,        wLen);
                DECWORDBY(&wStringInfoLen,  wLen);
                DECWORDBY(&wStringTableLen, wLen);

                INCWORDBY(&pNewVerStamp->wLength,      wLen);
                INCWORDBY(&pNewStringInfoBlk->wLength, wLen);
                INCWORDBY(&pNewStringTblBlk->wLength,  wLen);

                while ( wStringTableLen > 0 ) {
                    //... Is value a string?

                    if (pVerBlk->wType == VERTYPESTRING) {
                        wTokContinueNum = 0;

                        Tok.wID     = wTokNum++;
                        Tok.wReserved = ST_TRANSLATED;

                        lstrcpy( (TCHAR *)pNewBlk->szKey,
                                 (TCHAR *)pVerBlk->szKey);

                        pNewBlk->wLength =
                        DWORDUP(sizeof(VERBLOCK) +
                                MEMSIZE(lstrlen((TCHAR *)pNewBlk->szKey)));

                        Tok.wFlag   = wTokContinueNum++;

                        lstrcpy( (TCHAR *)Tok.szName, (TCHAR *)pVerBlk->szKey);

                        //... Find token for this

                        if ( ! FindToken( fpTokFile, &Tok, ST_TRANSLATED) ) {
                            //... token not found, flag error and exit.

                            ParseTokToBuf( (TCHAR *)szDHW, &Tok);
                            RLFREE( pNewVerStamp);
                            QuitT( IDS_ENGERR_05, (TCHAR *)szDHW, NULL);
                        }

                        Tok.wReserved = ST_TRANSLATED;

                        pNewBlk->wValueLength = (WORD)TextToBinW(
                                                                (TCHAR *)((PCHAR)pNewBlk + pNewBlk->wLength),
                                                                Tok.szText,
                                                                2048);

                        pNewBlk->wType    = VERTYPESTRING;
                        pNewBlk->wLength += MEMSIZE( pNewBlk->wValueLength);

                        INCWORDBY(&pNewVerStamp->wLength,
                                  DWORDUP(pNewBlk->wLength));
                        INCWORDBY(&pNewStringInfoBlk->wLength,
                                  DWORDUP(pNewBlk->wLength));
                        INCWORDBY(&pNewStringTblBlk->wLength,
                                  DWORDUP(pNewBlk->wLength));

                        pNewBlk = MoveAlongVer(pNewBlk, NULL, NULL, NULL);

                        RLFREE( Tok.szText);
                    }
                    //... Move to start of next String.

                    pVerBlk = MoveAlongVer(pVerBlk,
                                           &wDataLen,
                                           &wStringInfoLen,
                                           &wStringTableLen);

                }               //... END while wStringTableLen

            }                   //... END while wStringInfoLen
        } else {
            if (_tcsncmp((TCHAR *)pVerBlk->szKey,
                         (TCHAR *)VARFILEINFO,
                         min(wDataLen, (WORD)VARFILEINFOLEN)) == SAME) {
                WORD  wVarInfoLen = 0;  //... # of bytes in VarFileInfo
                WORD  wNewVarInfoLen = 0; //... # of bytes in new VarFileInfo
                WORD  wLen = 0;
                PVERBLOCK pNewVarStart = NULL; //... Start of VarInfo block


                wVarInfoLen = pVerBlk->wLength;
                pNewVarStart = pNewBlk;

                //... Get # of bytes in this VarFileInfo
                //... (Length of value is always 0 here)

                wLen = (WORD)(DWORDUP(sizeof(VERBLOCK)
                               - sizeof(TCHAR)
                               + MEMSIZE( VARFILEINFOLEN)));

                //... Copy non-localized header
                //... pNewVarStart->wLength field fixed up later

                memcpy((void *)pNewVarStart, (void *)pVerBlk, wLen);
                pNewVarStart->wLength = wLen;

                //... Move to start of first Var.

                pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
                pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + wLen);

                DECWORDBY(&wDataLen, wLen);
                DECWORDBY(&wVarInfoLen, wLen);

                INCWORDBY(&pNewVerStamp->wLength, wLen);

                while (wDataLen > 0 && wVarInfoLen > 0) {
                    if (_tcsncmp((TCHAR *)pVerBlk->szKey,
                                 (TCHAR *)TRANSLATION,
                                 min(wDataLen, (WORD)TRANSLATIONLEN)) == SAME) {
                        WORD  wTransLen = 0;
                        PBYTE pValue = NULL;


                        wTokContinueNum = 0;

                        //... Copy VarFileInfo key into Token

                        Tok.wID     = wTokNum;
                        Tok.wFlag   = wTokContinueNum++;
                        Tok.szText  = NULL;
                        lstrcpy((TCHAR *)Tok.szName, (TCHAR *)TRANSLATION);

                        Tok.wReserved = ST_TRANSLATED;

                        pNewBlk->wLength =
                        DWORDUP(sizeof(VERBLOCK) +
                                MEMSIZE(lstrlen((TCHAR *)TRANSLATION)));

                        INCWORDBY(&pNewVerStamp->wLength, pNewBlk->wLength);
                        INCWORDBY(&pNewVarStart->wLength, pNewBlk->wLength);

                        pNewBlk->wValueLength = 0;  //... fixed up later
                        pNewBlk->wType = VERTYPEBINARY;
                        lstrcpy( (TCHAR *)pNewBlk->szKey, (TCHAR *)TRANSLATION);
                        lstrcpy((TCHAR *)Tok.szName, (TCHAR *)TRANSLATION);

                        //... Find token for this

                        if ( ! FindToken( fpTokFile, &Tok, ST_TRANSLATED) ) {
                            //... token not found, flag error and exit.

                            ParseTokToBuf((TCHAR *)szDHW, &Tok);
                            RLFREE( pNewVerStamp);
                            RLFREE( Tok.szText);
                            QuitT( IDS_ENGERR_05, (TCHAR *)szDHW, NULL);
                        } else {
                            PCHAR  pszLangIDs   = NULL;
                            PCHAR  pszLangStart = NULL;
                            WORD   wLangIDCount = 0;
                            size_t nChars;

                            //... Get # chars in input string (token text)

                            wTransLen = (WORD)lstrlen( Tok.szText);

                            pszLangIDs = (PCHAR)FALLOC( MEMSIZE( wTransLen + 1));

                            nChars = _WCSTOMBS( pszLangIDs,
                                                Tok.szText,
                                                MEMSIZE( wTransLen + 1),
                                                wTransLen + 1);

                            RLFREE( Tok.szText);

                            if ( ! nChars ) {
                                RLFREE( pNewVerStamp);
                                RLFREE( pszLangIDs);
                                QuitT( IDS_ENGERR_14,
                                       (LPTSTR)IDS_INVVERCHAR,
                                       NULL);
                            }

                            //... Where to put these bytes?

                            pValue = (PBYTE)GetVerValue( pNewBlk);

                            //... Get each lang ID in the token

                            for ( wLangIDCount = 0, pszLangStart = pszLangIDs;
                                wTransLen >= 2 * TRANSDATALEN;
                                ++wLangIDCount ) {
                                USHORT uByte1 = 0;
                                USHORT uByte2 = 0;
                                WORD   wIndex = 0;


                                if ( sscanf( pszLangStart,
                                             "%2hx%2hx",
                                             &uByte2,
                                             &uByte1) != 2 ) {
                                    QuitA( IDS_ENGERR_16,
                                           (LPSTR)IDS_ENGERR_21,
                                           pszLangStart);
                                }

                                wIndex = wLangIDCount * TRANSDATALEN;

                                pValue[ wIndex]     = (BYTE)uByte1;
                                pValue[ wIndex + 1] = (BYTE)uByte2;

                                INCWORDBY(&pNewVerStamp->wLength, TRANSDATALEN);
                                INCWORDBY(&pNewVarStart->wLength, TRANSDATALEN);
                                INCWORDBY(&pNewBlk->wLength,      TRANSDATALEN);
                                INCWORDBY(&pNewBlk->wValueLength, TRANSDATALEN);

                                //... Set up to get next lang ID in token

                                wTransLen    -= 2 * TRANSDATALEN;
                                pszLangStart += 2 * TRANSDATALEN;

                                while ( wTransLen > 2 * TRANSDATALEN
                                        && *pszLangStart != '\0'
                                        && isspace( *pszLangStart) ) {
                                    wTransLen--;
                                    pszLangStart++;
                                }
                            }   //... END for ( wLangIDCount = 0 ...
                            RLFREE( pszLangIDs);
                        }
                        Tok.wReserved = ST_TRANSLATED;

                    }           //... END if (_tcsncmp((TCHAR *)pVerBlk->szKey))

                    //... Move to start of next Var info block.

                    pVerBlk = MoveAlongVer(pVerBlk,
                                           &wDataLen,
                                           &wVarInfoLen,
                                           NULL);

                    pNewBlk = MoveAlongVer(pNewBlk, NULL, NULL, NULL);

                }               //... END while (wDataLen > 0 && wVarInfoLen)
            } else {
                RLFREE( pNewVerStamp);
                QuitT( IDS_ENGERR_14, (LPTSTR)IDS_INVVERBLK, NULL);
            }
        }
    }                           //... END while (wDataLen)

    //... write new version stamping information
    //... to the resource file

    nWritten = fwrite((void *)pNewVerStamp,
                      sizeof(char),
                      (WORD)lSize + pNewVerStamp->wLength,
                      fpOutResFile);

    if ( ! UpdateResSize( fpOutResFile,
                          &lResSizePos,
                          lSize + pNewVerStamp->wLength) ) {
        RLFREE(  pNewVerStamp);

        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_VERSTAMP, NULL);
    }
    RLFREE(  pNewVerStamp);

    return (0);
}

#else //... #ifdef RLRES32

int PutResVer(

             FILE     *OutResFile,
             FILE     *TokFile,
             RESHEADER ResHeader,
             VERHEAD  *pVerHdr,
             VERBLOCK *pVerBlk)
{

    TCHAR    *pszBuf;
    fpos_t    ResSizePos;
    WORD      wcLang = 0,
    wcBlock = 0;
    TOKEN     tok;
    VERBLOCK *pCurBlk;
    VERBLOCK *pNewBlk,
    *pNewBlkStart;
    TCHAR    *pszStr,
    pErrBuf[ 128];
    WORD     *pwVal;
    DWORD     lTotBlkSize,
    lSize = 0;
    int       wTotLen,
    wcCurBlkLen,
    wcTransBlkLen,
    wcRead;
    WORD     *pStrBlkSizeLoc,
    wStrBlkSize = 0;
    int       wcBlkLen;



    // write the Version resouce header

    if ( PutResHeader( OutResFile, ResHeader, &ResSizePos, &lSize) ) {
        QuitT( IDS_ENGERR_06, MAKEINTRESOURCE( IDS_VERSTAMP), NULL);
    }

    lSize = 0L;

    if ( pVerBlk == NULL ) {
        //... We have no version block to write
        //... just write the version header and return

        wcRead = fwrite( (void *)pVerHdr,
                         sizeof( char),
                         sizeof( VERHEAD),
                         OutResFile);

        if ( ! UpdateResSize( OutResFile, &ResSizePos, (DWORD)wcRead) ) {
            QuitT( IDS_ENGERR_07, MAKEINTRESOURCE( IDS_VERSTAMP), NULL);
        }
        return ( 1);
    }

    wTotLen = pVerBlk->nTotLen;


    // Allocate buffer to hold New Version Stamping Block

    pNewBlk = (VERBLOCK *)FALLOC( VERMEM));

    // Set new memory block to NULLS
    memset( (void *)pNewBlk, 0, VERMEM);

    // save start of new version info block
    pNewBlkStart = pNewBlk;
    wcTransBlkLen = sizeof(VERHEAD);
    lSize += wcTransBlkLen;

    // Insert version header info into new version info bluffer

    memcpy((void *)pNewBlk, (void *)pVerHdr, wcTransBlkLen);

    // Position pNewBlk point at location to insert next piece of version info
    pNewBlk = (VERBLOCK *) ((char *) pNewBlk +   wcTransBlkLen);


    // File in static part of TOKEN struct
    tok.wType     = ResHeader.wTypeID;
    tok.wName     = IDFLAG;
    tok.wReserved = ST_TRANSLATED;

    wTotLen = pVerBlk->nTotLen;
    pCurBlk = pVerBlk;

    tok.wID = wcLang++;
    pszStr = pCurBlk->szKey;

    wcCurBlkLen = 4 + DWORDUP(lstrlen((TCHAR *)pszStr) + 1);
    wTotLen -= wcCurBlkLen;


    // Insert StringFileInfo Header into new version info buffer
    // this info is not localized
    memcpy((void *)pNewBlk, (void *)pCurBlk, wcCurBlkLen);
    pszStr=pNewBlk->szKey;

    // reposition pointers
    pCurBlk = (VERBLOCK *) ((char *) pCurBlk + wcCurBlkLen);
    pNewBlk = (VERBLOCK *) ((char *) pNewBlk + wcCurBlkLen);

    lSize += wcCurBlkLen;

    // Read All the StringTableBlocks
    while (wTotLen > 8) {

        // For String tables blocks we localizes the key field
        tok.wFlag = ISKEY;

        wcBlkLen = pCurBlk->nTotLen;


        lstrcpy((TCHAR *)tok.szName, TEXT("Language Info"));
        tok.wID = wcBlock;
        tok.szText = NULL;

        if ((pszStr = FindTokenText (TokFile,&tok,ST_TRANSLATED)) == NULL) {
            // token not found, flag error and exit.
            ParseTokToBuf(pErrBuf, &tok);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }

        RLFREE(tok.szText);
        tok.szText = NULL;

        tok.wReserved = ST_TRANSLATED;
        // Do not know length of the translated StringTable block
        // so set the nValLen to zero , and save location
        // of string file block size field, to be fixed up latter.

        pNewBlk->nValLen =  0;
        pStrBlkSizeLoc = (WORD *) &pNewBlk->nTotLen;

        // copy the translated key into that location
        TextToBin(pNewBlk->szKey,pszStr,VERMEM-2*sizeof(int));
        RLFREE( pszStr);

        // Update localized string block count

        wStrBlkSize = (WORD) DWORDUP (4 + lstrlen((TCHAR *)pNewBlk->szKey) + 1);

        // get the length of the current block, note the
        // translated length does not change.
        wcCurBlkLen = 4 + pVerBlk->nValLen + DWORDUP(lstrlen((TCHAR *)pCurBlk->szKey) + 1);
        lSize += wStrBlkSize;

        // Update counter vars
        wTotLen -= DWORDUP(wcBlkLen);
        wcBlkLen -= wcCurBlkLen;

        // repostion pointers
        pCurBlk = (VERBLOCK *) ((char *)pCurBlk + DWORDUP(wcCurBlkLen));
        pNewBlk = (VERBLOCK *) ((char *)pNewBlk + DWORDUP(wcCurBlkLen)) ;

        //  Read the String Blocks
        //  For String Blocks we localize the value fields.
        tok.wFlag = ISVAL;

        while (wcBlkLen > 0) {
            // for string blocks we translate the value fields.
            pszStr = pCurBlk->szKey;
            lstrcpy((TCHAR *)tok.szName, (TCHAR *)pszStr);
            tok.szText = NULL;

            if ((pszStr= FindTokenText(TokFile,&tok,ST_TRANSLATED)) == NULL) {
                //token not found, flag error and exit.
                ParseTokToBuf(pErrBuf, &tok);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }
            RLFREE(tok.szText);
            tok.szText = NULL;

            tok.wReserved = ST_TRANSLATED;

            lstrcpy((TCHAR *)pNewBlk->szKey, (TCHAR *)pCurBlk->szKey);

            // position pointer to location to insert translated token text into pCurBlk
            pszBuf = (TCHAR*) pNewBlk + 4 +
                     DWORDUP(lstrlen((TCHAR *)pNewBlk->szKey) + 1);

            // now insert the token text
            TextToBin(pszBuf,
                      pszStr ,
                      VERMEM - (4+DWORDUP(lstrlen((TCHAR *)pNewBlk->szKey)+1)));
            RLFREE( pszStr);

            // fix up counter fields in pNewBlk
            pNewBlk->nValLen =  lstrlen((TCHAR *)pszBuf) + 1;
            pNewBlk->nTotLen = 4 + pNewBlk->nValLen +
                               DWORDUP(lstrlen((TCHAR *)pNewBlk->szKey) + 1);

            wcBlkLen -= DWORDUP(pCurBlk->nTotLen);

            lSize +=  DWORDUP(pNewBlk->nTotLen);
            wStrBlkSize +=  DWORDUP(pNewBlk->nTotLen);

            pCurBlk = (VERBLOCK *) ((char *) pCurBlk + DWORDUP(pCurBlk->nTotLen));
            pNewBlk = (VERBLOCK *) ((char *) pNewBlk + DWORDUP(pNewBlk->nTotLen));
        } // while
        wcBlock ++;
        *pStrBlkSizeLoc =   wStrBlkSize  ;
    }

    // this stuff is not translated so just copy it straight over
    // Skip past Head of VarInfoBlock
    pszStr = pCurBlk->szKey;
    wTotLen = pCurBlk->nTotLen;
    wcCurBlkLen = 4 + DWORDUP(pVerBlk->nValLen) +
                  DWORDUP(lstrlen((TCHAR *)pszStr) + 1);

    wTotLen -= wcCurBlkLen;

    // Insert Head of Var Info Into new block buffer
    memcpy((void *)pNewBlk, (void *)pCurBlk, wcCurBlkLen);

    pCurBlk = (VERBLOCK *) ((char *) pCurBlk + wcCurBlkLen);
    pNewBlk = (VERBLOCK *) ((char *) pNewBlk + wcCurBlkLen);

    lTotBlkSize = lSize;   // Save the size value for the total Version blk (PW)
    lSize += wcCurBlkLen;

    wcLang = 0;

    // Read the Var Info Blocks
    // For Var Info Blocks we localize the Translation Value field.
    tok.wFlag = ISVAL;

    while (wTotLen > 0) {
        pszStr = pCurBlk->szKey;
        lstrcpy((TCHAR *)tok.szName, TEXT("Translation"));
        tok.wID = wcLang;
        tok.szText = NULL;

        // Read Language ID

        if ((pszStr = FindTokenText(TokFile,  &tok,ST_TRANSLATED)) == NULL) {
            //token not found, flag error and exit.
            ParseTokToBuf(pErrBuf, &tok);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }
        RLFREE(tok.szText);
        tok.szText = NULL;

        tok.wReserved = ST_TRANSLATED;

        // Found ascii translation string,
        // convert it to binary and insert into pCurBlk
        pwVal = (WORD *)((char *)pCurBlk +
                         DWORDUP(4 + lstrlen((TCHAR *)pCurBlk->szKey) + 1));

        *pwVal = MyAtoW((CHAR *)pszStr);
        pwVal++;
        *pwVal = MyAtoW((CHAR *)&pszStr[4]);

        wcLang ++;
        wTotLen -= DWORDUP(pCurBlk->nTotLen );
        memcpy((void *)pNewBlk, (void *)pCurBlk, pCurBlk->nTotLen);

        lSize += pCurBlk->nTotLen;

        // reposition pointers
        pCurBlk = (VERBLOCK *) ((char *) pCurBlk + DWORDUP(pCurBlk->nTotLen) + 4);
        pNewBlk = (VERBLOCK *) ((char *) pNewBlk + DWORDUP(pNewBlk->nTotLen) + 4);
        RLFREE( pszStr);

    }
    // Now fixup VerHeader Size. header not localized so
    // we do not need to update the value size.

    pVerHdr = (VERHEAD *) pNewBlkStart;
    pVerHdr->wTotLen = (WORD) lSize;

    // Update first size value of Version block (PW)
    wcTransBlkLen = sizeof (VERHEAD);
    pNewBlk = (VERBLOCK *) ((char *) pNewBlkStart + wcTransBlkLen);
    pNewBlk->nTotLen = (WORD) (lTotBlkSize - wcTransBlkLen);

    // write new version stamping information  to the resource file

    wcRead = fwrite( (void *)pNewBlkStart,
                     sizeof(char),
                     (size_t)lSize,
                     OutResFile);

    if (!UpdateResSize (OutResFile, &ResSizePos, lSize)) {
        QuitT( IDS_ENGERR_07, MAKEINTRESOURCE( IDS_VERSTAMP), NULL);
    }
    RLFREE( pNewBlkStart);
}

#endif //... RLRES32


/**
  *
  *
  *  Function: PutStrHdr.
  * Writes the string block info to the resource file.
  *
  *
  *  Arguments:
  * OutResFile, pointer to resource file being generated.
  * TokFile, pointer to token file containing localized string blocks.
  * ResHeader, structure containing Resource Header info for the string block.
  * pStrHder, Array of strings defined in the string block.
  *
  *
  *  Returns:
  * OutResFile, containing localized string blocks.
  *
  *  Errors Codes:
  * None.
  *
  *
  *  History:
  * 7/91. Implemented.              TerryRu.
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void PutStrHdr( FILE * OutResFile,
                FILE * TokFile,
                RESHEADER ResHeader,
                STRINGHEADER *pStrHdr)
{
    static TOKEN tok;
    WORD    i, j, k;
    static TCHAR pErrBuf[MAXINPUTBUFFER];
    fpos_t ResSizePos;
    DWORD lSize = 0;

    // write the Menu Res header
    if ( PutResHeader (OutResFile, ResHeader , &ResSizePos, &lSize)) {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_MENU, NULL);
    }

    lSize = 0L;

    for (i = 0; i < 16; i++) {
        tok.wType = ResHeader.wTypeID;
        tok.wName = ResHeader.wNameID;
        tok.wID = i;
        tok.wFlag = 0;
        tok.wReserved = ST_TRANSLATED;
        tok.szText = NULL;
        tok.szName[0] = 0;

        lstrcpy((TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);

        if ( ! FindToken(TokFile, &tok, ST_TRANSLATED) ) {
            // can not find token, terminate
            ParseTokToBuf( pErrBuf, &tok);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }
        tok.wReserved = ST_TRANSLATED;

        // token text found continue
        {
            static TCHAR szTmp[4160];
            int    cChars = 0;  //... # chars in token text, including nul

            cChars = lstrlen( tok.szText) + 1;

            j = TextToBin( szTmp, tok.szText, cChars) - 1;
            RLFREE( tok.szText);

#ifdef RLRES16
            PutByte( OutResFile, (BYTE) j, &lSize);
#else
            PutWord( OutResFile, j, &lSize);
#endif

            for (k = 0; k < j; k++) {
#ifdef RLRES16
                PutByte( OutResFile, szTmp[k], &lSize);
#else
                PutWord( OutResFile, szTmp[k], &lSize);
#endif
            }
        }
    }

    if (!UpdateResSize (OutResFile, &ResSizePos , lSize)) {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_MENU, NULL);
    }
}



/**
  *
  *
  *  Function: GetString.
  *    Read a block of 16 strings from string block in the resource file.
  *
  *  Arguments:
  *    InResFile, file pointer to location of string block in the
  *    resource file.
  *    lSize, dummy var not used.
  *
  *  Returns:
  *    pStrHdr containing 16 strings.
  *
  *
  *  Errors Codes:
  *    None.
  *
  *  History:
  *    7/91.       Implemented.            TerryRu.
  *
  *
  **/
STRINGHEADER *GetString( FILE *InResFile, DWORD *lSize)
{

    WORD wCharsLeft = 0;    // Count of remaining characters in the string
    WORD i = 0, j = 0;      // Indexes into current block of 16 strings

    STRINGHEADER *pStrHdr;

    pStrHdr = (STRINGHEADER *)FALLOC( sizeof( STRINGHEADER));

    for (j = 0; j < 16; j ++) {
#ifdef RLRES16
        wCharsLeft = pStrHdr->sChars[j] = (WORD)GetByte( InResFile, lSize);
#else
        wCharsLeft = pStrHdr->wChars[j] = GetWord( InResFile, lSize);
#endif
        pStrHdr->pszStrings[j] = (TCHAR *)FALLOC( MEMSIZE( wCharsLeft + 1));

        while ( wCharsLeft-- ) {
#ifdef RLRES32
            pStrHdr->pszStrings[j][i] = GetWord( InResFile, lSize);

#else  //RLRES32

            pStrHdr->pszStrings[j][i] = GetByte( InResFile, lSize);

#endif //RLRES32

            ++i;
        }
        pStrHdr->pszStrings[j][i] = TEXT('\0');
        i = 0;
    }
    return (pStrHdr);
}



/**
  *
  *
  *  Function: ReadInRes.
  * Reads a block of info from the input resource file, and
  *.    then writes the same info to the ouput resource file.
  *
  *
  *  Arguments:
  * InFile, handle of input file.
  * OutFile, handle of ouput file.
  * lSize, number of bytes to Copy.
  *
  *
  *  Returns:
  *
  *
  *  Errors Codes:
  * 8, read error.
  * 9, write error.
  *
  *  History:
  * 7/91, Implemented.                 TerryRu.
  * 11/91, Bug fix to copy more then 64k blocks.           PeterW.
  * 4/92, Bug fix to copy blocks in smaller chunks to save memory. SteveBl
  *
  **/
#define CHUNK_SIZE 5120

void ReadInRes( FILE *InFile, FILE *ResFile, DWORD *plSize )
{
    if ( *plSize > 0L ) {
        PBYTE   pBuf;
        size_t  cNum;
        size_t  cAmount;


        pBuf = (PBYTE)FALLOC( CHUNK_SIZE);

        do {
            cAmount = (*plSize > (DWORD)CHUNK_SIZE ? CHUNK_SIZE : *plSize);

            cNum = fread( (void *)pBuf, sizeof( BYTE), cAmount, InFile);

            if ( cNum != cAmount ) {
                QuitT( IDS_ENGERR_09, (LPTSTR)IDS_READ, NULL);
            }

            cNum = fwrite( (void *)pBuf, sizeof( BYTE), cAmount, ResFile);

            if ( cNum != cAmount) {
                QuitT( IDS_ENGERR_09, (LPTSTR)IDS_WRITE, NULL);
            }
            *plSize -= cAmount;

        } while ( *plSize);

        RLFREE( pBuf);
    }
}


/**
  *
  *
  *  Function: TokAccelTable
  * Reads array of accelerator keys, and writes info to be localized
  * to the token file.
  *
  *
  *  Arguments:
  *  TokeFile, file pointer of token file.
  *  ResHeader, Resource Header for Accelerator resource. This info
  * is need to generate token id.
  *  pAccelTable, array of accelerator keys.
  *  wcTableEntries, number of key definition in Accelerator table
  *
  *
  *  Returns:
  * Accelerator info to be localized writen to token file.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.              TerryRu.
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void   TokAccelTable (FILE *TokFile ,
 