--------------------------------------------------------------------------------------------
OSErr ConvertNamedIndexToPCS(   CMMModelPtr     cw,
                                CMColor         *theData, 
                                SINT32          pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
OSErr ConvertNamedIndexToPCS(   CMMModelPtr     cw,
                                CMColor         *theData, 
                                SINT32          pixCnt )
{
    UINT16          *tagTbl = NULL;
    LUT_DATA_TYPE   tagH = NULL;
    OSErr           err = noErr;
    UINT32          i,index;
    UINT16          *colorPtr=NULL;
    int             elemSz,deviceChannelCount,count;
    CMMModelPtr     modelingData = (CMMModelPtr)cw;

    
    LH_START_PROC("ConvertNamedIndexToPCS")
    if( cw == 0 )return cmparamErr;
    {
        /* prepare the tag table */
            tagH = modelingData->theNamedColorTagData;
        if (tagH == NULL) 
        {
            err = cmparamErr;
            goto CleanUp;
        }
        LOCK_DATA(tagH);
        
        /* tagTbl should now point to beginning of first PCS data */
        /* = CMNamedColor2Type_header(84) + firstName(32) */
        tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 58;
        
        /* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
        count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
        deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
        if (deviceChannelCount == 3) 
        {
            elemSz = 32+(3+3)*sizeof(SINT16);
        } else if (deviceChannelCount == 4) 
        {
            elemSz = 32+(3+4)*sizeof(SINT16);
        } else if (deviceChannelCount == 0) 
        {
            elemSz = 32+(3+0)*sizeof(SINT16);
        } else 
        {
            err = cmparamErr;
            goto CleanUp;
        }
        elemSz /= 2;
        
        /* doing the actual */
        for (i=0; i<(UINT32)pixCnt; i++) 
        {
            /* go to the index'th element*/
            index = theData->namedColor.namedColorIndex;
            if (index > (UINT32)count || index == 0 ) 
            {
                err = cmNamedColorNotFound;
                goto CleanUp;
            }
            colorPtr = tagTbl + (index-1)*elemSz;
            /* put in all the info */
            theData->Lab.L = *colorPtr++;
            theData->Lab.a = *colorPtr++;
            theData->Lab.b = *colorPtr++;
            theData++;
        }
        UNLOCK_DATA(tagH);
    }
CleanUp:
    LH_END_PROC("ConvertNamedIndexToPCS")
    return err;
}



#define POS(x)  ((x) > (0) ? (UINT32)(x) : (UINT32)(-(x)))
/*--------------------------------------------------------------------------------------------------------------
OSErr ConvertPCSToNamedIndex(   CMMModelPtr modelingData,
                                CMColor     *theData, 
                                SINT32      pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
OSErr ConvertPCSToNamedIndex(   CMMModelPtr modelingData,
                                CMColor     *theData, 
                                SINT32      pixCnt )
{
    UINT16          *tagTbl = NULL;
    LUT_DATA_TYPE   tagH = NULL;
    OSErr           err = noErr;
    UINT32          i,j,index,dE,dEnow;
    UINT16          *colorPtr=NULL;
    int             elemSz,deviceChannelCount,count;
    
    LH_START_PROC("ConvertPCSToNamedIndex")
    if (modelingData->hasNamedColorProf == NamedColorProfileAtEnd) 
    {
        /* prepare the tag table */
        tagH = modelingData->theNamedColorTagData;
        if (tagH==NULL) 
        {
            err = cmparamErr;
            goto CleanUp;
        }
        LOCK_DATA(tagH);
        
        /* tagTbl should now point to beginning of first PCS data */
        /* = CMNamedColor2Type_header(84) + firstName(32) */
        tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 58;
        
        /* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
        count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
        deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
        if (deviceChannelCount == 3) 
        {
            elemSz = 32+(3+3)*sizeof(SINT16);
        } else if (deviceChannelCount == 4) 
        {
            elemSz = 32+(3+4)*sizeof(SINT16);
        } else if (deviceChannelCount == 0) 
        {
            elemSz = 32+(3+0)*sizeof(SINT16);
        } else 
        {
            err = cmparamErr;
            goto CleanUp;
        }
        elemSz/=2;
        
        /* doing the actual */
        for (i=0; i < (UINT32)pixCnt; i++) 
        {
            /* go through the whole table to find the closest one*/
            dEnow = 0x40000;    /* just arbitrarily high = 256*256*4 */
            index = (UINT32)-1;
            colorPtr = tagTbl;
            for (j=0; j < (UINT32)count; j++) 
            {
                dE =      POS((long)theData->Lab.a - *(colorPtr+1));
                dE = dE + POS((long)theData->Lab.b - *(colorPtr+2));
                dE = 2*dE + (dE>>1) + POS((long)theData->Lab.L - *(colorPtr));
                if (dE < dEnow) 
                {
                    index = j;
                    dEnow = dE;
                }
                colorPtr += elemSz;
            }
            theData->namedColor.namedColorIndex = index+1;
            theData++;
        }
        UNLOCK_DATA(tagH);
    }
CleanUp:
    LH_END_PROC("ConvertPCSToNamedIndex")
    return err;
}

/*--------------------------------------------------------------------------------------------------------------
CMError CMConvertNamedIndexToColors(    CMWorldRef      cw,
                                        CMColor         *theData, 
                                        unsigned long   pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
CMError CMConvertNamedIndexToColors( CMWorldRef cw, CMColor *theData, unsigned long pixCnt );
CMError CMConvertNamedIndexToColors( CMWorldRef cw, CMColor *theData, unsigned long pixCnt )
{
    return ConvertNamedIndexToColors( (CMMModelPtr)cw, theData, (SINT32)pixCnt );
}
/*--------------------------------------------------------------------------------------------------------------
CMError CMConvertNamedIndexToPCS(   CMWorldRef      cw,
                                    CMColor         *theData, 
                                    unsigned long   pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
CMError CMConvertNamedIndexToPCS( CMWorldRef cw, CMColor *theData, unsigned long pixCnt );
CMError CMConvertNamedIndexToPCS( CMWorldRef cw, CMColor *theData, unsigned long pixCnt )
{
    return ConvertNamedIndexToPCS( (CMMModelPtr)cw, theData, (SINT32)pixCnt );
}
CMError ConvertLabToIndexBitmap(    CMMModelPtr modelingData,
                                    Ptr         InBuffer,
                                    UINT32      processedLinesIn,
                                    UINT32      inLineCount,
                                    UINT32      width,
                                    UINT32      rowBytes )
{
    OSErr           err = noErr;
    LUT_DATA_TYPE   tagH=NULL;
    UINT16          *tagTbl = NULL,*colorPtr = NULL;
    int             deviceChannelCount,elemSz,count;
    UINT32          i,j,k,index,dE,dEnow;
    UINT16          LL,aa,bb;
    UINT8           *imgIn=NULL,*imgOut=NULL;
    UINT32          *imgInPtr=NULL;
    UINT8           *imgInPtr8=NULL;
    UINT8           *imgOutPtr8=NULL;
    
    LH_START_PROC("ConvertLabToIndexBitmap")
    /* prepare the tag table  */
    tagH = modelingData->theNamedColorTagData;
    if (tagH==NULL){
        err = cmparamErr;
        goto CleanUp;
    }
    LOCK_DATA(tagH);
    tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 58;
    count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
    deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
    if (deviceChannelCount == 3){
        elemSz = 32+(3+3)*sizeof(SINT16);
    }
    else if (deviceChannelCount == 4){
        elemSz = 32+(3+4)*sizeof(SINT16);
    }
    else if (deviceChannelCount == 0){
        elemSz = 32+(3+0)*sizeof(SINT16);
    }
    else{
        err = cmparamErr;
        goto CleanUp;
    }
    elemSz /= 2;
    
    /* search for index */
    imgIn = (UINT8*)InBuffer + processedLinesIn * rowBytes;
    imgInPtr8=((UINT8 *)imgIn);
    LL = *(imgInPtr8+0)+1;  /* do not use cache for first pixel */
    for (i = 0; i < inLineCount; i++){
        for (j = 0; j < width; j++){
            imgInPtr8=((UINT8 *)imgIn+j*4);
            if( LL == *(imgInPtr8+0) ){
                if( aa == *(imgInPtr8+1) && bb == *(imgInPtr8+2) ){
                    *((UINT32 *)imgIn+j) = index+1;
                    continue;
                }
            }
            LL = *(imgInPtr8+0);
            aa = *(imgInPtr8+1);
            bb = *(imgInPtr8+2);
            /* go through the whole table to find the closest one*/
            dEnow = 0x40000;    /* just arbitrarily high = 256*256*4 */
            index =(UINT32)-1;
            colorPtr = tagTbl;
            for (k = 0; k < (UINT32)count; k++){
                dE =      POS((long)aa - (*(colorPtr+1)>>8));
                dE = dE + POS((long)bb - (*(colorPtr+2)>>8));
                dE = 2*dE + (dE>>1) + POS((long)LL - (*(colorPtr)>>8));         /* Quantization L = 2.55 * (a|b) */
                if (dE < dEnow){
                    index = k;
                    dEnow = dE;
                }
                colorPtr += elemSz;
            }
            *((UINT32 *)imgIn+j) = index+1;
        }
        imgIn+=rowBytes;
    }
CleanUp:
    UNLOCK_DATA(tagH);
    LH_END_PROC("ConvertLabToIndexBitmap")
    return err;
}
CMError ConvertIndexToLabBitmap(    CMMModelPtr modelingData,
                                    Ptr         InBuffer,
                                    Ptr         OutBuffer,
                                    UINT32      processedLinesIn,
                                    UINT32      lineCount,
                                    UINT32      inWidth,
                                    UINT32      inRowBytes,
                                    UINT32      outRowBytes,
                                    UINT32      outputSize )
{
    OSErr           err = noErr;
    LUT_DATA_TYPE   tagH=NULL;
    UINT16          *tagTbl = NULL,*ColorPtr = NULL;
    UINT32          *imgIn=NULL;
    UINT8           *imgOut=NULL;
    int             deviceChannelCount,elemSz;
    UINT32          i,j,index,countNamesInProfile;
    
    LH_START_PROC("ConvertIndexToLabBitmap")
    /* set up the table for indexing */
    tagH = modelingData->theNamedColorTagData;
    if (tagH==NULL) {
        err = cmparamErr;
        goto CleanUp;
    }
    
    LOCK_DATA(tagH);
    tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 58;       /* points to PCS */
    deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
    countNamesInProfile = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
    if (deviceChannelCount==3) {
        elemSz = 32+(3+3)*sizeof(UINT16);
    } else if (deviceChannelCount==4) {
        elemSz = 32+(3+4)*sizeof(UINT16);
    } else if (deviceChannelCount==0) {
        elemSz = 32+(3+0)*sizeof(UINT16);
    } else {
        err = cmparamErr;
        goto CleanUp;
    }
    elemSz/=2;
    
    /* ...and convert the data from index to PCS values */
    for( i=processedLinesIn; i<processedLinesIn+lineCount; i++ ){
        imgIn = (UINT32 *)(InBuffer + i * inRowBytes);
        imgOut = (UINT8*)OutBuffer + (i-processedLinesIn) * outRowBytes;
        if( outputSize == 24 ){
            for (j=0;j<inWidth;j++) {
                index = *imgIn++;
                if( index == 0 || index > countNamesInProfile ){
                    err = cmNamedColorNotFound;
                    goto CleanUp;
                }

                ColorPtr = tagTbl + (index-1)*elemSz;
                *imgOut++  = (*ColorPtr++)>>8;
                *imgOut++  = (*ColorPtr++)>>8;
                *imgOut++  = (*ColorPtr++)>>8;
            }
        }
        else if( outputSize == 32 ){
            for (j=0;j<inWidth;j++) {
                index = *imgIn++;
                if( index == 0 || index > countNamesInProfile ){
                    err = cmNamedColorNotFound;
                    goto CleanUp;
                }

                ColorPtr = tagTbl + (index-1)*elemSz;
                *imgOut++  = (*ColorPtr++)>>8;
                *imgOut++  = (*ColorPtr++)>>8;
                *imgOut    = (*ColorPtr++)>>8;
                imgOut += 2;
            }
        }
    }
CleanUp:
    UNLOCK_DATA(tagH);
    LH_END_PROC("ConvertIndexToLabBitmap")
    return err;
}

#include <string.h>
CMError CMConvNameToIndex( icNamedColor2Type *Data, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count );
CMError CMConvNameToIndex( icNamedColor2Type *Data, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count )
{   
    OSErr       err = noErr;
    UINT32      i,index,l,len;
    char        *colorPtr=NULL;
    long        elemSz,deviceChannelCount,countNamesInProfile;
    const char  *aPtr;
    Ptr         tagTbl;

    LH_START_PROC("CMConvNameToIndex")
    
    if( Data == 0 || count == 0 )return cmparamErr;
        
    tagTbl = &Data->ncolor.data[0];
    /* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
    countNamesInProfile = Data->ncolor.count;
    deviceChannelCount = Data->ncolor.nDeviceCoords;
    if (deviceChannelCount==3){
        elemSz = 32+(3+3)*sizeof(SINT16);
    }
    else if (deviceChannelCount == 4){
        elemSz = 32+(3+4)*sizeof(SINT16);
    }
    else if (deviceChannelCount == 0){
        elemSz = 32+(3+0)*sizeof(SINT16);
    }
    else{
        err = cmparamErr;
        goto CleanUp;
    }
    
    for (i=0; i<(UINT32)count; i++){
        colorPtr = tagTbl;
        len = strlen( Ptr2Name[i] );
        aPtr = Ptr2Name[i];
        for( index = 0; index < (UINT32)countNamesInProfile; index++ ){
            for( l = 0; l<len; l++ ){
                if( colorPtr[l] != aPtr[l] )break;
                if( colorPtr[l] == 0 )break;
            }
            if( l >= len )break;
            colorPtr += elemSz;
        }
        if( l < len )index = 0; /* not found */
        else index++;           /* Indices are 1 based */

        /* put in all the info */
        if( index == 0 ){
            err = cmNamedColorNotFound;
            goto CleanUp;
        }
        Arr2Indices[i] = index;
    }
CleanUp:
    LH_END_PROC("CMConvNameToIndex")
    return err;
}

CMError CMConvNameToIndexCW( CMWorldRef *Storage, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count);
CMError CMConvNameToIndexCW( CMWorldRef *Storage, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count)
{   
    Ptr                 tagTbl = NULL;
    LUT_DATA_TYPE       tagH = NULL;
    CMError             err = noErr;
    char                *colorPtr=NULL;
    CMMModelPtr         modelingData;
    icNamedColor2Type   *namedData;

    LH_START_PROC("CMConvNameToIndexCW")
    
    if( Storage == 0 )return cmparamErr;
    LOCK_DATA( Storage );
    modelingData = (CMMModelPtr)(DATA_2_PTR(    Storage ));
    if ( modelingData->hasNamedColorProf!=NoNamedColorProfile) 
    {
        /* prepare the tag table */
        tagH = modelingData->theNamedColorTagData;
        if (tagH==NULL){
            err = cmparamErr;
            goto CleanUp;
        }
        LOCK_DATA(tagH);
        
        namedData = (icNamedColor2Type *)DATA_2_PTR(tagH);
        err = CMConvNameToIndex( namedData, Ptr2Name, Arr2Indices, count );
        UNLOCK_DATA(tagH);
    }
CleanUp:
    UNLOCK_DATA( Storage );
    LH_END_PROC("CMConvNameToIndexCW")
    return err;
}
CMError CMConvNameToIndexProfile( CMProfileRef aProf, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count);
CMError CMConvNameToIndexProfile( CMProfileRef aProf, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count)
{
    CMError             err;
    short               aOSerr;
    icNamedColor2Type   *aName = 0;
    unsigned long       byteCount;

    LH_START_PROC("CMConvNameToIndexProfile")
    
    if( aProf == 0 )return cmparamErr;
    err = CMGetPartialProfileElement(   aProf,
                                        icSigNamedColor2Tag,
                                        0,
                                        &byteCount,
                                        0 );
    if (err)
        goto CleanupAndExit;
    aName = (icNamedColor2Type *)SmartNewPtr( byteCount, &aOSerr );
    err = aOSerr;
    if (err)
        goto CleanupAndExit;
    err = CMGetPartialProfileElement(   aProf,
                                        icSigNamedColor2Tag,
                                        0,
                                        &byteCount,
                                        (Ptr)aName );
    if (err){
        goto CleanupAndExit;
    }

#ifdef IntelMode
    SwapLongOffset( &aName->ncolor.count, 0, 4 );
    SwapLongOffset( &aName->ncolor.nDeviceCoords, 0, 4 );
#endif
    err = CMConvNameToIndex( aName, Ptr2Name, Arr2Indices, count );

CleanupAndExit:
    DisposeIfPtr( (Ptr)aName );
    LH_END_PROC("CMConvNameToIndexProfile")
    return err;
}

CMError CMConvIndexToName( icNamedColor2Type *Data, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count);
CMError CMConvIndexToName( icNamedColor2Type *Data, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count)
{   
    Ptr             tagTbl = NULL;
    OSErr           err = noErr;
    UINT32          i,index;
    char            *colorPtr=NULL;
    long            elemSz,deviceChannelCount,countNamesInProfile;

    LH_START_PROC("CMConvIndexToName")
    
    if( Data == 0 || count == 0 )return cmparamErr;
    tagTbl = &Data->ncolor.data[0];
        
    /* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
    countNamesInProfile = Data->ncolor.count;
    deviceChannelCount = Data->ncolor.nDeviceCoords;
    if (deviceChannelCount==3){
        elemSz = 32+(3+3)*sizeof(SINT16);
    }
    else if (deviceChannelCount == 4){
        elemSz = 32+(3+4)*sizeof(SINT16);
    } 
    else if (deviceChannelCount == 0){
        elemSz = 32+(3+0)*sizeof(SINT16);
    }
    else{
        err = cmparamErr;
        goto CleanUp;
    }
    
    /* doing the actual */
    for (i=0; i<(UINT32)count; i++){
        /* go to the index'th element*/
        index = Arr2Indices[i];
        if (index > (UINT32)countNamesInProfile || index == 0 ) 
        {
            err = cmNamedColorNotFound;
            goto CleanUp;
        }
        colorPtr = tagTbl + (index-1)*elemSz;
        /* put in all the info */
        strcpy( Ptr2Name[i], colorPtr );
    }

CleanUp:
    LH_END_PROC("CMConvIndexToName")
    return err;
}

CMError CMConvIndexToNameCW( CMWorldRef *Storage, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count);
CMError CMConvIndexToNameCW( CMWorldRef *Storage, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count)
{   
    Ptr                 tagTbl = NULL;
    LUT_DATA_TYPE       tagH = NULL;
    CMError             err = noErr;
    char                *colorPtr=NULL;
    CMMModelPtr         modelingData;
    icNamedColor2Type   *namedData;

    LH_START_PROC("CMConvIndexToNameCW")
    
    if( Storage == 0 )return cmparamErr;
    LOCK_DATA( Storage );
    modelingData = (CMMModelPtr)(DATA_2_PTR(    Storage ));
    if ( modelingData->hasNamedColorProf!=NoNamedColorProfile) 
    {
        /* prepare the tag table */
        tagH = modelingData->theNamedColorTagData ;
        if (tagH==NULL){
            err = cmparamErr;
            goto CleanUp;
        }
        LOCK_DATA(tagH);
        
        namedData = (icNamedColor2Type *)DATA_2_PTR(tagH);
        err = CMConvIndexToName( namedData, Arr2Indices, Ptr2Name, count );
        UNLOCK_DATA(tagH);
    }
CleanUp:
    UNLOCK_DATA( Storage );
    LH_END_PROC("CMConvIndexToNameCW")
    return err;
}
CMError CMConvIndexToNameProfile( CMProfileRef aProf, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count);
CMError CMConvIndexToNameProfile( CMProfileRef aProf, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count)
{
    CMError             err;
    short               aOSerr;
    icNamedColor2Type   *aName = 0;
    unsigned long       byteCount;

    LH_START_PROC("CMConvIndexToNameProfile")
    
    if( aProf == 0 )return cmparamErr;
    err = CMGetPartialProfileElement(   aProf,
                                        icSigNamedColor2Tag,
                                        0,
                                        &byteCount,
                                        0 );
    if (err)
        goto CleanupAndExit;
    aName = (icNamedColor2Type *)SmartNewPtr( byteCount, &aOSerr );
    err = aOSerr;
    if (err)
        goto CleanupAndExit;
    err = CMGetPartialProfileElement(   aProf,
                                        icSigNamedColor2Tag,
                                        0,
                                        &byteCount,
                                        (Ptr)aName );
    if (err){
        goto CleanupAndExit;
    }

#ifdef IntelMode
    SwapLongOffset( &aName->ncolor.count, 0, 4 );
    SwapLongOffset( &aName->ncolor.nDeviceCoords, 0, 4 );
#endif
    err = CMConvIndexToName( aName, Arr2Indices, Ptr2Name, count );

CleanupAndExit:
    DisposeIfPtr( (Ptr)aName );
    LH_END_PROC("CMConvIndexToNameProfile")
    return err;
}

CMError CMGetNamedProfileInfoProfile( CMProfileRef aProf, pCMNamedProfileInfo Info );
CMError CMGetNamedProfileInfoProfile( CMProfileRef aProf, pCMNamedProfileInfo Info )
{   
    CMError             err = noErr;
    Ptr                 tagTbl;
    short               aOSerr;
    icNamedColor2Type   *aName = 0;
    unsigned long       byteCount;

    LH_START_PROC("CMGetNamedProfileInfoProfile")
    
    if( aProf == 0 )return cmparamErr;
    err = CMGetPartialProfileElement(   aProf,
                                        icSigNamedColor2Tag,
                                        0,
                                        &byteCount,
                                        0 );
    if (err)
        goto CleanupAndExit;
    aName = (icNamedColor2Type *)SmartNewPtr( byteCount, &aOSerr );
    err = aOSerr;
    if (err)
        goto CleanupAndExit;
    err = CMGetPartialProfileElement(   aProf,
                                        icSigNamedColor2Tag,
                                        0,
                                        &byteCount,
                                        (Ptr)aName );
    if (err){
        goto CleanupAndExit;
    }

    
    /* = CMNamedColor2Type_header(84) + firstName(32) + PCSSize(3*2) */
    tagTbl = (Ptr)aName + 8;
    
#ifdef IntelMode
    SwapLongOffset( &aName->ncolor.count, 0, 4 );
    SwapLongOffset( &aName->ncolor.nDeviceCoords, 0, 4 );
    SwapLongOffset( &aName->ncolor.vendorFlag, 0, 4 );
#endif
    memcpy( Info, tagTbl, sizeof( CMNamedProfileInfo ));
CleanupAndExit:

  /* Clean up allocated storage */
    DisposeIfPtr((Ptr) aName);
  LH_END_PROC("CMGetNamedProfileInfoProfile")
    return err;
}
CMError CMGetNamedProfileInfoCW( CMWorldRef *Storage, pCMNamedProfileInfo Info );
CMError CMGetNamedProfileInfoCW( CMWorldRef *Storage, pCMNamedProfileInfo Info )
{   
    LUT_DATA_TYPE   tagH = NULL;
    OSErr           err = noErr;
    CMMModelPtr     modelingData;
    Ptr             tagTbl;

    LH_START_PROC("CMGetNamedProfileInfoCW")
    
    if( Storage == 0 )return cmparamErr;
    LOCK_DATA( Storage );
    modelingData = (CMMModelPtr)(DATA_2_PTR(    Storage ));
    if( modelingData->hasNamedColorProf != NoNamedColorProfile ){
        /* prepare the tag table */
        tagH = modelingData->theNamedColorTagData;
        if (tagH==NULL){
            err = cmparamErr;
            goto CleanUp;
        }
        LOCK_DATA(tagH);
        
        /* tagTbl should now point to beginning of first device data */
        /* = CMNamedColor2Type_header(84) + firstName(32) + PCSSize(3*2) */
        tagTbl = (Ptr)DATA_2_PTR(tagH) + 8;
        
        memcpy( Info, tagTbl, sizeof( CMNamedProfileInfo ));
        UNLOCK_DATA(tagH);
    }
CleanUp:
    UNLOCK_DATA( Storage );
    LH_END_PROC("CMGetNamedProfileInfoCW")
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_cmm.h ===
/*
	File:		PI_CMMInitialization.h

	Contains:	Initialization procdures 
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	File Ownership:

*/
#ifndef PI_CMMInitialization_h
#define PI_CMMInitialization_h
CMError CMMInitPrivate( 			CMMModelPtr 		storage, 
						 			CMProfileRef 		srcProfile, 
						 			CMProfileRef 		dstProfile );
CMError CMMConcatInitPrivate	( 	CMMModelPtr 		storage, 
						  			CMConcatProfileSet 	*profileSet);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_basic.h ===
/*
	File:		PI_Basic.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/


#ifndef PI_BasicTypes_h
#define PI_BasicTypes_h

#define TRUE 1
#define FALSE 0
#define nil 0

#ifndef NULL
#define NULL 0
#endif

typedef double DREAL;			/* double Werte fr Datenaustausch */
typedef float REAL;				/* Floating Werte fr Datenaustausch */


typedef	unsigned char	UINT8;
typedef	unsigned short	UINT16;
typedef	unsigned int	UINT32;

typedef	signed char		INT8;
typedef	signed short	INT16;
typedef	signed int		INT32;

typedef	char	SINT8;
typedef	short	SINT16;
typedef	long	SINT32;

typedef	char	SInt8;
typedef	short	SInt16;
typedef	long	SInt32;

typedef	float			Float32;			/* IEEE 	32bits (04Byte), 1 for sign, 08 for exponent, 23 mantissa */
typedef	double			Float64;			/* IEEE 	64bits (08Byte), 1 for sign, 11 for exponent, 52 mantissa */
typedef	long double		Float80;			/* IEEE 	80bits (10Byte), 1 for sign, 15 for exponent, 64 mantissa */

typedef unsigned char Boolean;
typedef unsigned char Str255[256], Str63[64], Str32[33], Str31[32], Str27[28], Str15[16];
typedef char *Ptr;
typedef char **Handle;

struct Point {
    short							v;
    short							h;
};
typedef struct Point Point;

typedef Point *PointPtr;
struct Rect {
    short							top;
    short							left;
    short							bottom;
    short							right;
};
typedef struct Rect Rect;
typedef	UINT32	Fixed;
typedef UINT32 OSType;
typedef short OSErr;

typedef Rect *RectPtr;

/*
 *	Here ends the list of things that "belong" in Windows.
 */
struct RGBColor {
    unsigned short					red;						/*magnitude of red component*/
    unsigned short					green;						/*magnitude of green component*/
    unsigned short					blue;						/*magnitude of blue component*/
};
typedef struct RGBColor RGBColor, *RGBColorPtr, **RGBColorHdl;

struct ColorSpec {
    short							value;						/*index or other value*/
    RGBColor						rgb;						/*true color*/
};
typedef struct ColorSpec ColorSpec;

typedef ColorSpec *ColorSpecPtr;

typedef ColorSpec CSpecArray[1];

struct ColorTable {
    long							ctSeed;						/*unique identifier for table*/
    short							ctFlags;					/*high bit: 0 = PixMap; 1 = device*/
    short							ctSize;						/*number of entries in CTTable*/
    CSpecArray						ctTable;					/*array [0..0] of ColorSpec*/
};
typedef struct ColorTable ColorTable, *CTabPtr, **CTabHandle;

struct PixMap {
    Ptr								baseAddr;					/*pointer to pixels*/
    short							rowBytes;					/*offset to next line*/
    Rect							bounds;						/*encloses bitmap*/
    short							pmVersion;					/*pixMap version number*/
    short							packType;					/*defines packing format*/
    long							packSize;					/*length of pixel data*/
    Fixed							hRes;						/*horiz. resolution (ppi)*/
    Fixed							vRes;						/*vert. resolution (ppi)*/
    short							pixelType;					/*defines pixel type*/
    short							pixelSize;					/*# bits in pixel*/
    short							cmpCount;					/*# components in pixel*/
    short							cmpSize;					/*# bits per component*/
    long							planeBytes;					/*offset to next plane*/
    CTabHandle						pmTable;					/*color map for this pixMap*/
    long							pmReserved;					/*for future use. MUST BE 0*/
};
typedef struct PixMap PixMap, *PixMapPtr, **PixMapHandle;

struct ColorWorldInstanceRecord {
    long							data[4];
};
typedef struct ColorWorldInstanceRecord ColorWorldInstanceRecord;

typedef ColorWorldInstanceRecord *ColorWorldInstance;

struct BitMap {
    Ptr								baseAddr;
    short							rowBytes;
    Rect							bounds;
};
typedef struct BitMap BitMap;

typedef BitMap *BitMapPtr, **BitMapHandle;

struct Picture {
    short							picSize;
    Rect							picFrame;
};
typedef struct Picture Picture;

typedef Picture *PicPtr, **PicHandle;

struct DateTimeRec {
    short							year;
    short							month;
    short							day;
    short							hour;
    short							minute;
    short							second;
    short							dayOfWeek;
};
typedef struct DateTimeRec DateTimeRec;

enum {
    noErr						= 0,
    unimpErr					= -4,		/* unimplemented core routine, should NOT occure */
	notEnoughMemoryErr    		= 8L	    /* mem Error used in ProfileAccess.c only, from winerror.h		*/
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_app.h ===
/*
	File:		PI_App.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef PI_Application_h
#define PI_Application_h

#ifndef PI_Machine_h
/*#include "PI_Machine.h"*/
#endif

#define CM_MAX_COLOR_CHANNELS 8
typedef unsigned long CMBitmapColorSpace;
typedef long CMError;
typedef unsigned int PI_OSType;
typedef struct CMPrivateProfileRecord *CMProfileRef;

#ifndef LHApplication_h
#include "App.h"
#endif

#ifdef MS_Icm
#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include "icm.h"
#endif

struct PI_NAMEDCOLOR {
    unsigned long   namedColorIndex;
    char			*pName;
};

struct PI_GRAYCOLOR {
    unsigned short    gray;
};

struct PI_RGBCOLOR {
    unsigned short    red;
    unsigned short    green;
    unsigned short    blue;
};

struct PI_CMYKCOLOR {
    unsigned short    cyan;
    unsigned short    magenta;
    unsigned short    yellow;
    unsigned short    black;
};

struct PI_XYZCOLOR {
    unsigned short    X;
    unsigned short    Y;
    unsigned short    Z;
};

struct PI_YxyCOLOR {
    unsigned short    Y;
    unsigned short    x;
    unsigned short    y;
};

struct PI_LabCOLOR {
    unsigned short    L;
    unsigned short    a;
    unsigned short    b;
};

struct PI_GENERIC3CHANNEL {
    unsigned short    ch1;
    unsigned short    ch2;
    unsigned short    ch3;
};

struct PI_HiFiCOLOR {
    unsigned char    channel[CM_MAX_COLOR_CHANNELS];
};


typedef union CMColor {
    struct PI_GRAYCOLOR        gray;
    struct PI_RGBCOLOR         rgb;
    struct PI_CMYKCOLOR        cmyk;
    struct PI_XYZCOLOR         XYZ;
    struct PI_YxyCOLOR         Yxy;
    struct PI_LabCOLOR         Lab;
    struct PI_GENERIC3CHANNEL  gen3ch;
    struct PI_NAMEDCOLOR       namedColor;
    struct PI_HiFiCOLOR        hifi;
} CMColor;

#ifdef MS_Icm
enum {
/* General Errors */
	cmopenErr               	= ERROR_INVALID_PARAMETER, /* I/O Error used in ProfileAccess.c only           */
	cmparamErr              	= ERROR_INVALID_PARAMETER,

	cmProfileError				= ERROR_INVALID_PROFILE,

	cmMethodError				= ERROR_INVALID_TRANSFORM, /* This is an internal error, no CalcFunction found */
	cmCantConcatenateError		= ERROR_INVALID_TRANSFORM, /* No concatenation possible                        */
														
	cmInvalidColorSpace			= ERROR_COLORSPACE_MISMATCH, /* no match between Profile colorspace bitmap type */

	cmInvalidSrcMap				= ERROR_INVALID_COLORSPACE,	/* Source bitmap color space is invalid	     */
    cmInvalidDstMap				= ERROR_INVALID_COLORSPACE,	/* Destination bitmap color space is invalid */

	cmNamedColorNotFound		= ERROR_INVALID_COLORINDEX,	/* index > count of named colors            */

	cmElementTagNotFound		= ERROR_TAG_NOT_FOUND,

    userCanceledErr				= ERROR_CANCELLED,        /* callback proc returned to cancel calculation	*/
	badProfileError      		= ERROR_INVALID_PROFILE,  /* header->magic != icMagicNumber used in ProfileAccess.c only  */
    memFullErr					= ERROR_NOT_ENOUGH_MEMORY
};
#else
enum cmErrorCodes{
/* General Errors */
	cmopenErr               	= -200,		/* I/O Error used in ProfileAccess.c only						*/
	cmparamErr              	= 86,

	cmProfileError				= 2301,
	cmMethodError				= -203,		/* This is an internal error, no CalcFunction found				*/
	cmCantConcatenateError		= -208,		/* No concatenation possible									*/
														
	cmInvalidColorSpace			= -209,		/* no match between Profile colorspace bitmap type				*/
	cmInvalidSrcMap				= -210,		/* Source bitmap color space is invalid							*/
	cmInvalidDstMap				= -211,		/* Destination bitmap color space is invalid					*/
															
	cmNamedColorNotFound		= -216,		/* index > count of named colors								*/

	cmElementTagNotFound		= 2302,

    userCanceledErr				= -128,		/* callback proc returned to cancel calculation					*/
	badProfileError      		= -228,		/* header->magic != icMagicNumber used in ProfileAccess.c only	*/
    memFullErr					= 8
};
#endif

#if RenderInt
#define CallCMBitmapCallBackProc(f,a,b,c) (!((*f)(a,b,c)))
#else
#define CallCMBitmapCallBackProc(f,a,b,c ) ((*f)((a)-(b),c))
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=mac68k
#endif

#if PRAGMA_IMPORT_SUPPORTED
#pragma import on
#endif

typedef icHeader CMCoreProfileHeader;


/* Param for CWConcatColorWorld() */
struct CMConcatProfileSet {
	unsigned short 					keyIndex;					/* Zero-based */
	unsigned short 					count;						/* Min 1 */
	CMProfileRef 					profileSet[1];				/* Variable. Ordered from Source -> Dest */
};
typedef struct CMConcatProfileSet CMConcatProfileSet;

typedef icDateTimeNumber CMDateTime;
struct CMUniqueIdentification {
	icHeader 						profileHeader;
	CMDateTime 						calibrationDate;
	unsigned long 					ASCIIProfileDescriptionLen;
	char 							ASCIIProfileDescription[1];	/* variable length */
};
typedef struct CMUniqueIdentification CMUniqueIdentification;


enum {
	cmNoColorPacking			= 0x0000,
	cmAlphaSpace				= 0x0080,
	cmWord5ColorPacking			= 0x0500,
	cmWord565ColorPacking		= 0x0600,
	cmLong8ColorPacking			= 0x0800,
	cmLong10ColorPacking		= 0x0A00,
	cmAlphaFirstPacking			= 0x1000,
	cmOneBitDirectPacking		= 0x0B00,  /* for gamut check. highest bit first */
	cmAlphaLastPacking			= 0x0000,
	cm8PerChannelPacking		= 0x2000,
	cm10PerChannelPacking		= 0x0A00,
	cm16PerChannelPacking		= 0x4000,
	
	cm32_32ColorPacking			= 0x2700
};


enum {
	cmNoSpace					= 0,
	cmRGBSpace					= 1,
	cmCMYKSpace					= 2,
	cmHSVSpace					= 3,
	cmHLSSpace					= 4,
	cmYXYSpace					= 5,
	cmXYZSpace					= 6,
	cmLUVSpace					= 7,
	cmLABSpace					= 8,
	cmCMYSpace					= 9,
	cmGraySpace					= 10,
	cmReservedSpace2			= 11,
	cmGamutResultSpace			= 12,
	
	cmGenericSpace				= 13,			/*UWE: GenericDataFormat  */
	cmBGRSpace					= 14,			/*UWE: BGR  */
	cmYCCSpace					= 15,			/*UWE: YCC  */
	cmNamedIndexedSpace			= 16,			/* */

	cmMCFiveSpace				= 17,
	cmMCSixSpace				= 18,
	cmMCSevenSpace				= 19,
	cmMCEightSpace				= 20,
	
	cmKYMCSpace					= 29,
	cmRGBASpace					= cmRGBSpace + cmAlphaSpace,
	cmGrayASpace				= cmGraySpace + cmAlphaSpace,
	cmRGB16Space				= cmWord5ColorPacking + cmRGBSpace,
	cmRGB16_565Space			= cmWord565ColorPacking + cmRGBSpace,
	cmRGB32Space				= cmLong8ColorPacking + cmRGBSpace,
	cmARGB32Space				= cmLong8ColorPacking + cmAlphaFirstPacking + cmRGBASpace,
	cmCMYK32Space				= cmLong8ColorPacking + cmCMYKSpace,
	cmKYMC32Space				= cmLong8ColorPacking + cmKYMCSpace,
	cmHSV32Space				= cmLong10ColorPacking + cmHSVSpace,
	cmHLS32Space				= cmLong10ColorPacking + cmHLSSpace,
	cmYXY32Space				= cmLong10ColorPacking + cmYXYSpace,
	cmXYZ32Space				= cmLong10ColorPacking + cmXYZSpace,
	cmLUV32Space				= cmLong10ColorPacking + cmLUVSpace,
	cmLAB32Space				= cmLong10ColorPacking + cmLABSpace,
	cmGamutResult1Space			= cmOneBitDirectPacking + cmGamutResultSpace,
	cmRGB24Space				= cm8PerChannelPacking + cmRGBSpace,
	cmRGBA32Space				= cm8PerChannelPacking + cmAlphaLastPacking + cmRGBASpace,
	cmCMY24Space				= cm8PerChannelPacking + cmCMYSpace,
	cmLAB24Space				= cm8PerChannelPacking + cmLABSpace,
	
	cmGraySpace8Bit				= cmGraySpace + cm8PerChannelPacking,
	cmYCC24Space				= cm8PerChannelPacking + cmYCCSpace,
	cmYCC32Space				= cmLong8ColorPacking + cmYCCSpace,
	cmYCCASpace					= cmYCCSpace + cmAlphaSpace,
	cmYCCA32Space				= cm8PerChannelPacking + cmAlphaLastPacking + cmYCCASpace,
	cmAYCC32Space				= cmLong8ColorPacking + cmAlphaFirstPacking + cmYCCASpace,
	cmBGR24Space				= cm8PerChannelPacking + cmBGRSpace,
	cmBGR32Space				= cmLong8ColorPacking + cmBGRSpace + cmAlphaSpace,

	cmNamedIndexed24Space		= cmNamedIndexedSpace,
	cmNamedIndexed32Space		= cm32_32ColorPacking + cmNamedIndexedSpace,

	cmMCFive8Space				= cmMCFiveSpace + cm8PerChannelPacking,
	cmMCSix8Space				= cmMCSixSpace + cm8PerChannelPacking,
	cmMCSeven8Space				= cmMCSevenSpace + cm8PerChannelPacking,
	cmMCEight8Space				= cmMCEightSpace + cm8PerChannelPacking
#if ( CM_MAX_COLOR_CHANNELS == 16 )
	,
	cmMC9Space				= cmMCEight8Space + 1,
	cmMCaSpace				= cmMCEight8Space + 2,
	cmMCbSpace				= cmMCEight8Space + 3,
	cmMCcSpace				= cmMCEight8Space + 4,
	cmMCdSpace				= cmMCEight8Space + 5,
	cmMCeSpace				= cmMCEight8Space + 6,
	cmMCfSpace				= cmMCEight8Space + 7,
	cmMC2Space				= cmMCEight8Space + 8,
	cmMC98Space				= cmMC9Space + cm8PerChannelPacking,
	cmMCa8Space				= cmMCaSpace + cm8PerChannelPacking,
	cmMCb8Space				= cmMCbSpace + cm8PerChannelPacking,
	cmMCc8Space				= cmMCcSpace + cm8PerChannelPacking,
	cmMCd8Space				= cmMCdSpace + cm8PerChannelPacking,
	cmMCe8Space				= cmMCeSpace + cm8PerChannelPacking,
	cmMCf8Space				= cmMCfSpace + cm8PerChannelPacking,
	cmMC28Space				= cmMC2Space + cm8PerChannelPacking
#endif
};

struct CMBitmap {
	char *				image;			/*	pointer to image data						*/
	long 				width;			/*	count of pixel in one line					*/
	long 				height;			/*	count of lines								*/
	long 				rowBytes;		/*	offset in bytes from one line to next line	*/
	long 				pixelSize;		/*	not used									*/
	CMBitmapColorSpace	space;			/*	color space see above, e.g. cmRGB24Space	*/
	long 				user1;			/*	not used									*/
	long 				user2;			/*	not used									*/
};
typedef struct CMBitmap CMBitmap;

typedef char CMColorName[32];
typedef CMColorName *pCMColorName;
typedef const CMColorName *pcCMColorName;
typedef struct tagCMNamedProfileInfo{
	unsigned long	dwVendorFlags;
	unsigned long	dwCount;
	unsigned long   dwCountDevCoordinates;
	CMColorName		szPrefix;
	CMColorName		szSuffix;
}CMNamedProfileInfo;
typedef CMNamedProfileInfo *pCMNamedProfileInfo;

/* rendering intent element values  */

enum {
	cmPerceptual				= 0,							/* Photographic images */
	cmRelativeColorimetric		= 1,							/* Logo Colors */
	cmSaturation				= 2,							/* Business graphics */
	cmAbsoluteColorimetric		= 3								/* Logo Colors */
};

/* speed and quality flag options */
enum {
    cmNormalMode				= 0,							/* it uses the least significent two bits in the high word of flag */
    cmDraftMode					= 1,							/* it should be evaulated like this: right shift 16 bits first, mask off the */
    cmBestMode					= 2,							/* high 14 bits, and then compare with the enum to determine the option value. Do NOT shift if CWConcatColorWorld4MS is used */
    cmBestMode16Bit				= 3								/* calculate 16 bit combi LUT */
};

/* constants for the profheader-flags */
#define		kQualityMask		0x00030000		/* see Modes obove ( e.g. cmBestMode<<16 ) */
#define		kLookupOnlyMask		0x00040000
#define		kCreateGamutLutMask	0x00080000		/* Set Bit disables gamut lut creation */
#define		kUseRelColorimetric	0x00100000
#define		kStartWithXyzPCS	0x00200000
#define		kStartWithLabPCS	0x00400000
#define		kEndWithXyzPCS		0x00800000
#define		kEndWithLabPCS		0x01000000

typedef unsigned char PI_Boolean;

#if RenderInt
typedef  PI_Boolean  (__stdcall *CMBitmapCallBackProcPtr)(long max, long progress, void *refCon);
#else
typedef  PI_Boolean (*CMBitmapCallBackProcPtr)(long progress, void *refCon);
#endif
typedef CMBitmapCallBackProcPtr CMBitmapCallBackUPP;

/* Abstract data type for ColorWorld reference */
typedef struct CMPrivateColorWorldRecord *CMWorldRef;

/* Profile file and element access */
extern  PI_Boolean CMProfileElementExists(CMProfileRef prof, PI_OSType tag);
extern  CMError CMGetProfileElement(CMProfileRef prof, PI_OSType tag, unsigned long *elementSize, void *elementData);
extern  CMError CMGetProfileHeader(CMProfileRef prof, CMCoreProfileHeader *header);
extern  CMError CMGetPartialProfileElement(CMProfileRef prof, PI_OSType tag, unsigned long offset, unsigned long *byteCount, void *elementData);
extern  CMError CMSetProfileElementSize(CMProfileRef prof, PI_OSType tag, unsigned long elementSize);
extern  CMError CMSetPartialProfileElement(CMProfileRef prof, PI_OSType tag, unsigned long offset, unsigned long byteCount, void *elementData);
extern  CMError CMSetProfileElement(CMProfileRef prof, PI_OSType tag, unsigned long elementSize, void *elementData);
extern  CMError CMSetProfileHeader(CMProfileRef prof, const CMCoreProfileHeader *header);
/* Low-level matching functions */
extern  CMError CWNewColorWorld(CMWorldRef *cw, CMProfileRef src, CMProfileRef dst);
extern  CMError CWConcatColorWorld(CMWorldRef *cw, CMConcatProfileSet *profileSet);
extern  CMError CWConcatColorWorld4MS (	CMWorldRef *storage, CMConcatProfileSet	*profileSet,
									    UINT32	*aIntentArr, UINT32 nIntents,
										UINT32 dwFlags );
extern  CMError	CWCreateLink4MS( CMWorldRef storage, CMConcatProfileSet *profileSet, UINT32 aIntentArr, icProfile **theLinkProfile );
extern  CMError CWLinkColorWorld(CMWorldRef *cw, CMConcatProfileSet *profileSet);
extern  void	CWDisposeColorWorld(CMWorldRef cw);
extern  CMError CWMatchColors(CMWorldRef cw, CMColor *myColors, unsigned long count);
extern  CMError CWCheckColors(CMWorldRef cw, CMColor *myColors, unsigned long count, unsigned char *result);
extern  CMError CWCheckColorsMS(CMWorldRef cw, CMColor *myColors, unsigned long count, unsigned char *result);
extern  CMError CWGetColorSpaces(CMWorldRef cw, CMBitmapColorSpace *In, CMBitmapColorSpace *Out );
/* Bitmap matching */
extern  CMError CWMatchBitmap(CMWorldRef cw, CMBitmap *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, CMBitmap *matchedBitmap);
extern  CMError CWCheckBitmap(CMWorldRef cw, const CMBitmap *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, CMBitmap *resultBitmap);
extern  CMError CWMatchBitmapPlane(CMWorldRef cw, LH_CMBitmapPlane *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, LH_CMBitmapPlane *matchedBitmap);
extern  CMError CWCheckBitmapPlane(CMWorldRef cw, LH_CMBitmapPlane *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, LH_CMBitmapPlane *matchedBitmap);

extern  void	CMFullColorRemains( CMWorldRef Storage, long ColorMask ); /* Special function for cmyk to cmyk match */
extern  void	CMSetLookupOnlyMode( CMWorldRef Storage, PI_Boolean Mode ); /* Special function for setting or resetting LookupOnly Mode after NCMInit.., CMConcat.. */
extern  CMError CMValidateProfile( CMProfileRef prof, PI_Boolean* valid );

extern  CMError CMConvNameToIndexProfile( CMProfileRef prof, pcCMColorName, unsigned long *, unsigned long );
extern  CMError CMConvNameToIndexCW( CMWorldRef *Storage, pcCMColorName, unsigned long *, unsigned long );
extern  CMError CMConvIndexToNameProfile( CMProfileRef prof, unsigned long *, pCMColorName, unsigned long );
extern  CMError CMConvIndexToNameCW( CMWorldRef *Storage, unsigned long *, pCMColorName, unsigned long );
extern  CMError CMGetNamedProfileInfoProfile( CMProfileRef prof, pCMNamedProfileInfo );
extern  CMError CMGetNamedProfileInfoCW( CMWorldRef *Storage, pCMNamedProfileInfo );
/*
extern	CMError CMConvertNamedIndexToPCS( CMWorldRef cw, CMColor *theData, unsigned long pixCnt );
extern	CMError CMConvertNamedIndexToColors( CMWorldRef cw, CMColor *theData, unsigned long pixCnt );
extern	CMError CMConvertNamedIndexBitMap( CMWorldRef cw, CMBitmap *BitMap, CMBitmap *resultBitMap );
*/
#if PRAGMA_IMPORT_SUPPORTED
#pragma import off
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_color.h ===
/*
	File:		PI_ColorWorld.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Change History (most recent first):
*/
#ifndef PI_ColorWorld_h
#define PI_ColorWorld_h
CMError LHColorWorldOpen (Ptr* storage);

CMError LHColorWorldClose( Ptr storage );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_cmm.c ===
/*
	File:		PI_CMMInitialization.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHGenLuts_h
#include "GenLuts.h"
#endif

#ifndef PI_CMMInitialization_h
#include "PI_CMM.h"
#endif

#ifndef LHStdConversionLuts_h
#include "StdConv.h"
#endif

#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kCMMInitializationID
#define __TYPES__
/*#include "DebugSpecial.h"*/
/*#include "LH_Util.h"*/
#endif
#endif

#define ALLOW_DEVICE_LINK   /* allows link as the last profile in a chain, change in genluts.c too */
/* ______________________________________________________________________

CMError CMMInitPrivate( 	CMMModelPtr 		storage, 
						 	CMProfileRef 		srcProfile, 
						 	CMProfileRef 		dstProfile );

	Abstract:
		ColorWorld function called to initialize a matching session.

	Params:
		Storage		(in)		Reference to CMMModel.
		srcProfile	(in)		Reference to source CMProfileRef.
		dstProfile	(in)		Reference to destination CMProfileRef.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CMMInitPrivate( 	CMMModelPtr 		storage, 
						 	CMProfileRef 		srcProfile, 
						 	CMProfileRef 		dstProfile )
{
    CMError					err = noErr;
    OSErr					aOSerr = noErr;
    CMConcatProfileSet 		*profileSet = nil;
    CMCoreProfileHeader		sourceHeader;
    CMCoreProfileHeader		destHeader;
    Boolean					valid;
    short					mode = 0;
#ifdef DEBUG_OUTPUT
    long					timer = TickCount();
#endif

#ifdef DEBUG_OUTPUT
    if ( DebugCheck(kThisFile, kDebugMiscInfo) )
        DebugPrint(" ->CMMInitPrivate\n");
#endif

    /*	--------------------------------------------------------------------------------------- valid profiles ???*/
    err = CMValidateProfile( srcProfile, &valid );
    if (err)
        goto CleanupAndExit;
    if (!valid)
    {
#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugErrorInfo) )
            DebugPrint(" CMMInitPrivate ERROR:  srcProfile is NOT valid!\n");
#endif
        
#ifdef realThing
        err = cmProfileError;
        goto CleanupAndExit;
#endif
    }

    err = CMValidateProfile(dstProfile, &valid );
    if (err)
        goto CleanupAndExit;
    if (!valid)
    {
#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugErrorInfo) )
            DebugPrint(" CMMInitPrivate ERROR:  dstProfile is NOT valid!\n");
#endif
#ifdef realThing
        err = cmProfileError;
        goto CleanupAndExit;
#endif
    }
    
    /*	--------------------------------------------------------------------------------------- initialization*/
	(storage)->lutParam.inputLut  = DISPOSE_IF_DATA((storage)->lutParam.inputLut);
	(storage)->lutParam.colorLut  = DISPOSE_IF_DATA((storage)->lutParam.colorLut);
	(storage)->lutParam.outputLut = DISPOSE_IF_DATA((storage)->lutParam.outputLut);
	
	(storage)->gamutLutParam.inputLut  = DISPOSE_IF_DATA((storage)->gamutLutParam.inputLut);
	(storage)->gamutLutParam.colorLut  = DISPOSE_IF_DATA((storage)->gamutLutParam.colorLut);
	(storage)->gamutLutParam.outputLut = DISPOSE_IF_DATA((storage)->gamutLutParam.outputLut);

 	(storage)->theNamedColorTagData = DISPOSE_IF_DATA((storage)->theNamedColorTagData);
	
	(storage)->srcProfileVersion = icVersionNumber;
    (storage)->dstProfileVersion = icVersionNumber;

    /*	--------------------------------------------------------------------------------------- check version of source profile*/
    err = CMGetProfileHeader( srcProfile, &sourceHeader);
    if (err)
        goto CleanupAndExit;

    if ( !((sourceHeader.version & 0xff000000) >= icVersionNumber) ){
        err = cmProfileError;
        goto CleanupAndExit;
    }
	if (sourceHeader.deviceClass == icSigLinkClass)
	{
		err = cmCantConcatenateError;
		goto CleanupAndExit;
	}

    /*	--------------------------------------------------------------------------------------- check version of destination profile*/
    err = CMGetProfileHeader( dstProfile, &destHeader);
    if (err)
        goto CleanupAndExit;

    if ( !((destHeader.version & 0xff000000) >= icVersionNumber) ){
        err = cmProfileError;
        goto CleanupAndExit;
    }
  	if (destHeader.deviceClass == icSigLinkClass)
	{
		err = cmCantConcatenateError;
		goto CleanupAndExit;
	}
  	storage->lookup =  (Boolean)((sourceHeader.flags & kLookupOnlyMask)>>16);		/* lookup vs. interpolation */
  	
#ifdef RenderInt
	if( storage-> dwFlags != 0xffffffff ){
		storage->lookup = (Boolean)((storage-> dwFlags & kLookupOnlyMask)>>16);
	}
#endif
    /*	--------------------------------------------------------------------------------------- 'normal' cases*/
                profileSet = (CMConcatProfileSet *)SmartNewPtr(sizeof (CMConcatProfileSet) + sizeof(CMProfileRef), &aOSerr);
                if (aOSerr)
                    goto CleanupAndExit;
                    
                profileSet->count    = 2;
                profileSet->keyIndex = 1;
                /* profileSet->flags	 = sourceHeader.flags; */
                profileSet->profileSet[0] = srcProfile;
                /* profileSet->profileSet[0]->renderingIntent = sourceHeader.renderingIntent; */
                profileSet->profileSet[1] = dstProfile;
                /* profileSet->profileSet[1]->renderingIntent = destHeader.renderingIntent; */
                     
                err =  PrepareCombiLUTs( storage, profileSet );	
    if (err)
        goto CleanupAndExit;

CleanupAndExit:
    profileSet = (CMConcatProfileSet*)DisposeIfPtr( (Ptr)profileSet );

#ifdef DEBUG_OUTPUT
    if ( err && DebugCheck(kThisFile, kDebugErrorInfo) )
        DebugPrint(" CMMInitPrivate: err = %d\n", err);
    if ( DebugCheck(kThisFile, kDebugTimingInfo) )
        DebugPrint("  time in CMMInitPrivate: %f second(s)\n",(TickCount()-timer)/60.0);
    if ( DebugCheck(kThisFile, kDebugMiscInfo) )
        DebugPrint(" <-CMMInitPrivate\n");
#endif
	return err;
} 

CMError MakeSessionFromLink(		CMMModelPtr 		storage, 
						  			CMConcatProfileSet 	*profileSet	);

#ifndef HD_NEW_CONCATE_INIT
CMError CMMConcatInitPrivate	( 	CMMModelPtr 		storage, 
						  			CMConcatProfileSet 	*profileSet)
{
	CMCoreProfileHeader	firstHeader;
	CMCoreProfileHeader	lastHeader;
	CMCoreProfileHeader	tempHeader;
	CMError					err = noErr;
	unsigned short			count;
	unsigned short			loop;
	Boolean					valid;
	CMProfileRef			theProfile;
	#ifdef DEBUG_OUTPUT
	long					timer = TickCount();
	#endif
	

	#ifdef DEBUG_OUTPUT
	if ( DebugCheck(kThisFile, kDebugMiscInfo) )
	{
		DebugPrint(" ->CMMConcatInitPrivate\n");
		DebugPrint("  got %d profiles      keyindex is %d \n", profileSet->count, profileSet->keyIndex);
	}
	#endif
	
	count = profileSet->count;
	if (count == 0)
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	/* ------------------------------------------------------------------------------------------ get first header	*/
	err = CMGetProfileHeader( profileSet->profileSet[0], &firstHeader);
	if (err)
		goto CleanupAndExit;
	/* ------------------------------------------------------------------------------------------ only one profile? -> has to be a link profile	*/
  	storage->lookup =  (Boolean)((firstHeader.flags & kLookupOnlyMask)>>16);		/* lookup vs. interpolation */
  	
#ifdef RenderInt
	if( storage-> dwFlags != 0xffffffff ){
		storage->lookup = (Boolean)((storage-> dwFlags & kLookupOnlyMask)>>16);
	}
#endif
	if (count == 1 && firstHeader.deviceClass != icSigNamedColorClass )
	{
		if (firstHeader.deviceClass != icSigLinkClass && firstHeader.deviceClass != icSigAbstractClass )
		{
			err =cmCantConcatenateError;
			goto CleanupAndExit;
		}
		else{
			err = MakeSessionFromLink( storage, profileSet	);
			if( err == 0 )return noErr;
		}
		lastHeader = firstHeader;
	} else
	{
		/* -------------------------------------------------------------------------------------- get last header	*/
		err = CMGetProfileHeader( profileSet->profileSet[count-1], &lastHeader);
		if (err)
			goto CleanupAndExit;
#ifndef ALLOW_DEVICE_LINK
		if (lastHeader.deviceClass == icSigLinkClass)
		{
			err = cmCantConcatenateError;
			goto CleanupAndExit;
		}
#endif
	}
	
	/* ------------------------------------------------------------------------------------------ valid profiles ???	*/
	for ( loop = 0; loop < count; loop++)
	{
		theProfile = profileSet->profileSet[loop];
		err = CMValidateProfile( theProfile, &valid );
		if (err)
			goto CleanupAndExit;
		if (!valid)
		{
		 	#ifdef DEBUG_OUTPUT
			if ( DebugCheck(kThisFile, kDebugErrorInfo) )
				DebugPrint(" CMMConcatInitPrivate ERROR: profile #%d is NOT valid!\n", loop);
			#endif
			#ifdef realThing
			err = cmProfileError;
			goto CleanupAndExit;
			#endif
		}
		/* -------------------------------------------------------------------------------------- link profiles may not be used inbetween	*/
		if ( (loop > 0) && (loop < count-1))
		{
			err = CMGetProfileHeader( profileSet->profileSet[loop], &tempHeader);
			if (err)
				goto CleanupAndExit;
			if (tempHeader.deviceClass == icSigLinkClass)
			{
				err = cmCantConcatenateError;
				goto CleanupAndExit;
			}
		}
	}
	
	/* ------------------------------------------------------------------------------------------ no abstract profile as first or last	*/
	if ( (count >1) && ( (firstHeader.deviceClass == icSigAbstractClass) || (lastHeader.deviceClass == icSigAbstractClass) ) )
	{
		err = cmCantConcatenateError;
		goto CleanupAndExit;
	}
	
	/* ------------------------------------------------------------------------------------------ initialization	*/
	(storage)->lutParam.inputLut  = DISPOSE_IF_DATA((storage)->lutParam.inputLut);
	(storage)->lutParam.colorLut  = DISPOSE_IF_DATA((storage)->lutParam.colorLut);
	(storage)->lutParam.outputLut = DISPOSE_IF_DATA((storage)->lutParam.outputLut);
	
	(storage)->gamutLutParam.inputLut  = DISPOSE_IF_DATA((storage)->gamutLutParam.inputLut);
	(storage)->gamutLutParam.colorLut  = DISPOSE_IF_DATA((storage)->gamutLutParam.colorLut);
	(storage)->gamutLutParam.outputLut = DISPOSE_IF_DATA((storage)->gamutLutParam.outputLut);

	(storage)->theNamedColorTagData = DISPOSE_IF_DATA((storage)->theNamedColorTagData);
	/* ------------------------------------------------------------------------------------------ check 'special' cases	*/
	{
		err =  PrepareCombiLUTs( storage, profileSet );	
	}

CleanupAndExit:

	#ifdef DEBUG_OUTPUT
	if ( err && DebugCheck(kThisFile, kDebugErrorInfo) )
		DebugPrint("  CMMConcatInitPrivate: err = %d\n", err);
	DebugPrint("  time in CMMConcatInitPrivate: %f second(s)\n",(TickCount()-timer)/60.0);
	DebugPrint(" <-CMMConcatInitPrivate\n");
	#endif
	return( err );
} 

Boolean IsPowerOf2( unsigned long l );
Boolean IsPowerOf2( unsigned long l )
{
	unsigned long i;
	for( i=1; i<32; i++){
		if( (1U<<i) == l ) return 1;
	}
	return 0;
}

#endif
CMError MakeSessionFromLink(		CMMModelPtr 		storage, 
						  			CMConcatProfileSet 	*profileSet	)
{
	CMLutParam	theLut={0};	
	CMLutParam	*theLutData;	
	LHCombiData	theCombi={0};
	LHCombiData	*theCombiData;
	double		*aDoublePtr;
	double		aDouble;
	OSType		theTag = icSigAToB0Tag;

  	CMError		err = noErr;
  	OSErr		aOSerr = noErr;
	Ptr			profileLutPtr = nil;
	UINT32		elementSize;
	double		factor;
	UINT32 		byteCount;
    CMCoreProfileHeader		aHeader;

	LH_START_PROC("MakeSessionFromLink")


	theLutData = &theLut;
	theCombiData = &theCombi;
 	theCombiData->theProfile = profileSet->profileSet[0];

	/* -------------------------------------------------------- get partial tag data from profile */
	err = CMGetProfileElement(theCombiData->theProfile, theTag, &elementSize, nil);
	if (err)
		goto CleanupAndExit;
	
	byteCount = 52;											/* get the first 52 bytes out of the profile */
  	profileLutPtr = SmartNewPtr(byteCount, &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	
    err = CMGetProfileElement( theCombiData->theProfile, theTag, &byteCount, profileLutPtr );
	if (err)
		goto CleanupAndExit;
#ifdef IntelMode
    SwapLongOffset( &((icLut16Type*)profileLutPtr)->base.sig, 0, 4 );
    SwapShortOffset( &((icLut16Type*)profileLutPtr)->lut.inputEnt, 0, 2 );
    SwapShortOffset( &((icLut16Type*)profileLutPtr)->lut.outputEnt, 0, 2 );
#endif

	theLutData->colorLutInDim 		= ((icLut8Type*)profileLutPtr)->lut.inputChan;
	theLutData->colorLutOutDim 		= ((icLut8Type*)profileLutPtr)->lut.outputChan;
	theLutData->colorLutGridPoints 	= ((icLut8Type*)profileLutPtr)->lut.clutPoints;

	switch( theLutData->colorLutInDim ){
	  case 3:
		if( theLutData->colorLutGridPoints != 16 && theLutData->colorLutGridPoints != 32 ){
			err = 1;
			goto CleanupAndExit;
		}
		break;
	  case 4:
		if( theLutData->colorLutGridPoints != 8 && theLutData->colorLutGridPoints != 16 ){
			err = 1;
			goto CleanupAndExit;
		}
		break;
	}

	err = CMGetProfileHeader( profileSet->profileSet[0], &aHeader);
	if (err)
		goto CleanupAndExit;
	storage->firstColorSpace = aHeader.colorSpace;
	storage->lastColorSpace = aHeader.pcs;
    storage->srcProfileVersion = icVersionNumber;
    storage->dstProfileVersion = icVersionNumber;

	if (	( theLutData->colorLutInDim == 3) &&
			( aHeader.pcs == icSigXYZData ) )
	{
		factor = 1.;
		err = GetMatrixFromProfile(theLutData, theCombiData, theTag, factor);
		if( err ) goto CleanupAndExit;
		aDoublePtr = (double *)theLutData->matrixMFT;
		if( aDoublePtr != 0 ){
			aDouble = aDoublePtr[0] + aDoublePtr[4] + aDoublePtr[8];
			if( aDouble > 3.0 + 1E-6 || aDouble < 3.0 - 1E-6 ){
				err = 1;
				goto CleanupAndExit;
			}
		}
	}
	theCombiData->maxProfileCount = 0;
	if( ((icLut16Type*)profileLutPtr)->base.sig == icSigLut16Type ){
		theCombiData->doCreate_16bit_Combi = 1;
		theCombiData->doCreate_16bit_ELut = 0;
		theCombiData->doCreate_16bit_XLut = 1;
		theCombiData->doCreate_16bit_ALut = 0;
	}
	else{
		theCombiData->doCreate_16bit_Combi = 0;
		theCombiData->doCreate_16bit_ELut = 0;
		theCombiData->doCreate_16bit_XLut = 0;
		theCombiData->doCreate_16bit_ALut = 0;
	}

	/* ---------------------------------------------------------------------- process A Lut */
	err = Extract_MFT_Alut( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;

	/* ---------------------------------------------------------------------- process X Lut */
	err = Extract_MFT_Xlut ( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;
	
	/* ---------------------------------------------------------------------- process E Lut */
	err = Extract_MFT_Elut( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;

	storage->lutParam = *theLutData;

	/* ---------------------------------------------------------------------------------
		 clean up
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:
	profileLutPtr = DisposeIfPtr(profileLutPtr);
	LH_END_PROC("MakeSessionFromLink")
	return err;
}
#if 0
#define	POS(x)	((x) > (0) ? (x) : -(x))
CMError QuantizeNamedValues( CMMModelPtr 		storage,
							 Ptr				imgIn,
							 long				size )
{
	long	j,k;
	UINT16	*imgInPtr;
	UINT16	*tagTbl = NULL,*colorPtr = NULL;
	Handle	tagH = NULL;
	CMError	err = noErr;
	long	elemSz,deviceChannelCount,count;
	UINT16	LL,aa,bb;
	UINT32	dE,dEnow,index;

	LH_START_PROC("QuantizeNamedValues")
	tagH = storage->theNamedColorTagData;
	if (tagH==NULL) 
	{
		err = cmparamErr;
		goto CleanUp;
	}
	LOCK_DATA(tagH);
	
	/* tagTbl should now point to beginning of first device data */
	/* = CMNamedColor2Type_header(84) + firstName(32) + PCSSize(3*2) */
	tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 61;
	
	/* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
	count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
	deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
	if (deviceChannelCount==3) 
	{
		elemSz = 32+(3+3)*sizeof(SINT16);
	} else if (deviceChannelCount == 4) 
	{
		elemSz = 32+(3+4)*sizeof(SINT16);
	} else if (deviceChannelCount == 0) 
	{
		elemSz = 32+(3+0)*sizeof(SINT16);
	} else 
	{
		err = cmparamErr;
		goto CleanUp;
	}
	elemSz/=2;

	imgInPtr = (UINT16 *)  imgIn;
 	for (j = 0; j < size; j++) 
	{
		LL = (*imgInPtr+0);
		aa = (*imgInPtr+1);
		bb = (*imgInPtr+2);
		/* go through the whole table to find the closest one*/
		dEnow = 0x40000;	/* just arbitrarily high = 256*256*4 */
		index =(UINT32)-1;
		colorPtr = tagTbl;
		for (k = 0; k < count; k++) 
		{
			dE = 	  POS(LL - *(colorPtr+0));
			dE = dE + POS(aa - *(colorPtr+1));
			dE = dE + POS(bb - *(colorPtr+2));
			if (dE < dEnow) 
			{
				index = k;
				dEnow = dE;
			}
			colorPtr += elemSz;
		}
		colorPtr = tagTbl + index * elemSz;
		*(imgInPtr+0)= *(colorPtr+0);
		*(imgInPtr+1)= *(colorPtr+1);
		*(imgInPtr+2)= *(colorPtr+2);
		imgInPtr += 3;
	}
		UNLOCK_DATA(tagH);
CleanUp:
	LH_END_PROC("QuantizeNamedValues")
	return err;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_color.c ===
/*
	File:		PI_ColorWorld.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef PI_ColorWorld_h
#include "PI_Color.h"
#endif

#ifndef realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kLHCMDo3DID
#define __TYPES__
/*#include "DebugSpecial.h"*/
/*#include "LH_Util.h"*/
#endif
#endif

#ifndef PI_CMMInitialization_h
#include "PI_CMM.h"
#endif

#ifndef MemLink_h
#include "MemLink.h"
#endif

/* ______________________________________________________________________

         CMError
               LHColorWorldOpen (Handle* storage)

        Abstract:
                opens ColorWorld and allocates up any necessary memory

        Params:
                storage         (in/out)   pointer to
                                           handle to memory to be used by CMM

        Return:
                noErr                      successful

   _____________________________________________________________________ */

 CMError LHColorWorldOpen (Ptr* storage)
{ 
    Ptr 			    myStorage;
    OSErr               err;
    
    myStorage = (Ptr)SmartNewPtrClear( sizeof( CMMModelData ) , &err);
    if (err) 
        goto CleanupAndExit;
    else
    {
        *storage = myStorage;
    }

CleanupAndExit:
    return err;
}

/* ______________________________________________________________________

          CMError
        LHColorWorldClose(Handle storage);

        Abstract:
                closes ColorWorld and cleans up any remaining memory allocations

        Params:
                storage (in/out)        handle to memory to be used by CMM

        Return:
                noErr           successful

   _____________________________________________________________________ */

 CMError LHColorWorldClose( Ptr storage )
{ 
    CMMModelPtr  modelData = (CMMModelPtr)storage;

    if (storage)
    {
		DISPOSE_IF_DATA((modelData)->lutParam.inputLut);		
		DISPOSE_IF_DATA((modelData)->lutParam.outputLut);		
		DISPOSE_IF_DATA((modelData)->lutParam.colorLut);

		DISPOSE_IF_DATA((modelData)->gamutLutParam.inputLut);		
		DISPOSE_IF_DATA((modelData)->gamutLutParam.outputLut);		
		DISPOSE_IF_DATA((modelData)->gamutLutParam.colorLut);

		DISPOSE_IF_DATA((modelData)->theNamedColorTagData);
#if	__IS_MAC
		DisposeIfHandle((modelData)->Monet);
#endif

		DisposeIfPtr(storage);
    }
    return( noErr );
}
/* ______________________________________________________________________

         CMError
               CWNewColorWorld (CMWorldRef*    storage,
                                 CMProfileRef   srcProfile, 
                                 CMProfileRef   dstProfile)

        Abstract:
                opens ColorWorld and allocates up any necessary memory,
                fill buffer for color transformation


        Params:
                storage         (in/out)   Ptr to memory to be used by CMM
                srcProfile      (in)       pointer to source profile
                                           description
                dstProfile      (in)       pointer to destination profile
                                           description

                storage:
                typedef struct CMPrivateColorWorldRecord *CMWorldRef;

        Return:
                noErr                      successful
		System or result code if an error occurs.

   _____________________________________________________________________ */


 CMError 
       CWNewColorWorld (	CMWorldRef*    storage,
							CMProfileRef   srcProfile,
							CMProfileRef   dstProfile)
{ 
    Ptr 		myStorage = NULL;
    CMError    	err;

#ifdef DEBUG_OUTPUT
    /*printf("vor LHColorWorldOpen\n");*/
#endif
    err = LHColorWorldOpen(&myStorage);
#ifdef DEBUG_OUTPUT
    /*printf("nach LHColorWorldOpen: err = %d\n", err);*/
#endif
    if ( !err )
    {
        ((CMMModelPtr)myStorage)->aIntentArr	= 0;
		((CMMModelPtr)myStorage)->dwFlags		= 0xffffffff;
        err =  CMMInitPrivate((CMMModelPtr)myStorage,
                               srcProfile, 
                               dstProfile);
#ifdef DEBUG_OUTPUT
    /*printf("nach NCMMInitPrivate: err = %d\n", err);*/
#endif
    }


    if ( !err )
    {
		*storage = (CMWorldRef)myStorage;
    }
	else{
		*storage = (CMWorldRef)0;
		LHColorWorldClose( myStorage );
	}

    return err;
}

/* ______________________________________________________________________

         CMError
               CWConcatColorWorld (	CMWorldRef*    storage,
									CMConcatProfileSet* profileSet )

        Abstract:
                opens ColorWorld and allocates up any necessary memory,
                fill buffer for color transformation


        Params:
                storage         (in/out)   Ptr to memory to be used by CMM
				profileSet		(in)		CMConcatProfileSet contains an array of
											Profiles which describe the processing
											to be carried out.The profileSet array
											is in processing order Source through
											Destination. A minimum of one CMProfileRef
											must be specified.

                storage:
                typedef struct CMPrivateColorWorldRecord *CMWorldRef;

        Return:
                noErr                      successful
		System or result code if an error occurs.

   _____________________________________________________________________ */
 CMError 
       CWConcatColorWorld  (	CMWorldRef*         storage,
								CMConcatProfileSet* profileSet)
{ 
    Ptr 		myStorage = NULL;
    CMError     err;

    err = LHColorWorldOpen(&myStorage);

    if ( !err )
    {
        ((CMMModelPtr)myStorage)->aIntentArr	= 0;
		((CMMModelPtr)myStorage)->dwFlags		= 0xffffffff;
        err = CMMConcatInitPrivate  ((CMMModelPtr)myStorage, profileSet );
    }


    if ( !err )
    {
		*storage = (CMWorldRef)myStorage;
    }
	else{
		*storage = (CMWorldRef)0;
		LHColorWorldClose( myStorage );
	}

    return err;
}

#if WRITE_PROFILE
 void WriteProf( Ptr name, icProfile *theProf, long currentSize );
#endif
/* ______________________________________________________________________

         CMError
           CWConcatColorWorld4MS (	CMWorldRef			*storage,
									CMConcatProfileSet	*profileSet,
									UINT32				*aIntentArr,
									UINT32				nIntents,
									UINT32				dwFlags
								)

        Abstract:
                opens ColorWorld and allocates up any necessary memory,
                fill buffer for color transformation


        Params:
                storage         (in/out)   Ptr to memory to be used by CMM
				profileSet		(in)		CMConcatProfileSet contains an array of
											Profiles which describe the processing
											to be carried out.The profileSet array
											is in processing order Source through
											Destination. A minimum of one CMProfileRef
											must be specified.

				padwIntents		(in)		Points to an array of intent structures.
											0 = default behavior ( intents out of profiles )

				nIntents		(in)		Specifies the number of intents in the intent array. 
											Can be 1, or the same value as nProfiles.

				dwFlags			(in)		Specifies flags to control creation of the transform.
											These flags are intended only as hints, and it is up to the CMM
											to determine how best to use these flags. 
											Set the high-order word to ENABLE_GAMUT_CHECKING if the transform will be used 
											for gamut checking. 
											The low-order WORD can have one of the following constant values:
											PROOF_MODE, NORMAL_MODE, BEST_MODE. Moving from PROOF_MODE to BEST_MODE, 
											output quality generally improves and transform speed declines.
        Return:
                noErr                      successful
		System or result code if an error occurs.

   _____________________________________________________________________ */
 CMError	CWConcatColorWorld4MS  (	CMWorldRef			*storage,
										CMConcatProfileSet	*profileSet,
										UINT32				*aIntentArr,
										UINT32				nIntents,
										UINT32				dwFlags
								  )
{ 
    Ptr 		myStorage = NULL;
    CMError     err;
#if WRITE_PROFILE
	icProfile *theLinkProfile;
	long l;
#endif

    err = LHColorWorldOpen(&myStorage);

    if ( !err )
    {
		((CMMModelPtr)myStorage)->aIntentArr	= aIntentArr;
        ((CMMModelPtr)myStorage)->nIntents		= nIntents;
        ((CMMModelPtr)myStorage)->dwFlags		= dwFlags;
		err = CMMConcatInitPrivate  ((CMMModelPtr)myStorage, profileSet );
    }


    if ( !err )
    {
		*storage = (CMWorldRef)myStorage;
    }
	else{
		*storage = (CMWorldRef)0;
		LHColorWorldClose( myStorage );
	}

#if WRITE_PROFILE
	err = DeviceLinkFill( (CMMModelPtr)myStorage, profileSet, &theLinkProfile, 0 );
	if( !err ){
		l = *(unsigned long *)theLinkProfile;
		SwapLong(&l);
		WriteProf( "test", theLinkProfile, l );
	}
#endif
    return err;
}

 CMError 
       CWLinkColorWorld (	CMWorldRef*         storage,
                            CMConcatProfileSet* profileSet)
{ 
    Ptr 		myStorage = NULL;
    CMError     err;

    err = LHColorWorldOpen(&myStorage);

	if ( !err )
    {
		((CMMModelPtr)myStorage)->currentCall	= kCMMNewLinkProfile;
		((CMMModelPtr)myStorage)->aIntentArr	= 0;
		((CMMModelPtr)myStorage)->dwFlags		= 0xffffffff;
		err = CMMConcatInitPrivate  ((CMMModelPtr)myStorage, profileSet );
    }


    if ( !err )
    {
		*storage = (CMWorldRef)myStorage;
    }
	else{
		*storage = (CMWorldRef)0;
		LHColorWorldClose( myStorage );
	}

    return err;
}

/* ______________________________________________________________________

         CMError
               CWDisposeColorWorld (CMWorldRef storage)

        Abstract:
                closes ColorWorld and cleans up any remaining memory allocations

        Params:
                storage         (in/out)    handle to memory to be used by CMM
        
        Return:
                -
   _____________________________________________________________________ */


 void 
       CWDisposeColorWorld ( CMWorldRef storage )
{ 
    LHColorWorldClose ( (Ptr)storage ); 
}

void CMSetLookupOnlyMode( CMWorldRef	Storage,
						  PI_Boolean		Mode )
{
	CMMModelPtr		aPtr;

	if( Storage == 0 )return;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	aPtr->lookup = Mode;
	UNLOCK_DATA( Storage );
	return;
}

void CMFullColorRemains( CMWorldRef	Storage,
						 long		ColorMask )
{
	CMMModelPtr		aPtr;
	CMLutParamPtr	lutParamPtr;
	long Address,Size,i,j;

	if( Storage == 0 )return;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	lutParamPtr = &aPtr->lutParam; 

	Size = lutParamPtr->colorLutWordSize / 8;
	if( !(lutParamPtr->colorLutInDim == 4 && lutParamPtr->colorLutOutDim == 4 ))return;

	for( i=0; i<4; i++ ){
		if( (ColorMask & (1<<i)) == 0 ) continue;
		Address = lutParamPtr->colorLutGridPoints - 1;
		for( j=3-i+1; j<4; j++ )Address *= lutParamPtr->colorLutGridPoints;  
		Address	= Address * lutParamPtr->colorLutOutDim;
		for( j=0; j<4; j++){
			if( i == j ){
				if( Size == 1 ){
					*( ((unsigned char*)lutParamPtr->colorLut)+Address+3-j ) = (unsigned char)255;
				}
				else{
					*( ((unsigned short*)lutParamPtr->colorLut)+Address+3-j ) = (unsigned short)65535;
				}
			}
			else{
				if( Size == 1 ){
					*( ((unsigned char*)lutParamPtr->colorLut)+Address+3-j ) = (unsigned char)0;
				}
				else{
					*( ((unsigned short*)lutParamPtr->colorLut)+Address+3-j ) = (unsigned short)0;
				}
			}
		}
	}
	UNLOCK_DATA( Storage );
	return;
}

CMError	CWCreateLink4MS (				CMWorldRef			storage,
										CMConcatProfileSet	*profileSet,
										UINT32				aIntent,
										icProfile			**theLinkProfile )
{ 
    CMError     err;

	*theLinkProfile = 0;
	
	err = DeviceLinkFill( (CMMModelPtr)storage, profileSet, theLinkProfile, aIntent );

	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_mem.c ===
/*
	File:		PI_Memory.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef PI_BasicTypes_h
#include "PI_Basic.h"
#endif

#ifndef PI_Memory_h
#include "PI_Mem.h"
#endif

#ifndef PI_Machine_h
#include "PI_Mach.h"
#endif

#include <string.h>	
#ifdef IntelMode
#include "PI_Swap.h"
#endif

#if __IS_MAC
void Debugger();
#endif

/* --------------------------------------------------------------------------

	Ptr SmartNewPtr(Size byteCount,
					OSErr* resultCode)

	Abstract:

	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */
Ptr SmartNewPtr(Size byteCount,
				OSErr* resultCode)
{
	Ptr aPtr;
	aPtr = (Ptr)LH_malloc(byteCount);
	if (aPtr == 0)
		*resultCode = notEnoughMemoryErr;
	else
		*resultCode = 0;
	return aPtr;
}


/* --------------------------------------------------------------------------

	Ptr SmartNewPtrClear(Size byteCount,
						 OSErr* resultCode)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
Ptr SmartNewPtrClear(Size byteCount,
					 OSErr* resultCode)
{
	Ptr ptr = NULL;

	ptr = SmartNewPtr(byteCount, resultCode);

	if (ptr != NULL)
	{
 		memset( ptr, 0, byteCount );
	}
	return ptr;

}


/* --------------------------------------------------------------------------

	Ptr DisposeIfPtr(Ptr thePtr)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
Ptr DisposeIfPtr(Ptr thePtr)
{
	if (thePtr)
	{
		LH_free(thePtr);
	}
	return NULL;
}

#ifdef __MWERKS__
extern pascal Ptr NewPtr(Size byteCount);
extern pascal void DisposePtr(Ptr p);
#endif	

#ifdef LH_MEMORY_DEBUG
typedef struct
{
	void* p;
	long l;
} LH_PointerType;
static LH_PointerType PListe[2001];
static long PListeCount = 0;

/* --------------------------------------------------------------------------

	void LH_mallocInit()

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void LH_mallocInit()
{
	long i;
	for (i = 0; i < 2000; i++)
	{
		PListe[i].p = 0;
		PListe[i].l = 0;
	}
	PListeCount = 0;
}


/* --------------------------------------------------------------------------

	void* LH_malloc(long a)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void* LH_malloc(long a)
{
	long i;
#ifdef __MWERKS__
	void* aPtr = NewPtr(a);
#else
	void* aPtr = malloc(a);
#endif	

	for (i = 0; i < PListeCount; i++)
	{
		if (aPtr < PListe[i].p)
			continue;
		if (aPtr >= (char*)PListe[i].p + PListe[i].l)
			continue;
		Debugger();
	}

	for (i = 0; i < PListeCount; i++)
	{
		if (PListe[i].p == 0)
			break;
	}
	PListe[i].p = aPtr;
	PListe[i].l = a;
	if (i >= PListeCount)
	{
		if (PListeCount < 2000)
			PListeCount++;
	}
	return aPtr;
}


/* --------------------------------------------------------------------------

	void LH_free(void* a)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void LH_free(void* a)
{
	long i;
	for (i = 0; i < PListeCount; i++)
	{
		if (PListe[i].p == a)
			break;
	}
	if (i < PListeCount)
	{
		PListe[i].p = 0;
		PListe[i].l = 0;
#ifdef __MWERKS__
		DisposePtr(a);
#else
		free(a);
#endif	

	}
	else
	{
		Debugger();
	}
}
#else

/* --------------------------------------------------------------------------

	void LH_mallocInit()

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void LH_mallocInit()
{
}


/* --------------------------------------------------------------------------

	void* LH_malloc(long a)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void* LH_malloc(long a)
{
#ifdef __MWERKS__
	return NewPtr(a);
#else
	return malloc(a);
#endif	

}


/* --------------------------------------------------------------------------

	void LH_free(void* a)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void LH_free(void* a)
{
#ifdef __MWERKS__
	DisposePtr((Ptr)a);
#else
	free(a);
#endif	

}
#endif	


/* --------------------------------------------------------------------------

	void SetMem(void* bytePtr,
				size_t numBytes,
				unsigned char byteValue);

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void SetMem(void* bytePtr,
			size_t numBytes,
			unsigned char byteValue);
void SetMem(void* bytePtr,
			size_t numBytes,
			unsigned char byteValue)
{
	memset(bytePtr, byteValue, numBytes);
}

/*void SecondsToDate(unsigned long secs, DateTimeRec *d)
  {
  secs=secs;
  d->year = 55;
  d->month = 8;
  d->day = 8;
  d->hour = 0;
  d->minute = 0;
  d->second = 0;
  d->dayOfWeek = 0;
  }*/

#if !__IS_MAC
/* --------------------------------------------------------------------------

	void BlockMove(const void* srcPtr,
				   void* destPtr,
				   Size byteCount);

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void BlockMove(const void* srcPtr,
			   void* destPtr,
			   Size byteCount)
{
	memmove(destPtr, srcPtr, byteCount);
}
#endif

#ifdef IntelMode
/* --------------------------------------------------------------------------

	void SwapLongOffset(void* p,
						unsigned long a,
						unsigned long b)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void SwapLongOffset(void* p,
					unsigned long a,
					unsigned long b)
{
	unsigned long* aPtr = (unsigned long*)((char*)p + a);
	unsigned long* bPtr = (unsigned long*)((char*)p + b);
	while (aPtr < bPtr)
	{
		SwapLong(aPtr);
		aPtr++;
	}
}


/* --------------------------------------------------------------------------

	void SwapShortOffset(void* p,
						 unsigned long a,
						 unsigned long b);

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void SwapShortOffset(void* p,
					 unsigned long a,
					 unsigned long b);
void SwapShortOffset(void* p,
					 unsigned long a,
					 unsigned long b)
{
	unsigned short* aPtr = (unsigned short*)((char*)p + a);
	unsigned short* bPtr = (unsigned short*)((char*)p + b);
	while (aPtr < bPtr)
	{
		SwapShort(aPtr);
		aPtr++;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_mach.h ===
/*
	File:		PI_Mach.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef PI_Machine_h
#define PI_Machine_h

#if defined(unix) || defined(__unix) || defined(__unix__)
#define __IS_UNIX 1
#else
#define __IS_UNIX 0
#endif

#ifdef __MSDOS__
#define __IS_MSDOS 1
#else
#define __IS_MSDOS 0
#endif

#ifdef __MWERKS__
#define __IS_MAC 1
#else
#define __IS_MAC 0
#endif

#if __IS_MSDOS 
typedef long int off_t;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_mem.h ===
/*
	File:		PI_Mem.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef PI_Memory_h
#define PI_Memory_h

#include <stdlib.h>
typedef INT32 Size;

#ifdef __cplusplus
extern "C" {
#endif
void *LH_malloc(long a);
void LH_free(void *a);
void LH_mallocInit();
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

Ptr  		DisposeIfPtr		( Ptr aPtr );

Ptr
SmartNewPtr(Size byteCount, OSErr *resultCode);

Ptr
SmartNewPtrClear(Size byteCount, OSErr *resultCode);

UINT32 TickCount(void);
double MyTickCount(void);

double rint(double a);
void BlockMove(const void* srcPtr,
			   void* destPtr,
			   Size byteCount);
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_swap.h ===
/*
	File:		PI_SwapMem.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef PI_SwapMem_h
#define PI_SwapMem_h

#ifdef IntelMode
#if defined(__cplusplus)
extern "C" {
#endif
#define SwapLong(b) (*((unsigned long *)(b))) = ((unsigned long)(((unsigned char *)(b))[3]))         | (((unsigned long)(((unsigned char *)(b))[2])) << 8) | \
		        (((unsigned long)(((unsigned char *)(b))[1])) << 16) | (((unsigned long)(((unsigned char *)(b))[0])) << 24);
#define SwapShort(b) (*((unsigned short *)(b))) = ((unsigned short)(((unsigned char *)(b))[1])) | ((unsigned short)(((unsigned char *)(b))[0] << 8));

void SwapLongOffset( void *p, unsigned long a, unsigned long b); /* */
void SwapShortOffset( void *p, unsigned long a, unsigned long b);

#if defined(__cplusplus)
}
#endif
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_run.c ===
/*
	File:		PI_CWRuntime.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif


#ifndef LHCMRuntime_h
#include "Runtime.h"
#endif
/* ______________________________________________________________________

CMError CWMatchBitmap   ( 
 							CMWorldRef          Storage,
							CMBitmap*           bitMap, 
							CMBitmapCallBackUPP progressProc, 
							void*               refCon, 
							CMBitmap*           matchedBitMap)
        Abstract:
                Match pixel data of bitMap according to the CMProfileRef parameters
                supplied to a previous call to CMMInitPrivate(), CWNewColorWorld(...),
                CMMConcatInitPrivate() or CWConcatColorWorld(...).

        Params:
                storage                 (in)            Reference to ColorWorld storage.
                bitMap                  (in/out)        Describes source BitMap data.
                progressProc            (in)            Client function which is called once
                                                        per row of the BitMap. If the
                                                        function result is TRUE then the
                                                        operation is aborted. May be NULL.
                refCon                  (in)            Client data which is passed as a
                                                        parameter to calls to progressProc.
                matchedBitMap           (in/out)        Result matched BitMap. The caller
                                                        is responsible for allocating the
                                                        pixel buffer pointed to by baseAddr.
                                                        If NULL then the source BitMap is
                                                        matched in place.
        
        Return:
               noErr                                    successful
               System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CWMatchBitmap   ( 
 							CMWorldRef          Storage,
							CMBitmap*           bitMap, 
							CMBitmapCallBackUPP progressProc, 
							void*               refCon, 
							CMBitmap*           matchedBitMap)

{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHMatchBitMapPrivate(	aPtr, 
								(const CMBitmap*)bitMap, 
								progressProc,
								refCon, 
								matchedBitMap );
	UNLOCK_DATA( Storage );
	return err;
}

/* ______________________________________________________________________

CMError CWCheckBitmap (
							CMWorldRef			Storage, 
							const CMBitmap		*bitMap,
							CMBitmapCallBackUPP	progressProc,
							void				*refCon,
							CMBitmap 			*resultBitMap )
						
	Abstract:
		Gamut test pixel data of bitMap  according to the CMProfileRef
		parameters supplied to a previous call to CMMInitPrivate(), CWNewColorWorld(...),
		CMMConcatInitPrivate() or CWConcatColorWorld(...).

	Params:
		storage			(in)		Reference to ColorWorld storage.
		bitMap			(in/out)	Describes BitMap data.
		progressProc	(in)		Client function which is called
									once per row of the BitMap. If
									the function result is true then
									the operation is aborted.May be NULL.
		refCon			(in)		Client data which is passed as a
									parameter to calls to progressProc.
		resultBitMap	(in/out)	Result BitMap. Must be one bit depth
									and equal bounds of bitMap parameter.
									Pixels are set to 1 if corresponding
									pixel of bitMap is out of gamut.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CWCheckBitmap (
							CMWorldRef			Storage, 
							const CMBitmap		*bitMap,
							CMBitmapCallBackUPP	progressProc,
							void				*refCon,
							CMBitmap 			*resultBitMap )
{
	CMError		err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
    err = LHCheckBitMapPrivate(  aPtr, 
                                  (const CMBitmap*)bitMap, 
                                  progressProc,
                                  refCon, 
                                  resultBitMap );
	UNLOCK_DATA( Storage );
	return err;
}
/* ______________________________________________________________________

CMError CWMatchBitmapPlane(	CMWorldRef          Storage,
                         	LH_CMBitmapPlane*   bitMap, 
                         	CMBitmapCallBackUPP progressProc, 
                         	void*               refCon, 
                         	LH_CMBitmapPlane*   matchedBitMap)
                        
        Abstract:
                Match pixel data of LH_CMBitmapPlane according to the CMProfileRef parameters
                supplied to a previous call to CMMInitPrivate(), CWNewColorWorld(...),
                CMMConcatInitPrivate() or CWConcatColorWorld(...).

        Params:
                storage                 (in)            Reference to ColorWorld storage.
                bitMap                  (in/out)        Describes source BitMap data.
                progressProc            (in)            Client function which is called once
                                                        per row of the BitMap. If the
                                                        function result is TRUE then the
                                                        operation is aborted. May be NULL.
                refCon                  (in)            Client data which is passed as a
                                                        parameter to calls to progressProc.
                matchedBitMap           (in/out)        Result matched BitMap. The caller
                                                        is responsible for allocating the
                                                        pixel buffer pointed to by baseAddr.
                                                        If NULL then the source BitMap is
                                                        matched in place.
        
        Return:
               noErr                                    successful
               System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CWMatchBitmapPlane(	CMWorldRef          Storage,
                         	LH_CMBitmapPlane*   bitMap, 
                         	CMBitmapCallBackUPP progressProc, 
                         	void*               refCon, 
                         	LH_CMBitmapPlane*   matchedBitMap)

{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHMatchBitMapPlanePrivate(	aPtr, 
                                  		(const LH_CMBitmapPlane*)bitMap, 
                                 	 	progressProc,
                                  		refCon, 
                                  		matchedBitMap );
	UNLOCK_DATA( Storage );
	return err;
}

/* ______________________________________________________________________

 CMError CWCheckBitmapPlane(	CMWorldRef          Storage,
								LH_CMBitmapPlane*   bitMap, 
								CMBitmapCallBackUPP progressProc, 
								void*               refCon, 
								LH_CMBitmapPlane*   CheckedBitMap)
                        
        Abstract:
                Check pixel data of LH_CMBitmapPlane according to the CMProfileRef parameters
                supplied to a previous call to CMMInitPrivate(), CWNewColorWorld(...),
                CMMConcatInitPrivate() or CWConcatColorWorld(...).

        Params:
                storage                 (in)            Reference to ColorWorld storage.
                bitMap                  (in/out)        Describes source BitMap data.
                progressProc            (in)            Client function which is called once
                                                        per row of the BitMap. If the
                                                        function result is TRUE then the
                                                        operation is aborted. May be NULL.
                refCon                  (in)            Client data which is passed as a
                                                        parameter to calls to progressProc.
                CheckedBitMap           (in/out)        Result Checked BitMap. The caller
                                                        is responsible for allocating the
                                                        pixel buffer pointed to by baseAddr.
                                                        If NULL then the source BitMap is
                                                        Checked in place.
        
        Return:
               noErr                                    successful
               System or result code if an error occurs.

   _____________________________________________________________________ */

 CMError CWCheckBitmapPlane(	CMWorldRef          Storage,
								LH_CMBitmapPlane*   bitMap, 
								CMBitmapCallBackUPP progressProc, 
								void*               refCon, 
								LH_CMBitmapPlane*   CheckedBitMap)

{
	Storage=Storage;
	bitMap=bitMap;
	progressProc=progressProc;
	refCon=refCon;
	CheckedBitMap=CheckedBitMap;
	return cmparamErr;
	/*CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHMatchBitMapPlanePrivate( aPtr, 
                                  	(const LH_CMBitmapPlane*)bitMap, 
                                 	progressProc,
                                  	refCon, 
                                  	CheckedBitMap );
	UNLOCK_DATA( Storage );
		return err;*/
}

/*---------------------------------------------------------------------------------
 CMError CWMatchColors(	CMWorldRef		Storage,
						CMColor			*myColors, 
						unsigned long	count )
						
	Abstract:
		Color-matching on a list of CMColor. The source and destination
		data types are specified by the CMProfileRef parameters to the
		previous call to the CMMInitPrivate(), CWNewColorWorld(...),
		CMMConcatInitPrivate() or CWConcatColorWorld(...) function.

	Params:
		storage		(in)		Reference to ColorWorld storage.
		myColors	(in/out)	Array of CMColor.
		count		(in)		One-based count of elements in array.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */
 CMError CWMatchColors(	CMWorldRef		Storage,
						CMColor			*myColors, 
						unsigned long	count )

{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHMatchColorsPrivate( aPtr, myColors, count );
	UNLOCK_DATA( Storage );
	return err;
}

/* ______________________________________________________________________

CMError CWCheckColorsMS ( 
						CMWorldRef 		Storage, 
						CMColor 		*myColors, 
						unsigned long	count, 
						long 			*result )
						
	Abstract:
		Gamut test a list of CMColor. The source and destination are
		specified by the CMProfileRef parameters to the previous call to
		the CMMInitPrivate(), CWNewColorWorld(...),
		CMMConcatInitPrivate() or CWConcatColorWorld(...) function.

	Params:
		storage		(in)		Reference to ColorWorld storage.
		myColors	(in)		Array of CMColor.
		count		(in)		One-based count of elements in array.
		result		(in/out)	Bits in array are set to 1 if the corresponding color is out of gamut.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */


CMError CWCheckColorsMS ( 
						CMWorldRef 		Storage, 
						CMColor 		*myColors, 
						unsigned long	count, 
						UINT8 			*result )
{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHCheckColorsPrivateMS( aPtr, myColors, count, result );
	UNLOCK_DATA( Storage );
	return err;
}
/* ______________________________________________________________________

CMError CWCheckColors ( 
						CMWorldRef 		Storage, 
						CMColor 		*myColors, 
						unsigned long	count, 
						unsigned char	*result )
						
	Abstract:
		Gamut test a list of CMColor. The source and destination are
		specified by the CMProfileRef parameters to the previous call to
		the CMMInitPrivate(), CWNewColorWorld(...),
		CMMConcatInitPrivate() or CWConcatColorWorld(...) function.

	Params:
		storage		(in)		Reference to ColorWorld storage.
		myColors	(in)		Array of CMColor.
		count		(in)		One-based count of elements in array.
		result		(in/out)	Bits in array are set to 1 if the corresponding color is out of gamut.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */


CMError CWCheckColors ( 
						CMWorldRef 		Storage, 
						CMColor 		*myColors, 
						unsigned long	count, 
						unsigned char	*result )
{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHCheckColorsPrivate( aPtr, myColors, count, result );
	UNLOCK_DATA( Storage );
	return err;
}
/* ______________________________________________________________________

 CMError CWGetColorSpaces(	CMWorldRef cw, 
							CMBitmapColorSpace *In, 
							CMBitmapColorSpace *Out );
                        
        Abstract:
                Get input and output colorspace out of CMWorldRef.

        Params:
                cw       (in)            Reference to ColorWorld storage.
                In       (Out)           Reference to input CMBitmapColorSpace.
                In       (Out)           Reference to output CMBitmapColorSpace.
        
        Return:
               noErr                                    successful
               System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CWGetColorSpaces(	CMWorldRef cw, 
							CMBitmapColorSpace *In, 
							CMBitmapColorSpace *Out )

{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( cw == 0 )return cmparamErr;
	LOCK_DATA( cw );
	aPtr = (CMMModelPtr)(DATA_2_PTR( cw ));
	*In = aPtr->firstColorSpace;
	*Out = aPtr->lastColorSpace;
	UNLOCK_DATA( cw );
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_priv.h ===
#ifndef PI_PrivateProfAccess_h
#define PI_PrivateProfAccess_h
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_tick.c ===
/*
	File:		PI_TickCount.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef PI_BasicTypes_h
#include "PI_Basic.h"
#endif

#ifndef PI_Machine_h
#include "PI_Mach.h"
#endif

#ifndef PI_Memory_h
#include "PI_Mem.h"
#endif

#include <time.h>
#if __IS_MSDOS
#include <wtypes.h>
#endif

double MyTickCount(void);
double MyTickCount(void)
{
	double timevalue;
#if __IS_MAC
	timevalue = TickCount()/60.;
#elif __IS_MSDOS
	timevalue = GetTickCount()/1000.;
#else
	timevalue = clock()/(CLOCKS_PER_SEC*1000.);
#endif
	return timevalue;
}

#if __IS_MSDOS
UINT32 TickCount(void)
{
	UINT32 timevalue;
	timevalue = (UINT32)(GetTickCount()/1000.*60 + .5 );
	return timevalue;
}
#endif

#if !__IS_MSDOS
#if !__IS_MAC
UINT32 TickCount(void)
{
	UINT32 timevalue;
	timevalue = (UINT32) time(NULL);
	return timevalue;
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_valid.h ===
#ifndef PI_Validate_h
#define PI_Validate_h

CMError CMValidateProfile( CMProfileRef prof, Boolean* valid );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=gdi
MINORCOMP=cmm_open

!ifndef ICMROOT
ICMROOT=$(NTGDI_PATH)\icm
!endif

!include $(ICMROOT)\icmsrc.inc

TARGETNAME=lh_open
TARGETTYPE=LIBRARY
TARGETPATH=..\$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

INCLUDES=..\.;..\..\lh_core

C_DEFINES=$(C_DEFINES) -DWIN32 -D__MSDOS__ -DIntelMode -DRenderInt -DMS_Icm

MSC_WARNING_LEVEL=/W3 /WX

SOURCES= ..\pi_cmm.c   \
         ..\pi_color.c \
         ..\pi_mem.c   \
         ..\pi_run.c   \
         ..\pi_tick.c  \
         ..\pi_valid.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_open\pi_valid.c ===
/*
	File:		PI_Val.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHGeneralIncs_h
#include "General.h"
#endif

PI_Boolean CMValInput(		CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValDisplay(	CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValOutput(		CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValLink(		CMProfileRef prof );
PI_Boolean CMValColorSpace(	CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValAbstract(	CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValNamed(		CMProfileRef prof,
							icHeader* aHeader );

PI_Boolean CMValGray(		CMProfileRef prof );
PI_Boolean CMValRGB(		CMProfileRef prof );
PI_Boolean CMValAToB(		CMProfileRef prof );
PI_Boolean CMValBToA(		CMProfileRef prof );
PI_Boolean CMValMftOutput(	CMProfileRef prof );

PI_Boolean CMValInput(	CMProfileRef prof,
						icHeader* aHeader )
{
	PI_Boolean valid;
	switch ( aHeader->colorSpace)
	{

		case icSigGrayData:
			valid = CMValGray(prof);
			break;

		case icSigRgbData:
			if (aHeader->pcs == icSigLabData)
			{
				valid = CMValAToB(prof);
			}
			else
			{
				valid = CMValRGB(prof);
			}
			break;

		case icSigCmyData:
		case icSigCmykData:
		case icSigMCH2Data:
		case icSigMCH3Data:
		case icSigMCH4Data:
		case icSigMCH5Data:
		case icSigMCH6Data:
		case icSigMCH7Data:
		case icSigMCH8Data:
		case icSigMCH9Data:
		case icSigMCHAData:
		case icSigMCHBData:
		case icSigMCHCData:
		case icSigMCHDData:
		case icSigMCHEData:
		case icSigMCHFData:
			valid = CMValAToB(prof);
			break;

		default:
			valid = FALSE;
	}

	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
	}
	return (valid);
}

PI_Boolean CMValDisplay(	CMProfileRef prof,
							icHeader* aHeader )
{
	PI_Boolean valid;
	switch (aHeader->colorSpace)
	{

		case icSigGrayData:
			valid = CMValGray(prof);
			break;

		case icSigRgbData:
			if (aHeader->pcs == icSigLabData){
				valid = CMValBToA(prof);
			}
			else{
				valid = CMValRGB(prof);
			}
			break;
		case icSigMCH3Data:
		case icSigMCH4Data:
		case icSigCmyData:
		case icSigCmykData:
			valid = CMValBToA(prof);
			break;

		default:
			valid = FALSE;
	}

	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
	}
	return (valid);
}

PI_Boolean CMValOutput(	CMProfileRef prof,
						icHeader* aHeader )
{
	PI_Boolean valid;
	switch (aHeader->colorSpace)
	{

		case icSigGrayData:
			valid = CMValGray(prof);
			break;

		case icSigRgbData:
		case icSigCmyData:
		case icSigCmykData:
		case icSigMCH2Data:
		case icSigMCH3Data:
		case icSigMCH4Data:
		case icSigMCH5Data:
		case icSigMCH6Data:
		case icSigMCH7Data:
		case icSigMCH8Data:
		case icSigMCH9Data:
		case icSigMCHAData:
		case icSigMCHBData:
		case icSigMCHCData:
		case icSigMCHDData:
		case icSigMCHEData:
		case icSigMCHFData:
			valid = CMValMftOutput(prof);
			break;

		default:
			valid = FALSE;
	}

	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
	}
	return (valid);
}

PI_Boolean CMValLink(	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileSequenceDescTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}

PI_Boolean CMValColorSpace(	CMProfileRef prof,
							icHeader* aHeader )
{
	PI_Boolean valid;
	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
		return (valid);
	}

	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}


PI_Boolean CMValAbstract(	CMProfileRef prof,
							icHeader* aHeader )
{
	PI_Boolean valid;
	switch (aHeader->pcs)
	{

		case icSigXYZData:
		case icSigLabData:
			valid = CMValAToB(prof);
			break;

		default:
			valid = FALSE;
	}

	return (valid);
}

PI_Boolean CMValNamed(		CMProfileRef prof,
							icHeader* aHeader )
{
	PI_Boolean valid;
	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
		return (valid);
	}

	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigNamedColor2Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}

PI_Boolean CMValGray(	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigGrayTRCTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}

PI_Boolean CMValAToB(	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);/* change to enum */

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);/* change to enum */

	return (valid);
}

PI_Boolean CMValBToA(	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);/* change to enum */

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);/* change to enum */

	return (valid);
}

CMError CMValidateProfile(	CMProfileRef	prof,
							PI_Boolean		*valid )
{
	CMError err = noErr;
	icHeader aHeader;

	*valid = FALSE;
	err = CMGetProfileHeader((CMProfileRef)prof, &aHeader);

	if (!err)
	{
		if ((aHeader.version & 0xff000000) >= icVersionNumber ){
			switch (aHeader.deviceClass)
			  {
				case icSigInputClass:
				*valid = CMValInput(prof, &aHeader );
				break;

				case icSigDisplayClass:
				*valid = CMValDisplay(prof, &aHeader );
				break;

				case icSigOutputClass:
				*valid = CMValOutput(prof, &aHeader );
				break;

				case icSigLinkClass:
				*valid = CMValLink(prof);
				break;

				case icSigColorSpaceClass:
				*valid = CMValColorSpace(prof, &aHeader );
				break;

				case icSigAbstractClass:
				*valid = CMValAbstract(prof, &aHeader );
				break;

				case icSigNamedColorClass:
				*valid = CMValNamed(prof, &aHeader );
				break;

				default:
				*valid = FALSE;
			  }

		}
		else
		{										/* unknown profile */
			*valid = FALSE;
			return (cmProfileError);
		}
	}

	return (err);
}

PI_Boolean CMValMftOutput (	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB1Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB2Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA1Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA2Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigGamutTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}

PI_Boolean CMValRGB(			CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigRedColorantTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigGreenColorantTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBlueColorantTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigRedTRCTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigGreenTRCTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBlueTRCTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);/* wtpt change to enum */

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);/* cprt change to enum */

	return (valid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\mscmm\memprof.h ===
/*
	File:		MSNewMemProfile.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef MSNewMemProfile_h
#define MSNewMemProfile_h


CMError MyNewAbstractW( LPLOGCOLORSPACEW	lpColorSpace, icProfile **theProf ); 
CMError MyNewAbstract(	LPLOGCOLORSPACEA	lpColorSpace, icProfile **theProf ); 
 
CMError MyNewDeviceLink( CMWorldRef cw, CMConcatProfileSet *profileSet, LPSTR theProf );
CMError MyNewDeviceLinkW( CMWorldRef cw, CMConcatProfileSet *profileSet, LPWSTR theProf );

CMError MyNewDeviceLinkFill( CMWorldRef cw, CMConcatProfileSet *profileSet, HPROFILE aHProf );
long	SaveMyProfile( LPSTR lpProfileName, LPWSTR lpProfileNameW, PPROFILE theProf );

CMError DeviceLinkFill(	CMMModelPtr cw, 
						CMConcatProfileSet *profileSet, 
						icProfile **theProf,
						unsigned long aIntent );
UINT32	GetSizes( CMMModelPtr cw, UINT32 *clutSize );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\app.h ===
/*
	File:		LHApplication.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHApplication_h
#define LHApplication_h

#ifdef __cplusplus
extern "C" {
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=mac68k
#endif

#if PRAGMA_IMPORT_SUPPORTED
#pragma import on
#endif

#define MAX_ELEMENT_PER_PIXEL   17 /* 16 Colors + Alpha */
typedef struct LH_CMBitmapPlane 
{
	char *						image[MAX_ELEMENT_PER_PIXEL];	/* used for plane-interleaved data		*/
	long 						width;							/* count of pixel in a line				*/
	long 						height;							/* line count							*/
	long 						rowBytes;						/* Offset to next line					*/
	long 						elementOffset;					/* Offset to next element in a plane	*/
	long 						pixelSize;						/* not used								*/
	CMBitmapColorSpace			space;							/* color space							*/
	long 						user1;							/* not used								*/
	long						user2;							/* not used								*/
} LH_CMBitmapPlane;

/* example:
	convert CMYK plane interleaved (InPtr) to BGR pixel interleaved (OutPtr)
	InBitMap.width = OutBitMap.width = 200;
	InBitMap.height = OutBitMap.height = 100;
	InBitMap.rowBytes = 200;
	InBitMap.elementOffset = 1;
	InBitMap.space = cmCMYK32Space;
	InBitMap.image[0] = InPtr+InBitMap.rowBytes*0;
	InBitMap.image[1] = InPtr+InBitMap.rowBytes*1;
	InBitMap.image[2] = InPtr+InBitMap.rowBytes*2;
	InBitMap.image[3] = InPtr+InBitMap.rowBytes*3;
	OutBitMap.rowBytes = 200 * 3;
	OutBitMap.elementOffset = 3;
	OutBitMap.space = cmRGB24Space;
 	OutBitMap.image[0] = OutPtr+2;
	OutBitMap.image[1] = OutPtr+1;
	OutBitMap.image[2] = OutPtr+0;
	
	Only 8 bit or 16 bit data allowed.
*/
#if PRAGMA_IMPORT_SUPPORTED
#pragma import off
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\mscmm\access.c ===
/*
	File:		MSICMProfileAccess.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/
#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include "ICM.h"
#include "General.h"
/* --------------------------------------------------------------------------

CMError CMGetProfileHeader(	CMProfileRef			prof,
							CMCoreProfileHeader*	header );

	Abstract:

	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */
CMError CMGetProfileHeader(	CMProfileRef			prof,
							CMCoreProfileHeader*	header )
{
	BOOL bool;
	CMError ret = badProfileError;

	bool = GetColorProfileHeader( (HPROFILE)prof, (PPROFILEHEADER) header );
	if (header->magic == icMagicNumber && bool )
		ret = noErr;
	
	return (ret);
}


/* --------------------------------------------------------------------------

CMError CMGetProfileElement(	CMProfileRef 		prof,
								OSType 				tag,
								unsigned long*		elementSize,
								void* 				elementData );

	Abstract:
		This function gives an pointer to the requested tag back
	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */
CMError CMGetProfileElement(	CMProfileRef 		prof,
								OSType 				tag,
								unsigned long*		elementSize,
								void* 				elementData )
{
	return (CMGetPartialProfileElement(prof, tag, 0, elementSize, elementData));
}


/* --------------------------------------------------------------------------

	CMError CMGetPartialProfileElement(	CMProfileRef 		prof,
										OSType 				tag,
										unsigned long		offset,
										unsigned long		*byteCount,
										void				*elementData )

	Abstract:
		Core likes small amounts of memory we too but this is ascetic.
	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */

CMError CMGetPartialProfileElement(	CMProfileRef 		prof,
									OSType 				tag,
									unsigned long		offset,
									unsigned long		*byteCount,
									void				*elementData )
{
	BOOL bool;
	BOOL ret;

	if (!byteCount)
	{
		return -1;
	}
	SetLastError(0);
	/*ret = IsColorProfileTagPresent( (HPROFILE)prof, (TAGTYPE)tag, &bool );*/
	if( elementData == 0 ) *byteCount = 0;
	ret = GetColorProfileElement( (HPROFILE)prof, (TAGTYPE)tag, offset, byteCount, elementData, &bool );
	if( ret )		return (noErr);
	/*					GetColorProfileElement returns FALSE for calls with elementData = 0
						but byteCount is set correctly */		
	else if( elementData == 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER )	return (noErr);
	
	return (cmElementTagNotFound);
}

/* --------------------------------------------------------------------------

Boolean CMProfileElementExists(		CMProfileRef 	prof,
									OSType 			tag );

	Abstract:

	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */
Boolean CMProfileElementExists(		CMProfileRef 	prof,
									OSType 			tag )
{
	BOOL bool;
    bool = FALSE;
	IsColorProfileTagPresent( (HPROFILE)prof, (TAGTYPE)tag, &bool );
	return (BOOLEAN)bool;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\calcenf.h ===
/*
	File:		LHCalcEngine.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCalcEngineF_h
#define LHCalcEngineF_h

#ifndef LHTypeDefs_h
#include "TypeDefs.h"
#endif

typedef unsigned char  LH_UINT8;
typedef unsigned short LH_UINT16;
typedef unsigned long  LH_UINT32;
#undef  LH_CALC_ENGINE_UNDEF_MODE
#undef  LH_CALC_ENGINE_P_TO_P
#undef  LH_CALC_ENGINE_P_TO_U			
#undef  LH_CALC_ENGINE_U_TO_P
#undef  LH_CALC_ENGINE_U_TO_U		
#define LH_CALC_ENGINE_UNDEF_MODE           0
#define LH_CALC_ENGINE_P_TO_P               1
#define LH_CALC_ENGINE_P_TO_U		        2				
#define LH_CALC_ENGINE_U_TO_P			    3
#define LH_CALC_ENGINE_U_TO_U			    4				

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to3_Di8_Do8_Lut8_G32_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do8_Lut8_G16_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to4_Di8_Do8_Lut8_G32_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do8_Lut8_G16_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );

/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to3_Di8_Do8_Lut8_G8_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do8_Lut8_G16_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to4_Di8_Do8_Lut8_G8_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di8_Do8_Lut8_G16_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\mscmm\icm32.c ===
/*
	File:		MsLinoCMM.c

	Contains:
		Interface to MS ICM
	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include <winbase.h>
#include <WindowsX.h>
#include "ICM.h"

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef MSNewMemProfile_h
#include "MemProf.h"
#endif

#define CMM_WIN_VERSION		0
#define CMM_IDENT			1
#define CMM_DRIVER_LEVEL	2
#define CMM_DLL_VERSION		3
#define CMM_VERSION			4
#define CMS_LEVEL_1			1

typedef HANDLE  HCMTRANSFORM;
typedef LPVOID  LPDEVCHARACTER;
typedef HANDLE *LPHPROFILE;
typedef LPVOID  LPARGBQUAD;
typedef COLORREF FAR *LPCOLORREF;

#ifdef _DEBUG
//#define WRITE_PROFILE
#endif
/* ______________________________________________________________________
			static section for holding the CW pointers
   _____________________________________________________________________ */

long IndexTransform=0;
HCMTRANSFORM TheTransform[1000] = {0};

CRITICAL_SECTION GlobalCriticalSection;		/* for multithreaded dll */

/* ______________________________________________________________________ */

/* ______________________________________________________________________

BOOL WINAPI DllMain (	HINSTANCE hinstDLL,
						DWORD fdwReason,
						LPVOID lpvReserved )

        Abstract:
                DLL Entrypoint

        Params:
                standard

        Return:
                TRUE

   _____________________________________________________________________ */
BOOL WINAPI DllMain (	HINSTANCE hinstDLL,
						DWORD fdwReason,
						LPVOID lpvReserved )
{
switch (fdwReason)
   {
   case DLL_PROCESS_ATTACH:
      DisableThreadLibraryCalls(hinstDLL);
	  InitializeCriticalSection(&GlobalCriticalSection);
      break;
   case DLL_PROCESS_DETACH:
      DeleteCriticalSection(&GlobalCriticalSection);
      break;
   }
return TRUE;
}

#define DllExport	__declspec( dllexport )

HCMTRANSFORM  WINAPI CMCreateMultiProfileTransform(	LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													DWORD		*aIntentArr,
													DWORD		nIntents,
													DWORD		dwFlags );
long FillProfileFromLog(	LPLOGCOLORSPACEA	lpColorSpace,
							PPROFILE			theProf );
long FillProfileFromLogW(	LPLOGCOLORSPACEW	lpColorSpace,
							PPROFILE			theProf );
BOOL  WINAPI CMCreateProfile(	LPLOGCOLORSPACEA	lpColorSpace,
								LPDEVCHARACTER 		*lpProfileData );
CMWorldRef StoreTransform( CMWorldRef aRef );
CMBitmapColorSpace CMGetDataColorSpace( BMFORMAT c, long *pixelSize );
HCMTRANSFORM  WINAPI CMGetTransform( HCMTRANSFORM 	hcmTransform );
long  CMCreateMultiProfileTransformInternal(		CMWorldRef	*cw,
													LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													DWORD		*aIntentArr,
													DWORD		nIntents,
													DWORD		dwFlags,
													DWORD		dwCreateLink );
/* ______________________________________________________________________

DWORD WINAPI CMGetInfo( DWORD dwInfo );

Abstract:
	The CMGetInfo function retrieves various information about the ICM.

Parameter		Description
	
	dwInfo		Values that can have the following meaning:

	Type	Meaning
		
	CMS_VERSION	Retrieves the version of Windows supported.
	CMS_IDENT	Retrieves the identifier of the ICMDLL.
	CMS_DRIVER_LEVEL	Retrieves the support level of a device driver.

Returns
	CMGetInfo returns zero if an invalid parameter is passed in. If successful it returns a value that depends on the information requested.
	For CMS_VERSION CMGetInfo retrieves the version of Windows ICM interface supported by this module. For Windows 95 this should be 4.0, represented as 0x00040000.
	For CMS_IDENT CMGetInfo retrieves the identifier of the ICMDLL. This is the same as the ICC color profile header identifier.
	For CMS_DRIVER_LEVEL CMGetInfo retrieves the supported level of the device driver. ICMDLLs should return CMS_LEVEL_1. The values have been defined in a previous section.
   _____________________________________________________________________ */
DWORD WINAPI CMGetInfo( DWORD dwInfo )
{
	DWORD ret = 0;
	switch( dwInfo ){
	case CMM_VERSION:
		ret = 0x00050000;
		break;
	case CMM_WIN_VERSION:
		ret = 0x00040000;
		break;
	case CMM_DLL_VERSION:
		ret = 0x00010000;
		break;
	case CMM_IDENT:
		ret = 'Win ';
		break;
	case CMM_LOGOICON:
		ret = 100;
		break;
	case CMM_DESCRIPTION:
		ret = 100;
		break;
	case CMM_DRIVER_LEVEL:
		ret = CMS_LEVEL_1;
		break;
	default:
		ret = 0;
		break;
	}
	return 	ret;
}


long CMCreateTransformExtInternal(	CMWorldRef	*cwOut,
									UINT32		dwFlags,
									UINT32		lcsIntent,
									HPROFILE	aProf,
									LPBYTE		ptDeRef,
									LPBYTE		pdDeRef )
{
	CMWorldRef cw=0;
	CMWorldRef cw2=0;
	long err;
	HPROFILE saveProf;
	HPROFILE hArray[3];
	UINT32 aIntent[3];
	UINT32 aUINT32,count;
	CMMModelPtr theModelPtr;

	*cwOut = 0;
	aIntent[0] = icRelativeColorimetric;
	switch( lcsIntent ){
	  case LCS_GM_BUSINESS:
		aIntent[1] = icSaturation;
		break;
	  case LCS_GM_GRAPHICS:
		aIntent[1] = icRelativeColorimetric;
		break;
	  case LCS_GM_ABS_COLORIMETRIC:
		aIntent[1] = icAbsoluteColorimetric;
		break;
	  default:
		aIntent[1] = icPerceptual;
		break;
	}
	if( ptDeRef == 0 ){
		count = 2;
		hArray[0] =  aProf;
		hArray[1] =  pdDeRef;
	}
	else{
		count = 3;
		hArray[0] =  aProf;
		hArray[1] =  ptDeRef;
		hArray[2] =  pdDeRef;
		if( dwFlags & USE_RELATIVE_COLORIMETRIC )aIntent[2] = INTENT_RELATIVE_COLORIMETRIC;
		else aIntent[2] = INTENT_ABSOLUTE_COLORIMETRIC;
	}

	err = CMCreateMultiProfileTransformInternal( &cw, hArray, count, aIntent, count, dwFlags, 0 );
	if( err ){
		goto CleanupAndExit;
	}
	if( dwFlags & 0x80000000 ){				/* this is for the backward transform */
		count--;
		saveProf = hArray[count];
		hArray[count] =  hArray[0];
		hArray[0] =  saveProf;
		aUINT32 = aIntent[count];
		aIntent[count] = aIntent[0];
		aIntent[0] = aUINT32;

		count++;
		err = CMCreateMultiProfileTransformInternal( &cw2, hArray, count, aIntent, count, dwFlags, 0 );
		if( err ){
			CWDisposeColorWorld( cw );	/* delete other cw */
			goto CleanupAndExit;
		}
		LOCK_DATA( cw );
		theModelPtr = (CMMModelPtr)(DATA_2_PTR( cw ));
		theModelPtr->pBackwardTransform = cw2;
		UNLOCK_DATA( aTrans );
	}

CleanupAndExit:
	CloseColorProfile( aProf );
	if( err ){
		SetLastError( err );
		cw = (CMWorldRef)(ULONG_PTR)(err & 255);
	}
	else{
        CMWorldRef cwTemp = cw;
		cw = StoreTransform( cw );
        if( cw == (HCMTRANSFORM)ERROR_NOT_ENOUGH_MEMORY ){
            CWDisposeColorWorld( cwTemp );
        }
	}
	*cwOut = cw;
	return 0;
}
/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateTransformExt(	LPLOGCOLORSPACEA	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER		lpTargetDevCharacter,
											UINT32				dwFlags );

Abstract:
	The CMCreateTransformExt function creates a color transform that
	maps from an input LogColorSpace to an optional target to an
	output device.

Parameter					Description
	lpColorSpace			Pointer to input color space. If lcsFilename is non-zero,
							it is a pointer to the memory mapped profile.
	LpDevCharacter			Pointer to memory mapped device profile
	lpTargetDevCharacter	Pointer to memory mapped target profile
	dwFlags					Specifies flags to control creation of the transform.
							It is up to the CMM to determine how best to use these flags.
							Set the high-order word to ENABLE_GAMUT_CHECKING if the transform
							will be used for gamut checking.
							The low-order WORD can have one of the following constant values:
							PROOF_MODE, NORMAL_MODE, BEST_MODE.
							Moving from PROOF_MODE to BEST_MODE, output quality generally improves and transform speed declines.

Returns
	If the function is successful, it returns a color transform
	in the range 256 to 65535. Otherwise it returns an error code
	(return value < 255).

  _____________________________________________________________________ */
void WriteProf( LPSTR name, icProfile *theProf, long currentSize );
HCMTRANSFORM  WINAPI CMCreateTransformExt(	LPLOGCOLORSPACEA	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER		lpTargetDevCharacter,
											DWORD				dwFlags )
{
	CMWorldRef cw=0;
	long err;
	LPBYTE pt,pd, ptDeRef, pdDeRef = NULL;
	HPROFILE aProf;
	PROFILE theProf;
    BOOL   bWin95 = FALSE;
    OSVERSIONINFO osvi;

#if 0				/* Test for CMCreateProfile */
	CMCreateProfile( lpColorSpace, &pt );
	err = *(long *)pt;
	SwapLong(&err);
	WriteProf( "CMCreateProfile.icc", (icProfile *)pt, err );
	GlobalFreePtr( pt );
#endif


	err = FillProfileFromLog( lpColorSpace, &theProf );
	if( err ){
		SetLastError( err );
		goto CleanupAndExit;
	}
	aProf = OpenColorProfileA(&theProf, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING );
	if( !aProf ){
		err = GetLastError();
		goto CleanupAndExit;
	}
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);
    bWin95 = osvi.dwMajorVersion == 4 &&
             osvi.dwMinorVersion == 0 &&
             osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;

    if (bWin95)
    {
        PROFILE myProf;
        DWORD   l;

        //
        // Handles are not provided below LCS structure, so create handles
        //

        myProf.dwType = PROFILE_MEMBUFFER;
        myProf.pProfileData = lpDevCharacter;
        l = *(DWORD *)(myProf.pProfileData);
        myProf.cbDataSize = SwapLong(&l);
        pdDeRef = OpenColorProfile(&myProf, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING );
        if( !pdDeRef ){
                err = GetLastError();
                goto CleanupAndExit;
        }

        ptDeRef = 0;
        if (lpTargetDevCharacter)
        {
            myProf.dwType = PROFILE_MEMBUFFER;
            myProf.pProfileData = lpTargetDevCharacter;
            l = *(DWORD *)(myProf.pProfileData);
            myProf.cbDataSize = SwapLong(&l);
            ptDeRef = OpenColorProfile(&myProf, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING );
            if( !ptDeRef ){
                    err = GetLastError();
                    goto CleanupAndExit;
            }
        }
    }
    else
    {
		pd = ((LPBYTE)lpColorSpace+sizeof(LOGCOLORSPACEA));
		pdDeRef= (LPBYTE)*(PULONG_PTR)pd;

		pt = ((LPBYTE)lpColorSpace+sizeof(LOGCOLORSPACEA)+sizeof(HPROFILE));
		ptDeRef= (LPBYTE)*(PULONG_PTR)pt;
	}

	err = CMCreateTransformExtInternal(	&cw, dwFlags,
				lpColorSpace->lcsIntent, aProf, ptDeRef, pdDeRef );

CleanupAndExit:
	if( lpColorSpace->lcsFilename[0] == 0 ){
		if( theProf.pProfileData )GlobalFreePtr( theProf.pProfileData );
		theProf.pProfileData = 0;
	}
    if (bWin95)
    {
        if (pdDeRef)
        {
            CloseColorProfile(pdDeRef);
        }
        if (ptDeRef)
        {
            CloseColorProfile(ptDeRef);
        }
    }
	if( err ){
		return (HCMTRANSFORM)(ULONG_PTR)(err & 255);
	}
	return (HCMTRANSFORM)cw;
}

/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateTransform(		LPLOGCOLORSPACEA	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter );

Abstract:
	The CMCreateTransform function creates a color transform that
	maps from an input LogColorSpace to an optional target to an
	output device.

Parameter					Description
	lpColorSpace			Pointer to input color space. If lcsFilename is non-zero,
							it is a pointer to the memory mapped profile.
	LpDevCharacter			Pointer to memory mapped device profile
	lpTargetDevCharacter	Pointer to memory mapped target profile

Returns
	If the function is successful, it returns a color transform
	in the range 256 to 65535. Otherwise it returns an error code
	(return value < 255).

  _____________________________________________________________________ */
HCMTRANSFORM  WINAPI CMCreateTransform	(	LPLOGCOLORSPACEA	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter )
{
	return CMCreateTransformExt( lpColorSpace, lpDevCharacter, lpTargetDevCharacter, PROOF_MODE | ENABLE_GAMUT_CHECKING | 0x80000000 );
}
/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateTransformExtW(	LPLOGCOLORSPACEW	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter,
											DWORD				dwFlags );

Abstract:
	The CMCreateTransformExtW function creates a color transform that
	maps from an input LogColorSpace to an optional target to an
	output device.

Parameter					Description
	lpColorSpace			Pointer to input color space. If lcsFilename is non-zero, it is a pointer to the memory mapped profile.
	LpDevCharacter			Pointer to memory mapped device profile
	lpTargetDevCharacter	Pointer to memory mapped target profile
	dwFlags					Specifies flags to control creation of the transform.
							It is up to the CMM to determine how best to use these flags.
							Set the high-order word to ENABLE_GAMUT_CHECKING if the transform
							will be used for gamut checking.
							The low-order WORD can have one of the following constant values:
							PROOF_MODE, NORMAL_MODE, BEST_MODE.
							Moving from PROOF_MODE to BEST_MODE, output quality generally improves and transform speed declines.

Returns
	If the function is successful, it returns a color transform
	in the range 256 to 65535. Otherwise it returns an error code
	(return value < 255).

   _____________________________________________________________________ */
HCMTRANSFORM  WINAPI CMCreateTransformExtW(	LPLOGCOLORSPACEW 	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter,
											DWORD				dwFlags )
{
	CMWorldRef cw=0;
	long err;
	LPBYTE pt,pd, ptDeRef, pdDeRef;
	HPROFILE aProf;
	PROFILE theProf;

	err = FillProfileFromLogW( lpColorSpace, &theProf );
	if( err ){
		SetLastError( err );
		goto CleanupAndExit;
	}
	aProf = OpenColorProfileW(&theProf, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING );
	if( !aProf ){
		err = GetLastError();
		goto CleanupAndExit;
	}
	pd = ((LPBYTE)lpColorSpace+sizeof(LOGCOLORSPACEW));
	pdDeRef= (LPBYTE)*(ULONG_PTR UNALIGNED*)pd;

	pt = ((LPBYTE)lpColorSpace+sizeof(LOGCOLORSPACEW)+sizeof(HPROFILE));
	ptDeRef= (LPBYTE)*(ULONG_PTR UNALIGNED*)pt;

	err = CMCreateTransformExtInternal(	&cw, dwFlags,
				lpColorSpace->lcsIntent, aProf, ptDeRef, pdDeRef );

CleanupAndExit:
	if( lpColorSpace->lcsFilename[0] == 0 ){
		if( theProf.pProfileData )GlobalFreePtr( theProf.pProfileData );
		theProf.pProfileData = 0;
	}
	if( err ){
		return (HCMTRANSFORM)(ULONG_PTR)(err & 255);
	}
	return (HCMTRANSFORM)cw;
}

/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateTransformW(	LPLOGCOLORSPACEW	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter );

Abstract:
	The CMCreateTransformW function creates a color transform that
	maps from an input LogColorSpace to an optional target to an
	output device.

Parameter					Description
	lpColorSpace			Pointer to input color space. If lcsFilename is non-zero, it is a pointer to the memory mapped profile.
	LpDevCharacter			Pointer to memory mapped device profile
	lpTargetDevCharacter	Pointer to memory mapped target profile

Returns
	If the function is successful, it returns a color transform
	in the range 256 to 65535. Otherwise it returns an error code
	(return value < 255).

   _____________________________________________________________________ */
HCMTRANSFORM  WINAPI CMCreateTransformW(	LPLOGCOLORSPACEW 	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter )
{
	return CMCreateTransformExtW( lpColorSpace, lpDevCharacter, lpTargetDevCharacter, PROOF_MODE | ENABLE_GAMUT_CHECKING );
}

long  CMCreateMultiProfileTransformInternal(		CMWorldRef	*cw,
													LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													DWORD		*aIntentArr,
													DWORD		nIntents,
													DWORD		dwFlags,
													DWORD		dwCreateLink )
{
	CMConcatProfileSet	*profileSet;
	OSErr				aOSErr;
	DWORD				i;
	long				err;
	UINT32				theFlags;
	UINT32				*arrIntents = 0;;

	profileSet = (CMConcatProfileSet *)SmartNewPtrClear( sizeof (CMConcatProfileSet) + (nProfiles)* sizeof(CMProfileRef), &aOSErr );
	if (aOSErr == 0 )
	{
		profileSet->keyIndex = 0;
		profileSet->count = (unsigned short)nProfiles;
		for( i=0; i<nProfiles; i++)
			profileSet->profileSet[i] = (CMProfileRef)((DWORD *)(((PVOID *)lpahProfiles)[i]));
	}
	else return ERROR_NOT_ENOUGH_MEMORY;

	switch( dwFlags & 0xffff ){
		case BEST_MODE:
			theFlags = cmBestMode;
			break;
		case PROOF_MODE:
			theFlags = cmDraftMode;
			break;
		default:
			theFlags = cmNormalMode;
			break;
	}
	if( ! (dwFlags & ENABLE_GAMUT_CHECKING) ){
		theFlags |= kCreateGamutLutMask;
	}
	if( dwFlags & USE_RELATIVE_COLORIMETRIC ){
		theFlags |= kUseRelColorimetric;
	}
	if( dwFlags & FAST_TRANSLATE ){
		theFlags |= kLookupOnlyMask;
	}
	if( nProfiles > 1 && nIntents == 1 ){
		arrIntents = (UINT32 *)SmartNewPtrClear( nProfiles * sizeof (UINT32), &aOSErr);
		if (aOSErr != 0 ){
			err = ERROR_NOT_ENOUGH_MEMORY;
			goto CleanupAndExit;
		}
		arrIntents[0] = icPerceptual;
		arrIntents[1] = aIntentArr[0];
		for( i=2; i<nProfiles; i++){
			arrIntents[i] = icAbsoluteColorimetric;
			if( dwFlags & kUseRelColorimetric ) arrIntents[i] = icRelativeColorimetric;
		}
		err = CWConcatColorWorld4MS( cw, profileSet, arrIntents, nProfiles, theFlags );
		arrIntents= (UINT32 *)DisposeIfPtr( (Ptr) arrIntents );
	}
	else{
		err = CWConcatColorWorld4MS( cw, profileSet, aIntentArr, nIntents, theFlags );
	}
#ifdef WRITE_PROFILE
	if( err == 0 ){
		err = MyNewDeviceLink( *cw, profileSet, "MyCreateTransform.pf" );
		//goto CleanupAndExit;
	}
#endif
CleanupAndExit:
	profileSet= (CMConcatProfileSet *)DisposeIfPtr( (Ptr) profileSet );
	return err;
}

/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateMultiProfileTransform(	LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													UINT32		*aIntentArr,
													UINT32		nIntents,
													UINT32		dwFlags );

Abstract:
	The CMCreateMultiProfileTransform function accepts
	an array of profiles or a single device link profile
	and creates a color transform.
	This transform is a mapping from the color space specified
	by the first profile to that of the second profile
	and so on until the last one.

Parameter			Description
	lpahProfiles	Pointer to an array of profile handles
	nProfiles		Number of profiles in the array
	padwIntents		(in)		Points to an array of intent structures.
								0 = default behavior ( intents out of profiles )

	nIntents		(in)		Specifies the number of intents in the intent array.
								Can be 1, or the same value as nProfiles.

	dwFlags			(in)		Specifies flags to control creation of the transform.
								These flags are intended only as hints, and it is up to the CMM
								to determine how best to use these flags.
								Set the high-order word to ENABLE_GAMUT_CHECKING if the transform will be used
								for gamut checking.
								The low-order WORD can have one of the following constant values:
								PROOF_MODE, NORMAL_MODE, BEST_MODE. Moving from PROOF_MODE to BEST_MODE,
Returns
	If the function is successful, it returns a color transform.
	Otherwise it returns an error code (return value < 255).
   _____________________________________________________________________ */
HCMTRANSFORM  WINAPI CMCreateMultiProfileTransform(	LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													DWORD		*aIntentArr,
													DWORD		nIntents,
													DWORD		dwFlags )
{
	long				err;
	CMWorldRef			cw;
    CMWorldRef          cwTemp;

	err = CMCreateMultiProfileTransformInternal( &cw, lpahProfiles, nProfiles, aIntentArr, nIntents, dwFlags, 0 );
	if( err ){
		SetLastError( err );
		return (HCMTRANSFORM)(ULONG_PTR)(err & 255);
	}
    cwTemp = cw;
    cw = StoreTransform( cw );
    if( cw == (HCMTRANSFORM)ERROR_NOT_ENOUGH_MEMORY ){
        CWDisposeColorWorld( cwTemp );
    }

	return (HCMTRANSFORM)cw;
}

/* ______________________________________________________________________
BOOL  WINAPI CMDeleteTransform( HCMTRANSFORM 	hcmTransform );

Abstract:
	The CMDeleteTransform function deletes the given color transform,
	and frees any memory associated with it.

Parameter			Description
	hcmTransform	Identifies the color transform

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
   _____________________________________________________________________ */
BOOL  WINAPI CMDeleteTransform( HCMTRANSFORM 	hcmTransform )
{
	long actTransform = (long)(ULONG_PTR)hcmTransform - 256;
	HCMTRANSFORM aTrans = NULL;
	CMMModelPtr theModelPtr;
	CMWorldRef theWorldRef;
    BOOL bReturn = 0;

	__try {
		EnterCriticalSection(&GlobalCriticalSection);
		if( actTransform < IndexTransform && actTransform >= 0 ){
			aTrans = TheTransform[actTransform];
			TheTransform[ actTransform ] = 0;
			if( actTransform == IndexTransform-1 )IndexTransform--;
			bReturn = 1;
		}
	}
	__finally{
		LeaveCriticalSection(&GlobalCriticalSection);
		
		LOCK_DATA( aTrans );
		theModelPtr = (CMMModelPtr)(DATA_2_PTR( aTrans ));
		theWorldRef = theModelPtr->pBackwardTransform;
		UNLOCK_DATA( aTrans );
		if( theWorldRef != 0 ){
			CWDisposeColorWorld( theWorldRef );
		}

		CWDisposeColorWorld( aTrans );
	}
    return bReturn;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCreateProfile(	LPLOGCOLORSPACEA		lpColorSpace,
								LPBYTE 					*lpProfileData );

Abstract:
	The CMCreateProfile function creates a display color profile
	from a LogColorSpace structure.

Parameter			Description
	lpColorSpace	Pointer to color space. lcsFilename field will be NULL.
	pProfileData	Points to a pointer to a buffer.
					If successful the function allocates and fills this buffer.
					It is then the calling applications responsibility to
					free this buffer with GlobalFreePtr( lpProfileData )
					when it is no longer needed.

Returns
	If the function is successful, it returns nonzero.
	Otherwise it returns zero.

   _____________________________________________________________________ */
BOOL  WINAPI CMCreateProfile(	LPLOGCOLORSPACEA	lpColorSpace,
								LPBYTE 				*lpProfileData )
{
	CMWorldRef cw=0;
	long err;

	if( lpColorSpace->lcsFilename[0] ) return 0;
	err = MyNewAbstract( lpColorSpace, (icProfile **)lpProfileData );
	//err = FillProfileFromLog( lpColorSpace, &theProf );
	if( err ){
		SetLastError( err );
		goto CleanupAndExit;
	}
	return 1;
CleanupAndExit:
	return 0;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCreateProfileW(	LPLOGCOLORSPACEW	lpColorSpace,
								LPBYTE 				*lpProfileData );

Abstract:
	The CMCreateProfileW function creates a display color profile
	from a LogColorSpace structure.

Parameter			Description
	lpColorSpace	Pointer to color space. lcsFilename field will be NULL.
	pProfileData	Points to a pointer to a buffer.
					If successful the function allocates and fills this buffer.
					It is then the calling applications responsibility to
					free this buffer with GlobalFreePtr( lpProfileData )
					when it is no longer needed.

Returns
	If the function is successful, it returns nonzero.
	Otherwise it returns zero.

   _____________________________________________________________________ */
BOOL  WINAPI CMCreateProfileW(	LPLOGCOLORSPACEW	lpColorSpace,
								LPBYTE 				*lpProfileData )
{
	CMWorldRef cw=0;
	long err;

	if( lpColorSpace->lcsFilename[0] ) return 0;
	err = MyNewAbstractW( lpColorSpace, (icProfile **)lpProfileData );
	//err = FillProfileFromLogW( lpColorSpace, &theProf );
	if( err ){
		SetLastError( err );
		goto CleanupAndExit;
	}
	return 1;
CleanupAndExit:
	return 0;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCreateDeviceLinkProfile(		LPHPROFILE	lpahProfiles,
											DWORD 		nProfiles,
											UINT32		*aIntentArr,
											UINT32		nIntents,
											UINT32		dwFlags,
											LPBYTE		*lpProfileData );

Abstract:
	The CMCreateDeviceLinkProfile function creates a device link
	profile as specified by the "ICC Profile Format Specification."

Parameter			Description
	lpahProfiles	Pointer to an array of profile handles
	nProfiles		Number of profiles in the array
	padwIntents		Points to an array of rendering intents.
					Each rendering intent is represented by one of the following values:
						INTENT_PERCEPTUAL
						INTENT_SATURATION
						INTENT_RELATIVE_COLORIMETRIC
						INTENT_ABSOLUTE_COLORIMETRIC
					For more information, see Rendering Intents.

	nIntents		Specifies the number of intents in the intent array. Can be 1, or the same value as nProfiles.
	dwFlags			Specifies flags to control creation of the transform. These flags are intended only as hints,
					and it is up to the CMM to determine how best to use these flags.
					Set the high-order word to ENABLE_GAMUT_CHECKING if the transform will be used for gamut checking.
					The low-order WORD can have one of the following constant values:
						PROOF_MODE, NORMAL_MODE, BEST_MODE. Moving from PROOF_MODE to BEST_MODE,
						output quality generally improves.

	lpProfileData	Points to a pointer to a buffer.
					If successful the function allocates and fills this buffer.
					It is then the calling applications responsibility to
					free this buffer with GlobalFreePtr( lpProfileData )
					when it is no longer needed.

Returns
	If the function is successful, it returns nonzero.
	Otherwise it returns zero. SetLastError is used.

   _____________________________________________________________________ */

BOOL  WINAPI CMCreateDeviceLinkProfile(	LPHPROFILE	lpahProfiles,
										DWORD 		nProfiles,
										DWORD		*aIntentArr,
										DWORD		nIntents,
										DWORD		dwFlags,
										LPBYTE		*lpProfileData )
{
	long				err;
	OSErr				aOSErr;
	CMWorldRef			cw;
	CMConcatProfileSet	*profileSet;
	UINT32				i;

	*lpProfileData = 0;
	
	err = CMCreateMultiProfileTransformInternal( &cw, lpahProfiles, nProfiles, aIntentArr, nIntents, dwFlags, 0 );
	if( err ){
		SetLastError( err );
		return 0;
	}
	profileSet = (CMConcatProfileSet *)SmartNewPtrClear(sizeof (CMConcatProfileSet) + (nProfiles)* sizeof(CMProfileRef),&aOSErr);
	err = aOSErr;
	if (aOSErr == 0 )
	{
		profileSet->keyIndex = 0;
		profileSet->count = (unsigned short)nProfiles;
		for( i=0; i<nProfiles; i++)
			profileSet->profileSet[i] = (CMProfileRef)((DWORD *)(((PVOID *)lpahProfiles)[i]));
	}
	else goto CleanupAndExit;

	err = DeviceLinkFill( (CMMModelPtr)cw, profileSet, (icProfile **)lpProfileData, aIntentArr[0]  );
	profileSet= (CMConcatProfileSet *)DisposeIfPtr( (Ptr) profileSet );

	if( err )goto CleanupAndExit;
	CWDisposeColorWorld ( cw );
	return 1;

CleanupAndExit:
	CWDisposeColorWorld ( cw );
	SetLastError( err );
	return 0;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCreateDeviceLinkProfile(	LPHPROFILE	lpahProfiles,
										DWORD 		nProfiles,
										LPBYTE		*lpProfileData );

Abstract:
	The CMCreateDeviceLinkProfile function creates a device link
	profile as specified by the "ICC Profile Format Specification."

Parameter			Description
	lpahProfiles	Pointer to an array of profile handles
	nProfiles		Number of profiles in the array
	pProfileData	Points to a pointer to a buffer.
					If successful the function allocates and fills this buffer.
					It is then the calling applications responsibility to
					free this buffer with GlobalFreePtr( lpProfileData )
					when it is no longer needed.

Returns
	If the function is successful, it returns nonzero.
	Otherwise it returns zero. SetLastError is used.

   _____________________________________________________________________ */

/*BOOL  WINAPI CMCreateDeviceLinkProfile(	LPHPROFILE	lpahProfiles,
										DWORD 		nProfiles,
										LPBYTE		*lpProfileData )
{
	long			err;
	UINT32			*arrIntents = 0;
	OSErr			aOSErr;
	DWORD			i;

	arrIntents = (UINT32 *)SmartNewPtrClear( nProfiles * sizeof (UINT32), &aOSErr);
	if (aOSErr != 0 ) return ERROR_NOT_ENOUGH_MEMORY;

	for( i=0; i<nProfiles; i++){
		arrIntents[i] = icPerceptual;
	}

	err = CMCreateDeviceLinkProfileExt( lpahProfiles, nProfiles, arrIntents, nProfiles, BEST_MODE, lpProfileData );
	
	arrIntents = (UINT32 *)DisposeIfPtr( (Ptr)arrIntents );
	return err;
}
*/
/* ______________________________________________________________________
BOOL  WINAPI CMIsProfileValid (	HPROFILE	hProfile,	
								LPBOOL		lpbValid	
							  );

Abstract:
	The CMIsProfileValid function reports if the given profile is a valid ICC profile that can be used for color matching.

Parameter			Description
	lpDevCharacter	Pointer to memory mapped profile
	lpbValid		Points to a variable that is set on exit to TRUE if the profile is a valid ICC profile, or FALSE if not.

Returns
	If it is a valid ICC profile that can be used for color matching,
	the return value is nonzero. Otherwise it is zero.
   _____________________________________________________________________ */
BOOL  WINAPI CMIsProfileValid(	HPROFILE	hProfile,	
								LPBOOL		lpbValid	
							  )
{
	Boolean valid;

	CMValidateProfile( (CMProfileRef)hProfile, &valid );

	*lpbValid = valid;
	return valid;
}

/* ______________________________________________________________________
BOOL  WINAPI CMTranslateColors(	HCMTRANSFORM	hcmTransform,
								LPCOLOR 		lpaInputColors,
								DWORD 			nColors,
								COLORTYPE		ctInput,
								LPCOLOR 		lpaOutputColors,
								COLORTYPE		ctOutput );
Abstract:
	The CMTranslateColors function translates an array of colors from
	the source colorspace to the destination colorspace as defined by
	the color transform.

Parameter			Description
	hcmTransform	Identifies the color transform to use
	lpaInputColors	Pointer to an array of COLOR structures to translate
	nColors			Number of elements in the array
	ctInput			Specifies the input color type
	lpaOutputColors	Pointer to an array of COLOR structures that receive the translated colors
	ctOutput		Specifies the output color type

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.

   _____________________________________________________________________ */
BOOL  WINAPI CMTranslateColors(	HCMTRANSFORM	hcmTransform,
								LPCOLOR 		lpaInputColors,
								DWORD 			nColors,
								COLORTYPE		ctInput,
								LPCOLOR 		lpaOutputColors,
								COLORTYPE		ctOutput )
{
	long matchErr;
	DWORD i;

    if (lpaOutputColors != lpaInputColors){
    	for( i=0; i<nColors; i++) lpaOutputColors[ i ] = lpaInputColors[ i ];
    }

	matchErr = CWMatchColors( CMGetTransform( hcmTransform ), (CMColor *)lpaOutputColors, nColors );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCheckColors(	HCMTRANSFORM	hcmTransform,
							LPCOLOR 		lpaInputColors,
							DWORD			nColors,
							COLORTYPE		ctInput,
							LPBYTE 			lpaResult );
Abstract:
	The CMCheckColors function determines if the given colors lie
	within the output gamut of the given transform.

Parameter			Description
	hcmTransform	Identifies the color transform to use
	lpaInputColors	Pointer to an array of COLOR structures
	nColors			Number of elements in the array
	ctInput			Input color type
	lpaResult		Pointer to an array of bytes that hold the result

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
	The lpaResult array holds the results, each byte corresponds to a
	COLOR element and has a value between 0 and 255.
	The value 0 denotes that the color is in gamut; a non-zero value
	implies that it is out of gamut, with the number "n+1" being at
	least as far out of gamut as the number "n". These values are
	usually generated from the gamutTag in the ICC profile.

   _____________________________________________________________________ */
BOOL  WINAPI CMCheckColors(	HCMTRANSFORM	hcmTransform,
							LPCOLOR 		lpaInputColors,
							DWORD			nColors,
							COLORTYPE		ctInput,
							LPBYTE 			lpaResult )
{
	long matchErr;

	matchErr = CWCheckColorsMS( CMGetTransform( hcmTransform ), (CMColor *)lpaInputColors, nColors, lpaResult );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL  WINAPI CMTranslateRGBs(	HCMTRANSFORM	hcmTransform,
								LPVOID			lpSrcBits,
								BMFORMAT		bmInput,
								DWORD			dwWidth,
								DWORD			dwHeight,
								DWORD			dwStride,
								LPVOID			lpDestBits,
								BMFORMAT		bmOutput,
								DWORD			dwTranslateDirection );
Abstract:
	The CMTranslateRGBs function takes a bitmap in one of the defined
	formats and translates the colors in the bitmap producing another
	bitmap in the requested format.

Parameter					Description
	hcmTransform			Identifies the color transform to use
	lpSrcBits				Pointer to bitmap to translate
	bmInput					Input bitmap format
	dwWidth					Number of pixels per scanline of input data
	dwHeight				Number of	 scanlines of input data
	dwStride				Number of bytes from beginning of one scanline to beginning of next
	lpDestBits				Pointer to buffer to receive translated data
	bmOutput				Output bitmap format
	dwTranslateDirection	Describes direction of transform
	Value	Meaning
	CMS_FORWARD	Use forward transform
	CMS_BACKWARD	Use reverse transform  // NOT supported

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
   _____________________________________________________________________ */
BOOL  WINAPI CMTranslateRGBs(	HCMTRANSFORM	hcmTransform,
								LPVOID			lpSrcBits,
								BMFORMAT		bmInput,
								DWORD			dwWidth,
								DWORD			dwHeight,
								DWORD			dwStride,
								LPVOID			lpDestBits,
								BMFORMAT		bmOutput,
								DWORD			dwTranslateDirection )
{
	CMBitmapColorSpace 		spaceIn,spaceOut;
	CMBitmap				InBitmap,OutBitmap;
	long matchErr, inPixelSize, outPixelSize;
	BOOL aBgrMode = FALSE;
	CMMModelPtr theModelPtr;
	CMWorldRef theWorldRef;
	HCMTRANSFORM theTransform = CMGetTransform( hcmTransform );
	
	if( dwTranslateDirection == CMS_BACKWARD ){
		if( theTransform == 0 ){
			SetLastError( (DWORD)cmparamErr );
			return 0;
		}
		LOCK_DATA( theTransform );
		theModelPtr = (CMMModelPtr)(DATA_2_PTR( theTransform ));
		theWorldRef = theModelPtr->pBackwardTransform;
		UNLOCK_DATA( theTransform );
		if( theWorldRef == 0 ){
			SetLastError( (DWORD)cmparamErr );
			return 0;
		}
		theTransform = (HCMTRANSFORM)theWorldRef;
	}

	spaceIn = CMGetDataColorSpace( bmInput, &inPixelSize );
	if( spaceIn == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	spaceOut = CMGetDataColorSpace( bmOutput, &outPixelSize );
	if( spaceOut == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	InBitmap.image		= lpSrcBits;
	InBitmap.width		= dwWidth;
	InBitmap.height		= dwHeight;
	if( dwStride == 0 ){
		InBitmap.rowBytes = ( dwWidth * (inPixelSize / 8) + 3 ) & ~3;
	}
	else{
		InBitmap.rowBytes	= dwStride;
	}
	InBitmap.pixelSize	= inPixelSize;
	InBitmap.space		= spaceIn;
		
	OutBitmap.image		= lpDestBits;
	OutBitmap.width		= dwWidth;
	OutBitmap.height	= dwHeight;
	OutBitmap.rowBytes	= ( dwWidth * (outPixelSize / 8) + 3 ) & ~3;
	OutBitmap.pixelSize	= outPixelSize;
	OutBitmap.space		= spaceOut;

	matchErr = CWMatchBitmap( theTransform, &InBitmap,
							  (CMBitmapCallBackUPP)0,(void *)NULL,&OutBitmap );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL  WINAPI CMTranslateRGBsExt(	HCMTRANSFORM	hcmTransform,
									LPVOID			lpSrcBits,
									BMFORMAT		bmInput,
									DWORD			dwWidth,
									DWORD			dwHeight,
									DWORD			dwInputStride,
									LPVOID			lpDestBits,
									BMFORMAT		bmOutput,
									DWORD			dwOutputStride,
									LPBMCALLBACKFN  lpfnCallback,
									LPARAM			ulCallbackData )
Abstract:
	The CMTranslateRGBs function takes a bitmap in one of the defined
	formats and translates the colors in the bitmap producing another
	bitmap in the requested format.

Parameter					Description
	hcmTransform			Specifies the color transform to use.
	lpSrcBits				Points to the bitmap to translate.
	bmInput					Specifies the input bitmap format.
	dwWidth					Specifies the number of pixels per scanline in the input bitmap.
	dwHeight				Specifies the number of scanlines in the input bitmap.
	dwInputStride			Specifies the number of bytes from the beginning of one scanline to
							the beginning of the next in the input bitmap.
							If dwInputStride is set to zero, the CMM should assume that scanlines
							are padded so as to be DWORD aligned.
	lpDestBits				Points to a destination buffer in which to place the translated bitmap.
	bmOutput				Specifies the output bitmap format.
	dwOutputStride			Specifies the number of bytes from the beginning of one scanline to the
							beginning of the next in the input bitmap.
							If dwOutputStride is set to zero, the CMM should pad scanlines so
							that they are DWORD aligned.
	lpfnCallback			Pointer to an application-supplied callback function called periodically
							by CMTranslateRGBsExt to report progress and allow the calling process
							to cancel the translation. (See ICMProgressProc.)
	ulCallbackData			Data passed back to the callback function, for example to identify the
							translation that is reporting progress.

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
   _____________________________________________________________________ */
BOOL  WINAPI CMTranslateRGBsExt(	HCMTRANSFORM	hcmTransform,
									LPVOID			lpSrcBits,
									BMFORMAT		bmInput,
									DWORD			dwWidth,
									DWORD			dwHeight,
									DWORD			dwInputStride,
									LPVOID			lpDestBits,
									BMFORMAT		bmOutput,
									DWORD			dwOutputStride,
									LPBMCALLBACKFN  lpfnCallback,
									LPARAM		ulCallbackData )
{
	CMBitmapColorSpace 		spaceIn,spaceOut;
	CMBitmap				InBitmap,OutBitmap;
	long matchErr, inPixelSize, outPixelSize;
	BOOL aBgrMode = FALSE;

	spaceIn = CMGetDataColorSpace( bmInput, &inPixelSize );
	if( spaceIn == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	spaceOut = CMGetDataColorSpace( bmOutput, &outPixelSize );
	if( spaceOut == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	InBitmap.image		= lpSrcBits;
	InBitmap.width		= dwWidth;
	InBitmap.height		= dwHeight;
	if( dwInputStride == 0 ){
		InBitmap.rowBytes = ( dwWidth * (inPixelSize / 8) + 3 ) & ~3;
	}
	else{
		InBitmap.rowBytes	= dwInputStride;
	}
	InBitmap.pixelSize	= inPixelSize;
	InBitmap.space		= spaceIn;
		
	OutBitmap.image		= lpDestBits;
	OutBitmap.width		= dwWidth;
	OutBitmap.height	= dwHeight;
	if( dwOutputStride == 0 ){
		OutBitmap.rowBytes = ( dwWidth * (outPixelSize / 8) + 3 ) & ~3;
	}
	else{
		OutBitmap.rowBytes	= dwOutputStride;
	}
	OutBitmap.pixelSize	= outPixelSize;
	OutBitmap.space		= spaceOut;

	matchErr = CWMatchBitmap( CMGetTransform( hcmTransform ), &InBitmap,
							  (CMBitmapCallBackUPP)lpfnCallback,(void *)ulCallbackData,&OutBitmap );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCheckRGBs(	HCMTRANSFORM	hcmTransform,
							LPVOID			lpSrcBits,
							BMFORMAT		bmInput,
							DWORD			dwWidth,
							DWORD			dwHeight,
							DWORD			dwStride,
							LPBYTE			lpDestBits,
							PBMCALLBACKFN	pfnCallback,	
							LPARAM		ulCallbackData );
Abstract:
	The CMCheckRGBs function checks if the pixels in the bitmap lie
	within the output gamut of the given transform.

Parameter			Description

	hcmTransform	Specifies the color transform to use.
	lpSrcBits		Points to the bitmap to check against an output gamut.
	bmInput			Specifies the input bitmap format.
	dwWidth			Specifies the number of pixels per scanline in the input bitmap.
	dwHeight		Specifies the number of scanlines in the input bitmap.
	dwStride		Specifies the number of bytes from the beginning of one scanline
					to the beginning of the next in the input bitmap.
					If dwStride is set to zero, the CMM should assume that scanlines
					are padded so as to be DWORD-aligned.
	lpaResult		Points to a buffer in which the test results are to be placed.
					The results are represented by an array of bytes.
					Each byte in the array corresponds to a pixel in the bitmap,
					and on exit is set to an unsigned value between 0 and 255.
					The value 0 denotes that the color is in gamut,
					while a nonzero value denotes that it is out of gamut.
					For any integer n such that 0 < n < 255, a result value of n+1
					indicates that the corresponding color is at least as far out of
					gamut as would be indicated by a result value of n.
					These values are usually generated from the gamutTag in the ICC profile.
	pfnCallback		Pointer to an application-supplied callback function called periodically
					by CMCheckRGBs to report progress and allow the calling process
					to cancel the translation. (See ICMProgressProc.)
	ulCallbackData	Data passed back to the callback function, for example to identify
					the bitmap test that is reporting progress.

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
	The lpaResult array holds the results, each byte corresponds to a pixel
	and has a value between 0 and 255. The value 0 denotes that the color is in gamut;
	a non-zero value implies that it is out of gamut, with the number "n+1" being at
	least as far out of gamut as the number "n". These values are usually generated
	from the gamutTag in the ICC profile.
   _____________________________________________________________________ */
BOOL  WINAPI CMCheckRGBs(	HCMTRANSFORM	hcmTransform,
							LPVOID			lpSrcBits,
							BMFORMAT		bmInput,
							DWORD			dwWidth,
							DWORD			dwHeight,
							DWORD			dwStride,
							LPBYTE			lpDestBits,
							PBMCALLBACKFN	pfnCallback,	
							LPARAM		ulCallbackData )

{
	CMBitmapColorSpace 		spaceIn,spaceOut;
	CMBitmap				InBitmap,OutBitmap;
	long matchErr, inPixelSize;
	BOOL aBgrMode = FALSE;

	spaceIn = CMGetDataColorSpace( bmInput, &inPixelSize );
	if( spaceIn == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	spaceOut = cm8PerChannelPacking + cmGraySpace;

	if( spaceOut == 0 )return 0;
	InBitmap.image		= lpSrcBits;
	InBitmap.width		= dwWidth;
	InBitmap.height		= dwHeight;
	if( dwStride == 0 ){
		InBitmap.rowBytes = ( dwWidth * (inPixelSize / 8) + 3 ) & ~3;
	}
	else{
		InBitmap.rowBytes	= dwStride;
	}
	InBitmap.pixelSize	= inPixelSize;
	InBitmap.space		= spaceIn;
		
	OutBitmap.image		= lpDestBits;
	OutBitmap.width		= dwWidth;
	OutBitmap.height	= dwHeight;
	OutBitmap.rowBytes	= dwWidth;	// perhaps wrong format?
	OutBitmap.pixelSize	= 8;
	OutBitmap.space		= cmGamutResultSpace;

	matchErr = CWCheckBitmap(	CMGetTransform( hcmTransform ), &InBitmap,
								(CMBitmapCallBackUPP)pfnCallback,(void *)ulCallbackData,&OutBitmap );
	
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL WINAPI CMTranslateRGB(	HCMTRANSFORM	hcmTransform,
							COLORREF		colorRef,
							LPCOLORREF		lpColorRef,
							DWORD			dwFlags );
Abstract:
	The CMTranslateRGB function translates an application supplied RGBQuad into the
	device color coordinate space.

Parameter			Description
	hcmTransform	Handle of transform to use.
	colorRef		RGBQuad to translate.
	lpColorRef		Pointer to buffer to store result.
	dwFlags			Flags that can have the following meaning

	Type			Meaning
		
	CMS_FORWARD		Specifies that the forward transform is to be used.
	CMS_BACKWARD	Specifies that the backward transform is to be used.  // NOT supported

Returns
	The return value is TRUE if the function is successful. Otherwise, it is NULL.

   _____________________________________________________________________ */
BOOL WINAPI CMTranslateRGB(	HCMTRANSFORM	hcmTransform,
							COLORREF		colorRef,
							LPCOLORREF		lpColorRef,
							DWORD			dwFlags )

{
	CMBitmapColorSpace 		spaceIn;
	CMBitmap				InBitmap,OutBitmap;
	long matchErr;
	COLORREF aColorRef = colorRef;
	BOOL aBgrMode = FALSE;
	CMBitmapColorSpace In,Out;
	CMMModelPtr theModelPtr;
	CMWorldRef theWorldRef;
	HCMTRANSFORM theTransform = CMGetTransform( hcmTransform );
	
	if( dwFlags == CMS_BACKWARD ){
		if( theTransform == 0 ){
			SetLastError( (DWORD)cmparamErr );
			return 0;
		}
		LOCK_DATA( theTransform );
		theModelPtr = (CMMModelPtr)(DATA_2_PTR( theTransform ));
		theWorldRef = theModelPtr->pBackwardTransform;
		UNLOCK_DATA( theTransform );
		if( theWorldRef == 0 ){
			SetLastError( (DWORD)cmparamErr );
			return 0;
		}
		theTransform = (HCMTRANSFORM)theWorldRef;
	}

	spaceIn = cmRGBA32Space;
	InBitmap.image		= (char *)(&aColorRef);
	InBitmap.width		= 1;
	InBitmap.height		= 1;
	InBitmap.rowBytes	= 4;
	InBitmap.pixelSize	= 32;
	InBitmap.space		= spaceIn;
	OutBitmap = InBitmap;	
	OutBitmap.image		= (char *)lpColorRef;

	matchErr = CWGetColorSpaces( theTransform, &In, &Out );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	if( Out == icSigCmykData ) OutBitmap.space = cmKYMC32Space;
	matchErr = CWMatchBitmap(	theTransform, &InBitmap,
								(CMBitmapCallBackUPP)0,(void *)NULL,&OutBitmap );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}


/* ______________________________________________________________________
BOOL WINAPI CMCheckColorsInGamut(	HCMTRANSFORM	hcmTransform,
									LPARGBQUAD		lpaRGBTriplet,
									LPBYTE			lpBuffer,
									UINT			nCount );
Abstract:
	The CMCheckColorInGamut determines if the given RGBs lie in the output gamut of the
	given transform.

Parameter			Description	
	hcmTransform	Handle of transform to use.
	lpaRGBTriples	Pointer to array of RGB triples to check.
	lpBuffer		Pointer to buffer to put results.
	nCount			Count of elements in array.


Returns
	The return value is TRUE if the function is successful. Otherwise, it is NULL.
	The lpBuffer holds the results, each byte corresponding to an RGB triple is a value in
	the range 0 to 255.
   _____________________________________________________________________ */
BOOL WINAPI CMCheckColorsInGamut(	HCMTRANSFORM	hcmTransform,
									RGBTRIPLE		*lpaRGBTriplet,
									LPBYTE			lpBuffer,
									UINT			nCount )
{
	CMBitmap				InBitmap,OutBitmap;
	long matchErr;
	BOOL aBgrMode = FALSE;

	InBitmap.image		= (char *)(lpaRGBTriplet);
	InBitmap.width		= nCount;
	InBitmap.height		= 1;
	InBitmap.rowBytes	= 3*nCount;
	InBitmap.pixelSize	= 24;
	InBitmap.space		= cm8PerChannelPacking + cmRGBSpace;
	OutBitmap = InBitmap;	
	OutBitmap.rowBytes	= nCount;	// perhaps wrong format?
	OutBitmap.pixelSize	= 8;
	OutBitmap.image		= (char *)lpBuffer;

	matchErr = CWCheckBitmap(	CMGetTransform( hcmTransform ), &InBitmap,
								(CMBitmapCallBackUPP)0,(void *)NULL,&OutBitmap );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}
/* ______________________________________________________________________
long FillProfileFromLog(	LPLOGCOLORSPACEA	lpColorSpace,
							PPROFILE			theProf )
Abstract:
	The FillProfileFromLog function convertes a lpColorSpace to a PROFILE.
	If lpColorSpace has a profile name the function returns a file based profile.
	Else it returns a memory based profile.

Parameter			Description	
	lpColorSpace	Handle of transform to use.
	theProf			Pointer to the profile.

Returns
	The return value is 0 if the function is successful. Otherwise, it is an error code.
   _____________________________________________________________________ */
long FillProfileFromLog(	LPLOGCOLORSPACEA	lpColorSpace,
							PPROFILE			theProf )
{
	long l;
	icProfile *aProf;
	CMError  err = -1;

	if( lpColorSpace->lcsFilename[0] ){
		theProf->pProfileData = (char *)lpColorSpace->lcsFilename;
		theProf->dwType = PROFILE_FILENAME;
		theProf->cbDataSize = lstrlenA((const unsigned char *)theProf->pProfileData) * sizeof(CHAR);
		err = 0;
	}
	else if( lpColorSpace->lcsCSType == LCS_CALIBRATED_RGB ){
		err = MyNewAbstract( lpColorSpace, &aProf );
        if(aProf)
        {
    		theProf->pProfileData = ((PVOID *)aProf);
    		theProf->dwType = PROFILE_MEMBUFFER;
    		l = *(DWORD *)(theProf->pProfileData);
    		theProf->cbDataSize = SwapLong(&l);
        }
        else theProf->pProfileData = 0;
	}
	else  theProf->pProfileData = 0;

	return err;
}

/* ______________________________________________________________________
long FillProfileFromLogW(	LPLOGCOLORSPACEW	lpColorSpace,
							PPROFILE			theProf )
Abstract:
	The FillProfileFromLog function convertes a lpColorSpace to a PROFILE.
	If lpColorSpace has a profile name the function returns a file based profile.
	Else it returns a memory based profile.

Parameter			Description	
	lpColorSpace	Handle of transform to use.
	theProf			Pointer to the profile.

Returns
	The return value is 0 if the function is successful. Otherwise, it is an error code.
   _____________________________________________________________________ */
long FillProfileFromLogW(	LPLOGCOLORSPACEW	lpColorSpace,
							PPROFILE			theProf )
{
	long l;
	icProfile *aProf;
	CMError  err = -1;

	if( lpColorSpace->lcsFilename[0] ){
		theProf->pProfileData = (char *)lpColorSpace->lcsFilename;
		theProf->dwType = PROFILE_FILENAME;
		theProf->cbDataSize = lstrlenW((const unsigned short *)theProf->pProfileData) * sizeof(WCHAR);
		err = 0;
	}
	else if( lpColorSpace->lcsCSType == LCS_CALIBRATED_RGB ){
		err = MyNewAbstractW( lpColorSpace, &aProf );
        if(aProf)
        {
    		theProf->pProfileData = ((PVOID *)aProf);
    		theProf->dwType = PROFILE_MEMBUFFER;
    		l = *(DWORD *)(theProf->pProfileData);
    		theProf->cbDataSize = SwapLong(&l);
        }
        else theProf->pProfileData = 0;
	}
	else  theProf->pProfileData = 0;

	return err;
}

/* ______________________________________________________________________
CMBitmapColorSpace CMGetDataColorSpace( BMFORMAT bmMode, long *pixelSize );

Abstract:
	The CMGetDataColorSpace function retrieves the CMBitmapColorSpace and
	the pixel size from the BMFORMAT.

Parameter			Description
	bmMode			Identifies the data format.
	pixelSize		Pointer to pixelsize.

Returns
	function returns the internal data format
________________________________________________________________ */
CMBitmapColorSpace CMGetDataColorSpace( BMFORMAT bmMode, long *pixelSize )
{
	switch(  bmMode ){
	case BM_565RGB:
		*pixelSize = 16;
		return cmWord565ColorPacking + cmRGBSpace;
		break;
    case BM_x555RGB:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmRGBSpace;
		break;
	case BM_x555XYZ:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmXYZSpace;
		break;
	case BM_x555Yxy:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmYXYSpace;
		break;
	case BM_x555Lab:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmLABSpace;
		break;
	case BM_x555G3CH:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmGenericSpace;
		break;
	case BM_RGBTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmBGRSpace;
		break;
	case BM_BGRTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmRGBSpace;
		break;
	case BM_XYZTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmXYZSpace;
		break;
	case BM_YxyTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmYXYSpace;
		break;
	case BM_LabTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmLABSpace;
		break;
	case BM_G3CHTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmGenericSpace;
		break;
	case BM_5CHANNEL:
		*pixelSize = 40;
		return cmMCFive8Space;
		break;
	case BM_6CHANNEL:
		*pixelSize = 48;
		return cmMCSix8Space;
		break;
	case BM_7CHANNEL:
		*pixelSize = 56;
		return cmMCSeven8Space;
		break;
	case BM_8CHANNEL:
		*pixelSize = 64;
		return cmMCEight8Space;
		break;
	case BM_GRAY:
		*pixelSize = 8;
		return cm8PerChannelPacking + cmGraySpace;
		break;
	case BM_xRGBQUADS:
		*pixelSize = 32;
		return cmBGR32Space;
		break;
	case BM_xBGRQUADS:
		*pixelSize = 32;
		return cmRGBA32Space;
		break;
#if 0
	case BM_xXYZQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmXYZSpace;
		break;
	case BM_xYxyQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmYXYSpace;
		break;
	case BM_xLabQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmLABSpace;
		break;
#endif
    case BM_xG3CHQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmGenericSpace;
		break;
	case BM_CMYKQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmKYMCSpace;
		break;
	case BM_KYMCQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmCMYKSpace;
		break;
	case BM_10b_RGB:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmRGBSpace;
		break;
	case BM_10b_XYZ:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmXYZSpace;
		break;
	case BM_10b_Yxy:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmYXYSpace;
		break;
	case BM_10b_Lab:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmLABSpace;
		break;
	case BM_10b_G3CH:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmGenericSpace;
		break;
	case BM_16b_RGB:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmBGRSpace;
		break;
	case BM_16b_XYZ:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmXYZSpace;
		break;
	case BM_16b_Yxy:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmYXYSpace;
		break;
	case BM_16b_Lab:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmLABSpace;
		break;
	case BM_16b_G3CH:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmGenericSpace;
		break;
	case BM_16b_GRAY:
		*pixelSize = 16;
		return cmGraySpace;
		break;
	case BM_NAMED_INDEX:
		*pixelSize = 32;
		return cmNamedIndexed32Space;
		break;
	default:
		*pixelSize = 0;
		return 0;
	}
}

/* ______________________________________________________________________
HCMTRANSFORM  WINAPI CMGetTransform( HCMTRANSFORM 	hcmTransform );

Abstract:
	The CMGetTransform function retrieves the actual transform out of the static array
	in the critical section.

Parameter			Description
	hcmTransform	Handle to the transform.

Returns
	the actual pointer to the transform
________________________________________________________________ */
HCMTRANSFORM  WINAPI CMGetTransform( HCMTRANSFORM 	hcmTransform )
{
	long actTransform = (long)(ULONG_PTR)hcmTransform - 256;
	HCMTRANSFORM aTrans = NULL;

	__try {
		EnterCriticalSection(&GlobalCriticalSection);
		if( actTransform < IndexTransform && actTransform >= 0 ){
			aTrans = TheTransform[actTransform];
		}
	}
	__finally{
		LeaveCriticalSection(&GlobalCriticalSection);
 	}
    return aTrans;
}

/* ______________________________________________________________________
CMWorldRef StoreTransform( CMWorldRef aRef );

Abstract:
	The StoreTransform function stores the actual transform in the static array
	in the critical section.

Parameter		Description
	aRef		Ptr to the transform.

Returns
	valid (255 < handle < 65536 ) handle of the transform
________________________________________________________________ */
CMWorldRef StoreTransform( CMWorldRef aRef )
{
	long i;
    CMWorldRef cw = NULL;
	
	__try {
		EnterCriticalSection(&GlobalCriticalSection);
        
        /* Find a free spot in the array to insert our transform */
        
        for( i = 0; i<IndexTransform ; i++ ){
            if( TheTransform[i] == 0 ){
                TheTransform[i] = aRef;
                cw = (CMWorldRef)(ULONG_PTR)(i + 256 );
                break;
            }
        }
        
        /* Check if we failed to find an empty index for our transform, if
           so, make some more space available. */
        
		if( i >= IndexTransform ){
            /* Check to make sure we haven't overrun our array */
            
            if( IndexTransform >= 1000 ){
                return (HCMTRANSFORM)ERROR_NOT_ENOUGH_MEMORY;
            }
            
			TheTransform[IndexTransform] = aRef;
			IndexTransform++;
			cw = (CMWorldRef)(ULONG_PTR)(IndexTransform - 1 + 256);
		}
	}
	__finally{
		LeaveCriticalSection(&GlobalCriticalSection);
	}

   return cw;
}

BOOL  WINAPI CMConvertColorNameToIndex( HPROFILE aProf, LPCOLOR_NAME aColorNameArr, LPDWORD aDWordArr, DWORD count )
{
	CMError err;

	err = CMConvNameToIndexProfile( aProf, aColorNameArr, aDWordArr, count );
	if( err ){
		SetLastError( err );
		return 0;
	}
	return 1;
}

BOOL  WINAPI CMConvertIndexToColorName( HPROFILE aProf, LPDWORD aDWordArr, LPCOLOR_NAME aColorNameArr, DWORD count )
{
	long matchErr;

	matchErr = CMConvIndexToNameProfile( aProf, aDWordArr, aColorNameArr, count );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

BOOL  WINAPI CMGetNamedProfileInfo( HPROFILE aProf, LPNAMED_PROFILE_INFO Info )
{
	long matchErr;

	matchErr = CMGetNamedProfileInfoProfile( aProf, (pCMNamedProfileInfo)Info );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/*
CMBitmapColorSpace CMGetColorType( COLORTYPE bmMode, long *pixelSize )
{
	switch(  bmMode ){
	case COLOR_GRAY:
		*pixelSize = 16;
		return cm16PerChannelPacking + cmGraySpace;
		break;
	case COLOR_	:
	case COLOR_XYZ:
	case COLOR_Yxy:
	case COLOR_Lab:
	case COLOR_3_CHANNEL:
	case COLOR_CMYK:
		*pixelSize = 64;
		return cm16PerChannelPacking + cmRGBSpace;
		break;
	case COLOR_5_CHANNEL:
	case COLOR_6_CHANNEL:
	case COLOR_7_CHANNEL:
	case COLOR_8_CHANNEL:
		*pixelSize = 64;
		return cm8PerChannelPacking + cmMCFiveSpace + bmMode - COLOR_5_CHANNEL;
		break;
	default:
		*pixelSize = 0;
		return 0;
	}
}

#define CMS_x555WORD      0x00000000
#define CMS_565WORD       0x00000001
#define CMS_RGBTRIPLETS   0x00000002
#define CMS_BGRTRIPLETS   0x00000004
#define CMS_XRGBQUADS     0x00000008
#define CMS_XBGRQUADS     0x00000010
#define CMS_QUADS         0x00000020

CMBitmapColorSpace CMGetCMSType( DWORD bmMode, long *pixelSize )
{
	if(  bmMode & CMS_x555WORD ){
		*pixelSize = 16;
		return cmWord5ColorPacking + cmRGBSpace;
	}
	else if( bmMode & CMS_RGBTRIPLETS ){
		*pixelSize = 24;
		return cm8PerChannelPacking + cmRGBSpace;
	}
	else if( bmMode &  CMS_BGRTRIPLETS ){
		*pixelSize = 24;
		return cm8PerChannelPacking + cmBGRSpace;
	}
	else if( bmMode &  CMS_XRGBQUADS ){
		*pixelSize = 32;
		return cmLong8ColorPacking + cmRGBSpace;
	}
	else if( bmMode &  CMS_XBGRQUADS ){
		*pixelSize = 32;
		return cmLong8ColorPacking + cmBGRSpace;
	}
	else if( bmMode &  CMS_QUADS	 ){
		*pixelSize = 32;
		return cmLong8ColorPacking + cmCMYKSpace;
	}
	else{
		*pixelSize = 0;
		return 0;
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\mscmm\memprof.c ===
/*
	File:		MSNewMemProfile.c

	Contains:	
		creation of mem based profiles

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include <winbase.h>
#include <windowsX.h>
#include "ICM.h"

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef MSNewMemProfile_h
#include "MemProf.h"
#endif

#ifndef MemLink_h
#include "MemLink.h"
#endif

#ifdef _DEBUG
//#define WRITE_PROFILE
#endif
#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kLHMemProfileID
#endif
#endif

#ifdef WRITE_PROFILE
void WriteProf( LPSTR name, icProfile *theProf, long currentSize );
#endif

CMError MyNewDeviceLink( CMWorldRef cw, CMConcatProfileSet *profileSet, LPSTR theProf )
{
	CMError			err = unimpErr;
	PROFILE			pProf;
	HPROFILE		aHProf;

	pProf.pProfileData = (PVOID *)theProf;
	pProf.dwType = PROFILE_FILENAME;
	pProf.cbDataSize = strlen((const unsigned char *)pProf.pProfileData) * sizeof(CHAR);
	aHProf = OpenColorProfile( &pProf, PROFILE_READWRITE, 0, CREATE_ALWAYS );
 	if( !aHProf ){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = MyNewDeviceLinkFill( cw, profileSet, aHProf );

CleanupAndExit:
	return err;
}

CMError MyNewDeviceLinkW( CMWorldRef cw, CMConcatProfileSet *profileSet, LPWSTR theProf )
{
	CMError			err = unimpErr;
	PROFILE			pProf;
	HPROFILE		aHProf;

	pProf.pProfileData = (PVOID *)theProf;
	pProf.dwType = PROFILE_FILENAME;
	pProf.cbDataSize = wcslen((const unsigned short *)pProf.pProfileData) * sizeof(WCHAR);
	aHProf = OpenColorProfileW( &pProf, PROFILE_READWRITE, 0, CREATE_ALWAYS );
 	if( !aHProf ){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = MyNewDeviceLinkFill( cw, profileSet, aHProf );
CleanupAndExit:
	return err;
}

CMError MyNewDeviceLinkFill( CMWorldRef cw, CMConcatProfileSet *profileSet, HPROFILE aHProf )
{
	CMError			err = unimpErr;
	OSErr			aOSerr = unimpErr;
#ifdef __MWERKS__
        unsigned char			theText[] = "\pLogColorSpProfile";
#else
      char			theText[] = "\024DeviceLinkProfile   ";
#endif
	char			copyrightText[] = "\0601996 by Heidelberger Druckmaschinen AG  U.J.K.";
	Ptr 			aPtr=0;
	long 			theHeaderSize;
	long 			theDescSize;
	long 			theMediaSize;
	long 			theCopyRightSize;
	long 			currentSize=0;
	long 			theTotalSize=0;
	long 			theSequenceDescSize = 0;
	long			theA2B0Size;
	unsigned long	aIntent;
	UINT32			sCS,dCS,clutSize;
	OSErr			aOSErr;


	MyDoubleXYZ D50XYZ = { 0.9642, 1.0000, 0.8249 };
	icXYZNumber D50 = { (unsigned long)(D50XYZ.X * 65536), (unsigned long)(D50XYZ.Y * 65536), (unsigned long)(D50XYZ.Z * 65536)};
	theHeaderSize = sizeof(icHeader);

	theDescSize   = 									  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ sizeof(unsigned long) 	/* ASCII length */
														+ theText[0]				/* ASCII profile description */
														+ sizeof(unsigned long)		/* Unicode code */
														+ sizeof(unsigned long)		/* Unicode character count */
														+ sizeof(unsigned short)	/* Macintosh script code */
														+ sizeof(unsigned char)		/* Macintosh string length */
														+ 67						/* Macintosh string */
														;
	theCopyRightSize   = 								  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ copyrightText[0]			/* ASCII profile description */
														;
	theMediaSize = sizeof( icXYZType );;

	aPtr = SmartNewPtrClear( 5000, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;

	aIntent = 0;

	err = MyGetColorSpaces( profileSet, &sCS, &dCS );
	if (err)
		goto CleanupAndExit;
		
	err = MyAdd_NL_HeaderMS(theHeaderSize+4, (icHeader*)aPtr, aIntent, sCS, dCS );
	if (err)
		goto CleanupAndExit;
		
	err = SetColorProfileHeader( aHProf, (PPROFILEHEADER)aPtr);
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}

	err =MyAdd_NL_DescriptionTag	( (LHTextDescriptionType *)aPtr, (unsigned char *)theText );
	if (err)
		goto CleanupAndExit;
	err = SetColorProfileElementSize( aHProf, icSigProfileDescriptionTag, theDescSize );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigProfileDescriptionTag, 0, (DWORD *)&theDescSize, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}

	err = MyAdd_NL_ColorantTag((icXYZType *)aPtr, &D50);
	if (err)
		goto CleanupAndExit;

	err = SetColorProfileElementSize( aHProf, icSigMediaWhitePointTag, theMediaSize );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigMediaWhitePointTag, 0, (DWORD *)&theMediaSize, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}

	err = MyAdd_NL_CopyrightTag( (unsigned char *)copyrightText, (LHTextType *)aPtr);
	if (err)
		goto CleanupAndExit;
	err = SetColorProfileElementSize( aHProf, icSigCopyrightTag, theCopyRightSize );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigCopyrightTag, 0, (DWORD *)&theCopyRightSize, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
		
	err = MyAdd_NL_SequenceDescTag( profileSet, (icProfileSequenceDescType *)aPtr, &theSequenceDescSize );
	if (err)
		goto CleanupAndExit;
	err = SetColorProfileElementSize( aHProf, icSigProfileSequenceDescTag, theSequenceDescSize );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigProfileSequenceDescTag, 0, (DWORD *)&theSequenceDescSize, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	
	aPtr = DisposeIfPtr( aPtr );

    theA2B0Size = GetSizes( (CMMModelPtr)cw, &clutSize );

	aPtr =  SmartNewPtr( theA2B0Size, &aOSErr );
	err = aOSErr;
	if (err)
		goto CleanupAndExit;

	if ( ((CMMModelPtr)cw)->lutParam.colorLutWordSize == 8)
        err = MyAdd_NL_AToB0Tag_mft1( (CMMModelPtr)cw, (icLut8Type *)aPtr, clutSize );
    else
        err = MyAdd_NL_AToB0Tag_mft2( (CMMModelPtr)cw, (icLut16Type *)aPtr, clutSize );

	if (err)
		goto CleanupAndExit;

	//if( theA2B0Size > 12000 ) theA2B0Size = 12000;
	err = SetColorProfileElementSize( aHProf, icSigAToB0Tag, theA2B0Size );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigAToB0Tag, 0, (DWORD *)&theA2B0Size, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
		
	err = noErr;
	
CleanupAndExit:
	CloseColorProfile( aHProf );
	aPtr = DisposeIfPtr( aPtr );
	return err;
}

#ifdef WRITE_PROFILE
#ifdef IS_MAC
/*#include <unistd.h>*/
/*#include <fcntl.h>*/
#else
#include <fcntl.h>
#include <io.h>
#include <sys/stat.h>
#endif
#include <stdio.h>

void WriteProf( LPSTR name, icProfile *theProf, long currentSize )
{
	int fh;
	
	fh = open( name, O_CREAT|O_RDWR|O_BINARY, _S_IREAD | _S_IWRITE );
	if( fh <= 0 ){
#ifdef DEBUG_OUTPUT
		printf("Open %s failed\n",name);
#endif
		return;
	}
	write( fh, (Ptr)theProf, currentSize );
	close(fh);
}
#endif

#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>
long SaveMyProfile( LPSTR lpProfileName, LPWSTR lpProfileNameW, PPROFILE theProf )
{
	long ret;
	int fh;

	if( theProf->dwType != PROFILE_MEMBUFFER ){
		SetLastError( (unsigned long) unimpErr );
		return 0;
	}
	if( lpProfileNameW == 0 ){
		if( lpProfileName == 0 ) return 0;
		fh = _open( lpProfileName, _O_BINARY | _O_CREAT  | _O_EXCL, _S_IREAD | _S_IWRITE );
	}
	else{
		fh = _wopen( lpProfileNameW, _O_BINARY | _O_CREAT  | _O_EXCL, _S_IREAD | _S_IWRITE );
	}
	if( fh == -1 ) return -1;

	if( theProf->pProfileData == 0 ){
		SetLastError( ERROR_INVALID_DATA );
		return 0;
	}
	ret = _write( fh, theProf->pProfileData, theProf->cbDataSize );
	if( ret == -1 ) return -1;

	ret = _close( fh );
	if( ret == -1 ) return -1;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\calceng1.h ===
/*
	File:		LHCalcEngine.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCalcEngine1Dim_h
#define LHCalcEngine1Dim_h

#ifndef LHTypeDefs_h
#include "TypeDefs.h"
#endif

#ifndef LHCalcEngine_h
typedef unsigned char  LH_UINT8;
typedef unsigned short LH_UINT16;
typedef unsigned long  LH_UINT32;
#endif
#undef  LH_CALC_ENGINE_UNDEF_MODE
#undef  LH_CALC_ENGINE_P_TO_P
#undef  LH_CALC_ENGINE_P_TO_U			
#undef  LH_CALC_ENGINE_U_TO_P
#undef  LH_CALC_ENGINE_U_TO_U		
#define LH_CALC_ENGINE_UNDEF_MODE           0
#define LH_CALC_ENGINE_P_TO_P               1
#define LH_CALC_ENGINE_P_TO_U		        2				
#define LH_CALC_ENGINE_U_TO_P			    3
#define LH_CALC_ENGINE_U_TO_U			    4				

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc1toX_Di8_Do8_Lut8_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di8_Do8_Lut16_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di8_Do16_Lut8_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di8_Do16_Lut16_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di16_Do8_Lut8_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di16_Do8_Lut16_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di16_Do16_Lut8_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di16_Do16_Lut16_G128 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\mscmm\membaspr.c ===
/*
	File:		MemBasPr.c

	Contains:	
		creation of mem based profiles

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1996 by Linotype-Hell AG, all rights reserved.

	Version:	
*/

#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include <winbase.h>
#include <windowsX.h>
#include "ICM.h"

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef MSNewMemProfile_h
#include "MemProf.h"
#endif

#ifdef _DEBUG
//#define WRITE_PROFILE
#endif

#ifdef WRITE_PROFILE
	void WriteProf( LPSTR name, icProfile *theProf, long currentSize );
#endif

#define MyTagCount 5
#define LINK_BUFFER_MAX 3000

CMError DeviceLinkFill( CMWorldRef cw, CMConcatProfileSet *profileSet, icProfile **theProf,
		unsigned long aIntent )
{
	CMError			err = unimpErr;
	OSErr			aOSerr = unimpErr;
#ifdef __MWERKS__
        unsigned char			theText[] = "\pDeviceLink profile  ";
#else
      char			theText[] = "\026DeviceLink profile   ";
#endif
      char	copyrightText[] = "\0371996 by Linotype-Hell  U.J.K.";
	icProfile 		*aProf=0;
	long 			theTagTabSize;
	long 			theHeaderSize;
	long 			theDescSize;
	long 			theMediaSize;
	long 			theSequenceDescSize;
	long 			theA2B0Size;
	long 			theCopyRightSize;
	long 			currentSize=0;
	long 			theTotalSize=0;
	icTag			aTag;
	UINT32			sCS,dCS,clutSize;
	Ptr				aPtr=0;

	MyDoubleXYZ D50XYZ = { 0.9642, 1.0000, 0.8249 };
	icXYZNumber D50 = { (unsigned long)(D50XYZ.X * 65536), (unsigned long)(D50XYZ.Y * 65536), (unsigned long)(D50XYZ.Z * 65536)};
	theHeaderSize = sizeof(icHeader);
	theDescSize   = 									  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ sizeof(unsigned long) 	/* ASCII length */
														+ theText[0]				/* ASCII profile description */
														+ sizeof(unsigned long)		/* Unicode code */
														+ sizeof(unsigned long)		/* Unicode character count */
														+ sizeof(unsigned short)	/* Macintosh script code */
														+ sizeof(unsigned char)		/* Macintosh string length */
														+ 67						/* Macintosh string */
														;
	theCopyRightSize   = 								  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ copyrightText[0]			/* ASCII profile description */
														;
	theMediaSize = sizeof( icXYZType );;

	theTagTabSize = MyTagCount * sizeof( icTag ) + sizeof( unsigned long );
	
	*theProf = 0;
	
	if( ((CMMModelPtr)cw)->hasNamedColorProf != NoNamedColorProfile ){
		err = cmProfileError;
		goto CleanupAndExit;
	}
	err = MyGetColorSpaces( profileSet, &sCS, &dCS );
	if (err)
		goto CleanupAndExit;
		
	aProf = (icProfile *)SmartNewPtrClear( LINK_BUFFER_MAX, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;

	err = MyAdd_NL_Header(theTotalSize, (icHeader*)((Ptr)aProf+currentSize), aIntent, icSigLinkClass, sCS, dCS );
	if (err)
		goto CleanupAndExit;
		
	/*----------------------------------------------------------------------------------------- cmProfileDescriptionTag */
	currentSize = theHeaderSize + theTagTabSize;
	CMHelperICC2int32Const(&(aProf->tagList.count ), MyTagCount);

	CMHelperICC2int32Const(&(aTag.sig ), icSigProfileDescriptionTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize);
	CMHelperICC2int32Const(&(aTag.size ), theDescSize);
	aProf->tagList.tags[0] = aTag;
	err =MyAdd_NL_DescriptionTag	( (CMTextDescriptionType *)((Ptr)aProf+currentSize), (unsigned char *)theText );
	if (err)
		goto CleanupAndExit;  
	currentSize += theDescSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

	CMHelperICC2int32Const(&(aTag.sig ), icSigMediaWhitePointTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theMediaSize);
	aProf->tagList.tags[1] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &D50);
	currentSize += theMediaSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

	CMHelperICC2int32Const(&(aTag.sig ), icSigCopyrightTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theCopyRightSize);
	aProf->tagList.tags[2] = aTag;
	err = MyAdd_NL_CopyrightTag( (unsigned char *)copyrightText, (CMTextType *)((Ptr)aProf+currentSize));
	if (err)
		goto CleanupAndExit;
	currentSize += theCopyRightSize;
	currentSize = ( currentSize + 3 ) & ~ 3;
		
	err = MyAdd_NL_SequenceDescTag( profileSet, (icProfileSequenceDescType *)((Ptr)aProf+currentSize), &theSequenceDescSize );
	CMHelperICC2int32Const(&(aTag.sig ), icSigProfileSequenceDescTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theSequenceDescSize);
	aProf->tagList.tags[3] = aTag;
	currentSize += theSequenceDescSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

    theA2B0Size = GetSizes( (CMMModelPtr)cw, &clutSize );

	CMHelperICC2int32Const(&(aTag.sig ), icSigAToB0Tag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theA2B0Size);
	aProf->tagList.tags[4] = aTag;

	/* aPtr =  SmartNewPtr( theA2B0Size+currentSize, &aOSerr );
	err = aOSerr;
	if( err ){
		goto CleanupAndExit;
	}*/
	aPtr = GlobalAllocPtr( GHND, theA2B0Size+currentSize );

	if( aPtr == 0 ){
		err = GetLastError();
		goto CleanupAndExit;
	}

	if ( ((CMMModelPtr)cw)->lutParam.colorLutWordSize == 8 )
        err = MyAdd_NL_AToB0Tag_mft1( (CMMModelPtr)cw, (icLut8Type *)(aPtr+currentSize), clutSize );
    else
        err = MyAdd_NL_AToB0Tag_mft2( (CMMModelPtr)cw, (icLut16Type *)(aPtr+currentSize), clutSize );

	if (err)
		goto CleanupAndExit;

	BlockMove( (Ptr)aProf, aPtr, currentSize );
	aProf = (icProfile *)DisposeIfPtr( (Ptr)aProf );

	CMHelperICC2int32Const( aPtr, theA2B0Size+currentSize );

	*theProf = (icProfile *)aPtr;
#ifdef WRITE_PROFILE
	WriteProf( "DeviceLinkFill.pf", (icProfile *)aPtr, theA2B0Size+currentSize );
#endif
	return noErr;
	
CleanupAndExit:
	*theProf = (icProfile *)DisposeIfPtr( (Ptr)aProf );
	if( aPtr )GlobalFreePtr( aPtr );
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\defines.h ===
/*
	File:		LHDefines.h

	Contains:	defines for the CMM

	Written by:	Werner Neubrand

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHDefines_h
#define LHDefines_h

#ifndef LUTS_ARE_PTR_BASED
#define LUTS_ARE_PTR_BASED 0
#else
#define LUTS_ARE_PTR_BASED 1
#endif

/* made a few changes to get it to compile with MrC and SC. */
#if LUTS_ARE_PTR_BASED
	#define LUT_DATA_TYPE		void*
	#define CUBE_DATA_TYPE		void*
	#define DATA_2_PTR
	#define GETDATASIZE(x)		GetPtrSize(x)
	#define SETDATASIZE(x,y)	SetPtrSize(x,y)
	#define LOCK_DATA(x)
	#define UNLOCK_DATA(x)
	#define ALLOC_DATA(x,y)		SmartNewPtr(x,y)
	#define DISPOSE_DATA(x)		DisposePtr((Ptr)(x))
	#define DISPOSE_IF_DATA(x)	DisposeIfPtr((Ptr)(x))
#else
	#define LUT_DATA_TYPE		void**
	#define CUBE_DATA_TYPE		void**
	#define DATA_2_PTR *
	#define GETDATASIZE(x)		GetHandleSize((Handle)(x))
	#define SETDATASIZE(x,y)	SetHandleSize((Handle)(x),(y))
	#define LOCK_DATA(x)		HLock((Handle)(x))
	#define UNLOCK_DATA(x)		HUnlock((Handle)(x))
	#define ALLOC_DATA(x,y)		(void **)SmartNewHandle(x,y)
	#define DISPOSE_DATA(x)		(void **)DisposeHandle((Handle)(x))
	#define DISPOSE_IF_DATA(x)	(void **)DisposeIfHandle((Handle)(x))
#endif


#define		kDoDefaultLut	0
#define		kDoGamutLut		1

#define		kNoInfo			0
#define		kDoXYZ2Lab		1
#define		kDoLab2XYZ		2

#define		kNumOfRGBchannels 3
#define		kNumOfLab_XYZchannels 3

/*							these constants are the defaults for Do3D and hardware			*/
/*- BYTE ---------------------------------------------------------------------------------- */
#define     adr_bereich_elut       256	/* ElutAdrSize   |  Elut pixeloriented 256 entries 10 bit each dim.	*/
#define     adr_breite_elut          8	/* ElutAdrShift  |  2^8 = 256										*/
#define     bit_breite_elut         10  /* ElutWordSize														*/


#define     adr_bereich_alut      1024	/* AlutAdrSize   |  Alut pixeloriented 1024 entries 8 bit each dim.	*/
#define     adr_breite_alut         10	/* AlutAdrShift  |  2^10 = 1024										*/
#define     bit_breite_alut          8
		
/* constants for the profheader-flags *
#define		kQualityMask		0x00030000
#define		kLookupOnlyMask		0x00040000
#define		kCreateGamutLutMask	0x00080000
#define		kUseRelColorimetric	0x00100000*/
							
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\calcndim.h ===
/*
	File:		LHCalcNDim.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCalcNDim_h
#define LHCalcNDim_h
/*--------------------------------------------------------------------------------------------------------------
	DoNDim prototypes
  --------------------------------------------------------------------------------------------------------------*/
CMError	CalcNDim_Data8To8_Lut8		( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data8To16_Lut8		( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data16To8_Lut8		( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );
									  
CMError	CalcNDim_Data16To16_Lut8	( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );
									  
CMError	CalcNDim_Data8To8_Lut16		( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data8To16_Lut16	( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data16To8_Lut16	( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data16To16_Lut16	( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\dondim.h ===
/*
	File:		LHDoNDim.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHDoNDim_h
#define LHDoNDim_h

#if powerc
#pragma options align=mac68k
#endif

/* typedef double Matrix2D[3][3]; 	*/
typedef struct{ 	
                long 		aElutAdrSize;					/* Count of Adresses of Elut ( for one Dimension )*/
                long 		aElutAdrShift;					/* Count of used bits ( MUST BE = 2^ aElutAdrSize )*/
                long 		aElutWordSize;					/* Count of bits of each entry ( e.g. 10 for partly used UINT16 )*/
                Boolean 	separateEluts;					/* 0= same Elut for all Dimensions; 1= separate Eluts*/
                UINT16 		*ein_lut;						/* Pointer to Elut*/
                long 		aAlutAdrSize;					/* Count of Adresses of Alut ( for one Dimension )		*/
                long		aAlutAdrShift;					/* Count of used bits ( MUST BE = 2^ aAlutAdrSize )*/
                long 		aAlutWordSize;					/* Count of bits of each entry ( e.g. 16 for fully used UINT16 )*/
                Boolean 	separateAluts;					/* 0= same Alut for all Dimensions; 1= separate Aluts*/
                UINT8 		*aus_lut;						/* Pointer to Alut*/
                Matrix2D	*theMatrix;						/* Pointer to Matrix*/
                long 		aPointCount;					/* Count of input pixels*/
                long 		gridPoints;						/* gridpoints*/
                long 		aBufferByteCount;				/* BufferByteCount*/
                UINT8		*theArr;						/* Input/Output array*/
}DoMatrixForCubeStruct,*DoMatrixForCubeStructPtr;

#if powerc
#pragma options align=reset
#endif
/*					DoMatrixForCube*/
/*	works with planeinterleaved Elut, Alut*/
/*	but with pixelinterleaved data ( BYTES/WORDs).*/
/*	Elut, Alut must have 2^n UINT16 entries. */
/*	Matrix is 3*3 double.*/
#ifdef __cplusplus
extern "C" {
#endif
void DoMatrixForCube16( DoMatrixForCubeStructPtr aStructPtr );
void DoOnlyMatrixForCube16( Matrix2D	*theMatrix, Ptr aXlut, long aPointCount, long gridPointsCube );
void DoOnlyMatrixForCube( Matrix2D	*theMatrix, Ptr aXlut, long aPointCount, long gridPointsCube );

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\mscmm\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSLinoCMM.rc
//
#define VER_DEBUG                       0

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\mscmm\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

!ENDIF

MAJORCOMP=windows
MINORCOMP=mscmm

!ifndef ICMROOT
ICMROOT=$(NTGDI_PATH)\icm
!endif

!include $(ICMROOT)\icmsrc.inc

TARGETNAME=icm32
TARGETTYPE=DYNLINK
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)
TARGETLIBS=$(ICMROOT)\mscms\winnt\$(O)\mscms.lib        \
           $(SDK_LIB_PATH)\kernel32.lib                 \
           $(ICMROOT)\mscmm\lh_open\$(O)\lh_open.lib    \
           $(ICMROOT)\mscmm\lh_core\$(O)\lh_core.lib

DLLBASE=@$(COFFBASE_TXT_FILE),icm32

C_DEFINES=$(C_DEFINES) -DWIN32 -D__MSDOS__ -DIntelMode -DRenderInt -DMS_Icm

USE_MSVCRT=1
DLLENTRY=DllMain

INCLUDES=..\.;..\..\lh_core;..\..\lh_open

SOURCES= ..\icm32.rc    \
         ..\icm32.c     \
         ..\access.c    \
         ..\memprof.c

DLLDEF=..\$(TARGETNAME).def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\calcndim.c ===
/*
	File:		LHCalcNDim_Lut16.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHCalcEngine_h
#include "CalcEng.h"
#endif

#ifndef LHCalcNDim_h
#include "CalcNDim.h"
#endif

#define UNROLL_NDIM 1
#if UNROLL_NDIM

CMError Calc323Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc324Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc423Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc424Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
#endif
#define SHRINK_FACTOR 13
/*
#define FARBR_FILES 1
#define FARBR_DEBUG 1
#define FARBR_DEBUG0 1
*/
#if FARBR_FILES
#include "stdio.h"
#include "string.h"
void WriteLuts(	char *theName,long WordSize,long aElutAdrSize,long aElutWordSize,LH_UINT16 *Elut,
				long aXlutInDim,long aXlutOutDim,long aXlutAdrSize,long aXlutWordSize,LH_UINT16 *Xlut,
				long aAlutAdrSize,long aAlutWordSize,LH_UINT16 *aus_lut);
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCalcNDim_Lut16ID
#else
#define DebugPrint(x)
#endif

#define CLIPPWord(x,a,b) ((x)<(a)?(LH_UINT16)(a):((x)>(b)?(LH_UINT16)(b):(LH_UINT16)(x+.5)))
#define CLIPP(x,a,b) ((x)<(a)?(a):((x)>(b)?(b):(x)))
/*
	 DoNDim
  */
CMError CalcNDim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 InputIncrement, OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register unsigned long nDim;
    register long aElutShift,aAlutShift,aElutOffset,aAlutOffset;
    register unsigned long aElutAdrSize;
    register long aElutAdrShift;
    register long aElutWordSize;
    register long aAlutAdrSize;
    register long aAlutAdrShift;
    register long aAlutWordSize;
    register unsigned long aXlutInDim;
    register unsigned long aXlutOutDim;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
    register long aInputPackMode8Bit;
    register long aOutputPackMode8Bit;
    register long aElutShiftNum;
	register unsigned long ii,jj;
	long ein_Cache[8];
	
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	Boolean aCopyAlpha;
   
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("CalcNDim_Data8To8_Lut16")

#if UNROLL_NDIM
	if( lutParam->colorLutInDim == 3 &&
		calcParam->cmInputPixelOffset == 6 ){
		if(	lutParam->colorLutOutDim == 3 &&
			(	calcParam->cmOutputPixelOffset == 3 ||
				calcParam->cmOutputPixelOffset == 6)){
			return Calc323Dim_Data8To8_Lut16( calcParam, lutParam );
		}
		if(	lutParam->colorLutOutDim == 4 &&
			(	calcParam->cmOutputPixelOffset == 4 ||
				calcParam->cmOutputPixelOffset == 8) ){
			return Calc324Dim_Data8To8_Lut16( calcParam, lutParam );
		}
	}
	if( lutParam->colorLutInDim == 4 &&
		calcParam->cmInputPixelOffset == 8 ){
		if(	lutParam->colorLutOutDim == 3 &&
			(	calcParam->cmOutputPixelOffset == 3 ||
				calcParam->cmOutputPixelOffset == 6) ){
			return Calc423Dim_Data8To8_Lut16( calcParam, lutParam );
		}
		if(	lutParam->colorLutOutDim == 4 &&
			(	calcParam->cmOutputPixelOffset == 4 ||
				calcParam->cmOutputPixelOffset == 8) ){
			return Calc424Dim_Data8To8_Lut16( calcParam, lutParam );
		}
	}
#endif
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
	inputData[4] = (LH_UINT8 *)calcParam->inputData[4];
	inputData[5] = (LH_UINT8 *)calcParam->inputData[5];
	inputData[6] = (LH_UINT8 *)calcParam->inputData[6];
	inputData[7] = (LH_UINT8 *)calcParam->inputData[7];

	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
	outputData[4] = (LH_UINT8 *)calcParam->outputData[4];
	outputData[5] = (LH_UINT8 *)calcParam->outputData[5];
	outputData[6] = (LH_UINT8 *)calcParam->outputData[6];
	outputData[7] = (LH_UINT8 *)calcParam->outputData[7];
	InputIncrement = calcParam->cmInputPixelOffset;
	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + InputIncrement;
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutAdrSize = lutParam->inputLutEntryCount;
	for ( i = 1; (i < 32) && (aElutAdrSize >> i); i++)
		aElutAdrShift = i;
	aElutWordSize = lutParam->inputLutWordSize;
	aAlutAdrSize = lutParam->outputLutEntryCount;
	for ( i = 1; (i < 32) && (aAlutAdrSize >> i); i++)
		aAlutAdrShift = i;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutInDim = lutParam->colorLutInDim;
	aXlutOutDim = lutParam->colorLutOutDim;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

	aInputPackMode8Bit = calcParam->cmInputColorSpace & cm8PerChannelPacking || calcParam->cmInputColorSpace & cmLong8ColorPacking;
	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
	
    /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,aElutAdrSize,aElutWordSize,ein_lut,
				aXlutInDim,aXlutOutDim,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,aAlutAdrSize,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
			
	
	if( calcParam->copyAlpha )aCopyAlpha = 1;
	else aCopyAlpha = 0;
	if( aXlutInDim > 7 || aXlutOutDim > 7 )aCopyAlpha = 0;
	if( aInputPackMode8Bit != aOutputPackMode8Bit )aCopyAlpha = 0;
	
	nDim=aXlutInDim;
	
	if( aInputPackMode8Bit ){
		aElutShift = aElutAdrShift-8;
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	else{
		aElutShift = 16-aElutAdrShift;
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						aElutAdrSize,aElutAdrShift,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						aAlutAdrSize,aAlutAdrShift,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						aXlutInDim,aXlutOutDim,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
			DebugPrint("aInputPackMode8Bit=%lx,aOutputPackMode8Bit=%lx\n",
						aInputPackMode8Bit,aOutputPackMode8Bit );
		}
    #endif
    aElutShiftNum = 1<<aElutShift;
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
#if FARBR_DEBUG
    register long aXlutPlaneOffset;
#endif
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =aXlutOutDim;
    for( i=0; i<(long)nDim; i++){
        theXlutOffsets[ nDim-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(aAlutAdrSize/2))/aAlutAdrSize = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			if( aInputPackMode8Bit ){
				for( ii=0; ii<nDim; ii++){ 
			        ein_Cache[ii]=jj=ein_lut[((*inputData[ii])<<aElutShift)+aElutOffset];
			        jj *= aXlutAdrSize;
			        aElutOffset += aElutAdrSize;
		        	adr[ii] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[ii];
		        	ein_reg[ii] = (LH_UINT16)jj;
				}
			}
			else{
				for( ii=0; ii<nDim; ii++){ 
			        ein_Cache[ii]=jj=(*(LH_UINT16 *)inputData[ii]);
					ko0 = jj - ( jj >> ( aElutAdrShift ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += aElutAdrSize;
		        	adr[ii] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[ii];
		        	ein_reg[ii] = (LH_UINT16)jj;
				}
			}
	
       	#if FARBR_DEBUG
		aXlutPlaneOffset = nDim;
        DebugPrint("i=%ld o=%ld\n",i,o);
        if( aInputPackMode < k3ShortsUnpacked ){ DebugPrint("ein_arr=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",ein_arr[i+ii]); DebugPrint("\n");}
        else{ DebugPrint("ein_arr=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",aEinArr[i+ii]); DebugPrint("\n");}
        DebugPrint("ein_reg=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",ein_reg[ii]/aXlutAdrSize); DebugPrint("\n");
	    DebugPrint("adr=(d)");for( ii=0; ii<nDim; ++ii) DebugPrint("%ld ",adr[ii] ); DebugPrint("\n");
        #endif

       	{								/* a kind of*/
			register unsigned long Top, Gap;
			register long Hold,Switches;
			
			Gap = nDim;
			
			for( ii=0; ii<nDim; ++ii){
				Index[ii] = ii;
			}
			do{
				/*Gap = (Gap * 10 ) / SHRINK_FACTOR;*/
				Gap = (Gap * ((10*16)/SHRINK_FACTOR) ) >>4;
				if( Gap == 0 ) Gap = 1;
				Switches = 0;
				Top = nDim - Gap;
				for( ii=0; ii<Top; ++ii){
					jj = ii + Gap;
					if( adr[Index[ii]] < adr[Index[jj]] ){
						Hold = Index[ii];
						Index[ii] = Index[jj];
						Index[jj] = Hold;
						Switches = 1;
					}
				}
			}while( Switches || Gap > 1 );
		}
		#if FARBR_DEBUG
	    DebugPrint("Index=");
	    for( ii=0; ii<nDim; ++ii){
	    	DebugPrint("%3ld ",Index[ii] );
	    }
	    DebugPrint("\n");
        #endif

        for( jj=0; jj<aXlutOutDim; ++jj)accu[jj]=0;

        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
            for( ii=0; ii<nDim; ++ii){
                jj = Index[ii];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                   for( jj=0; jj<aXlutOutDim; ++jj){		    		
#if FARBR_DEBUG
                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj*aXlutPlaneOffset),Xlut[adrAdr+(jj*aXlutPlaneOffset)],ko);
#endif
                    accu[jj]+=Xlut[adrAdr+(jj)]*ko;
                }

                adrAdr = (adr0 + adrOffset);
            }
               for( jj=0; jj<aXlutOutDim; ++jj){		    		
#if FARBR_DEBUG
                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj*aXlutPlaneOffset),Xlut[adrAdr+(jj*aXlutPlaneOffset)],ko0);
#endif
                accu[jj]+=Xlut[adrAdr+jj]*ko0;
            }
        }
        else{

            for( ii=0; ii<nDim; ++ii){
                jj = Index[ii];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                   for( jj=0; jj<aXlutOutDim; ++jj){		    		
#if FARBR_DEBUG
                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj*aXlutPlaneOffset),Xlut[adrAdr+(jj*aXlutPlaneOffset)],ko);
#endif
                    accu[jj]+=((LH_UINT8 *)Xlut)[adrAdr+(jj)]*ko;
                }

                adrAdr = (adr0 + adrOffset);
            }
               for( jj=0; jj<aXlutOutDim; ++jj){		    		
#if FARBR_DEBUG
                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj*aXlutPlaneOffset),Xlut[adrAdr+(jj*aXlutPlaneOffset)],ko0);
#endif
                accu[jj]+=((LH_UINT8 *)Xlut)[adrAdr+jj]*ko0;
                /*ii = accu[jj]+((LH_UINT8 *)Xlut)[adrAdr+jj]*ko0;
                accu[jj] = ii +( ii >> 8 );*/
            }
        }

#if FARBR_DEBUG
        DebugPrint("accu=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",accu[ii] ); DebugPrint("\n");
#endif
		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<aXlutOutDim; ++ii){
	#if FARBR_DEBUG
	                ii = ((accu[ii]) >> aAlutInShift)+aAlutOffset;
	                DebugPrint("adr:((accu[ii]) >> aAlutInShift)+aAlutOffset = %ld\n",ii);
	                DebugPrint("aus_lut[%ld]=%ld aus_lut[%ld]=%ld aus_lut[%ld]=%ld \n",ii-1,aus_lut[ii-1],ii,aus_lut[ii],ii+1,aus_lut[ii+1]);
	#endif
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( aAlutAdrShift ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += aAlutAdrSize;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<aXlutOutDim; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( aAlutAdrShift ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += aAlutAdrSize;
					}
				}
				else{
					for( ii=0; ii<aXlutOutDim; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( aAlutAdrShift ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += aAlutAdrSize;
					}
				}
	        }
	        #if FARBR_DEBUG
		    if( aOutputPackMode8Bit ){DebugPrint("outputData=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",outputData[ii+o] ); DebugPrint("\n");}
		    else{DebugPrint("outputData=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",aAusArr[ii+o] ); DebugPrint("\n");}
			#endif
			if( aCopyAlpha ){
				if( aOutputPackMode8Bit )
					*outputData[aXlutOutDim] = *inputData[aXlutInDim];
				else
					*((LH_UINT16 *)outputData[aXlutOutDim]) = *((LH_UINT16 *)inputData[aXlutInDim]);
			}
			while (--i){
			   	for( jj=0; jj<aXlutInDim; ++jj){
					inputData[jj] += InputIncrement;
				}
			   	for( jj=0; jj<aXlutOutDim; ++jj){
					outputData[jj] += OutputIncrement;
				}
				if( aCopyAlpha ){
					inputData[aXlutInDim] += InputIncrement;
					outputData[aXlutOutDim] += OutputIncrement;
				}
	
				if( aInputPackMode8Bit ){
				   	for( jj=0; jj<aXlutInDim; ++jj){
						if( *inputData[jj] ^ *(LH_UINT8 *)(&ein_Cache[jj]) )break;
					}
				}
				else{
				   	for( jj=0; jj<aXlutInDim; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<aXlutInDim ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<aXlutOutDim; ++jj){
						*outputData[jj] = outputData[jj][-(long)OutputIncrement];
					}
					if( aCopyAlpha ){
						*outputData[aXlutOutDim] = *inputData[aXlutInDim];
					}
				}
				else{
				   	for( jj=0; jj<aXlutOutDim; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)OutputIncrement]);
					}
					if( aCopyAlpha ){
						*((LH_UINT16 *)outputData[aXlutOutDim]) = *((LH_UINT16 *)inputData[aXlutInDim]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<aXlutInDim; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<aXlutOutDim; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
			if( aCopyAlpha ){
				inputData[aXlutInDim] += inputDataRowOffset;
				outputData[aXlutOutDim] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-aAlutAdrShift);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
			if( aInputPackMode8Bit ){
	            for( ii=0; ii<nDim; ii++){ 
	                ein_Cache[ii]=jj=ein_lut[((*inputData[ii])<<aElutShift)+aElutOffset];
	                aElutOffset += aElutAdrSize;
	                adr[ii] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((nDim-ii-1)*bit_breit_adr);
	                ein_reg[ii] = (LH_UINT16)jj;
	            }
	        }
	        else{
	            for( ii=0; ii<nDim; ii++){ 
	                ein_Cache[ii]=jj=(*(LH_UINT16 *)inputData[ii]);
	                ko0 = jj - ( jj >> ( aElutAdrShift ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += aElutAdrSize;
	                adr[ii] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((nDim-ii-1)*bit_breit_adr);
	                ein_reg[ii] = (LH_UINT16)jj;
	            }
	        }
	
	        adr0 *= aXlutOutDim;
	#if FARBR_DEBUG
	        DebugPrint("i=%ld o=%ld\n",i,o);
	        DebugPrint("adr0=%ld\n",adr0);
	        if( aInputPackMode < k3ShortsUnpacked ){ DebugPrint("ein_arr=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",ein_arr[i+ii]); DebugPrint("\n");}
	        else{ DebugPrint("ein_arr=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",aEinArr[i+ii]); DebugPrint("\n");}
	        DebugPrint("ein_reg=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",ein_reg[ii]); DebugPrint("\n");
	        DebugPrint("adr=(d)");for( ii=0; ii<nDim; ++ii) DebugPrint("%ld ",adr[ii] ); DebugPrint("\n");
	#endif
	
	           {								/* a kind of */
	            register unsigned long Top, Gap;
	            register long Hold,Switches;
	            
	            Gap = nDim;
	            
	            for( ii=0; ii<nDim; ++ii){
	                Index[ii] = ii;
	            }
	            do{
	                /*Gap = (Gap * 10 ) / SHRINK_FACTOR;*/
	                Gap = (Gap * ((10*16)/SHRINK_FACTOR) ) >>4;
	                if( Gap == 0 ) Gap = 1;
	                Switches = 0;
	                Top = nDim - Gap;
	                for( ii=0; ii<Top; ++ii){
	                    jj = ii + Gap;
	                    if( adr[Index[ii]] < adr[Index[jj]] ){
	                        Hold = Index[ii];
	                        Index[ii] = Index[jj];
	                        Index[jj] = Hold;
	                        Switches = 1;
	                    }
	                }
	            }while( Switches || Gap > 1 );
	        }
	#if FARBR_DEBUG
	        DebugPrint("Index=");
	        for( ii=0; ii<nDim; ++ii){
	            DebugPrint("%3ld ",Index[ii] );
	        }
	        DebugPrint("\n");
	#endif
	
	           for( jj=0; jj<aXlutOutDim; ++jj)accu[jj]=0;
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	            for( ii=0; ii<nDim; ++ii){
	                jj = Index[ii];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(nDim-1-jj)*bit_breit_adr);
	
	                   for( jj=0; jj<aXlutOutDim; ++jj){		    		
	#if FARBR_DEBUG
	                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj),Xlut[adrAdr+(jj)],ko);
	#endif
	                    accu[jj]+=Xlut[adrAdr+(jj)]*ko;
	                }
	
	                adrAdr = (adr0 + aXlutOutDim*adrOffset);
	            }
	               for( jj=0; jj<aXlutOutDim; ++jj){		    		
	#if FARBR_DEBUG
	                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj),Xlut[adrAdr+(jj)],ko0);
	#endif
	                accu[jj]+=Xlut[adrAdr+(jj)]*ko0;
	            }
	        }
	        else{
	
	            for( ii=0; ii<nDim; ++ii){
	                jj = Index[ii];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(nDim-1-jj)*bit_breit_adr);
	
	                   for( jj=0; jj<aXlutOutDim; ++jj){		    		
	#if FARBR_DEBUG
	                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj),Xlut[adrAdr+(jj)],ko);
	#endif
	                    accu[jj]+=((LH_UINT8 *)Xlut)[adrAdr+(jj)]*ko;
	                }
	
	                adrAdr = (adr0 + aXlutOutDim*adrOffset);
	            }
	               for( jj=0; jj<aXlutOutDim; ++jj){		    		
	#if FARBR_DEBUG
	                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj),Xlut[adrAdr+(jj)],ko0);
	#endif
	                accu[jj]+=((LH_UINT8 *)Xlut)[adrAdr+(jj)]*ko0;
	            }
	        }
	
	#if FARBR_DEBUG
	        DebugPrint("accu=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",accu[ii] ); DebugPrint("\n");
	#endif
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<aXlutOutDim; ++ii){
	#if FARBR_DEBUG
	                ii = ((accu[ii]) >> aAlutInShift)+aAlutOffset;
	                DebugPrint("adr:((accu[ii]) >> aAlutInShift)+aAlutOffset = %ld\n",ii);
	                DebugPrint("aus_lut[%ld]=%ld aus_lut[%ld]=%ld aus_lut[%ld]=%ld \n",ii-1,aus_lut[ii-1],ii,aus_lut[ii],ii+1,aus_lut[ii+1]);
	#endif
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( aAlutAdrShift ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += aAlutAdrSize;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<aXlutOutDim; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( aAlutAdrShift ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += aAlutAdrSize;
					}
				}
				else{
					for( ii=0; ii<aXlutOutDim; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( aAlutAdrShift ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += aAlutAdrSize;
					}
				}
	        }
	
	#if FARBR_DEBUG
	        if( aOutputPackMode < k3ShortsUnpacked ){DebugPrint("aus_arr=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",aus_arr[ii+o] ); DebugPrint("\n");}
	        else{DebugPrint("aus_arr=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",aAusArr[ii+o] ); DebugPrint("\n");}
	#endif
			if( aCopyAlpha ){
				if( aOutputPackMode8Bit )
					*outputData[aXlutOutDim] = *inputData[aXlutInDim];
				else
					*((LH_UINT16 *)outputData[aXlutOutDim]) = *((LH_UINT16 *)inputData[aXlutInDim]);
			}
			while (--i){
			   	for( jj=0; jj<aXlutInDim; ++jj){
					inputData[jj] += InputIncrement;
				}
			   	for( jj=0; jj<aXlutOutDim; ++jj){
					outputData[jj] += OutputIncrement;
				}
				if( aCopyAlpha ){
					inputData[aXlutInDim] += InputIncrement;
					outputData[aXlutOutDim] += OutputIncrement;
				}
	
				if( aInputPackMode8Bit ){
				   	for( jj=0; jj<aXlutInDim; ++jj){
						if( *inputData[jj] ^ *(LH_UINT8 *)(&ein_Cache[jj]) )break;
					}
				}
				else{
				   	for( jj=0; jj<aXlutInDim; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<aXlutInDim ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<aXlutOutDim; ++jj){
						*outputData[jj] = outputData[jj][-(long)OutputIncrement];
					}
					if( aCopyAlpha ){
						*outputData[aXlutOutDim] = *inputData[aXlutInDim];
					}
				}
				else{
				   	for( jj=0; jj<aXlutOutDim; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)OutputIncrement]);
					}
					if( aCopyAlpha ){
						*((LH_UINT16 *)outputData[aXlutOutDim]) = *((LH_UINT16 *)inputData[aXlutInDim]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<aXlutInDim; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<aXlutOutDim; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
			if( aCopyAlpha ){
				inputData[aXlutInDim] += inputDataRowOffset;
				outputData[aXlutOutDim] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("CalcNDim_Data8To8_Lut16")
	return noErr;
}


/*
   CalcNDim_Data8To16_Lut16
  */
CMError CalcNDim_Data8To16_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data8To8_Lut16
  */
CMError CalcNDim_Data16To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data16To16_Lut16
  */
CMError CalcNDim_Data16To16_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data8To16_Lut16
  */
CMError CalcNDim_Data8To8_Lut8 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data8To8_Lut16
  */
CMError CalcNDim_Data16To8_Lut8 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data16To16_Lut16
  */
CMError CalcNDim_Data8To16_Lut8 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data8To16_Lut16
  */
CMError CalcNDim_Data16To16_Lut8 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\calceng.h ===
/*
	File:		LHCalcEngine.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCalcEngine_h
#define LHCalcEngine_h

#ifndef LHTypeDefs_h
#include "TypeDefs.h"
#endif

typedef unsigned char  LH_UINT8;
typedef unsigned short LH_UINT16;
typedef unsigned long  LH_UINT32;
#undef  LH_CALC_ENGINE_UNDEF_MODE
#undef  LH_CALC_ENGINE_P_TO_P
#undef  LH_CALC_ENGINE_P_TO_U			
#undef  LH_CALC_ENGINE_U_TO_P
#undef  LH_CALC_ENGINE_U_TO_U		
#define LH_CALC_ENGINE_UNDEF_MODE           0
#define LH_CALC_ENGINE_P_TO_P               1
#define LH_CALC_ENGINE_P_TO_U		        2				
#define LH_CALC_ENGINE_U_TO_P			    3
#define LH_CALC_ENGINE_U_TO_U			    4				

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to3_Di8_Do8_Lut8_G32 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do16_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do16_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to3_Di8_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di8_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di16_Do16_Lut8_G16		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc3to3_Di8_Do8_Lut16_G32 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do16_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do16_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to3_Di8_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di8_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di16_Do16_Lut16_G16		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to4_Di8_Do8_Lut8_G32 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do16_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do16_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to4_Di8_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di8_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di16_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc3to4_Di8_Do8_Lut16_G32 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do16_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do16_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to4_Di8_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di8_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di16_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to3_Di8_Do8_Lut8_G8 			( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut8_G8			( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do16_Lut8_G8			( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do16_Lut8_G8		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc4to3_Di8_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di8_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di16_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc4to3_Di8_Do8_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut16_G8		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do16_Lut16_G8		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do16_Lut16_G8		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc4to3_Di8_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di8_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di16_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to4_Di8_Do8_Lut8_G8 			( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut8_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut8_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut8_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

CMError	LHCalc4to4_Di8_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
								 
								 
CMError	LHCalc4to4_Di8_Do8_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

CMError	LHCalc4to4_Di8_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to3_Di8_Do8_Lut8_G32_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut8_G32_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do16_Lut8_G32_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do16_Lut8_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to3_Di8_Do8_Lut8_G16_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di8_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di16_Do16_Lut8_G16_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc3to3_Di8_Do8_Lut16_G32_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do16_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do16_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to3_Di8_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di8_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di16_Do16_Lut16_G16_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to4_Di8_Do8_Lut8_G32_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut8_G32_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do16_Lut8_G32_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do16_Lut8_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to4_Di8_Do8_Lut8_G16_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di8_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di16_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc3to4_Di8_Do8_Lut16_G32_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do16_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do16_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to4_Di8_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di8_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di16_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to3_Di8_Do8_Lut8_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut8_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do16_Lut8_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do16_Lut8_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc4to3_Di8_Do8_Lut8_G16_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di8_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di16_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc4to3_Di8_Do8_Lut16_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut16_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do16_Lut16_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do16_Lut16_G8_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc4to3_Di8_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di8_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di16_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to4_Di8_Do8_Lut8_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut8_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut8_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut8_G8_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

CMError	LHCalc4to4_Di8_Do8_Lut8_G16_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
								 
								 
CMError	LHCalc4to4_Di8_Do8_Lut16_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut16_G8_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut16_G8_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut16_G8_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

CMError	LHCalc4to4_Di8_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

/*--------------------------------------------------------------------------------------------------------------
	calc routines for non in place matching
  --------------------------------------------------------------------------------------------------------------*/
#if LH_CALC_USE_ADDITIONAL_OLD_CODE
CMError	LHCalc3to3_Di8_Do8_Lut8_G16_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do8_Lut8_G32_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do8_Lut8_G16_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do8_Lut8_G32_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
#endif							 
#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM
CMError	LHCalc4to3_Di8_Do8_Lut8_G8_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do8_Lut8_G16_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di8_Do8_Lut8_G8_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di8_Do8_Lut8_G16_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
#endif							 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\calcnd3.c ===
/*
	File:		LHCalcND3_Lut16.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHCalcEngine_h
#include "CalcEng.h"
#endif

#ifndef LHCalcNDim_h
#include "CalcNDim.h"
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCalcNDim_Lut16ID
#else
#define DebugPrint(x)
#endif

#define CLIPPWord(x,a,b) ((x)<(a)?(LH_UINT16)(a):((x)>(b)?(LH_UINT16)(b):(LH_UINT16)(x+.5)))
#define CLIPP(x,a,b) ((x)<(a)?(a):((x)>(b)?(b):(x)))

#define UNROLL_NDIM 1
#if UNROLL_NDIM
#define NDIM_IN_DIM 3
#define NDIM_OUT_DIM 3
#define aElutShift (16-adr_breite_elut)
#define aElutShiftNum (1<<aElutShift)

CMError Calc323Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register long aAlutShift,aElutOffset,aAlutOffset;
    register long aElutWordSize;
    register long aAlutWordSize;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
	register unsigned long ii,jj;
    register long aOutputPackMode8Bit;
	long ein_Cache[8];
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("Calc323Dim_Data8To8_Lut16")
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
#if NDIM_IN_DIM == 4
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
#endif
	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
#if NDIM_OUT_DIM == 4
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
#endif

	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + (NDIM_IN_DIM * 2);
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutWordSize = lutParam->inputLutWordSize;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

 	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
   /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,adr_bereich_elut,aElutWordSize,ein_lut,
				NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,adr_bereich_alut,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
					
	{
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						adr_bereich_elut,adr_breite_elut,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						adr_bereich_alut,adr_breite_alut,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
		}
    #endif
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =NDIM_OUT_DIM;
    for( i=0; i<(long)NDIM_IN_DIM; i++){
        theXlutOffsets[ NDIM_IN_DIM-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(adr_bereich_alut/2))/adr_bereich_alut = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			
			        ein_Cache[0]=jj=(*(LH_UINT16 *)inputData[0]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[0] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[0];
		        	ein_reg[0] = (LH_UINT16)jj;

			        ein_Cache[1]=jj=(*(LH_UINT16 *)inputData[1]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[1] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[1];
		        	ein_reg[1] = (LH_UINT16)jj;

					ein_Cache[2]=jj=(*(LH_UINT16 *)inputData[2]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[2] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[2];
		        	ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
					ein_Cache[3]=jj=(*(LH_UINT16 *)inputData[3]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[3] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[3];
		        	ein_reg[3] = (LH_UINT16)jj;
#endif
		
	

	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }

        accu[0]=0;
        accu[1]=0;
        accu[2]=0;
#if NDIM_OUT_DIM == 4
        accu[3]=0;
#endif
        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);
#endif

                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
 #if NDIM_OUT_DIM == 4
               accu[3]+=Xlut[adrAdr+3]*ko0;
 #endif
       }
       else{

                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);
#endif
                accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
               accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
        }

		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
			}
			else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
			}
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
					for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-adr_breite_alut);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
	                ein_Cache[0]=jj=(*(LH_UINT16 *)inputData[0]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[0] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-0-1)*bit_breit_adr);
	                ein_reg[0] = (LH_UINT16)jj;

	                ein_Cache[1]=jj=(*(LH_UINT16 *)inputData[1]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[1] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-1-1)*bit_breit_adr);
	                ein_reg[1] = (LH_UINT16)jj;

	                ein_Cache[2]=jj=(*(LH_UINT16 *)inputData[2]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[2] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-2-1)*bit_breit_adr);
	                ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
	                ein_Cache[3]=jj=(*(LH_UINT16 *)inputData[3]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[3] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-3-1)*bit_breit_adr);
	                ein_reg[3] = (LH_UINT16)jj;
#endif	
	        adr0 *= NDIM_OUT_DIM;
	
	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }
	
			accu[0]=0;
			accu[1]=0;
			accu[2]=0;
#if NDIM_OUT_DIM == 4
			accu[3]=0;
#endif
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=Xlut[adrAdr+3]*ko0;
#endif
	        }
	        else{
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
				accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
	        }
	
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
	        }
	
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
				   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("Calc323Dim_Data8To8_Lut16")
	return noErr;
}

#undef NDIM_IN_DIM
#undef NDIM_OUT_DIM
#undef aElutShift
#undef aElutShiftNum
#define NDIM_IN_DIM 3
#define NDIM_OUT_DIM 4
#define aElutShift (16-adr_breite_elut)
#define aElutShiftNum (1<<aElutShift)

CMError Calc324Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register long aAlutShift,aElutOffset,aAlutOffset;
    register long aElutWordSize;
    register long aAlutWordSize;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
	register unsigned long ii,jj;
    register long aOutputPackMode8Bit;
	long ein_Cache[8];
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("Calc324Dim_Data8To8_Lut16")
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
#if NDIM_IN_DIM == 4
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
#endif
	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
#if NDIM_OUT_DIM == 4
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
#endif

	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + (NDIM_IN_DIM * 2);
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutWordSize = lutParam->inputLutWordSize;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

 	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
   /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,adr_bereich_elut,aElutWordSize,ein_lut,
				NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,adr_bereich_alut,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
					
	{
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						adr_bereich_elut,adr_breite_elut,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						adr_bereich_alut,adr_breite_alut,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
		}
    #endif
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =NDIM_OUT_DIM;
    for( i=0; i<(long)NDIM_IN_DIM; i++){
        theXlutOffsets[ NDIM_IN_DIM-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(adr_bereich_alut/2))/adr_bereich_alut = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			
			        ein_Cache[0]=jj=(*(LH_UINT16 *)inputData[0]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[0] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[0];
		        	ein_reg[0] = (LH_UINT16)jj;

			        ein_Cache[1]=jj=(*(LH_UINT16 *)inputData[1]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[1] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[1];
		        	ein_reg[1] = (LH_UINT16)jj;

					ein_Cache[2]=jj=(*(LH_UINT16 *)inputData[2]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[2] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[2];
		        	ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
					ein_Cache[3]=jj=(*(LH_UINT16 *)inputData[3]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[3] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[3];
		        	ein_reg[3] = (LH_UINT16)jj;
#endif
		
	

	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }

        accu[0]=0;
        accu[1]=0;
        accu[2]=0;
#if NDIM_OUT_DIM == 4
        accu[3]=0;
#endif
        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);
#endif

                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
 #if NDIM_OUT_DIM == 4
               accu[3]+=Xlut[adrAdr+3]*ko0;
 #endif
       }
       else{

                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);
#endif
                accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
               accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
        }

		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
			}
			else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
			}
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
					for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-adr_breite_alut);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
	                ein_Cache[0]=jj=(*(LH_UINT16 *)inputData[0]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[0] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-0-1)*bit_breit_adr);
	                ein_reg[0] = (LH_UINT16)jj;

	                ein_Cache[1]=jj=(*(LH_UINT16 *)inputData[1]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[1] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-1-1)*bit_breit_adr);
	                ein_reg[1] = (LH_UINT16)jj;

	                ein_Cache[2]=jj=(*(LH_UINT16 *)inputData[2]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[2] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-2-1)*bit_breit_adr);
	                ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
	                ein_Cache[3]=jj=(*(LH_UINT16 *)inputData[3]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[3] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-3-1)*bit_breit_adr);
	                ein_reg[3] = (LH_UINT16)jj;
#endif	
	        adr0 *= NDIM_OUT_DIM;
	
	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }
	
			accu[0]=0;
			accu[1]=0;
			accu[2]=0;
#if NDIM_OUT_DIM == 4
			accu[3]=0;
#endif
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=Xlut[adrAdr+3]*ko0;
#endif
	        }
	        else{
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
				accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
	        }
	
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
	        }
	
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
				   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("Calc324Dim_Data8To8_Lut16")
	return noErr;
}

#undef NDIM_IN_DIM
#undef NDIM_OUT_DIM
#undef aElutShift
#undef aElutShiftNum
#define NDIM_IN_DIM 4
#define NDIM_OUT_DIM 3
#define aElutShift (16-adr_breite_elut)
#define aElutShiftNum (1<<aElutShift)

CMError Calc423Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register long aAlutShift,aElutOffset,aAlutOffset;
    register long aElutWordSize;
    register long aAlutWordSize;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
	register unsigned long ii,jj;
    register long aOutputPackMode8Bit;
	long ein_Cache[8];
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("Calc423Dim_Data8To8_Lut16")
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
#if NDIM_IN_DIM == 4
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
#endif
	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
#if NDIM_OUT_DIM == 4
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
#endif

	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + (NDIM_IN_DIM * 2);
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutWordSize = lutParam->inputLutWordSize;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

 	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
   /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,adr_bereich_elut,aElutWordSize,ein_lut,
				NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,adr_bereich_alut,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
					
	{
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						adr_bereich_elut,adr_breite_elut,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						adr_bereich_alut,adr_breite_alut,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
		}
    #endif
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =NDIM_OUT_DIM;
    for( i=0; i<(long)NDIM_IN_DIM; i++){
        theXlutOffsets[ NDIM_IN_DIM-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(adr_bereich_alut/2))/adr_bereich_alut = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			
			        ein_Cache[0]=jj=(*(LH_UINT16 *)inputData[0]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[0] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[0];
		        	ein_reg[0] = (LH_UINT16)jj;

			        ein_Cache[1]=jj=(*(LH_UINT16 *)inputData[1]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[1] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[1];
		        	ein_reg[1] = (LH_UINT16)jj;

					ein_Cache[2]=jj=(*(LH_UINT16 *)inputData[2]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[2] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[2];
		        	ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
					ein_Cache[3]=jj=(*(LH_UINT16 *)inputData[3]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[3] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[3];
		        	ein_reg[3] = (LH_UINT16)jj;
#endif
		
	

	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }

        accu[0]=0;
        accu[1]=0;
        accu[2]=0;
#if NDIM_OUT_DIM == 4
        accu[3]=0;
#endif
        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);
#endif

                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
 #if NDIM_OUT_DIM == 4
               accu[3]+=Xlut[adrAdr+3]*ko0;
 #endif
       }
       else{

                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);
#endif
                accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
               accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
        }

		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
			}
			else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
			}
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
					for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-adr_breite_alut);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
	                ein_Cache[0]=jj=(*(LH_UINT16 *)inputData[0]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[0] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-0-1)*bit_breit_adr);
	                ein_reg[0] = (LH_UINT16)jj;

	                ein_Cache[1]=jj=(*(LH_UINT16 *)inputData[1]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[1] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-1-1)*bit_breit_adr);
	                ein_reg[1] = (LH_UINT16)jj;

	                ein_Cache[2]=jj=(*(LH_UINT16 *)inputData[2]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[2] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-2-1)*bit_breit_adr);
	                ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
	                ein_Cache[3]=jj=(*(LH_UINT16 *)inputData[3]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[3] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-3-1)*bit_breit_adr);
	                ein_reg[3] = (LH_UINT16)jj;
#endif	
	        adr0 *= NDIM_OUT_DIM;
	
	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }
	
			accu[0]=0;
			accu[1]=0;
			accu[2]=0;
#if NDIM_OUT_DIM == 4
			accu[3]=0;
#endif
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=Xlut[adrAdr+3]*ko0;
#endif
	        }
	        else{
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
				accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
	        }
	
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
	        }
	
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
				   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("Calc423Dim_Data8To8_Lut16")
	return noErr;
}

#undef NDIM_IN_DIM
#undef NDIM_OUT_DIM
#undef aElutShift
#undef aElutShiftNum
#define NDIM_IN_DIM 4
#define NDIM_OUT_DIM 4
#define aElutShift (16-adr_breite_elut)
#define aElutShiftNum (1<<aElutShift)

CMError Calc424Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register long aAlutShift,aElutOffset,aAlutOffset;
    register long aElutWordSize;
    register long aAlutWordSize;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
	register unsigned long ii,jj;
    register long aOutputPackMode8Bit;
	long ein_Cache[8];
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("Calc424Dim_Data8To8_Lut16")
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
#if NDIM_IN_DIM == 4
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
#endif
	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
#if NDIM_OUT_DIM == 4
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
#endif

	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + (NDIM_IN_DIM * 2);
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutWordSize = lutParam->inputLutWordSize;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

 	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
   /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,adr_bereich_elut,aElutWordSize,ein_lut,
				NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,adr_bereich_alut,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
					
	{
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						adr_bereich_elut,adr_breite_elut,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						adr_bereich_alut,adr_breite_alut,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
		}
    #endif
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =NDIM_OUT_DIM;
    for( i=0; i<(long)NDIM_IN_DIM; i++){
        theXlutOffsets[ NDIM_IN_DIM-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(adr_bereich_alut/2))/adr_bereich_alut = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			
			        ein_Cache[0]=jj=(*(LH_UINT16 *)inputData[0]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[0] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[0];
		        	ein_reg[0] = (LH_UINT16)jj;

			        ein_Cache[1]=jj=(*(LH_UINT16 *)inputData[1]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[1] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[1];
		        	ein_reg[1] = (LH_UINT16)jj;

					ein_Cache[2]=jj=(*(LH_UINT16 *)inputData[2]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[2] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[2];
		        	ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
					ein_Cache[3]=jj=(*(LH_UINT16 *)inputData[3]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[3] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[3];
		        	ein_reg[3] = (LH_UINT16)jj;
#endif
		
	

	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }

        accu[0]=0;
        accu[1]=0;
        accu[2]=0;
#if NDIM_OUT_DIM == 4
        accu[3]=0;
#endif
        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);
#endif

                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
 #if NDIM_OUT_DIM == 4
               accu[3]+=Xlut[adrAdr+3]*ko0;
 #endif
       }
       else{

                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);
#endif
                accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
               accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
        }

		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
			}
			else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
			}
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
					for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-adr_breite_alut);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
	                ein_Cache[0]=jj=(*(LH_UINT16 *)inputData[0]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[0] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-0-1)*bit_breit_adr);
	                ein_reg[0] = (LH_UINT16)jj;

	                ein_Cache[1]=jj=(*(LH_UINT16 *)inputData[1]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[1] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-1-1)*bit_breit_adr);
	                ein_reg[1] = (LH_UINT16)jj;

	                ein_Cache[2]=jj=(*(LH_UINT16 *)inputData[2]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[2] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-2-1)*bit_breit_adr);
	                ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
	                ein_Cache[3]=jj=(*(LH_UINT16 *)inputData[3]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[3] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-3-1)*bit_breit_adr);
	                ein_reg[3] = (LH_UINT16)jj;
#endif	
	        adr0 *= NDIM_OUT_DIM;
	
	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }
	
			accu[0]=0;
			accu[1]=0;
			accu[2]=0;
#if NDIM_OUT_DIM == 4
			accu[3]=0;
#endif
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=Xlut[adrAdr+3]*ko0;
#endif
	        }
	        else{
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
				accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
	        }
	
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
	        }
	
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
				   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ *(LH_UINT16 *)(&ein_Cache[jj]) )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("Calc424Dim_Data8To8_Lut16")
	return noErr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\engine1d.c ===
/*
	File:		Engine1D.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#define smallCode 1

#undef LH_DATA_IN_TYPE
#undef LH_DATA_OUT_TYPE
#undef LH_LUT_DATA_TYPE
#undef LH_DATA_IN_COUNT
#undef LH_DATA_SHR
#undef LH_DATA_SHR_CORR
#undef LH_LUT_DATA_SHR
#undef LH_BIT_BREIT_INTERNAL
#if LH_DATA_IN_SIZE_16
#define LH_DATA_IN_TYPE LH_UINT16
#else
#define LH_DATA_IN_TYPE LH_UINT8
#endif
#if LH_DATA_OUT_SIZE_16
#define LH_DATA_OUT_TYPE LH_UINT16
#else
#define LH_DATA_OUT_TYPE LH_UINT8
#endif
#if LH_LUT_DATA_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#define LH_LUT_DATA_TYPE LH_UINT16
#else
#if LH_DATA_IN_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#else
#define LH_BIT_BREIT_INTERNAL 	10
#endif
#define LH_LUT_DATA_TYPE LH_UINT8
#endif

#if LH_DATA_IN_COUNT_4
#define LH_DATA_IN_COUNT 		4
#else
#define LH_DATA_IN_COUNT 		3
#endif

#define LH_BIT_MASKE_ADR (((1<<7)-1)<< (LH_BIT_BREIT_INTERNAL-7))
#define LH_BIT_BREIT_SELEKTOR (LH_BIT_BREIT_INTERNAL-7)
#define LH_BIT_MASKE_SELEKTOR ((1<<LH_BIT_BREIT_SELEKTOR)-1)

#define LH_ADR_BEREICH_SEL 		(1<<LH_BIT_BREIT_SELEKTOR)

#if LH_LUT_DATA_SIZE_16
#define LH_DATA_SHR               (16+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)  /* z.B. 16+11-10=17 */
#define LH_DATA_SHR_CORR 8		/* notwendig bei LH_DATA_SHR > 16 */
#define LH_LUT_DATA_SHR  16		/* Normierung bei Alutinterpolation */
#else
#define LH_DATA_SHR               (8+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)   /* z.B. 8+7-10=5 */
#define LH_LUT_DATA_SHR  8		/* Normierung bei Alutinterpolation */
#endif

{
	LH_UINT32 ein_regr;
	LH_DATA_IN_TYPE ein_cache;
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;

	LH_UINT8 	Mode;
	LH_UINT8	LH_DATA_OUT_COUNT = (LH_UINT8)lutParam->colorLutOutDim;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}
 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[(ein_cache=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[(ein_cache=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((ein_regr >> LH_BIT_BREIT_SELEKTOR)*LH_DATA_OUT_COUNT);
			ein_regr &= LH_BIT_MASKE_SELEKTOR;

			ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_OUT_SIZE_16
	
			aVal =					 (ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
			*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			if( LH_DATA_OUT_COUNT > 1 ){
			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
			*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
			*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			if( LH_DATA_OUT_COUNT > 3 ){
			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
			*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
			}}
			
			#else
			*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
			if( LH_DATA_OUT_COUNT > 1 ){
			paNewVal0++;
			*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
			paNewVal0++;
			*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
			if( LH_DATA_OUT_COUNT > 3 ){
			paNewVal0++;
			*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
			}}
			#endif
			
			#else
			*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
			if( LH_DATA_OUT_COUNT > 1 ){
			paNewVal0++;
			*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
			paNewVal0++;
			*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
			if( LH_DATA_OUT_COUNT > 3 ){
			paNewVal0++;
			*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
			}}
			#endif

			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			if( LH_DATA_OUT_COUNT > 1 ){
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			if( LH_DATA_OUT_COUNT > 3 ){
			*output3 |= (*output3 << 8);
			}}
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;

					if ((*input0 ^ ein_cache)){
						break;
					}
					*output0 = output0[-outputOffset];
					if( LH_DATA_OUT_COUNT > 1 ){
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT > 3 ){
					*output3 = output3[-outputOffset];
					}}
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				if( LH_DATA_OUT_COUNT == 1 ){
					*output1 &= Mask;
				}else if( LH_DATA_OUT_COUNT == 3 ){
					*output3 &= Mask;
				}else{
					*output4 &= Mask;
				}
				while (--i)
				{
					input0 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					output4 += outputOffset;
					if ((*input0 ^ ein_cache)){
						break;
					}
					*output0 = output0[-outputOffset];
					if( LH_DATA_OUT_COUNT > 1 ){
						*output1 = output1[-outputOffset];
						*output2 = output2[-outputOffset];
						if( LH_DATA_OUT_COUNT > 3 ){
							*output3 = output3[-outputOffset];
							*output4 &= Mask;
						}
						else{
							*output3 &= Mask;
						}
					}
					else{
						*output1 &= Mask;
					}
				}
			}
			else
			{
				if( LH_DATA_OUT_COUNT == 1 ){
					*output1 = (LH_DATA_OUT_TYPE)*input1;
				}else if( LH_DATA_OUT_COUNT == 3 ){
					*output3 = (LH_DATA_OUT_TYPE)*input1;
				}else{
					*output4 = (LH_DATA_OUT_TYPE)*input1;
				}
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					output4 += outputOffset;
					if ((*input0 ^ ein_cache))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					if( LH_DATA_OUT_COUNT > 1 ){
						*output1 = output1[-outputOffset];
						*output2 = output2[-outputOffset];
						if( LH_DATA_OUT_COUNT > 3 ){
							*output3 = output3[-outputOffset];
							*output4 = (LH_DATA_OUT_TYPE)*input1;
						}
						else{
							*output3 = (LH_DATA_OUT_TYPE)*input1;
						}
					}
					else{
						*output1 = (LH_DATA_OUT_TYPE)*input1;
					}
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#undef LH_CALC_PROC_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\dondim.c ===
/*
	File:		LHDoNDim.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHDoNDim_h
#include "DoNDim.h"
#endif

#define SHRINK_FACTOR 13
/*
#define FARBR_FILES 1
#define FARBR_DEBUG 1
#define FARBR_DEBUG0 1
*/
#if FARBR_FILES
#include "stdio.h"
#include "string.h"
void WriteLuts(	char *theName,long WordSize,long aElutAdrSize,long aElutWordSize,UINT16 *Elut,
				long aXlutInDim,long aXlutOutDim,long aXlutAdrSize,long aXlutWordSize,UINT16 *Xlut,
				long aAlutAdrSize,long aAlutWordSize,UINT16 *aus_lut);
#endif

#if UWEs_eigene_Umgebung
#include <stdio.h>
#define DebugPrint printf
#else
#ifdef DEBUG_OUTPUT
#define kThisFile kLHDoNDimID
/*#include "DebugSpecial.h"*/
#else
#define DebugPrint(x)
#endif
#endif

#define CLIPPWord(x,a,b) ((x)<(a)?(UINT16)(a):((x)>(b)?(UINT16)(b):(UINT16)(x+.5)))
#define CLIPP(x,a,b) ((x)<(a)?(a):((x)>(b)?(b):(x)))
/*#if 0*/

/*
  */
#define Round(a) (((a)>0.)?((a)+.5):((a)-.5))

/*
   DoOnlyMatrixForCube
  */
void DoOnlyMatrixForCube( Matrix2D	*theMatrix, Ptr aXlut, long aPointCount, long gridPointsCube )
{
    register long 	ii,jj;
    register long 	i;
    register long 	aLong0;
    register long 	aLong1;
    register long 	aLong2;
    register long 	theEnd;
    register long 	aVal;
    long 			aMatrix[3][3];
    register double aFactor,dVal;
    register UINT16 	accu,aMax;
    register UINT8 *theArr = (UINT8 *)aXlut;
    /*   FILE *aSt; */
 
    
#ifdef DEBUG_OUTPUT
	long err=0;
#endif
	LH_START_PROC("DoOnlyMatrixForCube")
	jj=aPointCount;
	theEnd = 3 * aPointCount;
	/*for( i=1; i<100; ++i)if( i*i*i == jj )break;*/		  /* calculate gridpoints*/
	/*if( i<= 0 || i >= 100 ) return;*/
	i = gridPointsCube;
	aMax = 256 - 1;
	aFactor = 4096.*255./(256.*(i-1)/i);
	for( ii=0; ii<3; ii++){ 
		for( jj=0; jj<3; jj++){ 
			dVal = (*theMatrix)[ii][jj]*aFactor;
			aMatrix[ii][jj] = (long)Round(dVal);
		}
	}
   	#if FARBR_DEBUG
    DebugPrint("theArr=(d)");for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) DebugPrint("%f ",aMatrix[ii][jj]); DebugPrint("\n");
    #endif
    /*
    aSt = fopen("Matrix","a");
    for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) fprintf(aSt,"%f ",(*(aStructPtr->theMatrix))[ii][jj]); fprintf(aSt,"\n");
    for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) fprintf(aSt,"%d ",aMatrix[ii][jj]); fprintf(aSt,"\n");
	fclose(aSt);
	*/
	for (i = 0; i < theEnd; i +=3){		/* Schleife der Points */
	       aLong0=theArr[i+0];
	       aLong1=theArr[i+1];
	       aLong2=theArr[i+2];
		for( ii=0; ii<3; ii++){ 
				aVal = aMatrix[ii][0] * aLong0;
				aVal += aMatrix[ii][1] * aLong1;
				aVal += aMatrix[ii][2] * aLong2;
			if( aVal > 0) aVal = (aVal+2047)>>12;
			else aVal = (aVal-2047)>>12;
			accu = (UINT16)CLIPP(aVal,0,(long)aMax);
        	theArr[i+ii] = (UINT8)accu;
		}
       	#if FARBR_DEBUG
        DebugPrint("i=%ld\n",i);
        DebugPrint("theArr=(d)");for(ii=0; ii<3; ++ii) DebugPrint("%ld ",theArr[i+ii]); DebugPrint("\n");
        DebugPrint("ein_reg=(d)");DebugPrint("%ld ",aLong0);DebugPrint("%ld ",aLong1);DebugPrint("%ld ",aLong2); DebugPrint("\n");
        #endif
	}

	LH_END_PROC("DoOnlyMatrixForCube")
}


#define VAL_MAX 65536
#define VAL_MAXM1 (VAL_MAX-1)

/*
   DoMatrixForCube16
  */
void DoMatrixForCube16( DoMatrixForCubeStructPtr aStructPtr )
{
    register long 	ii,jj;
    register long 	i;
    /*long 		  	aLong[3];*/
    register long 	aLong0;
    register long 	aLong1;
    register long 	aLong2;
    register long 	theEnd;
    register long 	aElutShift,aElutShiftNum,aAlutShift,aElutOffset,aAlutOffset;
    register unsigned long 	aElutAdrSize,separateEluts,separateAluts;
    register long 	aVal;
    long 			aMatrix[3][3];
    register double aFactor,dVal;
    register unsigned long 	aMax;
    register UINT16 *ein_lut;
    register UINT16 *aus_lut;
    register UINT8 *aus_lutByte;
    register unsigned long aAlutAdrSize;
    register UINT16 *theArr;
    register UINT8 *theByteArr;
    register unsigned long ko,ko0;
    register long aElutShiftRight;
    /*   FILE *aSt;*/
 
#ifdef DEBUG_OUTPUT
	long err=0;
#endif
	LH_START_PROC("DoMatrixForCube16")

    /*DebugPrint("DoMatrixForCube16 with %d input pixels\n",aPointCount);*/
	ein_lut = aStructPtr->ein_lut;
	aus_lut = (UINT16 *)aStructPtr->aus_lut;
	aus_lutByte = (UINT8 *)aus_lut;
	theArr = (UINT16 *)aStructPtr->theArr;
	theByteArr = (UINT8 *)theArr;
	aAlutAdrSize = aStructPtr->aAlutAdrSize;
	aElutAdrSize = aStructPtr->aElutAdrSize;
	separateEluts = aStructPtr->separateEluts;
	separateAluts = aStructPtr->separateAluts;
	theEnd =  3*aStructPtr->aPointCount;
	aMax = aAlutAdrSize-1;
	
	for( i=0; i<33; i++) if( (1L<<i) == (long)aElutAdrSize )break;
	if( i > 32 ) return;
	aElutShift = 16-i;
	aElutShiftRight = aStructPtr->aElutWordSize - aElutShift + 0; /* use only 16 bit from elut*/
	if( aElutShiftRight < 0 ) return;
	aElutShiftNum = 1<<aElutShift;
	
	aFactor = 2*8. * aMax /(aStructPtr->gridPoints-1)*(double)aStructPtr->gridPoints;
	for( ii=0; ii<3; ii++){ 
		for( jj=0; jj<3; jj++){ 
			dVal = (*(aStructPtr->theMatrix))[ii][jj]*aFactor;
      		aMatrix[ii][jj] = (long)Round(dVal);
		}
	}
   	#if FARBR_DEBUG
    DebugPrint("theArr=(d)");for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) DebugPrint("%f ",aMatrix[ii][jj]); DebugPrint("\n");
    /*
    aSt = fopen("Matrix","a");
    for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) fprintf(aSt,"%f ",(*(aStructPtr->theMatrix))[ii][jj]); fprintf(aSt,"\n");
    for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) fprintf(aSt,"%d ",aMatrix[ii][jj]); fprintf(aSt,"\n");
	fclose(aSt);
	*/
    #endif
    if( aStructPtr->aBufferByteCount == 2 ){
		aAlutShift = 16-aStructPtr->aAlutWordSize;
		for (i = 0; i < theEnd; i +=3){		/* Schleife der Points */
	
			aElutOffset = 0;
			ko = (theArr[i+0]);
			ko0 = ko - ( ko >> ( 16 - aElutShift ));
			ko = ko0 & ( aElutShiftNum - 1 );
			ko0 = ko0 >> aElutShift;
			if( ko0 >= (aElutAdrSize-1) ){
		        	aLong0 = ein_lut[ ko0 + aElutOffset ]<<(aElutShift-aElutShiftRight);
			}
			else{
				ko0 += aElutOffset;
		       	aLong0 = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 + 1 ] * ko )>>aElutShiftRight;
		    }   
			if( separateEluts )aElutOffset += aElutAdrSize;
			
			ko = (theArr[i+1]);
			ko0 = ko - ( ko >> ( 16 - aElutShift ));
			ko = ko0 & ( aElutShiftNum - 1 );
			ko0 = ko0 >> aElutShift;
			if( ko0 >= (aElutAdrSize-1) ){
		        	aLong1 = ein_lut[ ko0 + aElutOffset ]<<(aElutShift-aElutShiftRight);
			}
			else{
				ko0 += aElutOffset;
		       	aLong1 = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 + 1 ] * ko )>>aElutShiftRight;
		    }   
			if( separateEluts )aElutOffset += aElutAdrSize;
			
			ko = (theArr[i+2]);
			ko0 = ko - ( ko >> ( 16 - aElutShift ));
			ko = ko0 & ( aElutShiftNum - 1 );
			ko0 = ko0 >> aElutShift;
			if( ko0 >= (aElutAdrSize-1) ){
		        	aLong2 = ein_lut[ ko0 + aElutOffset ]<<(aElutShift-aElutShiftRight);
			}
			else{
				ko0 += aElutOffset;
		       	aLong2 = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 + 1 ] * ko )>>aElutShiftRight;
		    }   
				
			aLong0 = ( aLong0 +2 )>>2;	       
			aLong1 = ( aLong1 +2 )>>2;	       
			aLong2 = ( aLong2 +2 )>>2;	       
			aAlutOffset = 0;
			for( ii=0; ii<3; ii++){ 
					aVal = aMatrix[ii][0] * aLong0;
					aVal += aMatrix[ii][1] * aLong1;
					aVal += aMatrix[ii][2] * aLong2;
				aVal = (aVal+((1<<9)-1))>>10;
				if( aVal < 0 ) aVal = 0;
				
		        ko0= ( aVal>> (3+2+3) );
		        if( ko0 >= (aAlutAdrSize-1) ){
		        	theArr[i+ii] = aus_lut[ (aAlutAdrSize-1) + aAlutOffset ] <<aAlutShift;
		        }
		        else{
		        	ko0 += aAlutOffset;
			        ko = ( aVal & ((1<<(3+2+3))-1) );
			        theArr[i+ii] = (UINT16)(( aus_lut[ ko0 ] * ( (1<<(3+2+3)) - ko ) + aus_lut[ ko0 +1 ] * ko)>>((3+2+3)-aAlutShift));
				}
		       	if( separateAluts )aAlutOffset += aAlutAdrSize;
			}
	       	#if FARBR_DEBUG
	        DebugPrint("i=%ld\n",i);
	        DebugPrint("theArr=(d)");for(ii=0; ii<3; ++ii) DebugPrint("%ld ",theArr[i+ii]); DebugPrint("\n");
	        DebugPrint("ein_reg=(d)");DebugPrint("%ld ",aLong0);DebugPrint("%ld ",aLong1);DebugPrint("%ld ",aLong2); DebugPrint("\n");
	        #endif
		}
	}
	else{
		aAlutShift = aStructPtr->aAlutWordSize - 8;
		for (i = 0; i < theEnd; i +=3){		/* Schleife der Points*/
	
	
			aElutOffset = 0;
			ko = (theArr[i+0]);
			ko0 = ko - ( ko >> ( 16 - aElutShift ));
			ko = ko0 & ( aElutShiftNum - 1 );
			ko0 = ko0 >> aElutShift;
			if( ko0 >= (aElutAdrSize-1) ){
		        	aLong0 = ein_lut[ ko0 + aElutOffset ]<<(aElutShift-aElutShiftRight);
			}
			else{
				ko0 += aElutOffset;
		       	aLong0 = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 + 1 ] * ko )>>aElutShiftRight;
		    }   
			if( separateEluts )aElutOffset += aElutAdrSize;
			
			ko = (theArr[i+1]);
			ko0 = ko - ( ko >> ( 16 - aElutShift ));
			ko = ko0 & ( aElutShiftNum - 1 );
			ko0 = ko0 >> aElutShift;
			if( ko0 >= (aElutAdrSize-1) ){
		        	aLong1 = ein_lut[ ko0 + aElutOffset ]<<(aElutShift-aElutShiftRight);
			}
			else{
				ko0 += aElutOffset;
		       	aLong1 = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 + 1 ] * ko )>>aElutShiftRight;
		    }   
			if( separateEluts )aElutOffset += aElutAdrSize;
			
			ko = (theArr[i+2]);
			ko0 = ko - ( ko >> ( 16 - aElutShift ));
			ko = ko0 & ( aElutShiftNum - 1 );
			ko0 = ko0 >> aElutShift;
			if( ko0 >= (aElutAdrSize-1) ){
		        	aLong2 = ein_lut[ ko0 + aElutOffset ]<<(aElutShift-aElutShiftRight);
			}
			else{
				ko0 += aElutOffset;
		       	aLong2 = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 + 1 ] * ko )>>aElutShiftRight;
		    }   
		       
			aLong0 = ( aLong0 +2 )>>2;	       
			aLong1 = ( aLong1 +2 )>>2;	       
			aLong2 = ( aLong2 +2 )>>2;	       
			aAlutOffset = 0;
			if( aStructPtr->aAlutWordSize > 8 ){
				for( ii=0; ii<3; ii++){ 
						aVal = aMatrix[ii][0] * aLong0;
						aVal += aMatrix[ii][1] * aLong1;
						aVal += aMatrix[ii][2] * aLong2;
					aVal = (aVal+((1<<12)-1))>>13;
					if( aVal < 0 ) aVal = 0;
					
			        ko0= (aVal+((1<<(3+2-1))-1)) >> (3+2);
			        if( ko0 >= (aAlutAdrSize-1) ){
			        	theByteArr[i+ii] = aus_lut[ (aAlutAdrSize-1) + aAlutOffset ] >>aAlutShift;
			        }
			        else{
			        	theByteArr[i+ii] = aus_lut[ ko0 + aAlutOffset ] >>aAlutShift;
					}
			       	if( separateAluts )aAlutOffset += aAlutAdrSize;
				}
			}
			else{
				for( ii=0; ii<3; ii++){ 
						aVal = aMatrix[ii][0] * aLong0;
						aVal += aMatrix[ii][1] * aLong1;
						aVal += aMatrix[ii][2] * aLong2;
					aVal = (aVal+((1<<12)-1))>>13;
					if( aVal < 0 ) aVal = 0;
					
			        ko0= (aVal+((1<<(3+2-1))-1)) >> (3+2);
			        if( ko0 >= (aAlutAdrSize-1) ){
			        	theByteArr[i+ii] = aus_lutByte[ (aAlutAdrSize-1) + aAlutOffset ] ;
			        }
			        else{
			        	theByteArr[i+ii] = aus_lutByte[ ko0 + aAlutOffset ] ;
					}
			       	if( separateAluts )aAlutOffset += aAlutAdrSize;
				}
			}
	       	#if FARBR_DEBUG
	        DebugPrint("i=%ld\n",i);
	        DebugPrint("theArr=(d)");for(ii=0; ii<3; ++ii) DebugPrint("%ld ",theArr[i+ii]); DebugPrint("\n");
	        DebugPrint("ein_reg=(d)");DebugPrint("%ld ",aLong0);DebugPrint("%ld ",aLong1);DebugPrint("%ld ",aLong2); DebugPrint("\n");
	        #endif
		}
	}
	LH_END_PROC("DoMatrixForCube16")
}

void DoOnlyMatrixForCube16( Matrix2D	*theMatrix, Ptr aXlut, long aPointCount, long gridPointsCube )
{
    register long 	ii,jj;
    register long 	i;
    register long 	aLong0;
    register long 	aLong1;
    register long 	aLong2;
    register long 	theEnd;
    register long 	aVal;
    long 			aMatrix[3][3];
    register double aFactor,dVal;
    register UINT16 	accu,aMax;
    register UINT16 *theArr = (UINT16 *)aXlut;
    /*   FILE *aSt;*/
 
    
#ifdef DEBUG_OUTPUT
	long err = 0;
#endif
	LH_START_PROC("DoOnlyMatrixForCube16")
	jj=aPointCount;
	theEnd = 3 * aPointCount;
	/*for( i=1; i<100; ++i)if( i*i*i == jj )break; */  /* calculate gridpoints*/
	/*if( i<= 0 || i >= 100 ) return;*/
	i = gridPointsCube;
	aMax = VAL_MAXM1;
	aFactor = 4096.;
	for( ii=0; ii<3; ii++){ 
		for( jj=0; jj<3; jj++){ 
			dVal = (*theMatrix)[ii][jj]*aFactor;
			aMatrix[ii][jj] = (long)Round(dVal);
		}
	}
   	#if FARBR_DEBUG
    DebugPrint("theArr=(d)");for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) DebugPrint("%f ",aMatrix[ii][jj]); DebugPrint("\n");
    #endif
    /*
    aSt = fopen("Matrix","a");
    for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) fprintf(aSt,"%f ",(*(aStructPtr->theMatrix))[ii][jj]); fprintf(aSt,"\n");
    for(ii=0; ii<3; ++ii) for( jj=0; jj<3; jj++) fprintf(aSt,"%d ",aMatrix[ii][jj]); fprintf(aSt,"\n");
	fclose(aSt);
	*/
	for (i = 0; i < theEnd; i +=3){		/* Schleife der Points */
	       aLong0=theArr[i+0];
	       aLong1=theArr[i+1];
	       aLong2=theArr[i+2];
		for( ii=0; ii<3; ii++){ 
				aVal = aMatrix[ii][0] * aLong0;
				aVal += aMatrix[ii][1] * aLong1;
				aVal += aMatrix[ii][2] * aLong2;
			if( aVal > 0) aVal = (aVal+2047)>>12;
			else aVal = (aVal-2047)>>12;
			accu = (UINT16)CLIPP(aVal,0,(long)aMax);
        	theArr[i+ii] = accu;
		}
       	#if FARBR_DEBUG
        DebugPrint("i=%ld\n",i);
        DebugPrint("theArr=(d)");for(ii=0; ii<3; ++ii) DebugPrint("%ld ",theArr[i+ii]); DebugPrint("\n");
        DebugPrint("ein_reg=(d)");DebugPrint("%ld ",aLong0);DebugPrint("%ld ",aLong1);DebugPrint("%ld ",aLong2); DebugPrint("\n");
        #endif
	}
	LH_END_PROC("DoOnlyMatrixForCube16")
}


#if FARBR_FILES
static FileCount = 0;
static FILE *stream1;

/*
   WriteLuts
  */
void WriteLuts(	char *theName,long WordSize,long aElutAdrSize,long aElutWordSize,UINT16 *Elut,
				long aXlutInDim,long aXlutOutDim,long aXlutAdrSize,long aXlutWordSize,UINT16 *Xlut,
				long aAlutAdrSize,long aAlutWordSize,UINT16 *Alut)
{
	register unsigned long Size,i,ii,l,lMax;
	char FileNameBuffer[256];
	
	Size = aElutAdrSize*aXlutInDim;
    sprintf(FileNameBuffer,"%s Elut%d",theName,FileCount);
    stream1=fopen(FileNameBuffer,"wb");             /*  oeffne Schreibedatei            */
    if(stream1 == NULL){
        DebugPrint("Open %s failed \n",FileNameBuffer);
        return;
    }
	lMax=0;
	if( 2 == 2 ){ for(i=0; i<Size; ++i)if( lMax < Elut[i] )lMax = Elut[i];}
	else{ for(i=0; i<Size; ++i)if( lMax < ((UINT8 *)Elut)[i] )lMax = ((UINT8 *)Elut)[i];}
	sprintf(FileNameBuffer,"%s InputDimension=%d OutputDimension=%d AdrSize=%ld EndWert=%ld WordSize=%ld",
			FileNameBuffer,aXlutInDim,aXlutInDim,aElutAdrSize,lMax,aElutWordSize);
	i=strlen( FileNameBuffer )+1;
	for( ii=i; ii<((i+15)/16)*16; ii++)FileNameBuffer[ii-1]=' ';
	FileNameBuffer[ii-1]='\0';
	l=fprintf(stream1,"%s\n",FileNameBuffer);
	
    if(fwrite(Elut,sizeof(UINT16),Size,stream1) != Size){
            DebugPrint("Write Error %s\n",FileNameBuffer);
            return;
    }
    fclose(stream1);
    Size = 1;
    for( i=0; i<aXlutInDim; ++i)Size *= aXlutAdrSize;			/* Calc aXlutAdrSize^aXlutInDim */
	Size = Size*aXlutOutDim;
    sprintf(FileNameBuffer,"DoNDim Xlut%d",FileCount);
    stream1=fopen(FileNameBuffer,"wb");             /*  oeffne Schreibedatei            */
    if(stream1 == NULL){
        DebugPrint("Open %s failed \n",FileNameBuffer);
        return;
    }
	lMax=0;
	if( WordSize == 2 ){ for(i=0; i<Size; ++i)if( lMax < Xlut[i] )lMax = Xlut[i];}
	else{ for(i=0; i<Size; ++i)if( lMax < ((UINT8 *)Xlut)[i] )lMax = ((UINT8 *)Xlut)[i];}
	sprintf(FileNameBuffer,"%s InputDimension=%d OutputDimension=%d AdrSize=%ld EndWert=%ld WordSize=%ld",
			FileNameBuffer,aXlutInDim,aXlutOutDim,aXlutAdrSize,lMax,aXlutWordSize);
	i=strlen( FileNameBuffer )+1;
	for( ii=i; ii<((i+15)/16)*16; ii++)FileNameBuffer[ii-1]=' ';
	FileNameBuffer[ii-1]='\0';
	l=fprintf(stream1,"%s\n",FileNameBuffer);
	
    if(fwrite(Xlut,WordSize,Size,stream1) != Size){
            DebugPrint("Write Error %s\n",FileNameBuffer);
            return;
    }
    fclose(stream1);
	Size = aAlutAdrSize*aXlutOutDim;
    sprintf(FileNameBuffer,"DoNDim Alut%d",FileCount);
    stream1=fopen(FileNameBuffer,"wb");             /*  oeffne Schreibedatei            */
    if(stream1 == NULL){
        DebugPrint("Open %s failed \n",FileNameBuffer);
        return;
    }
	lMax=0;
	if( WordSize == 2 ){ for(i=0; i<Size; ++i)if( lMax < Alut[i] )lMax = Alut[i];}
	else{ for(i=0; i<Size; ++i)if( lMax < ((UINT8 *)Alut)[i] )lMax = ((UINT8 *)Alut)[i];}
	sprintf(FileNameBuffer,"%s InputDimension=%d OutputDimension=%d AdrSize=%ld EndWert=%ld WordSize=%ld",
			FileNameBuffer,aXlutOutDim,aXlutOutDim,aAlutAdrSize,lMax,aAlutWordSize);
	i=strlen( FileNameBuffer )+1;
	for( ii=i; ii<((i+15)/16)*16; ii++)FileNameBuffer[ii-1]=' ';
	FileNameBuffer[ii-1]='\0';
	l=fprintf(stream1,"%s\n",FileNameBuffer);
	
    if(fwrite(Alut,WordSize,Size,stream1) != Size){
            DebugPrint("Write Error %s\n",FileNameBuffer);
            return;
    }
    fclose(stream1);
    FileCount++;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\engine.c ===
/*
	File:		LHCalcEngine.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#undef LH_DATA_IN_TYPE
#undef LH_DATA_OUT_TYPE
#undef LH_LUT_DATA_TYPE
#undef LH_DATA_IN_COUNT
#undef LH_DATA_OUT_COUNT
#undef LH_DATA_SHR
#undef LH_DATA_SHR_CORR
#undef LH_LUT_DATA_SHR
#undef LH_BIT_BREIT_INTERNAL
#if LH_DATA_IN_SIZE_16
#define LH_DATA_IN_TYPE LH_UINT16
#else
#define LH_DATA_IN_TYPE LH_UINT8
#endif
#if LH_DATA_OUT_SIZE_16
#define LH_DATA_OUT_TYPE LH_UINT16
#else
#define LH_DATA_OUT_TYPE LH_UINT8
#endif
#if LH_LUT_DATA_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#define LH_LUT_DATA_TYPE LH_UINT16
#else
#if LH_DATA_IN_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#else
#define LH_BIT_BREIT_INTERNAL 	10
#endif
#define LH_LUT_DATA_TYPE LH_UINT8
#endif

#if LH_DATA_IN_COUNT_4
#define LH_DATA_IN_COUNT 		4
#else
#define LH_DATA_IN_COUNT 		3
#endif

#if LH_DATA_OUT_COUNT_4
#define LH_DATA_OUT_COUNT 		4
#else
#define LH_DATA_OUT_COUNT 		3
#endif

#define LH_BIT_MASKE_ADR (((1<<LH_BIT_BREIT_ADR)-1)<< (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR))
#define LH_BIT_BREIT_SELEKTOR (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR)
#define LH_BIT_MASKE_SELEKTOR ((1<<LH_BIT_BREIT_SELEKTOR)-1)

#define LH_ADR_BEREICH_SEL 		(1<<LH_BIT_BREIT_SELEKTOR)

#if LH_LUT_DATA_SIZE_16
#define LH_DATA_SHR               (16+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)  /* z.B. 16+11-10=17 */
#define LH_DATA_SHR_CORR 8		/* notwendig bei LH_DATA_SHR > 16 */
#define LH_LUT_DATA_SHR  16		/* Normierung bei Alutinterpolation */
#else
#define LH_DATA_SHR               (8+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)   /* z.B. 8+7-10=5 */
#define LH_LUT_DATA_SHR  8		/* Normierung bei Alutinterpolation */
#endif

#if LH_DATA_IN_COUNT_4
{

 	LH_UINT32 ein_regY;
	LH_UINT32 ein_regM;
	LH_UINT32 ein_regC;
	LH_UINT32 ein_regK;
	LH_DATA_IN_TYPE ein_cache[4];
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;
	LH_UINT32 ako3;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];
	LH_DATA_IN_TYPE * input4 = (LH_DATA_IN_TYPE *)calcParam->inputData[4];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}

 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regC = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(*input3>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((((ein_regC & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							   (ein_regM & LH_BIT_MASKE_ADR)) << LH_BIT_BREIT_ADR) +
							   (ein_regY & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						       (ein_regK >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regC &= LH_BIT_MASKE_SELEKTOR;
			ein_regM &= LH_BIT_MASKE_SELEKTOR;
			ein_regY &= LH_BIT_MASKE_SELEKTOR;
			ein_regK &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regY >= ein_regC)
			{
		        if( ein_regM >= ein_regC )
		        {
		            if( ein_regY >= ein_regM )	 	   /*  YMCK !*/
		            {	   		
		            	if( ein_regC >= ein_regK )
		            	{
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regC;
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  YMKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  YKMC !*/
						{	 
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else{	 						/*  KYMC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}	
		            }
		            else
		            { 								/*  MYCK !*/
		            	if( ein_regC >= ein_regK )
		            	{				  
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regC;						    
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  MYKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  MKYC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else
						{							/*  KMYC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regM;
							ako2 = ein_regM - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
		                }
					}
	            }
	            else
	            { 									/*  YCMK !*/
	            	if( ein_regM >= ein_regK )
	            	{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regC;
						ako2 = ein_regC - ein_regM;
						ako3 = ein_regM - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else if(ein_regC >= ein_regK )	/*  YCKM !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regC;
						ako2 = ein_regC - ein_regK;
						ako3 = ein_regK - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else if(ein_regY >= ein_regK )	/*  YKCM !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regK;
						ako2 = ein_regK - ein_regC;
						ako3 = ein_regC - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else
					{						 	/*  KYCM !*/
						ako0 = LH_ADR_BEREICH_SEL - ein_regK;
						ako1 = ein_regK - ein_regY;
						ako2 = ein_regY - ein_regC;
						ako3 = ein_regC - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
	            	}
		        }
			}
	        else
	        {
            	if( ein_regM >= ein_regC )
            	{
          			if( ein_regY >= ein_regK )		/*  MCYK !*/
          			{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regC;
						ako2 = ein_regC - ein_regY;
						ako3 = ein_regY - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else if(ein_regC >= ein_regK )	/*  MCKY !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regC;
						ako2 = ein_regC - ein_regK;
						ako3 = ein_regK - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
				}
					else if(ein_regM >= ein_regK )	/*  MKCY !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regK;
						ako2 = ein_regK - ein_regC;
						ako3 = ein_regC - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else
					{						 	/*  KMCY !*/
						ako0 = LH_ADR_BEREICH_SEL - ein_regK;
						ako1 = ein_regK - ein_regM;
						ako2 = ein_regM - ein_regC;
						ako3 = ein_regC - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
                }
                else
                {
                    if( ein_regY >= ein_regM )
                    {
	          			if( ein_regM >= ein_regK )	/*  CYMK !*/
	          			{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  CYKM !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regC >= ein_regK )	/*  CKYM */
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else
						{							/*  KCYM !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regY;
							ako3 = ein_regY - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
                    }
                    else if( ein_regY >= ein_regK )		/*  CMYK !*/
                    {	
						ako0 = LH_ADR_BEREICH_SEL - ein_regC;
						ako1 = ein_regC - ein_regM;
						ako2 = ein_regM - ein_regY;
						ako3 = ein_regY - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else if(ein_regM >= ein_regK )	/*  CMKY !*/
					{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regC;
						ako1 = ein_regC - ein_regM;
						ako2 = ein_regM - ein_regK;
						ako3 = ein_regK - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else
					{ 
						if(ein_regC >= ein_regK )	/*  CKMY !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else
						{							/*  KCMY !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regM;
							ako3 = ein_regM - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
		                }
					}
		    	}
			}
			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			#if LH_DATA_OUT_COUNT_4
			*output3 |= (*output3 << 8);
			#endif
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output3 += outputOffset;
					#endif

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					#endif
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 &= Mask;
				#else
				*output3 &= Mask;
				#endif
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					#else
					*output3 &= Mask;
					#endif
				}
			}
			else
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 = (LH_DATA_OUT_TYPE)*input4;
				#else
				*output3 = (LH_DATA_OUT_TYPE)*input4;
				#endif
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					input4 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input4;
					#else
					*output3 = (LH_DATA_OUT_TYPE)*input4;
					#endif
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);
			input4 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[4] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			#if LH_DATA_OUT_COUNT_4
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			#endif
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#else
{

 	LH_UINT32 ein_regb;
	LH_UINT32 ein_regg;
	LH_UINT32 ein_regr;
	LH_DATA_IN_TYPE ein_cache[3];
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}
 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regr = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((ein_regr & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							 (ein_regg & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						     (ein_regb >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regr &= LH_BIT_MASKE_SELEKTOR;
			ein_regg &= LH_BIT_MASKE_SELEKTOR;
			ein_regb &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regb >= ein_regr)
			{
				if (ein_regg >= ein_regr)
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regg;
						ako2 = ein_regg - ein_regr;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
						ako1 = ein_regg - ein_regb;
						ako2 = ein_regb - ein_regr;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
					}
				}
				else
				{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regr;
						ako2 = ein_regr - ein_regg;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
				}
			}
			else
			{
				if (ein_regg >= ein_regr)
				{
					ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
					ako1 = ein_regg - ein_regr;
					ako2 = ein_regr - ein_regb;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
				}
				else
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regb;
						ako2 = ein_regb - ein_regg;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regg;
						ako2 = ein_regg - ein_regb;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
					}
				}
			}
			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			#if LH_DATA_OUT_COUNT_4
			*output3 |= (*output3 << 8);
			#endif
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output3 += outputOffset;
					#endif

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					#endif
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 &= Mask;
				#else
				*output3 &= Mask;
				#endif
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					#else
					*output3 &= Mask;
					#endif
				}
			}
			else
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 = (LH_DATA_OUT_TYPE)*input3;
				#else
				*output3 = (LH_DATA_OUT_TYPE)*input3;
				#endif
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input3;
					#else
					*output3 = (LH_DATA_OUT_TYPE)*input3;
					#endif
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			#if LH_DATA_OUT_COUNT_4
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			#endif
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#endif
#undef LH_CALC_PROC_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\fragment.h ===
/*
	File:		LHFragment.h

	Contains:	prototypes for special lut extraction

	Written by:	H.Siegeritz

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.


*/

#ifndef LHFragment_h
#define	LHFragment_h

#ifndef LHDefines_h
#include "Defines.h"
#endif

#ifndef LHGenLuts_h
#include "GenLuts.h"
#endif


icCurveType	*	InvertLut1d	( icCurveType *LookUpTable,
							  UINT8 AdressBits);
							  
CMError			CombiMatrix	( icXYZType srcColorantData[3],
							  icXYZType destColorantData[3], 
							  double resMatrix[3][3] );
							  
Boolean		doubMatrixInvert( double MatHin[3][3], 
							  double MatRueck[3][3] );

CMError Fill_ushort_ELUT_identical(	UINT16 *usELUT, 
									char addrBits, 
									char usedBits, 
									long gridPoints);

CMError Fill_ushort_ELUT_from_CurveTag( icCurveType *pCurveTag,
										UINT16		*usELUT, 
										char		addrBits, 
										char		usedBits, 
										long		gridPoints);

CMError Fill_inverse_byte_ALUT_from_CurveTag( icCurveType	*pCurveTag,
											  UINT8			*ucALUT, 
											  char			addrBits);

CMError Fill_inverse_ushort_ALUT_from_CurveTag(	icCurveType		*pCurveTag,
												unsigned short	*usALUT,
												char			addrBits );


CMError	Fill_ushort_ELUTs_from_lut8Tag ( CMLutParamPtr	theLutData,
										 Ptr			profileELuts,
										 char			addrBits,
										 char			usedBits, 
										 long			gridPoints );

CMError Fill_byte_ALUTs_from_lut8Tag( CMLutParamPtr	theLutData,
									  Ptr			profileALuts, 
									  char			addrBits );

CMError Fill_ushort_ALUTs_from_lut8Tag(	CMLutParamPtr	theLutData,
							  			Ptr				profileALuts, 
							  			char			addrBits );


CMError	Fill_ushort_ELUTs_from_lut16Tag ( CMLutParamPtr	theLutData,
										  Ptr			profileELuts,
										  char			addrBits,
										  char			usedBits, 
										  long			gridPoints,
										  long			inputTableEntries );

CMError Fill_byte_ALUTs_from_lut16Tag( CMLutParamPtr	theLutData,
									   Ptr				profileALuts, 
									   char				addrBits,
									   long				outputTableEntries );

CMError Fill_ushort_ALUTs_from_lut16Tag(CMLutParamPtr	theLutData,
										Ptr				profileALuts,
										char			addrBits,
							    		long			outputTableEntries );


CMError  MakeGamut16or32ForMonitor(	icXYZType		*pRedXYZ,
									icXYZType		*pGreenXYZ,
									icXYZType		*pBlueXYZ,
									CMLutParamPtr	theLutData,
									Boolean			cube32Flag );

CMError	DoAbsoluteShiftForPCS_Cube16(	unsigned short	*theCube,
										long			count,
										CMProfileRef	theProfile,
										Boolean			pcsIsXYZ,
										Boolean			afterInput );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\engineol.c ===
/*
	File:		LHCalcEngine.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#undef LH_DATA_IN_TYPE
#undef LH_DATA_OUT_TYPE
#undef LH_LUT_DATA_TYPE
#undef LH_DATA_IN_COUNT
#undef LH_DATA_OUT_COUNT
#undef LH_DATA_SHR
#undef LH_DATA_SHR_CORR
#undef LH_LUT_DATA_SHR
#undef LH_BIT_BREIT_INTERNAL
#if LH_DATA_IN_SIZE_16
#define LH_DATA_IN_TYPE LH_UINT16
#else
#define LH_DATA_IN_TYPE LH_UINT8
#endif
#if LH_DATA_OUT_SIZE_16
#define LH_DATA_OUT_TYPE LH_UINT16
#else
#define LH_DATA_OUT_TYPE LH_UINT8
#endif
#if LH_LUT_DATA_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#define LH_LUT_DATA_TYPE LH_UINT16
#else
#if LH_DATA_IN_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#else
#define LH_BIT_BREIT_INTERNAL 	10
#endif
#define LH_LUT_DATA_TYPE LH_UINT8
#endif

#if LH_DATA_IN_COUNT_4
#define LH_DATA_IN_COUNT 		4
#else
#define LH_DATA_IN_COUNT 		3
#endif

#if LH_DATA_OUT_COUNT_4
#define LH_DATA_OUT_COUNT 		4
#else
#define LH_DATA_OUT_COUNT 		3
#endif

#define LH_BIT_MASKE_ADR (((1<<LH_BIT_BREIT_ADR)-1)<< (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR))
#define LH_BIT_BREIT_SELEKTOR (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR)
#define LH_BIT_MASKE_SELEKTOR ((1<<LH_BIT_BREIT_SELEKTOR)-1)

#define LH_ADR_BEREICH_SEL 		(1<<LH_BIT_BREIT_SELEKTOR)

#if LH_LUT_DATA_SIZE_16
#define LH_DATA_SHR               (16+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)  /* z.B. 16+11-10=17 */
#define LH_DATA_SHR_CORR 8		/* notwendig bei LH_DATA_SHR > 16 */
#define LH_LUT_DATA_SHR  16		/* Normierung bei Alutinterpolation */
#else
#define LH_DATA_SHR               (8+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)   /* z.B. 8+7-10=5 */
#define LH_LUT_DATA_SHR  8		/* Normierung bei Alutinterpolation */
#endif

#if LH_DATA_IN_COUNT_4
{

 	LH_UINT32 ein_regY;
	LH_UINT32 ein_regM;
	LH_UINT32 ein_regC;
	LH_UINT32 ein_regK;
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;
	LH_UINT32 ako3;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];
	LH_DATA_IN_TYPE * input4 = (LH_DATA_IN_TYPE *)calcParam->inputData[4];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}

 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = *input0 - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = *input1 - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = *input2 - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );

				aValIn = *input3 - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regC = My_InputLut[*input0 + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[*input1 + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[*input2 + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[*input3 + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = *input0 - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = *input1 - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = *input2 - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );

				aValIn = *input3 - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regC = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(*input3>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regC = My_InputLut[*input0 + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[*input1 + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[*input2 + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[*input3 + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((((ein_regC & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							   (ein_regM & LH_BIT_MASKE_ADR)) << LH_BIT_BREIT_ADR) +
							   (ein_regY & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						       (ein_regK >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regC &= LH_BIT_MASKE_SELEKTOR;
			ein_regM &= LH_BIT_MASKE_SELEKTOR;
			ein_regY &= LH_BIT_MASKE_SELEKTOR;
			ein_regK &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regY >= ein_regC)
			{
		        if( ein_regM >= ein_regC )
		        {
		            if( ein_regY >= ein_regM )	 	   /*  YMCK !*/
		            {	   		
		            	if( ein_regC >= ein_regK )
		            	{
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regC;
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  YMKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  YKMC !*/
						{	 
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else{	 						/*  KYMC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}	
		            }
		            else
		            { 								/*  MYCK !*/
		            	if( ein_regC >= ein_regK )
		            	{				  
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regC;						    
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  MYKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  MKYC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else
						{							/*  KMYC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regM;
							ako2 = ein_regM - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
		                }
					}
	            }
	            else
	            { 									/*  YCMK !*/
	            	if( ein_regM >= ein_regK )
	            	{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regC;
						ako2 = ein_regC - ein_regM;
						ako3 = ein_regM - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else if(ein_regC >= ein_regK )	/*  YCKM !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regC;
						ako2 = ein_regC - ein_regK;
						ako3 = ein_regK - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else if(ein_regY >= ein_regK )	/*  YKCM !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regK;
						ako2 = ein_regK - ein_regC;
						ako3 = ein_regC - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else
					{						 	/*  KYCM !*/
						ako0 = LH_ADR_BEREICH_SEL - ein_regK;
						ako1 = ein_regK - ein_regY;
						ako2 = ein_regY - ein_regC;
						ako3 = ein_regC - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
	            	}
		        }
			}
	        else
	        {
            	if( ein_regM >= ein_regC )
            	{
          			if( ein_regY >= ein_regK )		/*  MCYK !*/
          			{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regC;
						ako2 = ein_regC - ein_regY;
						ako3 = ein_regY - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else if(ein_regC >= ein_regK )	/*  MCKY !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regC;
						ako2 = ein_regC - ein_regK;
						ako3 = ein_regK - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
				}
					else if(ein_regM >= ein_regK )	/*  MKCY !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regK;
						ako2 = ein_regK - ein_regC;
						ako3 = ein_regC - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else
					{						 	/*  KMCY !*/
						ako0 = LH_ADR_BEREICH_SEL - ein_regK;
						ako1 = ein_regK - ein_regM;
						ako2 = ein_regM - ein_regC;
						ako3 = ein_regC - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
                }
                else
                {
                    if( ein_regY >= ein_regM )
                    {
	          			if( ein_regM >= ein_regK )	/*  CYMK !*/
	          			{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  CYKM !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regC >= ein_regK )	/*  CKYM */
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else
						{							/*  KCYM !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regY;
							ako3 = ein_regY - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
                    }
                    else if( ein_regY >= ein_regK )		/*  CMYK !*/
                    {	
						ako0 = LH_ADR_BEREICH_SEL - ein_regC;
						ako1 = ein_regC - ein_regM;
						ako2 = ein_regM - ein_regY;
						ako3 = ein_regY - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else if(ein_regM >= ein_regK )	/*  CMKY !*/
					{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regC;
						ako1 = ein_regC - ein_regM;
						ako2 = ein_regM - ein_regK;
						ako3 = ein_regK - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
					}
					else
					{ 
						if(ein_regC >= ein_regK )	/*  CKMY !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else
						{							/*  KCMY !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regM;
							ako3 = ein_regM - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
		                }
					}
		    	}
			}
			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			#if LH_DATA_OUT_COUNT_4
			*output3 |= (*output3 << 8);
			#endif
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output3 += outputOffset;
					#endif

					if ((*input0 ^ input0[-inputOffset]) || (*input1 ^ input1[-inputOffset]) || (*input2 ^ input2[-inputOffset]) || (*input3 ^ input3[-inputOffset]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					#endif
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 &= Mask;
				#else
				*output3 &= Mask;
				#endif
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ input0[-inputOffset]) || (*input1 ^ input1[-inputOffset]) || (*input2 ^ input2[-inputOffset]) || (*input3 ^ input3[-inputOffset]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					#else
					*output3 &= Mask;
					#endif
				}
			}
			else
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 = (LH_DATA_OUT_TYPE)*input4;
				#else
				*output3 = (LH_DATA_OUT_TYPE)*input4;
				#endif
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					input4 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ input0[-inputOffset]) || (*input1 ^ input1[-inputOffset]) || (*input2 ^ input2[-inputOffset]) || (*input3 ^ input3[-inputOffset]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input4;
					#else
					*output3 = (LH_DATA_OUT_TYPE)*input4;
					#endif
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);
			input4 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[4] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			#if LH_DATA_OUT_COUNT_4
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			#endif
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#else
{

 	LH_UINT32 ein_regb;
	LH_UINT32 ein_regg;
	LH_UINT32 ein_regr;
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}
 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = *input0 - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = *input1 - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = *input2 - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[*input0 + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[*input1 + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[*input2 + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = *input0 - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = *input1 - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = *input2 - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regr = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regr = My_InputLut[*input0 + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[*input1 + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[*input2 + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((ein_regr & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							 (ein_regg & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						     (ein_regb >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regr &= LH_BIT_MASKE_SELEKTOR;
			ein_regg &= LH_BIT_MASKE_SELEKTOR;
			ein_regb &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regb >= ein_regr)
			{
				if (ein_regg >= ein_regr)
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regg;
						ako2 = ein_regg - ein_regr;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
						ako1 = ein_regg - ein_regb;
						ako2 = ein_regb - ein_regr;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
					}
				}
				else
				{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regr;
						ako2 = ein_regr - ein_regg;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
				}
			}
			else
			{
				if (ein_regg >= ein_regr)
				{
					ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
					ako1 = ein_regg - ein_regr;
					ako2 = ein_regr - ein_regb;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
				}
				else
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regb;
						ako2 = ein_regb - ein_regg;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regg;
						ako2 = ein_regg - ein_regb;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif
					}
				}
			}
			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			#if LH_DATA_OUT_COUNT_4
			*output3 |= (*output3 << 8);
			#endif
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output3 += outputOffset;
					#endif

					if ((*input0 ^ input0[-inputOffset]) || (*input1 ^ input1[-inputOffset]) || (*input2 ^ input2[-inputOffset]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					#endif
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 &= Mask;
				#else
				*output3 &= Mask;
				#endif
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ input0[-inputOffset]) || (*input1 ^ input1[-inputOffset]) || (*input2 ^ input2[-inputOffset]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					#else
					*output3 &= Mask;
					#endif
				}
			}
			else
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 = (LH_DATA_OUT_TYPE)*input3;
				#else
				*output3 = (LH_DATA_OUT_TYPE)*input3;
				#endif
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ input0[-inputOffset]) || (*input1 ^ input1[-inputOffset]) || (*input2 ^ input2[-inputOffset]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input3;
					#else
					*output3 = (LH_DATA_OUT_TYPE)*input3;
					#endif
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			#if LH_DATA_OUT_COUNT_4
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			#endif
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#endif
#undef LH_CALC_PROC_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\gen1dim.c ===
/*
	File:		Gen1Dim.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	

*/

/* #define LH_CALC_ENGINE_SMALL see LHGeneralIncs.h */

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHCalcEngine1Dim_h
#include "CalcEng1.h"      
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCalcGeneratorID
#endif

#define LH_ADR_BREIT_EIN_LUT   	adr_breite_elut
#define LH_ADR_BREIT_AUS_LUT   	adr_breite_alut

#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0

#if LH_Calc1toX_Di8_Do8_Lut8_G128 == LH_CALC_USE_SMALL_ENGINE 
CMError LHCalc1toX_Di8_Do8_Lut8_G128( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc1toX_Di8_Do8_Lut8_G128"
#include "Engine1D.c"
#endif

#undef LH_LUT_DATA_SIZE_16

#define LH_LUT_DATA_SIZE_16		1

#if LH_Calc1toX_Di8_Do8_Lut16_G128 == LH_CALC_USE_SMALL_ENGINE 
CMError LHCalc1toX_Di8_Do8_Lut16_G128( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc1toX_Di8_Do8_Lut16_G128"
#include "Engine1D.c"
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16

#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0

#if LH_Calc1toX_Di8_Do16_Lut8_G128 == LH_CALC_USE_SMALL_ENGINE 
CMError LHCalc1toX_Di8_Do16_Lut8_G128( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc1toX_Di8_Do16_Lut8_G128"
#include "Engine1D.c"
#endif

#undef LH_LUT_DATA_SIZE_16

#define LH_LUT_DATA_SIZE_16		1

#if LH_Calc1toX_Di8_Do16_Lut16_G128 == LH_CALC_USE_SMALL_ENGINE 
CMError LHCalc1toX_Di8_Do16_Lut16_G128( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc1toX_Di8_Do16_Lut16_G128"
#include "Engine1D.c"
#endif

#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16

#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0

#if LH_Calc1toX_Di16_Do8_Lut8_G128 == LH_CALC_USE_SMALL_ENGINE 
CMError LHCalc1toX_Di16_Do8_Lut8_G128( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc1toX_Di16_Do8_Lut8_G128"
#include "Engine1D.c"
#endif

#undef LH_LUT_DATA_SIZE_16

#define LH_LUT_DATA_SIZE_16		1

#if LH_Calc1toX_Di16_Do8_Lut16_G128 == LH_CALC_USE_SMALL_ENGINE 
CMError LHCalc1toX_Di16_Do8_Lut16_G128( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc1toX_Di16_Do8_Lut16_G128"
#include "Engine1D.c"
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16

#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0

#if LH_Calc1toX_Di16_Do16_Lut8_G128 == LH_CALC_USE_SMALL_ENGINE 
CMError LHCalc1toX_Di16_Do16_Lut8_G128( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc1toX_Di16_Do16_Lut8_G128"
#include "Engine1D.c"
#endif

#undef LH_LUT_DATA_SIZE_16

#define LH_LUT_DATA_SIZE_16		1

#if LH_Calc1toX_Di16_Do16_Lut16_G128 == LH_CALC_USE_SMALL_ENGINE 
CMError LHCalc1toX_Di16_Do16_Lut16_G128( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc1toX_Di16_Do16_Lut16_G128"
#include "Engine1D.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\enginef.c ===
/*
	File:		LHCalcEngine.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#undef LH_DATA_IN_TYPE
#undef LH_DATA_OUT_TYPE
#undef LH_LUT_DATA_TYPE
#undef LH_DATA_IN_COUNT
#undef LH_DATA_OUT_COUNT
#undef LH_DATA_SHR
#undef LH_DATA_SHR_CORR
#undef LH_LUT_DATA_SHR
#undef LH_BIT_BREIT_INTERNAL
#if LH_DATA_IN_SIZE_16
#define LH_DATA_IN_TYPE LH_UINT16
#else
#define LH_DATA_IN_TYPE LH_UINT8
#endif
#if LH_DATA_OUT_SIZE_16
#define LH_DATA_OUT_TYPE LH_UINT16
#else
#define LH_DATA_OUT_TYPE LH_UINT8
#endif
#if LH_LUT_DATA_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#define LH_LUT_DATA_TYPE LH_UINT16
#else
#if LH_DATA_IN_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#else
#define LH_BIT_BREIT_INTERNAL 	10
#endif
#define LH_LUT_DATA_TYPE LH_UINT8
#endif

#if LH_DATA_IN_COUNT_4
#define LH_DATA_IN_COUNT 		4
#else
#define LH_DATA_IN_COUNT 		3
#endif

#if LH_DATA_OUT_COUNT_4
#define LH_DATA_OUT_COUNT 		4
#else
#define LH_DATA_OUT_COUNT 		3
#endif

#define LH_BIT_MASKE_ADR (((1<<LH_BIT_BREIT_ADR)-1)<< (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR))
#define LH_BIT_BREIT_SELEKTOR (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR)
#define LH_BIT_MASKE_SELEKTOR ((1<<LH_BIT_BREIT_SELEKTOR)-1)

#define LH_ADR_BEREICH_SEL 		(1<<LH_BIT_BREIT_SELEKTOR)

#if LH_LUT_DATA_SIZE_16
#define LH_DATA_SHR               (16+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)  /* z.B. 16+11-10=17 */
#define LH_DATA_SHR_CORR 8		/* notwendig bei LH_DATA_SHR > 16 */
#define LH_LUT_DATA_SHR  16		/* Normierung bei Alutinterpolation */
#else
#define LH_DATA_SHR               (8+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)   /* z.B. 8+7-10=5 */
#define LH_LUT_DATA_SHR  8		/* Normierung bei Alutinterpolation */
#endif

#if LH_DATA_IN_COUNT_4
{
static LH_UINT16 MMXTab [] = 
{
    0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0001, 0x0001, 0x0001,
    0x0002, 0x0002, 0x0002, 0x0002,
    0x0003, 0x0003, 0x0003, 0x0003,
    0x0004, 0x0004, 0x0004, 0x0004,
    0x0005, 0x0005, 0x0005, 0x0005,
    0x0006, 0x0006, 0x0006, 0x0006,
    0x0007, 0x0007, 0x0007, 0x0007,
    0x0008, 0x0008, 0x0008, 0x0008,
    0x0009, 0x0009, 0x0009, 0x0009,
    0x000A, 0x000A, 0x000A, 0x000a,
    0x000B, 0x000B, 0x000B, 0x000b,
    0x000C, 0x000C, 0x000C, 0x000c,
    0x000D, 0x000D, 0x000D, 0x000d,
    0x000E, 0x000E, 0x000E, 0x000e,
    0x000F, 0x000F, 0x000F, 0x000f,
    0x0010, 0x0010, 0x0010, 0x0010,
    0x0011, 0x0011, 0x0011, 0x0011,
    0x0012, 0x0012, 0x0012, 0x0012,
    0x0013, 0x0013, 0x0013, 0x0013,
    0x0014, 0x0014, 0x0014, 0x0014,
    0x0015, 0x0015, 0x0015, 0x0015,
    0x0016, 0x0016, 0x0016, 0x0016,
    0x0017, 0x0017, 0x0017, 0x0017,
    0x0018, 0x0018, 0x0018, 0x0018,
    0x0019, 0x0019, 0x0019, 0x0019,
    0x001A, 0x001A, 0x001A, 0x001a,
    0x001B, 0x001B, 0x001B, 0x001b,
    0x001C, 0x001C, 0x001C, 0x001c,
    0x001D, 0x001D, 0x001D, 0x001d,
    0x001E, 0x001E, 0x001E, 0x001e,
    0x001F, 0x001F, 0x001F, 0x001f,
    0x0020, 0x0020, 0x0020, 0x0020,
    0x0021, 0x0021, 0x0021, 0x0021,
    0x0022, 0x0022, 0x0022, 0x0022,
    0x0023, 0x0023, 0x0023, 0x0023,
    0x0024, 0x0024, 0x0024, 0x0024,
    0x0025, 0x0025, 0x0025, 0x0025,
    0x0026, 0x0026, 0x0026, 0x0026,
    0x0027, 0x0027, 0x0027, 0x0027,
    0x0028, 0x0028, 0x0028, 0x0028,
    0x0029, 0x0029, 0x0029, 0x0029,
    0x002A, 0x002A, 0x002A, 0x002a,
    0x002B, 0x002B, 0x002B, 0x002b,
    0x002C, 0x002C, 0x002C, 0x002c,
    0x002D, 0x002D, 0x002D, 0x002d,
    0x002E, 0x002E, 0x002E, 0x002e,
    0x002F, 0x002F, 0x002F, 0x002f,
    0x0030, 0x0030, 0x0030, 0x0030,
    0x0031, 0x0031, 0x0031, 0x0031,
    0x0032, 0x0032, 0x0032, 0x0032,
    0x0033, 0x0033, 0x0033, 0x0033,
    0x0034, 0x0034, 0x0034, 0x0034,
    0x0035, 0x0035, 0x0035, 0x0035,
    0x0036, 0x0036, 0x0036, 0x0036,
    0x0037, 0x0037, 0x0037, 0x0037,
    0x0038, 0x0038, 0x0038, 0x0038,
    0x0039, 0x0039, 0x0039, 0x0039,
    0x003A, 0x003A, 0x003A, 0x003a,
    0x003B, 0x003B, 0x003B, 0x003b,
    0x003C, 0x003C, 0x003C, 0x003c,
    0x003D, 0x003D, 0x003D, 0x003d,
    0x003E, 0x003E, 0x003E, 0x003e,
    0x003F, 0x003F, 0x003F, 0x003f,
    0x0040, 0x0040, 0x0040, 0x0040,
    0x0041, 0x0041, 0x0041, 0x0041,
    0x0042, 0x0042, 0x0042, 0x0042,
    0x0043, 0x0043, 0x0043, 0x0043,
    0x0044, 0x0044, 0x0044, 0x0044,
    0x0045, 0x0045, 0x0045, 0x0045,
    0x0046, 0x0046, 0x0046, 0x0046,
    0x0047, 0x0047, 0x0047, 0x0047,
    0x0048, 0x0048, 0x0048, 0x0048,
    0x0049, 0x0049, 0x0049, 0x0049,
    0x004A, 0x004A, 0x004A, 0x004a,
    0x004B, 0x004B, 0x004B, 0x004b,
    0x004C, 0x004C, 0x004C, 0x004c,
    0x004D, 0x004D, 0x004D, 0x004d,
    0x004E, 0x004E, 0x004E, 0x004e,
    0x004F, 0x004F, 0x004F, 0x004f,
    0x0050, 0x0050, 0x0050, 0x0050,
    0x0051, 0x0051, 0x0051, 0x0051,
    0x0052, 0x0052, 0x0052, 0x0052,
    0x0053, 0x0053, 0x0053, 0x0053,
    0x0054, 0x0054, 0x0054, 0x0054,
    0x0055, 0x0055, 0x0055, 0x0055,
    0x0056, 0x0056, 0x0056, 0x0056,
    0x0057, 0x0057, 0x0057, 0x0057,
    0x0058, 0x0058, 0x0058, 0x0058,
    0x0059, 0x0059, 0x0059, 0x0059,
    0x005A, 0x005A, 0x005A, 0x005a,
    0x005B, 0x005B, 0x005B, 0x005b,
    0x005C, 0x005C, 0x005C, 0x005c,
    0x005D, 0x005D, 0x005D, 0x005d,
    0x005E, 0x005E, 0x005E, 0x005e,
    0x005F, 0x005F, 0x005F, 0x005f,
    0x0060, 0x0060, 0x0060, 0x0060,
    0x0061, 0x0061, 0x0061, 0x0061,
    0x0062, 0x0062, 0x0062, 0x0062,
    0x0063, 0x0063, 0x0063, 0x0063,
    0x0064, 0x0064, 0x0064, 0x0064,
    0x0065, 0x0065, 0x0065, 0x0065,
    0x0066, 0x0066, 0x0066, 0x0066,
    0x0067, 0x0067, 0x0067, 0x0067,
    0x0068, 0x0068, 0x0068, 0x0068,
    0x0069, 0x0069, 0x0069, 0x0069,
    0x006A, 0x006A, 0x006A, 0x006a,
    0x006B, 0x006B, 0x006B, 0x006b,
    0x006C, 0x006C, 0x006C, 0x006c,
    0x006D, 0x006D, 0x006D, 0x006d,
    0x006E, 0x006E, 0x006E, 0x006e,
    0x006F, 0x006F, 0x006F, 0x006f,
    0x0070, 0x0070, 0x0070, 0x0070,
    0x0071, 0x0071, 0x0071, 0x0071,
    0x0072, 0x0072, 0x0072, 0x0072,
    0x0073, 0x0073, 0x0073, 0x0073,
    0x0074, 0x0074, 0x0074, 0x0074,
    0x0075, 0x0075, 0x0075, 0x0075,
    0x0076, 0x0076, 0x0076, 0x0076,
    0x0077, 0x0077, 0x0077, 0x0077,
    0x0078, 0x0078, 0x0078, 0x0078,
    0x0079, 0x0079, 0x0079, 0x0079,
    0x007A, 0x007A, 0x007A, 0x007a,
    0x007B, 0x007B, 0x007B, 0x007b,
    0x007C, 0x007C, 0x007C, 0x007c,
    0x007D, 0x007D, 0x007D, 0x007d,
    0x007E, 0x007E, 0x007E, 0x007e,
    0x007F, 0x007F, 0x007F, 0x007f,
    0x0080, 0x0080, 0x0080, 0x0080
};
	LH_UINT32 ein_regY;
	LH_UINT32 ein_regM;
	LH_UINT32 ein_regC;
	LH_UINT32 ein_regK;
	LH_DATA_IN_TYPE ein_cache[4];
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;
	LH_UINT32 ako3;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];
	LH_DATA_IN_TYPE * input4 = (LH_DATA_IN_TYPE *)calcParam->inputData[4];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;
	LH_UINT16 ak[4];
	LH_UINT8    bFPUState [108];
#define Test_mode
#ifdef Test_mode
	LH_UINT16 TestRam[4];
#endif

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}

	__asm {
            fnsave  bFPUState
			pxor		mm0,mm0
			pxor		mm1,mm1
			pxor		mm2,mm2
			pxor		mm3,mm3
			pxor		mm4,mm4
			pxor		mm5,mm5
			pxor		mm6,mm6
			pxor		mm7,mm7
	}
	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regC = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(*input3>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((((ein_regC & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							   (ein_regM & LH_BIT_MASKE_ADR)) << LH_BIT_BREIT_ADR) +
							   (ein_regY & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						       (ein_regK >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regC &= LH_BIT_MASKE_SELEKTOR;
			ein_regM &= LH_BIT_MASKE_SELEKTOR;
			ein_regY &= LH_BIT_MASKE_SELEKTOR;
			ein_regK &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regY >= ein_regC)
			{
		        if( ein_regM >= ein_regC )
		        {
		            if( ein_regY >= ein_regM )	 	   /*  YMCK !*/
		            {	   		
		            	if( ein_regC >= ein_regK )
		            	{
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regC;
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regK
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  YMKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regC
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  YKMC !*/
						{	 
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regC
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else{	 						/*  KYMC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regC
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}	
		            }
		            else
		            { 								/*  MYCK !*/
		            	if( ein_regC >= ein_regK )
		            	{				  
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regC;						    
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regK
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  MYKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regC
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  MKYC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regC
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else
						{							/*  KMYC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regM;
							ako2 = ein_regM - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regC
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
		                }
					}
	            }
	            else
	            { 									/*  YCMK !*/
	            	if( ein_regM >= ein_regK )
	            	{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regC;
						ako2 = ein_regC - ein_regM;
						ako3 = ein_regM - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regK
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
					}
					else if(ein_regC >= ein_regK )	/*  YCKM !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regC;
						ako2 = ein_regC - ein_regK;
						ako3 = ein_regK - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regM
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
					}
					else if(ein_regY >= ein_regK )	/*  YKCM !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regK;
						ako2 = ein_regK - ein_regC;
						ako3 = ein_regC - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regM
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
					}
					else
					{						 	/*  KYCM !*/
						ako0 = LH_ADR_BEREICH_SEL - ein_regK;
						ako1 = ein_regK - ein_regY;
						ako2 = ein_regY - ein_regC;
						ako3 = ein_regC - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regM
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
	            	}
		        }
			}
	        else
	        {
            	if( ein_regM >= ein_regC )
            	{
          			if( ein_regY >= ein_regK )		/*  MCYK !*/
          			{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regC;
						ako2 = ein_regC - ein_regY;
						ako3 = ein_regY - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regK
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
					}
					else if(ein_regC >= ein_regK )	/*  MCKY !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regC;
						ako2 = ein_regC - ein_regK;
						ako3 = ein_regK - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regY
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
				}
					else if(ein_regM >= ein_regK )	/*  MKCY !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regK;
						ako2 = ein_regK - ein_regC;
						ako3 = ein_regC - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regY
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
					}
					else
					{						 	/*  KMCY !*/
						ako0 = LH_ADR_BEREICH_SEL - ein_regK;
						ako1 = ein_regK - ein_regM;
						ako2 = ein_regM - ein_regC;
						ako3 = ein_regC - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regY
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
					}
                }
                else
                {
                    if( ein_regY >= ein_regM )
                    {
	          			if( ein_regM >= ein_regK )	/*  CYMK !*/
	          			{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regK
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  CYKM !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regM
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else if(ein_regC >= ein_regK )	/*  CKYM */
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regM
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else
						{							/*  KCYM !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regY;
							ako3 = ein_regY - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regM
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
                    }
                    else if( ein_regY >= ein_regK )		/*  CMYK !*/
                    {	
						ako0 = LH_ADR_BEREICH_SEL - ein_regC;
						ako1 = ein_regC - ein_regM;
						ako2 = ein_regM - ein_regY;
						ako3 = ein_regY - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regK
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
					}
					else if(ein_regM >= ein_regK )	/*  CMKY !*/
					{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regC;
						ako1 = ein_regC - ein_regM;
						ako2 = ein_regM - ein_regK;
						ako3 = ein_regK - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regY
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
					}
					else
					{ 
						if(ein_regC >= ein_regK )	/*  CKMY !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regY
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
						}
						else
						{							/*  KCMY !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regM;
							ako3 = ein_regM - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako3
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm6
#endif
 			punpcklbw   mm2,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regY
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1
			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm5
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
							#endif
		                }
					}
		    	}
			}
			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			#if LH_DATA_OUT_COUNT_4
			*output3 |= (*output3 << 8);
			#endif
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output3 += outputOffset;
					#endif

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					#endif
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 &= Mask;
				#else
				*output3 &= Mask;
				#endif
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					#else
					*output3 &= Mask;
					#endif
				}
			}
			else
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 = (LH_DATA_OUT_TYPE)*input4;
				#else
				*output3 = (LH_DATA_OUT_TYPE)*input4;
				#endif
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					input4 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input4;
					#else
					*output3 = (LH_DATA_OUT_TYPE)*input4;
					#endif
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);
			input4 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[4] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			#if LH_DATA_OUT_COUNT_4
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			#endif
		}
	}
    __asm {
		emms
		frstor      bFPUState
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#else
{

static LH_UINT16 MMXTab [260] = 
{
    0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0001, 0x0001, 0x0001,
    0x0002, 0x0002, 0x0002, 0x0002,
    0x0003, 0x0003, 0x0003, 0x0003,
    0x0004, 0x0004, 0x0004, 0x0004,
    0x0005, 0x0005, 0x0005, 0x0005,
    0x0006, 0x0006, 0x0006, 0x0006,
    0x0007, 0x0007, 0x0007, 0x0007,
    0x0008, 0x0008, 0x0008, 0x0008,
    0x0009, 0x0009, 0x0009, 0x0009,
    0x000A, 0x000A, 0x000A, 0x000a,
    0x000B, 0x000B, 0x000B, 0x000b,
    0x000C, 0x000C, 0x000C, 0x000c,
    0x000D, 0x000D, 0x000D, 0x000d,
    0x000E, 0x000E, 0x000E, 0x000e,
    0x000F, 0x000F, 0x000F, 0x000f,
    0x0010, 0x0010, 0x0010, 0x0010,
    0x0011, 0x0011, 0x0011, 0x0011,
    0x0012, 0x0012, 0x0012, 0x0012,
    0x0013, 0x0013, 0x0013, 0x0013,
    0x0014, 0x0014, 0x0014, 0x0014,
    0x0015, 0x0015, 0x0015, 0x0015,
    0x0016, 0x0016, 0x0016, 0x0016,
    0x0017, 0x0017, 0x0017, 0x0017,
    0x0018, 0x0018, 0x0018, 0x0018,
    0x0019, 0x0019, 0x0019, 0x0019,
    0x001A, 0x001A, 0x001A, 0x001a,
    0x001B, 0x001B, 0x001B, 0x001b,
    0x001C, 0x001C, 0x001C, 0x001c,
    0x001D, 0x001D, 0x001D, 0x001d,
    0x001E, 0x001E, 0x001E, 0x001e,
    0x001F, 0x001F, 0x001F, 0x001f,
    0x0020, 0x0020, 0x0020, 0x0020,
    0x0021, 0x0021, 0x0021, 0x0021,
    0x0022, 0x0022, 0x0022, 0x0022,
    0x0023, 0x0023, 0x0023, 0x0023,
    0x0024, 0x0024, 0x0024, 0x0024,
    0x0025, 0x0025, 0x0025, 0x0025,
    0x0026, 0x0026, 0x0026, 0x0026,
    0x0027, 0x0027, 0x0027, 0x0027,
    0x0028, 0x0028, 0x0028, 0x0028,
    0x0029, 0x0029, 0x0029, 0x0029,
    0x002A, 0x002A, 0x002A, 0x002a,
    0x002B, 0x002B, 0x002B, 0x002b,
    0x002C, 0x002C, 0x002C, 0x002c,
    0x002D, 0x002D, 0x002D, 0x002d,
    0x002E, 0x002E, 0x002E, 0x002e,
    0x002F, 0x002F, 0x002F, 0x002f,
    0x0030, 0x0030, 0x0030, 0x0030,
    0x0031, 0x0031, 0x0031, 0x0031,
    0x0032, 0x0032, 0x0032, 0x0032,
    0x0033, 0x0033, 0x0033, 0x0033,
    0x0034, 0x0034, 0x0034, 0x0034,
    0x0035, 0x0035, 0x0035, 0x0035,
    0x0036, 0x0036, 0x0036, 0x0036,
    0x0037, 0x0037, 0x0037, 0x0037,
    0x0038, 0x0038, 0x0038, 0x0038,
    0x0039, 0x0039, 0x0039, 0x0039,
    0x003A, 0x003A, 0x003A, 0x003a,
    0x003B, 0x003B, 0x003B, 0x003b,
    0x003C, 0x003C, 0x003C, 0x003c,
    0x003D, 0x003D, 0x003D, 0x003d,
    0x003E, 0x003E, 0x003E, 0x003e,
    0x003F, 0x003F, 0x003F, 0x003f,
    0x0040, 0x0040, 0x0040, 0x0040
};

 	LH_UINT32 ein_regb;
	LH_UINT32 ein_regg;
	LH_UINT32 ein_regr;
	LH_DATA_IN_TYPE ein_cache[3];
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

	LH_UINT16 ak[4];
	LH_UINT8    bFPUState [108];
//#define Test_mode
#ifdef Test_mode
	LH_UINT16 TestRam[4];
#endif
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}
    __asm {
            fnsave  bFPUState
			pxor		mm0,mm0
			pxor		mm1,mm1
			pxor		mm2,mm2
			pxor		mm3,mm3
			pxor		mm4,mm4
			pxor		mm5,mm5
			pxor		mm6,mm6
			pxor		mm7,mm7
	}
	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regr = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((ein_regr & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							 (ein_regg & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						     (ein_regb >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regr &= LH_BIT_MASKE_SELEKTOR;
			ein_regg &= LH_BIT_MASKE_SELEKTOR;
			ein_regb &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regb >= ein_regr)
			{
				if (ein_regg >= ein_regr)
				{
					if (ein_regb >= ein_regg)
					{

						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regg;
						ako2 = ein_regg - ein_regr;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regr
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm2,[eax+(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2
			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm6
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
						#endif
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
						ako1 = ein_regg - ein_regb;
						ako2 = ein_regb - ein_regr;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regr
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm2,[eax+(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2
			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm6
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }

						#endif
					}
				}
				else
				{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regr;
						ako2 = ein_regr - ein_regg;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regg
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm2,[eax+(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2
			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm6
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
						#endif
				}
			}
			else
			{
				if (ein_regg >= ein_regr)
				{
					ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
					ako1 = ein_regg - ein_regr;
					ako2 = ein_regr - ein_regb;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regb
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm2,[eax+(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2
			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm6
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
						#endif
				}
				else
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regb;
						ako2 = ein_regb - ein_regg;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regg
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm2,[eax+(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2
			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm6
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
						#endif
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regg;
						ako2 = ein_regg - ein_regb;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
     __asm { 
            mov         eax, paNewVal0

 			mov			ebx, ako0
            movq        mm5, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm5
#endif
			punpcklbw	mm1,[eax] 
 			mov			ebx, ako1
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif

 			pmullw		mm5,mm1
            movq        mm6, MMXTab [ebx*8]
#ifdef Test_mode
			movq		TestRam,mm6
#endif
			punpcklbw   mm2,[eax+(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ako2
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2

			movq        mm7, MMXTab [ebx*8]
 			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm1,[eax+(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)]
			mov			ebx, ein_regb
			psrlw	    mm1,8
#ifdef Test_mode
			movq		TestRam,mm1
#endif
 			pmullw		mm7,mm1

			movq        mm6, MMXTab [ebx*8]
 			paddusw		mm5,mm7
#ifdef Test_mode
			movq		TestRam,mm7
#endif
 			punpcklbw   mm2,[eax+(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]
			psrlw	    mm2,8
#ifdef Test_mode
			movq		TestRam,mm2
#endif
 			pmullw		mm6,mm2
			paddusw		mm5,mm6
#ifdef Test_mode
			movq		TestRam,mm6
#endif


			xor			eax,eax
			psrlw		mm5,LH_DATA_SHR
			movq		ak,mm5

			mov			ax,ak
			mov			esi,My_OutputLut
			mov			al,BYTE PTR[eax+esi]
			mov			edi,output0
			mov			[edi], al
			mov			ax,ak+2
			mov			al,BYTE PTR[eax+esi+(1<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output1
			mov			[edi], al
			mov			ax,ak+4
			mov			al,BYTE PTR[eax+esi+(2<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output2
			mov			[edi], al
			#if LH_DATA_OUT_COUNT_4
			mov			ax,ak+6
			mov			al,BYTE PTR[eax+esi+(3<<LH_ADR_BREIT_AUS_LUT)]
			mov			edi,output3
			mov			[edi], al
			#endif
			

	 }
						#endif
					}
				}
			}
			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			#if LH_DATA_OUT_COUNT_4
			*output3 |= (*output3 << 8);
			#endif
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output3 += outputOffset;
					#endif

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					#endif
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 &= Mask;
				#else
				*output3 &= Mask;
				#endif
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					#else
					*output3 &= Mask;
					#endif
				}
			}
			else
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 = (LH_DATA_OUT_TYPE)*input3;
				#else
				*output3 = (LH_DATA_OUT_TYPE)*input3;
				#endif
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input3;
					#else
					*output3 = (LH_DATA_OUT_TYPE)*input3;
					#endif
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			#if LH_DATA_OUT_COUNT_4
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			#endif
		}
	}
    __asm {
		emms
		frstor      bFPUState
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#endif
#undef LH_CALC_PROC_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\genfast.c ===
/*
	File:		LHCalcGenerator.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	

*/

/* #define LH_CALC_ENGINE_SMALL see LHGeneralIncs.h */

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifdef ALLOW_MMX
#ifndef LHCalcEngine_h
#include "CalcEng.h"
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCalcGeneratorID
#endif

#define LH_ADR_BREIT_EIN_LUT   	adr_breite_elut
#define LH_ADR_BREIT_AUS_LUT   	adr_breite_alut

#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do8_Lut8_G16_F( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut8_G16_F"
#include "EngineF.c"
#endif

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di8_Do8_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do8_Lut8_G32_F( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut8_G32_F"
#include "EngineF.c"
#endif

#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do8_Lut8_G16_F( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut8_G16_F"
#include "EngineF.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di8_Do8_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do8_Lut8_G32_F( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut8_G32_F"
#include "EngineF.c"
#endif

#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di8_Do8_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do8_Lut8_G8_F( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut8_G8_F"
#include "EngineF.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do8_Lut8_G16_F( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut8_G16_F"
#include "EngineF.c"
#endif


#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di8_Do8_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do8_Lut8_G8_F( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut8_G8_F"
#include "EngineF.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do8_Lut8_G16_F( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut8_G16_F"
#include "EngineF.c"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\enginesm.c ===
/*
	File:		LHCalcEngine.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#define smallCode 1

#undef LH_DATA_IN_TYPE
#undef LH_DATA_OUT_TYPE
#undef LH_LUT_DATA_TYPE
#undef LH_DATA_IN_COUNT
#undef LH_DATA_SHR
#undef LH_DATA_SHR_CORR
#undef LH_LUT_DATA_SHR
#undef LH_BIT_BREIT_INTERNAL
#if LH_DATA_IN_SIZE_16
#define LH_DATA_IN_TYPE LH_UINT16
#else
#define LH_DATA_IN_TYPE LH_UINT8
#endif
#if LH_DATA_OUT_SIZE_16
#define LH_DATA_OUT_TYPE LH_UINT16
#else
#define LH_DATA_OUT_TYPE LH_UINT8
#endif
#if LH_LUT_DATA_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#define LH_LUT_DATA_TYPE LH_UINT16
#else
#if LH_DATA_IN_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#else
#define LH_BIT_BREIT_INTERNAL 	10
#endif
#define LH_LUT_DATA_TYPE LH_UINT8
#endif

#if LH_DATA_IN_COUNT_4
#define LH_DATA_IN_COUNT 		4
#else
#define LH_DATA_IN_COUNT 		3
#endif

#define LH_BIT_MASKE_ADR (((1<<LH_BIT_BREIT_ADR)-1)<< (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR))
#define LH_BIT_BREIT_SELEKTOR (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR)
#define LH_BIT_MASKE_SELEKTOR ((1<<LH_BIT_BREIT_SELEKTOR)-1)

#define LH_ADR_BEREICH_SEL 		(1<<LH_BIT_BREIT_SELEKTOR)

#if LH_LUT_DATA_SIZE_16
#define LH_DATA_SHR               (16+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)  /* z.B. 16+11-10=17 */
#define LH_DATA_SHR_CORR 8		/* notwendig bei LH_DATA_SHR > 16 */
#define LH_LUT_DATA_SHR  16		/* Normierung bei Alutinterpolation */
#else
#define LH_DATA_SHR               (8+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)   /* z.B. 8+7-10=5 */
#define LH_LUT_DATA_SHR  8		/* Normierung bei Alutinterpolation */
#endif

#if LH_DATA_IN_COUNT_4
{
#if smallCode

	LH_UINT32 var_0_0_0_1;
	LH_UINT32 var_0_0_1_0;
	LH_UINT32 var_0_0_1_1;
	LH_UINT32 var_0_1_0_0;
	LH_UINT32 var_0_1_0_1;
	LH_UINT32 var_0_1_1_0;
	LH_UINT32 var_0_1_1_1;
	LH_UINT32 var_1_0_0_0;
	LH_UINT32 var_1_0_0_1;
	LH_UINT32 var_1_0_1_0;
	LH_UINT32 var_1_0_1_1;
	LH_UINT32 var_1_1_0_0;
	LH_UINT32 var_1_1_0_1;
	LH_UINT32 var_1_1_1_0;
	LH_UINT32 var_1_1_1_1;


 	LH_UINT32 ein_regY;
	LH_UINT32 ein_regM;
	LH_UINT32 ein_regC;
	LH_UINT32 ein_regK;
	LH_DATA_IN_TYPE ein_cache[4];
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;
	LH_UINT32 ako3;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	LH_UINT8 	LH_DATA_OUT_COUNT;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];
	LH_DATA_IN_TYPE * input4 = (LH_DATA_IN_TYPE *)calcParam->inputData[4];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif

	LH_START_PROC(LH_CALC_PROC_NAME)

	if( LH_DATA_OUT_COUNT_4 ){
		LH_DATA_OUT_COUNT 		= 4;
	}else{
		LH_DATA_OUT_COUNT 		= 3;
	}

	var_0_0_0_1 = (((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT);
	var_0_0_1_0 = (((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT);
	var_0_0_1_1 = (((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT);
	var_0_1_0_0 = (((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT);
	var_0_1_0_1 = (((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT);
	var_0_1_1_0 = (((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT);
	var_0_1_1_1 = (((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT);
	var_1_0_0_0 = (((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT);
	var_1_0_0_1 = (((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT);
	var_1_0_1_0 = (((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT);
	var_1_0_1_1 = (((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT);
	var_1_1_0_0 = (((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT);
	var_1_1_0_1 = (((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT);
	var_1_1_1_0 = (((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT);
	var_1_1_1_1 = (((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT);

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}

 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regC = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(*input3>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((((ein_regC & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							   (ein_regM & LH_BIT_MASKE_ADR)) << LH_BIT_BREIT_ADR) +
							   (ein_regY & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						       (ein_regK >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regC &= LH_BIT_MASKE_SELEKTOR;
			ein_regM &= LH_BIT_MASKE_SELEKTOR;
			ein_regY &= LH_BIT_MASKE_SELEKTOR;
			ein_regK &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regY >= ein_regC)
			{
		        if( ein_regM >= ein_regC )
		        {
		            if( ein_regY >= ein_regM )	 	   /*  YMCK !*/
		            {	   		
		            	if( ein_regC >= ein_regK )
		            	{
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regC;
							ako3 = ein_regC - ein_regK;
							
							ein_regC = var_0_0_1_0;
							ein_regM = var_0_1_1_0;
							ein_regY = var_1_1_1_0;
							
 						}
						else if(ein_regM >= ein_regK )	/*  YMKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regK;
							ako3 = ein_regK - ein_regC;
							
							ein_regK = ein_regC;
							ein_regC = var_0_0_1_0;
							ein_regM = var_0_1_1_0;
							ein_regY = var_0_1_1_1;
							
						}
						else if(ein_regY >= ein_regK )	/*  YKMC !*/
						{	 
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regC;
							
							ein_regK = ein_regC;
							ein_regC = var_0_0_1_0;
							ein_regM = var_0_0_1_1;
							ein_regY = var_0_1_1_1;
							
						}
						else{	 						/*  KYMC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regC;
							
							ein_regK = ein_regC;
							ein_regC = var_0_0_0_1;
							ein_regM = var_0_0_1_1;
							ein_regY = var_0_1_1_1;
							
						}	
		            }
		            else
		            { 								/*  MYCK !*/
		            	if( ein_regC >= ein_regK )
		            	{				  
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regC;						    
							ako3 = ein_regC - ein_regK;
							
							ein_regC = var_0_1_0_0;
							ein_regM = var_0_1_1_0;
							ein_regY = var_1_1_1_0;
							
						}
						else if(ein_regY >= ein_regK )	/*  MYKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regC;
							
							ein_regK = ein_regC;
							ein_regC = var_0_1_0_0;
							ein_regM = var_0_1_1_0;
							ein_regY = var_0_1_1_1;
							
						}
						else if(ein_regM >= ein_regK )	/*  MKYC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regC;
							
							ein_regK = ein_regC;
							ein_regC = var_0_1_0_0;
							ein_regM = var_0_1_0_1;
							ein_regY = var_0_1_1_1;
							
						}
						else
						{							/*  KMYC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regM;
							ako2 = ein_regM - ein_regY;
							ako3 = ein_regY - ein_regC;
							
							ein_regK = ein_regC;
							ein_regC = var_0_0_0_1;
							ein_regM = var_0_1_0_1;
							ein_regY = var_0_1_1_1;
							
		                }
					}
	            }
	            else
	            { 									/*  YCMK !*/
	            	if( ein_regM >= ein_regK )
	            	{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regC;
							ako2 = ein_regC - ein_regM;
							ako3 = ein_regM - ein_regK;
							
							ein_regC = var_0_0_1_0;
							ein_regM = var_1_0_1_0;
							ein_regY = var_1_1_1_0;
							
					}
					else if(ein_regC >= ein_regK )	/*  YCKM !*/
					{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regC;
							ako2 = ein_regC - ein_regK;
							ako3 = ein_regK - ein_regM;
							
							ein_regK = ein_regM;
							ein_regC = var_0_0_1_0;
							ein_regM = var_1_0_1_0;
							ein_regY = var_1_0_1_1;
							
					}
					else if(ein_regY >= ein_regK )	/*  YKCM !*/
					{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regK;
							ako2 = ein_regK - ein_regC;
							ako3 = ein_regC - ein_regM;
							
							ein_regK = ein_regM;
							ein_regC = var_0_0_1_0;
							ein_regM = var_0_0_1_1;
							ein_regY = var_1_0_1_1;
							
					}
					else
					{						 	/*  KYCM !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regY;
							ako2 = ein_regY - ein_regC;
							ako3 = ein_regC - ein_regM;
							
							ein_regK = ein_regM;
							ein_regC = var_0_0_0_1;
							ein_regM = var_0_0_1_1;
							ein_regY = var_1_0_1_1;
							
	            	}
		        }
			}
	        else
	        {
            	if( ein_regM >= ein_regC )
            	{
          			if( ein_regY >= ein_regK )		/*  MCYK !*/
          			{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regC;
							ako2 = ein_regC - ein_regY;
							ako3 = ein_regY - ein_regK;

							ein_regC = var_0_1_0_0;
							ein_regM = var_1_1_0_0;
							ein_regY = var_1_1_1_0;
							
					}
					else if(ein_regC >= ein_regK )	/*  MCKY !*/
					{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regC;
							ako2 = ein_regC - ein_regK;
							ako3 = ein_regK - ein_regY;
							
							ein_regK = ein_regY;
							ein_regC = var_0_1_0_0;
							ein_regM = var_1_1_0_0;
							ein_regY = var_1_1_0_1;
							
				}
					else if(ein_regM >= ein_regK )	/*  MKCY !*/
					{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regK;
							ako2 = ein_regK - ein_regC;
							ako3 = ein_regC - ein_regY;
							
							ein_regK = ein_regY;
							ein_regC = var_0_1_0_0;
							ein_regM = var_0_1_0_1;
							ein_regY = var_1_1_0_1;
							
					}
					else
					{						 	/*  KMCY !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regM;
							ako2 = ein_regM - ein_regC;
							ako3 = ein_regC - ein_regY;
							
							ein_regK = ein_regY;
							ein_regC = var_0_0_0_1;
							ein_regM = var_0_1_0_1;
							ein_regY = var_1_1_0_1;
							
					}
                }
                else
                {
                    if( ein_regY >= ein_regM )
                    {
	          			if( ein_regM >= ein_regK )	/*  CYMK !*/
	          			{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regK;
							
							ein_regC = var_1_0_0_0;
							ein_regM = var_1_0_1_0;
							ein_regY = var_1_1_1_0;
							
						}
						else if(ein_regY >= ein_regK )	/*  CYKM !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regM;
							
							ein_regK = ein_regM;
							ein_regC = var_1_0_0_0;
							ein_regM = var_1_0_1_0;
							ein_regY = var_1_0_1_1;
							
						}
						else if(ein_regC >= ein_regK )	/*  CKYM */
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regM;
							
							ein_regK = ein_regM;
							ein_regC = var_1_0_0_0;
							ein_regM = var_1_0_0_1;
							ein_regY = var_1_0_1_1;
							
						}
						else
						{							/*  KCYM !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regY;
							ako3 = ein_regY - ein_regM;
							
							ein_regK = ein_regM;
							ein_regC = var_0_0_0_1;
							ein_regM = var_1_0_0_1;
							ein_regY = var_1_0_1_1;
							
						}
                    }
                    else if( ein_regY >= ein_regK )		/*  CMYK !*/
                    {	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regM;
							ako2 = ein_regM - ein_regY;
							ako3 = ein_regY - ein_regK;
							
							ein_regC = var_1_0_0_0;
							ein_regM = var_1_1_0_0;
							ein_regY = var_1_1_1_0;
							
					}
					else if(ein_regM >= ein_regK )	/*  CMKY !*/
					{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regM;
							ako2 = ein_regM - ein_regK;
							ako3 = ein_regK - ein_regY;
							
							ein_regK = ein_regY;
							ein_regC = var_1_0_0_0;
							ein_regM = var_1_1_0_0;
							ein_regY = var_1_1_0_1;
							
					}
					else
					{ 
						if(ein_regC >= ein_regK )	/*  CKMY !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regY;
							
							ein_regK = ein_regY;
							ein_regC = var_1_0_0_0;
							ein_regM = var_1_0_0_1;
							ein_regY = var_1_1_0_1;
							
						}
						else
						{							/*  KCMY !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regM;
							ako3 = ein_regM - ein_regY;
							
							ein_regK = ein_regY;
							ein_regC = var_0_0_0_1;
							ein_regM = var_1_0_0_1;
							ein_regY = var_1_1_0_1;
							
		                }
					}
		    	}
			}

			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_OUT_SIZE_16
	
			aVal =					 (	ako0 * paNewVal0[0] + 
	        							ako1 * paNewVal0[ein_regC + 0] + 
	        							ako2 * paNewVal0[ein_regM + 0] + 
	        							ako3 * paNewVal0[ein_regY + 0] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 0] );
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
	       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			aVal =					 (	ako0 * paNewVal0[1] + 
	        							ako1 * paNewVal0[ein_regC + 1] + 
	        							ako2 * paNewVal0[ein_regM + 1] + 
	        							ako3 * paNewVal0[ein_regY + 1] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 1] );
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
	       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			aVal =					 (	ako0 * paNewVal0[2] + 
	        							ako1 * paNewVal0[ein_regC + 2] + 
	        							ako2 * paNewVal0[ein_regM + 2] + 
	        							ako3 * paNewVal0[ein_regY + 2] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 2] );
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
	       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			if( LH_DATA_OUT_COUNT_4 ){
			aVal =					 (	ako0 * paNewVal0[3] + 
	        							ako1 * paNewVal0[ein_regC + 3] + 
	        							ako2 * paNewVal0[ein_regM + 3] + 
	        							ako3 * paNewVal0[ein_regY + 3] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 3] );
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
	       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
			}
			
			#else
			*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
	        							ako1 * paNewVal0[ein_regC + 0] + 
	        							ako2 * paNewVal0[ein_regM + 0] + 
	        							ako3 * paNewVal0[ein_regY + 0] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
			*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
	        							ako1 * paNewVal0[ein_regC + 1] + 
	        							ako2 * paNewVal0[ein_regM + 1] + 
	        							ako3 * paNewVal0[ein_regY + 1] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
			*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
	        							ako1 * paNewVal0[ein_regC + 2] + 
	        							ako2 * paNewVal0[ein_regM + 2] + 
	        							ako3 * paNewVal0[ein_regY + 2] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
			if( LH_DATA_OUT_COUNT_4 ){
			*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
	        							ako1 * paNewVal0[ein_regC + 3] + 
	        							ako2 * paNewVal0[ein_regM + 3] + 
	        							ako3 * paNewVal0[ein_regY + 3] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
			}
			#endif
			
			#else
			*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
	        							ako1 * paNewVal0[ein_regC + 0] + 
	        							ako2 * paNewVal0[ein_regM + 0] + 
	        							ako3 * paNewVal0[ein_regY + 0] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
			*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
	        							ako1 * paNewVal0[ein_regC + 1] + 
	        							ako2 * paNewVal0[ein_regM + 1] + 
	        							ako3 * paNewVal0[ein_regY + 1] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
			*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
	        							ako1 * paNewVal0[ein_regC + 2] + 
	        							ako2 * paNewVal0[ein_regM + 2] + 
	        							ako3 * paNewVal0[ein_regY + 2] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
			if( LH_DATA_OUT_COUNT_4 ){
			*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
	        							ako1 * paNewVal0[ein_regC + 3] + 
	        							ako2 * paNewVal0[ein_regM + 3] + 
	        							ako3 * paNewVal0[ein_regY + 3] + 
	        						ein_regK * paNewVal0[var_1_1_1_1 + 3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
			}
			#endif

			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			if( LH_DATA_OUT_COUNT_4 ){
			*output3 |= (*output3 << 8);
			}
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output3 += outputOffset;
					}

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					}
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				if( LH_DATA_OUT_COUNT_4 ){
				*output4 &= Mask;
				}else{
				*output3 &= Mask;
				}
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output4 += outputOffset;
					}
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					}else{
					*output3 &= Mask;
					}
				}
			}
			else
			{
				if( LH_DATA_OUT_COUNT_4 ){
				*output4 = (LH_DATA_OUT_TYPE)*input4;
				}else{
				*output3 = (LH_DATA_OUT_TYPE)*input4;
				}
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					input4 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output4 += outputOffset;
					}
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input4;
					}else{
					*output3 = (LH_DATA_OUT_TYPE)*input4;
					}
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);
			input4 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[4] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			if( LH_DATA_OUT_COUNT_4 ){
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			}
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;

#else

 	LH_UINT32 ein_regY;
	LH_UINT32 ein_regM;
	LH_UINT32 ein_regC;
	LH_UINT32 ein_regK;
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;
	LH_UINT32 ako3;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	LH_UINT8 	LH_DATA_OUT_COUNT;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];
	LH_DATA_IN_TYPE * input4 = (LH_DATA_IN_TYPE *)calcParam->inputData[4];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	if( LH_DATA_OUT_COUNT_4 ){
		LH_DATA_OUT_COUNT 		= 4;
	}else{
		LH_DATA_OUT_COUNT 		= 3;
	}
	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}

 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regC = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(*input3>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((((ein_regC & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							   (ein_regM & LH_BIT_MASKE_ADR)) << LH_BIT_BREIT_ADR) +
							   (ein_regY & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						       (ein_regK >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regC &= LH_BIT_MASKE_SELEKTOR;
			ein_regM &= LH_BIT_MASKE_SELEKTOR;
			ein_regY &= LH_BIT_MASKE_SELEKTOR;
			ein_regK &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regY >= ein_regC)
			{
		        if( ein_regM >= ein_regC )
		        {
		            if( ein_regY >= ein_regM )	 	   /*  YMCK !*/
		            {	   		
		            	if( ein_regC >= ein_regK )
		            	{
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regC;
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  YMKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  YKMC !*/
						{	 
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else{	 						/*  KYMC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}	
		            }
		            else
		            { 								/*  MYCK !*/
		            	if( ein_regC >= ein_regK )
		            	{				  
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regC;						    
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  MYKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  MKYC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else
						{							/*  KMYC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regM;
							ako2 = ein_regM - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
		                }
					}
	            }
	            else
	            { 									/*  YCMK !*/
	            	if( ein_regM >= ein_regK )
	            	{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regC;
						ako2 = ein_regC - ein_regM;
						ako3 = ein_regM - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
					}
					else if(ein_regC >= ein_regK )	/*  YCKM !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regC;
						ako2 = ein_regC - ein_regK;
						ako3 = ein_regK - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
					}
					else if(ein_regY >= ein_regK )	/*  YKCM !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regY;
						ako1 = ein_regY - ein_regK;
						ako2 = ein_regK - ein_regC;
						ako3 = ein_regC - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
					}
					else
					{						 	/*  KYCM !*/
						ako0 = LH_ADR_BEREICH_SEL - ein_regK;
						ako1 = ein_regK - ein_regY;
						ako2 = ein_regY - ein_regC;
						ako3 = ein_regC - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
	            	}
		        }
			}
	        else
	        {
            	if( ein_regM >= ein_regC )
            	{
          			if( ein_regY >= ein_regK )		/*  MCYK !*/
          			{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regC;
						ako2 = ein_regC - ein_regY;
						ako3 = ein_regY - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
					}
					else if(ein_regC >= ein_regK )	/*  MCKY !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regC;
						ako2 = ein_regC - ein_regK;
						ako3 = ein_regK - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
				}
					else if(ein_regM >= ein_regK )	/*  MKCY !*/
					{	 	
						ako0 = LH_ADR_BEREICH_SEL - ein_regM;
						ako1 = ein_regM - ein_regK;
						ako2 = ein_regK - ein_regC;
						ako3 = ein_regC - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
					}
					else
					{						 	/*  KMCY !*/
						ako0 = LH_ADR_BEREICH_SEL - ein_regK;
						ako1 = ein_regK - ein_regM;
						ako2 = ein_regM - ein_regC;
						ako3 = ein_regC - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
					}
                }
                else
                {
                    if( ein_regY >= ein_regM )
                    {
	          			if( ein_regM >= ein_regK )	/*  CYMK !*/
	          			{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  CYKM !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else if(ein_regC >= ein_regK )	/*  CKYM */
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else
						{							/*  KCYM !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regY;
							ako3 = ein_regY - ein_regM;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regM * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
                    }
                    else if( ein_regY >= ein_regK )		/*  CMYK !*/
                    {	
						ako0 = LH_ADR_BEREICH_SEL - ein_regC;
						ako1 = ein_regC - ein_regM;
						ako2 = ein_regM - ein_regY;
						ako3 = ein_regY - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
					}
					else if(ein_regM >= ein_regK )	/*  CMKY !*/
					{	
						ako0 = LH_ADR_BEREICH_SEL - ein_regC;
						ako1 = ein_regC - ein_regM;
						ako2 = ein_regM - ein_regK;
						ako3 = ein_regK - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
				        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
				        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
				        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
					}
					else
					{ 
						if(ein_regC >= ein_regK )	/*  CKMY !*/
						{	
							ako0 = LH_ADR_BEREICH_SEL - ein_regC;
							ako1 = ein_regC - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
						}
						else
						{							/*  KCMY !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regC;
							ako2 = ein_regC - ein_regM;
							ako3 = ein_regM - ein_regY;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							if( LH_DATA_OUT_COUNT_4 ){
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							}
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							}
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							if( LH_DATA_OUT_COUNT_4 ){
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regY * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							}
							#endif
		                }
					}
		    	}
			}
			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			if( LH_DATA_OUT_COUNT_4 ){
			*output3 |= (*output3 << 8);
			}
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output3 += outputOffset;
					}

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					}
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				if( LH_DATA_OUT_COUNT_4 ){
				*output4 &= Mask;
				}else{
				*output3 &= Mask;
				}
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output4 += outputOffset;
					}
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					}else{
					*output3 &= Mask;
					}
				}
			}
			else
			{
				if( LH_DATA_OUT_COUNT_4 ){
				*output4 = (LH_DATA_OUT_TYPE)*input4;
				}else{
				*output3 = (LH_DATA_OUT_TYPE)*input4;
				}
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					input4 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output4 += outputOffset;
					}
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input4;
					}else{
					*output3 = (LH_DATA_OUT_TYPE)*input4;
					}
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);
			input4 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[4] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			if( LH_DATA_OUT_COUNT_4 ){
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			}
		}
	}

#endif
}
#else
{

#if smallCode
	
	LH_UINT32 var_0_0_1;
	LH_UINT32 var_0_1_1;
	LH_UINT32 var_1_1_1;
	LH_UINT32 var_0_1_0;
	LH_UINT32 var_1_0_1;
	LH_UINT32 var_1_1_0;
	LH_UINT32 var_1_0_0;

 	LH_UINT32 ein_regb;
	LH_UINT32 ein_regg;
	LH_UINT32 ein_regr;
	LH_DATA_IN_TYPE ein_cache[3];
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	LH_UINT8 	LH_DATA_OUT_COUNT;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif

	LH_START_PROC(LH_CALC_PROC_NAME)

	if( LH_DATA_OUT_COUNT_4 ){
		LH_DATA_OUT_COUNT 		= 4;
	}else{
		LH_DATA_OUT_COUNT 		= 3;
	}

	var_0_0_1 = ((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT;
	var_0_1_1 = ((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT;
	var_1_1_1 = ((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT;
	var_0_1_0 = ((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT;
	var_1_0_1 = ((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT;
	var_1_1_0 = ((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT;
	var_1_0_0 = ((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT;

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}
 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regr = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((ein_regr & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							 (ein_regg & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						     (ein_regb >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regr &= LH_BIT_MASKE_SELEKTOR;
			ein_regg &= LH_BIT_MASKE_SELEKTOR;
			ein_regb &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regb >= ein_regr)
			{
				if (ein_regg >= ein_regr)
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regg;
						ako2 = ein_regg - ein_regr;
						ein_regb = ein_regr;
						ein_regr = var_0_0_1;
						ein_regg = var_0_1_1;
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
						ako1 = ein_regg - ein_regb;
						ako2 = ein_regb - ein_regr;
						ein_regb = ein_regr;
						ein_regr = var_0_1_0;
						ein_regg = var_0_1_1;
					}
				}
				else
				{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regr;
						ako2 = ein_regr - ein_regg;
						ein_regb = ein_regg;
						ein_regr = var_0_0_1;
						ein_regg = var_1_0_1;
				}
			}
			else
			{
				if (ein_regg >= ein_regr)
				{
					ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
					ako1 = ein_regg - ein_regr;
					ako2 = ein_regr - ein_regb;
						ein_regr = var_0_1_0;
						ein_regg = var_1_1_0;
				}
				else
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regb;
						ako2 = ein_regb - ein_regg;
						ein_regb = ein_regg;
						ein_regr = var_1_0_0;
						ein_regg = var_1_0_1;
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regg;
						ako2 = ein_regg - ein_regb;
						ein_regr = var_1_0_0;
						ein_regg = var_1_1_0;
					}
				}
			}

#if LH_LUT_DATA_SIZE_16
#if LH_DATA_OUT_SIZE_16
			aVal =					 (ako0 		* paNewVal0[0] + 
									  ako1 		* paNewVal0[ein_regr] + 
									  ako2 		* paNewVal0[ein_regg] + 
									  ein_regb	* paNewVal0[var_1_1_1]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
	       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] + 
									  ako1 		* paNewVal0[ein_regr] + 
									  ako2 		* paNewVal0[ein_regg] + 
									  ein_regb	* paNewVal0[var_1_1_1]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
	       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] + 
									  ako1 		* paNewVal0[ein_regr] + 
									  ako2 		* paNewVal0[ein_regg] + 
									  ein_regb	* paNewVal0[var_1_1_1]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
	       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			if( LH_DATA_OUT_COUNT_4 ){
			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] + 
									  ako1 		* paNewVal0[ein_regr] + 
									  ako2 		* paNewVal0[ein_regg] + 
									  ein_regb	* paNewVal0[var_1_1_1]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
	       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
			}
#else
			*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
									  ako1 		* paNewVal0[ein_regr] + 
									  ako2 		* paNewVal0[ein_regg] + 
									  ein_regb	* paNewVal0[var_1_1_1])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
			paNewVal0++;
			*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
									  ako1 		* paNewVal0[ein_regr] + 
									  ako2 		* paNewVal0[ein_regg] + 
									  ein_regb	* paNewVal0[var_1_1_1])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
			paNewVal0++;
			*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
								      ako1 		* paNewVal0[ein_regr] + 
								      ako2 		* paNewVal0[ein_regg] + 
								      ein_regb 	* paNewVal0[var_1_1_1])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
			if( LH_DATA_OUT_COUNT_4 ){
			paNewVal0++;
			*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
								      ako1 		* paNewVal0[ein_regr] + 
								      ako2 		* paNewVal0[ein_regg] + 
								      ein_regb 	* paNewVal0[var_1_1_1])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
			}
#endif

#else

			*output0 = My_OutputLut[((ako0 * paNewVal0[0] +
				ako1 * paNewVal0[ein_regr] +
				ako2 * paNewVal0[ein_regg] +
				ein_regb * paNewVal0[var_1_1_1])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];

			paNewVal0++;
			*output1 = My_OutputLut[((ako0 * paNewVal0[0] +
				ako1 * paNewVal0[ein_regr] +
				ako2 * paNewVal0[ein_regg] +
				ein_regb * paNewVal0[var_1_1_1])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];

			paNewVal0++;
			*output2 = My_OutputLut[((ako0 * paNewVal0[0] +
				ako1 * paNewVal0[ein_regr] +
				ako2 * paNewVal0[ein_regg] +
				ein_regb * paNewVal0[var_1_1_1])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];

			if( LH_DATA_OUT_COUNT_4 ){
				paNewVal0++;
				*output3 = My_OutputLut[((ako0 * paNewVal0[0] +
					ako1 * paNewVal0[ein_regr] +
					ako2 * paNewVal0[ein_regg] +
					ein_regb * paNewVal0[var_1_1_1])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
			}
#endif

			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			if( LH_DATA_OUT_COUNT_4 ){
			*output3 |= (*output3 << 8);
			}
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output3 += outputOffset;
					}

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					}
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				if( LH_DATA_OUT_COUNT_4 ){
				*output4 &= Mask;
				}else{
				*output3 &= Mask;
				}
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output4 += outputOffset;
					}
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					}else{
					*output3 &= Mask;
					}
				}
			}
			else
			{
				if( LH_DATA_OUT_COUNT_4 ){
				*output4 = (LH_DATA_OUT_TYPE)*input3;
				}else{
				*output3 = (LH_DATA_OUT_TYPE)*input3;
				}
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output4 += outputOffset;
					}
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input3;
					}else{
					*output3 = (LH_DATA_OUT_TYPE)*input3;
					}
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			if( LH_DATA_OUT_COUNT_4 ){
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			}
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
#else
 	LH_UINT32 ein_regb;
	LH_UINT32 ein_regg;
	LH_UINT32 ein_regr;
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	LH_UINT8 	LH_DATA_OUT_COUNT;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	if( LH_DATA_OUT_COUNT_4 ){
		LH_DATA_OUT_COUNT 		= 4;
	}else{
		LH_DATA_OUT_COUNT 		= 3;
	}
	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}
 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regg = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regb = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regr = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((ein_regr & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							 (ein_regg & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						     (ein_regb >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regr &= LH_BIT_MASKE_SELEKTOR;
			ein_regg &= LH_BIT_MASKE_SELEKTOR;
			ein_regb &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regb >= ein_regr)
			{
				if (ein_regg >= ein_regr)
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regg;
						ako2 = ein_regg - ein_regr;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						}
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						}
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						}
						#endif
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
						ako1 = ein_regg - ein_regb;
						ako2 = ein_regb - ein_regr;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						}
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						}
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regr	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regr 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						}
						#endif
					}
				}
				else
				{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regb;
						ako1 = ein_regb - ein_regr;
						ako2 = ein_regr - ein_regg;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						}
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						}
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						}
						#endif
				}
			}
			else
			{
				if (ein_regg >= ein_regr)
				{
					ako0 = (LH_ADR_BEREICH_SEL) - ein_regg;
					ako1 = ein_regg - ein_regr;
					ako2 = ein_regr - ein_regb;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						}
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						}
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((0 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						}
						#endif
				}
				else
				{
					if (ein_regb >= ein_regg)
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regb;
						ako2 = ein_regb - ein_regg;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						}
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						}
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
												  ein_regg	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)] + 
											      ein_regg 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						}
						#endif
					}
					else
					{
						ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
						ako1 = ein_regr - ein_regg;
						ako2 = ein_regg - ein_regb;
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						aVal =					 (ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						}
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						}
						#endif
						
						#else
						*output0 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[((ako0 		* paNewVal0[0] + 
												  ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
												  ein_regb	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						if( LH_DATA_OUT_COUNT_4 ){
						paNewVal0++;
						*output3 = My_OutputLut[((ako0 		* paNewVal0[0] + 
											      ako1 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 0) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ako2 		* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)] + 
											      ein_regb 	* paNewVal0[(((((1 << LH_BIT_BREIT_ADR) | 1) << LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						}
						#endif
					}
				}
			}
			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			if( LH_DATA_OUT_COUNT_4 ){
			*output3 |= (*output3 << 8);
			}
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output3 += outputOffset;
					}

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					}
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				if( LH_DATA_OUT_COUNT_4 ){
				*output4 &= Mask;
				}else{
				*output3 &= Mask;
				}
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output4 += outputOffset;
					}
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					}else{
					*output3 &= Mask;
					}
				}
			}
			else
			{
				if( LH_DATA_OUT_COUNT_4 ){
				*output4 = (LH_DATA_OUT_TYPE)*input3;
				}else{
				*output3 = (LH_DATA_OUT_TYPE)*input3;
				}
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					if( LH_DATA_OUT_COUNT_4 ){
					output4 += outputOffset;
					}
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT_4 ){
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input3;
					}else{
					*output3 = (LH_DATA_OUT_TYPE)*input3;
					}
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			if( LH_DATA_OUT_COUNT_4 ){
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			}
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
#endif
}
#endif
#undef LH_CALC_PROC_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\genluts.h ===
/*
	File:		LHGenLuts.h

	Contains:	

	Written by:	

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHGenLuts_h
#define LHGenLuts_h

#define kAbsoluteCalcNothing	0
#define kAbsoluteCalcBefore		1
#define kAbsoluteCalcAfter		2

#define kAbsShiftBeforeDoNDim	FALSE
#define kAbsShiftAfterDoNDim	TRUE


CMError 
FillLuts  ( CMMModelHandle	CMSession,
			CMProfileRef 		srcProfile,
			CMProfileRef			dstProfile );

void
CreateLinearElut16 (	Ptr		theElut,
				   		long	theSize,
				   		long	gridPoints,
				   		long	gridPointsCube);
void
CreateLinearElut ( Ptr		theElut,
				   long		theSize,
				   long		gridPoints,
				   long		gridPointsCube);
void
CreateLinearAlut ( UINT8*	theAlut,
				   long		count );
void
CreateLinearAlut16 ( 	UINT16*	theAlut,
				    	long 	aCount );
CMError
DoMakeGamutForMonitor	( CMLutParamPtr		theLutData,
						  LHCombiDataPtr	theCombiData );
CMError
Extract_MFT_Xlut	  ( CMLutParamPtr	theLutData,  
						LHCombiDataPtr	theCombiData,
						Ptr				profileLutPtr,
						OSType			theTag );
CMError
Extract_MFT_Elut	  ( CMLutParamPtr	theLutData,  
						LHCombiDataPtr	theCombiData,
						Ptr				profileLutPtr,
						OSType			theTag );
CMError
Extract_MFT_Alut	  ( CMLutParamPtr	theLutData,  
						LHCombiDataPtr	theCombiData,
						Ptr				profileLutPtr,
						OSType			theTag  );
						
CMError
ExtractAll_MFT_Luts  (  CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData,
						OSType			theTag );
CMError
Extract_TRC_Alut	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData );
CMError
Extract_TRC_Elut	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData );
CMError
Extract_TRC_Matrix	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData );
CMError
ExtractAll_TRC_Luts  (  CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData );
CMError
Extract_Gray_Luts	 (  CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData );
CMError
GetMatrixFromProfile	( CMLutParamPtr		theLutData,
						  LHCombiDataPtr	theCombiData,
						  OSType			theTag,
						  double			factor );
CMError
ExtractAllLuts    ( CMLutParamPtr	theLutData,
					LHCombiDataPtr	theCombiData );
					
CMError
Create_LH_ProfileSet	( CMMModelPtr    		CMSession,
						  CMConcatProfileSet* 	profileSet,
						  LHConcatProfileSet**	newProfileSet );
CMError
CreateCombi	( CMMModelPtr	    	modelingData,
			  CMConcatProfileSet* 	profileSet,
			  LHConcatProfileSet*	newProfileSet,
			  CMLutParamPtr			finalLutData,	
			  Boolean				createGamutLut );
CMError 
PrepareCombiLUTs	( CMMModelPtr    CMSession,
					  CMConcatProfileSet* profileSet );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\engineup.c ===
/*
	File:		LHCalcEngineOnlyLookup.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#undef LH_DATA_IN_TYPE
#undef LH_DATA_OUT_TYPE
#undef LH_LUT_DATA_TYPE
#undef LH_DATA_IN_COUNT
#undef LH_DATA_OUT_COUNT
#undef LH_DATA_SHR
#undef LH_DATA_SHR_CORR
#undef LH_LUT_DATA_SHR
#undef LH_BIT_BREIT_INTERNAL
#if LH_DATA_IN_SIZE_16
#define LH_DATA_IN_TYPE LH_UINT16
#else
#define LH_DATA_IN_TYPE LH_UINT8
#endif
#if LH_DATA_OUT_SIZE_16
#define LH_DATA_OUT_TYPE LH_UINT16
#else
#define LH_DATA_OUT_TYPE LH_UINT8
#endif
#if LH_LUT_DATA_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#define LH_LUT_DATA_TYPE LH_UINT16
#else
#define LH_BIT_BREIT_INTERNAL 	10
#define LH_LUT_DATA_TYPE LH_UINT8
#endif

#if LH_DATA_IN_COUNT_4
#define LH_DATA_IN_COUNT 		4
#else
#define LH_DATA_IN_COUNT 		3
#endif

#if LH_DATA_OUT_COUNT_4
#define LH_DATA_OUT_COUNT 		4
#else
#define LH_DATA_OUT_COUNT 		3
#endif

#define LH_BIT_MASKE_ADR (((1<<LH_BIT_BREIT_ADR)-1)<< (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR))
#define LH_BIT_BREIT_SELEKTOR (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR)
#define LH_BIT_MASKE_SELEKTOR ((1<<LH_BIT_BREIT_SELEKTOR)-1)

#define LH_ADR_BEREICH_SEL 		(1<<LH_BIT_BREIT_SELEKTOR)

#if LH_LUT_DATA_SIZE_16
#define LH_DATA_SHR               (16-LH_ADR_BREIT_AUS_LUT)  /* z.B. 16+11-10=17 */
#define LH_DATA_SHR_CORR 0		/* notwendig bei LH_DATA_SHR > 16 */
#define LH_LUT_DATA_SHR  16		/* Normierung bei Alutinterpolation */
#else
#define LH_DATA_SHR               (LH_ADR_BREIT_AUS_LUT-8)   /* z.B. 10-8=2 */
#define LH_LUT_DATA_SHR  8		/* Normierung bei Alutinterpolation */
#endif

#if LH_DATA_IN_COUNT_4
{

 	LH_UINT32 ein_regY;
	LH_UINT32 ein_regM;
	LH_UINT32 ein_regC;
	LH_UINT32 ein_regK;
	LH_DATA_IN_TYPE ein_cache[4];
	LH_LUT_DATA_TYPE * paNewVal0;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];
	LH_DATA_IN_TYPE * input4 = (LH_DATA_IN_TYPE *)calcParam->inputData[4];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}

 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
	       		register LH_UINT32 aVal;
    	   	#endif
    	   	#endif
			#if LH_DATA_IN_SIZE_16
			ein_regC = My_InputLut[((ein_cache[0]=*input0)>>( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regC += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regM = My_InputLut[((ein_cache[1]=*input1)>>( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regY = My_InputLut[((ein_cache[2]=*input2)>>( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regK = My_InputLut[((ein_cache[3]=*input3)>>( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK += 1<<LH_BIT_BREIT_SELEKTOR-1;
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regC += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK += 1<<LH_BIT_BREIT_SELEKTOR-1;
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((((ein_regC & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							   (ein_regM & LH_BIT_MASKE_ADR)) << LH_BIT_BREIT_ADR) +
							   (ein_regY & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						       (ein_regK >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
		       				#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	paNewVal0[0]);
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	paNewVal0[1]);
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	paNewVal0[2]);
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	paNewVal0[3]);
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	paNewVal0[0])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	paNewVal0[1])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	paNewVal0[2])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	paNewVal0[3])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	paNewVal0[0])<<LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	paNewVal0[1])<<LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	paNewVal0[2])<<LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	paNewVal0[3])<<LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif

			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			#if LH_DATA_OUT_COUNT_4
			*output3 |= (*output3 << 8);
			#endif
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output3 += outputOffset;
					#endif

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					#endif
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 &= Mask;
				#else
				*output3 &= Mask;
				#endif
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					#else
					*output3 &= Mask;
					#endif
				}
			}
			else
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 = (LH_DATA_OUT_TYPE)*input4;
				#else
				*output3 = (LH_DATA_OUT_TYPE)*input4;
				#endif
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;
					input4 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]) || (*input3 ^ ein_cache[3]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input4;
					#else
					*output3 = (LH_DATA_OUT_TYPE)*input4;
					#endif
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);
			input4 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[4] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			#if LH_DATA_OUT_COUNT_4
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			#endif
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#else
{

 	LH_UINT32 ein_regb;
	LH_UINT32 ein_regg;
	LH_UINT32 ein_regr;
	LH_DATA_IN_TYPE ein_cache[3];
	LH_LUT_DATA_TYPE * paNewVal0;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}
 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
	       		register LH_UINT32 aVal;
    	   	#endif
    	   	#endif
			#if LH_DATA_IN_SIZE_16
			ein_regr = My_InputLut[((ein_cache[0]=*input0)>>( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regr += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regg = My_InputLut[((ein_cache[1]=*input1)>>( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regb = My_InputLut[((ein_cache[2]=*input2)>>( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb += 1<<LH_BIT_BREIT_SELEKTOR-1;
			#else
			ein_regr = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regr += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regg = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regg += 1<<LH_BIT_BREIT_SELEKTOR-1;
			ein_regb = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regb += 1<<LH_BIT_BREIT_SELEKTOR-1;
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((ein_regr & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							 (ein_regg & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						     (ein_regb >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
						#if LH_LUT_DATA_SIZE_16
						#if LH_DATA_OUT_SIZE_16
		   		
						aVal =					 ( paNewVal0[0]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
				       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 ( paNewVal0[0]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
				       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						paNewVal0++;
						aVal =					 ( paNewVal0[0]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
				       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						aVal =					 ( paNewVal0[0]);
						aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
						aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
						ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
						aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
				       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
						#endif
						
						#else
						*output0 = My_OutputLut[(( paNewVal0[0])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output1 = My_OutputLut[(( paNewVal0[0])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
						paNewVal0++;
						*output2 = My_OutputLut[(( paNewVal0[0])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[(( paNewVal0[0])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
						#endif
						#endif
						
						#else
						*output0 = My_OutputLut[(( paNewVal0[0])<<LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output1 = My_OutputLut[(( paNewVal0[0])<<LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
						paNewVal0++;
						*output2 = My_OutputLut[(( paNewVal0[0])<<LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
						#if LH_DATA_OUT_COUNT_4
						paNewVal0++;
						*output3 = My_OutputLut[(( paNewVal0[0])<<LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
						#endif
						#endif

			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			#if LH_DATA_OUT_COUNT_4
			*output3 |= (*output3 << 8);
			#endif
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output3 += outputOffset;
					#endif

					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					#endif
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 &= Mask;
				#else
				*output3 &= Mask;
				#endif
				while (--i)
				{
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 &= Mask;
					#else
					*output3 &= Mask;
					#endif
				}
			}
			else
			{
				#if LH_DATA_OUT_COUNT_4
				*output4 = (LH_DATA_OUT_TYPE)*input3;
				#else
				*output3 = (LH_DATA_OUT_TYPE)*input3;
				#endif
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					input2 += inputOffset;
					input3 += inputOffset;

					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					#if LH_DATA_OUT_COUNT_4
					output4 += outputOffset;
					#endif
					if ((*input0 ^ ein_cache[0]) || (*input1 ^ ein_cache[1]) || (*input2 ^ ein_cache[2]))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					#if LH_DATA_OUT_COUNT_4
					*output3 = output3[-outputOffset];
					*output4 = (LH_DATA_OUT_TYPE)*input3;
					#else
					*output3 = (LH_DATA_OUT_TYPE)*input3;
					#endif
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);
			input2 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[2] + j * calcParam->cmInputBytesPerLine);
			input3 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[3] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			#if LH_DATA_OUT_COUNT_4
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
			#endif
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#endif
#undef LH_CALC_PROC_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\frgmnt16.c ===
/*
	File:		LHFragment16.c

	Contains:	ALUT stuff (16 bit) for Color Sync

	Version:	

	Written by:	H.Siegeritz

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#if GENERATING68K
/*	#include <ConditionalMacros.h> */

	#define CM_Doub	extended
	extern CM_Doub pow(CM_Doub _x,CM_Doub _y);
#else
	#define CM_Doub	double
	#include <math.h>
#endif

#ifndef LHFragment_h
#include "Fragment.h"
#endif

#ifndef LHStdConversionLuts_h
#include "StdConv.h"
#endif

#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kLHFragment16ID
#endif
#endif


/*-----prototypes for local functions-----*/
void	
Fill_inverseGamma_ushort_ALUT	( unsigned short *usALUT, char addrBits,
								  unsigned short gamma_u8_8);

/* ______________________________________________________________________

	CMError
		Fill_inverse_ushort_ALUT_from_CurveTag(	icCurveType		*pCurveTag,
												unsigned short	*usALUT,
												char			addrBits )
	Abstract:
		extracts output luts out of cmSigCurveType tag and converts them
		to desired format: (2 ^ addrBits) values in a range from 0 to 65535
		NOTE: not-monotone CurveTags are manipulated
		NOTE: Memory for the LUT has to be allocated before !

	Params:
		pCurveTag		(in)		extract input LUT from this
		usALUT			(in/out)	result LUT
		addrBits		(in)		2 ^ addrBits values are requested
		
	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_inverse_ushort_ALUT_from_CurveTag(	icCurveType		*pCurveTag,
										unsigned short	*usALUT,
										char			addrBits )
{
	unsigned long	i, inCount, outCount, clipIndex, ulFactor;
	unsigned long	intpFirst, intpLast, halfStep, ulAux, target;
	short			monot;
	unsigned short	*inCurve, *usPtr, *stopPtr;
	double			flFactor;
#ifdef DEBUG_OUTPUT
	OSErr err=noErr;
#endif
	LH_START_PROC("Fill_inverse_ushort_ALUT_from_CurveTag")
	
    if( pCurveTag->base.sig != icSigCurveType	/* 'curv' */
	 || addrBits > 15 )
	 {
#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugErrorInfo) )
			DebugPrint(" Fill_inverse_ushort_ALUT_from_CurveTag ERROR:   addrBits= %d\n",addrBits);
#endif
		return(cmparamErr);
	 }
	
	outCount  = 1 << addrBits;
	clipIndex = outCount - 1;

		/*---special cases:---*/

	if(pCurveTag->curve.count == 0)		/*---identity---*/
	{
		ulFactor = ((unsigned long)65535 << 16) / clipIndex;		/* use all 32 bits */
		
		for(i=0; i<clipIndex; i++)
			usALUT[i] = (unsigned short)((i * ulFactor + 32767) >> 16);
	
		for(i=clipIndex; i<outCount; i++)
			usALUT[i] = 0xFFFF;
	
		return(noErr);
	}
	else if(pCurveTag->curve.count == 1)	/*---gamma curve---*/
	{
		Fill_inverseGamma_ushort_ALUT(usALUT, addrBits, pCurveTag->curve.data[0]);
		return(noErr);
	}
	
		/*---ordinary case:---*/
	
	inCount = pCurveTag->curve.count;
	inCurve = pCurveTag->curve.data;
		
		 /* exact matching factor needed for special values: */
	flFactor = (double)clipIndex / 65535.;
	
	halfStep = clipIndex >> 1;		/* lessen computation incorrectness */
	
				/* ascending or descending ? */
	for(monot=0, i=1; i<inCount; i++)
	{
		if(inCurve[i-1] < inCurve[i])
			monot++;
		else if(inCurve[i-1] > inCurve[i])
			monot--;
	}
	
	if(monot >= 0)	/* curve seems to be ascending */
	{
		for(i=1; i<inCount; i++)
			if(inCurve[i-1] > inCurve[i])
				inCurve[i] = inCurve[i-1];	/* correct not-invertible parts */
		
		intpFirst = (unsigned long)(inCurve[0] * flFactor + 0.9999);
		intpLast  = (unsigned long)(inCurve[inCount-1] * flFactor);
		
		for(i=0; i<intpFirst; i++)			/* fill lacking area low */
			usALUT[i] = 0;
		for(i=intpLast+1; i<outCount; i++)	/* fill lacking area high */
			usALUT[i] = 0xFFFF;

			/* interpolate remaining values: */
		usPtr   = inCurve;
		stopPtr = inCurve + inCount - 2; /* stops incrementation */
		
		for(i=intpFirst; i<=intpLast; i++)
		{
			target = (0x0FFFF * i + halfStep)  / clipIndex;
			while(*(usPtr+1) < target && usPtr < stopPtr)
				usPtr++;					/* find interval */
			
			ulAux = ((unsigned long)(usPtr - inCurve) << 16) / (inCount - 1);
			if(*(usPtr+1) != *usPtr)
			{
				ulAux += ((target - (unsigned long)*usPtr) << 16)
					  / ( (*(usPtr+1) - *usPtr) * (inCount - 1) );
				
				if(ulAux & 0x10000)   /* *(usPtr+1) was required */
					ulAux = 0xFFFF;
			}
			
			usALUT[i] = (unsigned short)ulAux;
		}
	}
	else			/* curve seems to be descending */
	{
		for(i=1; i<inCount; i++)
			if(inCurve[i-1] < inCurve[i])
				inCurve[i] = inCurve[i-1];	/* correct not-invertible parts */
		
		intpFirst = (unsigned long)(inCurve[inCount-1] * flFactor + 0.9999);
		intpLast  = (unsigned long)(inCurve[0] * flFactor);
		
		for(i=0; i<intpFirst; i++)			/* fill lacking area low */
			usALUT[i] = 0xFFFF;
		for(i=intpLast+1; i<outCount; i++)	/* fill lacking area high */
			usALUT[i] = 0;

			/* interpolate remaining values: */
		usPtr   = inCurve + inCount - 1;
		stopPtr = inCurve + 1; 		/* stops decrementation */
		
		for(i=intpFirst; i<=intpLast; i++)
		{
			target = (0x0FFFF * i + halfStep)  / clipIndex;
			while(*(usPtr-1) < target && usPtr > stopPtr)
				usPtr--;					/* find interval */
			
			ulAux = ((unsigned long)(usPtr-1 - inCurve) << 16) / (inCount - 1);
			if(*(usPtr-1) != *usPtr)
			{
				ulAux += (((unsigned long)*(usPtr-1) - target) << 16)
					  / ( (*(usPtr-1) - *usPtr) * (inCount - 1) );
				
				if(ulAux & 0x10000)
					ulAux = 0xFFFF;
			}
			
			usALUT[i] = (unsigned short)ulAux;
		}
	}
	

	LH_END_PROC("Fill_inverse_ushort_ALUT_from_CurveTag")
	return(noErr);
}

/*   _____________________________________________________________________ */

void
Fill_inverseGamma_ushort_ALUT(	unsigned short	*usALUT,
								char			addrBits,
								unsigned short	gamma_u8_8 )
{
	unsigned long	i, j, outCount, step, stopit;
	long			leftVal, Diff, lAux;
	CM_Doub			invGamma, x, xFactor;
	long			clipIndex;
#ifdef DEBUG_OUTPUT
	OSErr err = noErr;
#endif
	LH_START_PROC("Fill_inverseGamma_ushort_ALUT")

	outCount = 0x1 << addrBits;
	
	invGamma  = 256. / (CM_Doub)gamma_u8_8;
	clipIndex = outCount - 1;
	xFactor   = 1. / (CM_Doub)clipIndex;
	
	if(addrBits <= 6)		/* up to 64 - 2 float.computations */
		step = 1;
	else
		step = 0x1 << (addrBits - 6);		/* more would take too long */
	
	usALUT[0]          = 0;			/* these two...	*/
	usALUT[outCount-1] = 0xFFFF;	/* ...are fixed	*/
	
	for(i=step; i<outCount-1; i+=step)
	{
		x = (CM_Doub)i * xFactor;
		if(x > 1.)
			x = 1.;		/* clipping in the end of ALUT */
		
		usALUT[i] = (unsigned short)( pow(x,invGamma) * 65535.0 + 0.5);
	}
	
		/*---fill intervals - except for last, which is odd:---*/
	for(i=0; i<outCount-step; i+=step)
	{
		leftVal = (long)usALUT[i];
		Diff    = (long)usALUT[i + step] - leftVal;
			
		for(j=1; j<step; j++)
		{
			lAux = ( (Diff * j << 8) / step + 128 ) >> 8;

			usALUT[i + j] = (unsigned short)(leftVal + lAux);
		}
	}
	
		/*---fill last interval:---*/
	i       = outCount - step;
	leftVal = (long)usALUT[i];
	Diff    = 0x0FFFF - leftVal;	/* 0xFFFF for 1.0 */
		
	for(j=1; j<step-1; j++)		/* stops here if step <= 2 */
	{
		lAux = ( (Diff * j << 8) / (step - 1) + 128 ) >> 8;

		usALUT[i + j] = (unsigned short)(leftVal + lAux);
	}
	
		/*--overwrite sensitive values depending on Gamma:--*/
	if(addrBits > 6 && invGamma < 1.0)		/* ...if lower part is difficult */
	{
		stopit = 0x1 << (addrBits - 6);
		
		for(i=1; i<stopit; i++)
		{
			x         = (CM_Doub)i * xFactor;
			usALUT[i] = (unsigned short)( pow(x,invGamma) * 65535.0);
		}
	}

	LH_END_PROC("Fill_inverseGamma_ushort_ALUT")
}

/* ______________________________________________________________________

	CMError
	Fill_ushort_ALUTs_from_lut8Tag( CMLutParamPtr	theLutData,
								  	Ptr				profileALuts,
								  	char			addrBits )
	Abstract:
		extracts output luts out of CMLut8Type tag and converts them
		to desired format: (2 ^ addrBits) values in a range from 0 to 65535

	Params:
		theLutData			(in/out)	Ptr to structure that holds all the luts...
		profileALuts		(in)		Ptr to the profile's output luts
		addrBits			(in)		2 ^ addrBits values are requested
		
	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_ushort_ALUTs_from_lut8Tag(	CMLutParamPtr	theLutData,
							  	Ptr				profileALuts,
							  	char			addrBits )
{
	long			i, j;
	unsigned char	*curOutLut;
	unsigned char	*profAluts = (unsigned char *)profileALuts;
	unsigned short	*curALUT;
	long			count, clipIndex;
	long			factor, fract, baseInd, lAux, leftVal, rightVal;
	OSErr			err = noErr;
	LUT_DATA_TYPE	localAlut = nil;
	unsigned short	*localAlutPtr;
	long			theAlutSize;
	
	LH_START_PROC("Fill_ushort_ALUTs_from_lut8Tag")
	
	count     = 1 << addrBits;						/* addrBits is always >= 8 */
	clipIndex = count - 1;
	
	theAlutSize = theLutData->colorLutOutDim * count * sizeof(unsigned short);
	localAlut   = ALLOC_DATA(theAlutSize + 2, &err);
	if (err)
		goto CleanupAndExit;
	
	LOCK_DATA(localAlut);
	localAlutPtr = (unsigned short *)DATA_2_PTR(localAlut);
	
	factor = ((255 << 12) + clipIndex/2) / clipIndex;		/* for adjusting the indices */
	
	for(i=0; i<theLutData->colorLutOutDim; i++)
	{
		curOutLut = profAluts + (i << 8);		/* these are unsigned char's */
		curALUT   = localAlutPtr + i * count;	/* these are unsigned short's */
		
		for(j=0; j<=clipIndex-1; j++)
		{
			lAux    = j * factor;
			baseInd = (unsigned long)lAux >> 12;
			fract   = lAux & 0x0FFF;
			
			leftVal = (long)curOutLut[baseInd];
			leftVal = (leftVal << 8) + leftVal;		/* 0xFF -> 0xFFFF */
			
			if(fract)
			{
				rightVal = (long)curOutLut[baseInd + 1];
				rightVal = (rightVal << 8) + rightVal;		/* 0xFF -> 0xFFFF */
				
				lAux = rightVal - leftVal;
				lAux = (lAux * fract + 0x0800) >> 12;
				
				curALUT[j] = (unsigned short)(leftVal + lAux);
			}
			else
				curALUT[j] = (unsigned short)leftVal;
		}
		
		leftVal = (long)curOutLut[255];
		leftVal = (leftVal << 8) + leftVal;		/* 0xFF -> 0xFFFF */
		curALUT[j] = (unsigned short)leftVal;
		
		for(j=clipIndex+1; j<count; j++)		/* unused indices, clip these */
			curALUT[j] = curALUT[clipIndex];
	}
	
	UNLOCK_DATA(localAlut);
	theLutData->outputLut = localAlut;
	localAlut = nil;
CleanupAndExit:
	localAlut = DISPOSE_IF_DATA(localAlut);

	LH_END_PROC("Fill_ushort_ALUTs_from_lut8Tag")
	return err;
}

/* ______________________________________________________________________

	CMError
	Fill_ushort_ALUTs_from_lut16Tag(CMLutParamPtr	theLutData,
									Ptr				profileALuts,
									char			addrBits,
								    long			outputTableEntries )
	Abstract:
		extracts output luts out of CMLut16Type tag and converts them
		to desired format: (2 ^ addrBits) values in a range from 0 to 65535

	Params:
		theLutData			(in/out)	Ptr to structure that holds all the luts...
		profileALuts		(in)		Ptr to the profile's output luts
		addrBits			(in)		2 ^ addrBits values are requested
		outputTableEntries	(in)		number of entries in the output lut (up to 4096)
		
	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_ushort_ALUTs_from_lut16Tag(CMLutParamPtr	theLutData,
								Ptr				profileALuts,
								char			addrBits,
							    long			outputTableEntries )
{
	long			i;
	unsigned short	*curOutLut;
	unsigned short	*curALUT;
	unsigned long	ulIndFactor, j;
	long			count, clipIndex, outTabLen;
	long			fract, baseInd, lAux, leftVal, rightVal;
	unsigned short	*profALUTs = (unsigned short *)profileALuts;
	OSErr			err = noErr;
	LUT_DATA_TYPE	localAlut = nil;
	unsigned short	*localAlutPtr;
	long			theAlutSize;
	
	LH_START_PROC("Fill_ushort_ALUTs_from_lut16Tag")
	
	count     = 1 << addrBits;						/* addrBits is always >= 8 */
	clipIndex = count - 1;

	theAlutSize = theLutData->colorLutOutDim * count * sizeof(unsigned short);
	localAlut   = ALLOC_DATA(theAlutSize + 2, &err);
	if (err)
		goto CleanupAndExit;
	
	outTabLen = outputTableEntries;			/* <= 4096 acc. to the spec */
	if(outTabLen > 4096)
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	
	ulIndFactor = (((unsigned long)outTabLen - 1) << 20)
				/ (unsigned long)clipIndex;				/* for adjusting the indices */
	
	LOCK_DATA(localAlut);
	localAlutPtr = (unsigned short *)DATA_2_PTR(localAlut);
	
	for(i=0; i<theLutData->colorLutOutDim; i++)
	{
		curOutLut = profALUTs + i * outTabLen;
		curALUT   = localAlutPtr + i * count;
		
		for(j=0; j<=(unsigned long)clipIndex; j++)
		{
			lAux    = (long)( (j * ulIndFactor + 16) >> 5 );		/* n.b: j is unsigned long ! */
			baseInd = (unsigned long)lAux >> 15;
			fract   = lAux & 0x7FFF;	/* 15 bits for interpolation */
			
			if(fract)
			{
				leftVal  = (long)curOutLut[baseInd];
				rightVal = (long)curOutLut[baseInd + 1];
				
				lAux = rightVal - leftVal;
				lAux = (lAux * fract + 16383) >> 15;
				
				curALUT[j] = (unsigned short)(leftVal + lAux);
			}
			else
				curALUT[j] = curOutLut[baseInd];
		}
		
		for(j=clipIndex+1; j<(unsigned long)count; j++)		/* unused indices, clip these */
			curALUT[j] = curALUT[clipIndex];
	}
	
	UNLOCK_DATA(localAlut);
	theLutData->outputLut = localAlut;
	localAlut = nil;
CleanupAndExit:
	localAlut = DISPOSE_IF_DATA(localAlut);

	LH_END_PROC("Fill_ushort_ALUTs_from_lut16Tag")
	return err;
}

/* ______________________________________________________________________

	CMError
		DoAbsoluteShiftForPCS_Cube16(	unsigned short	*theCube,
										long			count,
										CMProfileRef	theProfile,
										Boolean			pcsIsXYZ,
										Boolean			afterInput )
	Abstract:
		Performs color shift necessary for absolute colorimetry. Data of
		the cube points are in linear XYZ (16 bit) or in Lab (16 bit).
		Either conversion just after entering PCS or before leaving PCS (inverse
		operation). NOTE: for devices with colorant matrices this operation is
		done much faster by manipulating the matrix.

	Params:
		theCube			(in/out)	cube grid points
		count			(in)		number of points
		theProfile		(in)		contains media white point
		pcsIsXYZ		(in)		XYZ/Lab, saves one file access to profile
		afterInput		(in)		direct or inverse operation

	Return:
		noErr			successful
   _____________________________________________________________________ */
CMError	DoAbsoluteShiftForPCS_Cube16(	unsigned short	*theCube,
										long			count,
										CMProfileRef	theProfile,
										Boolean			pcsIsXYZ,
										Boolean			afterInput )
{
	unsigned long		i, uLong;
	unsigned short		*usPtr;
   CMError				err = noErr;
	unsigned long 		elementSize;
	icXYZType			curMediaWhite;
	double				xFactor, yFactor, zFactor;
	unsigned long		intFactorX, intFactorY, intFactorZ;
	unsigned long		roundX, roundY, roundZ;
	unsigned long		shiftX, shiftY, shiftZ;
	
	LH_START_PROC("DoAbsoluteShiftForPCS_Cube16")
	
	elementSize = sizeof(icXYZType);
	err = CMGetProfileElement(theProfile, icSigMediaWhitePointTag, &elementSize, &curMediaWhite);
#ifdef IntelMode
   SwapLongOffset( &curMediaWhite.base.sig, 0, 4 );
   SwapLongOffset( &curMediaWhite, (LONG)((char*)&curMediaWhite.data.data[0]-(char*)&curMediaWhite), elementSize );
#endif
	if(err)
	{
		if(err == cmElementTagNotFound)		/* take D50 and do nothing */
			return(noErr);
		else
			return(err);
	}
	
		/*--- preliminary matching factors: ---*/
	xFactor = ((double)curMediaWhite.data.data[0].X) / 65536. / 0.9642;
	if(xFactor > 100.)
		xFactor = 100.;			/* evil profile */
	else if(xFactor < 0.01)
		xFactor = 0.01;

	yFactor = ((double)curMediaWhite.data.data[0].Y) / 65536.;
	if(yFactor > 100.)
		yFactor = 100.;
	else if(yFactor < 0.01)
		yFactor = 0.01;

	zFactor = ((double)curMediaWhite.data.data[0].Z) / 65536. / 0.8249;
	if(zFactor > 100.)
		zFactor = 100.;
	else if(zFactor < 0.01)
		zFactor = 0.01;

	if( ( xFactor < 1.+1.E-3 && xFactor > 1.-1.E-3 ) &&
		( yFactor < 1.+1.E-3 && yFactor > 1.-1.E-3 ) &&
		( zFactor < 1.+1.E-3 && zFactor > 1.-1.E-3 ) )
			return noErr; /* do nothing if MediaWhite is D50 */
	
	if(!afterInput)		/* back to device space (for example with B2A1 table) */
	{
		xFactor = 1. / xFactor;
		yFactor = 1. / yFactor;
		zFactor = 1. / zFactor;
	}
	
		/*--- integer factors for speed: ---*/
	intFactorX = (unsigned long)(xFactor * 65536. * 64.);	/* probably too long...	*/
	intFactorY = (unsigned long)(yFactor * 65536. * 64.);	/* ...adding 22 bits	*/
	intFactorZ = (unsigned long)(zFactor * 65536. * 64.);
	
	roundX = roundY = roundZ = 0x1FFFFF;	/* 2^21 - 1 */
	shiftX = shiftY = shiftZ = 22;
	
	while(intFactorX & 0xFFFF0000)	/* stay within 16 bits to prevent product overflow */
	{
		intFactorX >>= 1;
		roundX     >>= 1;
		shiftX      -= 1;
	}
	
	while(intFactorY & 0xFFFF0000)
	{
		intFactorY >>= 1;
		roundY     >>= 1;
		shiftY      -= 1;
	}
	
	while(intFactorZ & 0xFFFF0000)
	{
		intFactorZ >>= 1;
		roundZ     >>= 1;
		shiftZ      -= 1;
	}
	
		/*--- perform matching: ---*/
	if(!pcsIsXYZ)		/* 16 bit linear Lab  to XYZ before and afterwards */
		Lab2XYZ_forCube16(theCube, count);
	
	usPtr = theCube;

	for(i=0; i<(unsigned long)count; i++)
	{
		uLong = ((unsigned long)(*usPtr) * intFactorX + roundX) >> shiftX;
		if(uLong > 0x0FFFF)
			uLong = 0xFFFF;				/* clip to 2.0 */
		*usPtr++ = (unsigned short)uLong;
		
		uLong = ((unsigned long)(*usPtr) * intFactorY + roundY) >> shiftY;
		if(uLong > 0x0FFFF)
			uLong = 0xFFFF;
		*usPtr++ = (unsigned short)uLong;
		
		uLong = ((unsigned long)(*usPtr) * intFactorZ + roundZ) >> shiftZ;
		if(uLong > 0x0FFFF)
			uLong = 0xFFFF;
		*usPtr++ = (unsigned short)uLong;
	}

	if(!pcsIsXYZ)		/* back to 16 bit Lab */
		XYZ2Lab_forCube16(theCube, count);


	LH_END_PROC("DoAbsoluteShiftForPCS_Cube16")
	return(noErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\gen.c ===
/*
	File:		LHCalcGenerator.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	

*/

/* #define LH_CALC_ENGINE_SMALL see LHGeneralIncs.h */

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHCalcEngine_h
#include "CalcEng.h"
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCalcGeneratorID
#endif

#define LH_ADR_BREIT_EIN_LUT   	adr_breite_elut
#define LH_ADR_BREIT_AUS_LUT   	adr_breite_alut

#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4

#if LH_Calc3to3_Di8_Do8_Lut8_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di8_Do8_Lut8_G16"
#include "EngineSm.c"

CMError LHCalc3to3_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do8_Lut8_G16( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do8_Lut8_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		5

#if LH_Calc3to3_Di8_Do8_Lut8_G32 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di8_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di8_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di8_Do8_Lut8_G32"
#include "EngineSm.c"
CMError LHCalc3to3_Di8_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do8_Lut8_G32( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di8_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do8_Lut8_G32( calcParam, lutParam, 1 );
}
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4

#if LH_Calc3to3_Di8_Do8_Lut16_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di8_Do8_Lut16_G16"
#include "EngineSm.c"
CMError LHCalc3to3_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do8_Lut16_G16( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do8_Lut16_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		5

#if LH_Calc3to3_Di8_Do8_Lut16_G32 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di8_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di8_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di8_Do8_Lut16_G32"
#include "EngineSm.c"
CMError LHCalc3to3_Di8_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do8_Lut16_G32( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di8_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do8_Lut16_G32( calcParam, lutParam, 1 );
}
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4

#if LH_Calc3to3_Di8_Do16_Lut8_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di8_Do16_Lut8_G16"
#include "EngineSm.c"

CMError LHCalc3to3_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do16_Lut8_G16( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do16_Lut8_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		5

#if LH_Calc3to3_Di8_Do16_Lut8_G32 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di8_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di8_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di8_Do16_Lut8_G32"
#include "EngineSm.c"
CMError LHCalc3to3_Di8_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do16_Lut8_G32( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di8_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do16_Lut8_G32( calcParam, lutParam, 1 );
}
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4

#if LH_Calc3to3_Di8_Do16_Lut16_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di8_Do16_Lut16_G16"
#include "EngineSm.c"
CMError LHCalc3to3_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do16_Lut16_G16( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do16_Lut16_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		5

#if LH_Calc3to3_Di8_Do16_Lut16_G32 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di8_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di8_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di8_Do16_Lut16_G32"
#include "EngineSm.c"
CMError LHCalc3to3_Di8_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do16_Lut16_G32( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di8_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di8_Do16_Lut16_G32( calcParam, lutParam, 1 );
}
#endif

#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4

#if LH_Calc4to3_Di8_Do8_Lut8_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di8_Do8_Lut8_G16"
#include "EngineSm.c"
CMError LHCalc4to3_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do8_Lut8_G16( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do8_Lut8_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		3

#if LH_Calc4to3_Di8_Do8_Lut8_G8 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di8_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di8_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di8_Do8_Lut8_G8"
#include "EngineSm.c"
CMError LHCalc4to3_Di8_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do8_Lut8_G8( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di8_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do8_Lut8_G8( calcParam, lutParam, 1 );
}
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4

#if LH_Calc4to3_Di8_Do8_Lut16_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di8_Do8_Lut16_G16"
#include "EngineSm.c"
CMError LHCalc4to3_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do8_Lut16_G16( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do8_Lut16_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		3

#if LH_Calc4to3_Di8_Do8_Lut16_G8 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di8_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di8_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di8_Do8_Lut16_G8"
#include "EngineSm.c"
CMError LHCalc4to3_Di8_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do8_Lut16_G8( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di8_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do8_Lut16_G8( calcParam, lutParam, 1 );
}
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4

#if LH_Calc4to3_Di8_Do16_Lut8_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di8_Do16_Lut8_G16"
#include "EngineSm.c"
CMError LHCalc4to3_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do16_Lut8_G16( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do16_Lut8_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		3

#if LH_Calc4to3_Di8_Do16_Lut8_G8 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di8_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di8_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di8_Do16_Lut8_G8"
#include "EngineSm.c"
CMError LHCalc4to3_Di8_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do16_Lut8_G8( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di8_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do16_Lut8_G8( calcParam, lutParam, 1 );
}
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4

#if LH_Calc4to3_Di8_Do16_Lut16_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di8_Do16_Lut16_G16"
#include "EngineSm.c"
CMError LHCalc4to3_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do16_Lut16_G16( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do16_Lut16_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		3

#if LH_Calc4to3_Di8_Do16_Lut16_G8 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di8_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di8_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di8_Do16_Lut16_G8"
#include "EngineSm.c"
CMError LHCalc4to3_Di8_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do16_Lut16_G8( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di8_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di8_Do16_Lut16_G8( calcParam, lutParam, 1 );
}
#endif

#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4

#if LH_Calc3to3_Di16_Do8_Lut8_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di16_Do8_Lut8_G16"
#include "EngineSm.c"

CMError LHCalc3to3_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do8_Lut8_G16( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do8_Lut8_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		5

#if LH_Calc3to3_Di16_Do8_Lut8_G32 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di16_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di16_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di16_Do8_Lut8_G32"
#include "EngineSm.c"
CMError LHCalc3to3_Di16_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do8_Lut8_G32( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di16_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do8_Lut8_G32( calcParam, lutParam, 1 );
}
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4

#if LH_Calc3to3_Di16_Do8_Lut16_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di16_Do8_Lut16_G16"
#include "EngineSm.c"
CMError LHCalc3to3_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do8_Lut16_G16( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do8_Lut16_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		5

#if LH_Calc3to3_Di16_Do8_Lut16_G32 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di16_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di16_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di16_Do8_Lut16_G32"
#include "EngineSm.c"
CMError LHCalc3to3_Di16_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do8_Lut16_G32( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di16_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do8_Lut16_G32( calcParam, lutParam, 1 );
}
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4

#if LH_Calc3to3_Di16_Do16_Lut8_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di16_Do16_Lut8_G16"
#include "EngineSm.c"

CMError LHCalc3to3_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do16_Lut8_G16( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do16_Lut8_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		5

#if LH_Calc3to3_Di16_Do16_Lut8_G32 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di16_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di16_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di16_Do16_Lut8_G32"
#include "EngineSm.c"
CMError LHCalc3to3_Di16_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do16_Lut8_G32( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di16_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do16_Lut8_G32( calcParam, lutParam, 1 );
}
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4

#if LH_Calc3to3_Di16_Do16_Lut16_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di16_Do16_Lut16_G16"
#include "EngineSm.c"
CMError LHCalc3to3_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do16_Lut16_G16( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do16_Lut16_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		5

#if LH_Calc3to3_Di16_Do16_Lut16_G32 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc3toX_Di16_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc3toX_Di16_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc3toX_Di16_Do16_Lut16_G32"
#include "EngineSm.c"
CMError LHCalc3to3_Di16_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do16_Lut16_G32( calcParam, lutParam, 0 );
}
CMError LHCalc3to4_Di16_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc3toX_Di16_Do16_Lut16_G32( calcParam, lutParam, 1 );
}
#endif

#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4

#if LH_Calc4to3_Di16_Do8_Lut8_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di16_Do8_Lut8_G16"
#include "EngineSm.c"
CMError LHCalc4to3_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do8_Lut8_G16( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do8_Lut8_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		3

#if LH_Calc4to3_Di16_Do8_Lut8_G8 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di16_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di16_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di16_Do8_Lut8_G8"
#include "EngineSm.c"
CMError LHCalc4to3_Di16_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do8_Lut8_G8( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di16_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do8_Lut8_G8( calcParam, lutParam, 1 );
}
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4

#if LH_Calc4to3_Di16_Do8_Lut16_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di16_Do8_Lut16_G16"
#include "EngineSm.c"
CMError LHCalc4to3_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do8_Lut16_G16( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do8_Lut16_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		3

#if LH_Calc4to3_Di16_Do8_Lut16_G8 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di16_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di16_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di16_Do8_Lut16_G8"
#include "EngineSm.c"
CMError LHCalc4to3_Di16_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do8_Lut16_G8( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di16_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do8_Lut16_G8( calcParam, lutParam, 1 );
}
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4

#if LH_Calc4to3_Di16_Do16_Lut8_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di16_Do16_Lut8_G16"
#include "EngineSm.c"
CMError LHCalc4to3_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do16_Lut8_G16( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do16_Lut8_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		3

#if LH_Calc4to3_Di16_Do16_Lut8_G8 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di16_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di16_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di16_Do16_Lut8_G8"
#include "EngineSm.c"
CMError LHCalc4to3_Di16_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do16_Lut8_G8( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di16_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do16_Lut8_G8( calcParam, lutParam, 1 );
}
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4

#if LH_Calc4to3_Di16_Do16_Lut16_G16 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di16_Do16_Lut16_G16"
#include "EngineSm.c"
CMError LHCalc4to3_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do16_Lut16_G16( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do16_Lut16_G16( calcParam, lutParam, 1 );
}
#endif

#undef LH_BIT_BREIT_ADR

#define LH_BIT_BREIT_ADR		3

#if LH_Calc4to3_Di16_Do16_Lut16_G8 == LH_CALC_USE_SMALL_ENGINE
CMError LHCalc4toX_Di16_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 );
CMError LHCalc4toX_Di16_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam
									, char LH_DATA_OUT_COUNT_4
									 )
#define LH_CALC_PROC_NAME "LHCalc4toX_Di16_Do16_Lut16_G8"
#include "EngineSm.c"
CMError LHCalc4to3_Di16_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do16_Lut16_G8( calcParam, lutParam, 0 );
}
CMError LHCalc4to4_Di16_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
{
	return LHCalc4toX_Di16_Do16_Lut16_G8( calcParam, lutParam, 1 );
}
#endif



					/* -------------- End of SMALL Version ---------------- */

#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut8_G16"
#include "Engine.c"
#endif

#if LH_CALC_USE_ADDITIONAL_OLD_CODE && LH_Calc3to3_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do8_Lut8_G16_Old( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut8_G16_Old"
#include "EngineOl.c"
#endif

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di8_Do8_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut8_G32"
#include "Engine.c"
#endif

#if LH_CALC_USE_ADDITIONAL_OLD_CODE && LH_Calc3to3_Di8_Do8_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do8_Lut8_G32_Old( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut8_G32_Old"
#include "EngineOl.c"
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di8_Do8_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di8_Do8_Lut16_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut16_G32"
#include "Engine.c"
#endif


#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di8_Do16_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do16_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di8_Do16_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do16_Lut8_G32"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di8_Do16_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do16_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di8_Do16_Lut16_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di8_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do16_Lut16_G32"
#include "Engine.c"
#endif


#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di16_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do8_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di16_Do8_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di16_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do8_Lut8_G32"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di16_Do8_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do8_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di16_Do8_Lut16_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di16_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do8_Lut16_G32"
#include "Engine.c"
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di16_Do16_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do16_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di16_Do16_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di16_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do16_Lut8_G32"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to3_Di16_Do16_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do16_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to3_Di16_Do16_Lut16_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to3_Di16_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do16_Lut16_G32"
#include "Engine.c"
#endif


#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut8_G16"
#include "Engine.c"
#endif

#if LH_CALC_USE_ADDITIONAL_OLD_CODE && LH_Calc3to4_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do8_Lut8_G16_Old( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut8_G16_Old"
#include "EngineOl.c"
#endif

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di8_Do8_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut8_G32"
#include "Engine.c"
#endif

#if LH_CALC_USE_ADDITIONAL_OLD_CODE && LH_Calc3to4_Di8_Do8_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do8_Lut8_G32_Old( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut8_G32_Old"
#include "EngineOl.c"
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di8_Do8_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di8_Do8_Lut16_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut16_G32"
#include "Engine.c"
#endif


#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di8_Do16_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do16_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di8_Do16_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do16_Lut8_G32"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di8_Do16_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do16_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di8_Do16_Lut16_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di8_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do16_Lut16_G32"
#include "Engine.c"
#endif


#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di16_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do8_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di16_Do8_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di16_Do8_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do8_Lut8_G32"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di16_Do8_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do8_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di16_Do8_Lut16_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di16_Do8_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do8_Lut16_G32"
#include "Engine.c"
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di16_Do16_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do16_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di16_Do16_Lut8_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di16_Do16_Lut8_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do16_Lut8_G32"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc3to4_Di16_Do16_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do16_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


#if LH_Calc3to4_Di16_Do16_Lut16_G32 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc3to4_Di16_Do16_Lut16_G32( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do16_Lut16_G32"
#include "Engine.c"
#endif


#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di8_Do8_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut8_G8"
#include "Engine.c"
#endif

#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM && LH_Calc4to3_Di8_Do8_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do8_Lut8_G8_Old( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut8_G8_Old"
#include "EngineOl.c"
#endif

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut8_G16"
#include "Engine.c"
#endif

#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM && LH_Calc4to3_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do8_Lut8_G16_Old( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut8_G16_Old"
#include "EngineOl.c"
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di8_Do8_Lut16_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut16_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di8_Do8_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di8_Do16_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do16_Lut8_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di8_Do16_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do16_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di8_Do16_Lut16_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do16_Lut16_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di8_Do16_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do16_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di16_Do8_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di16_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do8_Lut8_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di16_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do8_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di16_Do8_Lut16_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di16_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do8_Lut16_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di16_Do8_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do8_Lut16_G16"
#include "Engine.c"
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di16_Do16_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di16_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do16_Lut8_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di16_Do16_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do16_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to3_Di16_Do16_Lut16_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di16_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do16_Lut16_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to3_Di16_Do16_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to3_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do16_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di8_Do8_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut8_G8"
#include "Engine.c"
#endif

#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM && LH_Calc4to4_Di8_Do8_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do8_Lut8_G8_Old( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut8_G8_Old"
#include "EngineOl.c"
#endif

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut8_G16"
#include "Engine.c"
#endif

#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM && LH_Calc4to4_Di8_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do8_Lut8_G16_Old( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut8_G16_Old"
#include "EngineOl.c"
#endif

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di8_Do8_Lut16_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut16_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di8_Do8_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di8_Do16_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do16_Lut8_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di8_Do16_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do16_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di8_Do16_Lut16_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do16_Lut16_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di8_Do16_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di8_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do16_Lut16_G16"
#include "Engine.c"
#endif


#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di16_Do8_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di16_Do8_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do8_Lut8_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di16_Do8_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di16_Do8_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do8_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di16_Do8_Lut16_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di16_Do8_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do8_Lut16_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di16_Do8_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di16_Do8_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do8_Lut16_G16"
#include "Engine.c"
#endif

#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di16_Do16_Lut8_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di16_Do16_Lut8_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do16_Lut8_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di16_Do16_Lut8_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di16_Do16_Lut8_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do16_Lut8_G16"
#include "Engine.c"
#endif


#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


#if LH_Calc4to4_Di16_Do16_Lut16_G8 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di16_Do16_Lut16_G8( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do16_Lut16_G8"
#include "Engine.c"
#endif


#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


#if LH_Calc4to4_Di16_Do16_Lut16_G16 == LH_CALC_USE_BIG_ENGINE
CMError LHCalc4to4_Di16_Do16_Lut16_G16( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do16_Lut16_G16"
#include "Engine.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\memlink.h ===
#ifndef MemLink_h
#define MemLink_h

typedef icXYZNumber MyXYZNumber;

struct LHTextType {
    OSType							base;				/* 0x74657874 */
    unsigned long					reserved;					/* fill with 0x00 */
    unsigned char					text[1];					/* count of text is obtained from tag size element */
};
typedef struct LHTextType LHTextType;
struct LHTextDescriptionType {
    OSType							typeDescriptor;				/* 0x64657363 */
    unsigned long					reserved;					/* fill with 0x00 */
    unsigned long					ASCIICount;					/* the count of "bytes" */
    unsigned char					ASCIIName[2];				/* Variable size, to access fields after this one, have to count bytes */
    unsigned long					UniCodeCode;
    unsigned long					UniCodeCount;				/* the count of characters, each character has two bytes */
    unsigned char					UniCodeName[2];				/* Variable size */
    short							ScriptCodeCode;
    unsigned char					ScriptCodeCount;			/* the count of "bytes" */
    unsigned char					ScriptCodeName[2];			/* Variable size */
};
typedef struct LHTextDescriptionType LHTextDescriptionType;
typedef struct{
	double X;double Y;double Z;
}MyDoubleXYZ;

CMError MyGetColorSpaces(	CMConcatProfileSet	*profileSet,
							UINT32				*sCS,
							UINT32				*dCS );
#define Round(a) (((a)>0.)?((a)+.5):((a)-.5))
void  MakeMyDoubleXYZ( MyXYZNumber *x, MyDoubleXYZ *ret );
CMError MyAdd_NL_Header( UINT32 theSize, icHeader	*linkHeader,
						 UINT32 aIntent, UINT32 aClass, UINT32 aColorSpace, UINT32 aConnectionSpace );
CMError MyAdd_NL_DescriptionTag	( LHTextDescriptionType *descPtr, unsigned char *theText );
CMError MyAdd_NL_ColorantTag	( icXYZType *descPtr, MyXYZNumber *aColor );
CMError MyAdd_NL_CurveTag	( icCurveType *descPtr, unsigned short Gamma );
CMError MyAdd_NL_CopyrightTag		( unsigned char *copyrightText, LHTextType *aLHTextType );
CMError MyAdd_NL_SequenceDescTag(	CMConcatProfileSet			*profileSet,
						  			icProfileSequenceDescType	*pSeqPtr,
						  			long						*aSize );
CMError MyAdd_NL_AToB0Tag_mft1( CMMModelPtr cw, icLut8Type *lutPtr, long colorLutSize );
CMError MyAdd_NL_AToB0Tag_mft2( CMMModelPtr cw, icLut16Type *lutPtr, long colorLutSize );
CMError MyAdd_NL_HeaderMS	( UINT32 theSize, icHeader	*linkHeader, unsigned long aIntent, icColorSpaceSignature sCS, icColorSpaceSignature dCS );

CMError DeviceLinkFill(	CMMModelPtr cw, 
						CMConcatProfileSet *profileSet, 
						icProfile **theProf,
						unsigned long aIntent );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\routines.h ===
/*
	File:		LHTheRoutines.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHTheRoutines_h
#define LHTheRoutines_h

OSErr
CalcGridPoints4Cube ( long	theCubeSize,
					  long	inputDim,
					  long* theGridPoints,
					  long* theGridBits );
/*
					MakeCube
	Fills Array Poi with the whole 'inputDim' dimensional color space with
	'inputDim' pixel entries depending on size of Poi memory
	Return: # of address bits for one dimension ( gridPoints = 1<< # )
*/
OSErr	MakeCube( long 				inputDim, 
				  long 				*thePtrSize,
				  CUBE_DATA_TYPE	*theCube,
				  long 				*theBits );
/*					MakeCMColorCube
	Fills Array Poi with the whole 'inputDim' dimensional color space with
	'inputDim' pixel entries depending on size of Poi memory
	Return: # of address bits for one dimension ( gridPoints = 1<< # )

*/

OSErr	MakeCMColorCube( 	long inputDim, 
				 			long *theCubeSize,
							CUBE_DATA_TYPE *aHdlPtr,
			  	 			long *theBits );
#define UWE 2
#ifdef UWE
/*					MakeCube16
	Fills Array Poi with the whole 'inputDim' dimensional color space with
	'inputDim' pixel entries depending on size of Poi memory with WORD values
	Return: # of address bits for one dimension ( gridPoints = 1<< # )
*/
OSErr
MakeCube16( long 			inputDim, 
			long 			*theCubeSize,
			CUBE_DATA_TYPE	*theCube,
			long 			*theBits,
			long 			*theExtraSize );
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\fragment.c ===
/*
	File:		LHFragment.c

	Contains:	Test fragment for Color Sync

	Written by:	H.Siegeritz

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#if GENERATING68K
/*	#include <ConditionalMacros.h> */

	#define CM_Doub	extended
	extern CM_Doub pow(CM_Doub _x,CM_Doub _y);
#else
	#define CM_Doub	double
	#include <math.h>
#endif

#ifndef LHFragment_h
#include "Fragment.h"
#endif

#ifndef LHStdConversionLuts_h
#include "StdConv.h"
#endif

#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kLHFragmentID
#endif
#endif


/*-----prototypes for local functions-----*/

void	InvLut1dExceptions(unsigned short *inCurve, unsigned long inCount,
                                unsigned short *outCurve, UINT8 AdressBits);
CMError	Fill_ushort_ELUT_Gamma(unsigned short *usELUT, char addrBits, char usedBits,
											long gridPoints, unsigned short gamma_u8_8);
void	Fill_inverseGamma_byte_ALUT(unsigned char *ucALUT, char addrBits,
													unsigned short gamma_u8_8);

/* ______________________________________________________________________

	icCurveType	*
		InvertLut1d(icCurveType	*LookUpTable,
                    UINT8		AdressBits);
	Abstract:
		allocates memory and inverts Lut
		NOTE: not-monotone LookUpTables are manipulated
		areas without values in LookUpTable are set 0 resp. 0xFFFF

	Params:
		LookUpTable	(in)	LUT to be inverted
		AdressBits	(in)	curve with 2 ^ AdressBits values
		
	Return:
		Ptr to icCurveType		successful
		nil						Error

   _____________________________________________________________________ */
icCurveType	*
InvertLut1d ( icCurveType *LookUpTable,
			  UINT8 AdressBits)
{
	unsigned long	i, inCount, outCount;
	unsigned long	intpFirst, intpLast, halfStep, ulAux, target;
	short			monot;
	unsigned short	*inCurve, *outCurve, *usPtr, *stopPtr;
	icCurveType		*outCMcurve = nil;
	double			flFactor;
	OSErr			err = noErr;
	
	LH_START_PROC("InvertLut1d")
	
	if( LookUpTable->base.sig != icSigCurveType	/* 'curv' */ || AdressBits > 15 )
		goto CleanupAndExit;
	
	inCount  = LookUpTable->curve.count;
	inCurve  = LookUpTable->curve.data;
	outCount = 0x1 << AdressBits;
		
	outCMcurve = (icCurveType *)SmartNewPtr( sizeof(OSType)
									  + 2 * sizeof(unsigned long)
									  + outCount * sizeof(unsigned short), &err );
	if(err)
		goto CleanupAndExit;
	
	outCurve = (unsigned short *)outCMcurve->curve.data;
	
   	outCMcurve->base.sig 	= icSigCurveType;	/* 'curv' */
   	outCMcurve->base.reserved[0] = 0x00;
   	outCMcurve->base.reserved[1] = 0x00;
   	outCMcurve->base.reserved[2] = 0x00;
   	outCMcurve->base.reserved[3] = 0x00;
	outCMcurve->curve.count = outCount;
	
	if(inCount < 2)		/* 0 or 1 point in LUT */
	{
		InvLut1dExceptions(inCurve, inCount, outCurve, AdressBits);
		goto CleanupAndExit;
	}
	
		 /* exact matching factor for special values: */
	flFactor = (double)(outCount - 1) / 65535.;
	halfStep = outCount >> 1;		/* lessen computation incorrectness */
	
				/* ascending or descending ? */
	for(monot=0, i=1; i<inCount; i++)
	{
		if(inCurve[i-1] < inCurve[i])
			monot++;
		else if(inCurve[i-1] > inCurve[i])
			monot--;
	}
	
	if(monot >= 0)	/* curve seems to be ascending */
	{
		for(i=1; i<inCount; i++)
			if(inCurve[i-1] > inCurve[i])
				inCurve[i] = inCurve[i-1];
		
		intpFirst = (unsigned long)(inCurve[0] * flFactor + 0.9999);
		intpLast  = (unsigned long)(inCurve[inCount-1] * flFactor);
		
		for(i=0; i<intpFirst; i++)			/* fill lacking area low */
			outCurve[i] = 0;
		for(i=intpLast+1; i<outCount; i++)	/* fill lacking area high */
			outCurve[i] = 0xFFFF;

			/* interpolate remaining values: */
		usPtr   = inCurve;
		stopPtr = inCurve + inCount - 2; /* stops incrementation */
		
		for(i=intpFirst; i<=intpLast; i++)
		{
			target = (0x0FFFF * i + halfStep)  / (outCount - 1);
			while(*(usPtr+1) < target && usPtr < stopPtr)
				usPtr++;					/* find interval */
			
			ulAux = ((unsigned long)(usPtr - inCurve) << 16) / (inCount - 1);
			if(*(usPtr+1) != *usPtr)
			{
				ulAux += ((target - (unsigned long)*usPtr) << 16)
					  / ( (*(usPtr+1) - *usPtr) * (inCount - 1) );
				
				if(ulAux & 0x10000)   /* *(usPtr+1) was required */
					ulAux = 0xFFFF;
			}
			
			outCurve[i] = (unsigned short)ulAux;
		}
	}
	else			/* curve seems to be descending */
	{
		for(i=1; i<inCount; i++)
			if(inCurve[i-1] < inCurve[i])
				inCurve[i] = inCurve[i-1];
		
		intpFirst = (unsigned long)(inCurve[inCount-1] * flFactor + 0.9999);
		intpLast  = (unsigned long)(inCurve[0] * flFactor);
		
		for(i=0; i<intpFirst; i++)			/* fill lacking area low */
			outCurve[i] = 0xFFFF;
		for(i=intpLast+1; i<outCount; i++)	/* fill lacking area high */
			outCurve[i] = 0;

			/* interpolate remaining values: */
		usPtr   = inCurve + inCount - 1;
		stopPtr = inCurve + 1; 		/* stops decrementation */
		
		for(i=intpFirst; i<=intpLast; i++)
		{
			target = (0x0FFFF * i + halfStep)  / (outCount - 1);
			while(*(usPtr-1) < target && usPtr > stopPtr)
				usPtr--;					/* find interval */
			
			ulAux = ((unsigned long)(usPtr-1 - inCurve) << 16) / (inCount - 1);
			if(*(usPtr-1) != *usPtr)
			{
				ulAux += (((unsigned long)*(usPtr-1) - target) << 16)
					  / ( (*(usPtr-1) - *usPtr) * (inCount - 1) );
				
				if(ulAux & 0x10000)
					ulAux = 0x0FFFF;
			}
			
			outCurve[i] = (unsigned short)ulAux;
		}
	}
CleanupAndExit:
	LH_END_PROC("InvertLut1d")
	return(outCMcurve);
}

/* ______________________________________________________________________

	void
		InvLut1dExceptions(	unsigned short	*inCurve,
							unsigned long	inCount,
							unsigned short	*outCurve,
                            UINT8			AdressBits )
	Abstract:
		handles identity and gamma case for LUT inversion

	Params:
		inCurve		(in)	pseudo LUT to be inverted
		inCount		(in)	count of values, 0 (identity) or 1 (gamma)
		outCurve	(out)	inverted LUT
		AdressBits	(in)	2^n values are requested
		
	Return:
		void

   _____________________________________________________________________ */
void
InvLut1dExceptions	( unsigned short *	inCurve,
					  unsigned long 	inCount,
					  unsigned short *	outCurve,
					  UINT8				AdressBits)
{
	unsigned long	i, outCount, step, oldstep, stopit;
	UINT8			shiftBits;
	CM_Doub			invGamma, x, xFactor;
#ifdef DEBUG_OUTPUT
	CMError			err = noErr;
#endif

	LH_START_PROC("InvLut1dExceptions")
	outCount = 0x1 << AdressBits;
	
	if(inCount == 0)	/* identity */
	{
		shiftBits = 16 - AdressBits;
		
		for(i=0; i<outCount; i++)
			outCurve[i] = (unsigned short)( (i << shiftBits)
										  + (i >> AdressBits) );
	}
	else		/* inCount == 1 , gamma */
	{
		invGamma = 256. / (CM_Doub)inCurve[0];
		xFactor  = 1. / (CM_Doub)(outCount - 1);
		
		if(AdressBits <= 6)		/* up to 64 - 2 float.computations */
			step = 1;
		else
			step = 0x1 << (AdressBits - 6);		/* would take too long */
		
		outCurve[0]          = 0;
		outCurve[outCount-1] = 0xFFFF;
		
		for(i=step; i<outCount-1; i+=step)
		{
			x = (CM_Doub)i * xFactor;
			outCurve[i] = (unsigned short)( pow(x,invGamma) * 65535.0);
		}
		
		while(step > 1)		/* fill remaining values successively */
		{
			oldstep = step;
			step  >>= 1;
			
			stopit = outCount - step;	/* last value afterwards */
			
			for(i=step; i<stopit; i+=oldstep)
				outCurve[i] = (unsigned short)( ((long)outCurve[i - step]
										+ (long)outCurve[i + step]) >> 1 );
			
			if(step != 1)
				outCurve[stopit] = (unsigned short)
							( ((long)outCurve[stopit - step] + 0x0FFFF) >> 1 );
		}
		
			/* overwrite sensitive values depending on Gamma */
		if(AdressBits > 6 && invGamma < 1.0)	/* lower part is difficult */
		{
			stopit = 0x1 << (AdressBits - 6);
			
			for(i=1; i<stopit; i++)
			{
				x = (CM_Doub)i * xFactor;
				outCurve[i] = (unsigned short)( pow(x,invGamma) * 65535.0);
			}
		}
	}
	LH_END_PROC("InvLut1dExceptions")
}

/* ______________________________________________________________________

	CMError
		CombiMatrix(icXYZType	*srcColorantData[3],
					icXYZType	*destColorantData[3],
					double		resMatrix[3][3])
	Abstract:
		inverts the 2nd matrix, multiplies it with the 1rst and
		puts the result in resMatrix

	Params:
		srcColorantData		(in)		RGB colorants
		destColorantData	(in)		RGB colorants
		resMatrix			(in/out)
		
	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
CombiMatrix	( icXYZType srcColorantData[3],
			  icXYZType destColorantData[3],
			  double resMatrix[3][3] )
{
	short		i, j;
	double		straightMat[3][3], invMat[3][3];
	CMError 	err = noErr;

	LH_START_PROC("CombiMatrix")
		/* RGB -> XYZ for first profile: */
	straightMat[0][0] = (double)srcColorantData[0].data.data[0].X;
	straightMat[1][0] = (double)srcColorantData[0].data.data[0].Y;
	straightMat[2][0] = (double)srcColorantData[0].data.data[0].Z;
	
	straightMat[0][1] = (double)srcColorantData[1].data.data[0].X;
	straightMat[1][1] = (double)srcColorantData[1].data.data[0].Y;
	straightMat[2][1] = (double)srcColorantData[1].data.data[0].Z;
	
	straightMat[0][2] = (double)srcColorantData[2].data.data[0].X;
	straightMat[1][2] = (double)srcColorantData[2].data.data[0].Y;
	straightMat[2][2] = (double)srcColorantData[2].data.data[0].Z;
	
		/* RGB -> XYZ for 2nd profile, store in resMatrix prelim.: */
	resMatrix[0][0] = (double)destColorantData[0].data.data[0].X;
	resMatrix[1][0] = (double)destColorantData[0].data.data[0].Y;
	resMatrix[2][0] = (double)destColorantData[0].data.data[0].Z;
	
	resMatrix[0][1] = (double)destColorantData[1].data.data[0].X;
	resMatrix[1][1] = (double)destColorantData[1].data.data[0].Y;
	resMatrix[2][1] = (double)destColorantData[1].data.data[0].Z;
	
	resMatrix[0][2] = (double)destColorantData[2].data.data[0].X;
	resMatrix[1][2] = (double)destColorantData[2].data.data[0].Y;
	resMatrix[2][2] = (double)destColorantData[2].data.data[0].Z;
	
	if( !doubMatrixInvert(resMatrix, invMat) )
	{
#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugErrorInfo) )
            DebugPrint(" CombiMatrix-Error: doubMatrixInvert failed \n");
#endif
		err = cmparamErr;
		goto CleanupAndExit;
	}
	
	for(i=0; i<3; i++)
		for(j=0; j<3; j++)
			resMatrix[i][j] = straightMat[i][0] * invMat[0][j]
							+ straightMat[i][1] * invMat[1][j]
							+ straightMat[i][2] * invMat[2][j];
CleanupAndExit:
	LH_END_PROC("CombiMatrix")
	return err;
}

/* ______________________________________________________________________

	Boolean
		doubMatrixInvert(double	MatHin[3][3],
						 double	MatRueck[3][3])
	Abstract:
		inverts MatHin matrix and puts the result in MatRueck

	Params:
		MatHin			(in)			3 * 3 double matrix
		MatRueck		(in/out)		3 * 3 double matrix
		
	Return:
        TRUE		successful

   _____________________________________________________________________ */
Boolean	
doubMatrixInvert(double MatHin[3][3], double MatRueck[3][3])
{
	double	detm, hilf1, hilf2, hilf3, hilf4, hilf5, hilf6;
	double	*a;
	Boolean	success = TRUE;
#ifdef DEBUG_OUTPUT
	CMError err=noErr;
#endif
	LH_START_PROC("doubMatrixInvert")
	a = (double *)MatHin;
	
	hilf1 = a[0] * a[4];
	hilf2 = a[1] * a[5];
	hilf3 = a[2] * a[3];
	hilf4 = a[2] * a[4];
	hilf5 = a[1] * a[3];
	hilf6 = a[0] * a[5];
	
	detm = hilf1 * a[8] + hilf2 * a[6]
		 + hilf3 * a[7] - hilf4 * a[6]
		 - hilf5 * a[8] - hilf6 * a[7];
	
	/*	if(fabs(detm) < 1.E-9) */
	if ( (detm < 1.E-9) && (detm > -1.E-9) )
        success = FALSE;
	else
	{
		detm = 1. / detm;
		
		MatRueck[0][0] = (a[4] * a[8] - a[5] * a[7]) * detm;
		MatRueck[0][1] = (a[7] * a[2] - a[8] * a[1]) * detm;
		MatRueck[0][2] = (hilf2       - hilf4      ) * detm;
	
		MatRueck[1][0] = (a[5] * a[6] - a[3] * a[8]) * detm;
		MatRueck[1][1] = (a[8] * a[0] - a[6] * a[2]) * detm;
		MatRueck[1][2] = (hilf3       - hilf6      ) * detm;
	
		MatRueck[2][0] = (a[3] * a[7] - a[4] * a[6]) * detm;
		MatRueck[2][1] = (a[6] * a[1] - a[7] * a[0]) * detm;
		MatRueck[2][2] = (hilf1       - hilf5      ) * detm;
	}
	
	LH_END_PROC("doubMatrixInvert")
    return(success);
}

/* ______________________________________________________________________
	CMError
		Fill_ushort_ELUT_from_CurveTag(	icCurveType		*pCurveTag,
										unsigned short	*usELUT,
										char			addrBits,
										char			usedBits,
										long 			gridPoints )
	Abstract:
		extracts input luts out of cmSigCurveType tag and converts it
		to desired format: (2 ^ addrBits) values in a range from
		0 to (2 ^ usedBits) - (gridPoints ^ 2)
		NOTE: Memory for the LUTs has to be allocated before !

	Params:
		pCurveTag		(in)		extract input LUT from this
		usELUT			(in/out)	result LUT
		addrBits		(in)		2 ^ addrBits values are requested
		usedBits		(in)		used bits in u.short
		gridPoints		(in)		used for interpolation
		
	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_ushort_ELUT_from_CurveTag ( icCurveType	*pCurveTag,
								 unsigned short	*usELUT,
								 char			addrBits,
								 char			usedBits,
								 long 			gridPoints)
{
	long			i, count, indFactor, outFactor, baseInd, maxOut;
	long			fract, lAux, diff, outRound, outShift, interpRound, interpShift;
	unsigned short	*usCurv;
	double			dFactor;
	CMError			err = noErr;
	
	LH_START_PROC("Fill_ushort_ELUT_from_CurveTag")
		/*---special cases:---*/

	if(pCurveTag->curve.count == 0)		/* identity curve */
	{
		err = Fill_ushort_ELUT_identical(usELUT, addrBits, usedBits, gridPoints);
		goto CleanupAndExit;
	}
	
	if(pCurveTag->curve.count == 1)		/* Gamma  curve */
	{
		err = Fill_ushort_ELUT_Gamma(usELUT, addrBits, usedBits, gridPoints, pCurveTag->curve.data[0]);
		goto CleanupAndExit;
	}
		/*---ordinary case:---*/
	
	if(addrBits > 15)
	{
		err = cmparamErr;	/* would lead to overflow */
		goto CleanupAndExit;
	}
	
	count     = 1 << addrBits;
	indFactor = ((pCurveTag->curve.count - 1) << 18) / (count - 1);	/* for adjusting indices */
	
	if(usedBits < 8)
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	
	if(gridPoints == 0)
		maxOut = 65535;
	else
		maxOut = ((1L << (usedBits - 8) ) * 256 * (gridPoints - 1)) / gridPoints;
	
		/*-----find factor for the values that fits in 15 bits------*/
		/* (product with 16 bit number must fit in 31 bit uns.long)	*/
		/* n.b: 512 <= maxOut <= 65535  in all possible cases		*/
	
	dFactor  = (double)maxOut / 65535.;		/* 65535 is max. curve value */
	dFactor *= 4194304.;					/* same as << 22, certainly too much */
	
	outFactor = (long)dFactor;
	outRound  = (1L << 21) - 1;
	outShift  = 22;
	while(outFactor & 0xFFF8000)	/* stay within 15 bits to prevent product overflow */
	{
		outFactor >>= 1;
		outRound  >>= 1;
		outShift   -= 1;
	}
	
	interpRound = outRound >> 1;	/* with interpolation we have an additional...	*/
	interpShift = outShift  - 1;	/* ... >> 1 because we must add two nunmbers	*/
	
	usCurv = pCurveTag->curve.data;
	
	for(i=0; i<count; i++)
	{
		lAux    = (i * indFactor+4) >> 3;
		baseInd = (unsigned long)lAux >> 15;
		fract   = lAux & 0x7FFF;		/* 15 bits for interpolation */
		
		if(fract)		/* interpolation necessary ? */
		{
			lAux = (long)usCurv[baseInd] * outFactor >> 1;
			
			diff = (long)usCurv[baseInd+1] - (long)usCurv[baseInd];
			diff = (diff * outFactor >> 15) * fract >> 1;

			usELUT[i] = (unsigned short)( (lAux + diff + interpRound) >> interpShift );
		}
		else
			usELUT[i] = (unsigned short)( ((long)usCurv[baseInd]
												* outFactor + outRound) >> outShift );
	}

CleanupAndExit:	
	LH_END_PROC("Fill_ushort_ELUT_from_CurveTag")
	return(noErr);
}

/* ______________________________________________________________________
   _____________________________________________________________________ */
CMError
Fill_ushort_ELUT_identical	( UINT16 *usELUT,
							  char addrBits,
							  char usedBits,
							  long gridPoints )
{
	long		i, count, factor, maxOut;
	UINT16		*myWPtr;
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC("Fill_ushort_ELUT_identical")
		
	count  = 1 << addrBits;
	
	if(gridPoints == 0)
		maxOut = 65535;
	else
		maxOut = ((1L << (usedBits - 8) ) * 256 * (gridPoints - 1)) / gridPoints;
	
	factor = (maxOut << 14) / (count - 1);
	
	myWPtr = usELUT;
	for(i=0; i<count; i++)
		*myWPtr++ = (UINT16)((i * factor + 0x2000) >> 14);
	
	LH_END_PROC("Fill_ushort_ELUT_identical")
	return(noErr);
}

/* ______________________________________________________________________
   _____________________________________________________________________ */
CMError
Fill_ushort_ELUT_Gamma	( unsigned short*	usELUT,
						  char				addrBits,
						  char				usedBits,
						  long				gridPoints,
						  unsigned short	gamma_u8_8 )
{
	unsigned long	i, j, outCount, step, stopit;
	CM_Doub			gamma, x, xFactor;
	long			leftVal, Diff, lAux, maxOut;
#ifdef DEBUG_OUTPUT
	CMError			err=noErr;
#endif

	LH_START_PROC("Fill_ushort_ELUT_Gamma")
	outCount = 0x1 << addrBits;
	if(gridPoints == 0)
		maxOut = 65535;
	else
		maxOut = ((1L << (usedBits - 8) ) * 256 * (gridPoints - 1)) / gridPoints;
	
	gamma   = ((CM_Doub)gamma_u8_8 * 3.90625E-3);	/* / 256.0 */
	xFactor = 1. / (CM_Doub)(outCount - 1);
	
	if(addrBits <= 6)		/* up to 64 - 2 float.computations */
		step = 1;
	else
		step = 0x1 << (addrBits - 6);		/* would take too long */
	
	usELUT[0]          = 0;
    usELUT[outCount-1] = (UINT16)maxOut;
	
	for(i=step; i<outCount-1; i+=step)
	{
		x         = (CM_Doub)i * xFactor;
		usELUT[i] = (unsigned short)( pow(x,gamma) * maxOut);
	}
	
		/*---fill intervals - except for last, which is odd:---*/
	for(i=0; i<outCount-step; i+=step)
	{
		leftVal = (long)usELUT[i];
		Diff    = (long)usELUT[i + step] - leftVal;
			
		for(j=1; j<step; j++)
		{
			lAux = ( (Diff * j << 8) / step + 128 ) >> 8;

			usELUT[i + j] = (unsigned short)(leftVal + lAux);
		}
	}
	
		/*---fill last interval:---*/
	i       = outCount - step;
	leftVal = (long)usELUT[i];
	Diff    = maxOut - leftVal;		/* maxOut for 1.0 */
		
	for(j=1; j<step-1; j++)		/* stops here if step <= 2 */
	{
		lAux = ( (Diff * j << 8) / (step - 1) + 128 ) >> 8;

		usELUT[i + j] = (unsigned short)(leftVal + lAux);
	}
	
		/* overwrite sensitive values depending on Gamma */
	if(addrBits > 6 && gamma < 1.0)	/* lower part is difficult */
	{
		stopit = 0x1 << (addrBits - 6);
		
		for(i=1; i<stopit; i++)
		{
			x = (CM_Doub)i * xFactor;
			usELUT[i] = (unsigned short)( pow(x,gamma) * maxOut);
		}
	}

	LH_END_PROC("Fill_ushort_ELUT_Gamma")
	return(noErr);
}


/* ______________________________________________________________________

	CMError
		Fill_inverse_byte_ALUT_from_CurveTag(	icCurveType		*pCurveTag,
												unsigned char	*ucALUT,
												char			addrBits )
	Abstract:
		extracts output luts out of cmSigCurveType tag and converts them
		to desired format: (2 ^ addrBits) values in a range from 0 to 255
		NOTE: not-monotone CurveTags are manipulated
		NOTE: Memory for the LUT has to be allocated before !

	Params:
		pCurveTag		(in)		extract input LUT from this
		ucALUT			(in/out)	result LUT
		addrBits		(in)		2 ^ addrBits values are requested
		
	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_inverse_byte_ALUT_from_CurveTag	( icCurveType	*pCurveTag,
										  unsigned char	*ucALUT,
										  char			addrBits )
{
	unsigned long	i, inCount, outCount;
	unsigned long	intpFirst, intpLast, halfStep, ulAux, target;
	short			monot;
	unsigned short	*inCurve, *usPtr, *stopPtr;
	double			flFactor;
	char			baseShift;
	unsigned long	clipIndex;
	CMError			err = noErr;

	LH_START_PROC("Fill_inverse_byte_ALUT_from_CurveTag")

    if( pCurveTag->base.sig != icSigCurveType	/* 'curv' */
     || addrBits > 15 )
    {
#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugErrorInfo) )
            DebugPrint(" Fill_inverse_byte_ALUT_from_CurveTag ERROR:  addrBits = %d\n",addrBits);
#endif
		err = cmparamErr;
		goto CleanupAndExit;
	}
	
	outCount = 0x1 << addrBits;

		/*---special cases:---*/

	if(pCurveTag->curve.count == 0)		/*---identity---*/
	{
		baseShift = addrBits - 8;		/* >= 0, we need at least 256 values */
		
		for(i=0; i<outCount; i++)
			ucALUT[i] = (unsigned char)(i >> baseShift);
	
		goto CleanupAndExit;
	}
	else if(pCurveTag->curve.count == 1)	/*---gamma curve---*/
	{
		Fill_inverseGamma_byte_ALUT(ucALUT, addrBits, pCurveTag->curve.data[0]);
		goto CleanupAndExit;
	}
	
		/*---ordinary case:---*/
	
	inCount = pCurveTag->curve.count;
	inCurve = pCurveTag->curve.data;
		
		 /* exact matching factor needed for special values: */
	clipIndex = (1 << addrBits) - (1 << (addrBits - 8)); /* max XLUT output with 10 bit is at 1020, not at1023 */
	flFactor  = (double)clipIndex / 65535.;
	
	halfStep = outCount >> 1;		/* lessen computation incorrectness */
	
				/* ascending or descending ? */
	for(monot=0, i=1; i<inCount; i++)
	{
		if(inCurve[i-1] < inCurve[i])
			monot++;
		else if(inCurve[i-1] > inCurve[i])
			monot--;
	}
	
	if(monot >= 0)	/* curve seems to be ascending */
	{
		for(i=1; i<inCount; i++)
			if(inCurve[i-1] > inCurve[i])
				inCurve[i] = inCurve[i-1];
		
		intpFirst = (unsigned long)(inCurve[0] * flFactor + 0.9999);
		intpLast  = (unsigned long)(inCurve[inCount-1] * flFactor);
		
		for(i=0; i<intpFirst; i++)			/* fill lacking area low */
			ucALUT[i] = 0;
		for(i=intpLast+1; i<outCount; i++)	/* fill lacking area high */
			ucALUT[i] = 0xFF;

			/* interpolate remaining values: */
		usPtr   = inCurve;
		stopPtr = inCurve + inCount - 2; /* stops incrementation */
		
		for(i=intpFirst; i<=intpLast; i++)
		{
			target = (0x0FFFF * i + halfStep)  / (outCount - 1);
			while(*(usPtr+1) < target && usPtr < stopPtr)
				usPtr++;					/* find interval */
			
			ulAux = ((unsigned long)(usPtr - inCurve) << 16) / (inCount - 1);
			if(*(usPtr+1) != *usPtr)
			{
				ulAux += ((target - (unsigned long)*usPtr) << 16)
					  / ( (*(usPtr+1) - *usPtr) * (inCount - 1) );
				
				if(ulAux & 0x10000)   /* *(usPtr+1) was required */
					ulAux = 0x0FFFF;
			}
			
			ucALUT[i] = (unsigned char)(ulAux >> 8);
		}
	}
	else			/* curve seems to be descending */
	{
		for(i=1; i<inCount; i++)
			if(inCurve[i-1] < inCurve[i])
				inCurve[i] = inCurve[i-1];
		
		intpFirst = (unsigned long)(inCurve[inCount-1] * flFactor + 0.9999);
		intpLast  = (unsigned long)(inCurve[0] * flFactor);
		
		for(i=0; i<intpFirst; i++)			/* fill lacking area low */
			ucALUT[i] = 0xFF;
		for(i=intpLast+1; i<outCount; i++)	/* fill lacking area high */
			ucALUT[i] = 0;

			/* interpolate remaining values: */
		usPtr   = inCurve + inCount - 1;
		stopPtr = inCurve + 1; 		/* stops decrementation */
		
		for(i=intpFirst; i<=intpLast; i++)
		{
			target = (0x0FFFF * i + halfStep)  / (outCount - 1);
			while(*(usPtr-1) < target && usPtr > stopPtr)
				usPtr--;					/* find interval */
			
			ulAux = ((unsigned long)(usPtr-1 - inCurve) << 16) / (inCount - 1);
			if(*(usPtr-1) != *usPtr)
			{
				ulAux += (((unsigned long)*(usPtr-1) - target) << 16)
					  / ( (*(usPtr-1) - *usPtr) * (inCount - 1) );
				
				if(ulAux & 0x10000)
					ulAux = 0x0FFFF;
			}
			
            ucALUT[i] = (unsigned char)(ulAux >> 8);
		}
	}

CleanupAndExit:	
	LH_END_PROC("Fill_inverse_byte_ALUT_from_CurveTag")
	return(noErr);
}

/*   _____________________________________________________________________ */
void
Fill_inverseGamma_byte_ALUT ( unsigned char	*	ucALUT,
							  char				addrBits,
							  unsigned short	gamma_u8_8 )
{
	unsigned long	i, j, outCount, step, stopit;
	long			leftVal, Diff, lAux;
	CM_Doub			invGamma, x, xFactor;
    unsigned long	clipIndex;
#ifdef DEBUG_OUTPUT
	CMError			err=noErr;
#endif

	LH_START_PROC("Fill_inverseGamma_byte_ALUT")

	outCount = 0x1 << addrBits;
	
	invGamma  = 256. / (CM_Doub)gamma_u8_8;
	clipIndex = (1 << addrBits) - (1 << (addrBits - 8)); /* max XLUT output with 10 bit is at 1020, not at1023 */
	xFactor   = 1. / (CM_Doub)clipIndex;
	
	if(addrBits <= 6)		/* up to 64 - 2 float.computations */
		step = 1;
	else
		step = 0x1 << (addrBits - 6);		/* more would take too long */
	
	ucALUT[0]          = 0;			/* these two...	*/
	ucALUT[outCount-1] = 0xFF;		/* ...are fixed	*/
	
	for(i=step; i<outCount-1; i+=step)
	{
		x = (CM_Doub)i * xFactor;
		if(x > 1.)
			x = 1.;		/* clipping in the end of ALUT */
		
		ucALUT[i] = (unsigned char)( pow(x,invGamma) * 255.0 + 0.5);
	}
	
		/*---fill intervals - except for last, which is odd:---*/
	for(i=0; i<outCount-step; i+=step)
	{
		leftVal = (long)ucALUT[i];
		Diff    = (long)ucALUT[i + step] - leftVal;
			
		for(j=1; j<step; j++)
		{
			lAux = ( (Diff * j << 8) / step + 128 ) >> 8;

			ucALUT[i + j] = (unsigned char)(leftVal + lAux);
		}
	}
	
		/*---fill last interval:---*/
	i       = outCount - step;
	leftVal = (long)ucALUT[i];
	Diff    = 0x0FF - leftVal;	/* 0xFF for 1.0 */
		
	for(j=1; j<step-1; j++)		/* stops here if step <= 2 */
	{
		lAux = ( (Diff * j << 8) / (step - 1) + 128 ) >> 8;

		ucALUT[i + j] = (unsigned char)(leftVal + lAux);
	}
	
		/*--overwrite sensitive values depending on Gamma:--*/
	if(addrBits > 6 && invGamma < 1.0)		/* ...if lower part is difficult */
	{
		stopit = 0x1 << (addrBits - 6);
		
		for(i=1; i<stopit; i++)
		{
			x         = (CM_Doub)i * xFactor;
			ucALUT[i] = (unsigned char)( pow(x,invGamma) * 255.0);
		}
	}
	LH_END_PROC("Fill_inverseGamma_byte_ALUT")
}

/* ______________________________________________________________________

	CMError
	Fill_ushort_ELUTs_from_lut8Tag ( CMLutParamPtr	theLutData,
									 Ptr			profileELuts,
									 char			addrBits,
									 char			usedBits,
									 long			gridPoints )
	Abstract:
		extracts input luts out of CMlut8Type tag and converts them
		to desired format: (2 ^ addrBits) values in a range from
		0 to (2 ^ usedBits) - (gridPoints ^ 2)

	Params:
		theLutData			(in/out)	Ptr to structure that holds all the luts...
		profileELuts		(in)		Ptr to the profile's input luts
		addrBits			(in)		2 ^ addrBits values are requested
		usedBits			(in)		used bits in u.short
		gridPoints			(in)		used for interpolation

	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_ushort_ELUTs_from_lut8Tag ( CMLutParamPtr	theLutData,
								 Ptr			profileELuts,
								 char			addrBits,
								 char			usedBits,
								 long			gridPoints )
{
	long			i, j, maxOut;
	UINT8			*curInLut;
	UINT16			*curELUT;
	long			count, indFactor, outFactor, baseInd, fract, lAux, diff;
	LUT_DATA_TYPE	localElut = nil;
	UINT16			*localElutPtr;
	OSErr			err = noErr;
	long			theElutSize;
	
	LH_START_PROC("Fill_ushort_ELUTs_from_lut8Tag")
	
	count       = 1 << addrBits;
	theElutSize = theLutData->colorLutInDim * count * sizeof (UINT16);
	localElut   = ALLOC_DATA(theElutSize + 2, &err);
	if (err)
		goto CleanupAndExit;
	
	indFactor = (255 << 12) / (count - 1);	/* for adjusting indices */
	
	if(gridPoints == 0)
		maxOut = 65535;
	else
		maxOut = ((1L << (usedBits - 8) ) * 256 * (gridPoints - 1)) / gridPoints;
	outFactor = (maxOut << 12) / 255;			/* 255 is max. value from mft1 output lut */
	
	LOCK_DATA(localElut);
	localElutPtr = (UINT16*)DATA_2_PTR(localElut);
	for(i=0; i<theLutData->colorLutInDim; i++)
	{
		curInLut = (UINT8*)profileELuts + (i << 8);
		curELUT  = localElutPtr + i * count;
		
		for(j=0; j<count; j++)
		{
			lAux    = j * indFactor;
			baseInd = lAux >> 12;
			fract   = (lAux & 0x0FFF) >> 4; /* leaves 8 bits for interpolation as with distortion */

			if(fract && baseInd != 255)		/* interpolation necessary ? */
			{
				lAux = (long)curInLut[baseInd] * outFactor >> 6;
				
				diff = (long)curInLut[baseInd+1] - (long)curInLut[baseInd];
				diff = (diff * outFactor >> 6) * fract >> 8;

				curELUT[j] = (UINT16)( (lAux + diff + 32) >> 6 );
			}
			else
				curELUT[j] = (UINT16)( ((long)curInLut[baseInd]
													* outFactor + 0x0800) >> 12 );
		}
	}
	UNLOCK_DATA(localElut);
	theLutData->inputLut = localElut;
	localElut = nil;
CleanupAndExit:
	localElut = DISPOSE_IF_DATA(localElut);
	LH_END_PROC("Fill_ushort_ELUTs_from_lut8Tag")
	return err;
}

/* ______________________________________________________________________

	CMError
	Fill_byte_ALUTs_from_lut8Tag( CMLutParamPtr	theLutData,
								  Ptr			profileALuts,
								  char 			addrBits )
	Abstract:
		extracts output luts out of CMLut8Type tag and converts them
		to desired format: (2 ^ addrBits) values in a range from 0 to 255

	Params:
		theLutData			(in/out)	Ptr to structure that holds all the luts...
		profileALuts		(in)		Ptr to the profile's output luts
		addrBits			(in)		2 ^ addrBits values are requested
		
	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_byte_ALUTs_from_lut8Tag( CMLutParamPtr	theLutData,
							  Ptr			profileALuts,
							  char 			addrBits )
{
	long			i, j;
	UINT8			*curOutLut;
	UINT8			*profAluts = (UINT8*)profileALuts;
	UINT8			*curALUT;
	long			count, clipIndex;
	long			factor, fract, baseInd, lAux;
	OSErr			err = noErr;
	LUT_DATA_TYPE	localAlut = nil;
	UINT8			*localAlutPtr;
	long			theAlutSize;
	
	LH_START_PROC("Fill_byte_ALUTs_from_lut8Tag")

	count     = 1 << addrBits;								/* addrBits is always >= 8 */
	clipIndex = (1 << addrBits) - (1 << (addrBits - 8));	/* max XLUT output with 10 bit is at 1020, not at1023 */
	
	theAlutSize = theLutData->colorLutOutDim * count;
	localAlut   = ALLOC_DATA(theAlutSize + 1, &err);
	if (err)
		goto CleanupAndExit;
	
	LOCK_DATA(localAlut);
	localAlutPtr = (UINT8*)DATA_2_PTR(localAlut);
	
	factor = (255 << 12) / clipIndex;		/* for adjusting the indices */
	
	for(i=0; i<theLutData->colorLutOutDim; i++)
	{
		curOutLut = profAluts + (i << 8);
		curALUT   = localAlutPtr + i * count;
		
		for(j=0; j<=clipIndex; j++)
		{
			lAux    = j * factor;
			baseInd = lAux >> 12;
			fract   = lAux & 0x0FFF;
			
			if(fract)
			{
				lAux = (long)curOutLut[baseInd + 1] - (long)curOutLut[baseInd];
				lAux = (lAux * fract + 0x0800) >> 12;
				
				curALUT[j] = (UINT8)((long)curOutLut[baseInd] + lAux);
			}
			else
				curALUT[j] = curOutLut[baseInd];
		}
		
		for(j=clipIndex+1; j<count; j++)		/* unused indices, clip these */
			curALUT[j] = curALUT[clipIndex];
	}
	
	UNLOCK_DATA(localAlut);
	theLutData->outputLut = localAlut;
	localAlut = nil;
CleanupAndExit:
	localAlut = DISPOSE_IF_DATA(localAlut);
	LH_END_PROC("Fill_byte_ALUTs_from_lut8Tag")
	return err;
}

/* ______________________________________________________________________

	CMError
	Fill_ushort_ELUTs_from_lut16Tag( CMLutParamPtr	theLutData,
									 Ptr			profileELuts,
									 char			addrBits,
									 char			usedBits,
									 long			gridPoints,
									 long			inputTableEntries )

	Abstract:
		extracts input luts out of CMLut16Type tag and converts them
		to desired format: (2 ^ addrBits) values in a range from
		0 to (2 ^ usedBits) - (gridPoints ^ 2)

	Params:
		theLutData			(in/out)	Ptr to structure that holds all the luts...
		profileELuts		(in)		Ptr to the profile's input luts
		addrBits			(in)		2 ^ addrBits values are requested
		usedBits			(in)		used bits in u.short
		gridPoints			(in)		used for interpolation
		inputTableEntries	(in)		number of entries in the input lut (up to 4096)

	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_ushort_ELUTs_from_lut16Tag( CMLutParamPtr	theLutData,
								 Ptr			profileELuts,
								 char			addrBits,
								 char			usedBits,
								 long			gridPoints,
								 long			inputTableEntries )
{
	long			i, j, inTabLen, maxOut;
	UINT16			*curInLut;
	UINT16			*curELUT;
	UINT16			*profELUT = (UINT16*)profileELuts;
	long			count, outFactor, fract, lAux, diff;
	long			baseInd, indFactor;
	long			outRound, outShift, interpRound, interpShift;
	double			dFactor;
	long			theElutSize;
	LUT_DATA_TYPE	localElut = nil;
	UINT16			*localElutPtr;
	OSErr			err = noErr;

	LH_START_PROC("Fill_ushort_ELUTs_from_lut16Tag")
	
	count     = 1 << addrBits;
	inTabLen  = inputTableEntries;

	theElutSize = theLutData->colorLutInDim * count * sizeof (UINT16);
	localElut   = ALLOC_DATA(theElutSize + 2, &err);
	if(err)
		goto CleanupAndExit;
	
	indFactor = ((inTabLen - 1) << 18) / (count - 1);	/* for adjusting indices */

	if(gridPoints == 0)
		maxOut = 65535;
	else
		maxOut = ((1L << (usedBits - 8) ) * 256 * (gridPoints - 1)) / gridPoints;

		/*-----find factor for the values that fits in 15 bits------*/
		/* (product with 16 bit number must fit in 31 bit uns.long)	*/
		/* n.b: 512 <= maxOut <= 65535  in all possible cases		*/
	
	dFactor  = (double)maxOut / 65535.;		/* 65535 is max. curve value */
	dFactor *= 4194304.;					/* same as << 22, certainly too much */
	
	outFactor = (long)dFactor;
	outRound  = (1L << 21) - 1;
	outShift  = 22;
	while(outFactor & 0xFFF8000)	/* stay within 15 bits to prevent product overflow */
	{
		outFactor >>= 1;
		outRound  >>= 1;
		outShift   -= 1;
	}
	
	interpRound = outRound >> 1;	/* with interpolation we have an additional...	*/
	interpShift = outShift  - 1;	/* ... >> 1 because we must add two nunmbers	*/
	
	LOCK_DATA(localElut);
	localElutPtr = (UINT16*)DATA_2_PTR(localElut);

	for(i=0; i<theLutData->colorLutInDim; i++)
	{
		curInLut = profELUT + (i * inTabLen);
		curELUT  = localElutPtr + (i * count);

		for(j=0; j<count; j++)
		{
			lAux    = (j * indFactor+4) >> 3;
			baseInd = (unsigned long)lAux >> 15;
			fract   = lAux & 0x7FFF;	/* 15 bits for interpolation */

			if(fract)		/* interpolation necessary ? */
			{
				lAux = (long)curInLut[baseInd] * outFactor >> 1;
				
				diff = (long)curInLut[baseInd+1] - (long)curInLut[baseInd];
				diff = ((diff * outFactor >> 15) * fract) >> 1;

				curELUT[j] = (UINT16)( (lAux + diff + interpRound) >> interpShift );
			}
			else
				curELUT[j] = (UINT16)( ((long)curInLut[baseInd] * outFactor
													+ outRound) >> outShift );
		}
	}
	UNLOCK_DATA(localElut);
	theLutData->inputLut = localElut;
	localElut = nil;
CleanupAndExit:	
	localElut = DISPOSE_IF_DATA(localElut);	
	LH_END_PROC("Fill_ushort_ELUTs_from_lut16Tag")
	return err;
}

/* ______________________________________________________________________

	CMError
	Fill_byte_ALUTs_from_lut16Tag(	CMLutParamPtr	theLutData,
									Ptr				profileALuts,
									char			addrBits,
								    long			outputTableEntries )
	Abstract:
		extracts output luts out of CMLut16Type tag and converts them
		to desired format: (2 ^ addrBits) values in a range from 0 to 255

	Params:
		theLutData			(in/out)	Ptr to structure that holds all the luts...
		profileALuts		(in)		Ptr to the profile's output luts
		addrBits			(in)		2 ^ addrBits values are requested
		outputTableEntries	(in)		number of entries in the output lut (up to 4096)
		
	Return:
		noErr		successful

   _____________________________________________________________________ */
CMError
Fill_byte_ALUTs_from_lut16Tag(	CMLutParamPtr	theLutData,
								Ptr				profileALuts,
								char			addrBits,
							    long			outputTableEntries )
{
	long			i, j;
	UINT16			*curOutLut;
	UINT8			*curALUT;
	long			count, clipIndex, outTabLen;
	long			indFactor, fract, baseInd, lAux;
	UINT16			*profALUTs = (UINT16*)profileALuts;
	OSErr			err = noErr;
	LUT_DATA_TYPE	localAlut = nil;
	UINT8			*localAlutPtr;
	long			theAlutSize;
	
	LH_START_PROC("Fill_byte_ALUTs_from_lut16Tag")
	
	count     = 1 << addrBits;								/* addrBits is always >= 8 */
	clipIndex = (1 << addrBits) - (1 << (addrBits - 8));	/* max XLUT output with 10 bit is at 1020, not at1023 */

	theAlutSize = theLutData->colorLutOutDim * count;
	localAlut   = ALLOC_DATA(theAlutSize + 1, &err);
	if (err)
		goto CleanupAndExit;
	
	outTabLen = outputTableEntries;					/* <= 4096 */
	indFactor = ((outTabLen - 1) << 18) / clipIndex;	/* for adjusting the indices */
	
	LOCK_DATA(localAlut);
	localAlutPtr = (UINT8*)DATA_2_PTR(localAlut);
	
	for(i=0; i<theLutData->colorLutOutDim; i++)
	{
		curOutLut = profALUTs + i * outTabLen;
		curALUT   = localAlutPtr + i * count;
		
		for(j=0; j<=clipIndex; j++)
		{
			lAux    = (j * indFactor+32) >> 6;
			baseInd = lAux >> 12;
			fract   = lAux & 0x0FFF;
			
			if(fract)
			{
				lAux = (long)curOutLut[baseInd + 1] - (long)curOutLut[baseInd];
				lAux = (lAux * fract + 0x0800) >> 12;
				
				curALUT[j] = (UINT8)(((long)curOutLut[baseInd] + lAux) >> 8);
			}
			else
				curALUT[j] = curOutLut[baseInd] >> 8;
		}
		
		for(j=clipIndex+1; j<count; j++)		/* unused indices, clip these */
			curALUT[j] = curALUT[clipIndex];
	}
	
	UNLOCK_DATA(localAlut);
	theLutData->outputLut = localAlut;
	localAlut = nil;
CleanupAndExit:
	localAlut = DISPOSE_IF_DATA(localAlut);
	
	LH_END_PROC("Fill_byte_ALUTs_from_lut16Tag")
	return err;
}

/* ______________________________________________________________________

	CMError
		MakeGamut16or32ForMonitor(	icXYZType		*pRedXYZ,
									icXYZType		*pGreenXYZ,
									icXYZType		*pBlueXYZ,
									unsigned short	**ppELUTs,
                                   UINT8			**ppXLUT,
                                   UINT8			**ppALUT,
									Boolean			cube32Flag )
	Abstract:
		Computes 3 ELUTs, XLUT and ALUT for gamut checking out of the
		3 monitor primaries. Color space is XYZ
		NOTE: Memory for the ELUTs, XLUt and ALUT is allocated here !

	Params:
		pRedXYZ			(in)		-> red primary of monitor
		pGreenXYZ		(in)		-> green primary of monitor
		pBlueXYZ		(in)		-> blue primary of monitor
		ppELUTs			(out)		3 input LUTs
		ppXLUT			(out)		3 dimensional byte Lut (32^3)
		ppALUT			(out)		Boolean output LUT (1024 bytes)
        cube32Flag		(in)		TRUE: 32*32*32 points, FALSE: 16*16*16 points
		
	Return:
		noErr		successful

   _____________________________________________________________________ */

CMError MakeGamut16or32ForMonitor	( 	icXYZType		*pRedXYZ,
							 			icXYZType		*pGreenXYZ,
							  			icXYZType		*pBlueXYZ,
							  			CMLutParamPtr	theLutData,
							  			Boolean			cube32Flag )

{
	double			XYZmatrix[3][3], RGBmatrix[3][3];
	double			sum, dFactor;
	long			i, j, k, gridPoints, planeCount, totalCount, longMat[9];
	long			longX, longY, longZ, longR, longG, longB;
	long			*lPtr, lFactor, maxOut;
	unsigned short	*usPtr;
	unsigned char	*XPtr;
	LUT_DATA_TYPE	tempXLutHdl	= nil;
	LUT_DATA_TYPE	tempELutHdl	= nil;
	LUT_DATA_TYPE	tempALutHdl	= nil;
	unsigned char   *tempXLut 	= nil;
	unsigned char   *tempALut 	= nil;
	unsigned short  *tempELut 	= nil;
	unsigned short	Levels[32];
	OSErr			err = noErr;
	
	LH_START_PROC("MakeGamut16or32ForMonitor")
	
	if(theLutData->inputLut != nil || theLutData->colorLut != nil || theLutData->outputLut != nil)
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	
	/*----------------------------------------------------------------------------------------- E */
	tempELutHdl = ALLOC_DATA(256 * 3 * sizeof(unsigned short), &err);
	if(err)
		goto CleanupAndExit;
	LOCK_DATA(tempELutHdl);
	tempELut = (unsigned short *)DATA_2_PTR(tempELutHdl);

	/*----------------------------------------------------------------------------------------- X */
	if(cube32Flag)
		gridPoints = 32;			/* for cube grid */
	else
		gridPoints = 16;
	totalCount = gridPoints * gridPoints * gridPoints;

	tempXLutHdl = ALLOC_DATA(totalCount, &err);
	if(err)
		goto CleanupAndExit;
	LOCK_DATA(tempXLutHdl);
	tempXLut = (unsigned char *)DATA_2_PTR(tempXLutHdl);
	
	/*----------------------------------------------------------------------------------------- A */
	tempALutHdl = ALLOC_DATA(adr_bereich_alut, &err);
	if(err)
		goto CleanupAndExit;
	LOCK_DATA(tempALutHdl);
	tempALut = (unsigned char *)DATA_2_PTR(tempALutHdl);
	
		/*---------fill 3 ELUTs for X, Y, Z (256 u.shorts each):--------------------*/
		/* linear curve with clipping, slope makes white value  become				*/
		/* max * 30.5/31 or max * 14.5/15, that is half of the last XLUT interval	*/
	if(cube32Flag)
		dFactor = 30.5 / 31.;
	else
		dFactor = 14.5 / 15.;
	
	maxOut = ((1L << (16 /*usedBits*/ - 8) ) * 256 * (gridPoints - 1)) / gridPoints;
	
	for(i=0; i<3; i++)		/* X, Y, Z ELUTs */
	{
		if(i == 0)
			lFactor = (long)( dFactor * 2. * maxOut * 256. / 255. / 0.9642 );/* X, adjust D50 */
		else if(i == 1)
			lFactor = (long)( dFactor * 2. * maxOut * 256. / 255.);			/* Y */
		else
			lFactor = (long)( dFactor * 2. * maxOut * 256. / 255. / 0.8249);/* Z, adjust D50 */
		
		usPtr = tempELut + 256 * i;
		for(j=0; j<256; j++)
		{
			k = (j * lFactor + 127) >> 8;
			if(k > maxOut)
				k = maxOut;		/* max. ELUT value */
			
			*usPtr++ = (unsigned short)k;
		}
	}

		/*------ RGB to XYZ matrix in the range 0.0 to 1.0 -----*/
		/* floating point for accurate inversion				*/
	XYZmatrix[0][0] = (double)pRedXYZ->data.data[0].X;
	XYZmatrix[1][0] = (double)pRedXYZ->data.data[0].Y;
	XYZmatrix[2][0] = (double)pRedXYZ->data.data[0].Z;

	XYZmatrix[0][1] = (double)pGreenXYZ->data.data[0].X;
	XYZmatrix[1][1] = (double)pGreenXYZ->data.data[0].Y;
	XYZmatrix[2][1] = (double)pGreenXYZ->data.data[0].Z;

	XYZmatrix[0][2] = (double)pBlueXYZ->data.data[0].X;
	XYZmatrix[1][2] = (double)pBlueXYZ->data.data[0].Y;
	XYZmatrix[2][2] = (double)pBlueXYZ->data.data[0].Z;
	
		/*--- grey with R = G = B (D50 adjustment is done by the ELUTs) ----*/
	for(i=0; i<3; i++)
	{
		sum = XYZmatrix[i][0] + XYZmatrix[i][1] + XYZmatrix[i][2];
		if(sum < 0.1)
			sum = 0.1;	/* prevent from div. by 0 (bad profiles) */
		
		for(j=0; j<3; j++)
			XYZmatrix[i][j] /= sum;
	}
	
		/*---XYZ to RGB matrix:---*/
	if(!doubMatrixInvert(XYZmatrix, RGBmatrix))
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	
	for(i=0; i<3; i++)				/* create integer format for speed, */
		for(j=0; j<3; j++)			/* 1.0 becomes 2^13, works for coeff. up to 8. */
			longMat[3*i + j] = (long)(RGBmatrix[i][j] * 8192.);
	
		/*-----grid levels for cube grid in XYZ (16 bit) so ----*/
		/* that white is at half of last interval, so the last	*/
		/* value is white * 15/14.5 or white * 31/30.5			*/
	if(cube32Flag)
		dFactor = 32768. / 30.5 * 31. / (gridPoints - 1);
	else
		dFactor = 32768. / 14.5 * 15. / (gridPoints - 1);

	for(i=0; i<gridPoints; i++)			/* n.b: 32 is max. possible gridPoints */
		Levels[i] = (unsigned short)(i * dFactor + 0.5);
	
		/*----special treatment of first and last plane for speed:----*/
	planeCount = gridPoints * gridPoints;
	XPtr       = tempXLut;
	for(i=0; i<planeCount; i++)
		*XPtr++ = 255;		/* out of gamut */
	
	XPtr = tempXLut + (gridPoints - 1) * planeCount;
	for(i=0; i<planeCount; i++)
		*XPtr++ = 255;		/* out of gamut */
	
	*tempXLut = 0;	/* set black (white is between last 2 planes) */

		/*----second to second last plane must be computed:-----*/
		/*  transform points to RGB and judge in/out			*/
	XPtr = tempXLut + planeCount;
		
	for(i=1; i<gridPoints-1; i++)
		for(j=0; j<gridPoints; j++)
			for(k=0; k<gridPoints; k++)
			{
				longX = (long)Levels[i];		/* X */
				longY = (long)Levels[j];		/* Y */
				longZ = (long)Levels[k];		/* Z */
				
					/* matrix coeff: 2^13 is 1.0 , XYZ values: 1.0 or 100. is 2^15 ;	*/
					/* -> mask for products < 0 and >= 2^28 is used for in/out checking	*/
				
				longR = longX * longMat[0] + longY * longMat[1] + longZ * longMat[2];
				if(longR & 0xF0000000)
					*XPtr++ = 255;		/* out of gamut */
				else
				{
					longG = longX * longMat[3] + longY * longMat[4] + longZ * longMat[5];
					if(longG & 0xF0000000)
						*XPtr++ = 255;		/* out of gamut */
					else
					{
						longB = longX * longMat[6] + longY * longMat[7] + longZ * longMat[8];
						if(longB & 0xF0000000)
							*XPtr++ = 255;		/* out of gamut */
						else
							*XPtr++ = 0;		/* in gamut */
					}
				}
			}
	
		/*---fill Boolean output LUT, adr_bereich_alut Bytes, 4 at one time with long:---*/
	lPtr = (long *)(tempALut);
	j = adr_bereich_alut/4/2 + 8;	/* slightly more than 50 % */
	for(i=0; i<j; i++)				/* slightly more than 50 % */
		*(lPtr + i) = 0;			/* in gamut */
	k = adr_bereich_alut/4;
	for(i=j; i<k; i++)
		*(lPtr + i) = 0xFFFFFFFF;	/* out of gamut */
	
	UNLOCK_DATA(tempELutHdl);
	UNLOCK_DATA(tempXLutHdl);
	UNLOCK_DATA(tempALutHdl);
	theLutData->colorLut	= tempXLutHdl;	tempXLutHdl = nil;
	theLutData->inputLut	= tempELutHdl;	tempELutHdl = nil;
	theLutData->outputLut	= tempALutHdl;	tempALutHdl = nil;
	
CleanupAndExit:
	tempELutHdl = DISPOSE_IF_DATA(tempELutHdl);
	tempXLutHdl = DISPOSE_IF_DATA(tempXLutHdl);
	tempALutHdl = DISPOSE_IF_DATA(tempALutHdl);
	LH_END_PROC("MakeGamut16or32ForMonitor")
	return (err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\runtime.h ===
/*
	File:		LHCMRuntime.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCMRuntime_h
#define LHCMRuntime_h



CMError
LHMatchColorsPrivate	 ( CMMModelPtr		modelingData,
						   CMColor			*myColors,
						   long				count );
CMError
LHCheckBitMapPrivate	( CMMModelPtr			modelingData,
						  const CMBitmap		*bitMap,
						  CMBitmapCallBackUPP	progressProc,
						  void* 				refCon,
						  CMBitmap 				*resultBitMap );

CMError
LHMatchBitMapPrivate	 ( CMMModelPtr			modelingData,
						   const CMBitmap *		bitMap,
						   CMBitmapCallBackUPP	progressProc,
						   void* 				refCon,
						   CMBitmap *			matchedBitMap );
			 	

CMError
LHCheckColorsPrivate	( CMMModelPtr		modelingData,
						  CMColor*			myColors,
						  UINT32    		count,
						  unsigned char		*result );

CMError
LHCheckColorsPrivateMS	( CMMModelPtr		modelingData,
						  CMColor*			myColors,
						  UINT32    		count,
						  UINT8				*result );


CMError
LHMatchBitMapPlanePrivate	 ( CMMModelPtr				modelingData,
							   const LH_CMBitmapPlane *	bitMapLH,
							   CMBitmapCallBackUPP		progressProc,
							   void* 					refCon,
							   LH_CMBitmapPlane *		matchedBitMapLH );
			 	


OSErr ConvertNamedIndexToPCS(	CMMModelPtr		cw,
								CMColor 		*theData,
								SINT32 			pixCnt );
OSErr
ConvertNamedIndexToColors	( CMMModelPtr	modelingData,
							  CMColor 		*theData,
							  long	 		pixCnt );

OSErr
ConvertPCSToNamedIndex ( CMMModelPtr modelingData,
						 CMColor 	 *theData,
						 long 		 pixCnt );

CMError ConvertLabToIndexBitmap(	CMMModelPtr	modelingData,
									Ptr 		InBuffer,
									UINT32		processedLinesIn,
									UINT32		inLineCount,
									UINT32		width,
									UINT32		rowBytes );
CMError ConvertIndexToLabBitmap(	CMMModelPtr	modelingData,
									Ptr		 	InBuffer,
									Ptr		 	OutBuffer,
									UINT32		processedLinesIn,
									UINT32		lineCount,
									UINT32		inWidth,
									UINT32		inRowBytes,
									UINT32		outRowBytes,
									UINT32		outputSize );
OSErr PreProcNamedColorMatchBitmap(	CMMModelPtr 	modelingData,
									CMBitmap 		*inBitMap,
									CMBitmap 		*outBitMap,
									Boolean		MatchInPlace );

OSErr MidProcNamedColorMatchBitmap(		CMMModelPtr modelingData,
										CMBitmap *InBitMap,
										Ptr dataOut,
										UINT32 startLine,
										UINT32 height);
									
OSErr PostProcNamedColorMatchBitmap	( CMMModelPtr modelingData,
									  CMBitmap *inBitMap,
									  CMBitmap *outBitMap);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\genup.c ===
/*
	File:		LHCalcGeneratorOnlyLookup.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

/* #define LH_CALC_ENGINE_SMALL */

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHCalcEngine_h
#include "CalcEng.h"
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCalcGeneratorLookupID
#endif

#define LH_ADR_BREIT_EIN_LUT   	adr_breite_elut
#define LH_ADR_BREIT_AUS_LUT   	adr_breite_alut


#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


#if LH_CALC_ENGINE_ALL_FORMATS_LO
CMError LHCalc3to3_Di8_Do8_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut8_G16_LO"
#include "Engineup.c"
#endif

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to3_Di8_Do8_Lut8_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut8_G32_LO"
#include "Engineup.c"

#if LH_CALC_ENGINE_ALL_FORMATS_LO
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to3_Di8_Do8_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to3_Di8_Do8_Lut16_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do8_Lut16_G32_LO"
#include "Engineup.c"

#if LH_CALC_ENGINE_MIXED_DATAFORMAT
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to3_Di8_Do16_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to3_Di8_Do16_Lut8_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do16_Lut8_G32_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to3_Di8_Do16_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do16_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to3_Di8_Do16_Lut16_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di8_Do16_Lut16_G32_LO"
#include "Engineup.c"

#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to3_Di16_Do8_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do8_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to3_Di16_Do8_Lut8_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do8_Lut8_G32_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to3_Di16_Do8_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do8_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to3_Di16_Do8_Lut16_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do8_Lut16_G32_LO"
#include "Engineup.c"
#else
#undef LH_DATA_IN_SIZE_16
#endif

#if LH_CALC_ENGINE_16_BIT_LO
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to3_Di16_Do16_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to3_Di16_Do16_Lut8_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do16_Lut8_G32_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to3_Di16_Do16_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do16_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to3_Di16_Do16_Lut16_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to3_Di16_Do16_Lut16_G32_LO"
#include "Engineup.c"

#endif
#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to4_Di8_Do8_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to4_Di8_Do8_Lut8_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut8_G32_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to4_Di8_Do8_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to4_Di8_Do8_Lut16_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do8_Lut16_G32_LO"
#include "Engineup.c"

#if LH_CALC_ENGINE_MIXED_DATAFORMAT
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to4_Di8_Do16_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to4_Di8_Do16_Lut8_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do16_Lut8_G32_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to4_Di8_Do16_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do16_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to4_Di8_Do16_Lut16_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di8_Do16_Lut16_G32_LO"
#include "Engineup.c"

#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to4_Di16_Do8_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do8_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to4_Di16_Do8_Lut8_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do8_Lut8_G32_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to4_Di16_Do8_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do8_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to4_Di16_Do8_Lut16_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do8_Lut16_G32_LO"
#include "Engineup.c"
#else
#undef LH_DATA_IN_SIZE_16
#endif

#if LH_CALC_ENGINE_16_BIT_LO
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to4_Di16_Do16_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to4_Di16_Do16_Lut8_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do16_Lut8_G32_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc3to4_Di16_Do16_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do16_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		0
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		5


CMError LHCalc3to4_Di16_Do16_Lut16_G32_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc3to4_Di16_Do16_Lut16_G32_LO"
#include "Engineup.c"

#endif
#undef LH_DATA_IN_COUNT_4
#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to3_Di8_Do8_Lut8_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut8_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to3_Di8_Do8_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to3_Di8_Do8_Lut16_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut16_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to3_Di8_Do8_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do8_Lut16_G16_LO"
#include "Engineup.c"

#if LH_CALC_ENGINE_MIXED_DATAFORMAT
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to3_Di8_Do16_Lut8_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do16_Lut8_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to3_Di8_Do16_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to3_Di8_Do16_Lut16_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to3_Di8_Do16_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di8_Do16_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to3_Di16_Do8_Lut8_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do8_Lut8_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to3_Di16_Do8_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do8_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to3_Di16_Do8_Lut16_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do8_Lut16_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to3_Di16_Do8_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do8_Lut16_G16_LO"
#include "Engineup.c"
#else
#undef LH_DATA_IN_SIZE_16
#endif

#if LH_CALC_ENGINE_16_BIT_LO
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to3_Di16_Do16_Lut8_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do16_Lut8_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to3_Di16_Do16_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to3_Di16_Do16_Lut16_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do16_Lut16_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	0
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to3_Di16_Do16_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to3_Di16_Do16_Lut16_G16_LO"
#include "Engineup.c"
#endif

#undef LH_DATA_OUT_COUNT_4
#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to4_Di8_Do8_Lut8_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut8_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to4_Di8_Do8_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to4_Di8_Do8_Lut16_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut16_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to4_Di8_Do8_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do8_Lut16_G16_LO"
#include "Engineup.c"

#if LH_CALC_ENGINE_MIXED_DATAFORMAT
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to4_Di8_Do16_Lut8_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do16_Lut8_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to4_Di8_Do16_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to4_Di8_Do16_Lut16_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do16_Lut16_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		0
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to4_Di8_Do16_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di8_Do16_Lut16_G16_LO"
#include "Engineup.c"

#undef LH_DATA_IN_SIZE_16
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to4_Di16_Do8_Lut8_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do8_Lut8_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to4_Di16_Do8_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do8_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to4_Di16_Do8_Lut16_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do8_Lut16_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		0
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to4_Di16_Do8_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do8_Lut16_G16_LO"
#include "Engineup.c"
#else
#undef LH_DATA_IN_SIZE_16
#endif

#if LH_CALC_ENGINE_16_BIT_LO
#undef LH_DATA_OUT_SIZE_16
#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to4_Di16_Do16_Lut8_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do16_Lut8_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		0
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to4_Di16_Do16_Lut8_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do16_Lut8_G16_LO"
#include "Engineup.c"

#undef LH_LUT_DATA_SIZE_16
#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		3


CMError LHCalc4to4_Di16_Do16_Lut16_G8_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do16_Lut16_G8_LO"
#include "Engineup.c"

#undef LH_BIT_BREIT_ADR

#define LH_DATA_IN_COUNT_4 		1
#define LH_DATA_OUT_COUNT_4 	1
#define LH_DATA_IN_SIZE_16 		1
#define LH_DATA_OUT_SIZE_16		1
#define LH_LUT_DATA_SIZE_16		1
#define LH_BIT_BREIT_ADR		4


CMError LHCalc4to4_Di16_Do16_Lut16_G16_LO( CMCalcParamPtr calcParam, CMLutParamPtr lutParam )
#define LH_CALC_PROC_NAME "LHCalc4to4_Di16_Do16_Lut16_G16_LO"
#include "Engineup.c"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\profile.h ===
/*
	File:		LHICCProfile.h

	Contains:	

	Version:	

	Copyright:	 see below
*/

/* Header file guard bands */
#ifndef LHICCProfile_h
#define LHICCProfile_h

/***************************************************************** 
 Copyright (c) 1994 SunSoft, Inc.

                    Rights Reserved

Permission is hereby granted, free of charge, to any person 
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict- 
ion, including without limitation the rights to use, copy, modify, 
merge, publish distribute, sublicense, and/or sell copies of the 
Software, and to permit persons to whom the Software is furnished 
to do so, subject to the following conditions: 
 
The above copyright notice and this permission notice shall be 
included in all copies or substantial portions of the Software. 
 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT 
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
OTHER DEALINGS IN THE SOFTWARE. 
 
Except as contained in this notice, the name of SunSoft, Inc. 
shall not be used in advertising or otherwise to promote the 
sale, use or other dealings in this Software without written 
authorization from SunSoft Inc. 
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.0.1, and includes support for the
 * Named Color profile type approved August 1995.
 *
 * All header file entries are pre-fixed with "ic" to help 
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array 
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file. 
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.  Note strlen + 1
 * to remember NULL terminator.
 *
		icUcrBgCurve		*ucrCurve, *bgCurve;
		int				ucr_nbytes, bg_nbytes, string_bytes;
		icUcrBg				*ucrBgWrite;
		char				ucr_string[100], *ucr_char;

		strcpy(ucr_string, "Example ucrBG curves");
		ucr_nbytes = sizeof(icUInt32Number) + 
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
		bg_nbytes = sizeof(icUInt32Number) + 
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));
		string_bytes = strlen(ucr_string) + 1;

		ucrBgWrite = (icUcrBg *)malloc(
								(ucr_nbytes + bg_nbytes + string_bytes));
 
		ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
		ucrCurve->count = UCR_CURVE_SIZE;
		for (i=0; i<ucrCurve->count; i++)
				ucrCurve->curve[i] = (icUInt16Number)i;
 
		bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
		bgCurve->count = BG_CURVE_SIZE;
		for (i=0; i<bgCurve->count; i++)
				bgCurve->curve[i] = 255 - (icUInt16Number)i;

		ucr_char = (char *)((char *)bgCurve + bg_nbytes);
		memcpy(ucr_char, ucr_string, string_bytes);
 *
 */

/*------------------------------------------------------------------------*/
/*
 * Use this area to translate platform definitions of long
 * etc into icXXX form. The rest of the header uses the icXXX
 * typedefs. Signatures are 4 byte quantities.
 */
 
#if defined(__MWERKS__) || defined(__PPCC__) || defined(WIN32) || defined(SYM_C) || defined(__MRC__)

/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char		icUInt8Number;
typedef unsigned short		icUInt16Number;
typedef unsigned long		icUInt32Number;
typedef unsigned long		icUInt64Number[2];

typedef icUInt32Number 		icSignature;

/* Signed numbers */
typedef char				icInt8Number;
typedef short				icInt16Number;
typedef long				icInt32Number;
typedef long				icInt64Number[2];

/* Fixed numbers */
typedef icInt32Number		icS15Fixed16Number;
typedef	icUInt32Number		icU16Fixed16Number;
#endif /* __MWERKS__ || WIN32 || SYM_C || __MRC__ */

#if 0		

#ifdef __sgi
/* #include "sgidefs.h" */

typedef __int32_t     		icSignature;

/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char		icUInt8Number;
typedef unsigned short		icUInt16Number;
typedef __uint32_t			icUInt32Number;
typedef __uint32_t			icUInt64Number[2];

/* Signed numbers */
typedef char				icInt8Number;
typedef short				icInt16Number;
typedef __int32_t			icInt32Number;
typedef __int32_t			icInt64Number[2];

/* Fixed numbers */
typedef __int32_t			icS15Fixed16Number;
typedef	__uint32_t			icU16Fixed16Number;
#endif /* Silicon Graphics */

#endif

#if defined(unix) || defined(__unix) || defined(__unix__) 	/* 32-bit UNIX */

typedef long				icSignature;

/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char		icUInt8Number;
typedef unsigned short		icUInt16Number;
typedef unsigned long		icUInt32Number;
typedef unsigned long		icUInt64Number[2];

/* Signed numbers */
typedef char				icInt8Number;
typedef short				icInt16Number;
typedef long				icInt32Number;
typedef long				icInt64Number[2];

/* Fixed numbers */
typedef long				icS15Fixed16Number;
typedef	unsigned long		icU16Fixed16Number;

#endif		/* 32-bit UNIX */


/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *		type		data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define	icMagicNumber						0x61637370L		/* 'acsp' */
#define icVersionNumber						0x02000000L		/* 2.0, BCD */

/* Screening Encodings */
#define	icPrtrDefaultScreensFalse			0x00000000L		/* Bit position 0 */
#define	icPrtrDefaultScreensTrue			0x00000001L		/* Bit position 0 */
#define icLinesPerInch						0x00000002L		/* Bit position 1 */
#define icLinesPerCm						0x00000000L		/* Bit position 1 */

/* 
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective						0x00000000L		/* Bit position 0 */
#define icTransparency						0x00000001L		/* Bit position 0 */
#define icGlossy							0x00000000L		/* Bit position 1 */
#define icMatte								0x00000002L		/* Bit position 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define	icEmbeddedProfileFalse				0x00000000L		/* Bit position 0 */
#define	icEmbeddedProfileTrue				0x00000001L		/* Bit position 0 */
#define icUseAnywhere						0x00000000L		/* Bit position 1 */
#define icUseWithEmbeddedDataOnly			0x00000002L		/* Bit position 1 */

/* Ascii or Binary data */
#define icAsciiData							0x00000000L		/* Used in dataType */
#define icBinaryData						0x00000001L

/* 
 * Define used to indicate that this is a variable length array
 */
#define icAny								1


/*------------------------------------------------------------------------*/
/* public tags and sizes */
typedef enum {
    icSigAToB0Tag						= 0x41324230L,		/* 'A2B0' */ 
    icSigAToB1Tag						= 0x41324231L,		/* 'A2B1' */
    icSigAToB2Tag						= 0x41324232L,		/* 'A2B2' */ 
    icSigBlueColorantTag				= 0x6258595AL,		/* 'bXYZ' */
    icSigBlueTRCTag						= 0x62545243L,		/* 'bTRC' */
    icSigBToA0Tag						= 0x42324130L,		/* 'B2A0' */
    icSigBToA1Tag						= 0x42324131L,		/* 'B2A1' */
    icSigBToA2Tag						= 0x42324132L,		/* 'B2A2' */
    icSigCalibrationDateTimeTag			= 0x63616C74L,		/* 'calt' */
    icSigCharTargetTag					= 0x74617267L,		/* 'targ' */ 
    icSigCopyrightTag					= 0x63707274L,		/* 'cprt' */
    icSigDeviceMfgDescTag				= 0x646D6E64L,		/* 'dmnd' */
    icSigDeviceModelDescTag				= 0x646D6464L,		/* 'dmdd' */
    icSigGamutTag						= 0x67616D74L,		/* 'gamt ' */
    icSigGrayTRCTag						= 0x6b545243L,		/* 'kTRC' */
    icSigGreenColorantTag				= 0x6758595AL,		/* 'gXYZ' */
    icSigGreenTRCTag					= 0x67545243L,		/* 'gTRC' */
    icSigLuminanceTag					= 0x6C756d69L,		/* 'lumi' */
    icSigMeasurementTag					= 0x6D656173L,		/* 'meas' */
    icSigMediaBlackPointTag				= 0x626B7074L,		/* 'bkpt' */
    icSigMediaWhitePointTag				= 0x77747074L,		/* 'wtpt' */
    icSigNamedColorTag					= 0x6E636f6CL,		/* 'ncol' 
															 * OBSOLETE, use ncl2 */
    icSigPreview0Tag					= 0x70726530L,		/* 'pre0' */
    icSigPreview1Tag					= 0x70726531L,		/* 'pre1' */
    icSigPreview2Tag					= 0x70726532L,		/* 'pre2' */
    icSigProfileDescriptionTag			= 0x64657363L,		/* 'desc' */
    icSigProfileSequenceDescTag			= 0x70736571L,		/* 'pseq' */
    icSigPs2CRD0Tag						= 0x70736430L,		/* 'psd0' */
    icSigPs2CRD1Tag						= 0x70736431L,		/* 'psd1' */
    icSigPs2CRD2Tag						= 0x70736432L,		/* 'psd2' */
    icSigPs2CRD3Tag						= 0x70736433L,		/* 'psd3' */
    icSigPs2CSATag						= 0x70733273L,		/* 'ps2s' */
    icSigPs2RenderingIntentTag			= 0x70733269L,		/* 'ps2i' */
    icSigRedColorantTag					= 0x7258595AL,		/* 'rXYZ' */
    icSigRedTRCTag						= 0x72545243L,		/* 'rTRC' */
    icSigScreeningDescTag				= 0x73637264L,		/* 'scrd' */
    icSigScreeningTag					= 0x7363726EL,		/* 'scrn' */
    icSigTechnologyTag					= 0x74656368L,		/* 'tech' */
    icSigUcrBgTag						= 0x62666420L,		/* 'bfd ' */
    icSigViewingCondDescTag				= 0x76756564L,		/* 'vued' */
    icSigViewingConditionsTag			= 0x76696577L,		/* 'view' */
    icSigNamedColor2Tag					= 0x6E636C32L,		/* 'ncl2' */
    icMaxEnumTag						= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icTagSignature;

/* technology signature descriptions */
typedef enum {
    icSigDigitalCamera					= 0x6463616DL,		/* 'dcam' */
    icSigFilmScanner					= 0x6673636EL,		/* 'fscn' */
    icSigReflectiveScanner				= 0x7273636EL,		/* 'rscn' */
    icSigInkJetPrinter					= 0x696A6574L,		/* 'ijet' */ 
    icSigThermalWaxPrinter				= 0x74776178L,		/* 'twax' */
    icSigElectrophotographicPrinter		= 0x6570686FL,		/* 'epho' */
    icSigElectrostaticPrinter			= 0x65737461L,		/* 'esta' */
    icSigDyeSublimationPrinter			= 0x64737562L,		/* 'dsub' */
    icSigPhotographicPaperPrinter		= 0x7270686FL,		/* 'rpho' */
    icSigFilmWriter						= 0x6670726EL,		/* 'fprn' */
    icSigVideoMonitor					= 0x7669646DL,		/* 'vidm' */
    icSigVideoCamera					= 0x76696463L,		/* 'vidc' */
    icSigProjectionTelevision			= 0x706A7476L,		/* 'pjtv' */
    icSigCRTDisplay						= 0x43525420L,		/* 'CRT ' */
    icSigPMDisplay						= 0x504D4420L,		/* 'PMD ' */
    icSigAMDisplay						= 0x414D4420L,		/* 'AMD ' */
    icSigPhotoCD						= 0x4B504344L,		/* 'KPCD' */
    icSigPhotoImageSetter				= 0x696D6773L,		/* 'imgs' */
    icSigGravure						= 0x67726176L,		/* 'grav' */
    icSigOffsetLithography				= 0x6F666673L,		/* 'offs' */
    icSigSilkscreen						= 0x73696C6BL, 		/* 'silk' */
    icSigFlexography					= 0x666C6578L,		/* 'flex' */
    icMaxEnumTechnology					= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icTechnologySignature;

/* type signatures */
typedef enum {
    icSigCurveType						= 0x63757276L,		/* 'curv' */
    icSigDataType						= 0x64617461L,		/* 'data' */
    icSigDateTimeType					= 0x6474696DL,		/* 'dtim' */
    icSigLut16Type						= 0x6d667432L,		/* 'mft2' */
    icSigLut8Type						= 0x6d667431L,		/* 'mft1' */
    icSigMeasurementType				= 0x6D656173L,		/* 'meas' */
    icSigNamedColorType					= 0x6E636f6CL,		/* 'ncol' 
															 * OBSOLETE, use ncl2 */
    icSigProfileSequenceDescType		= 0x70736571L,		/* 'pseq' */
    icSigS15Fixed16ArrayType			= 0x73663332L,		/* 'sf32' */
    icSigScreeningType					= 0x7363726EL,		/* 'scrn' */
    icSigSignatureType					= 0x73696720L,		/* 'sig ' */
    icSigTextType						= 0x74657874L,		/* 'text' */
    icSigTextDescriptionType			= 0x64657363L,		/* 'desc' */
    icSigU16Fixed16ArrayType			= 0x75663332L,		/* 'uf32' */
    icSigUcrBgType						= 0x62666420L,		/* 'bfd ' */
    icSigUInt16ArrayType				= 0x75693136L,		/* 'ui16' */
    icSigUInt32ArrayType				= 0x75693332L,		/* 'ui32' */
    icSigUInt64ArrayType				= 0x75693634L,		/* 'ui64' */
    icSigUInt8ArrayType					= 0x75693038L,		/* 'ui08' */
    icSigViewingConditionsType			= 0x76696577L,		/* 'view' */
    icSigXYZType						= 0x58595A20L,		/* 'XYZ ' */
    icSigXYZArrayType					= 0x58595A20L,		/* 'XYZ ' */
    icSigNamedColor2Type				= 0x6E636C32L,		/* 'ncl2' */
    icMaxEnumType						= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icTagTypeSignature;

/* 
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */ 
typedef enum {
    icSigXYZData						= 0x58595A20L,		/* 'XYZ ' */
    icSigLabData						= 0x4C616220L,		/* 'Lab ' */
    icSigLuvData						= 0x4C757620L,		/* 'Luv ' */
    icSigYCbCrData						= 0x59436272L,		/* 'YCbr' */
    icSigYxyData						= 0x59787920L,		/* 'Yxy ' */
    icSigRgbData						= 0x52474220L,		/* 'RGB ' */
    icSigGrayData						= 0x47524159L,		/* 'GRAY' */
    icSigHsvData						= 0x48535620L,		/* 'HSV ' */
    icSigHlsData						= 0x484C5320L,		/* 'HLS ' */
    icSigCmykData						= 0x434D594BL,		/* 'CMYK' */
    icSigCmyData						= 0x434D5920L,		/* 'CMY ' */
    
    icSigMCH2Data						= 0x32434C52L,		/* '2CLR' */		
    icSigMCH3Data						= 0x33434C52L,		/* '3CLR' */		
    icSigMCH4Data						= 0x34434C52L,		/* '4CLR' */		
	icSigMCH5Data						= 0x35434C52L,		/* '5CLR' */
	icSigMCH6Data						= 0x36434C52L,		/* '6CLR' */
	icSigMCH7Data						= 0x37434C52L,		/* '7CLR' */
	icSigMCH8Data						= 0x38434C52L,		/* '8CLR' */
	icSigMCH9Data						= 0x39434C52L,		/* '9CLR' */
	icSigMCHAData						= 0x41434C52L,		/* 'ACLR' */
	icSigMCHBData						= 0x42434C52L,		/* 'BCLR' */
	icSigMCHCData						= 0x43434C52L,		/* 'CCLR' */
	icSigMCHDData						= 0x44434C52L,		/* 'DCLR' */
	icSigMCHEData						= 0x45434C52L,		/* 'ECLR' */
	icSigMCHFData						= 0x46434C52L,		/* 'FCLR' */
    icSigNamedData						= 0x6e6d636cL,		/* 'nmcl' */

    icMaxEnumData						= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icColorSpaceSignature;

/* profileClass enumerations */
typedef enum {
    icSigInputClass						= 0x73636E72L,		/* 'scnr' */
    icSigDisplayClass					= 0x6D6E7472L,		/* 'mntr' */
    icSigOutputClass					= 0x70727472L,		/* 'prtr' */
    icSigLinkClass						= 0x6C696E6BL,		/* 'link' */
    icSigAbstractClass					= 0x61627374L,		/* 'abst' */
    icSigColorSpaceClass				= 0x73706163L,		/* 'spac' */
    icSigNamedColorClass                = 0x6e6d636cL,		/* 'nmcl' */
    icMaxEnumClass						= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icProfileClassSignature;

/* Platform Signatures */
typedef enum {
    icSigMacintosh						= 0x4150504CL,		/* 'APPL' */
    icSigMicrosoft						= 0x4D534654L,		/* 'MSFT' */
    icSigSolaris						= 0x53554E57L,		/* 'SUNW' */
    icSigSGI							= 0x53474920L,		/* 'SGI ' */
    icSigTaligent						= 0x54474E54L,		/* 'TGNT' */
    icMaxEnumPlatform					= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icPlatformSignature;

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef enum {
    icFlare0							= 0x00000000L,		/* 0% flare */
    icFlare100							= 0x00000001L,		/* 100% flare */
    icMaxFlare							= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icMeasurementFlare;

/* Measurement Geometry, used in the measurmentType tag */
typedef enum {
    icGeometryUnknown					= 0x00000000L,		/* Unknown geometry */
    icGeometry045or450					= 0x00000001L,		/* 0/45 or 45/0 */
    icGeometry0dord0					= 0x00000002L,		/* 0/d or d/0 */
    icMaxGeometry						= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icMeasurementGeometry;

/* Rendering Intents, used in the profile header */
typedef enum {
    icPerceptual						= 0,
    icRelativeColorimetric				= 1,
    icSaturation						= 2,
    icAbsoluteColorimetric				= 3,
    icMaxEnumIntent						= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icRenderingIntent;

/* Different Spot Shapes currently defined, used for screeningType */
typedef enum {
    icSpotShapeUnknown					= 0,
    icSpotShapePrinterDefault			= 1,
    icSpotShapeRound					= 2,
    icSpotShapeDiamond					= 3,
    icSpotShapeEllipse					= 4,
    icSpotShapeLine						= 5,
    icSpotShapeSquare					= 6,
    icSpotShapeCross					= 7,
    icMaxEnumSpot						= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icSpotShape;

/* Standard Observer, used in the measurmentType tag */
typedef enum {
    icStdObsUnknown						= 0x00000000L,		/* Unknown observer */
    icStdObs1931TwoDegrees				= 0x00000001L,		/* 1931 two degrees */
    icStdObs1964TenDegrees				= 0x00000002L,		/* 1961 ten degrees */
    icMaxStdObs							= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icStandardObserver;

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef enum {
    icIlluminantUnknown					= 0x00000000L,
    icIlluminantD50						= 0x00000001L,
    icIlluminantD65						= 0x00000002L,
    icIlluminantD93						= 0x00000003L,
    icIlluminantF2						= 0x00000004L,
    icIlluminantD55						= 0x00000005L,
    icIlluminantA						= 0x00000006L,
    icIlluminantEquiPowerE				= 0x00000007L,		/* Equi-Power (E) */
    icIlluminantF8						= 0x00000008L,		
    icMaxEnumIluminant					= 0xFFFFFFFFL		/* enum = 4 bytes max */
} icIlluminant;


/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers 
 */

/* Int8 Array */
typedef struct {
    icInt8Number		data[icAny];		/* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number		data[icAny];		/* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number		data[icAny];		/* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number		data[icAny];		/* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number		data[icAny];		/* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number		data[icAny];		/* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number		data[icAny];		/* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number		data[icAny];		/* Variable array of values */
} icInt64Array;
    
/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number	data[icAny];		/* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number	data[icAny];		/* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number		year;
    icUInt16Number		month;
    icUInt16Number		day;
    icUInt16Number		hours;
    icUInt16Number		minutes;
    icUInt16Number		seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number		X;
    icS15Fixed16Number		Y;
    icS15Fixed16Number		Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber			data[icAny];		/* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number		count;				/* Number of entries */
    icUInt16Number		data[icAny];		/* The actual table data, real
		            	                     * number is determined by count
											 * Interpretation depends on how
											 * data is used with a given tag.
											 */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number		dataFlag;			/* 0 = ascii, 1 = binary */
    icInt8Number		data[icAny];		/* Data, size determined from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number		inputChan;			/* Number of input channels */
    icUInt8Number		outputChan;			/* Number of output channels */
    icUInt8Number		clutPoints;			/* Number of clutTable grid points */
    icInt8Number		pad;				/* Padding for byte alignment */
    icS15Fixed16Number	e00;				/* e00 in the 3 * 3 */
    icS15Fixed16Number	e01;				/* e01 in the 3 * 3 */    
    icS15Fixed16Number	e02;				/* e02 in the 3 * 3 */
    icS15Fixed16Number	e10;				/* e10 in the 3 * 3 */
    icS15Fixed16Number	e11;				/* e11 in the 3 * 3 */    
    icS15Fixed16Number	e12;				/* e12 in the 3 * 3 */ 
    icS15Fixed16Number	e20;				/* e20 in the 3 * 3 */
    icS15Fixed16Number	e21;				/* e21 in the 3 * 3 */    
    icS15Fixed16Number	e22;				/* e22 in the 3 * 3 */
    icUInt16Number		inputEnt;			/* Number of input table entries */
    icUInt16Number		outputEnt;			/* Number of output table entries */
    icUInt16Number		data[icAny];		/* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number		inputTable[inputChan][icAny];		* The input table
 *  icUInt16Number		clutTable[icAny];					* The clut table
 *  icUInt16Number		outputTable[outputChan][icAny];		* The output table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number		inputChan;			/* Number of input channels */
    icUInt8Number		outputChan;			/* Number of output channels */
    icUInt8Number		clutPoints;			/* Number of clutTable grid points */
    icInt8Number		pad;
    icS15Fixed16Number	e00;				/* e00 in the 3 * 3 */
    icS15Fixed16Number	e01;				/* e01 in the 3 * 3 */    
    icS15Fixed16Number	e02;				/* e02 in the 3 * 3 */
    icS15Fixed16Number	e10;				/* e10 in the 3 * 3 */
    icS15Fixed16Number	e11;				/* e11 in the 3 * 3 */    
    icS15Fixed16Number	e12;				/* e12 in the 3 * 3 */ 
    icS15Fixed16Number	e20;				/* e20 in the 3 * 3 */
    icS15Fixed16Number	e21;				/* e21 in the 3 * 3 */    
    icS15Fixed16Number	e22;				/* e22 in the 3 * 3 */
    icUInt8Number		data[icAny];		/* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number		inputTable[inputChan][256];		* The input table
 *  icUInt8Number		clutTable[icAny];				* The clut table
 *  icUInt8Number		outputTable[outputChan][256];	* The output table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver			stdObserver;	/* Standard observer */
    icXYZNumber					backing;		/* XYZ for backing material */
    icMeasurementGeometry		geometry;		/* Measurement geometry */
    icMeasurementFlare			flare;			/* Measurement flare */
    icIlluminant				illuminant;		/* Illuminant */
} icMeasurement;

/* Named color */

/*
 * icNamedColor2 takes the place of icNamedColor, approved at the
 * SIGGRAPH 95, ICC meeting.
 */
typedef struct {
    icUInt32Number		vendorFlag;				/* Bottom 16 bits for IC use */
    icUInt32Number		count;					/* Count of named colors */
    icUInt32Number		nDeviceCoords;			/* Number of device coordinates */
    icInt8Number		prefix[32];				/* Prefix for each color name */
    icInt8Number		suffix[32];				/* Suffix for each color name */
    icInt8Number		data[icAny];			/* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number			root1[32];				* Root name for first color
 * icUInt16Number		pcsCoords1[icAny];		* PCS coordinates of first color
 * icUInt16Number		deviceCoords1[icAny];	* Device coordinates of first color
 * icInt8Number			root2[32];				* Root name for second color
 * icUInt16Number		pcsCoords2[icAny];		* PCS coordinates of first color
 * icUInt16Number		deviceCoords2[icAny];	* Device coordinates of first color
 *						:
 *						:
 * Repeat for name and PCS and device color coordinates up to (count-1)
 * 
 * NOTES:  
 * PCS and device space can be determined from the header.
 *
 * PCS coordinates are icUInt16 numbers and are described in section 2.6 of 
 * the ICC spec. Only 16 bit L*a*b* and XYZ are allowed. The number of 
 * coordinates is consistent with the headers PCS.
 *
 * Device coordinates are icUInt16 numbers where 0x0000 represents
 * the minimum value and 0xFFFF represents the maximum value. 
 * If the nDeviceCoords value is 0 this field is not given.
 */
} icNamedColor2;

/* Profile sequence structure */
typedef struct {
    icSignature				deviceMfg;			/* Device Manufacturer */
    icSignature				deviceModel;		/* Decvice Model */
    icUInt64Number			attributes;			/* Device attributes */
    icTechnologySignature	technology;			/* Technology signature */
    icInt8Number			data[icAny];		/* Descriptions text follows */
/*
 *  Data that follows is of this form, this is an icInt8Number
 *  to avoid problems with a compiler generating  bad code as 
 *  these arrays are variable in length.
 *
 * icTextDescription		deviceMfgDesc;		* Manufacturer text
 * icTextDescription    	modelDesc;			* Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number			count;				/* Number of descriptions */
    icUInt8Number			data[icAny];		/* Array of description struct */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number			count;				/* Description length */
    icInt8Number			data[icAny];		/* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number				desc[count]			* NULL terminated ascii string
 * icUInt32Number			ucLangCode;			* UniCode language code
 * icUInt32Number			ucCount;			* UniCode description length
 * icInt16Number			ucDesc[ucCount];	* The UniCode description
 * icUInt16Number			scCode;				* ScriptCode code
 * icUInt8Number			scCount;			* ScriptCode count
 * icInt8Number				scDesc[67];			* ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number		frequency;			/* Frequency */
    icS15Fixed16Number		angle;				/* Screen angle */
    icSpotShape				spotShape;			/* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number			screeningFlag;		/* Screening flag */
    icUInt32Number			channels;			/* Number of channels */
    icScreeningData			data[icAny];		/* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number			data[icAny];		/* Variable array of characters */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number			count;				/* Curve length */
    icUInt16Number			curve[icAny];		/* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icInt8Number			data[icAny];		/* The Ucr BG data */
/*
 *  Data that follows is of this form, this is a icInt8Number
 *  to avoid problems with a compiler generating  bad code as 
 *  these arrays are variable in length.
 *
 * icUcrBgCurve				ucr;				* Ucr curve
 * icUcrBgCurve				bg;					* Bg curve
 * icInt8Number				string;				* UcrBg description
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber				illuminant;			/* In candelas per metre sq'd */
    icXYZNumber				surround;			/* In candelas per metre sq'd */
    icIlluminant			stdIluminant;		/* See icIlluminant defines */
} icViewingCondition;


/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *		type		data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature		sig;				/* Signature */
    icInt8Number			reserved[4];		/* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase				base;				/* Signature, "curv" */
    icCurve					curve;				/* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase				base;				/* Signature, "data" */
    icData					data;				/* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase				base;				/* Signature, "dtim" */
    icDateTimeNumber		date;				/* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase				base;				/* Signature, "mft2" */
    icLut16					lut;				/* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase				base;				/* Signature, "mft1" */
    icLut8					lut;				/* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase				base;				/* Signature, "meas" */
    icMeasurement			measurement;		/* Measurement data */
} icMeasurementType;

/* Named color type */
/* icNamedColor2Type, replaces icNamedColorType */
typedef struct {
    icTagBase				base;				/* Signature, "ncl2" */
    icNamedColor2			ncolor;				/* Named color data */
} icNamedColor2Type;

/* Profile sequence description type */
typedef struct {
    icTagBase				base;				/* Signature, "pseq" */
    icProfileSequenceDesc	desc;				/* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase				base;				/* Signature, "desc" */
    icTextDescription		desc;				/* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase				base;				/* Signature, "sf32" */
    icS15Fixed16Array		data;				/* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase				base;				/* Signature, "scrn" */
    icScreening				screen;				/* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase				base;				/* Signature, "sig" */
    icSignature				signature;			/* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase				base;				/* Signature, "text" */
    icText					data;				/* Variable array of characters */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase				base;				/* Signature, "uf32" */
    icU16Fixed16Array		data;				/* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase				base;				/* Signature, "bfd " */
    icUcrBg					data;				/* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase				base;				/* Signature, "ui16" */
    icUInt16Array			data;				/* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase				base;				/* Signature, "ui32" */
    icUInt32Array			data;				/* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase				base;				/* Signature, "ui64" */
    icUInt64Array			data;				/* Variable array of values */
} icUInt64ArrayType;
    
/* uInt8Type */
typedef struct {
    icTagBase				base;				/* Signature, "ui08" */
    icUInt8Array			data;				/* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase				base;				/* Signature, "view" */
    icViewingCondition		view;				/* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase				base;				/* Signature, "XYZ" */
    icXYZArray				data;				/* Variable array of XYZ numbers */
} icXYZType;

/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile strcuture
 */

/* A tag */
typedef struct {
    icTagSignature			sig;				/* The tag signature */
    icUInt32Number			offset;				/* Start of tag relative to 
								 				 * start of header, Spec Section 8 */
    icUInt32Number			size;				/* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number			count;				/* Number of tags in the profile */
    icTag					tags[icAny];		/* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number			size;				/* Profile size in bytes */
    icSignature				cmmId;				/* CMM for this profile */
    icUInt32Number			version;			/* Format version number */
    icProfileClassSignature	deviceClass;		/* Type of profile */
    icColorSpaceSignature	colorSpace;			/* Color space of data */
    icColorSpaceSignature	pcs;				/* PCS, XYZ or Lab only */
    icDateTimeNumber		date;				/* Date profile was created */
    icSignature				magic;				/* icMagicNumber */
    icPlatformSignature		platform;			/* Primary Platform */
    icUInt32Number			flags;				/* Various bit settings */
    icSignature				manufacturer;		/* Device manufacturer */
    icUInt32Number			model;				/* Device model number */
    icUInt64Number			attributes;			/* Device attributes */
    icUInt32Number			renderingIntent;	/* Rendering intent */
    icXYZNumber				illuminant;			/* Profile illuminant */
	icSignature 			creator;			/* profile creator */
    icInt8Number			reserved[44];		/* Reserved for future use */
} icHeader;

/* 
 * A profile, 
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader				header;				/* The header */
    icTagList				tagList;			/* WERNER */
    /* Original:
    icHeader				header;				The header 
  	icUInt32Number			count;				Number of tags in the profile 
    icInt8Number			data[icAny];		The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag					tagTable[icAny];	* The tag table 
 * icInt8Number				tagData[icAny];		* The tag data 
 */
} icProfile;		       

/*------------------------------------------------------------------------*/
/* Obsolete entries */

/* icNamedColor was replaced with icNamedColor2 */
typedef struct {
    icUInt32Number			vendorFlag;			/* Bottom 16 bits for IC use */
    icUInt32Number			count;				/* Count of named colors */
    icInt8Number			data[icAny];		/* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number				prefix[icAny];		* Prefix for the color name, max = 32
 * icInt8Number				suffix[icAny];		* Suffix for the color name, max = 32
 * icInt8Number				root1[icAny];		* Root name for first color, max = 32
 * icInt8Number				coords1[icAny];		* Color coordinates of first color
 * icInt8Number				root2[icAny];		* Root name for first color, max = 32
 * icInt8Number				coords2[icAny];		* Color coordinates of first color
 *						:
 *						:
 * Repeat for root name and color coordinates up to (count-1)
 */
} icNamedColor;

/* icNamedColorType was replaced by icNamedColor2Type */
typedef struct {
    icTagBase				base;				/* Signature, "ncol" */
    icNamedColor			ncolor;				/* Named color data */
} icNamedColorType;

#endif /* ICC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\memlink.c ===
/*
	File:		MemLink.c

	Contains:	
		creation of mem based profiles

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#if __IS_MSDOS
#include <wtypes.h>
#include <winbase.h>
#include <windowsX.h>
#ifdef RenderInt
#include "Windef.h"
#endif
#endif

#ifndef MemLink_h
#include "MemLink.h"
#endif

#if !__IS_MSDOS && !__IS_MAC
#include <time.h>
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCMRuntimeID
#endif


#ifndef IntelMode
#define CMHelperICC2int16Const(a, b) 																\
		  (*((UINT16 *)(a))) = (UINT16)(b);
#define CMHelperICC2int32Const(a, b) 																\
		  (*((UINT32 *)(a))) = (UINT32)(b);
#else
#define CMHelperICC2int16Const(a, b) 																\
		  (*((UINT16 *)(a))) = (((UINT16)(b)>>8)         | ((UINT16)((UINT8 )(b)) << 8));
#define CMHelperICC2int32Const(a, b) 																\
		  (*((UINT32 *)(a))) = (((UINT32)(b)>>24)         | ((UINT32)(0x0ff0000&(UINT32)(b)) >> 8) | \
		        ((UINT32)(0x0ff00&(UINT32)(b)) << 8) | ((UINT32)(0x0ff&(UINT32)(b)) << 24));
#endif

CMError MyAdd_NL_Header( UINT32 theSize, icHeader	*linkHeader,
						 UINT32 aIntent, UINT32 aClass, UINT32 aColorSpace, UINT32 aConnectionSpace )
{
	OSErr					err = noErr;
#if ! __IS_MSDOS
	unsigned long			secs;
#endif
	DateTimeRec				datetimeRec;
	/*icHeader	linkHeader; */

#if __IS_MSDOS
	SYSTEMTIME aSystemTime;
	GetLocalTime( (SYSTEMTIME *)&aSystemTime);
	datetimeRec.year	 = aSystemTime.wYear; 	datetimeRec.month	 = aSystemTime.wMonth;
	datetimeRec.day		 = aSystemTime.wDay; 	datetimeRec.hour	 = aSystemTime.wHour;
	datetimeRec.minute	 = aSystemTime.wMinute; datetimeRec.second	 = aSystemTime.wSecond;
#else
#if __IS_MAC
	GetDateTime(&secs);
	SecondsToDate(secs, &datetimeRec);/* Secs2Date  (link.*)=(.*); CMHelperICC2int32(\&(\1),\2); */
#else
    struct tm* loctime;
    time_t long_time;
    time( &long_time );                /* Get time as long integer. */
	loctime = localtime(&long_time);
	datetimeRec.year	 = loctime->tm_year;	datetimeRec.month	= loctime->tm_mon+1;
	datetimeRec.day		 = loctime->tm_mday;	datetimeRec.hour	= loctime->tm_hour;
	datetimeRec.minute	 = loctime->tm_min;		datetimeRec.second	= loctime->tm_sec;
#endif
#endif
	
	CMHelperICC2int32Const(&(linkHeader->size				), theSize);		/* This is the total size of the CMProfileRef */
	CMHelperICC2int32Const(&(linkHeader->cmmId 				), 'Win ');							/* CMM signature,  Registered with ICC consortium  */
	CMHelperICC2int32Const(&(linkHeader->version 			), icVersionNumber);				/* Version of CMProfile format */
	CMHelperICC2int32Const(&(linkHeader->deviceClass 		), aClass);					/* input, display, output, devicelink, abstract, or color conversion profile type */
	
	CMHelperICC2int32Const(&(linkHeader->colorSpace			), aColorSpace);	/* color space of data = dataColorSpace of first profile*/

	CMHelperICC2int32Const(&(linkHeader->pcs				), aConnectionSpace);	/* profile connection color space = dataColorSpace of last profile*/
	
	CMHelperICC2int16(&(linkHeader->date.year				), &datetimeRec.year);					/* date and time of profile creation */
	CMHelperICC2int16(&(linkHeader->date.month				), &datetimeRec.month);	
	CMHelperICC2int16(&(linkHeader->date.day				), &datetimeRec.day);	
	CMHelperICC2int16(&(linkHeader->date.hours				), &datetimeRec.hour);	
	CMHelperICC2int16(&(linkHeader->date.minutes			), &datetimeRec.minute);	
	CMHelperICC2int16(&(linkHeader->date.seconds			), &datetimeRec.second);	
	CMHelperICC2int32Const(&(linkHeader->magic				), icMagicNumber);					/* 'acsp' constant ICC file ID */
	CMHelperICC2int32Const(&(linkHeader->platform 			), icSigMicrosoft);					/* primary profile platform, Registered with ICC consortium */
	CMHelperICC2int32Const(&(linkHeader->flags				), 0);								/* profile flags */
	CMHelperICC2int32Const(&(linkHeader->manufacturer		), icSigMicrosoft);							/* Registered with ICC consortium */
	CMHelperICC2int32Const(&(linkHeader->model				), 0);								/* Registered with ICC consortium */
	CMHelperICC2int32Const(&(linkHeader->attributes[0]		), 0);								/* Attributes like paper type */
	CMHelperICC2int32Const(&(linkHeader->attributes[1]		), 0);
	CMHelperICC2int32Const(&(linkHeader->renderingIntent	), aIntent );								/* preferred rendering intent of tagged object */
	CMHelperICC2int32Const(&(linkHeader->illuminant.X		), 0.9642 * 65536);					/* profile illuminant */
	CMHelperICC2int32Const(&(linkHeader->illuminant.Y		), 1.0000 * 65536);
	CMHelperICC2int32Const(&(linkHeader->illuminant.Z		), 0.8249 * 65536);
	CMHelperICC2int32Const(&(linkHeader->creator			), 'UJK ');
		
	return err;
}

CMError MyAdd_NL_HeaderMS	( UINT32 theSize, icHeader	*linkHeader, unsigned long aIntent, icColorSpaceSignature sCS, icColorSpaceSignature dCS );
CMError MyAdd_NL_HeaderMS	( UINT32 theSize, icHeader	*linkHeader, unsigned long aIntent, icColorSpaceSignature sCS, icColorSpaceSignature dCS )
{
	OSErr					err = noErr;
#if ! __IS_MSDOS
	unsigned long			secs;
#endif
	DateTimeRec				datetimeRec;
	/*icHeader	linkHeader; */

#if __IS_MSDOS
	SYSTEMTIME aSystemTime;
	GetLocalTime( (SYSTEMTIME *)&aSystemTime);
	datetimeRec.year	 = aSystemTime.wYear; 	datetimeRec.month	 = aSystemTime.wMonth;
	datetimeRec.day		 = aSystemTime.wDay; 	datetimeRec.hour	 = aSystemTime.wHour;
	datetimeRec.minute	 = aSystemTime.wMinute; datetimeRec.second	 = aSystemTime.wSecond;
#else
#if __IS_MAC
	GetDateTime(&secs);
	SecondsToDate(secs, &datetimeRec);/* Secs2Date  (link.*)=(.*); CMHelperICC2int32(\&(\1),\2); */
#else
    struct tm* loctime;
    time_t long_time;
    time( &long_time );                /* Get time as long integer. */
	loctime = localtime(&long_time);
	datetimeRec.year	 = loctime->tm_year;	datetimeRec.month	= loctime->tm_mon+1;
	datetimeRec.day		 = loctime->tm_mday;	datetimeRec.hour	= loctime->tm_hour;
	datetimeRec.minute	 = loctime->tm_min;		datetimeRec.second	= loctime->tm_sec;
#endif
#endif
	
	
	linkHeader->size				= theSize;		/* This is the total size of the CMProfileRef */
	linkHeader->cmmId 				= 'Win ';							/* CMM signature,  Registered with ICC consortium  */
	linkHeader->version 			= icVersionNumber;				/* Version of CMProfile format */
	linkHeader->deviceClass 		= icSigLinkClass;					/* input, display, output, devicelink, abstract, or color conversion profile type */
	
	linkHeader->colorSpace			= sCS;	/* color space of data = dataColorSpace of first profile*/

	linkHeader->pcs					= dCS;	/* profile connection color space = dataColorSpace of last profile*/
	
	linkHeader->date.year			= datetimeRec.year;					/* date and time of profile creation */
	linkHeader->date.month			= datetimeRec.month;	
	linkHeader->date.day			= datetimeRec.day;	
	linkHeader->date.hours			= datetimeRec.hour;	
	linkHeader->date.minutes		= datetimeRec.minute;	
	linkHeader->date.seconds		= datetimeRec.second;	
	linkHeader->magic				= icMagicNumber;					/* 'acsp' constant ICC file ID */
	linkHeader->platform 			= icSigMicrosoft;					/* primary profile platform, Registered with ICC consortium */
	linkHeader->flags				= 0;								/* profile flags */
	linkHeader->manufacturer		= icSigMicrosoft;							/* Registered with ICC consortium */
	linkHeader->model				= 0;								/* Registered with ICC consortium */
	linkHeader->attributes[0]		= 0;								/* Attributes like paper type */
	linkHeader->attributes[1]		= 0;
	linkHeader->renderingIntent		= aIntent ;								/* preferred rendering intent of tagged object */
	linkHeader->illuminant.X		= (long)(0.9642 * 65536);					/* profile illuminant */
	linkHeader->illuminant.Y		= (long)(1.0000 * 65536);
	linkHeader->illuminant.Z		= (long)(0.8249 * 65536);
	linkHeader->creator				= 'UJK ';

	return err;
}

CMError MyAdd_NL_DescriptionTag	( LHTextDescriptionType *descPtr, unsigned char *theText )
{
	Ptr						thePtr;
	OSErr					err = noErr;
	
	theText[theText[0]] = 0x00;
	
	/*descPtr = (LHTextDescriptionType*)NewPtrClear( theSize );	 */
	if (descPtr == 0)
		return -1;
	
	/*------------------------------------------------------------------------ ASCII */
	CMHelperICC2int32Const(&(descPtr->typeDescriptor ), icSigTextDescriptionType);
	CMHelperICC2int32Const(&(descPtr->reserved ), 0);
	CMHelperICC2int32Const(&(descPtr->ASCIICount	 ), (long)theText[0]);
	thePtr = (Ptr) &descPtr->ASCIIName[0];
	BlockMove(&theText[1], thePtr, theText[0]);
	thePtr += theText[0];
	
	/*------------------------------------------------------------------------ Unicode */
	/**((unsigned long*)thePtr) = 0;	does not work on some machines ( adress not long word aligned )	/*Unicode code */
	/*thePtr+=sizeof(unsigned long); */
	*thePtr++ = 0;
	*thePtr++ = 0;
	*thePtr++ = 0;
	*thePtr++ = 0;
	/**((unsigned long*)thePtr) = 0;						/*Unicode character count */
	/*thePtr+=sizeof(unsigned long); */
	*thePtr++ = 0;
	*thePtr++ = 0;
	*thePtr++ = 0;
	*thePtr++ = 0;
	/*BlockMove(&theText[1], thePtr, theText[0]);		//Unicode string  */
	/*thePtr += theText[0]; */
	
	/*------------------------------------------------------------------------ Macintosh */
	/**((short*)thePtr) = 0;
	thePtr+=sizeof(short); */
	*thePtr++ = 0;
	*thePtr++ = 0;
	BlockMove(&theText[0], thePtr, theText[0]+1);	
	return err;
}

CMError MyAdd_NL_ColorantTag	( icXYZType *descPtr, MyXYZNumber *aColor )
{
	OSErr					err = noErr;
	
	CMHelperICC2int32Const(&(descPtr->base ), icSigXYZType);
	CMHelperICC2int32Const((OSType*)&(descPtr->base )+1, 0);
	CMHelperICC2int32(&(descPtr->data.data[0].X	 ), &aColor->X);
	CMHelperICC2int32(&(descPtr->data.data[0].Y	 ), &aColor->Y);
	CMHelperICC2int32(&(descPtr->data.data[0].Z	 ), &aColor->Z);
	return err;
}

CMError MyAdd_NL_CurveTag	( icCurveType *descPtr, unsigned short Gamma )
{
	OSErr					err = noErr;
	
	CMHelperICC2int32Const(&(descPtr->base ), icSigCurveType);
	CMHelperICC2int32Const((OSType*)&(descPtr->base )+1, 0);
	CMHelperICC2int32Const(&(descPtr->curve.count ), 1);
	CMHelperICC2int16(&(descPtr->curve.data[0] ), &Gamma );
	return err;
}

CMError MyAdd_NL_CopyrightTag		( unsigned char *copyrightText, LHTextType *aLHTextType )
{
    OSErr			err=noErr;

    copyrightText[copyrightText[0]] = 0x00;
    CMHelperICC2int32Const(&(aLHTextType->base ), icSigTextType);
	CMHelperICC2int32Const((OSType*)&(aLHTextType->base )+1, 0);
    BlockMove(&copyrightText[1], &aLHTextType->text[0], copyrightText[0]);

#ifdef DEBUG_OUTPUT
    if ( err && DebugCheck(kThisFile, kDebugErrorInfo) )
        DebugPrint(" MyAdd_NL_CopyrightTag-Error: result = %d\n",err);
#endif
    return err;
}

/* ______________________________________________________________________
    CMError
    Fill_mft1_InputTable	( Ptr				theElut,
                              icLut8*		lutPtr,
                              CMMModelPtr	modelData)

    Abstract:
        Fill mft1 inputTable with the data from the given E-Lut.

    Params:
        theElut		(in)		Reference to E-Lut.
        tempLutPtr	(in/out)	Reference to icLut8.

    Return:
        noErr		successful
        System or result code if an error occurs.
   _____________________________________________________________________ */
CMError Fill_mft1_InputTable(	Ptr			theElut,
                          		icLut8*		lutPtr,
                          		CMMModelPtr	modelData);
CMError Fill_mft1_InputTable(	Ptr			theElut,
                          		icLut8*		lutPtr,
                          		CMMModelPtr	modelData)
{
    OSErr			err = noErr;
    long			i;
    long			j;
    unsigned long	factor;
    unsigned long	round;
    unsigned long	shift;
    unsigned long	ulAux;
    unsigned short	*wordElut = (unsigned short*)theElut;
    unsigned long	newScale = 255;
    unsigned long	oldScale = ((1U<< modelData->lutParam.inputLutWordSize) * (lutPtr->clutPoints-1)) / lutPtr->clutPoints;

    if( modelData->currentCall == kCMMNewLinkProfile ){
		oldScale = 1<< modelData->lutParam.inputLutWordSize;
	}
	factor = (newScale << 24) / oldScale;
    round  = (1<<(24-1))-1;
    shift  = 24;

    ulAux = ~( (1<< (32-modelData->lutParam.inputLutWordSize))-1);
	while (factor & ulAux )	/* stay within 16 bits to prevent product overflow */
    {
        factor >>= 1;
        round  >>= 1;
        shift   -= 1;
    }

    for (i=0; i<(long)lutPtr->inputChan; i++)
    {
        for (j=0; j< 256; j++)
        {
            ulAux    = ((unsigned long)*wordElut * factor + round) >> shift;
            lutPtr->data[i * 256 + j] = (UINT8)(ulAux );
            wordElut++;
        }
    }
    return err;
}

/* ______________________________________________________________________
    CMError
    Fill_mft1_OutputTable	( Ptr			theAlut,
                              icLut8*	lutPtr,
                              long			offset,
                              CMMModelPtr	modelData)

    Abstract:
        Fill mft1 outputTable with the data from the given A-Lut.

    Params:
        theAlut	(in)		Reference to A-Lut.
        lutPtr	(in/out)	Reference to icLut8.
        offset	(in)		starting position for outputTable within icLut8

    Return:
        noErr		successful
        System or  result code if an error occurs.
   _____________________________________________________________________ */
CMError Fill_mft1_OutputTable(	Ptr			theAlut,
                      			icLut8*		lutPtr,
                          		long		offset,
                          		CMMModelPtr	modelData);
CMError Fill_mft1_OutputTable(	Ptr			theAlut,
                      			icLut8*		lutPtr,
                          		long		offset,
                          		CMMModelPtr	modelData)
{
    OSErr	err = noErr;
    long	i;
    long	j;
    UINT8*	byteAlut = (UINT8*)theAlut;
    long	numOfAlutEntries = modelData->lutParam.outputLutEntryCount;
    short	step = numOfAlutEntries / 256;

    for (i=0; i<(long)lutPtr->outputChan; i++)
    {
        for (j=0; j<256; j++)
        {
            byteAlut = (UINT8*)theAlut + (j * (numOfAlutEntries-1)) / 255 ;
            lutPtr->data[offset + i * 256 + j] = *byteAlut;
        }
		theAlut +=  numOfAlutEntries;
    }
    return err;
}

/* ______________________________________________________________________
    CMError
    Fill_mft2_InputTable	( Ptr				theElut,
                              icLut16*		lutPtr,
                              CMMModelPtr	modelData)

    Abstract:
        Fill mft2 inputTable with the data from the given E-Lut.

    Params:
        theElut		(in)		Reference to E-Lut.
        tempLutPtr	(in/out)	Reference to icLut8.

    Return:
        noErr		successful
        System or  result code if an error occurs.
   _____________________________________________________________________ */
CMError Fill_mft2_InputTable(	Ptr				theElut,
                          		icLut16*		lutPtr,
                          		CMMModelPtr	modelData);
CMError Fill_mft2_InputTable(	Ptr				theElut,
                          		icLut16*		lutPtr,
                          		CMMModelPtr	modelData)
{
    OSErr			err = noErr;
    unsigned long	factor;
    unsigned long	round;
    unsigned long	shift;
    unsigned long	ulAux;
    long			i;
    long			j;
    UINT16*			wordElut = (UINT16*)theElut;
    UINT16*			wordData = (UINT16*)lutPtr->data;
    unsigned long	newScale = 65535;

    unsigned long	oldScale = ( (1<<modelData->lutParam.inputLutWordSize) * (modelData->lutParam.colorLutGridPoints-1)) / modelData->lutParam.colorLutGridPoints;

    if( modelData->currentCall == kCMMNewLinkProfile ){
		oldScale = 1<< modelData->lutParam.inputLutWordSize;
	}
	factor = (newScale << 15) / oldScale;
    round  = (1<<(15-1))-1;
    shift  = 15;

    while (factor & 0xFFFF0000)	/* stay within 16 bits to prevent product overflow */
    {
        factor >>= 1;
        round  >>= 1;
        shift   -= 1;
    }

     for (i=0; i<(long)lutPtr->inputChan; i++)
    {
        for (j=0; j< (long)lutPtr->inputEnt; j++)
        {
            ulAux    = ((unsigned long)*wordElut * factor + round) >> shift;
			CMHelperICC2int16Const( wordData, ulAux );
			wordData++;
            wordElut++;
        }
    }
    return err;
}
/* ______________________________________________________________________
    CMError
    Fill_mft2_OutputTable	( Ptr				theAlut,
                              icLut16*		lutPtr,
                              long				offset,
                              CMMModelPtr	modelData )

    Abstract:
        Fill mft2 outputTable with the data from the given A-Lut.

    Params:
        theAlut	(in)		Reference to A-Lut.
        lutPtr	(in/out)	Reference to icLut8.
        offset	(in)		starting position for outputTable within CMLut8Type

    Return:
        noErr		successful
        System or  result code if an error occurs.
   _____________________________________________________________________ */
CMError Fill_mft2_OutputTable(	Ptr			theAlut,
                          		icLut16*	lutPtr,
                          		long		offset,
                          		CMMModelPtr	modelData );
CMError Fill_mft2_OutputTable(	Ptr			theAlut,
                          		icLut16*	lutPtr,
                          		long		offset,
                          		CMMModelPtr	modelData )
{
    OSErr	err = noErr;
    long	i;
    long	j;
    UINT16*	wordAlut = (UINT16*)theAlut;
    UINT16*	wordData = (UINT16*)lutPtr->data + offset;

    modelData = modelData;
    for (i=0; i<(long)lutPtr->outputChan; i++)
    {
        for (j=0; j<(long)lutPtr->outputEnt; j++)
        {
            CMHelperICC2int16Const( wordData, *wordAlut );
			wordData++;
            wordAlut++;
        }
    }
    return err;
}

/* ______________________________________________________________________
    CMError
    Fill_mft2_ColorTable	( Ptr			theAlut,
                              icLut16*		lutPtr,
                              long			offset,
                              long 			count )

    Abstract:
        Fill mft2 outputTable with the data from the given A-Lut.

    Params:
        theAlut	(in)		Reference to A-Lut.
        lutPtr	(in/out)	Reference to icLut8.
        offset	(in)		starting position for outputTable within CMLut8Type

    Return:
        noErr		successful
        System or  result code if an error occurs.
   _____________________________________________________________________ */
CMError Fill_mft2_ColorTable(	Ptr			theClut,
                          		icLut16*	lutPtr,
                          		long		offset,
                          		long 		count );
CMError Fill_mft2_ColorTable(	Ptr			theClut,
                          		icLut16*	lutPtr,
                          		long		offset,
                          		long 		count )
{
    OSErr	err = noErr;
    long	i;
    UINT16*	wordClut = (UINT16*)theClut;
    UINT16*	wordData = (UINT16*)lutPtr->data + offset;

    for ( i=0; i<count; i++)
    {
        CMHelperICC2int16Const( wordData, *wordClut );
		wordData++;
        wordClut++;
    }
    return err;
}

CMError MyAdd_NL_AToB0Tag_mft1( CMMModelPtr cw, icLut8Type *lutPtr, long colorLutSize )
{
	CMError			err;
	icLut8			*tempLutPtr;
	long			offset;
	UINT16			inputChannels;
	UINT16			outputChannels;
	UINT16			gridPoints;
	
	LH_START_PROC("Add_NL_AToB0Tag_mft1")

	LOCK_DATA(cw->lutParam.inputLut);
	LOCK_DATA(cw->lutParam.colorLut);
	LOCK_DATA(cw->lutParam.outputLut);
	
	inputChannels  = (UINT16)cw->lutParam.colorLutInDim;
	outputChannels = (UINT16)cw->lutParam.colorLutOutDim;
	gridPoints	   = (UINT16)cw->lutParam.colorLutGridPoints;
	
	tempLutPtr	= &lutPtr->lut;
	CMHelperICC2int32Const(&(lutPtr->base ), icSigLut8Type);
	CMHelperICC2int32Const((OSType*)&(lutPtr->base )+1, 0);
	tempLutPtr->inputChan	= (UINT8)inputChannels;
	tempLutPtr->outputChan	= (UINT8)outputChannels;
	tempLutPtr->clutPoints 	= (UINT8)gridPoints;
	tempLutPtr->e00 = tempLutPtr->e01 = tempLutPtr->e02 = 0;
	tempLutPtr->e10 = tempLutPtr->e11 = tempLutPtr->e12 = 0;
	tempLutPtr->e20 = tempLutPtr->e21 = tempLutPtr->e22 = 0;
	CMHelperICC2int32Const(&(tempLutPtr->e00	), 0x10000);
	CMHelperICC2int32Const(&(tempLutPtr->e11	), 0x10000);
	CMHelperICC2int32Const(&(tempLutPtr->e22	), 0x10000);

	err = Fill_mft1_InputTable((Ptr)DATA_2_PTR(cw->lutParam.inputLut), tempLutPtr, cw);
	if (err)
		goto CleanupAndExit;

	offset = 256 * inputChannels;
	BlockMoveData( DATA_2_PTR(cw->lutParam.colorLut), & tempLutPtr->data[0] + offset, colorLutSize);

	offset = offset + colorLutSize;
	err = Fill_mft1_OutputTable((Ptr)DATA_2_PTR(cw->lutParam.outputLut),  tempLutPtr, offset, cw);
	if (err)
		goto CleanupAndExit;

CleanupAndExit:

	#ifdef DEBUG_OUTPUT
	if ( err  )
		DebugPrint(" MyAdd_NL_AToB0Tag_mft1-Error: result = %d\n",err);
	#endif
	UNLOCK_DATA(cw->lutParam.inputLut);
	UNLOCK_DATA(cw->lutParam.colorLut);
	UNLOCK_DATA(cw->lutParam.outputLut);
	LH_END_PROC("Add_NL_AToB0Tag_mft1")
	return err;
}

UINT32 GetSizes( CMMModelPtr cw, UINT32 *clutSize );
UINT32 GetSizes( CMMModelPtr cw, UINT32 *clutSize )
{
	UINT16			inputChannels;
	UINT16			outputChannels;
	UINT16			gridPoints;
	SINT32			colorLutSize;
	UINT32			i,theSize;

	LOCK_DATA(cw->lutParam.inputLut);
	LOCK_DATA(cw->lutParam.colorLut);
	LOCK_DATA(cw->lutParam.outputLut);
	
	inputChannels  = (UINT16)cw->lutParam.colorLutInDim;
	outputChannels = (UINT16)cw->lutParam.colorLutOutDim;
	gridPoints	   = (UINT16)cw->lutParam.colorLutGridPoints;
	
	colorLutSize = outputChannels;
	for(i = 0; i < inputChannels; i++)
		colorLutSize *= gridPoints;

	if ( cw->lutParam.colorLutWordSize != 8){
		theSize = sizeof(OSType) + sizeof(UINT32) + (4 * sizeof(UINT8)) + (9 * sizeof(Fixed))			/* typeDescriptor...matrix */
					+ 2 * sizeof(icUInt16Number) 														/* inputLutEntryCount outputLutEntryCount*/
					+ (inputChannels * cw->lutParam.inputLutEntryCount * sizeof(UINT16)) 				/* inputTable */
					+ (outputChannels * cw->lutParam.outputLutEntryCount * sizeof(UINT16)) 				/* CLUT */
					+ colorLutSize * sizeof(UINT16);																		/* outputTable */
	}
	else{
		theSize = sizeof(OSType) + sizeof(UINT32) + (4 * sizeof(UINT8)) + (9 * sizeof(Fixed))			/* typeDescriptor...matrix */
					+ (inputChannels * 256 * sizeof(UINT8)) 											/* inputTable */
					+ (outputChannels * 256 * sizeof(UINT8)) 											/* CLUT */
					+ colorLutSize;																		/* outputTable */
	}
	*clutSize = colorLutSize;
	UNLOCK_DATA(cw->lutParam.inputLut);
	UNLOCK_DATA(cw->lutParam.colorLut);
	UNLOCK_DATA(cw->lutParam.outputLut);
	return theSize;
}

CMError MyAdd_NL_AToB0Tag_mft2( CMMModelPtr cw, icLut16Type *lutPtr, long colorLutSize )
{
	CMError			err;
	icLut16			*tempLutPtr;
	long			offset;
	UINT16			inputChannels;
	UINT16			outputChannels;
	UINT16			gridPoints;
	
	LH_START_PROC("Add_NL_AToB0Tag_mft2")

	LOCK_DATA(cw->lutParam.inputLut);
	LOCK_DATA(cw->lutParam.colorLut);
	LOCK_DATA(cw->lutParam.outputLut);
	
	inputChannels  = (UINT16)cw->lutParam.colorLutInDim;
	outputChannels = (UINT16)cw->lutParam.colorLutOutDim;
	gridPoints	   = (UINT16)cw->lutParam.colorLutGridPoints;
	
	tempLutPtr	= &lutPtr->lut;
	CMHelperICC2int32Const(&(lutPtr->base ), icSigLut16Type);
	CMHelperICC2int32Const((OSType*)&(lutPtr->base )+1, 0);
	tempLutPtr->inputChan	= (UINT8)inputChannels;
	tempLutPtr->outputChan	= (UINT8)outputChannels;
	tempLutPtr->clutPoints 	= (UINT8)((gridPoints>255)?255:gridPoints);
	tempLutPtr->e00 = tempLutPtr->e01 = tempLutPtr->e02 = 0;
	tempLutPtr->e10 = tempLutPtr->e11 = tempLutPtr->e12 = 0;
	tempLutPtr->e20 = tempLutPtr->e21 = tempLutPtr->e22 = 0;
	CMHelperICC2int32Const(&(tempLutPtr->e00	), 0x10000);
	CMHelperICC2int32Const(&(tempLutPtr->e11	), 0x10000);
	CMHelperICC2int32Const(&(tempLutPtr->e22	), 0x10000);

	tempLutPtr->inputEnt	= (UINT16)cw->lutParam.inputLutEntryCount;
	tempLutPtr->outputEnt	= (UINT16)cw->lutParam.outputLutEntryCount;
	err = Fill_mft2_InputTable((Ptr)DATA_2_PTR(cw->lutParam.inputLut), tempLutPtr, cw);
	if (err)
		goto CleanupAndExit;

	offset = cw->lutParam.inputLutEntryCount * inputChannels;
	Fill_mft2_ColorTable( (Ptr)DATA_2_PTR(cw->lutParam.colorLut), tempLutPtr, offset, colorLutSize);

	offset = offset + colorLutSize;
	err = Fill_mft2_OutputTable((Ptr)DATA_2_PTR(cw->lutParam.outputLut),  tempLutPtr, offset, cw);
	if (err)
		goto CleanupAndExit;

	CMHelperICC2int16Const(&(tempLutPtr->inputEnt	), (UINT16)cw->lutParam.inputLutEntryCount);
	CMHelperICC2int16Const(&(tempLutPtr->outputEnt	), (UINT16)cw->lutParam.outputLutEntryCount);

CleanupAndExit:

	#ifdef DEBUG_OUTPUT
	if ( err  )
		DebugPrint(" MyAdd_NL_AToB0Tag_mft2-Error: result = %d\n",err);
	#endif
	UNLOCK_DATA(cw->lutParam.inputLut);
	UNLOCK_DATA(cw->lutParam.colorLut);
	UNLOCK_DATA(cw->lutParam.outputLut);
	LH_END_PROC("Add_NL_AToB0Tag_mft2")
	return err;
}

CMError MyGetColorSpaces(	CMConcatProfileSet	*profileSet,
							UINT32				*sCS,
							UINT32				*dCS );
CMError MyGetColorSpaces(	CMConcatProfileSet	*profileSet,
							UINT32				*sCS,
							UINT32				*dCS )
{
	CMError						err;
	icHeader					profHeader;

	LH_START_PROC("MyGetColorSpaces")
	
	err = CMGetProfileHeader(profileSet->profileSet[0], (CMCoreProfileHeader *)&profHeader);
	if (err)
		goto CleanupAndExit;
	*sCS = profHeader.colorSpace;

	err = CMGetProfileHeader(profileSet->profileSet[profileSet->count-1], (CMCoreProfileHeader *)&profHeader);
	if (err)
		goto CleanupAndExit;
	*dCS = profHeader.colorSpace;

CleanupAndExit:
	LH_END_PROC("MyAdd_NL_SequenceDescTag")
	return err;
}
/* ______________________________________________________________________
	CMError
	MyAdd_NL_SequenceDescTag	( CMProfileRef 		 linkProfile,
							  CMConcatProfileSet *profileSet )

	Abstract:
		Create the ProfileSequenceDescTag for the NewDeviceLink CMProfileRef.
		Copy the data from the profiles in profileSet

	Params:
		linkProfile	(in/out)	Reference to new profile.
		profileSet	(in)		Reference to CMConcatProfileSet.
		
	Return:
		noErr		successful
		System or  result code if an error occurs.
   _____________________________________________________________________ */
CMError MyAdd_NL_SequenceDescTag(	CMConcatProfileSet			*profileSet,
						  			icProfileSequenceDescType	*pSeqPtr,
						  			long						*aSize )
{
	CMError						err;
	OSErr						aOSerr;
	/*icProfileSequenceDescType*	pSeqPtr 	= nil;*/
	Ptr							thePtr 		= nil;
	icHeader					profHeader;
	SINT32						loop;
	OSType						technology;
	UINT32 						elementSize;
	icSignatureType				theSignature;
	icTextDescriptionType*		descPtr 	= nil;
	char						descPtrNull[90]={0};

	LH_START_PROC("MyAdd_NL_SequenceDescTag")
	
	CMHelperICC2int32Const(&(((icTextDescriptionType*)descPtrNull)->base ), icSigTextDescriptionType );
	CMHelperICC2int32Const(((OSType*)&((icTextDescriptionType*)descPtrNull)->base )+1, 0);
	CMHelperICC2int32Const(&(((icTextDescriptionType*)descPtrNull)->desc.count ), 1 );
	/*pSeqPtr =  (icProfileSequenceDescType*)SmartNewPtrClear(5000, &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;*/
	CMHelperICC2int32Const(&(pSeqPtr->base ), icSigProfileSequenceDescType);
	CMHelperICC2int32Const((OSType*)&(pSeqPtr->base )+1, 0);
	CMHelperICC2int32Const(&(pSeqPtr->desc.count ), profileSet->count );
	thePtr = (Ptr)( (SIZE_T)&(pSeqPtr->desc.count) + sizeof(SINT32) ) ;		
	
	for (loop = 0; loop < (SINT32)profileSet->count; loop++)
	{
		err = CMGetProfileHeader(profileSet->profileSet[loop], (CMCoreProfileHeader *)&profHeader);
		if (err)
			goto CleanupAndExit;
		CMHelperICC2int32Const(thePtr, profHeader.manufacturer);
		thePtr += sizeof(OSType);
		CMHelperICC2int32Const(thePtr, profHeader.model);
		thePtr += sizeof(OSType);
		CMHelperICC2int32Const(thePtr, profHeader.attributes[0]);
		thePtr += sizeof(UINT32);
		CMHelperICC2int32Const(thePtr, profHeader.attributes[1]);
		thePtr += sizeof(UINT32);
		
		/* ----------------------------------------------------------------- icSigTechnologyTag */
		technology = 0;
		if ( CMGetProfileElement(profileSet->profileSet[loop], icSigTechnologyTag, &elementSize, nil) == noErr)
		{
			if (elementSize == sizeof(icSigTechnologyTag))
			{
				if ( CMGetProfileElement(profileSet->profileSet[loop], icSigTechnologyTag, &elementSize, &theSignature) == noErr)
					technology = theSignature.signature;
			}
		}
		*((OSType*)thePtr) = technology;									/* signature */
		thePtr += sizeof(OSType);
		
		/* ----------------------------------------------------------------- icSigDeviceMfgDescTag */
		if ( CMGetProfileElement(profileSet->profileSet[loop], icSigDeviceMfgDescTag, &elementSize, nil) == noErr)
		{
			descPtr = (icTextDescriptionType*)SmartNewPtr(elementSize,&aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			if ( CMGetProfileElement(profileSet->profileSet[loop], icSigDeviceMfgDescTag, &elementSize, descPtr) == noErr)
			{
				BlockMoveData( descPtr, thePtr, elementSize);
				thePtr += elementSize;
			}
			descPtr = (icTextDescriptionType*)DisposeIfPtr((Ptr)descPtr);
		} else
		{
			BlockMoveData( descPtrNull, thePtr, sizeof(descPtrNull));
			thePtr += sizeof(descPtrNull);
		}
		/* ----------------------------------------------------------------- icSigDeviceModelDescTag */
		if ( CMGetProfileElement(profileSet->profileSet[loop], icSigDeviceModelDescTag, &elementSize, nil) == noErr)
		{
			descPtr = (icTextDescriptionType*)SmartNewPtr(elementSize,&aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			if ( CMGetProfileElement(profileSet->profileSet[loop], icSigDeviceModelDescTag, &elementSize, descPtr) == noErr)
			{
				BlockMoveData( descPtr, thePtr, elementSize);
				thePtr += elementSize;
			}
			descPtr =  (icTextDescriptionType*)DisposeIfPtr((Ptr)descPtr);
		} else
		{
			BlockMoveData( descPtrNull, thePtr, sizeof(descPtrNull));
			thePtr += sizeof(descPtrNull);
		}
		/* ----------------------------------------------------------------- */
	}

   //Sundown safe truncation
	*aSize = (LONG)((ULONG_PTR)thePtr - (ULONG_PTR)pSeqPtr);
	
CleanupAndExit:
	descPtr = (icTextDescriptionType*)DisposeIfPtr((Ptr)descPtr);
	LH_END_PROC("MyAdd_NL_SequenceDescTag")
	return err;
}


MyXYZNumber MakeXYZNumber( MyXYZNumber *x );
MyXYZNumber MakeXYZNumber( MyXYZNumber *x )
{
	MyXYZNumber ret;
	ret.X = x->X>>14;
	ret.Y = x->Y>>14;
	ret.Z = x->Z>>14;
	return ret;
}

void  MakeMyDoubleXYZ( MyXYZNumber *x, MyDoubleXYZ *ret );
void  MakeMyDoubleXYZ( MyXYZNumber *x, MyDoubleXYZ *ret )
{
	ret->X = x->X/(double)(1<<30);
	ret->Y = x->Y/(double)(1<<30);
	ret->Z = x->Z/(double)(1<<30);
}
Boolean  doubMatrixInvert(	double	inpMat[3][3],
						double	outMat[3][3] );
void  TransposeMatrix(	double	inpMat[3][3] );
void  TransposeMatrix(	double	inpMat[3][3] )
{
	long i,j;
	double sav;
	for( i=0; i< 3; i++ ){
		for( j=i+1; j< 3; j++ ){
			sav			 =  inpMat[i][j];
			inpMat[i][j] =  inpMat[j][i];
			inpMat[j][i] =  sav;
		}
	}

}
#define Round(a) (((a)>0.)?((a)+.5):((a)-.5))

double GetMatrixedVal( double m[3][3], long color, MyDoubleXYZ *aXYZ );
double GetMatrixedVal( double m[3][3], long color, MyDoubleXYZ *aXYZ )
{
	double tmp;
	tmp = m[color][0] * aXYZ->X;
	tmp+= m[color][1] * aXYZ->Y;
	tmp+= m[color][2] * aXYZ->Z;
	return tmp;
}

void NormalizeColor( MyXYZNumber *r, MyXYZNumber *g, MyXYZNumber *b, MyDoubleXYZ *Illuminant, MyXYZNumber *resR, MyXYZNumber *resG, MyXYZNumber *resB );
void NormalizeColor( MyXYZNumber *r, MyXYZNumber *g, MyXYZNumber *b, MyDoubleXYZ *Illuminant, MyXYZNumber *resR, MyXYZNumber *resG, MyXYZNumber *resB )
{
	double 	factorX,factorY,factorZ;
	double inMat[3][3];
	
	MakeMyDoubleXYZ( r, (MyDoubleXYZ*)&inMat[0][0] );
	MakeMyDoubleXYZ( g, (MyDoubleXYZ*)&inMat[1][0] );
	MakeMyDoubleXYZ( b, (MyDoubleXYZ*)&inMat[2][0] );

	factorX = inMat[0][0] + inMat[1][0] + inMat[2][0];
	factorY = inMat[0][1] + inMat[1][1] + inMat[2][1];
	factorZ = inMat[0][2] + inMat[1][2] + inMat[2][2];

	factorX = Illuminant->X / factorX * 65536;
	factorY = Illuminant->Y / factorY * 65536;
	factorZ = Illuminant->Z / factorZ * 65536;

	resR->X = (long)Round(inMat[0][0] * factorX);			/* red primary */
	resR->Y = (long)Round(inMat[0][1] * factorY);
	resR->Z = (long)Round(inMat[0][2] * factorZ);
	resG->X = (long)Round(inMat[1][0] * factorX);			/* green primary */
	resG->Y = (long)Round(inMat[1][1] * factorY);
	resG->Z = (long)Round(inMat[1][2] * factorZ);
	resB->X = (long)Round(inMat[2][0] * factorX);			/* blue primary */
	resB->Y = (long)Round(inMat[2][1] * factorY);
	resB->Z = (long)Round(inMat[2][2] * factorZ);
}

void NormalizeWithWhiteAdaption( MyXYZNumber *r, MyXYZNumber *g, MyXYZNumber *b, MyDoubleXYZ *Illuminant, MyXYZNumber *resR, MyXYZNumber *resG, MyXYZNumber *resB );
void NormalizeWithWhiteAdaption( MyXYZNumber *r, MyXYZNumber *g, MyXYZNumber *b, MyDoubleXYZ *Illuminant, MyXYZNumber *resR, MyXYZNumber *resG, MyXYZNumber *resB )
{
	double 	factorR,factorG,factorB;
	double inMat[3][3];
	double outMat[3][3];

	MakeMyDoubleXYZ( r, (MyDoubleXYZ*)&inMat[0][0] );
	MakeMyDoubleXYZ( g, (MyDoubleXYZ*)&inMat[1][0] );
	MakeMyDoubleXYZ( b, (MyDoubleXYZ*)&inMat[2][0] );

	if( !doubMatrixInvert(inMat, outMat) )
	{
		return ;
	}

	TransposeMatrix( outMat );

	factorR =  GetMatrixedVal( outMat, 0, Illuminant )*65536;
	factorG =  GetMatrixedVal( outMat, 1, Illuminant )*65536;
	factorB =  GetMatrixedVal( outMat, 2, Illuminant )*65536;

	resR->X = (long)Round(inMat[0][0] * factorR);			/* red primary */
	resR->Y = (long)Round(inMat[0][1] * factorR);
	resR->Z = (long)Round(inMat[0][2] * factorR);
	resG->X = (long)Round(inMat[1][0] * factorG);			/* green primary */
	resG->Y = (long)Round(inMat[1][1] * factorG);
	resG->Z = (long)Round(inMat[1][2] * factorG);
	resB->X = (long)Round(inMat[2][0] * factorB);			/* blue primary */
	resB->Y = (long)Round(inMat[2][1] * factorB);
	resB->Z = (long)Round(inMat[2][2] * factorB);
}

#ifdef WRITE_PROFILE
void WriteProf( Ptr name, icProfile *theProf, long currentSize );
#endif

#define MyTagCount 9

#if __IS_MSDOS && defined(RenderInt)
CMError MyNewAbstract( LPLOGCOLORSPACEA	lpColorSpace, icProfile **theProf )
{
	CMError			err = unimpErr;
	OSErr			aOSerr = unimpErr;
#ifdef __MWERKS__
	unsigned char	theText[] = "\pLogColorSpProfile   ";
	char			copyrightText[] = "\p1996 by Heidelberger Druckmaschinen AG  U.J.K.";
#elif __IS_MSDOS
	char			theText[] = "\030LogColorSpProfile      ";
	char			copyrightText[] = "\0601996 by Heidelberger Druckmaschinen AG  U.J.K.";
#else
	char			theText[] = "\030LogColorSpProfile      ";
	char			copyrightText[] = "\0601996 by Heidelberger Druckmaschinen AG  U.J.K.";
#endif
	icProfile 		*aProf=0;
	long 			theTagTabSize;
	long 			theHeaderSize;
	long 			theDescSize;
	long 			theMediaSize;
	long 			theEndPointSize;
	long 			theTRCSize;
	long 			theCopyRightSize;
	long 			currentSize=0;
	long 			theTotalSize=0;
	icTag			aTag;
	unsigned long	aIntent;

	MyXYZNumber	rXYZ,gXYZ,bXYZ;
	MyDoubleXYZ D50XYZ = { 0.9642, 1.0000, 0.8249 };
	MyXYZNumber D50 = { (unsigned long)(D50XYZ.X * 65536), (unsigned long)(D50XYZ.Y * 65536), (unsigned long)(D50XYZ.Z * 65536)};
	theHeaderSize = sizeof(icHeader);
	theDescSize   = 									  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ sizeof(unsigned long) 	/* ASCII length */
														+ theText[0]				/* ASCII profile description */
														+ sizeof(unsigned long)		/* Unicode code */
														+ sizeof(unsigned long)		/* Unicode character count */
														+ sizeof(unsigned short)	/* Macintosh script code */
														+ sizeof(unsigned char)		/* Macintosh string length */
														+ 67						/* Macintosh string */
														;
	theCopyRightSize   = 								  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ copyrightText[0]			/* ASCII profile description */
														;
	theMediaSize = sizeof( icXYZType );;
	theEndPointSize = sizeof( icXYZType );;
	theTRCSize = 4*((sizeof( icCurveType ) +3)/4);

	theTagTabSize = MyTagCount * sizeof( icTag ) + sizeof( unsigned long );
	
	theTotalSize = theHeaderSize + theTagTabSize + theDescSize + theCopyRightSize
		+ theMediaSize + 3*theEndPointSize + 3*theTRCSize;
	aProf = (icProfile *)GlobalAllocPtr( GHND, theTotalSize );
	if( aProf == 0 ){
		err = GetLastError();
		goto CleanupAndExit;
	}

	switch( lpColorSpace->lcsIntent ){
	  case LCS_GM_BUSINESS:
		aIntent = icSaturation;
		break;
	  case LCS_GM_GRAPHICS:
		aIntent = icRelativeColorimetric;
		break;
	  case LCS_GM_ABS_COLORIMETRIC:
		aIntent = icAbsoluteColorimetric;
		break;
	  default:
		aIntent = icPerceptual;
		break;
	}
	err = MyAdd_NL_Header(theTotalSize, (icHeader*)((Ptr)aProf+currentSize), aIntent, icSigInputClass, icSigRgbData, icSigXYZData );
	if (err)
		goto CleanupAndExit;
		
	/*----------------------------------------------------------------------------------------- cmProfileDescriptionTag */
	currentSize = theHeaderSize + theTagTabSize;
	CMHelperICC2int32Const(&(aProf->tagList.count ), MyTagCount);

	CMHelperICC2int32Const(&(aTag.sig ), icSigProfileDescriptionTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize);
	CMHelperICC2int32Const(&(aTag.size ), theDescSize);
	aProf->tagList.tags[0] = aTag;
	err =MyAdd_NL_DescriptionTag	( (LHTextDescriptionType *)((Ptr)aProf+currentSize), (unsigned char *)theText );
	if (err)
		goto CleanupAndExit;
	currentSize += theDescSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigMediaWhitePointTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theMediaSize);
	aProf->tagList.tags[1] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &D50);
	currentSize += theMediaSize;

	NormalizeColor(	(icXYZNumber*)&lpColorSpace->lcsEndpoints.ciexyzRed,
					(icXYZNumber*)&lpColorSpace->lcsEndpoints.ciexyzGreen,
					(icXYZNumber*)&lpColorSpace->lcsEndpoints.ciexyzBlue,
					&D50XYZ,
					&rXYZ,
					&gXYZ,
					&bXYZ );
	CMHelperICC2int32Const(&(aTag.sig ), icSigRedColorantTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theEndPointSize);
	aProf->tagList.tags[2] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &rXYZ );
	currentSize += theEndPointSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigGreenColorantTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theEndPointSize);
	aProf->tagList.tags[3] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &gXYZ );
	currentSize += theEndPointSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigBlueColorantTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theEndPointSize);
	aProf->tagList.tags[4] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &bXYZ );
	currentSize += theEndPointSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigRedTRCTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), sizeof( icCurveType ));
	aProf->tagList.tags[5] = aTag;
	MyAdd_NL_CurveTag((icCurveType  *)((Ptr)aProf+currentSize), (unsigned short)(lpColorSpace->lcsGammaRed>>8) );
	currentSize += theTRCSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigGreenTRCTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), sizeof( icCurveType ));
	aProf->tagList.tags[6] = aTag;
	MyAdd_NL_CurveTag((icCurveType  *)((Ptr)aProf+currentSize), (unsigned short)(lpColorSpace->lcsGammaGreen>>8) );
	currentSize += theTRCSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigBlueTRCTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), sizeof( icCurveType ));
	aProf->tagList.tags[7] = aTag;
	MyAdd_NL_CurveTag((icCurveType  *)((Ptr)aProf+currentSize), (unsigned short)(lpColorSpace->lcsGammaBlue>>8) );
	currentSize += theTRCSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigCopyrightTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theCopyRightSize);
	aProf->tagList.tags[8] = aTag;
	err = MyAdd_NL_CopyrightTag( (unsigned char *)copyrightText, (LHTextType *)((Ptr)aProf+currentSize));
	if (err)
		goto CleanupAndExit;
	currentSize += theCopyRightSize;
		
	*theProf = aProf;
#ifdef WRITE_PROFILE
	WriteProf( "MyNewAbstract.pf", aProf, currentSize );
#endif
	return noErr;
	
CleanupAndExit:
	if( aProf )GlobalFreePtr( aProf );
	return err;
}


CMError MyNewAbstractW( LPLOGCOLORSPACEW	lpColorSpace, icProfile **theProf )
{
	CMError			err = unimpErr;
	OSErr			aOSerr = unimpErr;
#ifdef __MWERKS__
	unsigned char	theText[] = "\pLogColorSpProfile   ";
	char			copyrightText[] = "\p1996 by Heidelberger Druckmaschinen AG  U.J.K.";
#elif __IS_MSDOS
	char			theText[] = "\030LogColorSpProfile      ";
	char			copyrightText[] = "\0601996 by Heidelberger Druckmaschinen AG  U.J.K.";
#else
	char			theText[] = "\030LogColorSpProfile      ";
	char			copyrightText[] = "\0601996 by Heidelberger Druckmaschinen AG  U.J.K.";
#endif
	icProfile 		*aProf=0;
	long 			theTagTabSize;
	long 			theHeaderSize;
	long 			theDescSize;
	long 			theMediaSize;
	long 			theEndPointSize;
	long 			theTRCSize;
	long 			theCopyRightSize;
	long 			currentSize=0;
	long 			theTotalSize=0;
	icTag			aTag;
	unsigned long	aIntent;

	MyXYZNumber	rXYZ,gXYZ,bXYZ;
	MyDoubleXYZ D50XYZ = { 0.9642, 1.0000, 0.8249 };
	MyXYZNumber D50 = { (unsigned long)(D50XYZ.X * 65536), (unsigned long)(D50XYZ.Y * 65536), (unsigned long)(D50XYZ.Z * 65536)};
	theHeaderSize = sizeof(icHeader);
	theDescSize   = 									  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ sizeof(unsigned long) 	/* ASCII length */
														+ theText[0]				/* ASCII profile description */
														+ sizeof(unsigned long)		/* Unicode code */
														+ sizeof(unsigned long)		/* Unicode character count */
														+ sizeof(unsigned short)	/* Macintosh script code */
														+ sizeof(unsigned char)		/* Macintosh string length */
														+ 67						/* Macintosh string */
														;
	theCopyRightSize   = 								  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ copyrightText[0]			/* ASCII profile description */
														;
	theMediaSize = sizeof( icXYZType );;
	theEndPointSize = sizeof( icXYZType );;
	theTRCSize = 4*((sizeof( icCurveType ) +3)/4);

	theTagTabSize = MyTagCount * sizeof( icTag ) + sizeof( unsigned long );
	
	theTotalSize = theHeaderSize + theTagTabSize + theDescSize + theCopyRightSize
		+ theMediaSize + 3*theEndPointSize + 3*theTRCSize;
	aProf = (icProfile *)GlobalAllocPtr( GHND, theTotalSize );
	if( aProf == 0 ){
		err = GetLastError();
		goto CleanupAndExit;
	}

	switch( lpColorSpace->lcsIntent ){
	  case LCS_GM_BUSINESS:
		aIntent = icSaturation;
		break;
	  case LCS_GM_GRAPHICS:
		aIntent = icRelativeColorimetric;
		break;
	  case LCS_GM_GRAPHICS+1:
		aIntent = icAbsoluteColorimetric;
		break;
	  default:
		aIntent = icPerceptual;
		break;
	}
	err = MyAdd_NL_Header(theTotalSize, (icHeader*)((Ptr)aProf+currentSize), aIntent, icSigInputClass, icSigRgbData, icSigXYZData );
	if (err)
		goto CleanupAndExit;
		
	/*----------------------------------------------------------------------------------------- cmProfileDescriptionTag */
	currentSize = theHeaderSize + theTagTabSize;
	CMHelperICC2int32Const(&(aProf->tagList.count ), MyTagCount);

	CMHelperICC2int32Const(&(aTag.sig ), icSigProfileDescriptionTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize);
	CMHelperICC2int32Const(&(aTag.size ), theDescSize);
	aProf->tagList.tags[0] = aTag;
	err =MyAdd_NL_DescriptionTag	( (LHTextDescriptionType *)((Ptr)aProf+currentSize), (unsigned char *)theText );
	if (err)
		goto CleanupAndExit;
	currentSize += theDescSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigMediaWhitePointTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theMediaSize);
	aProf->tagList.tags[1] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &D50);
	currentSize += theMediaSize;

	NormalizeColor(	(icXYZNumber*)&lpColorSpace->lcsEndpoints.ciexyzRed,
					(icXYZNumber*)&lpColorSpace->lcsEndpoints.ciexyzGreen,
					(icXYZNumber*)&lpColorSpace->lcsEndpoints.ciexyzBlue,
					&D50XYZ,
					&rXYZ,
					&gXYZ,
					&bXYZ );
	CMHelperICC2int32Const(&(aTag.sig ), icSigRedColorantTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theEndPointSize);
	aProf->tagList.tags[2] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &rXYZ );
	currentSize += theEndPointSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigGreenColorantTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theEndPointSize);
	aProf->tagList.tags[3] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &gXYZ );
	currentSize += theEndPointSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigBlueColorantTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theEndPointSize);
	aProf->tagList.tags[4] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &bXYZ );
	currentSize += theEndPointSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigRedTRCTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), sizeof( icCurveType ));
	aProf->tagList.tags[5] = aTag;
	MyAdd_NL_CurveTag((icCurveType  *)((Ptr)aProf+currentSize), (unsigned short)(lpColorSpace->lcsGammaRed>>8) );
	currentSize += theTRCSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigGreenTRCTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), sizeof( icCurveType ));
	aProf->tagList.tags[6] = aTag;
	MyAdd_NL_CurveTag((icCurveType  *)((Ptr)aProf+currentSize), (unsigned short)(lpColorSpace->lcsGammaGreen>>8) );
	currentSize += theTRCSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigBlueTRCTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), sizeof( icCurveType ));
	aProf->tagList.tags[7] = aTag;
	MyAdd_NL_CurveTag((icCurveType  *)((Ptr)aProf+currentSize), (unsigned short)(lpColorSpace->lcsGammaBlue>>8) );
	currentSize += theTRCSize;

	CMHelperICC2int32Const(&(aTag.sig ), icSigCopyrightTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theCopyRightSize);
	aProf->tagList.tags[8] = aTag;
	err = MyAdd_NL_CopyrightTag( (unsigned char *)copyrightText, (LHTextType *)((Ptr)aProf+currentSize));
	if (err)
		goto CleanupAndExit;
	currentSize += theCopyRightSize;
		
	*theProf = aProf;
#ifdef WRITE_PROFILE
	WriteProf( "MyNewAbstractW.pf", aProf, currentSize );
#endif
	return noErr;
	
CleanupAndExit:
	if( aProf )GlobalFreePtr( aProf );
	return err;
}
#endif

#define MyTagCountLink 5
#define LINK_BUFFER_MAX 3000

CMError DeviceLinkFill(	CMMModelPtr cw,
						CMConcatProfileSet *profileSet,
						icProfile **theProf,
						unsigned long aIntent )
{
	CMError			err = unimpErr;
	OSErr			aOSerr = unimpErr;
#ifdef __MWERKS__
	unsigned char	theText[] = "\pDeviceLink profile  ";
	char			copyrightText[] = "\p1996 by Heidelberger Druckmaschinen AG  U.J.K.";
#elif __IS_MSDOS
	char			theText[] = "\030DeviceLink profile     ";
	char			copyrightText[] = "\0601996 by Heidelberger Druckmaschinen AG  U.J.K.";
#else
	char			theText[] = "\030DeviceLink profile     ";
	char			copyrightText[] = "\0601996 by Heidelberger Druckmaschinen AG  U.J.K.";
#endif
	icProfile 		*aProf=0;
	long 			theTagTabSize;
	long 			theHeaderSize;
	long 			theDescSize;
	long 			theMediaSize;
	long 			theSequenceDescSize;
	long 			theA2B0Size;
	long 			theCopyRightSize;
	long 			currentSize=0;
	long 			theTotalSize=0;
	icTag			aTag;
	UINT32			sCS,dCS,clutSize;
	Ptr				aPtr=0;

	MyDoubleXYZ D50XYZ = { 0.9642, 1.0000, 0.8249 };
	MyXYZNumber D50 = { (unsigned long)(0.9642 * 65536), (unsigned long)(1.0000 * 65536), (unsigned long)(0.8249 * 65536)};
	theHeaderSize = sizeof(icHeader);
	theDescSize   = 									  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ sizeof(unsigned long) 	/* ASCII length */
														+ theText[0]				/* ASCII profile description */
														+ sizeof(unsigned long)		/* Unicode code */
														+ sizeof(unsigned long)		/* Unicode character count */
														+ sizeof(unsigned short)	/* Macintosh script code */
														+ sizeof(unsigned char)		/* Macintosh string length */
														+ 67						/* Macintosh string */
														;
	theCopyRightSize   = 								  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ copyrightText[0]			/* ASCII profile description */
														;
	theMediaSize = sizeof( icXYZType );;

	theTagTabSize = MyTagCountLink * sizeof( icTag ) + sizeof( unsigned long );
	
	*theProf = 0;
	
	if( cw->hasNamedColorProf != NoNamedColorProfile ){
		err = cmProfileError;
		goto CleanupAndExit;
	}
	err = MyGetColorSpaces( profileSet, &sCS, &dCS );
	if (err)
		goto CleanupAndExit;
		
	aProf = (icProfile *)SmartNewPtrClear( LINK_BUFFER_MAX, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;

	err = MyAdd_NL_Header(theTotalSize, (icHeader*)((Ptr)aProf+currentSize), aIntent, icSigLinkClass, sCS, dCS );
	if (err)
		goto CleanupAndExit;
		
	/*----------------------------------------------------------------------------------------- cmProfileDescriptionTag */
	currentSize = theHeaderSize + theTagTabSize;
	CMHelperICC2int32Const(&(aProf->tagList.count ), MyTagCountLink);

	CMHelperICC2int32Const(&(aTag.sig ), icSigProfileDescriptionTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize);
	CMHelperICC2int32Const(&(aTag.size ), theDescSize);
	aProf->tagList.tags[0] = aTag;
	err =MyAdd_NL_DescriptionTag	( (LHTextDescriptionType *)((Ptr)aProf+currentSize), (unsigned char *)theText );
	if (err)
		goto CleanupAndExit;
	currentSize += theDescSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

	CMHelperICC2int32Const(&(aTag.sig ), icSigMediaWhitePointTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theMediaSize);
	aProf->tagList.tags[1] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &D50);
	currentSize += theMediaSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

	CMHelperICC2int32Const(&(aTag.sig ), icSigCopyrightTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theCopyRightSize);
	aProf->tagList.tags[2] = aTag;
	err = MyAdd_NL_CopyrightTag( (unsigned char *)copyrightText, (LHTextType *)((Ptr)aProf+currentSize));
	if (err)
		goto CleanupAndExit;
	currentSize += theCopyRightSize;
	currentSize = ( currentSize + 3 ) & ~ 3;
		
	err = MyAdd_NL_SequenceDescTag( profileSet, (icProfileSequenceDescType *)((Ptr)aProf+currentSize), &theSequenceDescSize );
	CMHelperICC2int32Const(&(aTag.sig ), icSigProfileSequenceDescTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theSequenceDescSize);
	aProf->tagList.tags[3] = aTag;
	currentSize += theSequenceDescSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

    theA2B0Size = GetSizes( (CMMModelPtr)cw, &clutSize );

	CMHelperICC2int32Const(&(aTag.sig ), icSigAToB0Tag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theA2B0Size);
	aProf->tagList.tags[4] = aTag;

#if __IS_MSDOS
	aPtr = GlobalAllocPtr( GHND, theA2B0Size+currentSize );
	if( aPtr == 0 ){
		err = GetLastError();
		goto CleanupAndExit;
	}
#else	
	aPtr =  SmartNewPtr( theA2B0Size+currentSize, &aOSerr );
	err = aOSerr;
	if( err ){
		goto CleanupAndExit;
	}
#endif


	if ( cw->lutParam.colorLutWordSize == 8 )
        err = MyAdd_NL_AToB0Tag_mft1( (CMMModelPtr)cw, (icLut8Type *)(aPtr+currentSize), clutSize );
    else
        err = MyAdd_NL_AToB0Tag_mft2( (CMMModelPtr)cw, (icLut16Type *)(aPtr+currentSize), clutSize );

	if (err)
		goto CleanupAndExit;

	BlockMove( (Ptr)aProf, aPtr, currentSize );
	aProf = (icProfile *)DisposeIfPtr( (Ptr)aProf );

	CMHelperICC2int32Const( aPtr, theA2B0Size+currentSize );

	*theProf = (icProfile *)aPtr;
#ifdef WRITE_PROFILE
	WriteProf( "DeviceLinkFill.pf", (icProfile *)aPtr, theA2B0Size+currentSize );
#endif
	return noErr;
	
CleanupAndExit:
	*theProf = (icProfile *)DisposeIfPtr( (Ptr)aProf );
#if __IS_MSDOS
	if( aPtr )GlobalFreePtr( aPtr );
#else
	aPtr = DisposeIfPtr( (Ptr)aPtr );
#endif
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\stdconv.h ===
/*
	File:		LHStdConversionLuts.h

	Contains:	prototypes for standard table funktions

	Written by:	H.Siegeritz

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHStdConversionLuts_h
#define	LHStdConversionLuts_h

#ifndef LHDefines_h
#include "Defines.h"
#endif

void	Lab2XYZ_forCube16(unsigned short *theCube, long count);
void	XYZ2Lab_forCube16(unsigned short *theCube, long count);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\genluts.c ===
/*
	File:		LHGenLuts.c

	Contains:	

	Version:	

	Written by:	S. Bleker & W. Neubrand & U.Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHTheRoutines_h
#include "Routines.h"
#endif

#ifndef LHFragment_h
#include "Fragment.h"
#endif

#ifndef LHCalcNDim_h
#include "CalcNDim.h"
#endif

#ifndef LHDoNDim_h
#include "DoNDim.h"
#endif


#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kLHGenLutsID
#define DoDisplayLutNew DoDisplayLut
#endif
#endif

#ifndef LHStdConversionLuts_h
#include "StdConv.h"
#endif

#define ALLOW_DEVICE_LINK   /* allows link as the last profile in a chain, change in PI_CMM.c too */
/*
	debugging only:
      - define  WRITE_LUTS to write out all luts that will be generated....
  */
/*#define WRITE_LUTS */
#ifdef WRITE_LUTS
void
WriteLut2File  ( Str255			theTitle,
				 LUT_DATA_TYPE	theLut,
				 OSType  		theType );
/*
	write a lut to a file...
  */
void
WriteLut2File  ( Str255			theTitle,
				 LUT_DATA_TYPE	theLut,
				 OSType  		theType )
{
	FSSpec  theFSSpec;
	SINT16	refNum;
	SINT32	theCount;
	
	if (theLut)
	{
		FSMakeFSSpec(0, 0, theTitle, &theFSSpec);
		FSpDelete(&theFSSpec);
		FSpCreate(&theFSSpec, 'Fill', theType, 0L);
		FSpOpenDF(&theFSSpec,fsWrPerm,&refNum);
		theCount = GETDATASIZE(theLut);
		FSWrite(refNum, &theCount, DATA_2_PTR(theLut));
		FSClose(refNum);
	}
}
#endif


/*
	debugging only
  */
/* #define WRITE_STRING */
#ifdef WRITE_STRING
#include "stdio.h"
void
WriteString2File  ( Str255	theFile,
					Str255	theString );
/*
	write a string to a file...
  */
void
WriteString2File  ( Str255	theFile,
					Str255	theString )
{
	FSSpec  theFSSpec;
	SINT16	refNum;
	SINT32	theCount;
	SINT32	curEOF;
	OSErr	err;
	
	FSMakeFSSpec(-LMGetSFSaveDisk(), LMGetCurDirStore(), theFile, &theFSSpec);
	err = FSpOpenDF(&theFSSpec,fsWrPerm,&refNum);
	if (err == fnfErr)
	{
		FSpCreate(&theFSSpec, 'MPS ', 'TEXT', 0L);
		FSpOpenDF(&theFSSpec,fsWrPerm,&refNum);
	}
	GetEOF(refNum,&curEOF);
	SetFPos(refNum,fsFromStart,curEOF);
	theCount = theString[0];
	FSWrite(refNum, &theCount, &theString[1]);
	FSClose(refNum);
}

#endif

/* 

1.		InvertLut1d( icCurveType *Lut )
	Params:
		Lut	(in/out)		Reference to Lut.
	Abstract:
		Given a Ptr to a Lut of type icCurveType this function calculates the invers Lut
		and overwrites the Entry-Lut.

			
2.		CombiMatrix( icXYZType *srcColorantData[3],
					 icXYZType *destColorantData[3] )
	Abstract:
		Given colorant data for source and destination matrix this function calculates the
		invers matrix of the destination and after it the multiplicated matrix of both.
	Params:
		*srcColorantData[3]	(in)			Reference to source matrix
		*destColorantData[3](in/out)		Reference to destination matrix
		
	Return:
		noErr					successful
    */
	
#define CLIPPByte(x,a,b) ((x)<(a)?(UINT8)(a):((x)>(b)?(UINT8)(b):(UINT8)(x+.5)))
#define CLIPPWord(x,a,b) ((x)<(a)?(UINT16)(a):((x)>(b)?(UINT16)(b):(UINT16)(x+.5)))

#define VAL_USED_BITS 16
#define VAL_MAX (1<<VAL_USED_BITS)
#define VAL_MAXM1 (VAL_MAX-1)
/* 
void
CreateLinearElut16 (	Ptr		theElut,
				   		SINT32	theSize,
				   		SINT32	gridPoints,
				   		SINT32	gridPointsCube)
    */
void
CreateLinearElut16 (	Ptr		theElut,
				   		SINT32	theSize,
				   		SINT32	gridPoints,
				   		SINT32	gridPointsCube)
{
	UINT16*			wordPtr;
	register UINT32 aVal;
	SINT16			loop;
	register UINT32 aFac;
	register UINT32 aDiv;
	register UINT32 aRound;
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	
	LH_START_PROC("CreateLinearElut16")
	if ( gridPointsCube )
	{
		if( gridPoints ){
			aFac = (UINT32)((gridPoints-1) * (256*128. * gridPointsCube) + (gridPointsCube-1) / 2) ;
			aFac = aFac / (gridPointsCube-1);
			aDiv = (UINT32)((gridPoints * (theSize-1) + .9999999 )/ 2.);
		}
		else{
			aFac = (UINT32)( (256*128. * gridPointsCube) + (gridPointsCube-1) / 2) ;
			aFac = aFac / (gridPointsCube-1);
			aDiv = (UINT32)(( (theSize-1) + .9999999 )/ 2.);
		}
	}
	else
	{
		if( gridPoints ){
			aFac = (gridPoints-1) * 65536;
			aDiv = gridPoints * (theSize-1);
		}
		else{
			aFac = 65535 ;
			aDiv = (theSize-1) ;
		}
	}
	aRound = aDiv/2-1;
	wordPtr = (UINT16*)theElut;
	for (loop =0; loop< theSize; loop++)
	{
		aVal = (loop * aFac + aRound ) / aDiv;
		if ( aVal > VAL_MAXM1 )
			aVal = VAL_MAXM1;
		wordPtr[loop] = (UINT16)aVal;
	}
	LH_END_PROC("CreateLinearElut16")
}

/* 
	void
	CreateLinearElut ( Ptr		theElut,
					   SINT32		theSize,
					   SINT32		gridPoints,
					   SINT32		gridPointsCube)
    */
void
CreateLinearElut ( Ptr		theElut,
				   SINT32		theSize,
				   SINT32		gridPoints,
				   SINT32		gridPointsCube)
{
	UINT16*	wordPtr;
	register UINT32 aVal;
	SINT32	loop;
	register UINT32 aFac;
	register UINT32 aDiv;
	register UINT32 aRound;
	register UINT32 aMax;
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif

	LH_START_PROC("CreateLinearElut")
	if ( gridPointsCube )
	{
		if( gridPoints ){
			aMax = 1024 * (gridPoints-1) / gridPoints;
			aFac = (UINT32)((gridPoints-1) * (1024 * gridPointsCube) + (gridPointsCube-1) / 2) ;
			aFac = aFac / (gridPointsCube-1);
			aDiv = (UINT32)((gridPoints * (theSize-1) + .9999999 ));
		}
		else{
			aFac = (UINT32)( (1024 * gridPointsCube) + (gridPointsCube-1) / 2) ;
			aFac = aFac / (gridPointsCube-1);
			aDiv = (UINT32)(( (theSize-1) + .9999999 ));
			aMax = 1023;
		}
	}
	else
	{
		if( gridPoints ){
			aMax = 1024 * (gridPoints-1) / gridPoints;
			aFac = (gridPoints-1) * 1024/2;
			aDiv = gridPoints * (theSize-1)/2;
		}
		else{
			aMax = 1023;
			aFac = aMax;
			aDiv = (theSize-1) ;
		}
	}
	aRound = aDiv/2-1;
	wordPtr = (UINT16*)theElut;
	for (loop =0; loop< theSize; loop++)
	{
		aVal = (loop * aFac + aRound ) / aDiv;
		if ( aVal > aMax )
			aVal = aMax;
		wordPtr[loop] = (UINT16)aVal;
	}
	LH_END_PROC("CreateLinearElut")
}

/* 
	void
	CreateLinearAlut16 ( 	UINT16*	theAlut,
				    		SINT32 	aCount )
    */
void
CreateLinearAlut16 ( 	UINT16*	theAlut,
				    	SINT32 	aCount )
{
	SINT32 	count = aCount;
	SINT32 	loop;
	SINT32 	aFac = 4096*VAL_MAXM1/(count-1);
	SINT32 	aRound = 2047;
	SINT32	aVal;
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
		
	LH_START_PROC("CreateLinearAlut16")
	for ( loop = 0; loop < count; loop++)
	{
		aVal = ( loop  * aFac + aRound ) >> 12;
		if ( aVal > VAL_MAXM1 )
			aVal = VAL_MAXM1;
		theAlut[loop] = (UINT16)aVal;
	}
	LH_END_PROC("CreateLinearAlut16")
}

/* 
	void
	CreateLinearAlut ( UINT8*	theAlut,
					   SINT32	count )
    */
void
CreateLinearAlut ( UINT8*	theAlut,
				   SINT32	count )
{
	SINT32 	adr_Bits;
	SINT32 	loop,i;
	SINT32	shift;
	SINT32	aRound;
	SINT32	aVal;
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	
	LH_START_PROC("CreateLinearAlut")
	for( i=1; i<100; ++i)
		if ( (1<<i) == count )
			break;  /* calculate gridpoints */
	if ( i<= 0 || i >= 100 )
		return;
	adr_Bits = i;
	shift = adr_Bits - 8;
	if ( shift > 0 )
		aRound = (1<<(shift-1));
	else
		aRound = 0;
	
	for ( loop = 0; loop < count; loop++)
	{
		aVal = ( loop + aRound ) >> shift;
		if ( aVal > 255 )
			aVal = 255;
		theAlut[loop] = (UINT8)aVal;
	}
	LH_END_PROC("CreateLinearAlut")
}

/* 
void
SetMem16  ( void *wordPtr,
			UINT32 numBytes,
			UINT16 wordValue)
    */
void
SetMem16  ( void *wordPtr,
			UINT32 numBytes,
			UINT16 wordValue);
void
SetMem16  ( void *wordPtr,
			UINT32 numBytes,
			UINT16 wordValue)
{
	register SINT32 i;
	register SINT32 count = numBytes;
	register UINT16 *ptr = (UINT16 *)wordPtr;
	register UINT16 value = wordValue;
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif

	LH_START_PROC("SetMem16")
	for (i = 0; i < count; ++i)
		*ptr++ = value;
	LH_END_PROC("SetMem16")
}

/* 
CMError
DoMakeGamutForMonitor	( CMLutParamPtr		theLutData,
						  LHCombiDataPtr	theCombiData)
    */
CMError
DoMakeGamutForMonitor	( CMLutParamPtr		theLutData,
						  LHCombiDataPtr	theCombiData)
{
	OSType			colorantTags[3];
	icXYZType 		colorantData[3];
	SINT16			loop;
	CMError			err;
	UINT32	elementSize;
	
	LH_START_PROC("DoMakeGamutForMonitor")
	
	colorantTags[0] = icSigRedColorantTag;
	colorantTags[1] = icSigGreenColorantTag;
	colorantTags[2] = icSigBlueColorantTag;
	
	/* --------------------------------------------------------------------------------- */
	for (loop = 0; loop < 3; loop++)
	{
		err = CMGetProfileElement(theCombiData->theProfile, colorantTags[loop], &elementSize, nil);
		if (err != noErr)
			goto CleanupAndExit;
		err = CMGetProfileElement(theCombiData->theProfile, colorantTags[loop], &elementSize, &colorantData[loop]);
#ifdef IntelMode
        SwapLongOffset( &colorantData[loop].base.sig, 0, 4 );
        SwapLongOffset( &colorantData[loop], (ULONG)((char*)&colorantData[0].data.data[0]-(char*)&colorantData[0]), elementSize );
#endif
		if (err != noErr)
			goto CleanupAndExit;
	}
	
	if ( theCombiData->precision == cmBestMode )
	{
		err = MakeGamut16or32ForMonitor( &colorantData[0], &colorantData[1], &colorantData[2], theLutData, TRUE );
		theLutData->colorLutGridPoints  = 32;
	}
	else
	{
		err = MakeGamut16or32ForMonitor( &colorantData[0], &colorantData[1], &colorantData[2], theLutData, FALSE);
		theLutData->colorLutGridPoints  = 16;
	}
	theLutData->colorLutInDim	= 3;
	theLutData->colorLutOutDim	= 1;
	theLutData->inputLutEntryCount = (1<<adr_breite_elut);
	theLutData->inputLutWordSize = VAL_USED_BITS;
	theLutData->outputLutEntryCount = adr_bereich_alut;
	theLutData->outputLutWordSize = bit_breite_alut;
	theLutData->colorLutWordSize = 8;

#ifdef DEBUG_OUTPUT
	if ( DebugLutCheck( kDisplayGamut ) )
	{
		LOCK_DATA(theLutData->colorLut);
		if (theCombiData->precision == cmBestMode)
			Show32by32by32GamutXLUT(DATA_2_PTR(theLutData->colorLut));
		else
			Show16by16by16GamutXLUT(DATA_2_PTR(theLutData->colorLut));
		UNLOCK_DATA(theLutData->colorLut);
	}
#endif
	
CleanupAndExit:

	LH_END_PROC("DoMakeGamutForMonitor")
	return err;
}

/* 
	CMError
	GetMatrixFromProfile	( CMProfileRef 	theProfile,
							  Ptr*			theMatrix,
							  OSType		theTag,
							  double		factor )
    */
CMError
GetMatrixFromProfile	( CMLutParamPtr		theLutData,
						  LHCombiDataPtr	theCombiData,
						  OSType			theTag,
						  double			factor )
{
 	CMError		err = noErr;
  	OSErr		aOSerr = noErr;
	SINT32		i;
	SINT32		j;
	Matrix2D	localMatrix;
	long		matrix[3][3];
	UINT32 		byteCount;
	SINT32		offset;
	
	LH_START_PROC("GetMatrixFromProfile")
	
	/* -------------------------------------------------------- get tag data from profile */
	offset	  = 12;	/* matrix starts at byte 12 */
	byteCount = 9 * sizeof(Fixed);
	err = CMGetPartialProfileElement(theCombiData->theProfile, theTag, offset, &byteCount, &matrix);
#ifdef IntelMode
        SwapLongOffset( &matrix, 0, byteCount );
#endif
	if (err)
		goto CleanupAndExit;
	
	for (i = 0; i < 3; i++)
		for (j = 0; j < 3; j++)
			localMatrix[i][j] =  (double)( matrix[i][j] / 65536.0 * factor);
	
	if ( 0  || localMatrix[0][0] + localMatrix[1][1] + localMatrix[2][2] != 3.0 )		/* ignore ident */
	{
		theLutData->matrixMFT = SmartNewPtr(sizeof(Matrix2D), &aOSerr);
		err = aOSerr;
		if (err)
			goto CleanupAndExit;
		BlockMoveData(localMatrix, theLutData->matrixMFT, sizeof(Matrix2D));
	}
	else
		theLutData->matrixMFT = nil;
	/* ---------------------------------------------------------------------------------
	    clean up
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:

	LH_END_PROC("GetMatrixFromProfile")
	return err;
}

/* 
	CMError
	Extract_MFT_Elut	  ( CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData,
							Ptr				profileLutPtr,
							OSType			theTag,
							SINT32			theCubeSize )
    */
CMError
Extract_MFT_Elut	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData,
						Ptr				profileLutPtr,
						OSType			theTag )
{
 	CMError		err = noErr;
  	OSErr		aOSerr = noErr;
	UINT32		byteCount;
	SINT32		offset;
	SINT32		i;
	SINT32		inputTableEntries;
	Ptr			theInputLuts	= nil;		/*12/1/95*/
	Boolean		readLutFromFile = TRUE;
	UINT16*		shortPtr;
	
	LH_START_PROC("Extract_MFT_Elut")
	
	/* ========================================================================================================