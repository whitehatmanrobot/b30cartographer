arams->WriteProtected =
            ((mediaInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);


        partitionCount = mediaInformation->MediumPartPage.AdditionalPartitionDefined;
        tapeGetMediaParams->PartitionCount = partitionCount + 1;


        //
        // Build a request sense to get remaining values.
        //

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(AIT_SENSE_DATA)) ) {
            DebugPrint((1,
                       "GetRemaining Size: insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(AIT_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

        Srb->DataTransferLength = sizeof(AIT_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 3) {
        if (LastError == TAPE_STATUS_SUCCESS) {
            senseData = Srb->DataBuffer;

            remaining =  (senseData->Remaining[0] << 24);
            remaining += (senseData->Remaining[1] << 16);
            remaining += (senseData->Remaining[2] <<  8);
            remaining += (senseData->Remaining[3]);


            tapeGetMediaParams->Capacity.LowPart  = extension->Capacity;

            //
            // The drive gives the information in 1024B units.
            //

            tapeGetMediaParams->Capacity.QuadPart <<= 10;

            tapeGetMediaParams->Remaining.LowPart = remaining;
            tapeGetMediaParams->Remaining.QuadPart <<= 10;
        }
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PTAPE_POSITION_DATA         positionBuffer;
    ULONG                       type;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;

        switch (type) {
            case TAPE_ABSOLUTE_POSITION:
            case TAPE_LOGICAL_POSITION:
                if (!TapeClassAllocateSrbBuffer(Srb, sizeof(TAPE_POSITION_DATA))) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (logicalBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                positionBuffer = Srb->DataBuffer;

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }
    }

    ASSERT(CallNumber == 1);

    positionBuffer = Srb->DataBuffer;

    if (positionBuffer->BlockPositionUnsupported) {
        DebugPrint((1,"TapeGetPosition: read position -- logical block position unsupported\n"));
        return TAPE_STATUS_INVALID_DEVICE_REQUEST;
    }

    tapeGetPosition->Partition = 0;
    if (tapeGetPosition->Type == TAPE_LOGICAL_POSITION) {
        tapeGetPosition->Partition = positionBuffer->PartitionNumber + 1;
    }
    tapeGetPosition->Offset.HighPart = 0;
    REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                  (PFOUR_BYTE)positionBuffer->FirstBlock);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PCDB    cdb = (PCDB)Srb->Cdb;
    PAIT_SENSE_DATA senseData;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags |= RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        commandExtension->CurrentState = LastError;

        //
        // Issue a request sense to get the cleaning info bits.
        //

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(AIT_SENSE_DATA))) {
            DebugPrint((1,
                        "GetStatus: Insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(AIT_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        Srb->DataTransferLength = sizeof(AIT_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    } else if (CallNumber == 2) {
        if ((commandExtension->CurrentState == TAPE_STATUS_SUCCESS)  ||
            (commandExtension->CurrentState == TAPE_STATUS_NO_MEDIA)) {

            //
            // Return needs cleaning status if necessary, but only if
            // no other errors are present (with the exception of no media as the
            // drive will spit out AME media when in this state).
            //

            senseData = Srb->DataBuffer;

            //
            // Determine if the clean bit is set.
            //

            if (senseData->CleaningReq) {
                DebugPrint((1,
                           "Drive reports needs cleaning\n"));

                return TAPE_STATUS_REQUIRES_CLEANING;
            } else {
               return (commandExtension->CurrentState);
            }
        } else {

            //
            // Return the saved error status.
            //

            return commandExtension->CurrentState;
        }
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_PREPARE               tapePrepare = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PAIT_SENSE_DATA             senseData;
    ULONG                       remaining;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_LOCK:
                case TAPE_UNLOCK:
                    break;

                case TAPE_TENSION:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_TENSION:
            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if ( CallNumber == 1 ) {

        if (tapePrepare->Operation == TAPE_LOAD ) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(AIT_SENSE_DATA)) ) {
                DebugPrint((1,"GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS ;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6INQUIRY.AllocationLength = sizeof(AIT_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(AIT_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        } else {

            return TAPE_STATUS_CALLBACK ;
        }
    }

    ASSERT(CallNumber == 2 );

    if ( LastError == TAPE_STATUS_SUCCESS ) {
        senseData = Srb->DataBuffer;

        remaining =  (senseData->Remaining[0] << 24);
        remaining += (senseData->Remaining[1] << 16);
        remaining += (senseData->Remaining[2] << 8);
        remaining += (senseData->Remaining[3]);

        extension->Capacity = remaining;
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE_PLUS    compressionBuffer;
    PMODE_DEVICE_CONFIG_PAGE_PLUS configBuffer;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        configBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        configBuffer = Srb->DataBuffer;

        configBuffer->ParameterListHeader.ModeDataLength = 0;
        configBuffer->ParameterListHeader.MediumType = 0;
        configBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        configBuffer->ParameterListHeader.BlockDescriptorLength = 8;

        if (tapeSetDriveParams->ReportSetmarks) {
            configBuffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            configBuffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DATA_COMPRESS_PAGE_PLUS))) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE_PLUS);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 3) {

        compressionBuffer = Srb->DataBuffer;

        if (!compressionBuffer->DataCompressPage.DCC) {
            return TAPE_STATUS_SUCCESS;
        }

        compressionBuffer->ParameterListHeader.ModeDataLength = 0;
        compressionBuffer->ParameterListHeader.MediumType = 0;
        compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        compressionBuffer->ParameterListHeader.BlockDescriptorLength = 8;

        compressionBuffer->DataCompressPage.PageCode = MODE_PAGE_DATA_COMPRESS;
        compressionBuffer->DataCompressPage.PageLength = 0x0E;

        if (tapeSetDriveParams->Compression) {
            compressionBuffer->DataCompressPage.DCE = SETBITON;
        } else {
            compressionBuffer->DataCompressPage.DCE = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE_PLUS);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE_PLUS);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 4);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
            MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.DensityCode = 0x7F;
        modeBuffer->ParameterListBlock.BlockLength[0] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
            (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 2);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_POSITION          tapeSetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    ULONG                       tapePositionVector;
    ULONG                       method;
    PAIT_SENSE_DATA             senseData;
    ULONG                       remaining;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                case TAPE_ABSOLUTE_BLOCK:
                case TAPE_LOGICAL_BLOCK:
                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:

                    break;

                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        method = tapeSetPosition->Method;
        tapePositionVector = tapeSetPosition->Offset.LowPart;

        switch (extension->DriveID) {
            case SONY_300:
            case SONY_500: {

               //
               // SDX-300 does not support spacing over sequential filemarks
               // and setmarks
               //
               switch (method) {
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS: {
                   DebugPrint((1, 
                               "TapeSetPosition: Method %x not supported on SDX-300.\n",
                               method));
                   return TAPE_STATUS_NOT_IMPLEMENTED;
                }
               }
            }

            default:
               break;
        }
        
        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (method) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));

                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 500;
                break;

            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute)\n"));

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 500;
                break;

            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute)\n"));

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 500;

                if (tapeSetPosition->Partition != 0) {

                    //
                    // Specified non-default partition.
                    //

                    if (tapeSetPosition->Partition != (extension->CurrentPartition + 1)) {

                        DebugPrint((1,
                                    "SetPosition: Setting partition (tape relative) %x\n",
                                    tapeSetPosition->Partition - 1));
                        //
                        // Need to change to the new partition.
                        //

                        cdb->LOCATE.Partition = (UCHAR)(tapeSetPosition->Partition - 1);
                        cdb->LOCATE.CPBit = 1;
                    }
                }

                break;


            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 1500;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_FILEMARKS:
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_SETMARKS:

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 4;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

        case TAPE_SPACE_SEQUENTIAL_FMKS:

            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 2;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)((tapePositionVector >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)((tapePositionVector >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapePositionVector & 0xFF);
            Srb->TimeOutValue = 4100;
            break;

        case TAPE_SPACE_SEQUENTIAL_SMKS:

            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 5;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)((tapePositionVector >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)((tapePositionVector >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapePositionVector & 0xFF);
            Srb->TimeOutValue = 4100;
            break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {
        if (tapeSetPosition->Method == TAPE_LOGICAL_BLOCK) {
            extension->CurrentPartition = tapeSetPosition->Partition - 1;
            DebugPrint((1,
                        "SetPosition: CurrentPartition (tape relative) %x\n",
                        extension->CurrentPartition));
        }

        if (tapeSetPosition->Method == TAPE_REWIND ) {

            //
            // Build a request sense to get remaining values.
            //

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(AIT_SENSE_DATA)) ) {
                DebugPrint((1,
                           "GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->ScsiStatus = Srb->SrbStatus = 0;
            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(AIT_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(AIT_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }

    }

    if (CallNumber == 2) {
        if (LastError == TAPE_STATUS_SUCCESS) {

            //
            // As a rewind was sent, get the remaining capacity from BOP.
            //

            senseData = Srb->DataBuffer;

            remaining =  (senseData->Remaining[0] << 24);
            remaining += (senseData->Remaining[1] << 16);
            remaining += (senseData->Remaining[2] <<  8);
            remaining += (senseData->Remaining[3]);

            extension->Capacity = remaining;
        }
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SHORT_FILEMARKS:
                case TAPE_LONG_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                    break;

                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SHORT_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == short filemarks\n"));
                cdb->WRITE_TAPE_MARKS.Control = 0x80;
                break;

            case TAPE_LONG_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == long filemarks\n"));
                break;

            case TAPE_SETMARKS:
                cdb->WRITE_TAPE_MARKS.WriteSetMarks = 1;
                break;

            case TAPE_FILEMARKS:
                break;

            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}


TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {

                DebugPrint((1,
                            "SonyAIT.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS));
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)Srb->DataTransferLength;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {


        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR densityCode;
        PMODE_DEVICE_CONFIG_PAGE_PLUS configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, AIT1_8mm is returned.
        //

        mediaTypes->MediaInfoCount = AIT_SUPPORTED_TYPES;


        if ( LastError == TAPE_STATUS_SUCCESS ) {
            //
            // Determine the media type currently loaded.
            //

            densityCode = configInformation->ParameterListBlock.DensityCode;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: DensityCode %x, Current Block Size %x\n",
                        densityCode,
                        blockSize));


            switch (densityCode) {
                case 0:

                    //
                    // Cleaner, unknown, no media mounted...
                    //

                    currentMedia = 0;
                    break;

                case 0x30: 
                case 0x31: {
                   //
                   // AIT1 or higher 
                   //
                   currentMedia = AIT1_8mm;
                   break;
                }

                default:

                    //
                    // Unknown
                    //

                    currentMedia = 0;
                    break;
            }
        } else if (LastError == TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED) {
            currentMedia = CLEANER_CARTRIDGE;
        } else {
            currentMedia = 0;
        }

        //
        // fill in buffer based on spec. values
        // Currently two types are supported.
        //

        for (i = 0; i < AIT_SUPPORTED_TYPES; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;
            mediaInfo->DeviceSpecific.TapeInfo.MediaType = AITMedia[i];

            if (AITMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                if (LastError == TAPE_STATUS_SUCCESS) {
                    //
                    // Indicate whether the media is write protected.
                    //

                    mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                        ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;

                    mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType =
                        configInformation->ParameterListHeader.MediumType;
                    mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode = densityCode;
                    mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                    //
                    // Fill in current blocksize.
                    //

                    mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
                } 
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }

    }

    return TAPE_STATUS_SUCCESS;
}


static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData,
    IN OUT PMINITAPE_EXTENSION miniExtension
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"SONY    ",8) == 8) {

        if ((TapeClassCompareMemory(InquiryData->ProductId,"SDX-300",7) == 7) ||
            (TapeClassCompareMemory(InquiryData->ProductId,"SDX-400",7) == 7)) {
            return SONY_300;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDX-500",7) == 7) {
            return SONY_500;
        }

        if ((TapeClassCompareMemory(InquiryData->ProductId,
                                    "TSL-A300C",
                                    9) == 9) ||
            (TapeClassCompareMemory(InquiryData->ProductId,
                                    "TSL-A400C",
                                    9) == 9)) {
            return SONY_300;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,
                                   "TSL-A500C",
                                   9) == 9) {
            return SONY_500;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"COMPAQ",6) == 6) {

        if ((TapeClassCompareMemory(InquiryData->ProductId,"SDX-300",7) == 7) ||
            (TapeClassCompareMemory(InquiryData->ProductId,"SDX-400",7) == 7)) {
            return SONY_300;
        }
        if (TapeClassCompareMemory(InquiryData->ProductId,"SDX-500",7) == 7) {
            return SONY_500;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"DEC     ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZS20",5) == 5) {
            return SONY_300;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"SEAGATE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"AIT",3) == 3) {
            return SONY_300;
        }

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\sonyait\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for sony ait drives.

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"
#include "sonyait.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TapeWMIControl)
#pragma alloc_text(PAGE, ProcessReadWriteErrors)
#pragma alloc_text(PAGE, QueryDeviceErrorData)
#pragma alloc_text(PAGE, QueryIoErrorData)
#pragma alloc_text(PAGE, VerifyReadWriteErrors)
#endif

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )
/*+
Routine Description:

   This is the common entry point for all WMI calls from tape class driver.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;

   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;

   switch (wmiOperations->Method) {
      case TAPE_CHECK_FOR_DRIVE_PROBLEM: {
         return QueryDeviceErrorData(MinitapeExtension, 
                                     CommandExtension,
                                     CommandParameters, 
                                     Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_IO_ERROR_DATA: {
         return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                 CommandParameters, Srb, CallNumber,
                                 LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_DEVICE_ERROR_DATA: {
         return QueryDeviceErrorData(MinitapeExtension, CommandExtension,
                                     CommandParameters, Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      default: {
         return TAPE_STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   } // switch (wmiOperations->Method) 
}

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns IO Error data such as read\write errors.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;

   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   IoErrorData = (PWMI_TAPE_PROBLEM_IO_ERROR)&(wmiData->TapeData);

   if (CallNumber == 0) {
      if (!TapeClassAllocateSrbBuffer(Srb, 
                                      sizeof(LOG_SENSE_PARAMETER_FORMAT))) {
         DebugPrint((1, "QueryIoErrorData : No memory for log sense info\n"));
         return TAPE_STATUS_INSUFFICIENT_RESOURCES;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(IoErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_IO_ERROR));
      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE2;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 1) {
      ProcessReadWriteErrors(Srb, FALSE, IoErrorData);

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE3;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 2) {
      ProcessReadWriteErrors(Srb, TRUE, IoErrorData);
      
      wmiData->DriveProblemType = VerifyReadWriteErrors(IoErrorData);
      DebugPrint((3, "QueryIoErrorData: DriveProblemType %x\n",
                  wmiData->DriveProblemType));
   }

   return TAPE_STATUS_SUCCESS;
}

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
)
/*+
Routine Description :

   This routine processes the buffer containing read\write counters,
   and sets the appropriate fields in WMI_TAPE_PROBLEM_IO_ERROR 
   buffer.
   
Arguments :

 Srb            SCSI Request Block
 Read           TRUE if we are to process read counters. FALSE if it is 
                Write counters
 IoErrorData    Buffer in which to return counter values.
 
Return Value :

  None  
-*/
{
   USHORT paramCode;
   UCHAR  paramLen;
   LONG  bytesLeft;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PLOG_SENSE_PARAMETER_HEADER logSenseParamHeader;
   PLOG_SENSE_PAGE_INFORMATION logSensePageInfo;
   PUCHAR  paramValue = NULL;
   ULONG transferLength;

   logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
   
   ASSERT(((logSenseHeader->PageCode) == LOGSENSEPAGE2) ||
          ((logSenseHeader->PageCode) == LOGSENSEPAGE3));

   bytesLeft = logSenseHeader->Length[0];
   bytesLeft <<= 8;
   bytesLeft += logSenseHeader->Length[1];

   transferLength = Srb->DataTransferLength;

   if (bytesLeft > (LONG)(transferLength -
                          sizeof(LOG_SENSE_PAGE_HEADER))) {
       bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
   }
   DebugPrint((3, "ProcessReadWriteErrors : BytesLeft %x, TransferLength %x\n",
            bytesLeft, transferLength));

   (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseHeader + sizeof(LOG_SENSE_PAGE_HEADER);
   while (bytesLeft >= sizeof(LOG_SENSE_PARAMETER_HEADER)) {
      paramCode = logSenseParamHeader->ParameterCode[0];
      paramCode <<= 8;
      paramCode |= logSenseParamHeader->ParameterCode[1];
      paramLen = logSenseParamHeader->ParameterLength;
      paramValue = (PUCHAR)logSenseParamHeader + sizeof(LOG_SENSE_PARAMETER_HEADER);

      //
      // Make sure we have at least
      // (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen) bytes left.
      // Otherwise, we've reached the end of the buffer.
      //
      if (bytesLeft < (LONG)(sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)) {
          DebugPrint((1,
                      "sonyait : Reached end of buffer. BytesLeft %x, Expected %x\n",
                      bytesLeft,
                      (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)));
          break;
      }
      DebugPrint((3,
                 "ProcessReadWriteErrors : ParamCode %x, ParamLen %x\n",
                 paramCode, paramLen));
      switch (paramCode) {
         case TotalCorrectedErrors: {
            USHORT value;

            value = (UCHAR)*(paramValue);
            value <<= 8;
            value += (UCHAR)*(paramValue+1);
            DebugPrint((3, "TotalCorrectedErrors %x\n",
                        value));
            if (Read) {
               IoErrorData->ReadTotalCorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalCorrectedErrors = value;
            }
            break;
         }

         case TotalUncorrectedErrors: {
            USHORT value;

            value = (UCHAR)*(paramValue);
            value <<= 8;
            value += (UCHAR)*(paramValue+1);
            DebugPrint((3, "TotalUncorrectedErrors %x\n",
                        value));
            if (Read) {
               IoErrorData->ReadTotalUncorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalUncorrectedErrors = value;
            }

            break;
         }

         case TotalTimesAlgorithmProcessed: {
            ULONG value;
            ULONG tmpVal;

            value = (UCHAR)*(paramValue);
            value <<= 24;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 16;
            value += tmpVal;
            tmpVal = (UCHAR)*(paramValue+2);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+3);
            DebugPrint((3, "TotalTimesAlgorithmProcessed %x\n",
                        value));
            if (Read) {
               IoErrorData->ReadCorrectionAlgorithmProcessed = value;
            } else {
               IoErrorData->WriteCorrectionAlgorithmProcessed = value;
            }
            break;
         }

         default: {
            break;
         }
      } // switch (paramCode) 

      (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseParamHeader + 
                                    sizeof(LOG_SENSE_PARAMETER_HEADER) +
                                    paramLen;

      bytesLeft -= paramLen + sizeof(LOG_SENSE_PARAMETER_HEADER);
   } // while (bytesLeft > 0)

   if (Read) {
      IoErrorData->ReadTotalErrors = IoErrorData->ReadTotalUncorrectedErrors +
                                     IoErrorData->ReadTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: ReadErrors %x\n",
                  IoErrorData->ReadTotalErrors));
   } else {
      IoErrorData->WriteTotalErrors = IoErrorData->WriteTotalUncorrectedErrors +
                                      IoErrorData->WriteTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: WriteErrors %x\n",
                  IoErrorData->WriteTotalErrors));
   }
}

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   )
/*+

Routine Description :

   This routine looks at the read\write error counters.
   If the values are above a certain threshold, it returns
   appropriate error value.
   
Argument :

  IoErrorData  WMI_TAPE_PROBLEM_IO_ERROR struct
  
Return Value :
   
      TapeDriveReadWriteError If there are too many uncorrected 
                              read\write errors
                         
      TapeDriveReadWriteWarning If there are too many corrected
                                read\write errors 
                                
      TapeDriveProblemNone    If the read\write errors are below
                              threshold   
  
-*/
{
   if (((IoErrorData->ReadTotalUncorrectedErrors) >=
         TAPE_READ_ERROR_LIMIT)   ||       
       ((IoErrorData->WriteTotalUncorrectedErrors) >=
         TAPE_WRITE_ERROR_LIMIT)) {
      return TapeDriveReadWriteError;
   }

   if (((IoErrorData->ReadTotalCorrectedErrors) >=
         TAPE_READ_WARNING_LIMIT) ||
       ((IoErrorData->WriteTotalCorrectedErrors) >=
         TAPE_WRITE_WARNING_LIMIT)) {

      return TapeDriveReadWriteWarning;
   }

   return TapeDriveProblemNone;
}

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns device Error data such as "drive calibration"
   error, etc.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;
   PWMI_TAPE_PROBLEM_DEVICE_ERROR DeviceErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;
   PAIT_SENSE_DATA aitSenseData;
   
   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   DeviceErrorData = (PWMI_TAPE_PROBLEM_DEVICE_ERROR)wmiData->TapeData;

   if (CallNumber == 0) {
      //
      // Build a request sense to get remaining values.
      //

      if (!TapeClassAllocateSrbBuffer( Srb, sizeof(AIT_SENSE_DATA)) ) {
          DebugPrint((1,
                     "QueryDeviceErrorData: insufficient resources (SenseData)\n"));
          return TAPE_STATUS_SUCCESS;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(DeviceErrorData,
                          sizeof(WMI_TAPE_PROBLEM_DEVICE_ERROR));

      //
      // Prepare SCSI command (CDB)
      //

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      Srb->ScsiStatus = Srb->SrbStatus = 0;
      Srb->CdbLength = CDB6GENERIC_LENGTH;

      cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
      cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(AIT_SENSE_DATA);

      //
      // Send SCSI command (CDB) to device
      //

      DebugPrint((3,"QueryDeviceErrorData: SendSrb (request sense)\n"));

      Srb->DataTransferLength = sizeof(AIT_SENSE_DATA);
      *RetryFlags |= RETURN_ERRORS;

      return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }
   
   if (CallNumber == 1) {

      if (LastError == TAPE_STATUS_SUCCESS) {
          aitSenseData = Srb->DataBuffer;

          if (aitSenseData->CleaningReq) {
             DeviceErrorData->DriveRequiresCleaning = TRUE;
             wmiData->DriveProblemType = TapeDriveCleanDriveNow;
          }
          
          if (aitSenseData->MEW) {
             DeviceErrorData->WriteWarning = TRUE;
             DeviceErrorData->ReadWarning = TRUE;
             wmiData->DriveProblemType = TapeDriveReadWarning;
          }

          if (((aitSenseData->FRUC) == 0x01) ||
              ((aitSenseData->FRUC) == 0x02)) {
                DeviceErrorData->DriveHardwareError = TRUE;
                wmiData->DriveProblemType = TapeDriveHardwareError;
          }

          DebugPrint((3, "QueryDeviceErrorData: DriveProblemType %x\n",
                      wmiData->DriveProblemType));
      }
   }
   
   return TAPE_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\tandqic\tandqic.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tandqic.c
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1994 - Arcada Software Inc. - All rights reserved

Module Name:

    tandqic.c

Abstract:

    This module contains device specific routines for Tandberg QIC
    drives with SCSI-2 interfaces -- TDC 4222, TDC 4220, TDC 4120,
    TDC 3820, and TDC 3660.

Author:

    Mike Colandreo  (Arcada)

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

//
//  Internal (module wide) defines that symbolize
//  non-QFA mode and the two QFA mode partitions.
//
#define NO_PARTITIONS        0  // non-QFA mode
#define DIRECTORY_PARTITION  1  // QFA mode, directory partition #
#define DATA_PARTITION       2  // QFA mode, data partition #

//
//  Internal (module wide) defines that symbolize
//  the Tandberg QIC drives supported by this module.
//
#define TDC_3600  (ULONG)1  // aka the TDC 3660
#define TDC_3800  (ULONG)2  // aka the TDC 3820
#define TDC_4100  (ULONG)3  // aka the TDC 4120
#define TDC_4200  (ULONG)4  // aka the TDC 4220
#define TDC_4222  (ULONG)5  // aka the TDC 4222
#define IBM_4100  (ULONG)6  // aka the TDC 4120
#define TDC_MLR1  (ULONG)7  // aka the TDC 6100

#define MLR1_PART_PAGE_SIZE 0x54

#define QIC_SUPPORTED_TYPES 1
STORAGE_MEDIA_TYPE QicMedia[QIC_SUPPORTED_TYPES] = {QIC};

//
// Minitape extension definition.
//
typedef struct _MINITAPE_EXTENSION {
          ULONG DriveID ;
          ULONG CurrentPartition ;
          BOOLEAN CompressionOn ;
} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION ;

//
// Command extension definition.
//

typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;
    UCHAR   densityCode;
    UCHAR   mediumType;
    ULONG   tapeBlockLength;
    BOOLEAN changePartition ;
    ULONG   psudo_space_count ;
    ULONG   pos_type ;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

//
//  Function Prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);


BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = NULL; // Doesn't do anything. So set it to NULL
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = QIC_SUPPORTED_TYPES;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData);
    extension->CurrentPartition = 0 ;
    extension->CompressionOn = FALSE ;
}


TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION      extension = MinitapeExtension;
    PCOMMAND_EXTENSION       tapeCmdExtension = CommandExtension ;
    PTAPE_CREATE_PARTITION   tapePartition = CommandParameters;
    PMODE_MEDIUM_PART_PAGE   buffer;
    ULONG                    partPageSize;
    PCDB                     cdb = (PCDB) Srb->Cdb;

    //
    //  Only support 2 partitions, QFA mode
    //  Partition 1 = Used as directory
    //  Partition 0 = used as data
    //
    //  Note that 0 & 1 are partition numbers used
    //  by the drive -- they are not tape API partition
    //  numbers.
    //

    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));

    if (CallNumber == 0) {

        switch (tapePartition->Method) {
            case TAPE_FIXED_PARTITIONS:
                DebugPrint((3,"TapeCreatePartition: fixed partitions\n"));
                break;

            case TAPE_SELECT_PARTITIONS:
            case TAPE_INITIATOR_PARTITIONS:

                //
                // The MLR1 is capable of Initiator-defined partitions, but only
                // with certain media types. Rather than creating confusion by returning
                // an error because of incorrect media, just claim it's not supported.
                //

            default:
                DebugPrint((1,"TapeCreatePartition: "));
                DebugPrint((1,"PartitionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
         }

        //
        // Must rewind to BOT before one can enable/disable QFA mode.
        // Changing the value of the FDP bit is only valid at BOT.
        // FDP bit is used to enable/disable "additional partitions"
        // (mode sense command).
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (rewind)\n"));

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_REWIND;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 320;
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if (CallNumber == 1) {

        //
        // Send mode sense - part page to get the current values.
        //

        if (extension->DriveID == TDC_MLR1) {

            //
            // 0x50 bytes for the MLR1 page + 4-byte header.
            //

            partPageSize = MLR1_PART_PAGE_SIZE;

        } else {

            //
            // Tandberg's page is 4 bytes less as it has no
            // partition0 and partition1 size fields.
            //

            partPageSize = sizeof(MODE_MEDIUM_PART_PAGE) - 4;
        }

        if (!TapeClassAllocateSrbBuffer( Srb,partPageSize) ) {
            DebugPrint((1,"TapeCreatePartition: insufficient resources (buffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)partPageSize;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = partPageSize;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if ( CallNumber == 2 ) {

        if (extension->DriveID == TDC_MLR1) {

            //
            // 0x50 bytes for the MLR1 page + 4-byte header.
            //

            partPageSize = MLR1_PART_PAGE_SIZE;

        } else {

            //
            // Tandberg's page is 4 bytes less as it has no
            // partition0 and partition1 size fields.
            //

            partPageSize = sizeof(MODE_MEDIUM_PART_PAGE) - 4;
        }


        //
        // Performing mode select command, medium partition parameters page,
        // to enable/disable QFA mode: set the FDP bit accordingly.
        //

        buffer = Srb->DataBuffer ;

        buffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        buffer->ParameterListHeader.ModeDataLength = 0x0;
        buffer->ParameterListHeader.MediumType = 0x0;

        buffer->MediumPartPage.PSBit = SETBITOFF;

        //
        // Setup FDP bit to enable/disable "additional partition".
        //

        if (tapePartition->Count == 0) {
            buffer->MediumPartPage.FDPBit = SETBITOFF;
        } else {
            buffer->MediumPartPage.FDPBit = SETBITON;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode  = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)partPageSize;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode select)\n"));

        Srb->DataTransferLength = partPageSize;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 3 ) ;

    if (tapePartition->Count == 0) {
        extension->CurrentPartition = NO_PARTITIONS;
        DebugPrint((3,"TapeCreatePartition: QFA disabled\n"));
    } else {
        extension->CurrentPartition = DATA_PARTITION;
        DebugPrint((3,"TapeCreatePartition: QFA enabled\n"));
    }

    return TAPE_STATUS_SUCCESS;

} // end TapeCreatePartition()


TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION      extension = MinitapeExtension;
    PTAPE_ERASE              tapeErase = CommandParameters;
    PCDB                     cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            switch (tapeErase->Type) {
                case TAPE_ERASE_LONG:
                    DebugPrint((3,"TapeErase: immediate\n"));
                    break;

                case TAPE_ERASE_SHORT:
                default:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = SETBITON;

        Srb->TimeOutValue = 320;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 1 ) ;

    if (extension->CurrentPartition) {
        extension->CurrentPartition = DATA_PARTITION;
    }

    return TAPE_STATUS_SUCCESS ;

} // end TapeErase()


VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer = Srb->SenseInfoBuffer;
    UCHAR              sensekey = senseBuffer->SenseKey & 0x0F;
    UCHAR              adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
    UCHAR              adsense = senseBuffer->AdditionalSenseCode;

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    return;

} // end TapeError()


TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          cmdExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;
    PMODE_PARM_READ_WRITE_DATA  blockDescripterModeSenseBuffer;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        switch (extension->DriveID) {
            case TDC_4100:
            case IBM_4100:
            case TDC_4200:
            case TDC_4222:
            case TDC_MLR1:
                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
                    DebugPrint((1,"TapeGetDriveParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }
                deviceConfigModeSenseBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.Dbd = SETBITON;
                cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
                cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

                Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

            default:
                return TAPE_STATUS_CALLBACK ;

        }
    }

    if ( CallNumber == 1 ) {

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        if ( extension->DriveID != IBM_4100 ) {

             tapeGetDriveParams->FeaturesLow |=
                         TAPE_DRIVE_REPORT_SMKS;

             tapeGetDriveParams->FeaturesHigh |=
                         TAPE_DRIVE_SETMARKS |
                         TAPE_DRIVE_WRITE_SETMARKS;
        }

        tapeGetDriveParams->ReportSetmarks = FALSE ;

        if (( LastError == TAPE_STATUS_SUCCESS ) &&
            (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk) ) {

            tapeGetDriveParams->ReportSetmarks = TRUE ;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {

            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockDescripterModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockDescripterModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        blockDescripterModeSenseBuffer = Srb->DataBuffer ;

        cmdExtension->mediumType = blockDescripterModeSenseBuffer->ParameterListHeader.MediumType;
        cmdExtension->densityCode= blockDescripterModeSenseBuffer->ParameterListBlock.DensityCode;

        switch (cmdExtension->mediumType) {
            case 1:
               cmdExtension->mediumType = DC600;
               break;

            case 2:
               cmdExtension->mediumType = DC6150;
               break;

            case 3:
               cmdExtension->mediumType = DC6320;
               break;

        }

        if ((extension->DriveID == TDC_4222) || (extension->DriveID == TDC_MLR1)) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
                DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            compressionModeSenseBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.Dbd = SETBITON;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

            Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        } else {
            return TAPE_STATUS_CALLBACK ;
        }
    }
    if ( CallNumber == 3 ) {

        if ( LastError == TAPE_STATUS_CALLBACK ) {
            return TAPE_STATUS_CALLBACK ;
        }

        compressionModeSenseBuffer = Srb->DataBuffer ;

        if ((extension->DriveID == TDC_4222) || 
            (extension->DriveID == TDC_MLR1)) {

            //
            // Attempt to forget the insanity of the other drives and do what is 'normal'.
            //

            if (compressionModeSenseBuffer->DataCompressPage.DCC) {
                tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
                tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
                tapeGetDriveParams->Compression =
                    (compressionModeSenseBuffer->DataCompressPage.DCE? TRUE : FALSE);
            }

        } else {
            if (!cmdExtension->densityCode) {

                switch (cmdExtension->mediumType) {
                    case DC9200SL:
                    case DC9200:
                    case DC9200XL:
                        cmdExtension->densityCode = QIC_2GB;
                        break;
                }


                if (cmdExtension->densityCode == QIC_2GB) {

                    tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
                    tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
                    tapeGetDriveParams->Compression = (BOOLEAN)extension->CompressionOn ;

                }
            }
        }

        return TAPE_STATUS_CALLBACK ;

    }

    if ( CallNumber == 4 ) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(READ_BLOCK_LIMITS_DATA)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimitsBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
         //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        Srb->DataTransferLength = sizeof(READ_BLOCK_LIMITS_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 5 ) ;

    blockLimits = Srb->DataBuffer ;

    tapeGetDriveParams->MaximumBlockSize  =  blockLimits->BlockMaximumSize[2];
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

    tapeGetDriveParams->MinimumBlockSize  =  blockLimits->BlockMinimumSize[1];
    tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);

    tapeGetDriveParams->ECC = 0;
    tapeGetDriveParams->DataPadding = 0;
    tapeGetDriveParams->MaximumPartitionCount = 2;

    //
    // CEP TODO: see what is correct for the MLR1 here.
    //

    switch (cmdExtension->densityCode) {
        case QIC_XX:
            switch (cmdExtension->mediumType) {
                case DC6320:
                case DC6525:
                case DC9100:
                case DC9120:
                case DC9120SL:
                case DC9120XL:
                case DC9200SL:
                case DC9200:
                case DC9200XL:
                    tapeGetDriveParams->DefaultBlockSize = 1024;
                    break;

                default:
                    tapeGetDriveParams->DefaultBlockSize = 512;
                    break;
            }
            break;

        case QIC_525:
        case QIC_1000:
        case QIC_2GB:
            tapeGetDriveParams->DefaultBlockSize = 512;
            break;

        default:
            tapeGetDriveParams->DefaultBlockSize = 512;
            break;
    }

    if ( ( extension->DriveID != TDC_3600) &&
         (extension->DriveID != IBM_4100) ) {

        tapeGetDriveParams->FeaturesLow |=
            TAPE_DRIVE_VARIABLE_BLOCK;

        tapeGetDriveParams->FeaturesHigh |=
            TAPE_DRIVE_SET_BLOCK_SIZE;

    }

    if (extension->DriveID == TDC_3600) {
        tapeGetDriveParams->FeaturesHigh &= ~(TAPE_DRIVE_SETMARKS | TAPE_DRIVE_WRITE_SETMARKS);
        tapeGetDriveParams->ReportSetmarks = FALSE ;
    }

    tapeGetDriveParams->FeaturesLow |=
        TAPE_DRIVE_FIXED |
        TAPE_DRIVE_ERASE_LONG |
        TAPE_DRIVE_ERASE_BOP_ONLY |
        TAPE_DRIVE_ERASE_IMMEDIATE |
        TAPE_DRIVE_FIXED_BLOCK |
        TAPE_DRIVE_WRITE_PROTECT |
        TAPE_DRIVE_GET_ABSOLUTE_BLK |
        TAPE_DRIVE_GET_LOGICAL_BLK;

    tapeGetDriveParams->FeaturesHigh |=
        TAPE_DRIVE_LOAD_UNLOAD |
        TAPE_DRIVE_TENSION |
        TAPE_DRIVE_LOCK_UNLOCK |
        TAPE_DRIVE_REWIND_IMMEDIATE |
        TAPE_DRIVE_LOAD_UNLD_IMMED |
        TAPE_DRIVE_TENSION_IMMED |
        TAPE_DRIVE_ABSOLUTE_BLK |
        TAPE_DRIVE_LOGICAL_BLK |
        TAPE_DRIVE_END_OF_DATA |
        TAPE_DRIVE_RELATIVE_BLKS |
        TAPE_DRIVE_FILEMARKS |
        TAPE_DRIVE_SEQUENTIAL_FMKS |
        TAPE_DRIVE_REVERSE_POSITION |
        TAPE_DRIVE_WRITE_FILEMARKS |
        TAPE_DRIVE_WRITE_MARK_IMMED;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
        tapeGetDriveParams->FeaturesLow));
    DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
        tapeGetDriveParams->FeaturesHigh));

    return TAPE_STATUS_SUCCESS;

} // end TapeGetDriveParameters()


TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigBuffer;
    PMODE_PARM_READ_WRITE_DATA  rwparametersModeSenseBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    BOOLEAN                     qfaMode;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (mediaInfoBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense #1)\n"));

        Srb->DataTransferLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        mediaInfoBuffer = Srb->DataBuffer ;

        tapeGetMediaParams->BlockSize = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);

        tapeGetMediaParams->WriteProtected =
            ((mediaInfoBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

        if (!mediaInfoBuffer->MediumPartPage.FDPBit) {

            tapeGetMediaParams->PartitionCount = 1 ;

            extension->CurrentPartition = NO_PARTITIONS;

            return TAPE_STATUS_SUCCESS ;

        } else {

            if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
                DebugPrint((1,"TapeGetMediaParameters: insufficient resources (deviceConfigBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            deviceConfigBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.Dbd = SETBITON;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense #2)\n"));

            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }
    }
    ASSERT( CallNumber == 3) ;

    deviceConfigBuffer = Srb->DataBuffer ;

    extension->CurrentPartition =
            deviceConfigBuffer->DeviceConfigPage.ActivePartition?
            DIRECTORY_PARTITION : DATA_PARTITION;

    tapeGetMediaParams->PartitionCount = 2;

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetMediaParameters()

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          cmdExtension = CommandExtension;
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigBuffer;
    PTAPE_POSITION_DATA         readPositionBuffer;
    PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;
    ULONG                       type;
    ULONG                        tapeBlockAddress;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;
        cmdExtension->pos_type = type ;

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if ( CallNumber == 1 ) {

        if ( cmdExtension->pos_type != TAPE_LOGICAL_POSITION ) {

            return TAPE_STATUS_CALLBACK ;
        }

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (mediaInfoBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (mode sense #1)\n"));

        Srb->DataTransferLength=sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 2) {

        if ( cmdExtension->pos_type != TAPE_LOGICAL_POSITION ) {

            return TAPE_STATUS_CALLBACK ;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        cmdExtension->mediumType  = mediaInfoBuffer->ParameterListHeader.MediumType;
        cmdExtension->densityCode = mediaInfoBuffer->ParameterListBlock.DensityCode;
        cmdExtension->tapeBlockLength  = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);

        if (!mediaInfoBuffer->MediumPartPage.FDPBit) {
            extension->CurrentPartition = NO_PARTITIONS;
            return TAPE_STATUS_CALLBACK ;
        }

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (deviceConfigBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (mode sense #2)\n"));

        Srb->DataTransferLength=sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if ( CallNumber == 3 ) {

        if ( cmdExtension->pos_type != TAPE_LOGICAL_POSITION ) {

            return TAPE_STATUS_CALLBACK ;
        }

        if ( LastError != TAPE_STATUS_CALLBACK ) {

            deviceConfigBuffer = Srb->DataBuffer ;

            extension->CurrentPartition =
                 deviceConfigBuffer->DeviceConfigPage.ActivePartition?
                 DIRECTORY_PARTITION : DATA_PARTITION;

        }

        if ((extension->DriveID != TDC_4222) && (extension->DriveID != TDC_MLR1)) {
             cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_POSITION;
             return TAPE_STATUS_CALLBACK ;
        }

        if ((extension->DriveID != TDC_4222) && (extension->DriveID != TDC_MLR1)) {

            if (!cmdExtension->densityCode) {

                switch (cmdExtension->mediumType) {
                    case DC9200SL:
                    case DC9200:
                    case DC9200XL:
                        cmdExtension->densityCode = QIC_2GB;
                        break;
                }

            }

            if (cmdExtension->densityCode != QIC_2GB) {
                 cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_POSITION;
                 return TAPE_STATUS_CALLBACK ;
            }
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength=sizeof(MODE_DATA_COMPRESS_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 4 ) {

        if ( LastError != TAPE_STATUS_CALLBACK ) {

            compressionModeSenseBuffer = Srb->DataBuffer;

            if (!(compressionModeSenseBuffer->DataCompressPage.DCE)) {
               if ((extension->DriveID != TDC_4222) && 
                   (extension->DriveID != TDC_MLR1)) { 
                  cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_POSITION;
               }
            }
        }

        switch (cmdExtension->pos_type) {
            case TAPE_ABSOLUTE_POSITION:
                DebugPrint((3,"TapeGetPosition: absolute\n"));
                break;

            case TAPE_LOGICAL_POSITION:
                DebugPrint((3,"TapeGetPosition: logical\n"));
                break;

            case TAPE_PSEUDO_LOGICAL_POSITION:
                DebugPrint((3,"TapeGetPosition: pseudo logical\n"));
                break;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));

           return TAPE_STATUS_NOT_IMPLEMENTED;

        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(TAPE_POSITION_DATA)) ) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (readPositionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        readPositionBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB10GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;
        cdb->READ_POSITION.BlockType = (cmdExtension->pos_type == TAPE_LOGICAL_POSITION)?
                                       SETBITOFF : SETBITON;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

        Srb->DataTransferLength = sizeof(TAPE_POSITION_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    ASSERT( CallNumber == 5 ) ;

    readPositionBuffer = Srb->DataBuffer ;

    REVERSE_BYTES((PFOUR_BYTE)&tapeBlockAddress,
                      (PFOUR_BYTE)readPositionBuffer->FirstBlock);


    if (cmdExtension->pos_type == TAPE_PSEUDO_LOGICAL_POSITION) {
        tapeBlockAddress =
            TapeClassPhysicalBlockToLogicalBlock(
                cmdExtension->densityCode,
                tapeBlockAddress,
                cmdExtension->tapeBlockLength,
                (BOOLEAN)(
                    (extension->CurrentPartition
                        == DIRECTORY_PARTITION)?
                    NOT_FROM_BOT : FROM_BOT
                )
            );
    }

    tapeGetPosition->Offset.HighPart = 0;
    tapeGetPosition->Offset.LowPart  = tapeBlockAddress;

    if (cmdExtension->pos_type != TAPE_ABSOLUTE_POSITION) {
        tapeGetPosition->Partition = extension->CurrentPartition;
    }

    return TAPE_STATUS_SUCCESS;

} // end TapeGetPosition()


TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCDB    cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;

} // end TapeGetStatus()


TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_PREPARE      tapePrepare = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                case TAPE_TENSION:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_LOCK:
                case TAPE_UNLOCK:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_TENSION:
                DebugPrint((3,"TapePrepare: Operation == tension\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                Srb->TimeOutValue = 320;
                break;

            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    ASSERT(CallNumber == 1) ;

    return TAPE_STATUS_SUCCESS;

} // end TapePrepare()


TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if ((extension->DriveID != TDC_4222) && (extension->DriveID != TDC_MLR1)) {
            DebugPrint((1,"TapeSetDriveParameters: Operation -- operation not supported\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if ( CallNumber == 1 ) {

        compressionBuffer = Srb->DataBuffer ;

        if (!compressionBuffer->DataCompressPage.DCC) {
            return TAPE_STATUS_SUCCESS ;
        }

        compressionBuffer->ParameterListHeader.ModeDataLength = 0;
        compressionBuffer->ParameterListHeader.MediumType = 0;
        compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        compressionBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        compressionBuffer->DataCompressPage.Reserved1  = 0;
        compressionBuffer->DataCompressPage.PageCode   = MODE_PAGE_DATA_COMPRESS;
        compressionBuffer->DataCompressPage.PageLength = 0x0E;

        if (tapeSetDriveParams->Compression) {
            compressionBuffer->DataCompressPage.DCE = SETBITON;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[3]= 3;
            extension->CompressionOn = TRUE;
        } else {
            compressionBuffer->DataCompressPage.DCE = SETBITOFF;
            extension->CompressionOn = FALSE;
        }

        compressionBuffer->DataCompressPage.DDE = SETBITON;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        *RetryFlags |= RETURN_ERRORS;

        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 2) ;
    if ( LastError == TAPE_STATUS_INVALID_DEVICE_REQUEST) {
         LastError = TAPE_STATUS_SUCCESS;
    }

    return LastError;

} // end TapeSetDriveParameters()

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if (extension->DriveID == TDC_3600) {
            DebugPrint((1,"TapeSetMediaParameters: whichdrive -- operation not supported\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ( CallNumber == 1 ) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer ;

        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength = MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.DensityCode = 0x7F;
        modeBuffer->ParameterListBlock.BlockLength[0] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
            (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    ASSERT( CallNumber == 2 );

    return TAPE_STATUS_SUCCESS;

} // end TapeSetMediaParameters()


TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION          extension = MinitapeExtension;
    PCOMMAND_EXTENSION           cmdExtension = CommandExtension ;
    PTAPE_SET_POSITION           tapeSetPosition = CommandParameters;
    PMODE_DATA_COMPRESS_PAGE     compressionModeSenseBuffer;
    PMODE_DEVICE_CONFIG_PAGE     deviceConfigBuffer;
    PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;
    PINQUIRYDATA                 inquiryBuffer;
    TAPE_PHYS_POSITION           physPosition;
    BOOLEAN                      changePartition = FALSE;
    ULONG                        tapePositionVector;
    ULONG                        tapeBlockLength;
    ULONG                        driveID;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        cmdExtension->changePartition = FALSE;


        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                    DebugPrint((3,"TapeSetPosition: immediate\n"));
                    break;

                case TAPE_LOGICAL_BLOCK:
                case TAPE_ABSOLUTE_BLOCK:
                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:
                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        cmdExtension->pos_type = tapeSetPosition->Method;

        if (cmdExtension->pos_type != TAPE_LOGICAL_BLOCK) {
            return TAPE_STATUS_CALLBACK ;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
            DebugPrint((1,"TapeSetPosition: insufficient resources (mediaInfoBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (mode sense #1)\n"));

        Srb->DataTransferLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 1 ) {

        if (cmdExtension->pos_type != TAPE_LOGICAL_BLOCK) {
            return TAPE_STATUS_CALLBACK ;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        cmdExtension->mediumType       = mediaInfoBuffer->ParameterListHeader.MediumType;
        cmdExtension->densityCode      = mediaInfoBuffer->ParameterListBlock.DensityCode;
        cmdExtension->tapeBlockLength  = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);


        if (!mediaInfoBuffer->MediumPartPage.FDPBit) {
            extension->CurrentPartition = NO_PARTITIONS;
            return TAPE_STATUS_CALLBACK ;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeSetPosition: insufficient resources (deviceConfigBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (mode sense #2)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;
        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        if (cmdExtension->pos_type != TAPE_LOGICAL_BLOCK) {
            return TAPE_STATUS_CALLBACK ;
        }

        if (LastError != TAPE_STATUS_CALLBACK ) {

            deviceConfigBuffer = Srb->DataBuffer ;

            extension->CurrentPartition =
                deviceConfigBuffer->DeviceConfigPage.ActivePartition?
                DIRECTORY_PARTITION : DATA_PARTITION;


        }


        switch (tapeSetPosition->Partition) {
            case 0:
                break;

            case DIRECTORY_PARTITION:
            case DATA_PARTITION:
                if (extension->CurrentPartition != NO_PARTITIONS) {
                    if (tapeSetPosition->Partition
                        != extension->CurrentPartition) {
                        cmdExtension->changePartition = TRUE;
                    }
                    break;
                }
                // else: fall through to next case

            default:
                DebugPrint((1,"TapeSetPosition: Partition -- invalid parameter\n"));
                return TAPE_STATUS_INVALID_PARAMETER;
        }

        if ((extension->DriveID != TDC_4222) && (extension->DriveID != TDC_MLR1)) {

            cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_BLOCK;
            return TAPE_STATUS_CALLBACK ;
        }

        if ((extension->DriveID != TDC_4222) && (extension->DriveID != TDC_MLR1)) {
            if (!cmdExtension->densityCode) {

                switch (cmdExtension->mediumType) {
                    case DC9200SL:
                    case DC9200:
                    case DC9200XL:
                        cmdExtension->densityCode = QIC_2GB;
                        break;
                }

            }

            if (cmdExtension->densityCode != QIC_2GB) {
                cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_BLOCK;
                return TAPE_STATUS_CALLBACK ;
            }
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeSetPosition: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if ( CallNumber == 3 ) {

        if (LastError != TAPE_STATUS_CALLBACK ) {
            compressionModeSenseBuffer = Srb->DataBuffer ;

            if (!compressionModeSenseBuffer->DataCompressPage.DCE) {
                if ((extension->DriveID != TDC_4222) && (extension->DriveID != TDC_MLR1)) {
                    cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_BLOCK;
                }
            }
        }

        tapePositionVector = tapeSetPosition->Offset.LowPart;

        if (cmdExtension->pos_type == TAPE_PSEUDO_LOGICAL_BLOCK) {

            physPosition =
                TapeClassLogicalBlockToPhysicalBlock(
                cmdExtension->densityCode,
                tapeSetPosition->Offset.LowPart,
                cmdExtension->tapeBlockLength,
                (BOOLEAN)(
                    (extension->CurrentPartition
                        == DIRECTORY_PARTITION)?
                    NOT_FROM_BOT : FROM_BOT
                )
            );

            tapePositionVector = physPosition.SeekBlockAddress;

        }

        DebugPrint((3,"TapeSetPosition: pseudo logical\n"));

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (cmdExtension->pos_type) {
            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute)\n"));
                break;

            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (logical)\n"));
                break;

            case TAPE_PSEUDO_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (pseudo logical)\n"));
                break;
        }

        cmdExtension->psudo_space_count = 0 ;

        switch (cmdExtension->pos_type) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_PSEUDO_LOGICAL_BLOCK:
                cmdExtension->psudo_space_count = physPosition.SpaceBlockCount ;

                // basicaly, we have to make two calls in this case
                //    one for locate and one for space

                /* fall through */

            case TAPE_ABSOLUTE_BLOCK:
            case TAPE_LOGICAL_BLOCK:

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.CPBit = changePartition? SETBITON : SETBITOFF;
                cdb->LOCATE.BTBit = (cmdExtension->pos_type == TAPE_LOGICAL_BLOCK)?
                                     SETBITOFF : SETBITON;
                cdb->LOCATE.LogicalBlockAddress[1] =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] =
                    (UCHAR)(tapePositionVector & 0xFF);
                if (changePartition &&
                    (tapeSetPosition->Partition == DIRECTORY_PARTITION)) {
                    cdb->LOCATE.Partition = 1;
                }

                Srb->TimeOutValue = 480;

                break;

            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:

                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11100;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11100;
                break;

            case TAPE_SPACE_SEQUENTIAL_FMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 2;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11100;
                break;

            case TAPE_SPACE_SETMARKS:
                DebugPrint((3,"TapeSetPosition: method == space setmarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 4;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11100;
                break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 4 ) {

        if (cmdExtension->psudo_space_count ) {

            //
            // Zero CDB in SRB on stack.
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            DebugPrint((3,"TapeSetPosition: method == locate (pseudo logical) + space block(s)\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 0;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                 (UCHAR)((cmdExtension->psudo_space_count >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                 (UCHAR)((cmdExtension->psudo_space_count >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                 (UCHAR)(cmdExtension->psudo_space_count & 0xFF);
            Srb->TimeOutValue = 180;

            Srb->DataTransferLength = 0 ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        }

        if (cmdExtension->changePartition) {
            extension->CurrentPartition = tapeSetPosition->Partition;
        }

        return TAPE_STATUS_SUCCESS ;

    }
    ASSERT( CallNumber == 5 )

    return TAPE_STATUS_SUCCESS ;

} // end TapeSetPosition()



TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                case TAPE_SHORT_FILEMARKS:
                case TAPE_LONG_FILEMARKS:
                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SETMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == setmarks\n"));
                cdb->WRITE_TAPE_MARKS.WriteSetMarks = SETBITON;
                break;

            case TAPE_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == filemarks\n"));
                break;

            case TAPE_SHORT_FILEMARKS:
            case TAPE_LONG_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    ASSERT( CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapeWriteMarks()



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {

                DebugPrint((1,
                            "SonyAIT.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS));
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)Srb->DataTransferLength;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {

        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;
        PMODE_DEVICE_CONFIG_PAGE_PLUS configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, only one type (either known or unknown) is returned.
        //

        mediaTypes->MediaInfoCount = 1;


        if ( LastError == TAPE_STATUS_SUCCESS ) {

            //
            // Determine the media type currently loaded.
            //

            mediaType = configInformation->ParameterListHeader.MediumType;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                        mediaType,
                        blockSize));

            switch (mediaType) {
                case 0:

                    //
                    // Cleaner, unknown, no media mounted...
                    //

                    currentMedia = 0;
                    break;

                case 0x02:
                case 0x03:
                case 0x04:
                case 0x06:
                case 0x08:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x55:

                    //
                    // qic media
                    //

                    currentMedia = QIC;
                    break;

                default:

                    DebugPrint((1,
                               "Tandqic.GetMediaTypes: Unknown type %x\n",
                               mediaType));

                    currentMedia = QIC;
                    break;
            }
        } else {
            currentMedia = 0;
        }

        //
        // fill in buffer based on spec. values
        // Only one type supported now.
        //

        for (i = 0; i < mediaTypes->MediaInfoCount; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = QicMedia[i];
            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (QicMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;


                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    configInformation->ParameterListBlock.DensityCode;

                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }

    }

    return TAPE_STATUS_SUCCESS;
}


static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"TANDBERG",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"MLR1",4) == 4) {
            return TDC_MLR1;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"MLR3",4) == 4) {
            return TDC_MLR1;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId," SLR5 4/8GB",11) == 11) {
            return TDC_4222;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId," SLR5 4GB",9) == 9) {
            return TDC_4200;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SLR100",6) == 6) {
            return TDC_MLR1;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"DEC     ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZK10",5) == 5) {
            return TDC_3800;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZK12",5) == 5) {
            return TDC_3800;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZK11",5) == 5) {
            return TDC_4200;
        }

    }

    return (ULONG)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\apitest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       apitest.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           apitest.c
 *
 *      Modified:       2/2/93.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <ctype.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"


#define TEST_ERROR  TRUE
#define SUCCESS     FALSE



//
// Function Prototypes
//

static BOOL GetINIFile( PUINT    API_Errors,
                        LPBOOL   Test_Unsupported_Features,
                        LPDWORD  Num_Test_Blocks
                      ) ;

static VOID HelpMenu ( VOID ) ;

static BOOL PerformTestInitRoutines( PUINT    API_Errors,
                                     LPBOOL   Test_Unsupported_Features,
                                     LPDWORD  Num_Test_Blocks
                                   ) ;

static VOID TerminateTest( VOID ) ;

static BOOL ValidSwitches( UINT  argc,
                           UCHAR *argv[],
                           UCHAR *sw_cmdline
                         ) ;




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           Main( )
 *
 *      Modified:       11/04/92.
 *
 *      Description:    1) Checks for valid test selection options
 *                      2) Opens tape device and performs initializations
 *                      3) Performs selected tests
 *                      4) Closes tape device and exits.
 *
 *      Notes:          -
 *
 *      Returns:        Standard executable return code to the OS.
 *
 *      Global Data:    gb_Feature_Errors
 *
**/


VOID __cdecl main( UINT  argc,
	            UCHAR *argv[]
                  )
{

   UINT   API_Errors = 0 ;
   BOOL   Test_Unsupported_Features = FALSE ;      // Set default to FALSE
   DWORD  Num_Test_Blocks = 10 ;                   // Set default to 10
   UCHAR  sw_cmdline[40] ;
   UINT   i ;

   // Check command line for valid switche options.

   if( ValidSwitches( argc,argv,sw_cmdline ) != SUCCESS ) {
      return ;
   }

   // Begin testing...


   // All Ok, so call test initializing routines, if errors exit test.

   if( PerformTestInitRoutines( &API_Errors,
                                &Test_Unsupported_Features,
                                &Num_Test_Blocks ) ) {        // 0 if successful.
      TerminateTest( ) ;
      return ;
   }


   for( i=0 ; i<strlen( sw_cmdline ) ; ++i ) {
      switch( sw_cmdline[i] ){

         case 'i'  :  API_Errors += GetTapeParametersAPITest( TRUE ) ;
                      PrintLine( '*', 60 ) ;
                      break ;

         case 't'  :  API_Errors += SetTapeParametersAPITest( TRUE ) ;
                      PrintLine( '*', 60 ) ;
                      break ;

         case 'p'  :  API_Errors += PrepareTapeAPITest( Test_Unsupported_Features ) ;
                      PrintLine( '*', 60 ) ;
                      break ;

         case 's'  :  if( TapeWriteEnabled( ) ) {

                         API_Errors += SetTapePositionAPITest( Test_Unsupported_Features,
                                                               Num_Test_Blocks
                                                          ) ;
                         PrintLine( '*', 60 ) ;

                      } else { TerminateTest( ) ;
                               return ;
                             }

                      break ;

         case 'g'  :  if( TapeWriteEnabled( ) ) {

                         API_Errors += GetTapePositionAPITest( Test_Unsupported_Features,
                                                            Num_Test_Blocks
                                                          ) ;
                         PrintLine( '*', 60 ) ;

                      } else { TerminateTest( ) ;
                               return ;
                             }

                      break ;

         case 'e'  :  if( TapeWriteEnabled( ) ) {

                         API_Errors += EraseTapeAPITest( Test_Unsupported_Features ) ;
                         PrintLine( '*', 60 ) ;

                      } else { TerminateTest( ) ;
                               return ;
                             }

                      break ;

         case 'c'  :  if( TapeWriteEnabled( ) ) {

                         API_Errors += CreateTapePartitionAPITest( Test_Unsupported_Features ) ;
                         PrintLine( '*', 60 ) ;

                      } else { TerminateTest( ) ;
                               return ;
                             }

                      break ;

         case 'w'  :  if( TapeWriteEnabled( ) ) {

                      API_Errors += WriteTapemarkAPITest( Test_Unsupported_Features,
                                                          Num_Test_Blocks
                                                        ) ;
                      PrintLine( '*', 60 ) ;

                      } else { TerminateTest( ) ;
                               return ;
                             }

                      break ;

         case 'v'  :  API_Errors += GetTapeStatusAPITest( ) ;
                      PrintLine( '*', 60 ) ;
                      break ;

         case '?'  :  break ;
      }
   }


   // Close the tape device.

   CloseTape( ) ;


   // Test is done.  Report status and exit.

   if( API_Errors ) {

      if( ( gb_Feature_Errors ) && ( Test_Unsupported_Features ) ) {

         printf( "\n\n\n ***  There were %d API errors encountered during the test  ***\n", API_Errors ) ;
         printf( " ***  %d of which were unsupported feature errors.          ***\n\n", gb_Feature_Errors ) ;
      }

      else printf( "\n\n\n *** There were %d API errors encountered during the test. ***\n\n",API_Errors ) ;

   } else printf( "\n\n\n *** There were no API errors encountered during the test. ***\n\n" ) ;

   printf( "\n\n\n- TEST COMPLETED -\n\n" ) ;



   return ;

}




/*********************************************************************
 *                 Setup and Output Functions                        *
 ********************************************************************/



/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           GetINIFile( )
 *
 *      Modified:       10/26/92.
 *
 *      Description:    Reads in the "apitest.ini" file and initializes the
 *                      global structures gb_Set_Drive_Info and
 *                      gb_Set_Media_Info accordingly.
 *                      accordingly.
 *
 *      Notes:          -
 *
 *      Returns:        SUCCESS if succesfull else TEST_ERROR.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Set_Drive_Info
 *                      gb_Set_Media_Info
 *                      gb_Drive_Info
 *                      gb_Media_Info
 *
**/


BOOL GetINIFile(
       PUINT    API_Errors,                  // IO - Error count
       LPBOOL   Test_Unsupported_Features,   // O  - Test  unsupported flag
       LPDWORD  Num_Test_Blocks              // O  - Number of test blocks
      ) {


  FILE  *fp ;
  UCHAR keyword[80] = "\0" ;
  UCHAR value[10] = "\0" ;
  DWORD status ;
  UINT  equal_pos ;
  UINT  i ;



   // Initialize the global structures by calling Get.  You must do this
   // before changing values from INI file because not all values in the
   // Drive and Media stuctures are covered in the INI file.
   // If error, exit.


   if( GetTapeParametersAPITest( FALSE ) ) {
      printf( "  ...occurred calling GetTapeParameters prior to reading in the INI file.\n\n" ) ;
      return TEST_ERROR ;
   }

   // Transfer over the info from the Get call into the Set_Info structure.

   gb_Set_Drive_Info.ECC            = gb_Drive_Info.ECC ;
   gb_Set_Drive_Info.Compression    = gb_Drive_Info.Compression ;
   gb_Set_Drive_Info.DataPadding    = gb_Drive_Info.DataPadding ;
   gb_Set_Drive_Info.ReportSetmarks = gb_Drive_Info.ReportSetmarks ;

   gb_Set_Media_Info.BlockSize = gb_Drive_Info.DefaultBlockSize ;


   // Check and make sure .INI file is in startup directory.

   if( ( fp = fopen( "apitest.ini","r" ) ) == NULL ) {

      fprintf( stderr, "\n\n*** MISSING 'APITEST.INI' FILE ***\n\n" ) ;
      return TEST_ERROR ;
   }


   // Now alter any desired information.

   printf( "Reading INI file...\n\n" ) ;

   while( !feof(fp) ){

      // read in one line of the INI file

      keyword[i] = i = 0 ;

      while( ( keyword[i] != '\n' ) && ( i < 79 ) ) {

         fscanf( fp, "%c", keyword+i ) ;
         keyword[i] = toupper( keyword[i] ) ;

         if ( keyword[i] != '\n' )
            ++ i ;
      }

      keyword[i] = '\0' ;

      // if a comment or a rtn, skip.

      if( ( keyword[0] != '@' ) && ( keyword[0] != '\0' ) ) {

         if( ( equal_pos = FindChar( keyword, '=' ) ) < 0 ) { // if no '=', error
            printf( "Error in INI file.\n" ) ;
            return TEST_ERROR ;
         }

         // Now break the line into a keyword and value field

         // First eliminate spaces (if any) between the '=' and the value

         i = equal_pos + 1 ;

         while( keyword[i] == ' ' )

            ++i ;

         sscanf( keyword + i , "%s" , value ) ;


         // Next eliminate spaces (if any) between the keyword and the '='

         i = equal_pos ;

         while( keyword[i-1] == ' ' )

            --i ;

         keyword[i] = '\0' ;


         // Find appropriate keyword and set values

         if( !strcmp( keyword, "BLOCK_SIZE" ) ) {

            if( SupportedFeature( TAPE_DRIVE_SET_BLOCK_SIZE ) )
               gb_Set_Media_Info.BlockSize = atol( value ) ;
         }
         if( !strcmp( keyword, "NUMBER_TEST_BLOCKS" ) )

            *Num_Test_Blocks = atol( value ) ;

         if( !strcmp( keyword, "ERROR_CORRECTION" ) )
            if( ( strcmp( value, "ENABLE" ) == 0 ) && ( SupportedFeature( TAPE_DRIVE_SET_ECC ) ) )
               gb_Set_Drive_Info.ECC = 1 ;
            else gb_Set_Drive_Info.ECC = 0 ;

         if( !strcmp( keyword, "COMPRESSION" ) )
            if( ( strcmp( value, "ENABLE" ) == 0 ) && ( SupportedFeature( TAPE_DRIVE_SET_COMPRESSION ) ) )
               gb_Set_Drive_Info.Compression =1 ;
            else gb_Set_Drive_Info.Compression = 0 ;

         if( !strcmp( keyword, "DATA_PADDING" ) )
            if( ( strcmp( value, "ENABLE" ) == 0 ) && ( SupportedFeature( TAPE_DRIVE_SET_PADDING ) ) )
               gb_Set_Drive_Info.DataPadding = 1 ;
            else gb_Set_Drive_Info.DataPadding = 0 ;

         if( !strcmp( keyword, "REPORT_SETMARKS" ) )
            if( ( strcmp( value, "ENABLE" ) ==0  ) && ( SupportedFeature( TAPE_DRIVE_SET_REPORT_SMKS ) ) )
               gb_Set_Drive_Info.ReportSetmarks = 1 ;
            else gb_Set_Drive_Info.ReportSetmarks = 0 ;

         if( !strcmp( keyword, "TEST_UNSUPPORTED_FEATURES" ) )
            if( strcmp( value, "ENABLE" ) == 0 )
               *Test_Unsupported_Features = 1 ;
            else *Test_Unsupported_Features = 0 ;


      }

   }

   fclose( fp ) ;

// Uncomment if need to see what INI file is reading in.

/*
   printf("BLOCK SIZE          = %ld\n",gb_Set_Media_Info.BlockSize);
   printf("NUMBER TEST BLOCKS  = %ld\n",*Num_Test_Blocks);

   printf("ECC                 = %s\n",(gb_Set_Drive_Info.ECC) ? "ENABLED" : "DISABLED");
   printf("COMPRESSION         = %s\n",(gb_Set_Drive_Info.Compression) ? "ENABLED" : "DISABLED");
   printf("DATA PADDING        = %s\n",(gb_Set_Drive_Info.DataPadding) ? "ENABLED" : "DISABLED");
   printf("REPORT SETMARKS     = %s\n",(gb_Set_Drive_Info.ReportSetmarks) ? "ENABLED" : "DISABLED");
   printf("TEST UNSUPPORTED\n") ;
   printf("FEATURES            = %s\n",(*Test_Unsupported_Features) ? "ENABLED" : "DISABLED");
*/


   // call SetTapeParameters(non-verbose) API to set info from INI file.
   // If erorr, exit.

   if( SetTapeParametersAPITest( FALSE ) ) {
      printf("  ...occurred calling SetTapeParameters after reading in the INI file.\n\n" ) ;
      return TEST_ERROR ;

   } else {  // Transfer back over the info into the gb_Info structure.

             gb_Drive_Info.ECC            = gb_Set_Drive_Info.ECC ;
             gb_Drive_Info.Compression    = gb_Set_Drive_Info.Compression ;
             gb_Drive_Info.DataPadding    = gb_Set_Drive_Info.DataPadding ;
             gb_Drive_Info.ReportSetmarks = gb_Set_Drive_Info.ReportSetmarks ;

             gb_Media_Info.BlockSize = gb_Set_Media_Info.BlockSize ;
          }


   return SUCCESS ;

}




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           HelpMenu( )
 *
 *      Modified:       8/10/92.
 *
 *      Description:    Displays switch options for the command line.
 *
 *      Notes:          -
 *
 *      Returns:        VOID.
 *
 *      Global Data:    -
 *
**/

VOID HelpMenu( VOID ){

   printf( "\n\n\n" ) ;
   printf( "              * TEST OPTIONS *\n\n\n" ) ;
   printf( "            Switch     Function\n\n" ) ;
   printf( "              i          Perform GetTapeParameters API Test.\n" ) ;
   printf( "              t          Perform SetTapeParameters API Test.\n" ) ;
   printf( "              c          Perform CreateTapePartition API Test.\n" ) ;
   printf( "              v          Perform GetTapeStatus API Test.\n" ) ;
   printf( "              p          Perform PrepareTape API Test.\n" );
   printf( "              s          Perform SetTapePosition API Test.\n" ) ;
   printf( "              g          Perform GetTapePosition API Test.\n" ) ;
   printf( "              w          Perform WriteFileMark API Test.\n" ) ;
   printf( "              e          Perform EraseTape API Test.\n" ) ;
   printf( "            (none)       Perform All Tests.\n\n" ) ;
   printf( "    Options may be entered in groups - i.e. '/psg' \n\n\n" ) ;

   return ;

}




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           PerformTestInitRoutines( )
 *
 *      Modified:       9/2/92.
 *
 *      Description:    Make proper tape and memory function calls to set up
 *                      fpr test.  If error return TEST_ERROR(TRUE)
 *                      otherwise SUCCESS (FALSE).
 *
 *      Notes:          -
 *
 *      Returns:        If successful SUCCESS (FALSE) else TEST_ERROR (TRUE)
 *
 *      Global Data:    -
 *
**/

BOOL PerformTestInitRoutines(
         PUINT    API_Errors,                    // IO - Error count
         LPBOOL   Test_Unsupported_Features,     // O  - Test  unsupported flag
         LPDWORD  Num_Test_Blocks                // O  - Number of test blocks
        ) {

   UCHAR  Tape_Device ;


   system( "cls" ) ;
   printf( "\nWindows NT Tape API Test V2.4  :  B. Rossi.\n" ) ;
   printf( "Copyright 1993 Conner Software Co.  All rights reserved.\n\n\n" ) ;

   fprintf( stderr, "\n\n*** Warning ***\n\n" ) ;
   fprintf( stderr, "This utility will destroy any data currently on tape.\n\n\n" ) ;

   // Open the Tape Device

   fprintf( stderr, "Enter Tape Device #(0-9):" ) ;

   Tape_Device = getch( ) ;

   fprintf( stderr, "%c\n\n", Tape_Device ) ;

   if( OpenTape( Tape_Device - '0' ) ) {
      return TEST_ERROR ;
   }

   // if device ok, read in the "apitest.ini" file and initialize INI structure

   if ( GetINIFile( API_Errors, Test_Unsupported_Features, Num_Test_Blocks ) )
      return TEST_ERROR ;


   printf( "\nBEGINNING TEST...\n\n\n" ) ;

   // print asterisk border

   PrintLine( '*', 60 ) ;

   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           TerminateTest( )
 *
 *      Modified:       8/10/92.
 *
 *      Description:    Prints test termination message and bell.
 *
 *      Notes:          -
 *
 *      Returns:        VOID.
 *
 *      Global Data:    -
 *
**/

VOID TerminateTest( VOID ){

   printf( "\n%cTest Terminated.\n\n",7 ) ;

   return ;

}





/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           ValidSwitches( )
 *
 *      Modified:       9/2/92.
 *
 *      Description:    Checks the O.S. command line for valid switch options.
 *
 *      Notes:          -
 *
 *      Returns:        If successful SUCCESS (FALSE) else TEST_ERROR (TRUE)
 *
 *      Global Data:    -
 *
**/

BOOL ValidSwitches( UINT  argc,          // I - # of args. on command line
		    UCHAR *argv[],       // I - command line args
		    UCHAR *sw_cmdline    // O - switch options portion of the
		   )                     //     command line
{
   char  options[]="/itcvpsgwe\0" ;   //  default order:  GetTapeParameters
   UINT  i = 0 ;                      //                  SetTapeParameters
                                      //                  CreateTapePartitition
   // check command line for options                      GetTapeStatus
                                      //                  PrepareTape
   // if just test command entered, assume all options.   SetTapePosition
                                      //                  GetTapePosition
   if( argc == 1 ) {                  //                  WriteTapemark
      strcpy( sw_cmdline,options ) ;  //                  EraseTape
   }

   else  // check what was entered for options...

   {  strcpy( sw_cmdline,argv[1] );

      // check to make sure switch selection was made.

      if( sw_cmdline[0] != '/' && sw_cmdline[0] != '?' ) {
         printf( "Unknown option '%s'.\n",sw_cmdline ) ;
         return TEST_ERROR ;
      }

      if( strlen( sw_cmdline ) == 1 && sw_cmdline[0] != '?' ) {    // Only '/'
         printf( "No options specified.\n" ) ;                     // entered
         return TEST_ERROR ;
      }

      // check if request for help menu.

      if( FindChar( sw_cmdline,'?' ) >= 0 ) {
         HelpMenu( ) ;
         return TEST_ERROR ;
      }

      // check that all options are valid, while converting any upper case
      // options to lower case

      sw_cmdline[i] = tolower( sw_cmdline[i] ) ;

      while( ( sw_cmdline[i] != '\0' ) && ( FindChar( options,sw_cmdline[i] ) >= 0 ) ) {
         ++i ;
         sw_cmdline[i] = tolower( sw_cmdline[i] ) ;
      }

      // check to see if we made it to end of option string (all were valid)

      if( sw_cmdline[i] != '\0' ) {
         printf( "Unknown option '%c'.\n",sw_cmdline[i] ) ;
         return TEST_ERROR ;
      }
   }

   return SUCCESS ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\erastape.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       erastape.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           erastape.c
 *
 *      Modified:       10/22/92.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <conio.h>
#include <malloc.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"





/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           EraseTapeAPITest( )
 *
 *      Modified:       10/22/92.
 *
 *      Description:    Tests the EraseTape API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API Errors.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Media_Info
 *
**/


UINT EraseTapeAPITest(
        BOOL Test_Unsupported_Features       // I - Test unsupported features
      )
{
   DWORD status ;
   UCHAR c ;
   UCHAR YorN_String[] = "yYnN\0" ;
   PVOID Readbuff;
   DWORD amount_read;


   DWORD API_Errors = 0 ;


   printf( "\nBeginning EraseTape API Test...\n\n\n" ) ;

   Readbuff = malloc( gb_Media_Info.BlockSize ) ;

//
   if ( SupportedFeature( TAPE_DRIVE_ERASE_SHORT ) || Test_Unsupported_Features ) {

      if( SupportedFeature( TAPE_DRIVE_ERASE_BOP_ONLY ) )

         RewindTape( ) ;

      printf( "\nAttempting short erase...\n\n" ) ;

      if( status = EraseTape( gb_Tape_Handle,
                              TAPE_ERASE_SHORT,
                              0
                            ) ) {

         DisplayDriverError( status ) ;
         ++API_Errors ;
      }
      else {  ReadTape( Readbuff,
                        gb_Media_Info.BlockSize,
                        &amount_read,
                        0 ) ;

              if( GetLastError( ) == ERROR_NO_DATA_DETECTED )

                 printf( "Short Erase Successful.\n\n\n" ) ;

              else { ++API_Errors ;
                     printf( "--- Error ---> End of data expected, not found.  Erase unsuccessful.\n\n" ) ;
                   }
           }

//
      if( SupportedFeature( TAPE_DRIVE_ERASE_IMMEDIATE ) || Test_Unsupported_Features ) {

         if( SupportedFeature( TAPE_DRIVE_ERASE_BOP_ONLY ) )

            RewindTape( ) ;

         printf( "\nAttempting short erase (immediate)...\n\n" ) ;

         if( status = EraseTape( gb_Tape_Handle,
                                 TAPE_ERASE_SHORT,
                                 1
                                ) ) {

            DisplayDriverError( status ) ;
            ++API_Errors ;
         }
         else {  // Loop until drive is ready to accept more commands.

                 status = 1 ;

                 while( status )
                    status = GetTapeStatus( gb_Tape_Handle ) ;

                 ReadTape( Readbuff,
                           gb_Media_Info.BlockSize,
                           &amount_read,
                           0 ) ;

                 if( GetLastError( ) == ERROR_NO_DATA_DETECTED )

                    printf( "Short Erase (Immediate) Successful.\n\n\n" ) ;

                 else { ++API_Errors ;
                        printf( "--- Error ---> End of data expected, not found.  Erase unsuccessful.\n\n" ) ;
                      }

              }

      }

   }

//
   if ( SupportedFeature( TAPE_DRIVE_ERASE_LONG ) || Test_Unsupported_Features ) {

      fprintf( stderr, "\nSure you wish to test LONG ERASE? (y/n):" ) ;

      c = 0 ;

      while( FindChar( YorN_String, c ) < 0 )

         c = getch( ) ;


      fprintf( stderr, "%c\n\n", c ) ;

      if( c== 'y' || c=='Y' ){

         if( SupportedFeature( TAPE_DRIVE_ERASE_BOP_ONLY ) )

            RewindTape( ) ;

         printf( "\nAttempting long erase...\n\n" ) ;

         if( status = EraseTape( gb_Tape_Handle,
                                 TAPE_ERASE_LONG,
                                 0
                               ) ) {

            DisplayDriverError( status ) ;
            ++API_Errors ;
         }
         else {  ReadTape( Readbuff,
                           gb_Media_Info.BlockSize,
                           &amount_read,
                           0 ) ;

                 if( GetLastError( ) == ERROR_NO_DATA_DETECTED )

                    printf( "Long Erase Successful.\n\n\n" ) ;

                 else { ++API_Errors ;
                        printf( "--- Error ---> End of data expected, not found.  Erase unsuccessful.\n\n" ) ;
                      }

              }

      }
//
      if ( SupportedFeature( TAPE_DRIVE_ERASE_IMMEDIATE ) || Test_Unsupported_Features ) {

         fprintf( stderr, "\nSure you wish to test LONG ERASE (immediate)? (y/n):" ) ;

         c = 0 ;

         while( FindChar( YorN_String, c ) < 0 )

            c = getch( ) ;


         fprintf( stderr, "%c\n\n", c ) ;

         if( c== 'y' || c=='Y' ){

            if( SupportedFeature( TAPE_DRIVE_ERASE_BOP_ONLY ) )

               RewindTape( ) ;

            printf( "\nAttempting long erase (immediate)...\n\n" ) ;

            if( status = EraseTape( gb_Tape_Handle,
                                    TAPE_ERASE_LONG,
                                    1
                                  ) ) {

               DisplayDriverError( status ) ;
               ++API_Errors ;
            }
            else {  // Loop until drive is ready to accept more commands.

                    status = 1 ;

                    while( status )
                       status = GetTapeStatus( gb_Tape_Handle ) ;

                    ReadTape( Readbuff,
                              gb_Media_Info.BlockSize,
                              &amount_read,
                              0 ) ;

                    if( GetLastError( ) == ERROR_NO_DATA_DETECTED )

                       printf( "Long Erase (Immediate) Successful.\n\n\n" ) ;

                    else { ++API_Errors ;
                           printf( "--- Error ---> End of data expected, not found.  Erase unsuccessful.\n\n" ) ;
                         }

                 }

         }

      }

   }


   printf( "\nEraseTape API Test completed.\n\n\n" ) ;

   free( Readbuff ) ;

   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\creatape.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       creatape.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           creatape.c
 *
 *      Modified:       12/14/92.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           CreateTapePartitionAPITest( )
 *
 *      Modified:       10/20/92.
 *
 *      Description:    Tests the CreateTapePartition API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API errors.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Drive_Info
 *
**/

#define INITIATOR_SIZE 10                       // 10Mb partition size.

UINT CreateTapePartitionAPITest(
        BOOL Test_Unsupported_Features          // I - Test unsupported flag
      )
{
   DWORD status ;
   DWORD API_Errors = 0 ;



   printf( "\nBeginning CreateTape API Test.\n\n\n" ) ;

   if( SupportedFeature( TAPE_DRIVE_FIXED ) || Test_Unsupported_Features ) {

      printf( "Testing TAPE_FIXED_PARTITIONS parameter.\n\n" );

      if( status = CreateTapePartition( gb_Tape_Handle,
                                        TAPE_FIXED_PARTITIONS,
                                        1,             // set partion mode
                                        0              // ingored
                                       ) ) {
         DisplayDriverError( status ) ;
         ++API_Errors ;
      } else {  printf( "Parameter Ok.  Tape sucessfully partitioned.\n\n" ) ;

                // Make the call again to get out of partition mode.

                if( status = CreateTapePartition( gb_Tape_Handle,
                                                  TAPE_FIXED_PARTITIONS,
                                                  0,     // exit partion mode
                                                  0      // ingored
                                                ) ) {
                   DisplayDriverError( status ) ;
                   ++API_Errors ;
                   printf( "  ...occurred attempting to get out of partition mode.\n\n" ) ;
                }
             }

   }

   if( SupportedFeature( TAPE_DRIVE_SELECT ) || Test_Unsupported_Features ) {

      printf( "Testing TAPE_SELECT_PARTITIONS parameter.\n\n" );

      if( status = CreateTapePartition( gb_Tape_Handle,
                                        TAPE_SELECT_PARTITIONS,
                                        gb_Drive_Info.MaximumPartitionCount,
                                        0                 // ingored
                                       ) ) {
         DisplayDriverError( status ) ;
         ++API_Errors ;
      } else printf( "Parameter Ok.  Tape sucessfully partitioned with %d partition(s).\n\n",
                                     gb_Drive_Info.MaximumPartitionCount ) ;

   }


   if( SupportedFeature( TAPE_DRIVE_INITIATOR ) || Test_Unsupported_Features ) {

      printf( "Testing TAPE_INITIATOR_PARTITIONS parameter.\n\n" );


      if( status = CreateTapePartition( gb_Tape_Handle,
                                        TAPE_INITIATOR_PARTITIONS,
                                        gb_Drive_Info.MaximumPartitionCount,
                                        INITIATOR_SIZE
                                       ) ) {
         DisplayDriverError( status ) ;
         ++API_Errors ;

      } else if( gb_Drive_Info.MaximumPartitionCount <= 1 )

                if( SupportedFeature( TAPE_DRIVE_TAPE_CAPACITY ) )

                   printf( "Parameter Ok.  Tape successfully partitioned\n                with 1 partition of size %ld%ld bytes.\n\n",
                                      gb_Media_Info.Capacity.HighPart, gb_Media_Info.Capacity.LowPart ) ;

                else printf( "Parameter OK.  Tape successfully partitioned.\n\n" ) ;

             else   printf( "Parameter Ok.  Tape successfully partitioned\n               with %d partition(s), the first of size %d Mb.\n\n",
                                       gb_Drive_Info.MaximumPartitionCount, INITIATOR_SIZE ) ;


   }

   printf( "\nCreateTape API Test Completed.\n\n\n" ) ;

   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\getparms.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       getparms.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           getparms.c
 *
 *      Modified:       2/2/93.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"



/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           DisplayFeatures ;
 *
 *      Modified:       10/2/92.
 *
 *      Description:    Displays device feature information.
 *
 *      Notes:          -
 *
 *      Returns:        -
 *
 *      Global Data:    gb_Drive_Info.Features
 *
**/

VOID DisplayFeatures( BOOL Show_Supported     // I - Display supported or
                    )                         //     unsupported features.
{
   UINT  i ;
   ULONG Feature ;
   ULONG mask ;


   mask = 0x01 ;

   for ( i=0; i<23; ++i ) {           // First 20 features (some bits skipped)

      if( Show_Supported )
         Feature =  mask & gb_Drive_Info.FeaturesLow ;   // Perform complement
      else Feature =  mask & ( ~gb_Drive_Info.FeaturesLow ) ;


      switch( Feature ) {


         case TAPE_DRIVE_FIXED             :   printf( "- Creation of fixed data partitions.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SELECT            :   printf( "- Creation of select data partitions.\n" ) ;
                                               break ;
         case TAPE_DRIVE_INITIATOR         :   printf( "- Creation of initiator-defined partitions.\n" ) ;
                                               break ;
         case TAPE_DRIVE_ERASE_SHORT       :   printf( "- Short erase operation.\n" ) ;
                                               break ;
         case TAPE_DRIVE_ERASE_LONG        :   printf( "- Long erase operation.\n" ) ;
                                               break ;
         case TAPE_DRIVE_ERASE_BOP_ONLY    :   printf( "- Erase from beginning-of-partition only.\n" ) ;
                                               break ;
         case TAPE_DRIVE_ERASE_IMMEDIATE   :   printf( "- Immediate tape erase command.\n" ) ;
                                               break ;
         case TAPE_DRIVE_TAPE_CAPACITY     :   printf( "- Returning the maximum capacity of the tape.\n" ) ;
                                               break ;
         case TAPE_DRIVE_TAPE_REMAINING    :   printf( "- Returning the remaining capacity of the tape.\n" ) ;
                                               break ;
         case TAPE_DRIVE_FIXED_BLOCK       :   printf( "- Fixed length block mode.\n" ) ;
                                               break ;
         case TAPE_DRIVE_VARIABLE_BLOCK    :   printf( "- Variable length block mode.\n" ) ;
                                               break ;
         case TAPE_DRIVE_WRITE_PROTECT     :   printf( "- Returning tape protection write enabled/disabled.\n" ) ;
                                               break ;
         case TAPE_DRIVE_EOT_WZ_SIZE       :   printf( "- Returning the size of the end of tape warning zone.\n" ) ;
                                               break ;
         case TAPE_DRIVE_ECC               :   printf( "- Hardware error correction.\n" ) ;
                                               break ;
         case TAPE_DRIVE_COMPRESSION       :   printf( "- Hardware data compression.\n" ) ;
                                               break ;
         case TAPE_DRIVE_PADDING           :   printf( "- Data padding.\n" ) ;
                                               break ;
         case TAPE_DRIVE_REPORT_SMKS       :   printf( "- Reporting setmarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_GET_ABSOLUTE_BLK  :   printf( "- Returning the current device specific block address.\n" ) ;
                                               break ;
         case TAPE_DRIVE_GET_LOGICAL_BLK   :   printf( "- Returning the current logical block address and partition.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SET_EOT_WZ_SIZE   :   printf( "- Setting the size of the end of tape warning zone.\n" ) ;
                                               break ;

      }

      mask <<= 1 ;  // shift bit for next feature on next pass

   }


   // If adding adt'l feature tests , put them in this section.

   mask = 0x01 ;

   for ( i=0; i<31; ++i ) {            // Last 31 features

      if( Show_Supported )
         Feature =  mask & gb_Drive_Info.FeaturesHigh ;   // Perform complement
      else Feature =  mask & ( ~gb_Drive_Info.FeaturesHigh ) ;


      switch( Feature | TAPE_DRIVE_HIGH_FEATURES ) {


         case TAPE_DRIVE_LOAD_UNLOAD       :   printf( "- Enabling and disabling the device for further operation(s).\n" ) ;
                                               break ;
         case TAPE_DRIVE_TENSION           :   printf( "- Tensioning the tape.\n" ) ;
                                               break ;
         case TAPE_DRIVE_LOCK_UNLOCK       :   printf( "- Enabling/disabling removal of the tape from the device.\n" ) ;
                                               break ;
         case TAPE_DRIVE_REWIND_IMMEDIATE  :   printf( "- Immediate tape rewind command.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SET_BLOCK_SIZE    :   printf( "- Setting the size of a fixed length logical block or setting variable-\n  length block mode.\n" ) ;
                                               break ;
         case TAPE_DRIVE_LOAD_UNLD_IMMED   :   printf( "- Immediate tape load/unload command.\n" ) ;
                                               break ;
         case TAPE_DRIVE_TENSION_IMMED     :   printf( "- Immediate tape tension command.\n" ) ;
                                               break ;
         case TAPE_DRIVE_LOCK_UNLK_IMMED   :   printf( "- Immediate tape lock/unlock command.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SET_ECC           :   printf( "- Enabling/disabling hardware error correction.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SET_COMPRESSION   :   printf( "- Enabling/disabling hardware data compression.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SET_PADDING       :   printf( "- Enabling/disabling data padding.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SET_REPORT_SMKS   :   printf( "- Enabling/disabling reporting of setmarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_ABSOLUTE_BLK      :   printf( "- Positioning to a device specific block address.\n" ) ;
                                               break ;
         case TAPE_DRIVE_ABS_BLK_IMMED     :   printf( "- Immediate positioning to a device specific block address.\n" ) ;
                                               break ;
         case TAPE_DRIVE_LOGICAL_BLK       :   printf( "- Positioning to a logical block address in a partition.\n" ) ;
                                               break ;
         case TAPE_DRIVE_LOG_BLK_IMMED     :   printf( "- Immediate positioning to a logical block address in a partition.\n" ) ;
                                               break ;
         case TAPE_DRIVE_END_OF_DATA       :   printf( "- Positioning to the end-of-data in a partition.\n" ) ;
                                               break ;
         case TAPE_DRIVE_RELATIVE_BLKS     :   printf( "- Positioning forward/backward a specified number of blocks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_FILEMARKS         :   printf( "- Positioning forward/backward a specified number of filemarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SEQUENTIAL_FMKS   :   printf( "- Positioning forward/backward to the first occurrence of a specified\n  number of consecutive filemarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SETMARKS          :   printf( "- Positioning forward/backward a specified number of setmarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SEQUENTIAL_SMKS   :   printf( "- Positioning forward/backward to the first occurrence of a specified\n  number of consecutive setmarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_REVERSE_POSITION  :   printf( "- Positioning over blocks, filemarks, or setmarks in the reverse direction.\n" ) ;
                                               break ;
         case TAPE_DRIVE_SPACE_IMMEDIATE   :   printf( "- Immediate spacing (position) command.\n" ) ;
                                               break ;
         case TAPE_DRIVE_WRITE_SETMARKS    :   printf( "- Writing setmarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_WRITE_FILEMARKS   :   printf( "- Writing filemarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_WRITE_SHORT_FMKS  :   printf( "- Writing short filemarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_WRITE_LONG_FMKS   :   printf( "- Writing long filemarks.\n" ) ;
                                               break ;
         case TAPE_DRIVE_WRITE_MARK_IMMED  :   printf( "- Immediate write tapemark command.\n" ) ;
                                               break ;
         case TAPE_DRIVE_FORMAT            :   printf( "- Formatting of the tape.\n" ) ;
                                               break ;
         case TAPE_DRIVE_FORMAT_IMMEDIATE  :   printf( "- Immediate tape format command.\n" ) ;
                                               break ;

      }

      mask <<= 1 ;   // shift bit for  next feature on next pass

   }

   return ;

}




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           GetTapeParametersAPITest( )
 *
 *      Modified:       10/2/92.
 *
 *      Description:    Tests the GetTapeParameters API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API errors.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Drive_Info
 *                      gb_Media_Info
 *
**/


#define SUPPORTED   TRUE
#define UNSUPPORTED FALSE


UINT GetTapeParametersAPITest( BOOL Verbose       // I - Verbose output or not
                             )
{
   DWORD status ;
   DWORD StructSize ;
   DWORD API_Errors = 0 ;



   if( Verbose )

      printf( "Beginning GetTapeParameters API Test...\n\n\n" ) ;

   StructSize = sizeof( TAPE_GET_DRIVE_PARAMETERS ) ;

   status = GetTapeParameters( gb_Tape_Handle,
                               GET_TAPE_DRIVE_INFORMATION,
                               &StructSize,
                               &gb_Drive_Info
                             ) ;

   // Retry if Bus Reset Error.

   if( status == ERROR_BUS_RESET ) {
      status = GetTapeParameters( gb_Tape_Handle,
                                  GET_TAPE_DRIVE_INFORMATION,
                                  &StructSize,
                                  &gb_Drive_Info
                                ) ;
   }

   if( status ) {
      DisplayDriverError( status ) ;
      printf("  ...occurred using GET_TAPE_DRIVE_INFORMATION parameter.\n\n" ) ;
      ++API_Errors ;
   }

   // Verbose or not make sure high bit is masked off.  On non-verbose
   // (initial) call display the warning and increment warning count.

   if( gb_Drive_Info.FeaturesHigh & TAPE_DRIVE_HIGH_FEATURES ) {

      gb_Drive_Info.FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES ;

      if( !Verbose ) {

         printf( "--- WARNING ---> High bit of FeaturesHigh member was not masked off in driver.\n" ) ;
         printf( "%c                 Masking off for purpose of test....\n\n" ,7 ) ;
      }
   }

   if( Verbose ) {

      printf( "Tape Drive Parameters:\n\n" ) ;
      printf( "\t\tError Correction         = %s\n", ( gb_Drive_Info.ECC ) ? "Enabled" : "Disabled" ) ;
      printf( "\t\tData Compression         = %s\n", ( gb_Drive_Info.Compression ) ? "Enabled" : "Disabled" ) ;
      printf( "\t\tData Padding             = %s\n", ( gb_Drive_Info.DataPadding ) ? "Enabled" : "Disabled" ) ;
      printf( "\t\tSetmark Reporting        = %s\n", ( gb_Drive_Info.ReportSetmarks ) ? "Enabled" : "Disabled" ) ;
      printf( "\t\tDefault Block Size       = %ld %s\n", gb_Drive_Info.DefaultBlockSize, "Bytes" ) ;
      printf( "\t\tMaximum Block Size       = %ld %s\n", gb_Drive_Info.MaximumBlockSize, "Bytes" ) ;
      printf( "\t\tMinimum Block Size       = %ld %s\n", gb_Drive_Info.MinimumBlockSize, "Byte(s)" ) ;
      printf( "\t\tMaximum Partitions       = %ld\n", gb_Drive_Info.MaximumPartitionCount ) ;

      if ( SupportedFeature( TAPE_DRIVE_EOT_WZ_SIZE ) )
         printf( "\t\tEOT Warning Zone Size    = %ld %s\n", gb_Drive_Info.EOTWarningZoneSize, "Bytes" ) ;
   }


   StructSize = sizeof( TAPE_GET_MEDIA_PARAMETERS ) ;

   if( status = GetTapeParameters( gb_Tape_Handle,
                                   GET_TAPE_MEDIA_INFORMATION,
                                   &StructSize,
                                   &gb_Media_Info
                                 ) ) {

      DisplayDriverError( status ) ;
      printf("  ...occurred using GET_TAPE_MEDIA_INFORMATION parameter.\n\n" ) ;
      ++API_Errors ;
   }

   if( Verbose ) {

      printf( "\nTape Media Parameters:\n\n" ) ;

      if( SupportedFeature( TAPE_DRIVE_TAPE_CAPACITY ) )

         printf( "\t\tTotal Tape Size          = %ld%ld Bytes\n", gb_Media_Info.Capacity.HighPart,
                                                                  gb_Media_Info.Capacity.LowPart ) ;
      if( SupportedFeature( TAPE_DRIVE_TAPE_REMAINING ) )

         printf( "\t\tTotal Free Space         = %ld%ld Bytes\n", gb_Media_Info.Remaining.HighPart,
                                                                  gb_Media_Info.Remaining.LowPart ) ;

      printf( "\t\tTape Block Size          = %ld Bytes\n", gb_Media_Info.BlockSize ) ;
      printf( "\t\tNumber Tape Partitions   = %ld\n", gb_Media_Info.PartitionCount ) ;

      if( SupportedFeature( TAPE_DRIVE_WRITE_PROTECT ) )

         printf( "\t\tTape Write Protected     = %s\n\n", ( gb_Media_Info.WriteProtected ) ? "TRUE" : "FALSE" ) ;


      // Display features.


      printf( "\nDevice Features Supported:\n\n" ) ;

      DisplayFeatures( SUPPORTED ) ;

      printf( "\nDevice Features Not Supported:\n\n" ) ;

      DisplayFeatures( UNSUPPORTED ) ;

      printf( "\n\nGetTapeParameters API Test Completed.\n\n\n" ) ;

   }



   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\globals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       globals.h
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           Globals.h
 *
 *      Modified:       10/26/92.
 *
 *      Description:    Header file for the Windows NT Tape API tests.
 *
 *      $LOG$
**/


#ifndef globals

#define globals

// Function prototypes


UINT CreateTapePartitionAPITest( BOOL Test_Unsupported_Features ) ;

UINT EraseTapeAPITest( BOOL Test_Unsupported_Features ) ;

UINT GetTapeParametersAPITest( BOOL Verbose
                             ) ;

UINT GetTapePositionAPITest( BOOL  Test_Unsupported_Features,
                             DWORD Num_Test_Blocks
                           ) ;

UINT GetTapeStatusAPITest( VOID ) ;

UINT PrepareTapeAPITest( BOOL Test_Unsupported_Features ) ;

UINT SetTapeParametersAPITest( BOOL Verbose
                             ) ;

UINT SetTapePositionAPITest( BOOL  Test_Unsupported_Features,
                             DWORD Num_Test_Blocks
                           ) ;

UINT WriteTapemarkAPITest( BOOL Test_Unsupported_Features,
                           DWORD Num_Test_Blocks
                         ) ;


INT  FindChar( UCHAR str[],
               UCHAR c
             ) ;

VOID PrintLine( UCHAR c,
                UINT Length
              ) ;

BOOL TapeWriteEnabled( VOID ) ;

VOID WriteBlocks( UINT  Num_Blocks,
                  DWORD Block_Size
                ) ;




//   Global Variable Declarations


extern UINT  gb_API_Errors ;

extern DWORD gb_Num_Test_Blocks ;

extern BOOL  gb_Test_Unsupported_Features ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\preptape.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       preptape.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           preptape.c
 *
 *      Modified:       12/21/92.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"


static UINT RunUnloadTests( BOOL Test_Unsupported_Features,
                            UINT Immed
                          ) ;



/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           RunUnloadTests( )
 *
 *      Modified:       9/4/92.
 *
 *      Description:    Performs overlapping standard/IMMED PrepareTape API
 *                      tests.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API errors.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


UINT RunUnloadTests(
        BOOL Test_Unsupported_Features,         // I - Test unsupported flag
        UINT immediate                          // I - Immediate or standard
      )

{
   DWORD status ;
   UCHAR YorN_String[] = "yYnN\0" ;
   UCHAR c ;
   DWORD API_Errors = 0 ;
   UINT  Feature ;


//
   if( immediate )

      Feature = TAPE_DRIVE_LOAD_UNLD_IMMED ;

   else Feature = TAPE_DRIVE_LOAD_UNLOAD ;


   if( SupportedFeature( Feature ) || Test_Unsupported_Features ) {

      printf( "\nAttempting tape unload...\n" ) ;

      if( status = PrepareTape( gb_Tape_Handle,
                                TAPE_UNLOAD,
                                (BOOLEAN)immediate
                              ) ) {

         DisplayDriverError( status ) ;
         ++API_Errors ;
      }
      else { fprintf( stderr, "\nRe-insert tape (if necessary) and press any key to continue..." ) ;

             c = getch( ) ;

             fprintf( stderr, "\n\n" ) ;

             // load tape in case drive doesn't actually eject tape.

             if( status = PrepareTape( gb_Tape_Handle,
                                       TAPE_LOAD,
                                       0
                                     ) ) {

                if( ( status == ERROR_NO_MEDIA_IN_DRIVE ) || ( status == ERROR_NOT_READY ) )

                   fprintf( stderr, " * Drive waiting to load or in process of loading tape...\n\n" ) ;

                     // Tape is back in drive, so media changed error should be returned, else
                     // we have a real error.

                else if( status != ERROR_MEDIA_CHANGED )

                        { DisplayDriverError( status ) ;
                          printf("  ...occurred using TAPE_LOAD parameter.\n\n" ) ;
                          ++API_Errors ;
                        }

             }

             // Wait until drive is ready to continue test.

             status = 1 ;

             while( status )
                status = GetTapeStatus( gb_Tape_Handle ) ;

             printf( "\nTape unload Successful.\n\n" ) ;

           }
   }

//
   if( SupportedFeature( Feature ) || Test_Unsupported_Features ) {

      printf( "\nAttempting tape load...\n" ) ;

      if( status = PrepareTape( gb_Tape_Handle,
                                TAPE_LOAD,
                                (BOOLEAN)immediate
                              ) ) {

         DisplayDriverError( status ) ;
         ++API_Errors ;
      }

      else { // Wait until drive is ready to continue test.

             status = 1 ;

             while( status )
                status = GetTapeStatus( gb_Tape_Handle ) ;

             printf( "\nTape load Successful.\n\n" ) ;

           }

   }


//
   if( immediate )

      Feature = TAPE_DRIVE_TENSION_IMMED ;

   else Feature = TAPE_DRIVE_TENSION ;


   if( SupportedFeature( Feature ) || Test_Unsupported_Features ) {

      fprintf( stderr, "\nSure you wish to test TAPE TENSION? (y/n):" ) ;

      c = 0 ;

      while( FindChar( YorN_String, c ) < 0 )

         c = getch( ) ;


      fprintf( stderr, "%c\n\n", c ) ;

      if( c== 'y' || c=='Y' ){


         printf( "\nAttempting to tension tape...\n" ) ;

         if( status = PrepareTape( gb_Tape_Handle,
                                   TAPE_TENSION,
                                   (BOOLEAN)immediate
                                 ) ) {

            DisplayDriverError( status ) ;
            ++API_Errors ;
         }
         else { // Wait until drive is ready to continue test.

                status = 1 ;

                while( status )
                   status = GetTapeStatus( gb_Tape_Handle ) ;

                printf( "\nTape tension Successful.\n\n" ) ;

              }

      }

   }

//
   if( immediate )

      Feature = TAPE_DRIVE_LOCK_UNLK_IMMED ;

   else Feature = TAPE_DRIVE_LOCK_UNLOCK ;


   if( SupportedFeature( Feature ) || Test_Unsupported_Features ) {

      printf( "Beginning tape lock/unlock tests...\n\n\n" ) ;

      printf( "Attempting to lock tape...\n\n" ) ;

      if( status = PrepareTape( gb_Tape_Handle,
                                TAPE_LOCK,
                                (BOOLEAN)immediate
                              ) ) {

         DisplayDriverError( status ) ;
         ++API_Errors ;
      }
      else printf( "Tape lock Successful.\n\n" ) ;


      printf( "\nAttempting to unlock tape...\n\n" ) ;

      if( status = PrepareTape( gb_Tape_Handle,
                                TAPE_UNLOCK,
                                (BOOLEAN)immediate
                              ) ) {

         DisplayDriverError( status ) ;
         ++API_Errors ;
      }
      else printf( "Tape unlock Successful.\n\n" ) ;
   }


   return API_Errors ;

}



/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           PrepareTapeAPITest( )
 *
 *      Modified:       12/10/92.
 *
 *      Description:    Tests the PrepareTape API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API errors.
 *
 *      Global Data:    -
 *
**/


UINT PrepareTapeAPITest(
        BOOL Test_Unsupported_Features         // I - Test unsupported flag
      )
{
   DWORD status ;
   DWORD API_Errors = 0 ;


   printf( "Beginning PrepareTape API Test...\n\n\n" ) ;

   printf( "Beginning standard PrepareTape tests...\n\n" ) ;

   API_Errors += RunUnloadTests( Test_Unsupported_Features, 0 ) ;

   printf( "\nStandard PrepareTape tests completed.\n\n\n\n" ) ;

   printf( "Beginning IMMEDiate PrepareTape tests...\n\n" ) ;

   API_Errors += RunUnloadTests( Test_Unsupported_Features, 1 ) ;

   printf( "\nIMMEDiate PrepareTape tests completed.\n\n\n" ) ;


   printf( "\n\nPrepareTape API Test Completed.\n\n\n" ) ;


   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\getpos.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       getpos.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           getpos.c
 *
 *      Modified:       11/24/92.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           GetTapePositionAPITest( )
 *
 *      Modified:       10/23/92.
 *
 *      Description:    Tests the GetTapePosition API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API errors.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Media_Info
 *
**/


UINT GetTapePositionAPITest(
        BOOL  Test_Unsupported_Features,      // I - Test unsupported flag
        DWORD Num_Test_Blocks                 // I - Number of test blocks
      )
{

   DWORD status ;
   DWORD Offset_Low_ABS ;
   DWORD Offset_High_ABS ;
   DWORD Offset_Low_LOG ;
   DWORD Offset_High_LOG ;
   DWORD Offset_Low ;
   DWORD Offset_High ;
   DWORD Partition =0 ;       // use 0 for this test.
   UINT  i ;

   DWORD API_Errors = 0 ;


   printf( "Beginning GetTapePosition API Test.\n\n" ) ;

   // Rewind, and write data to the device for test.

   RewindTape( ) ;

   // write NUM blocks of data followed by a filemark to flush tape buffer

   WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;


   // Now, get initial ABS and LOG positions.

   if( SupportedFeature( TAPE_DRIVE_GET_ABSOLUTE_BLK ) )

      if( status = GetTapePosition( gb_Tape_Handle,
                                    TAPE_ABSOLUTE_POSITION,
                                    &Partition,
                                    &Offset_Low_ABS,
                                    &Offset_High_ABS ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in GetTapePosition API using TAPE_ABSOLUTE_POSITION parameter.\n\n" ) ;
         ++API_Errors ;
      }

   if( SupportedFeature( TAPE_DRIVE_GET_LOGICAL_BLK ) )

      if( status = GetTapePosition( gb_Tape_Handle,
                                    TAPE_LOGICAL_POSITION,
                                    &Partition,
                                    &Offset_Low_LOG,
                                    &Offset_High_LOG ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in GetTapePosition API using TAPE_LOGICAL_POSITION parameter.\n\n" ) ;
         ++API_Errors ;
      }


   // Don't check for return error, because routine will find which Fmark
   // the drive supports.  Used only to flush buffer.

   i = WriteTapeFMK( ) ;
   printf( "\n" ) ;



   // Position tape to end of last block of data


   if( SupportedFeature( TAPE_DRIVE_ABSOLUTE_BLK ) ) {

      RewindTape( ) ;

      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_SPACE_RELATIVE_BLOCKS,
                                    Partition,
                                    Num_Test_Blocks,
                                    0,
                                    0 ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_SPACE_RELATIVE_BLOCKS parameter.\n\n" ) ;
         ++API_Errors ;

      }

   }

   // Now get the tape positions for ABS and LOG and check results.

   if( SupportedFeature( TAPE_DRIVE_GET_ABSOLUTE_BLK ) || Test_Unsupported_Features ) {

      printf( "\nTesting TAPE_ABSOLUTE_POSITION parameter.\n\n" ) ;


      if( status = GetTapePosition( gb_Tape_Handle,
                                    TAPE_ABSOLUTE_POSITION,
                                    &Partition,
                                    &Offset_Low,
                                    &Offset_High ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in GetTapePosition API using TAPE_ABSOLUTE_POSITION parameter.\n\n" ) ;
         ++API_Errors ;
      }
      else if( ( Offset_Low_ABS != Offset_Low ) || ( Offset_High_ABS != Offset_High ) ) {

              printf( "--- Error ---> Incorrect location returned.\n\n " ) ;
              ++API_Errors ;
           }
           else printf( "Parameter Ok.\n\n\n" ) ;
   }


//
   if( SupportedFeature( TAPE_DRIVE_GET_LOGICAL_BLK ) || Test_Unsupported_Features ) {

      printf( "Testing TAPE_LOGICAL_BLOCK parameter.\n\n" ) ;

      // Use the same position that was set by SetTapePosition above.

      if( status = GetTapePosition( gb_Tape_Handle,
                                    TAPE_LOGICAL_POSITION,
                                    &Partition,
                                    &Offset_Low,
                                    &Offset_High ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in GetTapePosition API using TAPE_LOGICAL_POSITION parameter.\n\n" ) ;
         ++API_Errors ;
      }
      else if( ( Offset_Low_LOG != Offset_Low ) || ( Offset_High_LOG != Offset_High ) ) {

              printf( "--- Error ---> Incorrect location returned.\n\n " ) ;
              ++API_Errors ;
           }
           else printf( "Parameter Ok.\n\n\n" ) ;

   }


   printf( "GetTapePosition API Test Completed.\n\n\n" ) ;


   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\getstats.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       getstats.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           getstats.c
 *
 *      Modified:       10/28/92.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           GetTapeStatusAPITest( )
 *
 *      Modified:       10/20/92.
 *
 *      Description:    Tests the GetTapeStatus API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API errors.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


UINT GetTapeStatusAPITest( VOID )
{

   DWORD status ;
   DWORD API_Errors = 0 ;


   // All we can do is make the call.  Aside from ejecting the tape from the
   // drive, the only immediate call guaranteed across the board is the
   // REWIND_IMMED, and not all drives will report status as busy.  Therefore
   // no sure way check status as busy in a standard operational mode.

   printf( "Beginning GetTapeStatus API Test...\n\n" ) ;

   if( status = GetTapeStatus( gb_Tape_Handle ) ) {

      DisplayDriverError( status ) ;
      ++API_Errors ;
   }

   printf( "GetTapeStatus API Test completed.\n\n\n" ) ;


   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\setparms.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       setparms.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           setparms.c
 *
 *      Modified:       2/2/93.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           SetTapeParametersAPITest( )
 *
 *      Modified:       10/20/92.
 *
 *      Description:    Tests the SetTapeParameters API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API Errors.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Drive_Info
 *                      gb_Media_Info
 *
**/


UINT SetTapeParametersAPITest( BOOL Verbose     // I - Verbose output or not
                             )
{
   DWORD status ;
   DWORD API_Errors = 0 ;


   if( Verbose )
      printf( "Beginning SetTapeParameters API Test...\n\n" ) ;

   // if media setting is supported, set the blocksize

   if( SupportedFeature( TAPE_DRIVE_SET_BLOCK_SIZE ) )

      if( status = SetTapeParameters( gb_Tape_Handle,
                                      SET_TAPE_MEDIA_INFORMATION,
                                      &gb_Set_Media_Info
                                    ) ) {

         DisplayDriverError( status ) ;
         printf("  ...occurred using SET_TAPE_MEDIA_INFORMATION parameter.\n\n" ) ;
         ++API_Errors ;
      }


   // If at least one drive feature is supported, make the call.

   if( SupportedFeature( TAPE_DRIVE_SET_ECC ) ||
       SupportedFeature( TAPE_DRIVE_SET_COMPRESSION ) ||
       SupportedFeature( TAPE_DRIVE_SET_PADDING ) ||
       SupportedFeature( TAPE_DRIVE_SET_REPORT_SMKS ) ||
       SupportedFeature( TAPE_DRIVE_SET_EOT_WZ_SIZE ) )

      if( status = SetTapeParameters( gb_Tape_Handle,
                                      SET_TAPE_DRIVE_INFORMATION,
                                      &gb_Set_Drive_Info
                                    ) ) {

         DisplayDriverError( status ) ;
         printf("  ...occurred using SET_TAPE_DRIVE_INFORMATION parameter.\n\n" ) ;
         ++API_Errors ;
      }


   if( Verbose )
      printf( "SetTapeParameters API Test Completed.\n\n\n" ) ;

   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\setpos.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       setpos.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           setpos.c
 *
 *      Modified:       10/22/92.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <malloc.h>
#include <conio.h>
#include <string.h>
#include "windows.h"
#include "tapelib.h"
#include "globals.h"



/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           SetTapePositionAPITest( )
 *
 *      Modified:       10/26/92.
 *
 *      Description:    Tests the SetTapePosition API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API errors.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Media_Info
 *
**/


#define NUM_TAPE_MARKS  3

UINT SetTapePositionAPITest(
        BOOL  Test_Unsupported_Features,     // I - Test unsupported flag
        DWORD Num_Test_Blocks                // I - Number of test blocks
      )
{

   DWORD ABS_Low ;
   DWORD ABS_High ;
   DWORD LOG_Low ;
   DWORD LOG_High ;
   DWORD EOD_Low ;
   DWORD EOD_High ;
   DWORD status ;
   DWORD Offset_Low ;
   DWORD Offset_High ;
   DWORD Offset_Low2 ;
   DWORD Offset_High2 ;
   DWORD Partition ;

   PVOID Readbuff;
   DWORD amount_read;
   UINT  i,j ;

   DWORD API_Errors = 0 ;


   printf( "\nBeginning SetTapePosition API Test.\n\n" ) ;

   Readbuff = malloc( gb_Media_Info.BlockSize ) ;

// ABSOLUTE TESTING


   RewindTape( ) ;

   // Write test data to tape

   WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;


   // Get the Absolute offsets at last data block position if supported.

   if( SupportedFeature( TAPE_DRIVE_GET_ABSOLUTE_BLK ) )

      if( status = GetTapePosition( gb_Tape_Handle,
                                    TAPE_ABSOLUTE_POSITION,                                    &Partition,
                                    &ABS_Low,
                                    &ABS_High
                                   ) ) {
         DisplayDriverError( status ) ;
         printf( "  ...occurred in GetTapePosition API using TAPE_ABSOLUTE_POSITION parameter.\n\n" ) ;
        ++API_Errors ;
      }

   // Try and write filemark.  If not supported, don't report error because
   // test will be skipped later anyway.

   j = WriteTapeFMK( ) ;

   // Try and write a NUM_TAPE_MARKS-1 more filemarks to tape.

   for( i=0; i<(NUM_TAPE_MARKS-1); ++i )

      j = WriteTapeFMK( ) ;


//

   // Test the standard rewind.

   printf( "\nTesting TAPE_REWIND parameter.\n\n" ) ;

   if( status = SetTapePosition( gb_Tape_Handle,
                                 TAPE_REWIND,
                                 0,
                                 0,
                                 0,
                                 0 ) ) {

      DisplayDriverError( status ) ;
      printf( "  ...occurred in SetTapePosition API using TAPE_REWIND parameter.\n\n" ) ;
      ++API_Errors ;

   } else printf( "Parameter Ok.\n\n\n" ) ;



//
   if( SupportedFeature( TAPE_DRIVE_ABSOLUTE_BLK ) || Test_Unsupported_Features ) {

      // Set up test offset for Absolute tests.

      Offset_Low  = ABS_Low  ;
      Offset_High = ABS_High ;


      printf( "Testing TAPE_ABSOLUTE_BLOCK parameter.\n\n" ) ;


      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_ABSOLUTE_BLOCK,
                                    Partition,
                                    Offset_Low,
                                    Offset_High,
                                    0 ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_ABSOLUTE_BLOCK parameter.\n\n" ) ;
         ++API_Errors ;

             // If Set ok, check results with Get.

      }
      else if( status = GetTapePosition( gb_Tape_Handle,
                                         TAPE_ABSOLUTE_POSITION,
                                         &Partition,
                                         &Offset_Low2,
                                         &Offset_High2 ) ) {

              DisplayDriverError( status ) ;
              printf( "  ...occurred in GetTapePosition API using TAPE_ABSOLUTE_POSITION parameter.\n\n" ) ;
              ++API_Errors ;
           }
           else if( ( Offset_Low != Offset_Low2 ) || ( Offset_High != Offset_High2 ) ) {

                   printf( "--- Error ---> Positioned to incorrect location.\n\n" ) ;
                   ++API_Errors ;
                }
                else printf( "Parameter Ok.\n\n\n" ) ;

   }

//
   if( SupportedFeature( TAPE_DRIVE_ABS_BLK_IMMED ) || Test_Unsupported_Features ) {

      RewindTape( ) ;

      printf( "\nTesting TAPE_ABSOLUTE_BLOCK parameter (immed).\n\n" ) ;


      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_ABSOLUTE_BLOCK,
                                    Partition,
                                    Offset_Low,
                                    Offset_High,
                                    1 ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_ABSOLUTE_BLOCK parameter (immed).\n\n" ) ;
         ++API_Errors ;

             // If Set ok, check results with Get.

      }
      else {  // Loop until drive is ready to accept more commands.

              status = 1 ;

              while( status )
                 status = GetTapeStatus( gb_Tape_Handle ) ;


              // Now, get the position and check results.

              if( status = GetTapePosition( gb_Tape_Handle,
                                            TAPE_ABSOLUTE_POSITION,
                                            &Partition,
                                            &Offset_Low2,
                                            &Offset_High2 ) ) {

                 DisplayDriverError( status ) ;
                 printf( "  ...occurred in GetTapePosition API using TAPE_ABSOLUTE_POSITION parameter.\n\n" ) ;
                 ++API_Errors ;
              }
              else if( ( Offset_Low != Offset_Low2 ) || ( Offset_High != Offset_High2 ) ) {

                      printf( "--- Error ---> Positioned to incorrect location.\n\n" ) ;
                      ++API_Errors ;
                   }
                   else printf( "Parameter Ok.\n\n\n" ) ;
           }

   }


// TAPEMARK POSITION TESTS - Remeber we already have Num_Test_Blocks blocks of
//                           data followed by (NUM_TAPE_MARKS) Filemarks and all offsets
//                           needed for the test.


   if( SupportedFeature( TAPE_DRIVE_FILEMARKS ) || Test_Unsupported_Features ) {

      RewindTape( ) ;

      printf( "\nTesting TAPE_SPACE_FILEMARKS parameter.\n\n" ) ;

      // Now perform the Position tests for filemark and make sure that the
      // offsets are equal.

      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_SPACE_FILEMARKS,
                                    Partition,
                                    1,         // Look for 1 filemark
                                    0,
                                    0
                                  ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_SPACE_FILEMARKS parameter.\n\n" ) ;
         ++API_Errors ;

      } else {  status = 0 ;

                for( i=0; i<( NUM_TAPE_MARKS ); ++i ) {

                   ReadTape( Readbuff,
                             gb_Media_Info.BlockSize,
                             &amount_read,
                             0 ) ;
//  *
                   if( ( GetLastError( ) != ERROR_FILEMARK_DETECTED ) && ( i <= NUM_TAPE_MARKS ) )

                      status = 1 ;

                }

                if( GetLastError( ) == ERROR_NO_DATA_DETECTED || status )

                   printf( "Parameter Ok.\n\n\n" ) ;

                else { ++API_Errors ;

                       printf( "--- Error ---> Spacing error, filemark detected at incorrect location.\n\n" ) ;
                     }

             }

   }

   if( SupportedFeature( TAPE_DRIVE_SEQUENTIAL_FMKS ) || Test_Unsupported_Features ) {

      RewindTape( ) ;

      printf( "\nTesting TAPE_SPACE_SEQUENTIAL_FMKS parameter.\n\n" ) ;


   // Now perform the Position tests for the group of filemarksand make
   // sure that the offsets are equal.


      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_SPACE_SEQUENTIAL_FMKS,
                                    Partition,
                                    (NUM_TAPE_MARKS),         // Look for the (NUM_TAPE_MARKS) filemarks
                                    0,
                                    0
                                  ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_TAPE_SEQUENTIAL_FMKS parameter.\n\n" ) ;
         ++API_Errors ;


      } else {  ReadTape( Readbuff,
                          gb_Media_Info.BlockSize,
                          &amount_read,
                          0 ) ;

                if( GetLastError( ) == ERROR_NO_DATA_DETECTED )

                   printf( "Parameter Ok.\n\n\n" ) ;

                else { ++API_Errors ;
                       printf( "--- Error ---> Spacing error, filemarks detected at incorrect location.\n\n" ) ;
                     }

             }

   }


// LOGICAL TESTING

   RewindTape( ) ;

   // Write more test data.

   WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

   // Store last data block position (before setmarks) in LOGical offsets
   // if supported.

   if( SupportedFeature( TAPE_DRIVE_GET_LOGICAL_BLK ) )

      if( status = GetTapePosition( gb_Tape_Handle,
                                    TAPE_LOGICAL_POSITION,
                                    &Partition,
                                    &LOG_Low,
                                    &LOG_High ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in GetTapePosition API using TAPE_LOGICAL_POSITION parameter.\n\n" ) ;
         ++API_Errors ;
      }

   // Try and write a setmark to tape.

   if( SupportedFeature( TAPE_DRIVE_WRITE_SETMARKS ) ) {

      j = WriteTapeSMK( ) ;

      // Try and write NUM_TAPE_MARKS-1 more setmarks.

      for( i=0; i<(NUM_TAPE_MARKS-1); ++i )

         j = WriteTapeSMK( ) ;

     // else write a filemark so EOD errors don't occur.

   } else i=WriteTapeFMK( ) ;


   // Store offsets of EOD for test later.

   if( SupportedFeature( TAPE_DRIVE_GET_LOGICAL_BLK ) )

      if( status = GetTapePosition( gb_Tape_Handle,
                                    TAPE_ABSOLUTE_POSITION,
                                    &Partition,
                                    &EOD_Low,
                                    &EOD_High ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in GetTapePosition API using TAPE_ABSOLUTE_POSITION parameter.\n\n" ) ;
         ++API_Errors ;
      }

   // Write 1 more block to space back over at EOD test to verify offsets.

   WriteBlocks( 1, gb_Media_Info.BlockSize ) ;

//
   if( SupportedFeature( TAPE_DRIVE_REWIND_IMMEDIATE ) || Test_Unsupported_Features ) {

      // Test the immediate rewind.

      printf( "Testing TAPE_REWIND parameter (immed).\n\n" ) ;

      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_REWIND,
                                    Partition,
                                    0,
                                    0,
                                    1 ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_REWIND parameter (immed).\n\n" ) ;
         ++API_Errors ;

         // Call RewindTape()  (which uses the standard rewind) so the following
         // test won't bomb (due to the TAPE_REWIND (immed.) call failing).

         RewindTape( ) ;

      } else {  // Loop until drive is ready to accept more commands.

                status = 1 ;

                while( status )
                   status = GetTapeStatus( gb_Tape_Handle ) ;

                printf( "Parameter Ok.\n\n\n" ) ;
             }

   } else RewindTape( ) ;

//
   if( SupportedFeature( TAPE_DRIVE_LOGICAL_BLK ) || Test_Unsupported_Features ) {


      printf( "Testing TAPE_LOGICAL_BLOCK parameter.\n\n" ) ;

      // call Get to set the Logical partiton in Partition

      if( status = GetTapePosition( gb_Tape_Handle,
                                    TAPE_LOGICAL_POSITION,
                                    &Partition,
                                    &Offset_Low,
                                    &Offset_High
                                  ) ) {
         DisplayDriverError( status ) ;
         printf( "  ...occurred in GetTapePosition API using TAPE_LOGICAL_POSITION parameter.\n\n" ) ;
         ++API_Errors ;
      }


      // Set up test offset for Logical testing

      Offset_Low  = LOG_Low ;
      Offset_High = LOG_High ;

// * 1,//partition,

      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_LOGICAL_BLOCK,
                                    Partition,
                                    Offset_Low,
                                    Offset_High,
                                    0 ) ) {

         DisplayDriverError( status ) ;
         printf("  ...occurred in SetTapePosition API using TAPE_LOGICAL_BLOCK parameter.\n\n" ) ;
         ++API_Errors ;

             // If Set ok, check results with Get.

      }
      else if( status = GetTapePosition( gb_Tape_Handle,
                                         TAPE_LOGICAL_POSITION,
                                         &Partition,
                                         &Offset_Low2,
                                         &Offset_High2 ) ) {

              DisplayDriverError( status ) ;
              printf( "  ...occurred in GetTapePosition API using TAPE_LOGICAL_POSITION parameter.\n\n" ) ;
              ++API_Errors ;
           }
           else if( ( Offset_Low != Offset_Low2 ) || ( Offset_High != Offset_High2 ) ) {

                   printf( "--- Error ---> Positioned to incorrect location.\n\n" ) ;
                   ++API_Errors ;
                }
                else printf( "Parameter Ok.\n\n\n" ) ;

   }

//
   if( SupportedFeature( TAPE_DRIVE_LOG_BLK_IMMED ) || Test_Unsupported_Features ) {

      RewindTape( ) ;

      printf( "\nTesting TAPE_LOGICAL_BLOCK parameter (immed).\n\n" ) ;

// * 1,//partition,

      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_LOGICAL_BLOCK,
                                    Partition,
                                    Offset_Low,
                                    Offset_High,
                                    1 ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_LOGICAL_BLOCK parameter (immed).\n\n" ) ;
         ++API_Errors ;

            // If Set ok, check results with Get.

      }
      else {  // Loop until drive is ready to accept more commands.

              status = 1 ;

              while( status )
                 status = GetTapeStatus( gb_Tape_Handle ) ;


              // Now, get the position and check results.

              if( status = GetTapePosition( gb_Tape_Handle,
                                            TAPE_LOGICAL_POSITION,
                                            &Partition,
                                            &Offset_Low2,
                                            &Offset_High2 ) ) {

                 DisplayDriverError( status ) ;
                 printf( "  ...occurred in GetTapePosition API using TAPE_LOGICAL_POSITION parameter.\n\n" ) ;
                 ++API_Errors ;
              }
              else if( ( Offset_Low != Offset_Low2 ) || ( Offset_High != Offset_High2 ) ) {

                      printf( "--- Error ---> Positioned to incorrect location.\n\n" ) ;
                      ++API_Errors ;
                   }
                   else printf( "Parameter Ok.\n\n\n" ) ;

           }

   }


// TAPEMARK POSITION TESTS - Remeber we already have Num_Test_Blocks blocks of
//                           data followed by  NUM_TAPE_MARKS Setmarks and all offsets
//                           needed for the test.



   if( ( SupportedFeature( TAPE_DRIVE_SETMARKS ) || Test_Unsupported_Features )
         && gb_Set_Drive_Info.ReportSetmarks ) {

      RewindTape( ) ;

      printf( "\nTesting TAPE_SPACE_SETMARKS parameter.\n\n" ) ;

      // Now perform the Position tests for setmark and make sure that the
      // offsets are equal.


      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_SPACE_SETMARKS,
                                    Partition,
                                    1,         // Look for 1 setmark
                                    0,
                                    0
                                  ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_SPACE_SETMARKS parameter.\n\n" ) ;
         ++API_Errors ;


      } else {  status = 0 ;

                for( i=0; i<( NUM_TAPE_MARKS+1 ); ++i ) {

                   ReadTape( Readbuff,
                             gb_Media_Info.BlockSize,
                             &amount_read,
                             0 ) ;
// *
                if( ( GetLastError( ) != ERROR_SETMARK_DETECTED ) && ( i <= NUM_TAPE_MARKS ) )

                      status = 1 ;

                }

                if( GetLastError( ) == ERROR_NO_DATA_DETECTED || status )

                   printf( "Parameter Ok.\n\n\n" ) ;

                else { ++API_Errors ;
                       printf( "--- Error ---> Spacing error, setmark detected at incorrect location.\n\n" ) ;
                     }

             }

   }

//

   if( ( SupportedFeature( TAPE_DRIVE_SEQUENTIAL_SMKS ) || Test_Unsupported_Features )
         && gb_Set_Drive_Info.ReportSetmarks ) {

      RewindTape( ) ;

      printf( "\nTesting TAPE_SPACE_SEQUENTIAL_SMKS parameter.\n\n" ) ;

      // Now perform the Position tests for the groups of setmarks
      // and make sure that the offsets are equal.


      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_SPACE_SEQUENTIAL_SMKS,
                                    Partition,
                                    (NUM_TAPE_MARKS),       // Look for NUM_TAPE_MARKS setmarks
                                    0,
                                    0
                                  ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_SPACE_SEQUENTIAL_SMKS parameter.\n\n" ) ;
         ++API_Errors ;


      } else {  for( i=0; i<2 ; ++i )       // 1 block of data, then read EOD

                   ReadTape( Readbuff,
                             gb_Media_Info.BlockSize,
                             &amount_read,
                             0 ) ;

                if( GetLastError( ) == ERROR_NO_DATA_DETECTED )

                   printf( "Parameter Ok.\n\n\n" ) ;

                else { ++API_Errors ;
                       printf( "--- Error ---> Spacing error, setmarks detected at incorrect location.\n\n" ) ;
                     }

             }

   }


// TAPE_SPACE_RELATIVE Test

   if( SupportedFeature( TAPE_DRIVE_RELATIVE_BLKS ) || Test_Unsupported_Features ) {

      RewindTape( ) ;

      printf( "\nTesting TAPE_SPACE_RELATIVE_BLOCKS parameter.\n\n" ) ;


      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_SPACE_RELATIVE_BLOCKS,
                                    Partition,
                                    Num_Test_Blocks,
                                    0,
                                    0 ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_SPACE_RELATIVE_BLOCKS parameter.\n\n" ) ;
         ++API_Errors ;

          // If Set ok, check results with Get.

      }
      else if( SupportedFeature( TAPE_DRIVE_GET_ABSOLUTE_BLK ) )

              if( status = GetTapePosition( gb_Tape_Handle,
                                            TAPE_LOGICAL_POSITION,
                                            &Partition,
                                            &Offset_Low2,
                                            &Offset_High2 ) ) {

                 DisplayDriverError( status ) ;
                 printf( "  ...occurred in GetTapePosition API using TAPE_LOGICAL_POSITION parameter.\n\n" ) ;
                 ++API_Errors ;
              }
              else if( ( LOG_Low != Offset_Low2 ) || ( LOG_High != Offset_High2 ) ) {

                      printf( "--- Error ---> Spaced to incorrect location.\n\n " ) ;
                      ++API_Errors ;
                   }
                   else printf( "Parameter Ok.\n\n\n" ) ;

           else {  for( i=0; i<(NUM_TAPE_MARKS+1); ++i )

                        ReadTape( Readbuff,
                                  gb_Media_Info.BlockSize,
                                  &amount_read,
                                  0 ) ;

                     if( GetLastError( ) == ERROR_NO_DATA_DETECTED )

                        printf( "Parameter Ok.\n\n" ) ;

                     else { ++API_Errors ;
                            printf( "--- Error ---> End of data expected, not found.\n\n" ) ;
                          }

                   }

   }


// END OF DATA TEST


   if( SupportedFeature( TAPE_DRIVE_END_OF_DATA ) || Test_Unsupported_Features ) {

      RewindTape( ) ;

      printf( "\nTesting TAPE_SPACE_END_OF_DATA parameter.\n\n" ) ;

      if( status = SetTapePosition( gb_Tape_Handle,
                                    TAPE_SPACE_END_OF_DATA,
                                    Partition,
                                    0,
                                    0,
                                    0 ) ) {

         DisplayDriverError( status ) ;
         printf( "  ...occurred in SetTapePosition API using TAPE_SPACE_END_OF_DATA parameter.\n\n" ) ;
         ++API_Errors ;

          // If Set ok, check results with Get.

      }
      else if( SupportedFeature( TAPE_DRIVE_GET_ABSOLUTE_BLK ) &&
               SupportedFeature( TAPE_DRIVE_RELATIVE_BLKS ) &&
               SupportedFeature( TAPE_DRIVE_REVERSE_POSITION ) )

              if( status = SetTapePosition( gb_Tape_Handle,
                                            TAPE_SPACE_RELATIVE_BLOCKS,
                                            Partition,
                                            (DWORD)-1L,
                                            0,
                                            0 ) ) {

                 DisplayDriverError( status ) ;
                 printf( "  ...occurred in SetTapePosition API using TAPE_SPACE_RELATIVE_BLOCKS parameter.\n\n" ) ;
                 ++API_Errors ;

              } else if( status = GetTapePosition( gb_Tape_Handle,
                                                   TAPE_ABSOLUTE_POSITION,
                                                   &Partition,
                                                   &Offset_Low2,
                                                   &Offset_High2 ) ) {

                        DisplayDriverError( status ) ;
                        printf( "  ...occurred in GetTapePosition API using TAPE_ABSOLUTE_POSITION parameter.\n\n" ) ;
                        ++API_Errors ;
                     }
                     else if( ( EOD_Low != Offset_Low2 ) || ( EOD_High != Offset_High2 ) ) {

                             printf( "--- Error ---> Spaced to incorrect location.\n\n " ) ;
                             ++API_Errors ;
                          }
                          else printf( "Parameter Ok.\n\n\n" ) ;

           else { ReadTape( Readbuff,
                            gb_Media_Info.BlockSize,
                            &amount_read,
                            0 ) ;

                  if( GetLastError( ) == ERROR_NO_DATA_DETECTED ) {

                     printf( "Call to SetTapePosition with SPACE_END_OF_DATA Parameter Ok:\n" ) ;
                     printf( "     Cannot confirm positioned to exact EOD with this drive.\n\n\n" ) ;

                  }

                  else { ++API_Errors ;
                         printf( "--- Error ---> End of data expected, not found.\n\n" ) ;
                       }
                }


   }


// TEST DONE

   printf( "\n\nSetTapePosition API Test Completed.\n\n\n" ) ;

   free( Readbuff ) ;

   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\tapelib.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       tapelib.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape Library  :  Additions Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.

/**
 *
 *      Unit:          Windows NT API Test Code
 *
 *      Name:          TapeLib.c
 *
 *      Modified:      12/21/92
 *
 *      Description:   Contains tape library routines.
 *
 *      $LOG$
 *
**/




#include "windows.h"
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include "TapeLib.h"          // Tape function prototypes

#define TEST_ERROR  TRUE
#define SUCCESS     FALSE



//  Global variables

HANDLE gb_Tape_Handle = NULL ;

DWORD  gb_Tape_Position ;           // Valid only from BOT using Read,Write,
                                    // or Tapemark functions.

UINT   gb_Feature_Errors = 0 ;


                                                 // Should be set with a call
TAPE_GET_MEDIA_PARAMETERS gb_Media_Info ;        // to GetTapeParameters()
TAPE_GET_DRIVE_PARAMETERS gb_Drive_Info ;        // before calling any of the
                                                 // following routines.
TAPE_SET_MEDIA_PARAMETERS gb_Set_Media_Info ;
TAPE_SET_DRIVE_PARAMETERS gb_Set_Drive_Info ;





/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           CloseTape( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    'Closes' the tape device, sets the handle gb_Tape_Handle.
 *
 *      Notes:          -
 *
 *      Returns:        VOID.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


VOID CloseTape( VOID )
{

   // If Tape was previously opened successfully, then close it...

   if( gb_Tape_Handle != NULL ) {

      CloseHandle( gb_Tape_Handle ) ;
      gb_Tape_Handle = NULL ;

   }

   printf( "CloseTape():\n" ) ;

   return ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           DisplayDriverError( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Prints out the appropriate error message and code based
 *                      on the code passed in.
 *
 *      Notes:          -
 *
 *      Returns:        VOID.
 *
 *      Global Data:    gb_Feature_Errors
 *
**/


VOID DisplayDriverError( DWORD error     // I - Error code.
                        )
{

   printf( "\n--- Error ---> " ) ;

   switch( error ) {

      case ERROR_SUCCESS:                                     // 0000
           break ;

      case ERROR_INVALID_HANDLE:                              // 0006
           printf( "Invalid handle.\n", error ) ;
           break ;

      case ERROR_SETMARK_DETECTED:                            // 1103
           printf( "Setmark detected. (%ld)\n", error ) ;
           break ;

      case ERROR_FILEMARK_DETECTED:                           // 1101
           printf( "Filemark detected. (%ld)\n", error ) ;
           break ;

      case ERROR_BEGINNING_OF_MEDIA:                          // 1102
           printf( "Beginning of Media detected. (%ld)\n", error ) ;
           break ;

      case ERROR_END_OF_MEDIA:                                // 1100
           printf( "End of Media detected. (%ld)\n", error ) ;
           break ;

      case ERROR_NOT_READY:                                   // 0021
           printf( "Drive busy or no tape in drive. (%ld)\n",error );
           break ;

      case ERROR_NO_MEDIA_IN_DRIVE:                           // 1112
           printf( "No tape in drive. (%ld)\n", error ) ;
           break ;

      case ERROR_NOT_DOS_DISK:
      case ERROR_INVALID_DATA:                                // 0013
           printf( "Unable to read data detected. (%ld)\n", error ) ;
           break ;

      case ERROR_GEN_FAILURE:
      case ERROR_IO_DEVICE:                                   // 1117
           printf( "Hardware error detected. (%ld)\n", error ) ;
           break ;

      case ERROR_INVALID_FUNCTION:                            // 0001
           printf( "Invalid Function. (%ld)\n",error ) ;
           break ;

      case ERROR_SECTOR_NOT_FOUND:                            // 0027
           printf( "Sector not found. (%ld)\n",error ) ;
           break ;

      case ERROR_FILE_NOT_FOUND:                              // 0002
           printf( "File not found. (%ld)\n",error ) ;
           break ;

      case ERROR_WRITE_PROTECT:                               // 0019
           printf( "Tape write protect error. (%ld)\n", error ) ;
           break ;

      case ERROR_NO_DATA_DETECTED:                            // 1104
           printf( "No data detected. (%ld)\n", error ) ;
           break ;

      case ERROR_PARTITION_FAILURE:                           // 1105
           printf( "Tape could not be partitioned. (%ld)\n", error ) ;
           break ;

      case ERROR_INVALID_BLOCK_LENGTH:                        // 1106
           printf( "Invalid block length. (%ld)\n", error ) ;
           break ;

      case ERROR_DEVICE_NOT_PARTITIONED:                      // 1107
           printf( "Device not partitioned. (%ld)\n", error ) ;
           break ;

      case ERROR_UNABLE_TO_LOCK_MEDIA:                        // 1108
           printf( "Unable to lock media. (%ld)\n", error ) ;
           break ;

      case ERROR_UNABLE_TO_UNLOAD_MEDIA:                      // 1109
           printf( "Unable to load media. (%ld)\n", error ) ;
           break ;

      case ERROR_MEDIA_CHANGED:                               // 1110
           printf( "The media in the drive has been changed. (%ld)\n", error ) ;
           break ;

      case ERROR_BUS_RESET:                                   // 1111
           printf( "The drive (bus) was reset. (%ld)\n", error ) ;
           break ;

      case ERROR_EOM_OVERFLOW:                                // 1129
           printf( "Physical end of tape has been reached. (%ld)\n", error ) ;
           break ;


      default:
           printf( "Unknown driver error = %ld\n", error ) ;
           break ;

   }

   printf( "\n" ) ;

   return;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           EjectTape( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Ejects the tape from the drive.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL EjectTape( VOID ){


   printf( "Attempting to Eject Tape...\n" ) ;

   if(gb_Tape_Handle != NULL) {

      if( PrepareTape( gb_Tape_Handle,
                       TAPE_UNLOAD,
                       0 ) ) {

         DisplayDriverError( GetLastError( ) ) ;
         return TEST_ERROR ;
      }

      else { return SUCCESS ;
      }
   }
}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           GetTapeParms( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Gets tape information.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL GetTapeParms(
   DWORD *total_low,       // O - tape capacity lower 32 bits
   DWORD *total_high,      // O - tape capacity upper 32 bits
   DWORD *freespace_low,   // O - free space remaining lower 32 bits
   DWORD *freespace_high,  // O - free space remaining upper 32 bits
   DWORD *blk_size,        // O - block size
   DWORD *part,            // O - number of partitions
   BOOL  *write_protect    // O - write protect on/off
    )

{

   TAPE_GET_MEDIA_PARAMETERS parms ;
   DWORD status ;
   DWORD StructSize ;

   if( gb_Tape_Handle != NULL ) {

   sizeof( TAPE_GET_MEDIA_PARAMETERS ) ;

      status = GetTapeParameters( gb_Tape_Handle,
                                  GET_TAPE_MEDIA_INFORMATION,
                                  &StructSize,
                                  &parms ) ;
      // If call to GetTapeParameters is successful, copy data to return

      if( status == NO_ERROR ) {

         *total_low      = parms.Capacity.LowPart ;
         *total_high     = parms.Capacity.HighPart ;
         *freespace_low  = parms.Remaining.LowPart ;
         *freespace_high = parms.Remaining.HighPart ;
         *blk_size       = parms.BlockSize ;
         *part	         = parms.PartitionCount ;
         *write_protect  = parms.WriteProtected ;

      }

      else { DisplayDriverError( GetLastError( ) ) ;
                return TEST_ERROR ;
      }
   }

   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           _GetTapePosition( )
 *
 *      Modified:       10/20/92
 *
 *      Description:    Returns the current software logical position of the
 *                      tape.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Position
 *
**/


BOOL _GetTapePosition( LPDWORD  Offset_Low,   // O - Current Tape Position
                       LPDWORD  Offset_High   // O - Always 0.
                     )
{

  *Offset_Low = gb_Tape_Position ;

  *Offset_High = 0 ;


  return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           OpenTape( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    'Opens' the tape device, sets the handle gb_Tape_Handle.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL OpenTape( UINT Device_Number        //  I - Tape device to open
             )
{
   UCHAR Device_Command[15] ;
   BOOL  success ;


   // Open the Tape Device

   sprintf( Device_Command, "\\\\.\\Tape%d", Device_Number );

   gb_Tape_Handle = CreateFile( Device_Command,
                                GENERIC_READ|GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL ) ;

   if ( gb_Tape_Handle == INVALID_HANDLE_VALUE ) {
      success = FALSE ;
   }
   else { success = TRUE ;
        }


   // Print message...

   printf( "Attempt to open tape device: %s. (handle=%lx)\n\n",
	  ( success ) ? "Successful." : "Failed.", gb_Tape_Handle ) ;

   if( success ) {

      return SUCCESS ;
   }
   else { return TEST_ERROR ;
   }

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           ReadTape( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Read 'len' bytes into 'buf' and puts the amount
 *                      successfuly read into 'amount_read.'
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Tape_Position
 *
**/


BOOL ReadTape(
     PVOID buf,             // O  - buffer to read into
     DWORD len,             // I  - amount of data in buf
     DWORD *amount_read,    // O  - amount succesfully read
     BOOL  verbose          // I  - Display read status or not.
    )
{

   *amount_read ;

   if( gb_Tape_Handle != NULL ) {

      if( !( ReadFile( gb_Tape_Handle,
                       buf,
                       len,
                       amount_read,
                       NULL
                     ) ) ) {
         if( verbose )
            DisplayDriverError( GetLastError( ) ) ;

         return TEST_ERROR ;
      }

   }

   ++gb_Tape_Position ;

   if( verbose )
      printf( "ReadTape(): Req = %ld, Read = %ld\n", len, *amount_read ) ;

   return SUCCESS ;
}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           ReadTapeFMK( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Reads a Filemark on the tape pointed to by
 *                      gb_Tape_Handle.  If 'forward' is true, the search is
 *                      performed from the current location forward, otherwise
 *                      backward.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL ReadTapeFMK( BOOL forward      // I - Direction of tape operation.
                  )
{
   printf( "ReadTapeFMK():\n" ) ;

   if( gb_Tape_Handle != NULL ) {

      if( SetTapePosition( gb_Tape_Handle,
                           TAPE_SPACE_FILEMARKS,
                           0,
                           ( forward ) ? 1L : -1L ,
                           ( forward ) ? 0L : -1L ,
                           0 ) ) {

         DisplayDriverError( GetLastError( ) ) ;
         return TEST_ERROR ;
      }
   }

   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           ReadTapePos()
 *
 *      Modified:       8/10/92
 *
 *      Description:    Using the current partition of the tape pointed to by
 *                      gb_Tape_Handle, sets 'tape_pos' to the current tape
 *                      block position.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL ReadTapePos( DWORD *tape_pos     // O - Current tape block position.
                )
{
   DWORD partition  = 0 ;
   DWORD offsethigh = 0 ;


   if( gb_Tape_Handle != NULL ) {

      if( GetTapePosition( gb_Tape_Handle,
                           TAPE_ABSOLUTE_POSITION,
                           &partition,
                           tape_pos,
                           &offsethigh
                         ) ) {

	 DisplayDriverError( GetLastError( ) ) ;
         return TEST_ERROR ;
      }
   }

   printf( "ReadTapePos(): (%lx)\n", *tape_pos ) ;

   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           ReadTapeSMK( )
 *
 *      Modified:       10/16/92
 *
 *      Description:    Reads a Setmark on the tape pointed to by
 *                      gb_Tape_Handle.  If 'forward' is true, the search is
 *                      performed from the current location forward, otherwise
 *                      backward.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL ReadTapeSMK( BOOL forward      // I - Direction of tape operation.
                  )
{
   printf( "ReadTapeSMK():\n" ) ;

   if( gb_Tape_Handle != NULL ) {

      if( SetTapePosition( gb_Tape_Handle,
                           TAPE_SPACE_SETMARKS,
                           0,
                           ( forward ) ? 1L : -1L,
                           ( forward ) ? 0L : -1L,
                           0 ) ) {

         DisplayDriverError( GetLastError( ) ) ;
         return TEST_ERROR ;
      }
   }

   return SUCCESS ;
}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           RewindTape( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Rewinds to beginning of the tape.
 *
 *      Notes:          -
 *
 *      Returns:        VOID.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Tape_Handle
 *
**/


VOID RewindTape( VOID )
{

    printf( "RewindTape():\n" ) ;

    if( gb_Tape_Handle != NULL ) {

       SetTapePosition( gb_Tape_Handle,
                        TAPE_REWIND,
                        0,
                        0,
                        0,
                        0 ) ;

    }

    gb_Tape_Position = 0 ;

    return ;

}


/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           SeekTape( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Starting at the current partition of the tape pointed
 *                      to by gb_Tape_Handle, does an absolute (vs relative)
 *                      block position offset by 'tape_pos.'  If tape_pos is
 *                      positive, a forward direction is indicated, otherwise
 *                      backward.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL SeekTape( DWORD tape_pos    // I - Direction of tape operation.
               )
{

   printf( "SeekTape(): (%lx)\n", tape_pos ) ;

   if( gb_Tape_Handle != NULL ) {

      if( SetTapePosition( gb_Tape_Handle,
                           TAPE_ABSOLUTE_BLOCK,
                           0,
                           tape_pos,
                           0,
                           0 ) ) {

         DisplayDriverError( GetLastError( ) ) ;
         return TEST_ERROR ;
      }
   }

   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           SeekTapeEOD( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Moves the tape pointed to by gb_Tape_Handle to the end
 *                      of data in the current partition.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL SeekTapeEOD( VOID )
{

   printf( "SeekTapeEOD():\n" ) ;

   if( gb_Tape_Handle != NULL ) {

      if( SetTapePosition( gb_Tape_Handle,
		           TAPE_SPACE_END_OF_DATA,
		           0,
		           0,
		           0,
                           0 ) ) {

	 DisplayDriverError( GetLastError( ) ) ;
         return TEST_ERROR ;
      }
   }

   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           _SetTapePosition( )
 *
 *      Modified:       10/20/92
 *
 *      Description:    Move the tape 'Position' blocks either forward or
 *                      backward based on 'Forward.'
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Tape_Position
 *
**/


BOOL _SetTapePosition( DWORD Position,     // I -  Number of blocks to move
                       BOOL  Forward       // I -  Direction
                    )

{
   DWORD status ;


   if( gb_Tape_Position == Position )

     return SUCCESS ;

   else if( status = SetTapePosition( gb_Tape_Handle,
                                      TAPE_SPACE_RELATIVE_BLOCKS,
                                      0,                           // ignored
                                      ( Position - gb_Tape_Position ),
                                      0,
                                      0 ) ) {

           DisplayDriverError( status ) ;
           printf( "  ...occurred in function _SetTapePosition in 'tapelib.c' while calling\n" ) ;
           printf( "     the SetTapePosition API with TAPE_SPACE_RELATIVE_BLOCKS parameter.\n\n" ) ;
        }

        else gb_Tape_Position += ( Position - gb_Tape_Position ) ;



   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           StatusTape( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Checks the tape pointed to by gb_handle and sets
 *                      'drive_status.'
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL StatusTape( DWORD *drive_status      // O - Status of drive.
                 )
{

   if( gb_Tape_Handle != NULL ){

      GetTapeStatus(  gb_Tape_Handle );
      DisplayDriverError( GetLastError( ) ) ;
      *drive_status = GetLastError( );

   }

   printf( "StatusTape(): status = %lx\n", *drive_status ) ;

   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           SupportedFeature( )
 *
 *      Modified:       9/2/92.
 *
 *      Description:    Determines if the device supports a particular feature
 *
 *      Notes:          -
 *
 *      Returns:        TRUE if the feature is supported, FALSE othewise.
 *
 *      Global Data:    gb_Device_Info
 *
**/

BOOL SupportedFeature( ULONG Feature	 // I - Feature to be checked
                     )
{

   // If a low feature, start checking the Low features

   if( !( TAPE_DRIVE_HIGH_FEATURES & Feature ) )

      switch( Feature ){

         case TAPE_DRIVE_FIXED             :

         case TAPE_DRIVE_SELECT            :

         case TAPE_DRIVE_INITIATOR         :

         case TAPE_DRIVE_ERASE_SHORT       :

         case TAPE_DRIVE_ERASE_LONG        :

         case TAPE_DRIVE_ERASE_BOP_ONLY    :

         case TAPE_DRIVE_ERASE_IMMEDIATE   :

         case TAPE_DRIVE_TAPE_CAPACITY     :

         case TAPE_DRIVE_TAPE_REMAINING    :

         case TAPE_DRIVE_FIXED_BLOCK       :

         case TAPE_DRIVE_VARIABLE_BLOCK    :

         case TAPE_DRIVE_WRITE_PROTECT     :

         case TAPE_DRIVE_EOT_WZ_SIZE       :

         case TAPE_DRIVE_ECC               :

         case TAPE_DRIVE_COMPRESSION       :

         case TAPE_DRIVE_PADDING           :

         case TAPE_DRIVE_REPORT_SMKS       :

         case TAPE_DRIVE_GET_ABSOLUTE_BLK  :

         case TAPE_DRIVE_GET_LOGICAL_BLK   :

         case TAPE_DRIVE_SET_EOT_WZ_SIZE   : return Feature & gb_Drive_Info.FeaturesLow ;

         default                           : printf( "WARNING - Invalid Feature sent to SupportedFeature function.\n\n." ) ;
                                             return FALSE ;


   }

   // Not found, must be High feature then...

   switch( Feature ){

      case TAPE_DRIVE_LOAD_UNLOAD       :

      case TAPE_DRIVE_TENSION           :

      case TAPE_DRIVE_LOCK_UNLOCK       :

      case TAPE_DRIVE_REWIND_IMMEDIATE  :

      case TAPE_DRIVE_SET_BLOCK_SIZE    :

      case TAPE_DRIVE_LOAD_UNLD_IMMED   :

      case TAPE_DRIVE_TENSION_IMMED     :

      case TAPE_DRIVE_LOCK_UNLK_IMMED   :

      case TAPE_DRIVE_SET_ECC           :

      case TAPE_DRIVE_SET_COMPRESSION   :

      case TAPE_DRIVE_SET_PADDING       :

      case TAPE_DRIVE_SET_REPORT_SMKS   :

      case TAPE_DRIVE_ABSOLUTE_BLK      :

      case TAPE_DRIVE_ABS_BLK_IMMED     :

      case TAPE_DRIVE_LOGICAL_BLK       :

      case TAPE_DRIVE_LOG_BLK_IMMED     :

      case TAPE_DRIVE_END_OF_DATA       :

      case TAPE_DRIVE_RELATIVE_BLKS     :

      case TAPE_DRIVE_FILEMARKS         :

      case TAPE_DRIVE_SEQUENTIAL_FMKS   :

      case TAPE_DRIVE_SETMARKS          :

      case TAPE_DRIVE_SEQUENTIAL_SMKS   :

      case TAPE_DRIVE_REVERSE_POSITION  :

      case TAPE_DRIVE_SPACE_IMMEDIATE   :

      case TAPE_DRIVE_WRITE_SETMARKS    :

      case TAPE_DRIVE_WRITE_FILEMARKS   :

      case TAPE_DRIVE_WRITE_SHORT_FMKS  :

      case TAPE_DRIVE_WRITE_LONG_FMKS   :

      case TAPE_DRIVE_WRITE_MARK_IMMED  :

      case TAPE_DRIVE_FORMAT            :

      case TAPE_DRIVE_FORMAT_IMMEDIATE  :  return  Feature & gb_Drive_Info.FeaturesHigh ;
   }

   printf( "WARNING - Invalid Feature sent to SupportedFeature function.\n\n." ) ;

   return FALSE ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           TapeErase( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Erases the tape using either 'short' or 'long' (secure)
 *                      erase.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *
**/


BOOL TapeErase( BOOL Erase_Type     // I - Short or long erase.
               )
{
   if( SupportedFeature( TAPE_DRIVE_ERASE_BOP_ONLY ) )

      RewindTape( ) ;

   if( Erase_Type )

      printf( "Erase tape (Long).\n" ) ;

   else printf( "Erase tape (Short).\n" ) ;

   if( EraseTape( gb_Tape_Handle,
                  (Erase_Type) ? TAPE_ERASE_LONG : TAPE_ERASE_SHORT ,
                  0
                ) ) {

      DisplayDriverError( GetLastError( ) ) ;
      return TEST_ERROR ;
   }

   else { RewindTape( ) ;
          return SUCCESS ;
   }
}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           WriteTape( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Writes 'len' bytes from 'buf' to the device pointed to
 *                      by gb_Tape_Handle and places the amount successfuly
 *                      written in 'amount_written.'
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Tape_Position
 *
**/


BOOL WriteTape(
   PVOID buf,                     // I  - buffer to write from
   DWORD len,                     // I  - amount of data in buf
   DWORD *amount_written_ptr,     // O  - amount succesfully written
   BOOL  verbose                  // I  - display write status or not
   )
{


   *amount_written_ptr = 0L ;

   if( gb_Tape_Handle != NULL ) {

      if( !( WriteFile( gb_Tape_Handle,          // returns true if succ.
                        buf,
                        len,
                        amount_written_ptr,
                        NULL
                      ) ) ) {

         if( verbose )
            DisplayDriverError( GetLastError( ) ) ;

         return TEST_ERROR ;

      }
   }


   ++gb_Tape_Position ;

   if( verbose )
     printf( "WriteTape(): Req = %ld, Written = %ld\n", len, *amount_written_ptr ) ;

   return SUCCESS ;
}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           WriteTapeFMK( )
 *
 *      Modified:       8/10/92
 *
 *      Description:    Writes a Filemark on the tape pointed to by
 *                      gb_Tape_Handle.  Attempt to write a regular filemark
 *                      first, if not supported, a long filemark, else a
 *                      short filemark.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Tape_Position
 *
**/


BOOL WriteTapeFMK( VOID )
{
   UINT FilemarkType ;


   if( gb_Tape_Handle != NULL ) {

      if( SupportedFeature( TAPE_DRIVE_WRITE_FILEMARKS ) )

         FilemarkType = TAPE_FILEMARKS ;

      else if( SupportedFeature( TAPE_DRIVE_WRITE_LONG_FMKS ) )

              FilemarkType = TAPE_LONG_FILEMARKS ;

           else if( SupportedFeature( TAPE_DRIVE_WRITE_SHORT_FMKS ) )

                   FilemarkType = TAPE_SHORT_FILEMARKS ;

                else FilemarkType = 999 ;


      if( FilemarkType == 999 )

         return TEST_ERROR ;

      else { printf( "WriteTapeFMK():\n" ) ;

             if( WriteTapemark( gb_Tape_Handle,
                                FilemarkType,
                                1,
                                0 ) ) {

                DisplayDriverError( GetLastError( ) ) ;
                return  TEST_ERROR ;
             }
           }

   }


   ++gb_Tape_Position ;

   return SUCCESS ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           WriteTapeSMK( )
 *
 *      Modified:       10/16/92
 *
 *      Description:    Writes a Setmark on the tape pointed to by
 *                      gb_Tape_Handle.
 *
 *      Notes:          -
 *
 *      Returns:        FALSE (0) if successful TRUE (1) if unsuccessful.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Tape_Position
 *
**/


BOOL WriteTapeSMK( VOID )
{

  if( SupportedFeature( TAPE_DRIVE_WRITE_SETMARKS ) ) {

     printf( "WriteTapeSMK():\n" ) ;

     if( WriteTapemark( gb_Tape_Handle,
                        TAPE_SETMARKS,
                        1,
                        0
                      ) ) {
        DisplayDriverError( GetLastError( ) ) ;
        return TEST_ERROR ;

     }

     ++ gb_Tape_Position ;

     return SUCCESS ;

  } else return TEST_ERROR ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\tapelib.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       tapelib.h
//
//--------------------------------------------------------------------------



/**
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           Tapelib.h
 *
 *      Modified:       8/10/92, Bob Rossi.
 *
 *      Description:    Function prototypes for 'tapelib.c'
 *
 *      $LOG$
 *
**/



//   TapeLib functions


#ifndef tapelib

#define tapelib


VOID CloseTape( VOID ) ;

VOID DisplayDriverError( DWORD error
                              ) ;

BOOL EjectTape( VOID ) ;

BOOL GetTapeParms( DWORD *total_low,
                   DWORD *total_high,
                   DWORD *free_low,
                   DWORD *free_high,
                   DWORD *blk_size,
                   DWORD *part,
                   BOOL  *write_protect
                 ) ;

BOOL _GetTapePosition( LPDWORD  Offset_Low,
                       LPDWORD  Offset_High
                     ) ;

BOOL OpenDevice( IN PCHAR DeviceName,         // Internal Tapelib prototype
                 IN OUT PHANDLE HandlePtr
               ) ;

BOOL OpenTape( UINT ) ;

BOOL ReadTape( PVOID buf,
               DWORD len,
               DWORD *amount_read,
               BOOL  verbose
             ) ;

BOOL ReadTapeFMK( BOOL forward
                ) ;

BOOL ReadTapePos( DWORD *tape_pos
                ) ;

BOOL ReadTapeSMK( BOOL forward
                ) ;

VOID RewindTape( VOID ) ;

BOOL SeekTape( DWORD tape_pos
             ) ;

BOOL SeekTapeEOD( ) ;

BOOL _SetTapePosition( DWORD Position,
                       BOOL  Forward
                     ) ;

BOOL StatusTape( DWORD *drive_status
               ) ;

BOOL SupportedFeature( ULONG Feature
                     ) ;

BOOL TapeErase( BOOL type
              ) ;

BOOL WriteTape( PVOID buf,
                DWORD len,
                DWORD *amount_written,
                BOOL  verbose
              ) ;

BOOL WriteTapeFMK( VOID ) ;

BOOL WriteTapeSMK( VOID ) ;





// Global variables


extern HANDLE gb_Tape_Handle ;

extern DWORD  gb_Tape_Position ;

extern UINT   gb_Feature_Errors ;


extern TAPE_SET_MEDIA_PARAMETERS gb_Set_Media_Info ;
extern TAPE_SET_DRIVE_PARAMETERS gb_Set_Drive_Info ;

extern TAPE_GET_MEDIA_PARAMETERS gb_Media_Info ;
extern TAPE_GET_DRIVE_PARAMETERS gb_Drive_Info ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\writemrk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       writemrk.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           writemrk.c
 *
 *      Modified:       10/20/92.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <conio.h>
#include <malloc.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"





/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           WriteTapemarkAPITest( )
 *
 *      Modified:       10/20/92.
 *
 *      Description:    Tests the WriteTapemark API.
 *
 *      Notes:          -
 *
 *      Returns:        Number of API errors.
 *
 *      Global Data:    gb_Tape_Handle
 *                      gb_Media_Info.BlockSize
 *
**/


UINT WriteTapemarkAPITest(
        BOOL  Test_Unsupported_Features,      // I - Test unsupported flag
        DWORD Num_Test_Blocks                 // I - Number of test blocks
      )
{
   DWORD status ;
   DWORD Offset_Low ;
   DWORD Offset_High ;
   DWORD Partition ;

   PVOID Readbuff;
   DWORD amount_read;

   DWORD API_Errors = 0 ;


   printf( "Beginning WriteTapemark API Test.\n\n" ) ;

   Readbuff = malloc( gb_Media_Info.BlockSize ) ;


   if( SupportedFeature( TAPE_DRIVE_WRITE_SETMARKS ) &&
       ( SupportedFeature( TAPE_DRIVE_SETMARKS ) || Test_Unsupported_Features )
       && gb_Set_Drive_Info.ReportSetmarks ) {

      printf( "Testing TAPE_SETMARKS parameter.\n\n" ) ;

      // Rewind to BOT

      RewindTape( ) ;

      // write Num_Test_Blocks of data followed by a setmark and record offsets.

      WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

      if( status = WriteTapemark( gb_Tape_Handle,
                                  TAPE_SETMARKS,
                                  1,
                                  0
                                ) ) {
         DisplayDriverError( status ) ;
         printf( "  ...occurred in WriteTapemark API using TAPE_SETMARKS parameter.\n\n" ) ;
         ++API_Errors ;

      } else if( status = _GetTapePosition( &Offset_Low,
                                            &Offset_High
                                            ) )
                ++API_Errors ;

             else printf( "Setmark written at %ld%ld.\n\n",Offset_High,Offset_Low ) ;



      // Now perform the Position test for the setmark and make
      // sure that the offsets are equal.

      if( !status ){   // If no error writing tapemark, check results.

         RewindTape( ) ;

         if( status = _SetTapePosition( Num_Test_Blocks,
                                        1                 // Forward
                                      ) )

            ++API_Errors ;

            else {  ReadTape( Readbuff,
                              gb_Media_Info.BlockSize,
                              &amount_read,
                              0 ) ;

                    // check and make sure we read a setmark

                    if( GetLastError( ) != ERROR_SETMARK_DETECTED ) {

                       printf( "--- Error --->  Setmark expected at %ld%ld, not found.\n\n", Offset_High, Offset_Low ) ;
                       ++API_Errors ;

                    } else { printf( "\nSetmark confirmed at %ld%ld.\n\n",Offset_High, Offset_Low ) ;
                             printf( "Parameter Ok.\n\n\n" ) ;
                           }

                 }

      }


//
      if( SupportedFeature( TAPE_DRIVE_WRITE_MARK_IMMED ) ) {

         printf( "Testing TAPE_SETMARKS parameter (immed).\n\n" ) ;

         // Rewind to BOT.

         RewindTape( ) ;

         // write Num_Test_Blocks of data followed by a setmark (IMMED) and record offsets.

         WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

         if( status = WriteTapemark( gb_Tape_Handle,
                                     TAPE_SETMARKS,
                                     1,
                                     1
                                   ) ) {
            DisplayDriverError( status ) ;
            printf( "  ...occurred in WriteTapemark API using TAPE_SETMARKS parameter (immed).\n\n" ) ;
            ++API_Errors ;

         } else {  // Loop until drive is ready to accept more commands.

                   status = 1 ;

                   while( status )
                      status = GetTapeStatus( gb_Tape_Handle ) ;


                   // Next, get the position for later tests.

                   if( status = _GetTapePosition( &Offset_High,
                                                  &Offset_High
                                                ) ) {

                      ++API_Errors ;

                   } else printf( "Setmark (Immed.) written at %ld%ld.\n\n",Offset_High,Offset_Low ) ;

                }


         // Now perform the Position test for the setmark and make
         // sure that the offsets are equal.

         if( !status ){   // If no error writing tapemark, check results.

            RewindTape( ) ;

            if( status = _SetTapePosition( Num_Test_Blocks,
                                           1                  // Forward
                                         ) ) {

               ++API_Errors ;

            } else {  ReadTape( Readbuff,
                                gb_Media_Info.BlockSize,
                                &amount_read,
                                0 ) ;

                      // check and make sure we read a setmark

                      if( GetLastError( ) != ERROR_SETMARK_DETECTED ) {

                         printf( "--- Error --->  Setmark (immed.) expected at %ld%ld, not found.\n\n", Offset_High, Offset_Low ) ;
                         ++API_Errors ;

                      }  else { printf( "\nSetmark (Immed.) confirmed at %ld%ld.\n\n",Offset_High,Offset_Low ) ;
                                printf( "Parameter Ok.\n\n\n" ) ;
                              }

                   }

         }

      }

   }


//
   if( SupportedFeature( TAPE_DRIVE_WRITE_FILEMARKS ) &&
       ( SupportedFeature( TAPE_DRIVE_FILEMARKS ) || Test_Unsupported_Features ) ) {

      printf( "Testing TAPE_FILEMARKS parameter.\n\n" ) ;

      // Rewind to BOT.

      RewindTape( ) ;

      // write 5 blocks of data followed by a filemark and record offsets.

      WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

      if( status = WriteTapemark( gb_Tape_Handle,
                                  TAPE_FILEMARKS,
                                  1,
                                  0
                                ) ) {
         DisplayDriverError( status ) ;
         printf( "  ...occurred in WriteTapemark API using TAPE_FILEMARKS parameter.\n\n" ) ;
         ++API_Errors ;

      } else if( status = _GetTapePosition( &Offset_Low,
                                            &Offset_High
                                          ) ) {

                ++API_Errors ;

             } else printf( "Filemark written at %ld%ld.\n\n",Offset_High,Offset_Low ) ;



      // Now perform the Position test for the filemark and make
      // sure that the offsets are equal.

      if( !status ){   // If no error writing tapemark, check results.

         RewindTape( ) ;

         if( status = _SetTapePosition( Num_Test_Blocks,
                                        1                     // Forward
                                      ) ) {

            ++API_Errors ;

         } else {  ReadTape( Readbuff,
                             gb_Media_Info.BlockSize,
                             &amount_read,
                             0 ) ;

                   // check and make sure we read a filemark

                   if( GetLastError( ) != ERROR_FILEMARK_DETECTED ) {

                      printf( "--- Error --->  Filemark expected at %ld%ld, not found.\n\n", Offset_High, Offset_Low ) ;
                      ++API_Errors ;

                   }  else { printf( "\nFilemark confirmed at %ld%ld.\n\n",Offset_High,Offset_Low ) ;
                             printf( "Parameter Ok.\n\n\n" ) ;
                           }

                }
      }


//
      if( SupportedFeature( TAPE_DRIVE_WRITE_MARK_IMMED ) ) {

         printf( "Testing TAPE_FILEMARKS parameter (immed).\n\n" ) ;

         // Rewind to BOT.

         RewindTape( ) ;

         // write 5 blocks of data followed by a filemark (IMMED) and record offsets.

         WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

         if( status = WriteTapemark( gb_Tape_Handle,
                                     TAPE_FILEMARKS,
                                     1,
                                     1
                                   ) ) {
            DisplayDriverError( status ) ;
            printf( "  ...occurred in WriteTapemark API using TAPE_FILEMARKS parameter (immed).\n\n" ) ;
            ++API_Errors ;

         } else {  // Loop until drive is ready to accept more commands.

                   status = 1 ;

                   while( status )
                      status = GetTapeStatus( gb_Tape_Handle ) ;


                   // Next, get the position for later tests.

                   if( status = _GetTapePosition( &Offset_Low,
                                                  &Offset_High
                                                ) ) {

                      ++API_Errors ;

                   } else printf( "Filemark (Immed.) written at %ld%ld.\n\n",Offset_High,Offset_Low ) ;

                }


         // Now perform the Position test for the filemark and make
         // sure that the offsets are equal.

         if( !status ){   // If no error writing tapemark, check results.

            RewindTape( ) ;

            if( status = _SetTapePosition( Num_Test_Blocks,
                                        1                   // Forward
                                      ) ) {

               ++API_Errors ;

            } else {  ReadTape( Readbuff,
                                gb_Media_Info.BlockSize,
                                &amount_read,
                                0 ) ;

                      // check and make sure we read a filemark

                      if( GetLastError( ) != ERROR_FILEMARK_DETECTED ) {

                         printf( "--- Error --->  Filemark (immed.) expected at %ld%ld, not found.\n\n", Offset_High, Offset_Low ) ;
                         ++API_Errors ;

                      }  else { printf( "\nFilemark (Immed.) confirmed at %ld%ld.\n\n",Offset_High,Offset_Low ) ;
                                printf( "Parameter Ok.\n\n\n" ) ;
                              }

                   }

         }

      }

   }


//
   if( SupportedFeature( TAPE_DRIVE_WRITE_SHORT_FMKS ) &&
       ( SupportedFeature( TAPE_DRIVE_FILEMARKS ) || Test_Unsupported_Features ) ) {

      printf( "Testing TAPE_SHORT_FILEMARKS parameter.\n\n" ) ;

      // Rewind to BOT.

      RewindTape( ) ;

      // write 5 blocks of data followed by a short filemark and record offsets.

      WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

      if( status = WriteTapemark( gb_Tape_Handle,
                                  TAPE_SHORT_FILEMARKS,
                                  1,
                                  0
                                ) ) {
         DisplayDriverError( status ) ;
         printf( "  ...occurred in WriteTapemark API using TAPE_SHORT_FILEMARKS parameter.\n\n" ) ;
         ++API_Errors ;

      } else if( status = _GetTapePosition( &Offset_Low,
                                            &Offset_High
                                          ) ) {

                ++API_Errors ;

             } else printf( "Short Filemark written at %ld%ld.\n\n",Offset_High,Offset_Low ) ;



      // Now perform the Position test for the filemark and make
      // sure that the offsets are equal.

      if( !status ){   // If no error writing tapemark, check results.

         RewindTape( ) ;

         if( status = _SetTapePosition( Num_Test_Blocks,
                                        1                    // Forward
                                      ) ) {

            ++API_Errors ;

         }  else {  ReadTape( Readbuff,
                              gb_Media_Info.BlockSize,
                              &amount_read,
                              0 ) ;

                    // check and make sure we read a filemark

                    if( GetLastError( ) != ERROR_FILEMARK_DETECTED ) {

                       printf( "--- Error --->  Short filemark expected at %ld%ld, not found.\n\n", Offset_High, Offset_Low ) ;
                       ++API_Errors ;

                    }  else { printf( "\nShort Filemark confirmed at %ld%ld.\n\n", Offset_High, Offset_Low ) ;
                              printf( "Parameter Ok.\n\n\n" ) ;
                            }

                  }

      }

//
      if( SupportedFeature( TAPE_DRIVE_WRITE_MARK_IMMED ) ) {

         printf( "Testing TAPE_SHORT_FILEMARKS parameter (immed).\n\n" ) ;

         // Rewind to BOT.

         RewindTape( ) ;

         // write 5 blocks of data followed by a short filemark (IMMED) and record offsets.

         WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

         if( status = WriteTapemark( gb_Tape_Handle,
                                     TAPE_SHORT_FILEMARKS,
                                     1,
                                     1
                                   ) ) {
            DisplayDriverError( status ) ;
            printf( "  ...occurred in WriteTapemark API using TAPE_SHORT_FILEMARKS parameter (immed).\n\n" ) ;
            ++API_Errors ;

         } else {  // Loop until drive is ready to accept more commands.

                   status = 1 ;

                   while( status )
                      status = GetTapeStatus( gb_Tape_Handle ) ;


                   // Next, get the position for later tests.


                   if( status = _GetTapePosition( &Offset_Low,
                                                  &Offset_High
                                                ) ) {

                      ++API_Errors ;

                   } else printf( "Short Filemark (Immed.) written at %ld%ld.\n\n",Offset_High,Offset_Low ) ;

                }


         // Now perform the Position test for the filemark and make
         // sure that the offsets are equal.

         if( !status ){   // If no error writing tapemark, check results.

            RewindTape( ) ;

            if( status = _SetTapePosition( Num_Test_Blocks,
                                           1                      // Forward
                                         ) ) {

               ++API_Errors ;

            } else {  ReadTape( Readbuff,
                                gb_Media_Info.BlockSize,
                                &amount_read,
                                0 ) ;

                      // check and make sure we read a filemark

                      if( GetLastError( ) != ERROR_FILEMARK_DETECTED ) {

                         printf( "--- Error --->  Short filemark (immed.) expected at %ld%ld, not found.\n\n", Offset_High, Offset_Low ) ;
                         ++API_Errors ;

                      } else { printf( "\nShort Filemark (Immed.) confirmed at %ld%ld.\n\n",0 ,Num_Test_Blocks ) ;
                               printf( "Parameter Ok.\n\n\n" ) ;
                             }

                   }

         }

      }

   }


//
   if( SupportedFeature( TAPE_DRIVE_WRITE_LONG_FMKS ) &&
       ( SupportedFeature( TAPE_DRIVE_FILEMARKS ) || Test_Unsupported_Features ) ) {

      printf( "Testing TAPE_LONG_FILEMARKS parameter.\n\n" ) ;

      // Rewind to BOT.

      RewindTape( ) ;

      // write 5 blocks of data followed by a long filemark and record offsets.

      WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

      if( status = WriteTapemark( gb_Tape_Handle,
                                  TAPE_LONG_FILEMARKS,
                                  1,
                                  0
                                ) ) {
         DisplayDriverError( status ) ;
         printf( "  ...occurred in WriteTapemark API using TAPE_LONG_FILEMARKS parameter.\n\n" ) ;
         ++API_Errors ;

      } else if( status = _GetTapePosition( &Offset_Low,
                                            &Offset_High
                                          ) ) {

                ++API_Errors ;

             } else printf( "Long Filemark written at %ld%ld.\n\n",Offset_High,Offset_Low ) ;



      // Now perform the Position test for the filemark and make
      // sure that the offsets are equal.


      if( !status ){   // If no error writing tapemark, check results.

         RewindTape( ) ;

         if( status = _SetTapePosition( Num_Test_Blocks,
                                        1                    // Forward
                                      ) ) {

            ++API_Errors ;

         } else {  ReadTape( Readbuff,
                             gb_Media_Info.BlockSize,
                             &amount_read,
                             0 ) ;

                   // check and make sure we read a filemark

                   if( GetLastError( ) != ERROR_FILEMARK_DETECTED ) {

                      printf( "--- Error --->  Long filemark expected at %ld%ld, not found.\n\n", Offset_High, Offset_Low ) ;
                      ++API_Errors ;

                   } else { printf( "\nLong Filemark confirmed at %ld%ld.\n\n",0 ,Num_Test_Blocks ) ;
                            printf( "Parameter Ok.\n\n\n" ) ;
                          }

                }

      }


//
      if( SupportedFeature( TAPE_DRIVE_WRITE_MARK_IMMED ) ) {

         printf( "Testing TAPE_LONG_FILEMARKS parameter (immed).\n\n" ) ;

         //Rewind to BOT.

         RewindTape( ) ;

         // write 5 blocks of data followed by a long filemark (IMMED) and record offsets.

         WriteBlocks( Num_Test_Blocks, gb_Media_Info.BlockSize ) ;

         if( status = WriteTapemark( gb_Tape_Handle,
                                     TAPE_LONG_FILEMARKS,
                                     1,
                                     1
                                   ) ) {
            DisplayDriverError( status ) ;
            printf( "  ...occurred in WriteTapemark API using TAPE_LONG_FILEMARKS parameter (immed).\n\n" ) ;
            ++API_Errors ;

         } else {  // Loop until drive is ready to accept more commands.

                   status = 1 ;

                   while( status )
                      status = GetTapeStatus( gb_Tape_Handle ) ;


                   // Next, get the position for later tests.

                   if( status = _GetTapePosition( &Offset_Low,
                                                  &Offset_High
                                                ) ) {

                      ++API_Errors ;

                   } else printf( "Long Filemark (Immed.) written at %ld%ld.\n\n",Offset_High,Offset_Low ) ;

                }


         // Now perform the Position test for the filemark and make
         // sure that the offsets are equal.

         if( !status ){   // If no error writing tapemark, check results.

            RewindTape( ) ;

            if( status = _SetTapePosition( Num_Test_Blocks,
                                           1                    // Forward
                                         ) ) {

               ++API_Errors ;

            } else {  ReadTape( Readbuff,
                                gb_Media_Info.BlockSize,
                                &amount_read,
                                0 ) ;

                      // check and make sure we read a filemark

                      if( GetLastError( ) != ERROR_FILEMARK_DETECTED ) {

                         printf( "--- Error --->  Long filemark (immed.) expected at %ld%ld, not found.\n\n", Offset_High, Offset_Low ) ;
                         ++API_Errors ;

                      }  else { printf( "\nLong Filemark (Immed.) confirmed at %ld%ld.\n\n", Offset_High, Offset_Low ) ;
                                printf( "Parameter Ok.\n\n\n" ) ;
                              }

                    }
         }

      }

   }


   printf( "WriteTapemark API Test Completed.\n\n\n" ) ;

   free( Readbuff ) ;

   return API_Errors ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\test\testlib.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       testlib.c
//
//--------------------------------------------------------------------------


//
//  Windows NT Tape API Test  :  Written Sept 2, 1992 - Bob Rossi.
//  Copyright 1992 Archive Corporation.  All rights reserved.
//


/**
 *
 *      Unit:           Windows NT API Test Code.
 *
 *      Name:           testlib.c
 *
 *      Modified:       11/06/92.
 *
 *      Description:    Tests the Windows NT Tape API's.
 *
 *      $LOG$
**/



#include <stdio.h>
#include <ctype.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include "tapelib.h"
#include "globals.h"




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           FindChar( )
 *
 *      Modified:       9/29/92.
 *
 *      Description:    Locates 'c' in "str".
 *
 *      Notes:          -
 *
 *      Returns:        The index into "str" of the first occurence of c.  -1
 *                      if not found.
 *
 *      Global Data:    -
 *
**/

INT FindChar( UCHAR *str,     //  I - input string
              UCHAR c         //  I - char to search for in str
	    )
{
   UINT i=0 ;

   while( str[i] != '\0' ) {
      if( str[i] ==c ) {
	 return i ;
      }
      ++i ;
   }

   return (DWORD)(-1) ;

}




/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           PrintLine( )
 *
 *      Modified:       9/30/92.
 *
 *      Description:    Prints a line of character 'c' of length 'Length'
 *                      starting at column 1.
 *
 *      Notes:          -
 *
 *      Returns:        VOID.
 *
 *      Global Data:    -
 *
**/

VOID PrintLine( UCHAR c,           //  I - The character to printed
                UINT  Length       //  I - The length of line
               )
{
   UINT i ;

   printf( "\n" ) ;

   for( i=0 ; i<Length ; ++i )
     printf( "%c", c ) ;

   printf( "\n\n" ) ;

   return ;

}

/**
 *
 *      Unit:           Windows NT Tape API Test Code.
 *
 *      Name:           TapeWriteEnabled( )
 *
 *      Modified:       11/6/92.
 *
 *      Description:    Checks if the tape is write-protected or not.
 *
 *      Notes:          -
 *
 *      Returns:        True if the tape is not write-protected, else FALSE.
 *
 *      Global Data:    gb_Media_Info.WriteProtected
 *
**/

BOOL TapeWriteEnabled( )
{

   if( gb_Media_Info.WriteProtected ) {

      printf( "\n** Tape is write-protected. **\n\n" ) ;

      return FALSE ;
   }

   else return TRUE ;

}



/**
 *
 *      Unit:           Windows NT Test Code.
 *
 *      Name:           WriteBlocks( )
 *
 *      Modified:       9/16/92
 *
 *      Description:    Writes Num_Blocks of size Block_Size the device pointed
 *                      to by gb_Tape_Handle.  The function calls WriteTape( )
 *                      to perform the write operation and flushes the tape
 *                      buffer with a filemark by calling WriteTapeFMK( ).
 *
 *      Notes:          -
 *
 *      Returns:        -
 *
 *      Global Data:    -
 *
**/

VOID WriteBlocks( UINT  Num_Blocks,     // I  - Number of blocks to write
                  DWORD Block_Size      // I  - Size of block
                )
{
   UCHAR  *Buffer = NULL;
   UINT   i ;
   DWORD  status ;
   DWORD  amount ;


   printf( "\nWriting %d blocks of data to tape.\n\n",Num_Blocks ) ;

   // Allocate the tape buffer

   if( ( Buffer = malloc( Block_Size ) ) == NULL ) {
      printf( "Insufficient memory available to allocate buffer for block writes.\n\n" ) ;
      return ;
   }

   // fill Buffer with data (i).

   memset( Buffer, i, Block_Size ) ;

   // write Num_Blocks blocks of data

   for ( i=0 ; i<Num_Blocks ; ++i ) {

      if( WriteTape( Buffer, Block_Size, &amount , 1 ) )

         printf( "Write Failed.\n\n" );

      if ( amount != Block_Size )

        printf( "Write count wrong.  Block Size in INI file may be exceeding\n miniport driver's memory limits.\n " ) ;

   }

   printf( "\n\n" ) ;

   free( Buffer ) ;

   return ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\wangqic\wangqic.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       wangqic.c
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1994 - Arcada Software Inc. - All rights reserved

Module Name:

    wangqic.c

Abstract:

    This module contains the device-specific routines for Wangtek QIC
    drives.

Author:

    Mike Colandreo (Arcada)

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"

//
//  Internal (module wide) defines that symbolize
//  non-QFA mode and the two QFA mode partitions.
//
#define NOT_PARTITIONED      0  // non-QFA mode
#define DIRECTORY_PARTITION  1  // QFA mode, directory partition #
#define DATA_PARTITION       2  // QFA mode, data partition #

//
//  Internal (module wide) defines that symbolize
//  the Wangtek QIC drives supported by this module.
//
#define WANGTEK_5150    1  // aka the Wangtek 150
#define WANGTEK_5525    2  // aka the Wangtek 525
#define WANGTEK_5360    3  // aka the Tecmar 720
#define WANGTEK_9500    4
#define WANGTEK_9500DC  5
#define WANGTEK_5100    6  // aka the Wangtek 525


#define QIC_SUPPORTED_TYPES 1
STORAGE_MEDIA_TYPE QicMedia[QIC_SUPPORTED_TYPES] = {QIC};

//
// Minitape extension definition.
//
typedef struct _MINITAPE_EXTENSION {
          ULONG DriveID ;
          ULONG CurrentPartition ;
          BOOLEAN CompressionOn ;
} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION ;

//
// Command extension definition.
//

typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;
    UCHAR   densityCode;
    UCHAR   mediumType;
    ULONG   tapeBlockLength;
    BOOLEAN changePartition ;
    BOOLEAN final9500call ;
    ULONG   psudo_space_count ;
    ULONG   pos_type ;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

//
//  Function Prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);


BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = VerifyInquiry;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = TapeError ;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = QIC_SUPPORTED_TYPES;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}

BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine examines the given inquiry data to determine whether
    or not the given device is one that may be controller by this driver.

Arguments:

    InquiryData - Supplies the SCSI inquiry data.

Return Value:

    FALSE   - This driver does not recognize the given device.

    TRUE    - This driver recognizes the given device.

--*/

{
    return WhichIsIt(InquiryData) ? TRUE : FALSE;
}

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData);
    extension->CurrentPartition = 0 ;
    extension->CompressionOn = FALSE ;
}


TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION      extension = MinitapeExtension;
    PCOMMAND_EXTENSION       tapeCmdExtension = CommandExtension ;
    PTAPE_CREATE_PARTITION   tapePartition = CommandParameters;
    PMODE_MEDIUM_PART_PAGE   modeSelectBuffer;
    PCDB                     cdb = (PCDB) Srb->Cdb;

    //
    //  Only support 2 partitions, QFA mode
    //  Partition 1 = Used as directory
    //  Partition 0 = used as data
    //
    //  Note that 0 & 1 are partition numbers used
    //  by the drive -- they are not tape API partition
    //  numbers.
    //

    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));

    if (CallNumber == 0) {

        //
        // Filter out invalid partition methods.
        //

        switch (tapePartition->Method) {
            case TAPE_FIXED_PARTITIONS:
                DebugPrint((3,"TapeCreatePartition: fixed partitions\n"));
                break;

            case TAPE_SELECT_PARTITIONS:
            case TAPE_INITIATOR_PARTITIONS:
            default:
                DebugPrint((1,"TapeCreatePartition: "));
                DebugPrint((1,"PartitionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Must rewind to BOT before one can enable/disable QFA mode.
        // Changing the state of QFA mode is only valid at BOT.
        //

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 480;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (rewind)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 1 ) {

        //
        //  A successful rewind also confirms that there is a tape in the drive.
        //

        //
        //  Now enable/disable QFA mode in either SCSI-2 fashion or SCSI-1
        //  fashion depending on what sort of drive this is.
        //

        switch (extension->DriveID) {
            case WANGTEK_9500:
            case WANGTEK_9500DC:
                //
                // Performing mode select command, medium partition parameters page,
                // to enable/disable QFA mode: set the FDP bit accordingly.
                //

                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_MEDIUM_PART_PAGE)) ) {
                    DebugPrint((1,"TapeCreatePartition: insufficient resources (modeSelectBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                modeSelectBuffer = Srb->DataBuffer ;

                modeSelectBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;

                modeSelectBuffer->MediumPartPage.PageCode = MODE_PAGE_MEDIUM_PARTITION;
                modeSelectBuffer->MediumPartPage.PageLength = 0x06;
                modeSelectBuffer->MediumPartPage.MaximumAdditionalPartitions = 1;

                //
                // Setup FDP bit to enable/disable "additional partition".
                //

                if (tapePartition->Count == 0) {
                    modeSelectBuffer->MediumPartPage.FDPBit = SETBITOFF;
                } else {
                    modeSelectBuffer->MediumPartPage.FDPBit = SETBITON;
                }

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;

                cdb->MODE_SELECT.OperationCode  = SCSIOP_MODE_SELECT;
                cdb->MODE_SELECT.PFBit = SETBITON;
                cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeCreatePartition: SendSrb (mode select)\n"));
                Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4 ;
                Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

            default:

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;
                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->PARTITION.OperationCode = SCSIOP_PARTITION;
                cdb->PARTITION.Sel = 1;
                cdb->PARTITION.PartitionSelect =
                    tapePartition->Count? DATA_PARTITION : NOT_PARTITIONED;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeCreatePartition: SendSrb (partition)\n"));
                Srb->DataTransferLength = 0 ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        }
    }

    ASSERT( CallNumber == 2 )  ;

    if (tapePartition->Count == 0) {
        extension->CurrentPartition = NOT_PARTITIONED;
        DebugPrint((3,"TapeCreatePartition: QFA disabled\n"));
    } else {
        extension->CurrentPartition = DATA_PARTITION;
        DebugPrint((3,"TapeCreatePartition: QFA enabled\n"));
    }

    return TAPE_STATUS_SUCCESS ;

} // end TapeCreatePartition()


TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION      extension = MinitapeExtension;
    PTAPE_ERASE              tapeErase = CommandParameters;
    PCDB                     cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            switch (extension->DriveID) {
                case WANGTEK_5150:
                case WANGTEK_5360:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }

            DebugPrint((3,"TapeErase: immediate\n"));
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = SETBITON;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 480;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    ASSERT( CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS;

} // end TapeErase()


VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer;
    UCHAR              senseKey;
    UCHAR              adsenseq;
    UCHAR              adsense;

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       senseBuffer = Srb->SenseInfoBuffer;
       senseKey = senseBuffer->SenseKey & 0x0F;
       adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
       adsense = senseBuffer->AdditionalSenseCode;

       if (*LastError == TAPE_STATUS_IO_DEVICE_ERROR) {
           if ((senseKey == SCSI_SENSE_ABORTED_COMMAND) &&
               (adsense  == 0x5A) &&
               (adsenseq == 0x01) ){    //operator medium removal request
   
               *LastError = TAPE_STATUS_NO_MEDIA;
   
           }
       }
    }

    DebugPrint((1,"TapeError: Status 0x%.8X \n", *LastError));

    return;

} // end TapeError()



TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          cmdExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimitsBuffer;
    PMODE_PARM_READ_WRITE_DATA  blockDescripterModeSenseBuffer;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if(!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockDescripterModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockDescripterModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if (CallNumber == 1 ) {
        blockDescripterModeSenseBuffer = Srb->DataBuffer ;

        if (LastError == TAPE_STATUS_SUCCESS) {

            cmdExtension->mediumType  =  blockDescripterModeSenseBuffer->ParameterListHeader.MediumType;
            cmdExtension->densityCode =  blockDescripterModeSenseBuffer->ParameterListBlock.DensityCode;
            cmdExtension->tapeBlockLength  =  blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[2];
            cmdExtension->tapeBlockLength += (blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[1] << 8);
            cmdExtension->tapeBlockLength += (blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[0] << 16);

        } else {

            cmdExtension->mediumType      = DC6150;
            cmdExtension->densityCode     = QIC_XX;
            cmdExtension->tapeBlockLength = 512;


            if (((extension->DriveID == WANGTEK_5150) || (extension->DriveID == WANGTEK_5360))
                 && (LastError == TAPE_STATUS_DEVICE_NOT_READY)) {

                LastError = TAPE_STATUS_SUCCESS;

            } else {

                DebugPrint((1,"TapeGetDriveParameters: mode sense, SendSrb unsuccessful\n"));
                return LastError;

            }

        }
        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(READ_BLOCK_LIMITS_DATA)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimitsBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimitsBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));
        Srb->DataTransferLength = sizeof(READ_BLOCK_LIMITS_DATA) ;
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if (CallNumber == 2) {
        blockLimitsBuffer = Srb->DataBuffer ;

        if (LastError == TAPE_STATUS_SUCCESS) {
            tapeGetDriveParams->MaximumBlockSize  =  blockLimitsBuffer->BlockMaximumSize[2];
            tapeGetDriveParams->MaximumBlockSize += (blockLimitsBuffer->BlockMaximumSize[1] << 8);
            tapeGetDriveParams->MaximumBlockSize += (blockLimitsBuffer->BlockMaximumSize[0] << 16);

            tapeGetDriveParams->MinimumBlockSize  =  blockLimitsBuffer->BlockMinimumSize[1];
            tapeGetDriveParams->MinimumBlockSize += (blockLimitsBuffer->BlockMinimumSize[0] << 8);
        } else {
            tapeGetDriveParams->MaximumBlockSize = 512;
            tapeGetDriveParams->MinimumBlockSize = 512;

            if (((extension->DriveID == WANGTEK_5150)||(extension->DriveID == WANGTEK_5360)) &&
                   (LastError == TAPE_STATUS_DEVICE_NOT_READY)) {

                LastError = TAPE_STATUS_SUCCESS;

            } else {

                DebugPrint((1,"TapeGetDriveParameters: read block limits, SendSrb unsuccessful\n"));
                return LastError;

            }

        }

        if ((extension->DriveID != WANGTEK_9500) && (extension->DriveID != WANGTEK_9500DC)) {
            return TAPE_STATUS_CALLBACK ;
        }
        //
        // wangtek 9500 only
        //

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if (CallNumber == 3 ) {
        if ((extension->DriveID != WANGTEK_9500) && (extension->DriveID != WANGTEK_9500DC)) {
            return TAPE_STATUS_CALLBACK ;
        }
        //
        // wangtek 9500 only
        //

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;
        if (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk) {

            tapeGetDriveParams->ReportSetmarks = TRUE;

        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT(CallNumber == 4 ) ;
    if ((extension->DriveID == WANGTEK_9500) || (extension->DriveID == WANGTEK_9500DC)) {
        //
        // wangtek 9500 only
        //
        compressionModeSenseBuffer = Srb->DataBuffer ;

        if (compressionModeSenseBuffer->DataCompressPage.DCC) {

            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
               (compressionModeSenseBuffer->DataCompressPage.DCE? TRUE : FALSE);

        }

    }

    switch (extension->DriveID) {
        case WANGTEK_9500:
        case WANGTEK_9500DC:
            tapeGetDriveParams->ECC = 0;
            tapeGetDriveParams->DataPadding = 0;
            tapeGetDriveParams->MaximumPartitionCount = 2;

            switch (cmdExtension->densityCode) {
                case QIC_XX:
                    switch (cmdExtension->mediumType) {
                        case DC6320:
                        case DC6525:
                        case DC9100:
                        case DC9120:
                        case DC9120SL:
                        case DC9120XL:
                        case DC9200SL:
                        case DC9200:
                        case DC9200XL:
                        case DC9500:
                        case DC9500SL:
                             tapeGetDriveParams->DefaultBlockSize = cmdExtension->tapeBlockLength;

                             tapeGetDriveParams->FeaturesLow |=
                                    TAPE_DRIVE_GET_LOGICAL_BLK;
                             tapeGetDriveParams->FeaturesHigh |=
                                    TAPE_DRIVE_LOGICAL_BLK ;
                             break;

                         default:
                             tapeGetDriveParams->DefaultBlockSize = 512;
                             break;
                     }
                     break;

                 case QIC_525:
                 case QIC_1000:
                 case QIC_1000C:
                 case QIC_2GB:
//                 case QIC_5GB:
                     tapeGetDriveParams->FeaturesLow |=
                           TAPE_DRIVE_GET_LOGICAL_BLK;
                     tapeGetDriveParams->FeaturesHigh |=
                           TAPE_DRIVE_LOGICAL_BLK ;

                     tapeGetDriveParams->DefaultBlockSize = cmdExtension->tapeBlockLength;
                     break;

                 default:
                     tapeGetDriveParams->DefaultBlockSize = 512;
                     break;
            }

            tapeGetDriveParams->FeaturesLow |=
                 TAPE_DRIVE_FIXED |
                 TAPE_DRIVE_ERASE_LONG |
                 TAPE_DRIVE_ERASE_BOP_ONLY |
                 TAPE_DRIVE_ERASE_IMMEDIATE |
                 TAPE_DRIVE_FIXED_BLOCK |
                 TAPE_DRIVE_WRITE_PROTECT |
                 TAPE_DRIVE_REPORT_SMKS |
                 TAPE_DRIVE_GET_ABSOLUTE_BLK ;

            tapeGetDriveParams->FeaturesHigh |=
                 TAPE_DRIVE_LOAD_UNLOAD |
                 TAPE_DRIVE_TENSION |
                 TAPE_DRIVE_LOCK_UNLOCK |
                 TAPE_DRIVE_REWIND_IMMEDIATE |
                 TAPE_DRIVE_SET_BLOCK_SIZE |
                 TAPE_DRIVE_LOAD_UNLD_IMMED |
                 TAPE_DRIVE_TENSION_IMMED |
                 TAPE_DRIVE_SET_REPORT_SMKS |
                 TAPE_DRIVE_ABSOLUTE_BLK |
                 TAPE_DRIVE_END_OF_DATA |
                 TAPE_DRIVE_RELATIVE_BLKS |
                 TAPE_DRIVE_FILEMARKS |
                 TAPE_DRIVE_SEQUENTIAL_FMKS |
                 TAPE_DRIVE_REVERSE_POSITION |
                 TAPE_DRIVE_WRITE_FILEMARKS |
                 TAPE_DRIVE_WRITE_SETMARKS |
                 TAPE_DRIVE_WRITE_MARK_IMMED;
            break;

        default:
            tapeGetDriveParams->ECC = 0;
            tapeGetDriveParams->Compression = 0;
            tapeGetDriveParams->DataPadding = 0;
            tapeGetDriveParams->ReportSetmarks = 0;
            tapeGetDriveParams->MaximumPartitionCount = 2;

            switch (cmdExtension->densityCode) {
                case QIC_XX:
                    switch (cmdExtension->mediumType) {
                        case DC6320:
                        case DC6525:
                            tapeGetDriveParams->DefaultBlockSize = 1024;
                            break;

                        default:
                            tapeGetDriveParams->DefaultBlockSize = 512;
                            break;
                    }
                    break;

                case QIC_525:
                case QIC_1000:
                    tapeGetDriveParams->DefaultBlockSize = 1024;
                    break;

                default:
                    tapeGetDriveParams->DefaultBlockSize = 512;
                    break;
            }

            if ( (extension->DriveID == WANGTEK_5525) ||
                 (extension->DriveID == WANGTEK_5100) ) {

                tapeGetDriveParams->FeaturesLow |=
                    TAPE_DRIVE_ERASE_IMMEDIATE;

                tapeGetDriveParams->FeaturesHigh |=
                    TAPE_DRIVE_SET_BLOCK_SIZE;

            } else if ((extension->DriveID == WANGTEK_9500) || (extension->DriveID == WANGTEK_9500DC)) {
                tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_EJECT_MEDIA;
                tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_VARIABLE_BLOCK;

            }

            tapeGetDriveParams->FeaturesLow |=
                TAPE_DRIVE_FIXED |
                TAPE_DRIVE_ERASE_LONG |
                TAPE_DRIVE_ERASE_BOP_ONLY |
                TAPE_DRIVE_FIXED_BLOCK |
                TAPE_DRIVE_WRITE_PROTECT |
                TAPE_DRIVE_GET_ABSOLUTE_BLK ;

            if ( extension->DriveID != WANGTEK_5360 ) {
                 tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_GET_LOGICAL_BLK;
            }

            tapeGetDriveParams->FeaturesHigh |=
                TAPE_DRIVE_LOAD_UNLOAD |
                TAPE_DRIVE_TENSION |
                TAPE_DRIVE_LOCK_UNLOCK |
                TAPE_DRIVE_REWIND_IMMEDIATE |
                TAPE_DRIVE_LOAD_UNLD_IMMED |
                TAPE_DRIVE_TENSION_IMMED |
                TAPE_DRIVE_ABSOLUTE_BLK |
                TAPE_DRIVE_END_OF_DATA |
                TAPE_DRIVE_RELATIVE_BLKS |
                TAPE_DRIVE_FILEMARKS |
                TAPE_DRIVE_SEQUENTIAL_FMKS |
                TAPE_DRIVE_REVERSE_POSITION |
                TAPE_DRIVE_WRITE_FILEMARKS ;
                TAPE_DRIVE_WRITE_MARK_IMMED;

            if ( extension->DriveID != WANGTEK_5360 ) {
                 tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_LOGICAL_BLK ;
            }

            if ( extension->DriveID != WANGTEK_5100 ) {
                 tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_WRITE_MARK_IMMED;
            }

            break;

    }

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
        tapeGetDriveParams->FeaturesLow));
    DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
        tapeGetDriveParams->FeaturesHigh));

    return TAPE_STATUS_SUCCESS;

} // end TapeGetDriveParameters()

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigBuffer;
    PMODE_PARM_READ_WRITE_DATA   modeBuffer;
    PUCHAR                       partitionBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if ( (extension->DriveID == WANGTEK_9500)||(extension->DriveID == WANGTEK_9500DC) ) {

        if (CallNumber == 1) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
                DebugPrint((1,"TapeGetMediaParameters: insufficient resources (mediaInfoBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            mediaInfoBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense #1)\n"));
            Srb->DataTransferLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }

        if (CallNumber == 2 ) {
            mediaInfoBuffer = Srb->DataBuffer ;

            tapeGetMediaParams->BlockSize  = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
            tapeGetMediaParams->BlockSize += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
            tapeGetMediaParams->BlockSize += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);

            tapeGetMediaParams->WriteProtected =
                ((mediaInfoBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

            if (mediaInfoBuffer->MediumPartPage.FDPBit) {

                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
                    DebugPrint((1,"TapeGetMediaParameters: insufficient resources (deviceConfigBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                deviceConfigBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;
                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.Dbd = SETBITON;
                cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
                cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense #2)\n"));
                Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

            } else {
                return TAPE_STATUS_CALLBACK ;
            }

        }

        ASSERT(CallNumber == 3) ;

        if (LastError == TAPE_STATUS_CALLBACK ) {

            tapeGetMediaParams->PartitionCount = 1 ;
            extension->CurrentPartition = NOT_PARTITIONED;

        } else {

            deviceConfigBuffer = Srb->DataBuffer ;

            extension->CurrentPartition =
                deviceConfigBuffer->DeviceConfigPage.ActivePartition?
                DIRECTORY_PARTITION : DATA_PARTITION;

            tapeGetMediaParams->PartitionCount = 2;

        }

    } else {  // non 9500 drives

        if (CallNumber == 1) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
                DebugPrint((1,"TapeGetMediaParameters: insufficient resources (modeBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            modeBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));
            Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }

        ASSERT(CallNumber == 2) ;

        modeBuffer = Srb->DataBuffer ;

        tapeGetMediaParams->BlockSize  = modeBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);


        tapeGetMediaParams->WriteProtected =
             ((modeBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);


        tapeGetMediaParams->PartitionCount = extension->CurrentPartition? 2 : 1 ;

    }

    return TAPE_STATUS_SUCCESS;

} // end TapeGetMediaParameters()



TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          cmdExtension = CommandExtension;
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigBuffer;
    PTAPE_POSITION_DATA         readPositionBuffer;
    PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;
    PMODE_PARM_READ_WRITE_DATA   modeBuffer;
    PUCHAR                       partitionBuffer;
    PUCHAR                       absoluteBuffer;
    ULONG                       type;
    ULONG                        tapeBlockAddress;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        cmdExtension->pos_type = tapeGetPosition->Type;
        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;
        cmdExtension->pos_type = type ;
        cmdExtension->final9500call = FALSE ;

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (!cmdExtension->final9500call &&
        ((extension->DriveID == WANGTEK_9500)||(extension->DriveID == WANGTEK_9500DC)) )  {

        if (tapeGetPosition->Type == TAPE_LOGICAL_POSITION) {

            if ( CallNumber == 1 ) {

                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (mediaInfoBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                mediaInfoBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;
                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
                cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (mode sense #1)\n"));
                Srb->DataTransferLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
            }

            if (CallNumber == 2 ) {

                mediaInfoBuffer = Srb->DataBuffer ;

                cmdExtension->densityCode      = mediaInfoBuffer->ParameterListBlock.DensityCode;
                cmdExtension->tapeBlockLength  = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
                cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
                cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);

                if (!mediaInfoBuffer->MediumPartPage.FDPBit) {
                    return TAPE_STATUS_CALLBACK ;

                } else {

                    if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
                        DebugPrint((1,"TapeGetPosition: insufficient resources (deviceConfigBuffer)\n"));
                        return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                    }

                    deviceConfigBuffer = Srb->DataBuffer ;

                    //
                    // Prepare SCSI command (CDB)
                    //

                    Srb->CdbLength = CDB6GENERIC_LENGTH;
                    TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                    cdb->MODE_SENSE.Dbd = SETBITON;
                    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
                    cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

                    //
                    // Send SCSI command (CDB) to device
                    //

                    DebugPrint((3,"TapeGetPosition: SendSrb (mode sense #2)\n"));
                    Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

                    return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
                }
            }

            if (CallNumber == 3 ) {
                if (LastError != TAPE_STATUS_CALLBACK ) {

                    deviceConfigBuffer = Srb->DataBuffer ;

                    extension->CurrentPartition =
                         deviceConfigBuffer->DeviceConfigPage.ActivePartition?
                         DIRECTORY_PARTITION : DATA_PARTITION;

                } else {

                    extension->CurrentPartition = NOT_PARTITIONED;

                }

                if (cmdExtension->densityCode != QIC_2GB) {
                    return TAPE_STATUS_CALLBACK ;

                } else {

                    if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
                        DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
                        return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                    }

                    compressionModeSenseBuffer = Srb->DataBuffer ;

                    //
                    // Prepare SCSI command (CDB)
                    //

                    Srb->CdbLength = CDB6GENERIC_LENGTH;
                    TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                    cdb->MODE_SENSE.Dbd = SETBITON;
                    cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
                    cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

                    //
                    // Send SCSI command (CDB) to device
                    //

                    DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));
                    Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

                    return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
                }
            }
            ASSERT (CallNumber == 4) ;
            if (LastError != TAPE_STATUS_CALLBACK ) {
                compressionModeSenseBuffer = Srb->DataBuffer ;
                if (!compressionModeSenseBuffer->DataCompressPage.DCE) {
                    cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_POSITION;
                }
            }

            if (cmdExtension->densityCode != QIC_5GB) {

               cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_POSITION;
            }
        }

        switch (cmdExtension->pos_type) {
            case TAPE_ABSOLUTE_POSITION:
                DebugPrint((3,"TapeGetPosition: absolute\n"));
                if (cmdExtension->densityCode == QIC_5GB) {
                    cmdExtension->pos_type = TAPE_LOGICAL_POSITION;
                }
                break;

            case TAPE_LOGICAL_POSITION:
                DebugPrint((3,"TapeGetPosition: logical\n"));
                break;

            case TAPE_PSEUDO_LOGICAL_POSITION:
                DebugPrint((3,"TapeGetPosition: pseudo logical\n"));
                break;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;

        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(TAPE_POSITION_DATA)) ) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (readPositionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }


        readPositionBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB10GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;
        cdb->READ_POSITION.BlockType = (cmdExtension->pos_type == TAPE_LOGICAL_POSITION)?
                                      SETBITOFF : SETBITON;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));
        Srb->DataTransferLength = sizeof(TAPE_POSITION_DATA) ;

        cmdExtension->final9500call = TRUE ;
        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (cmdExtension->final9500call) {
        cmdExtension->final9500call = FALSE ;

        readPositionBuffer = Srb->DataBuffer ;

        REVERSE_BYTES((PFOUR_BYTE)&tapeBlockAddress,
                      (PFOUR_BYTE)readPositionBuffer->FirstBlock);


        if (cmdExtension->pos_type == TAPE_PSEUDO_LOGICAL_POSITION) {
            tapeBlockAddress =
                TapeClassPhysicalBlockToLogicalBlock(
                    cmdExtension->densityCode,
                    tapeBlockAddress,
                    cmdExtension->tapeBlockLength,
                    (BOOLEAN)(
                        (extension->CurrentPartition
                            == DIRECTORY_PARTITION)?
                        NOT_FROM_BOT : FROM_BOT
                        )
                );
        }

        tapeGetPosition->Offset.HighPart = 0;
        tapeGetPosition->Offset.LowPart  = tapeBlockAddress;

        if (cmdExtension->pos_type != TAPE_ABSOLUTE_POSITION) {
            tapeGetPosition->Partition = extension->CurrentPartition;
        }
    }
    if ((extension->DriveID != WANGTEK_9500)&&(extension->DriveID != WANGTEK_9500DC) )  {

        if (CallNumber == 1 ) {
            if (cmdExtension->pos_type != TAPE_LOGICAL_POSITION) {
                return TAPE_STATUS_CALLBACK ;
            } else {

                DebugPrint((3,"TapeGetPosition: pseudo logical\n"));

                cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_POSITION;

                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(UCHAR)*2) ) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (partitionBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                partitionBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;
                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->PARTITION.OperationCode = SCSIOP_PARTITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (partition)\n"));
                Srb->DataTransferLength = sizeof(UCHAR) ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
            }
        }
        if (CallNumber == 2 ) {

            if ( LastError == TAPE_STATUS_CALLBACK ) {
                return TAPE_STATUS_CALLBACK ;
            }

            partitionBuffer = Srb->DataBuffer ;

            extension->CurrentPartition = *partitionBuffer;

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
                DebugPrint((1,"TapeGetPosition: insufficient resources (modeBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            modeBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetPosition: SendSrb (mode sense)\n"));
            Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }
        if (CallNumber == 3 ) {

            if ( LastError != TAPE_STATUS_CALLBACK ) {

                modeBuffer = Srb->DataBuffer ;

                cmdExtension->densityCode = modeBuffer->ParameterListBlock.DensityCode;
                cmdExtension->tapeBlockLength  = modeBuffer->ParameterListBlock.BlockLength[2];
                cmdExtension->tapeBlockLength += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
                cmdExtension->tapeBlockLength += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);
            }


            if ( (cmdExtension->pos_type!=TAPE_PSEUDO_LOGICAL_POSITION)&&
                 (cmdExtension->pos_type!=TAPE_ABSOLUTE_POSITION) ){

                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
            }

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(UCHAR)*3) ) {
                DebugPrint((1,"TapeGetPosition: insufficient resources (absoluteBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            absoluteBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->REQUEST_BLOCK_ADDRESS.OperationCode = SCSIOP_REQUEST_BLOCK_ADDR;

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetPosition: SendSrb (request block address)\n"));
            Srb->DataTransferLength = sizeof(UCHAR)*3 ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }

        ASSERT (CallNumber == 4) ;
        absoluteBuffer = Srb->DataBuffer ;

        tapeBlockAddress  = absoluteBuffer[2];
        tapeBlockAddress += (absoluteBuffer[1] << 8);
        tapeBlockAddress += (absoluteBuffer[0] << 16);

        if (cmdExtension->pos_type == TAPE_ABSOLUTE_POSITION) {
            tapeGetPosition->Partition  = 0;
            tapeGetPosition->Offset.HighPart = 0;
            tapeGetPosition->Offset.LowPart  = tapeBlockAddress;

        } else {

            tapeBlockAddress =
                TapeClassPhysicalBlockToLogicalBlock(
                    cmdExtension->densityCode,
                    tapeBlockAddress,
                    cmdExtension->tapeBlockLength,
                    (BOOLEAN)(
                        (extension->CurrentPartition
                            == DIRECTORY_PARTITION)?
                        NOT_FROM_BOT : FROM_BOT
                    )
                );

            tapeGetPosition->Offset.HighPart = 0;
            tapeGetPosition->Offset.LowPart  = tapeBlockAddress;
            tapeGetPosition->Partition = extension->CurrentPartition;
        }

    }

    return TAPE_STATUS_SUCCESS;

} // end TapeGetPosition()


TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCDB    cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;

} // end TapeGetStatus()


TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_PREPARE      tapePrepare = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                case TAPE_TENSION:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_LOCK:
                case TAPE_UNLOCK:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;
        Srb->TimeOutValue = 480;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                break;

            case TAPE_TENSION:
                DebugPrint((3,"TapePrepare: Operation == tension\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                break;

            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    ASSERT(CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapePrepare()


TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          cmdExtension = CommandExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;
    PMODE_DEVICE_CONFIG_PAGE    configBuffer;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0 ) {

        if ((extension->DriveID != WANGTEK_9500) && (extension->DriveID != WANGTEK_9500DC) ){
            return TAPE_STATUS_NOT_IMPLEMENTED ;
        }

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        configBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 1 ) {

        configBuffer = Srb->DataBuffer ;

        configBuffer->ParameterListHeader.ModeDataLength = 0;
        configBuffer->ParameterListHeader.MediumType = 0;
        configBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        configBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        configBuffer->DeviceConfigPage.PS = SETBITOFF;
        configBuffer->DeviceConfigPage.PageCode = MODE_PAGE_DEVICE_CONFIG;
        configBuffer->DeviceConfigPage.PageLength = 0x0E;

        if (tapeSetDriveParams->ReportSetmarks) {
            configBuffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            configBuffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if (CallNumber == 2 ) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3 ) {

        compressionBuffer = Srb->DataBuffer ;

        if (compressionBuffer->DataCompressPage.DCC) {

            compressionBuffer->ParameterListHeader.ModeDataLength = 0;
            compressionBuffer->ParameterListHeader.MediumType = 0;
            compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
            compressionBuffer->ParameterListHeader.BlockDescriptorLength = 0;

            compressionBuffer->DataCompressPage.Reserved1  = 0;
            compressionBuffer->DataCompressPage.PageCode   = MODE_PAGE_DATA_COMPRESS;
            compressionBuffer->DataCompressPage.PageLength = 0x0E;

            if (tapeSetDriveParams->Compression) {
                compressionBuffer->DataCompressPage.DCE = SETBITON;
                compressionBuffer->DataCompressPage.CompressionAlgorithm[3]= 3;
            } else {
                compressionBuffer->DataCompressPage.DCE = SETBITOFF;
            }

            compressionBuffer->DataCompressPage.DDE = SETBITON;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
            cdb->MODE_SELECT.PFBit = SETBITON;
            cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));
            Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;
            *RetryFlags |= RETURN_ERRORS;
            Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        } else {

            return TAPE_STATUS_CALLBACK ;
        }
    }
    ASSERT(CallNumber == 4 ) ;

    if (LastError == TAPE_STATUS_INVALID_DEVICE_REQUEST) {
        LastError = TAPE_STATUS_SUCCESS;
    }
    if (LastError == TAPE_STATUS_CALLBACK) {
        LastError = TAPE_STATUS_SUCCESS;
    }

    return TAPE_STATUS_SUCCESS;

} // end TapeSetDriveParameters()


TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          cmdExtension = CommandExtension;
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  blockDescripterModeSenseBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if ((extension->DriveID == WANGTEK_9500) || (extension->DriveID == WANGTEK_9500DC)) {

        if (CallNumber == 0) {
            return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
        }
        if (CallNumber == 1) {

            if( !TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
                DebugPrint((1,"TapeSetDriveParameters: insufficient resources (blockDescripterModeSenseBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            blockDescripterModeSenseBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));
            Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }

        if (CallNumber == 2 ) {

            blockDescripterModeSenseBuffer = Srb->DataBuffer ;

            if (cmdExtension->tapeBlockLength != tapeSetMediaParams->BlockSize) {

                TapeClassZeroMemory(blockDescripterModeSenseBuffer, sizeof(MODE_PARM_READ_WRITE_DATA));

                blockDescripterModeSenseBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
                blockDescripterModeSenseBuffer->ParameterListHeader.BlockDescriptorLength = MODE_BLOCK_DESC_LENGTH;

                blockDescripterModeSenseBuffer->ParameterListBlock.DensityCode = 0x7F;
                blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[0] =
                    (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
                blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[1] =
                    (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
                blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[2] =
                    (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;
                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
                cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));
                Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA);
                Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
            } else {
               return TAPE_STATUS_SUCCESS ;
            }
        }
        return TAPE_STATUS_SUCCESS ;

    } else {  //non 9500

        if ( CallNumber == 0 ) {
            if ((extension->DriveID == WANGTEK_5150) || (extension->DriveID == WANGTEK_5360) ) {
                DebugPrint((1,"TapeSetMediaParameters: driveID -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
            }

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetMediaParameters: SendSrb (test unit ready)\n"));
            Srb->DataTransferLength = 0 ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }

        if ( CallNumber == 1 ) {


            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
                DebugPrint((1,"TapeSetMediaParameters: insufficient resources (blockDescripterModeSenseBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            blockDescripterModeSenseBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode sense)\n"));
            Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }

        if (CallNumber == 2 ) {
            blockDescripterModeSenseBuffer = Srb->DataBuffer ;


            if (tapeSetMediaParams->BlockSize) {
                blockDescripterModeSenseBuffer->ParameterListHeader.ModeDataLength = 0;
                blockDescripterModeSenseBuffer->ParameterListHeader.MediumType = 0;
                blockDescripterModeSenseBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
                blockDescripterModeSenseBuffer->ParameterListHeader.BlockDescriptorLength = MODE_BLOCK_DESC_LENGTH;

                blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[0] =
                    (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
                blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[1] =
                    (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
                blockDescripterModeSenseBuffer->ParameterListBlock.BlockLength[2] =
                    (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);
            } else {
               DebugPrint((1,
                           "SetMediaParameters: Tried to set variable block size\n"));
               return TAPE_STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
            cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

            Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;
            Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        }

        ASSERT(CallNumber == 3 );

        return TAPE_STATUS_SUCCESS;
    }

} // end TapeSetMediaParameters()

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION          extension = MinitapeExtension;
    PCOMMAND_EXTENSION           cmdExtension = CommandExtension ;
    PTAPE_SET_POSITION           tapeSetPosition = CommandParameters;
    PMODE_DATA_COMPRESS_PAGE     compressionModeSenseBuffer;
    PMODE_DEVICE_CONFIG_PAGE     deviceConfigBuffer;
    PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;
    PMODE_PARM_READ_WRITE_DATA   modeBuffer;
    PINQUIRYDATA                 inquiryBuffer;
    TAPE_PHYS_POSITION           physPosition;
    PUCHAR                       partitionBuffer;
    ULONG                        tapePositionVector;
    ULONG                        tapeBlockLength;
    ULONG                        driveID;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (((tapeSetPosition->Method) == TAPE_LOGICAL_BLOCK) &&
            ((extension->DriveID) == WANGTEK_5360)) {
            DebugPrint((1, 
                        "TAPE_LOGICAL_BLOCK not supported for WANGTEK 5360\n"));
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        cmdExtension->changePartition = FALSE;
        cmdExtension->pos_type = tapeSetPosition->Method ;

        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                    DebugPrint((3,"TapeSetPosition: immediate\n"));
                    break;

                case TAPE_LOGICAL_BLOCK:
                case TAPE_ABSOLUTE_BLOCK:
                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:
                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        tapePositionVector = tapeSetPosition->Offset.LowPart;
        cmdExtension->CurrentState = 0 ;
    }

    if (cmdExtension->CurrentState == 0 ) {

        if ( (extension->DriveID != WANGTEK_9500) && (extension->DriveID != WANGTEK_9500) ) {
            cmdExtension->CurrentState = 50 ;

        } else {

            if (cmdExtension->pos_type != TAPE_LOGICAL_BLOCK) {
               cmdExtension->CurrentState = 10 ;

            } else {

                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
                    DebugPrint((1,"TapeSetPosition: insufficient resources (mediaInfoBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                mediaInfoBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;
                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
                cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeSetPosition: SendSrb (mode sense #1)\n"));
                Srb->DataTransferLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

                cmdExtension->CurrentState = 1 ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
            }
        }
    }
    if (cmdExtension->CurrentState == 1) {
        mediaInfoBuffer = Srb->DataBuffer ;

        cmdExtension->densityCode      = mediaInfoBuffer->ParameterListBlock.DensityCode;
        cmdExtension->tapeBlockLength  = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);

        if (!mediaInfoBuffer->MediumPartPage.FDPBit) {
            extension->CurrentPartition = NOT_PARTITIONED;
            cmdExtension->CurrentState = 3 ;

        } else {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
                DebugPrint((1,"TapeSetPosition: insufficient resources (deviceConfigBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            deviceConfigBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.Dbd = SETBITON;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetPosition: SendSrb (mode sense #2)\n"));
            cmdExtension->CurrentState = 2 ;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }
    }
    if (cmdExtension->CurrentState == 2) {

        deviceConfigBuffer = Srb->DataBuffer ;

        extension->CurrentPartition =
                deviceConfigBuffer->DeviceConfigPage.ActivePartition?
                DIRECTORY_PARTITION : DATA_PARTITION;

        cmdExtension->CurrentState = 3 ;
    }

    if (cmdExtension->CurrentState == 3) {

        if ( (cmdExtension->densityCode != QIC_2GB) &&
            (cmdExtension->densityCode != QIC_5GB) ) {

            cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_BLOCK;
            cmdExtension->CurrentState = 10 ;

        } else if (cmdExtension->densityCode != QIC_2GB) {

            cmdExtension->CurrentState = 10 ;

        } else {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
                DebugPrint((1,"TapeSetPosition: insufficient resources (compressionModeSenseBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            compressionModeSenseBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.Dbd = SETBITON;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetPosition: SendSrb (mode sense)\n"));
            Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

            cmdExtension->CurrentState = 4 ;
            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }
    }

    if (cmdExtension->CurrentState == 4) {

        compressionModeSenseBuffer = Srb->DataBuffer ;

        if (!compressionModeSenseBuffer->DataCompressPage.DCE) {
            cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_BLOCK;
        }

        cmdExtension->CurrentState = 10 ;
    }

    if (cmdExtension->CurrentState == 10 ) {

        switch (tapeSetPosition->Partition) {
            case 0:
                break;

            case DIRECTORY_PARTITION:
            case DATA_PARTITION:
                if (extension->CurrentPartition != NOT_PARTITIONED) {
                    if (tapeSetPosition->Partition != extension->CurrentPartition) {
                        cmdExtension->changePartition = TRUE;
                    }
                    break;
                }
                // else: fall through to next case

            default:
                DebugPrint((1,"TapeSetPosition: Partition -- invalid parameter\n"));
                return TAPE_STATUS_INVALID_PARAMETER;
        }

        tapePositionVector = tapeSetPosition->Offset.LowPart;

        if( cmdExtension->pos_type == TAPE_PSEUDO_LOGICAL_BLOCK) {

            physPosition =
                TapeClassLogicalBlockToPhysicalBlock(
                    cmdExtension->densityCode,
                    tapePositionVector,
                    cmdExtension->tapeBlockLength,
                    (BOOLEAN)(
                        (extension->CurrentPartition
                            == DIRECTORY_PARTITION)?
                        NOT_FROM_BOT : FROM_BOT
                    )
                );

            tapePositionVector = physPosition.SeekBlockAddress;

            DebugPrint((3,"TapeSetPosition: pseudo logical\n"));

        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (cmdExtension->pos_type) {
            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute)\n"));
                if (cmdExtension->densityCode == QIC_5GB) {
                    cmdExtension->pos_type = TAPE_LOGICAL_BLOCK;
                    DebugPrint((3,"TapeSetPosition: method == locate (logical absolute, 5GB)\n"));
                }
                break;

            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (logical)\n"));
                break;

            case TAPE_PSEUDO_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (pseudo logical)\n"));
                break;
        }

        Srb->TimeOutValue = 480;
        cmdExtension->CurrentState = 12 ;

        cmdExtension->psudo_space_count = 0 ;

        switch (cmdExtension->pos_type) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                break;

            case TAPE_PSEUDO_LOGICAL_BLOCK:
                if ( physPosition.SpaceBlockCount != 0 ) {
                    cmdExtension->psudo_space_count = physPosition.SpaceBlockCount ;
                    cmdExtension->CurrentState = 11 ;
                }
                /* fall through */

            case TAPE_ABSOLUTE_BLOCK:
            case TAPE_LOGICAL_BLOCK:
                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.CPBit = cmdExtension->changePartition? SETBITON : SETBITOFF;
                cdb->LOCATE.BTBit = (cmdExtension->pos_type == TAPE_LOGICAL_BLOCK)?
                                     SETBITOFF : SETBITON;
                cdb->LOCATE.LogicalBlockAddress[1] =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] =
                    (UCHAR)(tapePositionVector & 0xFF);
                if (cmdExtension->changePartition &&
                    (tapeSetPosition->Partition == DIRECTORY_PARTITION)) {
                    cdb->LOCATE.Partition = 1;
                }
                break;

            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));


                Srb->TimeOutValue = 9600;
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                break;

            case TAPE_SPACE_SEQUENTIAL_FMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 2;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }


    if (cmdExtension->CurrentState == 11 ) {

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        DebugPrint((3,"TapeSetPosition: method == locate (pseudo logical) + space block(s)\n"));
        cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
        cdb->SPACE_TAPE_MARKS.Code = 0;
        cdb->SPACE_TAPE_MARKS.NumMarksMSB =
             (UCHAR)((cmdExtension->psudo_space_count >> 16) & 0xFF);
        cdb->SPACE_TAPE_MARKS.NumMarks =
             (UCHAR)((cmdExtension->psudo_space_count >> 8) & 0xFF);
        cdb->SPACE_TAPE_MARKS.NumMarksLSB =
             (UCHAR)(cmdExtension->psudo_space_count & 0xFF);
        Srb->TimeOutValue = 480;

        Srb->DataTransferLength = 0 ;

        cmdExtension->CurrentState = 12 ;
        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (cmdExtension->CurrentState == 12 ) {

        if (cmdExtension->changePartition ) {
             extension->CurrentPartition = tapeSetPosition->Partition;
        }
        return TAPE_STATUS_SUCCESS ;
    }

    //
    // NON 9500 drives
    //

    if (cmdExtension->CurrentState == 50 ) {

        if (cmdExtension->pos_type != TAPE_LOGICAL_BLOCK) {

            cmdExtension->CurrentState = 60 ;

        } else {

            DebugPrint((3,"TapeSetPosition: pseudo logical\n"));

            cmdExtension->pos_type = TAPE_PSEUDO_LOGICAL_BLOCK;

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(UCHAR)*2) ) {
                DebugPrint((1,"TapeSetPosition: insufficient resources (partitionBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            partitionBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->PARTITION.OperationCode = SCSIOP_PARTITION;

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetPosition: SendSrb (partition)\n"));
            Srb->DataTransferLength = sizeof(UCHAR) ;

            cmdExtension->CurrentState = 51 ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }
    }
    if (cmdExtension->CurrentState == 51 ) {

        partitionBuffer = Srb->DataBuffer ;
        extension->CurrentPartition = *partitionBuffer;

        if ((tapeSetPosition->Partition != 0) &&
            (extension->CurrentPartition == NOT_PARTITIONED)) {
            DebugPrint((1,"TapeSetPosition: Partition -- invalid parameter\n"));
            return TAPE_STATUS_INVALID_PARAMETER;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
            DebugPrint((1,"TapeSetPosition: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        cmdExtension->CurrentState = 52 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (cmdExtension->CurrentState == 52 ) {
        modeBuffer = Srb->DataBuffer ;

        cmdExtension->densityCode = modeBuffer->ParameterListBlock.DensityCode;
        cmdExtension->tapeBlockLength  = modeBuffer->ParameterListBlock.BlockLength[2];
        cmdExtension->tapeBlockLength += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        cmdExtension->tapeBlockLength += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);

        if (tapeSetPosition->Partition == 0) {
            cmdExtension->CurrentState = 54 ;

        } else {

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->PARTITION.OperationCode = SCSIOP_PARTITION;
            cdb->PARTITION.Sel = 1;
            cdb->PARTITION.PartitionSelect = (UCHAR)tapeSetPosition->Partition;

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetPosition: SendSrb (partition)\n"));
            Srb->DataTransferLength = 0 ;

            cmdExtension->CurrentState = 53 ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }

    }
    if (cmdExtension->CurrentState == 53 ) {

        extension->CurrentPartition = tapeSetPosition->Partition;
        cmdExtension->CurrentState = 54 ;

    }

    if (cmdExtension->CurrentState == 54 ) {

        cmdExtension->CurrentState = 55 ;

        if ((cmdExtension->pos_type == TAPE_SPACE_END_OF_DATA) &&
            ((extension->DriveID == WANGTEK_5150) || (extension->DriveID == WANGTEK_5360)) ) {

            DebugPrint((1,"TapeSetPosition: method == rewind before space EOD\n"));

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;

            //
            // Set timeout value.
            //

            Srb->TimeOutValue = 180;

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetPosition: method == rewind before space EOD\n"));
            Srb->DataTransferLength = 0 ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }
    }

    if (cmdExtension->CurrentState == 55 ) {
        tapePositionVector = tapeSetPosition->Offset.LowPart;

        physPosition =
            TapeClassLogicalBlockToPhysicalBlock(
                cmdExtension->densityCode,
                tapePositionVector,
                cmdExtension->tapeBlockLength,
                (BOOLEAN)(
                    (extension->CurrentPartition
                        == DIRECTORY_PARTITION)?
                    NOT_FROM_BOT : FROM_BOT
                )
            );

        tapePositionVector = physPosition.SeekBlockAddress;
        cmdExtension->CurrentState = 60 ;

    }

    if (cmdExtension->CurrentState == 60 ) {

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        cmdExtension->CurrentState = 62 ;

        switch (cmdExtension->pos_type) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_PSEUDO_LOGICAL_BLOCK:
                if ( physPosition.SpaceBlockCount != 0 ) {
                    cmdExtension->psudo_space_count = physPosition.SpaceBlockCount ;
                    cmdExtension->CurrentState = 61 ;
                }
                /* fall through */

            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == seek block (absolute)\n"));
                cdb->SEEK_BLOCK.OperationCode = SCSIOP_SEEK_BLOCK;
                cdb->SEEK_BLOCK.BlockAddress[0] =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SEEK_BLOCK.BlockAddress[1] =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SEEK_BLOCK.BlockAddress[2] =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 480;

                break;

            case TAPE_SPACE_END_OF_DATA:

                DebugPrint((1,"TapeSetPosition: method == space to end-of-data\n"));

                cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;

                Srb->TimeOutValue = 960;

                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_SEQUENTIAL_FMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 2;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (cmdExtension->CurrentState == 61 ) {

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        DebugPrint((3,"TapeSetPosition: method == space block(s)\n"));
        cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
        cdb->SPACE_TAPE_MARKS.Code = 0;
        cdb->SPACE_TAPE_MARKS.NumMarksMSB =
             (UCHAR)((cmdExtension->psudo_space_count >> 16) & 0xFF);
        cdb->SPACE_TAPE_MARKS.NumMarks =
             (UCHAR)((cmdExtension->psudo_space_count >> 8) & 0xFF);
        cdb->SPACE_TAPE_MARKS.NumMarksLSB =
             (UCHAR)(cmdExtension->psudo_space_count & 0xFF);

        cmdExtension->CurrentState = 62 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT(cmdExtension->CurrentState == 62 ) ;
    return TAPE_STATUS_SUCCESS;

} // end TapeSetPosition()



TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                case TAPE_SHORT_FILEMARKS:
                case TAPE_LONG_FILEMARKS:
                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SETMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == setmarks\n"));
                cdb->WRITE_TAPE_MARKS.WriteSetMarks = SETBITON;
                break;

            case TAPE_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == filemarks\n"));
                break;

            case TAPE_SHORT_FILEMARKS:
            case TAPE_LONG_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    ASSERT(CallNumber == 1 ) ;
    return TAPE_STATUS_SUCCESS ;

} // end TapeWriteMarks()



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
                DebugPrint((1,
                            "GetMediaTypes: insufficient resources (blockDescripterModeSenseBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_PARM_READ_WRITE_DATA));

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;
            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,
                       "GetMediaTypes: SendSrb (mode sense)\n"));

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {

        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;
        PMODE_PARM_READ_WRITE_DATA configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, only one type (QIC) is returned.
        //

        mediaTypes->MediaInfoCount = 1;

        if ( LastError == TAPE_STATUS_SUCCESS ) {

            //
            // Determine the media type currently loaded.
            //

            mediaType = configInformation->ParameterListHeader.MediumType;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                        mediaType,
                        blockSize));


            switch (mediaType) {
                case 0:

                    //
                    // Cleaner, unknown, no media mounted...
                    //

                    currentMedia = 0;

                    //
                    // Check the density code.
                    //

                    if (configInformation->ParameterListBlock.DensityCode) {
                        currentMedia = QIC;
                    }

                    break;

                case 0x02:
                case 0x04:
                case 0x06:
                case 0x08:
                case 0x24:
                case 0x25:
                case 0x26:

                    //
                    // qic media
                    //

                    currentMedia = QIC;
                    break;

                default:

                    //
                    // Unknown
                    //

                    DebugPrint((1,
                               "Wangqic.GetMediaTypes: Unknown type %x\n",
                               mediaType));

                    currentMedia = QIC;
                    break;
            }
        } else {
            currentMedia = 0;
        }

        //
        // fill in buffer based on spec. values
        // Only one type supported now.
        //

        for (i = 0; i < mediaTypes->MediaInfoCount; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = QicMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (QicMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;

                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    configInformation->ParameterListBlock.DensityCode;

                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }

    }

    return TAPE_STATUS_SUCCESS;
}

static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"WANGTEK ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"51000  SCSI ",12) == 12) {
            return WANGTEK_5525;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"51000HTSCSI ",12) == 12) {
            return WANGTEK_5100;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"5525ES SCSI ",12) == 12) {
            return WANGTEK_5525;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"5360ES SCSI ",12) == 12) {
            return WANGTEK_5360;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"5150ES SCSI ",12) == 12) {
            return WANGTEK_5150;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"9500   ",7) == 7) {
            return WANGTEK_9500;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"9500 DC",7) == 7) {
            return WANGTEK_9500DC;
        }

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\inc\physlogi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    physlogi.h

Abstract:

    This file contains structures and defines that are used
    specifically for the tape drivers. Contains #define's,
    function protypes, etc. for use in calling functions in
    physlogi.c that do physical to pseudo-logical and pseudo-
    logical to physical tape block address/position translation.
    
Author:

    Mike Colandreo       (Maynard)
    
Revision History:

--*/

// begin_ntminitape

//
// defines for QIC tape density codes
//

#define QIC_XX     0   // ????
#define QIC_24     5   // 0x05
#define QIC_120    15  // 0x0F
#define QIC_150    16  // 0x10
#define QIC_525    17  // 0x11
#define QIC_1350   18  // 0x12
#define QIC_1000   21  // 0x15
#define QIC_1000C  30  // 0x1E
#define QIC_2100   31  // 0x1F
#define QIC_2GB    34  // 0x22
#define QIC_5GB    40  // 0x28

//
// defines for QIC tape media codes
//

#define DCXXXX   0
#define DC300    1
#define DC300XLP 2
#define DC615    3
#define DC600    4
#define DC6037   5
#define DC6150   6
#define DC6250   7
#define DC6320   8
#define DC6525   9
#define DC9135SL 33  //0x21
#define DC9210   34  //0x22
#define DC9135   35  //0x23
#define DC9100   36  //0x24
#define DC9120   37  //0x25
#define DC9120SL 38  //0x26
#define DC9164   39  //0x27
#define DCXXXXFW 48  //0x30
#define DC9200SL 49  //0x31
#define DC9210XL 50  //0x32
#define DC10GB   51  //0x33
#define DC9200   52  //0x34
#define DC9120XL 53  //0x35
#define DC9210SL 54  //0x36
#define DC9164XL 55  //0x37
#define DC9200XL 64  //0x40
#define DC9400   65  //0x41
#define DC9500   66  //0x42
#define DC9500SL 70  //0x46

//
// defines for translation reference point
//

#define NOT_FROM_BOT 0
#define FROM_BOT 1

//
// info/structure returned by/from
// TapeLogicalBlockToPhysicalBlock( )
//

typedef struct _TAPE_PHYS_POSITION {
    ULONG SeekBlockAddress;
    ULONG SpaceBlockCount;
} TAPE_PHYS_POSITION, PTAPE_PHYS_POSITION;

//
// function prototypes
//

TAPE_PHYS_POSITION
TapeClassLogicalBlockToPhysicalBlock(
    IN UCHAR DensityCode,
    IN ULONG LogicalBlockAddress,
    IN ULONG BlockLength,
    IN BOOLEAN FromBOT
    );

ULONG
TapeClassPhysicalBlockToLogicalBlock(
    IN UCHAR DensityCode,
    IN ULONG PhysicalBlockAddress,
    IN ULONG BlockLength,
    IN BOOLEAN FromBOT
    );

// end_ntminitape
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\inc\wmi.h ===
/*+++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmi.h

Abstract:

    This file contains structures and defines for WMI
    that are used by minidrivers.
    
Revision History:

---*/

// begin_ntminitape

//
// LOG SENSE Page codes
//
#define TapeAlertLogPage  0x2E

//
// Type of tape drive alert information
// supported by the drive.
// For example, if the type is TapeAlertInfoNone, the drive doesn't
// support any alert info. Need to use read\write error counters
// to predict drive problems. If the type is TapeAlertInfoRequestSense,
// request sense command can be used to determine drive problems.
//
typedef enum _TAPE_ALERT_INFO_TYPE { 
   TapeAlertInfoNone,        
   TapeAlertInfoRequestSense,
   TapeAlertInfoLogPage   
} TAPE_ALERT_INFO_TYPE;

//
// Tape alert information
//
#define READ_WARNING            1
#define WRITE_WARNING           2
#define HARD_ERROR              3 
#define MEDIA_ERROR             4
#define READ_FAILURE            5
#define WRITE_FAILURE           6
#define MEDIA_LIFE              7
#define NOT_DATA_GRADE          8
#define WRITE_PROTECT           9
#define NO_REMOVAL              10
#define CLEANING_MEDIA          11
#define UNSUPPORTED_FORMAT      12
#define SNAPPED_TAPE            13
#define CLEAN_NOW               20
#define CLEAN_PERIODIC          21
#define EXPIRED_CLEANING_MEDIA  22
#define HARDWARE_A              30
#define HARDWARE_B              31
#define INTERFACE_ERROR         32
#define EJECT_MEDIA             33
#define DOWNLOAD_FAIL           34

//
// The following structs are duplicated from wmidata.h
// wmidata.h is generated from wmicore.mof file. Should
// the MOF file change for these structs, the corresponding
// change should be made in these structs also. 
// Since minidrivers do not have access wmidata.h, we need
// to duplicate it here.
//
// ISSUE : 02/28/2000 - nramas : Should find a better way to
// handle the above. Duplication will cause problems in keeping
// these definitions in sync.
//
typedef struct _WMI_TAPE_DRIVE_PARAMETERS
{
    // Maximum block size supported
    ULONG MaximumBlockSize;

    // Minimum block size supported
    ULONG MinimumBlockSize;
    
    // Default block size supported
    ULONG DefaultBlockSize;

    // Maximum number of partitions allowed.
    ULONG MaximumPartitionCount;

    // TRUE if drive supports compression.
    BOOLEAN CompressionCapable;

    // TRUE if compression is enabled.
    BOOLEAN CompressionEnabled;

    // TRUE if drive reports setmarks
    BOOLEAN ReportSetmarks;

    // TRUE if drive supports hardware error correction
    BOOLEAN HardwareErrorCorrection;
} WMI_TAPE_DRIVE_PARAMETERS, *PWMI_TAPE_DRIVE_PARAMETERS;

typedef struct _WMI_TAPE_MEDIA_PARAMETERS
{
    // Maximum capacity of the media
    ULONGLONG MaximumCapacity;

    // Available capacity of the media
    ULONGLONG AvailableCapacity;

    // Current blocksize
    ULONG BlockSize;

    // Current number of partitions
    ULONG PartitionCount;

    // TRUEif media is write protected
    BOOLEAN MediaWriteProtected;
} WMI_TAPE_MEDIA_PARAMETERS, *PWMI_TAPE_MEDIA_PARAMETERS;


typedef struct _WMI_TAPE_PROBLEM_WARNING
{
    // Tape drive problem warning event
    ULONG DriveProblemType;

    // Tape drive problem data
    UCHAR TapeData[512];
} WMI_TAPE_PROBLEM_WARNING, *PWMI_TAPE_PROBLEM_WARNING;

typedef struct _WMI_TAPE_PROBLEM_IO_ERROR
{
    // Read errors corrected without much delay
    ULONG ReadCorrectedWithoutDelay;

    // Read errors corrected with substantial delay
    ULONG ReadCorrectedWithDelay;

    // Total number of Read errors
    ULONG ReadTotalErrors;

    // Total number of read errors that were corrected
    ULONG ReadTotalCorrectedErrors;

    // Total number of uncorrected read errors
    ULONG ReadTotalUncorrectedErrors;

    // Number of times correction algorithm was processed for read
    ULONG ReadCorrectionAlgorithmProcessed;

    // Write errors corrected without much delay
    ULONG WriteCorrectedWithoutDelay;

    // Write errors corrected with substantial delay
    ULONG WriteCorrectedWithDelay;

    // Total number of Read errors
    ULONG WriteTotalErrors;

    // Total number of write errors that were corrected
    ULONG WriteTotalCorrectedErrors;

    // Total number of uncorrected write errors
    ULONG WriteTotalUncorrectedErrors;

    // Number of times correction algorithm was processed for write
    ULONG WriteCorrectionAlgorithmProcessed;

    // Errors not related to medium
    ULONG NonMediumErrors;
} WMI_TAPE_PROBLEM_IO_ERROR, *PWMI_TAPE_PROBLEM_IO_ERROR;

typedef struct _WMI_TAPE_PROBLEM_DEVICE_ERROR
{

   // WARNING : Drive is experiencing read problem.
   BOOLEAN ReadWarning;
   
   // WARNING : Drive is experiencing write problem.
   BOOLEAN WriteWarning;

   // Drive hardware problem
   BOOLEAN HardError;

   // Critical Error : Too many read errors.
   BOOLEAN ReadFailure;

   // Critical Error : Too many write errors.
   BOOLEAN WriteFailure;

   // Tape format not supported
   BOOLEAN UnsupportedFormat;

   // Tape is snapped. Replace media
   BOOLEAN TapeSnapped;

   // Drive Requires Cleaning
   BOOLEAN DriveRequiresCleaning;

   // It's time to clean the drive
   BOOLEAN TimetoCleanDrive;

   // Hardware error. Check drive
   BOOLEAN DriveHardwareError;

   // Some error in cabling, or connection.
   BOOLEAN ScsiInterfaceError;

   // Critical Error : Media life expired. 
   BOOLEAN MediaLife;
} WMI_TAPE_PROBLEM_DEVICE_ERROR, *PWMI_TAPE_PROBLEM_DEVICE_ERROR;

// end_ntminitape
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\amdmtd.c ===
/*
 * $Log:   P:/user/amir/lite/vcs/amdmtd.c_v  $
 *
 *    Rev 1.21	 03 Nov 1997 16:07:06	danig
 * Support RFA
 *
 *    Rev 1.20	 02 Nov 1997 11:06:38	ANDRY
 * bug fix in AMDErase() for RFA on PowerPC
 *
 *    Rev 1.19	 20 Oct 1997 14:08:56	danig
 * Resume erase only when needed
 *
 *    Rev 1.18	 19 Oct 1997 16:39:50	danig
 * Deal with the last word in interleaving 4
 *
 *    Rev 1.17	 29 Sep 1997 18:21:08	danig
 * Try different interleavings in amdMTDIdentify()
 *
 *    Rev 1.16	 24 Sep 1997 17:45:52	danig
 * Default interleaving value is 4
 *
 *    Rev 1.15	 10 Sep 1997 16:22:00	danig
 * Got rid of generic names
 *
 *    Rev 1.14	 08 Sep 1997 18:56:50	danig
 * Support interleaving 4
 *
 *    Rev 1.13	 04 Sep 1997 17:39:34	danig
 * Debug messages
 *
 *    Rev 1.12	 31 Aug 1997 14:53:48	danig
 * Registration routine return status
 *
 *    Rev 1.11	 10 Aug 1997 17:56:02	danig
 * Comments
 *
 *    Rev 1.10	 24 Jul 1997 17:51:54	amirban
 * FAR to FAR0
 *
 *    Rev 1.9	20 Jul 1997 17:16:54   amirban
 * No watchDogTimer
 *
 *    Rev 1.8	07 Jul 1997 15:20:54   amirban
 * Ver 2.0
 *
 *    Rev 1.5	06 Feb 1997 18:18:34   danig
 * Different unlock addresses for series C
 *
 *    Rev 1.4	17 Nov 1996 15:45:16   danig
 * added LV017 support.
 *
 *    Rev 1.3	14 Oct 1996 17:57:00   danig
 * new IDs and eraseFirstBlockLV008.
 *
 *    Rev 1.2	09 Sep 1996 11:38:26   amirban
 * Correction for Fujitsu 8-mbit
 *
 *    Rev 1.1	29 Aug 1996 14:14:46   amirban
 * Warnings
 *
 *    Rev 1.0	15 Aug 1996 15:16:38   amirban
 * Initial revision.
 */

/************************************************************************/
/*									*/
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*									*/
/* This MTD supports the following Flash technologies:			*/
/*									*/
/* - AMD Am29F080 8-mbit devices					*/
/* - AMD Am29LV080 8-mbit devices					*/
/* - AMD Am29F016 16-mbit devices					*/
/* - Fujitsu MBM29F080 8-mbit devices					*/
/*									*/
/* And (among others) the following Flash media and cards:		*/
/*									*/
/* - AMD Series-D PCMCIA cards						*/
/* - AMD AmMC0XXA Miniature cards					*/
/* - AMD AmMCL0XXA Miniature cards					*/
/*									*/
/*----------------------------------------------------------------------*/

#include "flflash.h"
#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif

#define NO_UNLOCK_ADDR 0xffffffffL

typedef struct {
  ULONG  unlockAddr1,
		 unlockAddr2;
  ULONG  baseMask;
} Vars;

Vars mtdVars_amdmtd[SOCKETS];

#define thisVars   ((Vars *) vol.mtdVars)


#define SETUP_ERASE	0x80
#define SETUP_WRITE	0xa0
#define READ_ID 	0x90
#define SUSPEND_ERASE	0xb0
#define SECTOR_ERASE	0x30
#define RESUME_ERASE	0x30
#define READ_ARRAY	0xf0

#define UNLOCK_1	0xaa
#define UNLOCK_2	0x55

#define UNLOCK_ADDR1	0x5555u
#define UNLOCK_ADDR2	0x2aaau

#define D2		4	/* Toggles when erase suspended */
#define D5		0x20	/* Set when programming timeout */
#define D6		0x40	/* Toggles when programming */

/* JEDEC ids for this MTD */
#define Am29F040_FLASH		0x01a4
#define Am29F080_FLASH		0x01d5
#define Am29LV080_FLASH 	0x0138
#define Am29LV008_FLASH 	0x0137
#define Am29F016_FLASH		0x01ad
#define Am29F016C_FLASH 	0x013d
#define Am29LV017_FLASH 	0x01c8

#define Fuj29F040_FLASH 	0x04a4
#define Fuj29F080_FLASH 	0x04d5
#define Fuj29LV080_FLASH	0x0438
#define Fuj29LV008_FLASH	0x0437
#define Fuj29F016_FLASH 	0x04ad
#define Fuj29F016C_FLASH	0x043d
#define Fuj29LV017_FLASH	0x04c8


/*----------------------------------------------------------------------*/
/*			   m a p B a s e				*/
/*									*/
/* Map the window to a page base (page is 4KB or 32KB depends on the	*/
/* media type) and return a pointer to the base. Also return the offset */
/* of the given address from the base.					*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to map				*/
/*	offset		: receives the offset from the base		*/
/*	length		: length to map 				*/
/*									*/
/* Returns:								*/
/*	FlashPTR	: pointer to the page base.			*/
/*									*/
/*----------------------------------------------------------------------*/

FlashPTR mapBase(FLFlash        vol,
			CardAddress    address,
			ULONG *offset,
			LONG		length)
{
  CardAddress base = address & thisVars->baseMask;

  *offset = (ULONG)(address - base);
  return (FlashPTR)flMap(vol.socket, base);
}

/*----------------------------------------------------------------------*/
/*			   a m d C o m m a n d				*/
/*									*/
/* Writes an AMD command with the required unlock sequence		*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address at which to write command	*/
/*	command 	: command to write				*/
/*	flashPtr	: pointer to the window 			*/
/*									*/
/*----------------------------------------------------------------------*/

VOID amdCommand(FLFlash vol,
		       CardAddress address,
		       UCHAR command,
		       FlashPTR flashPtr)
{
  if (thisVars->unlockAddr1 != NO_UNLOCK_ADDR) {
    tffsWriteByteFlash(flAddLongToFarPointer((VOID FAR0 *)flashPtr,
	     ((LONG) address & (vol.interleaving - 1)) + thisVars->unlockAddr1)
	     ,UNLOCK_1);
    tffsWriteByteFlash(flAddLongToFarPointer((VOID FAR0 *)flashPtr,
	     ((LONG) address & (vol.interleaving - 1)) + thisVars->unlockAddr2)
	     ,UNLOCK_2);
    tffsWriteByteFlash(flAddLongToFarPointer((VOID FAR0 *)flashPtr,
	     ((LONG) address & (vol.interleaving - 1)) + thisVars->unlockAddr1)
	     ,command);
  }
  else {
    CardAddress baseAddress = address & (-0x10000l | (vol.interleaving - 1));

    tffsWriteByteFlash(flMap(vol.socket,baseAddress + vol.interleaving * UNLOCK_ADDR1),
		       UNLOCK_1);
    tffsWriteByteFlash(flMap(vol.socket,baseAddress + vol.interleaving * UNLOCK_ADDR2),
		       UNLOCK_2);
    tffsWriteByteFlash(flMap(vol.socket,baseAddress + vol.interleaving * UNLOCK_ADDR1),
		       command);
    flMap(vol.socket, address);
  }
}


/*----------------------------------------------------------------------*/
/*			a m d M T D W r i t e				*/
/*									*/
/* Write a block of bytes to Flash					*/
/*									*/
/* This routine will be registered as the MTD vol.write routine */
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	overwrite	: TRUE if overwriting old Flash contents	*/
/*			  FALSE if old contents are known to be erased	*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus amdMTDWrite(FLFlash vol,
			  CardAddress address,
			  const VOID FAR1 *buffer,
			  dword length,
			  word overwrite)
{
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;
  LONG cLength, i;
  FlashPTR flashPtr, unlockAddr1, unlockAddr2;
  ULONG offset;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  flashPtr = mapBase(&vol, address, &offset, length);
  unlockAddr1 = (FlashPTR) flAddLongToFarPointer((VOID FAR0 *)flashPtr,
						       thisVars->unlockAddr1);
  unlockAddr2 = (FlashPTR) flAddLongToFarPointer((VOID FAR0 *)flashPtr,
						       thisVars->unlockAddr2);
  flashPtr    = (FlashPTR) flAddLongToFarPointer((VOID FAR0 *)flashPtr,
						       offset);

  cLength = length;

  if (vol.interleaving == 1) {
lastByte:
#ifdef __cplusplus
    #define bFlashPtr  flashPtr
    #define bBuffer ((const UCHAR FAR1 * &) buffer)
#else
    #define bFlashPtr  flashPtr
    #define bBuffer ((const UCHAR FAR1 *) buffer)
#endif
    while (cLength >= 1) {
      tffsWriteByteFlash(unlockAddr1, UNLOCK_1);
      tffsWriteByteFlash(unlockAddr2, UNLOCK_2);
      tffsWriteByteFlash(unlockAddr1,SETUP_WRITE);
      tffsWriteByteFlash(bFlashPtr, *bBuffer);
      cLength--;
      bBuffer++;
      bFlashPtr++;
      while (tffsReadByteFlash(bFlashPtr-1) != bBuffer[-1] && flMsecCounter < writeTimeout) {
	if ((tffsReadByteFlash(bFlashPtr-1) & D5) &&
	     tffsReadByteFlash(bFlashPtr-1) != bBuffer[-1]) {
	  tffsWriteByteFlash(bFlashPtr-1, READ_ARRAY);
	  DEBUG_PRINT(("Debug: write failed in AMD MTD.\n"));
	  return flWriteFault;
	}
      }
    }
  }
  else if (vol.interleaving == 2)  {
lastWord:
#ifdef __cplusplus
    #define wFlashPtr ((FlashWPTR &) flashPtr)
    #define wBuffer ((const USHORT FAR1 * &) buffer)
    #define wUnlockAddr1 ((FlashWPTR &) unlockAddr1)
    #define wUnlockAddr2 ((FlashWPTR &) unlockAddr2)
#else
    #define wFlashPtr ((FlashWPTR) flashPtr)
    #define wBuffer ((const USHORT FAR1 *) buffer)
    #define wUnlockAddr1 ((FlashWPTR) unlockAddr1)
    #define wUnlockAddr2 ((FlashWPTR) unlockAddr2)
#endif
    while (cLength >= 2) {
      tffsWriteWordFlash(wUnlockAddr1, UNLOCK_1 * 0x101);
      tffsWriteWordFlash(wUnlockAddr2, UNLOCK_2 * 0x101);
      tffsWriteWordFlash(wUnlockAddr1, SETUP_WRITE * 0x101);
      tffsWriteWordFlash(wFlashPtr, *wBuffer);
      cLength -= 2;
      wBuffer++;
      wFlashPtr++;
      while ((tffsReadWordFlash(wFlashPtr-1) != wBuffer[-1]) && (flMsecCounter < writeTimeout)) {
	if (((tffsReadWordFlash(wFlashPtr-1) &	D5) &&
	      ((tffsReadWordFlash(wFlashPtr-1) ^ wBuffer[-1]) & 0xff))
			  ||
	    ((tffsReadWordFlash(wFlashPtr-1) & (D5 * 0x100)) &&
	      ((tffsReadWordFlash(wFlashPtr-1) ^ wBuffer[-1]) & 0xff00))) {
	  tffsWriteWordFlash(wFlashPtr-1, READ_ARRAY * 0x101);
	  DEBUG_PRINT(("Debug: write failed in AMD MTD.\n"));
	  return flWriteFault;
	}
      }
    }
    if (cLength > 0)
      goto lastByte;
  }
  else /* if (vol.interleaving >= 4) */ {
#ifdef __cplusplus
    #define dFlashPtr ((FlashDPTR &) flashPtr)
    #define dBuffer ((const ULONG FAR1 * &) buffer)
    #define dUnlockAddr1 ((FlashDPTR &) unlockAddr1)
    #define dUnlockAddr2 ((FlashDPTR &) unlockAddr2)
#else
    #define dFlashPtr ((FlashDPTR) flashPtr)
    #define dBuffer ((const ULONG FAR1 *) buffer)
    #define dUnlockAddr1 ((FlashDPTR) unlockAddr1)
    #define dUnlockAddr2 ((FlashDPTR) unlockAddr2)
#endif
    while (cLength >= 4) {
      tffsWriteDwordFlash(dUnlockAddr1, UNLOCK_1 * 0x1010101lu);
      tffsWriteDwordFlash(dUnlockAddr2, UNLOCK_2 * 0x1010101lu);
      tffsWriteDwordFlash(dUnlockAddr1, SETUP_WRITE * 0x1010101lu);
      tffsWriteDwordFlash(dFlashPtr, *dBuffer);
      cLength -= 4;
      dBuffer++;
      dFlashPtr++;
      while ((tffsReadDwordFlash(dFlashPtr-1) != dBuffer[-1]) && (flMsecCounter < writeTimeout)) {
	if (((tffsReadDwordFlash(dFlashPtr-1) &  D5) &&
	      ((tffsReadDwordFlash(dFlashPtr-1)  ^ dBuffer[-1]) & 0xff))
			       ||
	    ((tffsReadDwordFlash(dFlashPtr-1) & (D5 * 0x100)) &&
	      ((tffsReadDwordFlash(dFlashPtr-1) ^ dBuffer[-1]) & 0xff00))
			       ||
	    ((tffsReadDwordFlash(dFlashPtr-1) & (D5 * 0x10000lu)) &&
	      ((tffsReadDwordFlash(dFlashPtr-1) ^ dBuffer[-1]) & 0xff0000lu))
			       ||
	    ((tffsReadDwordFlash(dFlashPtr-1) & (D5 * 0x1000000lu)) &&
	      ((tffsReadDwordFlash(dFlashPtr-1) ^ dBuffer[-1]) & 0xff000000lu))) {
	  tffsWriteDwordFlash(dFlashPtr-1, READ_ARRAY * 0x1010101lu);
	  DEBUG_PRINT(("Debug: write failed in AMD MTD.\n"));
	  return flWriteFault;
	}
      }
    }
    if (cLength > 0)
      goto lastWord;
  }

  flashPtr -= length;
  bBuffer -= length;


  /* compare double words */
  for(;length >= 4; length -= 4, dFlashPtr++, dBuffer++) {
    if (tffsReadDwordFlash(dFlashPtr) != *dBuffer) {
	  DEBUG_PRINT(("Debug: write failed in AMD MTD on verification.\n"));
      return flWriteFault;
    }
  }

  /* compare the last bytes */
  for(; length; length--, bFlashPtr++, bBuffer++) {
    if (tffsReadByteFlash(bFlashPtr) != *bBuffer) {
	  DEBUG_PRINT(("Debug: write failed in AMD MTD on verification.\n"));
      return flWriteFault;
    }
  }


  return flOK;
}

/*----------------------------------------------------------------------*/
/*		 e r a s e F i r s t B l o c k L V 0 0 8		*/
/*									*/
/* Erase the first block in LV008 chip. This block is devided into four */
/* subblocks 16, 8, 8, and 32 kbytes in size.				*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	firstErasableBlock : Number of block to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus eraseFirstBlockLV008(FLFlash vol, LONG firstErasableBlock)
{
  LONG iSubBlock;
  LONG subBlockSize = 0;

  for (iSubBlock = 0; iSubBlock < 4; iSubBlock++) {
    LONG i;
    FlashPTR flashPtr;
    FLBoolean finished;

    switch (iSubBlock) {
      case 1:
	subBlockSize = 0x4000;
	break;
      case 2:
      case 3:
	subBlockSize = 0x2000;
	break;
    }

    flashPtr = (FlashPTR)
	  flMap(vol.socket,
		firstErasableBlock + subBlockSize * vol.interleaving);

    for (i = 0; i < vol.interleaving; i++) {
      amdCommand(&vol, i,SETUP_ERASE, flashPtr);
      tffsWriteByteFlash((FlashPTR) flAddLongToFarPointer((VOID FAR0 *)flashPtr,
					  i + thisVars->unlockAddr1), UNLOCK_1);
      tffsWriteByteFlash((FlashPTR) flAddLongToFarPointer((VOID FAR0 *)flashPtr,
					  i + thisVars->unlockAddr2), UNLOCK_2);
      tffsWriteByteFlash(flashPtr+i, SECTOR_ERASE);
    }

    do {
#ifdef FL_BACKGROUND
      while (flForeground(1) == BG_SUSPEND) {		/* suspend */
	for (i = 0; i < vol.interleaving; i++) {
	  tffsWriteByteFlash(flashPtr+i, SUSPEND_ERASE);
	  /* Wait for D6 to stop toggling */
	  while ((tffsReadByteFlash(flashPtr+i) ^ tffsReadByteFlash(flashPtr+i))
		 & D6)
	    ;
	}
      }
#endif
      finished = TRUE;
      for (i = 0; i < vol.interleaving; i++) {
	tffsWriteByteFlash(flashPtr+i, RESUME_ERASE);
	if (tffsReadByteFlash(flashPtr+i) != 0xff) {
	  if ((tffsReadByteFlash(flashPtr+i) & D5) &&
	       tffsReadByteFlash(flashPtr+i) != 0xff) {
	    tffsWriteByteFlash(flashPtr+i, READ_ARRAY);
	    return flWriteFault;
	  }
	  finished = FALSE;
	}
      }
    } while (!finished);
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		       a m d M T D E r a s e				*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks			*/
/*									*/
/* This routine will be registered as the MTD vol.erase routine */
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/
FLStatus amdMTDErase(FLFlash vol,
			  word firstErasableBlock,
			  word numOfErasableBlocks)
{
  LONG iBlock;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  for (iBlock = 0; iBlock < numOfErasableBlocks; iBlock++) {
    LONG i;
    FLBoolean finished;
    FlashPTR flashPtr;

    /* The first block in an LV008 chip requires special care.*/
    if ((vol.type == Am29LV008_FLASH) || (vol.type == Fuj29LV008_FLASH))
      if ((firstErasableBlock + iBlock) % (vol.chipSize / 0x10000l) == 0) {
	checkStatus(eraseFirstBlockLV008(&vol, firstErasableBlock + iBlock));
	continue;
      }

    /* No need to call mapBase because we know we are on a unit boundary */
    flashPtr = (FlashPTR)
	  flMap(vol.socket,
		    (firstErasableBlock + iBlock) * vol.erasableBlockSize);

    for (i = 0; i < vol.interleaving; i++) {
      amdCommand(&vol, i,SETUP_ERASE, flashPtr);
      tffsWriteByteFlash((FlashPTR) flAddLongToFarPointer((VOID FAR0 *)flashPtr,
					  i + thisVars->unlockAddr1), UNLOCK_1);
      tffsWriteByteFlash((FlashPTR) flAddLongToFarPointer((VOID FAR0 *)flashPtr,
					  i + thisVars->unlockAddr2), UNLOCK_2);
      tffsWriteByteFlash(flashPtr+i, SECTOR_ERASE);
    }

    do {
#ifdef FL_BACKGROUND
      FLBoolean eraseSuspended = FALSE;

      while (flForeground(1) == BG_SUSPEND) {		/* suspend */
	eraseSuspended = TRUE;
	for (i = 0; i < vol.interleaving; i++) {
	  tffsWriteByteFlash(flashPtr+i, SUSPEND_ERASE);
	  /* Wait for D6 to stop toggling */
	  while ((tffsReadByteFlash(flashPtr+i) ^
		  tffsReadByteFlash(flashPtr+i)) & D6)
	    ;
	}
      }

      if (eraseSuspended) {				/* resume */
	eraseSuspended = FALSE;
	for(i = 0; i < vol.interleaving; i++)
	  tffsWriteByteFlash(flashPtr+i, RESUME_ERASE);
      }
#endif
      finished = TRUE;
      for (i = 0; i < vol.interleaving; i++) {
	if (tffsReadByteFlash(flashPtr+i) != 0xff) {
	  if ((tffsReadByteFlash(flashPtr+i) & D5) && tffsReadByteFlash(flashPtr+i) != 0xff) {
	    tffsWriteByteFlash(flashPtr+i, READ_ARRAY);
	    DEBUG_PRINT(("Debug: erase failed in AMD MTD.\n"));
	    return flWriteFault;
	  }
	  finished = FALSE;
      flDelayMsecs(10);
	}
      }
    } while (!finished);
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*			  a m d M T D M a p				*/
/*									*/
/* Map through buffer. This routine will be registered as the map	*/
/* routine for this MTD.						*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Flash address to be mapped.				*/
/*	length	: number of bytes to map.				*/
/*									*/
/* Returns:								*/
/*	Pointer to the buffer data was mapped to.			*/
/*									*/
/*----------------------------------------------------------------------*/

VOID FAR0 *amdMTDMap (FLFlash vol, CardAddress address, int length)
{
  vol.socket->remapped = TRUE;
  return mapThroughBuffer(&vol,address,length);
}


/*----------------------------------------------------------------------*/
/*			  a m d M T D R e a d				*/
/*									*/
/* Read some data from the flash. This routine will be registered as	*/
/* the read routine for this MTD.					*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Address to read from. 				*/
/*	buffer	: buffer to read to.					*/
/*	length	: number of bytes to read (up to sector size).		*/
/*	modes	: EDC flag etc. 					*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failed.		*/
/*									*/
/*----------------------------------------------------------------------*/

FLStatus amdMTDRead(FLFlash vol,
			 CardAddress address,
			 VOID FAR1 *buffer,
			 dword length,
			 word modes)
{
  ULONG i;
  UCHAR * byteBuffer;
  FlashPTR byteFlashPtr;
  ULONG * dwordBuffer = (ULONG *)buffer;
  FlashDPTR dwordFlashPtr = (FlashDPTR)flMap(vol.socket, address);

  for (i = 0; i < length - 4; i += 4, dwordBuffer++, dwordFlashPtr++) {
    *dwordBuffer = tffsReadDwordFlash(dwordFlashPtr);
  }
  byteBuffer = (UCHAR *)dwordBuffer;
  byteFlashPtr = (FlashPTR)dwordFlashPtr;
  for(; i < length; i++, byteBuffer++, byteFlashPtr++) {
    *byteBuffer = tffsReadByteFlash(byteFlashPtr);
  }
  return flOK ;
}


/*----------------------------------------------------------------------*/
/*		      a m d M T D I d e n t i f y			*/
/*									*/
/* Identifies AMD and Fujitsu flash media and registers as an MTD for	*/
/* such.								*/
/*									*/
/* On successful identification, the Flash structure is filled out and	*/
/* the write and erase routines registered.				*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on positive identificaion, failed otherwise */
/*----------------------------------------------------------------------*/

FLStatus amdMTDIdentify(FLFlash vol)
{
  LONG inlv;

    DEBUG_PRINT(("Debug: entering AMD MTD identification routine.\n"));
  flSetWindowBusWidth(vol.socket,16);/* use 16-bits */
  flSetWindowSpeed(vol.socket,150);  /* 120 nsec. */
  flSetWindowSize(vol.socket,2);	/* 8 KBytes */

  vol.mtdVars = &mtdVars_amdmtd[flSocketNoOf(vol.socket)];
  thisVars->unlockAddr1 = NO_UNLOCK_ADDR;

  /* try different interleavings */
  for (inlv = 4; inlv > 0; inlv >>= 1) {
    if (inlv == 1)
      flSetWindowBusWidth(vol.socket,8); /* use 8-bits */
    vol.interleaving = (unsigned short)inlv;
    flIntelIdentify(&vol, amdCommand,0);
    if (vol.type == Am29F016_FLASH ||
	vol.type == Fuj29F016_FLASH ||
	vol.type == Am29F016C_FLASH ||
	vol.type == Fuj29F016C_FLASH ||
	vol.type == Am29F080_FLASH ||
	vol.type == Fuj29F080_FLASH ||
	vol.type == Am29LV080_FLASH ||
	vol.type == Fuj29LV080_FLASH ||
	vol.type == Am29LV008_FLASH ||
	vol.type == Fuj29LV008_FLASH ||
	vol.type == Am29F040_FLASH ||
	vol.type == Fuj29F040_FLASH ||
	vol.type == Am29LV017_FLASH ||
	vol.type == Fuj29LV017_FLASH)
      break;
  }

  if (vol.type == Am29F016_FLASH ||
      vol.type == Fuj29F016_FLASH ||
      vol.type == Am29F016C_FLASH ||
      vol.type == Fuj29F016C_FLASH ||
      vol.type == Am29LV017_FLASH ||
      vol.type == Fuj29LV017_FLASH)
    vol.chipSize = 0x200000l;
  else if (vol.type == Fuj29F080_FLASH ||
	   vol.type == Am29F080_FLASH ||
	   vol.type == Fuj29LV080_FLASH ||
	   vol.type == Am29LV080_FLASH ||
	   vol.type == Fuj29LV008_FLASH ||
	   vol.type == Am29LV008_FLASH)
    vol.chipSize = 0x100000l;
  else if (vol.type == Fuj29F040_FLASH ||
	   vol.type == Am29F040_FLASH)
    vol.chipSize = 0x80000l;
  else {
    DEBUG_PRINT(("Debug: did not identify AMD or Fujitsu flash media.\n"));
    return flUnknownMedia;
  }

  if ((vol.type == Am29F016C_FLASH) || (vol.type == Fuj29F016C_FLASH)) {
    thisVars->unlockAddr1 = thisVars->unlockAddr2 = 0L;
    thisVars->baseMask = 0xfffff800L * vol.interleaving;
  }
  else if ((vol.type == Am29F040_FLASH) || (vol.type == Fuj29F040_FLASH)){
    flSetWindowSize(vol.socket,8 * vol.interleaving);
    thisVars->unlockAddr1 = 0x5555u * vol.interleaving;
    thisVars->unlockAddr2 = 0x2aaau * vol.interleaving;
    thisVars->baseMask = 0xffff8000L * vol.interleaving;
  }
  else {
    thisVars->unlockAddr1 = 0x555 * vol.interleaving;
    thisVars->unlockAddr2 = 0x2aa * vol.interleaving;
    thisVars->baseMask = 0xfffff800L * vol.interleaving;
  }

  checkStatus(flIntelSize(&vol,amdCommand,0));

  vol.erasableBlockSize = 0x10000l * vol.interleaving;
  vol.flags |= SUSPEND_FOR_WRITE;

  /* Register our flash handlers */
  vol.write = amdMTDWrite;
  vol.erase = amdMTDErase;
  vol.map   = amdMTDMap;
  vol.read  = amdMTDRead;

  DEBUG_PRINT(("Debug: Identified AMD or Fujitsu flash media.\n"));
  return flOK;
}


/*----------------------------------------------------------------------*/
/*		     f l R e g i s t e r A M D M T D			*/
/*									*/
/* Registers this MTD for use						*/
/*									*/
/* Parameters:								*/
/*	None								*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterAMDMTD(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = amdMTDIdentify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\bddefs.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/BDDEFS.H_V  $
 * 
 *    Rev 1.4   Jan 17 2002 23:00:00   oris
 * Replace FLFlash record with a pointer to FLFlash record (TrueFFS now uses only SOCKETS number of FLFlash records).
 * Removed SINGLE_BUFFER ifdef.
 * Added partition parameter to setBusy.
 * 
 *    Rev 1.3   Mar 28 2001 05:59:22   oris
 * copywrite dates.
 * Added empty line at the end of the file
 * left alligned all # directives
 * Removed dismountLowLevel extern prototype
 *
 *    Rev 1.2   Feb 18 2001 14:22:58   oris
 * Removed driveHandle field from volume record.
 *
 *    Rev 1.1   Feb 12 2001 12:51:08   oris
 * Changed the mutex field to a pointer to support TrueFFS 5.0 mutex mechanism
 *
 *    Rev 1.0   Feb 02 2001 12:04:16   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef BDDEFS_H
#define BDDEFS_H

#include "fltl.h"
#include "flsocket.h"
#include "flbuffer.h"
#include "stdcomp.h"

typedef struct {
  char          flags;                  /* See description in flreq.h */
  unsigned      sectorsPerCluster;      /* Cluster size in sectors */
  unsigned      maxCluster;             /* highest cluster no. */
  unsigned      bytesPerCluster;        /* Bytes per cluster */
  unsigned      bootSectorNo;           /* Sector no. of DOS boot sector */
  unsigned      firstFATSectorNo;       /* Sector no. of 1st FAT */
  unsigned      secondFATSectorNo;      /* Sector no. of 2nd FAT */
  unsigned      numberOfFATS;           /* number of FAT copies */
  unsigned      sectorsPerFAT;          /* Sectors per FAT copy */
  unsigned      rootDirectorySectorNo;  /* Sector no. of root directory */
  unsigned      sectorsInRootDirectory; /* No. of sectors in root directory */
  unsigned      firstDataSectorNo;      /* 1st cluster sector no. */
  unsigned      allocationRover;        /* rover pointer for allocation */

#if FILES > 0
  FLBuffer      volBuffer;              /* Define a sector buffer */
#endif
  FLMutex*      volExecInProgress;
  FLFlash FAR2* flash;                  /* flash structure for low level operations */
  TL            tl;                     /* Translation layer methods */
  FLSocket      *socket;                /* Pointer to socket */
#ifdef WRITE_PROTECTION
  unsigned long password[2];
#endif
#ifdef WRITE_EXB_IMAGE
  dword binaryLength;        /* Actual binary area taken by the exb      */
  byte  moduleNo;            /* Currently written module                 */
#endif /* WRITE_EXB_IMAGE */
} Volume;

/* drive handle masks */

#if defined(FILES) && FILES > 0
typedef struct {
  long          currentPosition;        /* current byte offset in file */
#define         ownerDirCluster currentPosition /* 1st cluster of owner directory */
  long          fileSize;               /* file size in bytes */
  SectorNo      directorySector;        /* sector of directory containing file */
  unsigned      currentCluster;         /* cluster of current position */
  unsigned char directoryIndex;         /* entry no. in directory sector */
  unsigned char flags;                  /* See description below */
  Volume *      fileVol;                /* Drive of file */
} File;

/* File flag definitions */
#define FILE_MODIFIED           4       /* File was modified */
#define FILE_IS_OPEN            8       /* File entry is used */
#define FILE_IS_DIRECTORY    0x10       /* File is a directory */
#define FILE_IS_ROOT_DIR     0x20       /* File is root directory */
#define FILE_READ_ONLY       0x40       /* Writes not allowed */
#define FILE_MUST_OPEN       0x80       /* Create file if not found */
#endif /* FILES > 0 */

/* #define buffer (vol.volBuffer) */
#define execInProgress (vol.volExecInProgress)

extern FLStatus dismountVolume(Volume vol);
extern FLBoolean initDone;      /* Initialization already done */
extern Volume   vols[VOLUMES];
extern FLStatus setBusy(Volume vol, FLBoolean state, byte partition);
const void FAR0 *findSector(Volume vol, SectorNo sectorNo);
FLStatus dismountFS(Volume vol,FLStatus status);
#if FILES>0
void initFS(void);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\diskonc.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DISKONC.H_V  $
 * 
 *    Rev 1.8   Jan 17 2002 22:58:12   oris
 * Removed EXTRA_LEN
 * 
 *    Rev 1.7   Nov 08 2001 10:44:40   oris
 * Added BBT_MAX_DISTANCE definition
 * 
 *    Rev 1.6   Jul 13 2001 00:59:52   oris
 * Moved VERIFY_WRITE and VERIFY_ERASE compilation flag to flcustom.h.
 * Added file header.
 *
 */

/*******************************************************************
 *
 *    DESCRIPTION: basic mtd functions for the DiskOnChip 2000 family
 *
 *    AUTHOR: Dimitry Shmidt
 *
 *    HISTORY: OSAK 1.23
 *
 *******************************************************************/
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef DISKONC_H
#define DISKONC_H

#include "docsys.h"

#ifndef MTD_STANDALONE
extern FLBoolean checkWinForDOC(unsigned driveNo, NDOC2window memWinPtr);
#endif /* MTD_STANDALONE */

      /*.*/
      /*    Feature list            */
      /*.*/

/* #define MULTI_ERASE        */ /* use multiple block erase feature */
/* #define WIN_FROM_SS        */ /* call Socket Services to get window location */
/* #define BIG_PAGE_ENABLED   */ /* compile support for 2MB flashes             */
/* #define SEPARATED_CASCADED */ /* export each floor as a SEPARATED device     */

#define BUSY_DELAY    30000
#define START_ADR     0xC8000L
#define STOP_ADR      0xF0000L

#define PAGES_PER_BLOCK     16      /* 16 pages per block on a single chip */
#define CHIP_PAGE_SIZE      0x100   /* Page Size of 2 Mbyte Flash */

     /* miscellaneous limits */

/*#define MAX_FLASH_DEVICES_MDOC 2 *//* Removed in osak 5.0 */
#define MAX_FLASH_DEVICES_DOC  16
#define MAX_FLOORS             4
#define CHIP_ID_DOC            0x20
#define CHIP_ID_MDOC           0x30
#define MDOC_ALIAS_RANGE       0x100
#define ALIAS_RESOLUTION       (MAX_FLASH_DEVICES_DOC + 10)

  /*Ŀ
     Definition for writing boot image  
    */

#define SPL_SIZE           0x2000 /* 8 KBytes */
#define MAX_CODE_MODULES   6      /* max number of code modules in boot area (incl. SPL) */

  /*Ŀ
      Definition for doc2000 tsop bbt    
    */

#define BBT_SIGN_SIZE    8
#define BBT_SIGN         "MSYS_BBT"
#define MAX_BAD_PER_512  40
#define BBT_MAX_DISTANCE 0x20
 /*Ŀ
     Definition of DOC 2000 memory window  
    */

/*
       DOC 2000 memory window layout :

         0000 .... 003F    IPL ROM ( part 1 )
         0040 .... 07FF       (aliased 20H times)
         0800 .... 083F    IPL ROM ( part 2 )
         0840 .... 0FFF       (aliased 20H times)
               1000    Chip Id
               1001    DOC_Status_reg
               1002    DOC_Control_reg
               1003    ASIC_Control_reg
    CDSN window ----->     1004    CDSN_Control_reg
               1005    CDSN_Device_Selector
               1006    ECC_Config_reg
               1007    ECC_Status_reg
         1008 .... 100C    Test registers [5]
               100D    CDSN_Slow_IO_reg
         100E .... 100F    reserved ( 2 bytes )
         1010 .... 1015    ECC_Syndrom [6]
         1016 .... 17FF    reserved ( 2027 bytes )
         1800 .... 1FFF    CDSN_IO (aliased 800H times)
*/

   /*-----------------------------------------
    | Definition of MDOC 2000 memory window  |
    ----------------------------------------*/

/*        MDOC 2000 memory window layout :

         0000 .... 01FF    IPL SRAM ( part 1 )
         0200 .... 07FF       (aliased 4 times)
         0800 .... 0FFF    CDSN_IO (aliased 800H times)
               1000    Chip Id
               1001    DOC_Status_reg
               1002    DOC_Control_reg
               1003    ASIC_Control_reg
    CDSN window ----->     1004    CDSN_Control_reg
               1005    CDSN_Device_Selector
               1006    ECC_Config_reg
         1007 .... 100C    reserved ( 6 bytes )
               100D    CDSN_Slow_IO_reg
         100E .... 100F    reserved ( 2 bytes )
         1010 .... 1015    ECC_Syndrom [6]
         1016 .... 101A    reserved ( 5 bytes )
               101B    Alias_Resolution_reg
               101C    Config_Input_reg
               101D    Read_Pipeline_Init_reg
               101E    Write_Pipeline_Term_reg
               101F    Last_Data_Read_reg
               1020    NOP_reg
         1021 .... 103E    reserved ( 30 )
               103F    Foundary_Test_reg
         1040 .... 17FF    reserved ( 1984 bytes (7C0) )
         1800 .... 19FF    IPL SRAM ( part 1 )
         1A00 .... 1FFF       (aliased 4 times)
*/

#define NIPLpart1        0x0               /* read       */
#define NIPLpart2        0x800               /* read       */
#define NchipId          0x1000            /* read       */
#define NDOCstatus       0x1001            /* read       */
#define NDOCcontrol      0x1002            /*      write */
#define NASICselect      0x1003            /* read write */
#define Nsignals         0x1004            /* read write */
#define NdeviceSelector  0x1005            /* read write */
#define NECCconfig       0x1006            /*      write */
#define NECCstatus       0x1007            /* read       */
#define NslowIO          0x100d            /* read write */
#define Nsyndrom         0x1010            /* read       */
#define NaliasResolution 0x101B            /* read write MDOC only */
#define NconfigInput     0x101C            /* read write   - || -  */
#define NreadPipeInit    0x101D            /* read         - || -  */
#define NwritePipeTerm   0x101E            /*      write   - || -  */
#define NreadLastData    0x101F            /* read write   - || -  */
#define NNOPreg          0x1020            /* read write   - || -  */

#define NfoudaryTest     0x103F            /*      write */
#define Nio              0x1800            /* read write */

     /* bits for writing to DOC2window.DOCcontrol reg */

#define  ASIC_NORMAL_MODE  0x85
#define  ASIC_RESET_MODE   0x84
#define  ASIC_CHECK_RESET  0x00

     /* bits for writing to DOC2window.signals ( CDSN_Control reg ) */

#define  CE        0x01                 /* 1 - Chip Enable          */
#define  CLE       0x02                 /* 1 - Command Latch Enable */
#define  ALE       0x04                 /* 1 - Address Latch Enable */
#define  WP        0x08                 /* 1 - Write-Protect flash  */
#define  FLASH_IO  0x10
#define  ECC_IO    0x20                 /* 1 - turn ECC on          */
#define  PWDO      0x40

     /* bits for reading from DOC2window.signals ( CDSN_Control reg ) */

#define RB         0x80                 /* 1 - ready */

     /* bits for writing to DOC2window.ECCconfig */

#define ECC_RESET               0x00
#define ECC_IGNORE              0x01
#define ECC_RESERVED            0x02    /* reserved bits  */
#define ECC_EN    (0x08 | ECC_RESERVED) /* 1 - enable ECC */
#define ECC_RW    (0x20 | ECC_RESERVED) /* 1 - write mode, 0 - read mode */

     /* bits for reading from DOC2window.ECCstatus */

#define ECC_ERROR 0x80
#define TOGGLE    0x04                  /* used for DOC 2000 detection */

#define MDOC_ASIC   0x08                /* MDOC asic */

/*----------------------------------------------------------------------*/
/*                 c h e c k W i n F o r D o c                     */
/*                                    */
/* Checks if a given window is valid DOC window.            */
/*                                    */
/* Parameters:                                                          */
/*      memWinPtr host base address of the window                    */
/*                                                                      */
/* Returns:                                                             */
/*    TRUE if there is DOC FALSE otherwise                    */
/*----------------------------------------------------------------------*/

/* extern FLBoolean checkWinForDOC(unsigned driveNo, NDOC2window memWinPtr); */

#endif /* DISKONC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\doc2exb.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOC2EXB.C_V  $
 *
 *    Rev 1.26   Apr 15 2002 07:35:12   oris
 * Moved doc2exb internal functions declaration to blockdev.c.
 * Make sure all relevant data is stored in little endian format.
 *
 *    Rev 1.25   Feb 19 2002 20:58:28   oris
 * Moved include directive and routine  prototypes from H file.
 *
 *    Rev 1.24   Jan 23 2002 23:31:18   oris
 * Removed warnings.
 * Replaced Alon based DiskOnChip writeIPL code with the MTD writeIPL routine.
 *
 *    Rev 1.23   Jan 21 2002 20:44:02   oris
 * Bad support for firmware other then the default 3 firmwares (TrueFFS 4.3 backward compatibility firmware).
 * Added support for DiskOnChip Millennium Plus 16MB firmware.
 * Missing far heap initialization for DiskOnChip 2000 firmware.
 *
 *    Rev 1.22   Jan 17 2002 22:58:32   oris
 * Added new flags for placeExbByBuffer - Choose firmware to place
 * Added firmware number to getExbInfo().
 * Changed debug print to Dformat print.
 * Removed exb size calculation when writing SPL - It is done as part of the firmware build
 * Added support for far malloc heap.
 * All DiskOnChip use the same STACK size definition.
 *
 *    Rev 1.21   Nov 08 2001 10:44:50   oris
 * Removed warnings.
 *
 *    Rev 1.20   Sep 24 2001 18:23:10   oris
 * Removed warnings.
 *
 *    Rev 1.19   Sep 16 2001 21:47:42   oris
 * Bug fix - support for 1KB IPL code for DiskOnChip2000 tsop.
 *
 *    Rev 1.18   Sep 15 2001 23:44:54   oris
 * Bug fix - The last 512 bytes of the last firmware were not written, and IPL was not loaded.
 *
 *    Rev 1.17   Jul 30 2001 17:57:36   oris
 * Removed warrnings
 *
 *    Rev 1.16   Jul 30 2001 00:20:52   oris
 * Support new IPL and SPL formats.
 *
 *    Rev 1.15   Jul 13 2001 01:00:08   oris
 * Changed constant stack space from magic numbers to contents.
 * Added erase before write for the binary write operation.
 *
 *    Rev 1.14   Jun 17 2001 08:17:16   oris
 * Changed placeExbByBuffer exbflags argument to word instead of byte to  support /empty flag.
 * Adjust exb size field to fit OSAK 4.3 format.
 * Added \empty flag - Leaves exb space empty.
 *
 *    Rev 1.13   May 29 2001 19:47:12   oris
 * Bug fix - trueffs heap size discounted boot units (heap too small)
 * Doc2000 exbOffset hardcoded to 40.
 *
 *    Rev 1.12   May 16 2001 21:16:50   oris
 * Change "data" named variables to flData to avoid name clashes.
 * Removed warnings.
 *
 *    Rev 1.11   May 09 2001 00:31:52   oris
 * Bug fix - Added check status to intializaion routine of place EXB by buffer.
 *
 *    Rev 1.10   May 06 2001 22:41:34   oris
 * Reduced tffs head size for Millennium Plus and DOC2000 tsop devices.
 * Removed warnings.
 *
 *    Rev 1.9   Apr 12 2001 06:48:46   oris
 * Added call to download routine in order to load new IPL.
 *
 *    Rev 1.8   Apr 10 2001 16:40:22   oris
 * Removed warrnings.
 *
 *    Rev 1.7   Apr 09 2001 14:59:04   oris
 * Reduced exb size read by the SPL to minimum.
 *
 *    Rev 1.6   Apr 03 2001 18:08:42   oris
 * Bug fix - exb flags were not properly written.
 *
 *    Rev 1.5   Apr 03 2001 16:34:50   oris
 * Removed unsused variables.
 *
 *    Rev 1.4   Apr 03 2001 14:36:46   oris
 * Completly reviced in order to support alon devices.
 *
 *    Rev 1.3   Apr 02 2001 00:54:32   oris
 * Added doc2000 exb family.
 * Supply the exact length of the exb in the binary partition.
 * Removed the no_pnp_header from the media.
 * Bug fix for calculation Spl size.
 *
 *    Rev 1.2   Apr 01 2001 07:49:42   oris
 * Updated copywrite notice.
 * Added support for doc2300 firmware.
 * Bug fixes for mdoc plus.
 * Added support for 1k IPL.
 * Added consideration in media type in calculating tffs heap size.
 * Changed h\w to h/w
 * Changed 2400 family to doc plus family.
 *
 *    Rev 1.1   Feb 08 2001 10:37:54   oris
 * Bug fix for unaligned file signature
 *
 *    Rev 1.0   Feb 02 2001 12:59:48   oris
 * Initial revision.
 *
 */


/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Project : TrueFFS source code                                              *
*                                                                            *
* Name : doc2exb.c                                                           *
*                                                                            *
* Description : This file contains the code for analizing and writing        *
*               M-Systems EXB firmware files                                 *
*                                                                            *
*****************************************************************************/

#include "doc2exb.h"
#include "bddefs.h"

#ifdef WRITE_EXB_IMAGE

extern FLStatus absMountVolume(Volume vol);

#define BUFFER exb->buffer->flData

exbStruct exbs[SOCKETS];

#define roundedUpShift(a,bits) (((a - 1) >> bits)+1)

/*----------------------------------------------------------------------*/
/*                    g e t E x b I n f o                               */
/*                                                                      */
/* Analize M-systems firmware file                                      */
/* Analizes M-systems firmware (exb) file, calclating the media space   */
/* required for it.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      buf             : Pointer to EXB file buffer                    */
/*      bufLen          : Size of the buffer                            */
/*      bufFlags        : Flags for the EXB - specifing type of         */
/*                        firmware to extract from the EXB file.        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus          : flOK on success.                            */
/*                          flBadLength if buffer size is too small     */
/*                          flBadParameter on any other failure         */
/*  vol.binaryLength      : Total size needed in the binary partition   */
/*  exbs[i].firmwareStart : offset of the firmware begining in the file */
/*  exbs[i].firmwareEnd   : offset of the firmware end in the file      */
/*  exbs[i]l.splOffset    : offset of the spl start in the file         */
/*  exbs[i]l.exbFileEnd   : Total exb file size.                        */
/*----------------------------------------------------------------------*/

FLStatus getExbInfo(Volume vol, void FAR1 * buf, dword bufLen, word exbFlags)
{

   byte              i;
   byte              mediaType;

   ExbGlobalHeader FAR1* globalHeader   = (ExbGlobalHeader FAR1*)buf;
   FirmwareHeader  FAR1* firmwareHeader = (FirmwareHeader FAR1*)
           flAddLongToFarPointer(buf,sizeof(ExbGlobalHeader));

   /* Make sure size given is big enough */

   if (bufLen < sizeof(FirmwareHeader) * LE4(globalHeader->noOfFirmwares) +
           sizeof(ExbGlobalHeader))
   {
      DFORMAT_PRINT(("ERROR - Buffer size not big enough.\r\n"));
      return flBadLength;
   }

   /* Make sure this is an M-systems EXB file */

   if (tffscmp(globalHeader->mSysSign,SIGN_MSYS,SIGN_MSYS_SIZE) != 0)
   {
      DFORMAT_PRINT(("ERROR - Given file is not M-systems EXB file.\r\n"));
      return flBadParameter;
   }

   i = (exbFlags & FIRMWARE_NO_MASK) >> FIRMWARE_NO_SHIFT;
   if(i == 0)
   {
      /* Make sure this is the correct version of TrueFFS */

      if (tffscmp(globalHeader->osakVer,TrueFFSVersion,SIGN_MSYS_SIZE) != 0)
      {
         DFORMAT_PRINT(("ERROR - Incorrect TrueFFS EXB file version.\r\n"));
         return flBadParameter;
      }

      /* Find the corrent firmware in the file */

      /* Automatic firmware detection - by DiskOnChip type */
      switch (vol.flash->mediaType)
      {
         case DOC_TYPE:
         case MDOC_TYPE:
            mediaType = DOC2000_FAMILY_FIRMWARE;
            break;
         case MDOCP_TYPE:
            mediaType = DOCPLUS_FAMILY_FIRMWARE;
            break;
         case MDOCP_16_TYPE:
            mediaType = DOCPLUS_INT1_FAMILY_FIRMWARE;
            break;
         case DOC2000TSOP_TYPE:
            mediaType = DOC2300_FAMILY_FIRMWARE;
            break;
         default:
            DFORMAT_PRINT(("Unknown H/W - Try specifing the firmware manualy.\r\n"));
            return flFeatureNotSupported;
      }

      for (i=0;i<LE4(globalHeader->noOfFirmwares);i++,firmwareHeader++)
      {
         if (LE4(firmwareHeader->type) == mediaType)
           break;
      }
   }
   else /* Use given firmware */
   {
      i--; /* 0 was used for automatic choose of firmware */
   }

   if (i >= LE4(globalHeader->noOfFirmwares))
   {
      DFORMAT_PRINT(("ERROR - The EXB file does not support the required firmware.\r\n"));
      return flBadParameter;
   }

   /* Initialize the volumes EXB fields */

   firmwareHeader = (FirmwareHeader FAR1*)flAddLongToFarPointer(buf,
                     (sizeof(ExbGlobalHeader) + (i * sizeof(FirmwareHeader))));
   i = (byte)(&vol - vols);

   /* Save firmware files statstics recieved from the files header */
   exbs[i].firmwareStart = LE4(firmwareHeader->startOffset);
   exbs[i].firmwareEnd   = LE4(firmwareHeader->endOffset);
   exbs[i].splStart      = LE4(firmwareHeader->splStartOffset);
   exbs[i].splEnd        = LE4(firmwareHeader->splEndOffset);
   exbs[i].exbFileEnd    = LE4(globalHeader->fileSize);

   /* Calculate the binary partition size (good bytes) used to
      hold the EXB file.                                       */

   exbs[i].iplMod512 = (word)((exbs[i].splStart - exbs[i].firmwareStart)
                              >> SECTOR_SIZE_BITS);

   switch (vol.flash->mediaType)
   {
      /* NFTL formated device - IPL is placed on the binary partition */

      case DOC_TYPE:

         /* Size of EXB minus IPL which is placed in ROM */
         vol.binaryLength = exbs[i].firmwareEnd - exbs[i].splStart + 0x4000;
         break;

     case MDOC_TYPE:        /* Millennium 8, write data as is */

         /* Size of entire EXB */
         vol.binaryLength = exbs[i].firmwareEnd - exbs[i].firmwareStart;
         break;

      /* INFTL formated device - IPL is not placed on the binary
         partition, but on a dedicated flash area */

     case DOC2000TSOP_TYPE: /* DOC2000 TSOP   */
     case MDOCP_TYPE:       /* MDOC PLUS 32MB */
     case MDOCP_16_TYPE:    /* MDOC PLUS 16MB */

        vol.binaryLength  = exbs[i].firmwareEnd - exbs[i].splStart;
        break;

     default :
        DFORMAT_PRINT(("ERROR - Firmware formater reports A None DiskOnChip media.\r\n"));
        return flBadParameter;
   }
   return flOK;
}

/*------------------------------------------------------------------------*/
/*                    w a i t F o r H a l f B u f f e r                   */
/*                                                                        */
/* Increament the EXB file pointers and store the files data unit a       */
/* full sector of data is read.                                           */
/*                                                                        */
/* Parameters:                                                            */
/*  exbs[i].bufferOffset  : size of the buffer already filled with data   */
/*  exbs[i].exbFileOffset : offset from the beginning of the file         */
/*  exbs[i].buffer.data   : internal volume buffer accumulation file data */
/*  buf                   : buffer containing the files data              */
/*  bufLen                : Length of the buffer containing the file data */
/*  length                : Length of the buffer not yet used             */
/*  half                  : Wait for full 512 bytes of only 256           */
/* Returns:                                                               */
/*      boolean         : TRUE on full buffer otherwise FALSE.            */
/*      length          : Updated length of unused buffer                 */
/*------------------------------------------------------------------------*/

FLBoolean waitForFullBuffer(Volume vol , byte FAR1 * buf ,
                dword bufLen , Sdword * length,FLBoolean half)
{
  word bufferEnd;
  word tmp;
  byte i = (byte)(&vol - vols);

  if (half == TRUE)
  {
     bufferEnd = (SECTOR_SIZE >> 1);
  }
  else
  {
     bufferEnd = SECTOR_SIZE;
  }

  tmp = (word)TFFSMIN(*length , bufferEnd - exbs[i].bufferOffset);

  tffscpy(exbs[i].buffer->flData + exbs[i].bufferOffset ,
          flAddLongToFarPointer(buf,(bufLen-(*length))), tmp);
  exbs[i].bufferOffset  += tmp;
  exbs[i].exbFileOffset += tmp;
  *length           -= tmp;
  if (*length+tmp < bufferEnd)
     return FALSE;

  exbs[i].bufferOffset = 0;
  return TRUE;
}

/*------------------------------------------------------------------------*/
/*                    f i r s t T i m e I n i t                           */
/*                                                                        */
/* Initialize data structures for placing exb file.                       */
/* full sector of data is read.                                           */
/*                                                                        */
/* Actions:                                                               */
/*   1) Analize exb file buffer.                                          */
/*   2) Calculate TFFS heap size.                                         */
/*   3) Check if binary area with SPL signature is big enough.            */
/*   4) Calculate SPL start media address                                 */
/*   5) Calculate binary area used for the firmware.                      */
/*   6) Initialize the volumes EXB record.                                */
/*                                                                        */
/* Parameters:                                                            */
/*    vol    : Pointer to volume record describing the volume.            */
/*    exb    : Pointer to exb record describing the volume.               */
/*    buf    : Exb file buffer.                                           */
/*    bufLen : Length of exb file buffer.                                 */
/*    ioreq  : Internal ioreq record for binary operaions.                */
/*    bdk    : Bdk record which is a part of the ioreq packet.            */
/*                                                                        */
/* Affected Variables.                                                    */
/*                                                                        */
/* Returns:                                                               */
/*      flOK              : On success.                                   */
/*      flNoSpaceInVolume : Not enough space on the binary area.          */
/*------------------------------------------------------------------------*/

FLStatus firstTimeInit(Volume vol , exbStruct* exb, byte FAR1 * buf ,
               dword bufLen , IOreq* ioreq , BDKStruct* bdk ,
               word exbFlags)
{
   if (vol.moduleNo == INVALID_MODULE_NO)
   {
      FLStatus status;
      TLInfo info;

      /* Use the sockets buffer */

      exb->buffer = flBufferOf((unsigned)(exbs-exb));

      /* Find the number of blocks used needed for the EXB file */

      checkStatus(getExbInfo(&vol,buf,bufLen,exbFlags));

      /* Find TFFS heap size */

      if (!(vol.flags & VOLUME_ABS_MOUNTED))
         checkStatus(absMountVolume(&vol));
      ioreq->irData     = &info;
      checkStatus(vol.tl.getTLInfo(vol.tl.rec,&info));
      exb->tffsHeapSize = (dword)(vol.flash->chipSize * vol.flash->noOfChips) >> info.tlUnitBits;

      /* Add heap for dynamic allocation not related to convertion tables */

      if((exbFlags & FIRMWARE_NO_MASK) >> FIRMWARE_NO_SHIFT == 0)
      {
         /* virutal TABLE + physical table */
         exb->tffsFarHeapSize = (word)(((exb->tffsHeapSize * 3) >> SECTOR_SIZE_BITS) + 1);
         exb->tffsHeapSize    = INFTL_NEAR_HEAP_SIZE;
      }
      else /* Old TrueFFS source */
      {
         exb->tffsFarHeapSize = 0;
         exb->tffsHeapSize = exb->tffsHeapSize * 3 + DEFAULT_DOC_STACK;
      }

      /* Check if binary partition is formated for EXB */

      bdk->startingBlock = 0;
      ioreq->irData      = bdk;
      status = bdkCall(FL_BINARY_PARTITION_INFO,ioreq,vol.flash);

      if ((bdk->startingBlock < vol.binaryLength) || (status != flOK))
      {
         DFORMAT_PRINT(("ERROR - Not enough binary area marked for EXB.\r\n"));
         return flNoSpaceInVolume;
      }

      /* initialize binary area for writting the EXB file */

      bdk->length        = ((vol.binaryLength-1) >> vol.flash->erasableBlockSizeBits) +1;
      bdk->startingBlock = 0;
      bdk->signOffset    = EXB_SIGN_OFFSET;

      checkStatus(bdkCall(FL_BINARY_ERASE,ioreq,vol.flash)); /* ERASE */
      if ((exbFlags & LEAVE_EMPTY) == 0)
      {
         /* If actualy need to place firmware initialize Binary write */
         bdk->length        = vol.binaryLength;
         bdk->flags         = BDK_COMPLETE_IMAGE_UPDATE | EDC;
         bdkVol->bdkGlobalStatus |= BDK_S_INFO_FOUND; /* do not research */
         checkStatus(bdkCall(FL_BINARY_WRITE_INIT,ioreq,vol.flash));
         tffsset(BUFFER,0xff,SECTOR_SIZE);
      }
      exb->exbFileOffset = 0;        /* start of exb file          */
      exb->bufferOffset  = 0;        /* start of internal buffer   */
      exb->moduleLength  = 0;        /* size of the current module */
      exb->exbFlags      = exbFlags; /* see list in doc2exb.h      */
      vol.moduleNo       = 0;        /* module IPL                 */
   }
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                    p l a c e E x b B y B u f f e r                   */
/*                                                                      */
/* Place M-systems firmware file on the media.                          */
/* This routine analizes the exb file calclating the media space needed */
/* for it taking only the device specific code.                         */
/*                                                                      */
/* Note : The media must be already formated with enough binary area    */
/* already marked with the SPL signature. This routine is best used     */
/* with the format routine where the format routine is givven the first */
/* 512 bytes while the rest of the file is given with this routine      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol          : Pointer identifying drive                        */
/*      buf          : Buffer containing EXB file data                  */
/*      bufLen       : Size of the current buffer                       */
/*      windowBase   : Optional set window base address                 */
/*      exbFlags     : INSTALL_FIRST - Install device as drive C:        */
/*                     FLOPPY        - Install device as drive A:        */
/*                     QUIET          - Do not show TFFS titles         */
/*                     INT15_DISABLE - Do not hook int 15               */
/*                     SIS5598       - Support for SIS5598 platforms    */
/*                     NO_PNP_HEADER - Do not place the PNP bios header */
/*                     LEAVE_EMPTY   - Leave space for firmware         */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

FLStatus placeExbByBuffer(Volume vol, byte FAR1 * buf, dword bufLen,
              word docWinBase ,word exbFlags)
{
   IOreq       ioreq;
   BDKStruct   bdk;
   word        tmpWord;
   Sdword      length       = bufLen;
   byte        anandMark[2] = {0x55,0x55};
   exbStruct*  exb          = &exbs[(byte)(&vol-vols)];
   BIOSHeader* hdr;
   IplHeader   *ipl;
   SplHeader   *spl;
   TffsHeader  *tffs;

   /* Initialize binary partition call packet */

   tffscpy(bdk.oldSign,SIGN_SPL,BINARY_SIGNATURE_NAME);  /* firmware signature */
   ioreq.irData   = &bdk;
   bdk.signOffset = EXB_SIGN_OFFSET;
   ioreq.irHandle = 0;

   /* First time initialization */

   checkStatus(firstTimeInit(&vol,exb,buf,bufLen,&ioreq, &bdk, exbFlags));

   /* Initialize the rest of the binary partition call packet */

   bdk.bdkBuffer  = BUFFER;         /* internal bufer  */
   bdk.length     = sizeof(BUFFER); /* buffer size     */
   bdk.flags     |= ERASE_BEFORE_WRITE; /* Erase each unit before writing */

   /* Make sure this is a relevant part of the file */

   if (exb->exbFileOffset + length < exb->firmwareStart)
   {
      /* Before this specific device firmware */
      exb->exbFileOffset += length;
      return flOK;
   }

   if (exb->exbFileOffset >= exb->firmwareEnd)
   {
      /* After this specific device firmware */
      exb->exbFileOffset += length;
      if (exb->exbFileOffset >= exb->exbFileEnd)
      {
         vol.moduleNo = INVALID_MODULE_NO;
         if (vol.flash->download != NULL)
            return vol.flash->download(vol.flash); /* download IPL */
      }
      return flOK;
   }

   if (exb->exbFileOffset < exb->firmwareStart)
   {
      length -= exb->firmwareStart - exb->exbFileOffset;
      exb->exbFileOffset = exb->firmwareStart;
   }

   /* Start writting the file modules */

   while ((exb->firmwareEnd > exb->exbFileOffset) && (length >0))
   {
      /* Read next page into internal buffer */

      /* DOC2000 IPL is ROM and it assumed small pages therefore
         read only the first 256 bytes of each page.             */

      if ((vol.moduleNo == 1) && (vol.flash->mediaType == DOC_TYPE))
      {
         if (waitForFullBuffer(&vol , buf , bufLen , &length,
                               TRUE) == FALSE)  /* 256 BYTES */
         return flOK;
      }
      else
      {
         if ((waitForFullBuffer(&vol , buf , bufLen , &length,
                                FALSE) == FALSE) && /* 512 BYTES */
             (exb->exbFileOffset != exb->exbFileEnd)) /* Not last buffer */
            return flOK;
      }

      /* Update the module length according to its header */

      if (exb->moduleLength == 0)
      {
         /* All modules except for the SPL start with biosHdr record
            SPL has a 2 bytes opCode preciding the biosHdr and an
            incorrect module length */

         switch (vol.moduleNo) /* SPL */
         {
             case 1:
                hdr = &((SplHeader *)BUFFER)->biosHdr;
                /* calculate the number of buffers to use for the SPL */
                exb->moduleLength = (word)((exb->splEnd-exb->splStart) >> SECTOR_SIZE_BITS);
                /* Doc 2000 writes in chunks of 256 bytes therfore need to
                   double the amount of write operations */
                if (vol.flash->mediaType == DOC_TYPE)
                   exb->moduleLength = (word)(exb->moduleLength << 1);
                break;

             default : /* Get size from header */
                hdr = (BIOSHeader *) BUFFER;
                exb->moduleLength = hdr->lenMod512;
         }

         /* Check validy of bios header */

         if ((hdr->signature[0] != 0x55) || (hdr->signature[1] != 0xAA))
         {
            DFORMAT_PRINT(("ERROR - EXB file is missing one of the BIOS driver modules.\r\n"));
            return flBadLength;
         }

         /* Update neccesary fields in the modules headers */
         switch (vol.moduleNo)
         {
            case 0:   /* IPL */

               /* The IPL length is actualy the window size in order to */
               /* supply the BIOS the expantion range. The real size    */
               /* if calculated according to the exb file header.       */
               if (vol.moduleNo==0)
                  exb->moduleLength = exb->iplMod512;

               ipl = (IplHeader *)BUFFER;

               /* Set 0000 pointer of ISA P&P Header */

               if(exb->exbFlags & NO_PNP_HEADER)
               {
                  ipl->dummy    += ((byte)(ipl->pnpHeader >> 8) +
                                    (byte)ipl->pnpHeader);
                  ipl->pnpHeader = 0;
               }

               /* Set DOC Window base explicitely */

               if( docWinBase > 0 )
               {
                  toLE2(ipl->windowBase , docWinBase);
                  ipl->dummy     -= (byte)( docWinBase );
                  ipl->dummy     -= (byte)( docWinBase >> 8 );
               }
               break;

            case 1:   /* SPL */

               spl = (SplHeader *)BUFFER;

               /* calculate EXB module size */

               /* generate random run-time ID and write it into splHeader. */

               tmpWord = (word)flRandByte();
               toUNAL2(spl->runtimeID, tmpWord);
               spl->chksumFix -= (byte)(tmpWord);
               spl->chksumFix -= (byte)(tmpWord >> 8);

               /* Write TFFS heap size into splHeader. */

               toUNAL2(spl->tffsHeapSize, (word)exb->tffsHeapSize);
               spl->chksumFix -= (byte)(exb->tffsHeapSize);
               spl->chksumFix -= (byte)(exb->tffsHeapSize >> 8);

               /* set explicit DOC window base */

               if( docWinBase > 0 )
               {
                  toUNAL2(spl->windowBase, docWinBase);
                  spl->chksumFix -= (byte)(docWinBase);
                  spl->chksumFix -= (byte)(docWinBase >> 8);
               }

               break;

            case 2:   /* Socket Services OR interupt 13 driver */

               /* The doc2000 driver and or socket services start
                  at 0x4000 so we have to jump over there. */
               if (vol.flash->mediaType == DOC_TYPE)
               {
                  bdkVol->actualUpdateLen -= 0x4000 - bdkVol->curUpdateImageAddress;
                  bdkVol->curUpdateImageAddress = 0x4000;
               }
               tffs             = (TffsHeader *)BUFFER;
               tffs->chksumFix -= (byte)(exb->tffsFarHeapSize);
               tffs->chksumFix -= (byte)(exb->tffsFarHeapSize >> 8);
               toUNAL2(tffs->heapLen, exb->tffsFarHeapSize);
               exb->exbFlags   &= ~NO_PNP_HEADER;

            default:

               /* put "install as first drive" & QUIET mark
                  into the TFFS header */

               tffs = (TffsHeader *)BUFFER;
               tffs->exbFlags   = (byte)exb->exbFlags;
               tffs->chksumFix -= (byte)exb->exbFlags;

           break;
         } /* end - switch of module type */
      } /* end - first buffer of module */

      exb->moduleLength--;

      /* Write module and clean buffer */

      switch (vol.moduleNo)
      {
         case 0: /* IPL data */

            switch (vol.flash->mediaType)
            {
               case MDOC_TYPE: /* Millennium 8 - use bdk to write IPL * 2 */

                  if (exb->moduleLength == exb->iplMod512 - 1)
                  {
                    /* Milennium DiskOnChip is the only device that the IPL
                       is duplicated in the exb file. The dupplication was
                       needed in earlier versions but it is currently ignored.
                       The IPL is still written twice only that the second
                       copy is not taken from the file but the first copy is
                       simply written twice. */
                    if ((exbFlags & LEAVE_EMPTY) == 0)
                    {
                       checkStatus(bdkCall(FL_BINARY_WRITE_BLOCK,
                                           &ioreq,vol.flash));
                       checkStatus(bdkCall(FL_BINARY_WRITE_BLOCK,
                                           &ioreq,vol.flash));
                    }
                  }
                  /* Change byte #406 to non-0xFF value to force
                     Internal EEprom Mode */
                  checkStatus(vol.flash->write(vol.flash,
                  ANAND_MARK_ADDRESS,anandMark,ANAND_MARK_SIZE,EXTRA));
                  break;

               case DOC2000TSOP_TYPE: /* Doc 2000 tsop - write to block 0 */
               case MDOCP_TYPE:   /* Millennium Plus - use MTD specific routine */
               case MDOCP_16_TYPE:

                  if (vol.flash->writeIPL == NULL)
                     return flFeatureNotSupported;
                  if ((exbFlags & LEAVE_EMPTY) != 0)
                  {
                     /* Erase previous IPL if all we need is to leave
                        space for the firmware and not realy write it */
                     tffsset(BUFFER,0xff,SECTOR_SIZE);
                  }
                  checkStatus(vol.flash->writeIPL(vol.flash,
                              BUFFER,SECTOR_SIZE,
                              (byte)(exb->iplMod512 - exb->moduleLength-1),
                              FL_IPL_MODE_NORMAL));
               default: /* DiskOnChip 2000 */

                  break; /* IPL is burnt onto ROM */
            }
            break;

         default:

            if ((exbFlags & LEAVE_EMPTY) == 0)
            {
               checkStatus(bdkCall(FL_BINARY_WRITE_BLOCK,&ioreq,vol.flash));
            }
      }
      tffsset(BUFFER,0xff,sizeof(BUFFER));

      if (exb->moduleLength == 0)
         vol.moduleNo++;
   }

   if (exb->exbFileOffset >= exb->firmwareEnd)
   {
      exb->exbFileOffset += length;
   }
   if (exb->exbFileOffset >= exb->exbFileEnd)
   {
      vol.moduleNo = INVALID_MODULE_NO;
      if (vol.flash->download != NULL)
         return vol.flash->download(vol.flash); /* download IPL */
   }
   return(flOK);
}

#endif /* WRITE_EXB_IMAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\blockdev.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/BLOCKDEV.H_V  $
 * 
 *    Rev 1.20   Apr 15 2002 07:34:06   oris
 * Bug fix - FL_IPL_MODE_XSCALE define was set to 3 instead of 4 and therefore caused FL_IPL_DOWNLOAD and FL_IPL_MODE_SA to be set as well.
 * 
 *    Rev 1.19   Feb 19 2002 20:58:20   oris
 * Removed warnings.
 * Moved FLFunctionNo enumerator to dedicated file flfuncno.h
 * Added include directive for cleaner customer usage.
 * 
 *    Rev 1.18   Jan 29 2002 20:07:16   oris
 * Moved flParsePath declaration to the end of the file.
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * Added documentation of irFlags in flMountVolume (returns no of hidden sectors of the media).
 * flSetEnvVolume, flSetEnvSocket , flSetEnvAll , flSetDocBusRoutine , flGetDocBusRoutine, flBuildGeometry , bdCall and flExit
 * Added FL_IPL_MODE_XSCALE definition and change FL_IPL_XXX values.
 * 
 *    Rev 1.17   Jan 28 2002 21:23:46   oris
 * Changed FL_NFTL_CACHE_ENABLED to FL_TL_CACHE_ENABLED.
 * Changed flSetDocBusRoutine interface and added flGetDocBusRoutine. 
 * 
 *    Rev 1.16   Jan 23 2002 23:30:54   oris
 * Added documentation of irData and irLength to flCheckVolume.
 * 
 *    Rev 1.15   Jan 20 2002 20:27:40   oris
 * Added TL_NORMAL_FORMAT flag was added to bdFormatPhisycalDrive instead of 0 (in the comments).
 * Removed TL_QUICK_MOUNT_FORMAT flag definition.
 * 
 *    Rev 1.14   Jan 17 2002 22:57:18   oris
 * Added flClearQuickMountInfo() routine - FL_CLEAR_QUICK_MOUNT_INFO
 * Added flVerifyVolume() routine - FL_VERIFY_VOLUME
 * Added DiskOnChip Millennium Plus 16MB type
 * Changed the order of FLEnvVars enumerator.
 * Added FLEnvVars values for :
 *       FL_SECTORS_VERIFIED_PER_FOLDING 
 *       FL_SUSPEND_MODE
 *       FL_VERIFY_WRITE_OTHER
 *       FL_MTD_BUS_ACCESS_TYPE
 *       FL_VERIFY_WRITE_BDTL
 *       FL_VERIFY_WRITE_BINARY
 * flSetEnv() routine was changed into 3 different routines: flSetEnvVolume / flSetEnvSocket / flSetEnvAll
 * Removed TL_SINGLE_FLOOR_FORMATTING flag definition from format routine.
 * Added flSetDocBusRoutines prototype and required definitions.
 * 
 *    Rev 1.13   Nov 21 2001 11:39:36   oris
 * Changed FL_VERIFY_WRITE_MODE to FL_MTD_VERIFY_WRITE.
 * 
 *    Rev 1.12   Nov 08 2001 10:44:18   oris
 * Added FL_VERIFY_WRITE_MODE enumerator type for the flSetEnv routine .
 * Moved environment variable states definitions to flbase.h.
 * 
 *    Rev 1.11   Sep 15 2001 23:44:30   oris
 * Placed flDeepPowerDownMone under LOW_LEVEL compilation flag.
 * 
 *    Rev 1.10   May 17 2001 16:50:32   oris
 * Removed warnings.
 * 
 *    Rev 1.9   May 16 2001 21:16:22   oris
 * Added the Binary state (0,1) of the environment variables to meaningful definitions.
 * Removed LAST function enumerator.
 * Improved documentation.
 * 
 *    Rev 1.8   May 06 2001 22:41:14   oris
 * Added SUPPORT_WRITE_IPL_ROUTIN capability.
 * 
 *    Rev 1.7   Apr 30 2001 17:57:50   oris
 * Added required defintions to support the flMarkDeleteOnFlash environment variable. 
 * 
 *    Rev 1.6   Apr 24 2001 17:05:52   oris
 * Changed bdcall function numbers in order to allow future grouth.
 * 
 *    Rev 1.5   Apr 01 2001 07:49:04   oris
 * Added FL_READ_IPL .
 * flChangeEnvironmentVariable prototype removed.
 * Moved s/w protection definitions from iovtl.h to blockdev.h
 * Changed s\w and h\w to s/w and h/w.
 * Added flBuildGeometry prototype 
 * Moved bdcall prototype to the end of the file with the rest of the prototypes.
 * 
 *    Rev 1.4   Feb 18 2001 14:15:38   oris
 * Changed function enums order.
 *
 *    Rev 1.3   Feb 14 2001 01:44:16   oris
 * Changed capabilities from defined flags to an enumerator
 * Improoved documentation of readBBT, writeBBT InquireCapabilities, countVolumes
 * Added environment variables defintions
 *
 *    Rev 1.2   Feb 13 2001 02:08:42   oris
 * Moved LOCKED_OTP and DEEP_POWER_DOWN to flflash.h
 * Moved TL_FORMAT_FAT and TL_FORMAT_COMPRESSION to flformat.h
 * Added extern declaration for flSetEnv routine.
 *
 *    Rev 1.1   Feb 12 2001 11:54:46   oris
 * Added baseAddress in flGetPhysicalInfo as irLength.
 * Added boot sectors in flMountVolumes as irFlags.
 * Change order of routines definition.
 *
 *    Rev 1.0   Feb 04 2001 18:05:04   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef BLOCKDEV_H
#define BLOCKDEV_H

#include "flreq.h"
#include "flfuncno.h"
#include "docsys.h"

#ifdef FORMAT_VOLUME
#include "dosformt.h"
#endif /* FORMAT_VOLUME */
#ifdef WRITE_EXB_IMAGE
#include "doc2exb.h"
#else
#ifdef BDK_ACCESS
#include "docbdk.h"
#endif /* BDK_ACCESS */
#endif /* WRITE_EXB_IMAGE */



/*----------------------------------------------------------------------*/
/*                           b d C a l l                                */
/*                                                                      */
/* Common entry-point to all TrueFFS functions. Macros are to call      */
/* individual function, which are separately described below.           */
/*                                                                      */
/* Parameters:                                                          */
/*        function   : Block device driver function code (listed below) */
/*        ioreq      : IOreq structure                                  */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus   : 0 on success, otherwise failed                   */
/*----------------------------------------------------------------------*/

#if FILES > 0
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                     f l F l u s h B u f f e r                        */
/*                                                                      */
/* If there is relevant data in the RAM buffer then writes it on        */
/*   the flash memory.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Drive number (0, 1, ...)                          */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flFlushBuffer(ioreq)        bdCall(FL_FLUSH_BUFFER,ioreq)

#endif                                  /* READ_ONLY */
/*----------------------------------------------------------------------*/
/*                      f l O p e n F i l e                             */
/*                                                                      */
/* Opens an existing file or creates a new file. Creates a file handle  */
/* for further file processing.                                         */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irFlags         : Access and action options, defined below    */
/*        irPath          : path of file to open                        */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irHandle        : New file handle for open file               */
/*                                                                      */
/*----------------------------------------------------------------------*/

/** Values of irFlags for flOpenFile: */

#define ACCESS_MODE_MASK   3 /* Mask for access mode bits */

/* Individual flags */

#define ACCESS_READ_WRITE  1 /* Allow read and write */
#define ACCESS_CREATE      2 /* Create new file      */

/* Access mode combinations */

#define OPEN_FOR_READ      0 /* open existing file for read-only         */
#define OPEN_FOR_UPDATE    1 /* open existing file for read/write access */
#define OPEN_FOR_WRITE     3 /* create a new file, even if it exists     */


#define flOpenFile(ioreq)        bdCall(FL_OPEN_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*                      f l C l o s e F i l e                           */
/*                                                                      */
/* Closes an open file, records file size and dates in directory and    */
/* releases file handle.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Handle of file to close.                    */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flCloseFile(ioreq)      bdCall(FL_CLOSE_FILE,ioreq)

#ifndef FL_READ_ONLY
#ifdef SPLIT_JOIN_FILE

/*------------------------------------------------------------------------*/
/*                      f l S p l i t F i l e                             */
/*                                                                        */
/* Splits the file into two files. The original file contains the first   */
/* part, and a new file (which is created for that purpose) contains      */
/* the second part. If the current position is on a cluster               */
/* boundary, the file will be split at the current position. Otherwise,   */
/* the cluster of the current position is duplicated, one copy is the     */
/* first cluster of the new file, and the other is the last cluster of the*/
/* original file, which now ends at the current position.                 */
/*                                                                        */
/* Parameters:                                                            */
/*        file            : file to split.                                */
/*      irPath          : Path name of the new file.                      */
/*                                                                        */
/* Returns:                                                               */
/*        irHandle        : handle of the new file.                       */
/*        FLStatus        : 0 on success, otherwise failed.               */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define flSplitFile(ioreq)     bdCall(FL_SPLIT_FILE,ioreq)


/*------------------------------------------------------------------------*/
/*                      f l J o i n F i l e                               */
/*                                                                        */
/* joins two files. If the end of the first file is on a cluster          */
/* boundary, the files will be joined there. Otherwise, the data in       */
/* the second file from the beginning until the offset that is equal to   */
/* the offset in cluster of the end of the first file will be lost. The   */
/* rest of the second file will be joined to the first file at the end of */
/* the first file. On exit, the first file is the expanded file and the   */
/* second file is deleted.                                                */
/* Note: The second file will be open by this function, it is advised to  */
/*         close it before calling this function in order to avoid        */
/*         inconsistencies.                                               */
/*                                                                        */
/* Parameters:                                                            */
/*        file            : file to join to.                              */
/*        irPath          : Path name of the file to be joined.           */
/*                                                                        */
/* Return:                                                                */
/*        FLStatus        : 0 on success, otherwise failed.               */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define flJoinFile(ioreq)     bdCall(FL_JOIN_FILE,ioreq)

#endif /* SPLIT_JOIN_FILE */
#endif /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*                      f l R e a d F i l e                             */
/*                                                                      */
/* Reads from the current position in the file to the user-buffer.      */
/* Parameters:                                                          */
/*        irHandle     : Handle of file to read.                        */
/*        irData       : Address of user buffer                         */
/*        irLength     : Number of bytes to read. If the read extends   */
/*                       beyond the end-of-file, the read is truncated  */
/*                       at the end-of-file.                            */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus     : 0 on success, otherwise failed                 */
/*        irLength     : Actual number of bytes read                    */
/*----------------------------------------------------------------------*/

#define flReadFile(ioreq)        bdCall(FL_READ_FILE,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                      f l W r i t e F i l e                           */
/*                                                                      */
/* Writes from the current position in the file from the user-buffer.   */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Handle of file to write.                    */
/*        irData          : Address of user buffer                      */
/*        irLength        : Number of bytes to write.                   */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irLength        : Actual number of bytes written              */
/*----------------------------------------------------------------------*/

#define flWriteFile(ioreq)        bdCall(FL_WRITE_FILE,ioreq)

#endif  /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*                      f l S e e k F i l e                             */
/*                                                                      */
/* Sets the current position in the file, relative to file start, end or*/
/* current position.                                                    */
/* Note: This function will not move the file pointer beyond the        */
/* beginning or end of file, so the actual file position may be         */
/* different from the required. The actual position is indicated on     */
/* return.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : File handle to close.                             */
/*        irLength  : Offset to set position.                           */
/*        irFlags   : Method code                                       */
/*                     SEEK_START: absolute offset from start of file   */
/*                     SEEK_CURR:  signed offset from current position  */
/*                     SEEK_END:   signed offset from end of file       */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irLength        : Actual absolute offset from start of file   */
/*----------------------------------------------------------------------*/

/* Values of irFlags for flSeekFile: */

#define   SEEK_START   0        /* offset from start of file    */
#define   SEEK_CURR    1        /* offset from current position */
#define   SEEK_END     2        /* offset from end of file      */


#define flSeekFile(ioreq)        bdCall(FL_SEEK_FILE,ioreq)

/*----------------------------------------------------------------------*/
/*                          f l F i n d F i l e                         */
/*                                                                      */
/* Finds a file entry in a directory, optionally modifying the file     */
/* time/date and/or attributes.                                         */
/* Files may be found by handle no. provided they are open, or by name. */
/* Only the Hidden, System or Read-only attributes may be modified.     */
/* Entries may be found for any existing file or directory other than   */
/* the root. A DirectoryEntry structure describing the file is copied   */
/* to a user buffer.                                                    */
/*                                                                      */
/* The DirectoryEntry structure is defined in dosformt.h                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle     : If by name: Drive number (socket+partitions)   */
/*                       else      : Handle of open file                */
/*        irPath       : If by name: Specifies a file or directory path */
/*        irFlags      : Options flags                                  */
/*                        FIND_BY_HANDLE: Find open file by handle.     */
/*                                        Default is access by path.    */
/*                        SET_DATETIME:   Update time/date from buffer  */
/*                        SET_ATTRIBUTES: Update attributes from buffer */
/*        irDirEntry   : Address of user buffer to receive a            */
/*                       DirectoryEntry structure                       */
/*                                                                      */
/* Returns:                                                             */
/*        irLength        : Modified                                    */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

/** Bit assignment of irFlags for flFindFile: */

#define SET_DATETIME     1   /* Change date/time                        */
#define SET_ATTRIBUTES   2   /* Change attributes                       */
#define FIND_BY_HANDLE   4   /* Find file by handle rather than by name */

#define        flFindFile(ioreq)        bdCall(FL_FIND_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*                 f l F i n d F i r s t F i l e                        */
/*                                                                      */
/* Finds the first file entry in a directory.                           */
/* This function is used in combination with the flFindNextFile call,   */
/* which returns the remaining file entries in a directory sequentially.*/
/* Entries are returned according to the unsorted directory order.      */
/* flFindFirstFile creates a file handle, which is returned by it. Calls*/
/* to flFindNextFile will provide this file handle. When flFindNextFile */
/* returns 'noMoreEntries', the file handle is automatically closed.    */
/* Alternatively the file handle can be closed by a 'closeFile' call    */
/* before actually reaching the end of directory.                       */
/* A DirectoryEntry structure is copied to the user buffer describing   */
/* each file found. This structure is defined in dosformt.h.            */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle      : Drive number (0, 1, ...)                      */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath         : Specifies a directory path                   */
/*        irData         : Address of user buffer to receive a          */
/*                         DirectoryEntry structure                     */
/*                                                                      */
/* Returns:                                                             */
/*        irHandle       : File handle to use for subsequent operations */
/*        FLStatus       : 0 on success, otherwise failed               */
/*----------------------------------------------------------------------*/

#define        flFindFirstFile(ioreq)        bdCall(FL_FIND_FIRST_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*                 f l F i n d N e x t F i l e                          */
/*                                                                      */
/* See the description of 'flFindFirstFile'.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : File handle returned by flFindFirstFile.    */
/*        irData          : Address of user buffer to receive a         */
/*                          DirectoryEntry structure                    */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define        flFindNextFile(ioreq)        bdCall(FL_FIND_NEXT_FILE,ioreq)

/*----------------------------------------------------------------------*/
/*                      f l G e t D i s k I n f o                       */
/*                                                                      */
/* Returns general allocation information.                              */
/*                                                                      */
/* The bytes/sector, sector/cluster, total cluster and free cluster     */
/* information are returned into a DiskInfo structure.                  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData          : Address of DiskInfo structure               */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

typedef struct {
  unsigned        bytesPerSector;
  unsigned        sectorsPerCluster;
  unsigned        totalClusters;
  unsigned        freeClusters;
} DiskInfo;

#define flGetDiskInfo(ioreq)        bdCall(FL_GET_DISK_INFO,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                      f l D e l e t e F i l e                         */
/*                                                                      */
/* Deletes a file.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath          : path of file to delete                      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flDeleteFile(ioreq)        bdCall(FL_DELETE_FILE,ioreq)

#ifdef RENAME_FILE

/*----------------------------------------------------------------------*/
/*                      f l R e n a m e F i l e                         */
/*                                                                      */
/* Renames a file to another name.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath          : path of existing file                       */
/*        irData          : path of new name.                           */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flRenameFile(ioreq)        bdCall(FL_RENAME_FILE,ioreq)

#endif /* RENAME_FILE */

#ifdef SUB_DIRECTORY

/*----------------------------------------------------------------------*/
/*                      f l M a k e D i r                               */
/*                                                                      */
/* Creates a new directory.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath          : path of new directory.                      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flMakeDir(ioreq)        bdCall(FL_MAKE_DIR,ioreq)

/*----------------------------------------------------------------------*/
/*                      f l R e m o v e D i r                           */
/*                                                                      */
/* Removes an empty directory.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath          : path of directory to remove.                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flRemoveDir(ioreq)        bdCall(FL_REMOVE_DIR,ioreq)

#endif /* SUB_DIRECTORY */
#endif /* FL_READ_ONLY */

#endif /* FILES > 0 */

/*----------------------------------------------------------------------*/
/*                     V o l u m e I n f o R e c o r d                  */
/*                                                                      */
/* A structure that holds general information about the media. The      */
/* information includes Physical Info (see flGetPhysicalInfo), Logical  */
/* partition (number of sectors and CHS), boot area size, S/W versions  */
/* Media life-time etc.                                                 */
/* A pointer to this structure is passed to the function flVolumeInfo   */
/* where it receives the relevant data.                                 */
/*----------------------------------------------------------------------*/

typedef struct {
  unsigned long  logicalSectors;    /*  number of logical sectors                  */
  unsigned long  bootAreaSize;      /*  boot area size                             */
  unsigned long  baseAddress;       /*  physical base address                      */
#ifdef FL_LOW_LEVEL
  unsigned short flashType;         /*  JEDEC id of the flash                      */
  unsigned long  physicalSize;      /*  physical size of the media                 */
  unsigned short physicalUnitSize;  /*  Erasable block size                        */
  char DOCType;                     /*  DiskOnChip type (MDoc/Doc2000)             */
  char lifeTime;                    /*  Life time indicator for the media (1-10)   */
                                    /*  1 - the media is fresh,                    */
                                    /*  10 - the media is close to its end of life */
#endif
  char driverVer[10];               /*  driver version (NULL terminated string)    */
  char OSAKVer[10];                 /*  OSAK version that driver is based on
                                        (NULL terminated string)                   */
#ifdef ABS_READ_WRITE
  unsigned long cylinders;          /*  Media.....                                 */
  unsigned long heads;              /*            geometry......                   */
  unsigned long sectors;            /*                            parameters.      */
#endif
} VolumeInfoRecord;

/*----------------------------------------------------------------------*/
/*             f l V o l u m e I n f o                                  */
/*                                                                      */
/* Get general information about the media.                             */
/*                                                                      */
/* Parameters:                                                          */
/*      irHandle        : Socket number (0,1,..)                        */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*      irData    : Address of user buffer to read general              */
/*                          information into.                           */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flVolumeInfo(ioreq) bdCall(FL_VOLUME_INFO,ioreq)

/*----------------------------------------------------------------------*/
/*                f l C o u n t V o l u m e s                           */
/*                                                                      */
/* Counts the number of volumes on the Flash device.                    */
/*                                                                      */
/* This routine is applicable only for TL that can accomdate more then  */
/* a single volume on a flash medium. other TL's will simply return 1   */
/* while not even tring to access the medium.                           */
/*                                                                      */
/* Not all the volumes can neccesaryly be mounted. A drive formated     */
/* with a read protection will be registered but can not be accessed.   */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number ( 0,1,2...  )                 */
/*                        : Partition number ( 0,1,2...  )              */
/*        irFlags         : Returns the number of partitions            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flCountVolumes(ioreq)        bdCall(FL_COUNT_VOLUMES,ioreq)

/*----------------------------------------------------------------------*/
/*                f l C l e a r Q u i c k M o u n t I n f o             */
/*                                                                      */
/* Clear all quick mount informtion.                                    */
/*                                                                      */
/* Must be called before calling mount volume routines.                 */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number ( 0,1,2...  )                 */
/*                        : Partition number ( 0,1,2...  )              */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flClearQuickMountInfo(ioreq) bdCall(FL_CLEAR_QUICK_MOUNT_INFO,ioreq)

/*----------------------------------------------------------------------*/
/*                      f l M o u n t V o l u m e                       */
/*                                                                      */
/* Mounts, verifies or dismounts the Flash medium.                      */
/*                                                                      */
/* In case the inserted volume has changed, or on the first access to   */
/* the file system, it should be mounted before file operations can be  */
/* done on it.                                                          */
/*                                                                      */
/* The volume automatically becomes unmounted if it is removed or       */
/* changed.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0, 1, ...)                   */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */
/*        irFlags         : Number of hidden sectors.                   */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flMountVolume(ioreq)        bdCall(FL_MOUNT_VOLUME,ioreq)

/*----------------------------------------------------------------------*/
/*                  f l A b s M o u n t V o l u m e                     */
/*                                                                      */
/* Mounts, verifies or dismounts the Flash medium.                      */
/*                                                                      */
/* The volume automatically becomes unmounted if it is removed or       */
/* changed.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0, 1, ...)                   */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flAbsMountVolume(ioreq)        bdCall(FL_ABS_MOUNT,ioreq)

/*----------------------------------------------------------------------*/
/*                  f l V e r i f y V o l u m e                         */
/*                                                                      */
/* Verifies a mounted volume for partialy written sectors.              */
/*                                                                      */
/* Note: The volume must be mounted first.                              */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0, 1, ...)                   */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */
/*        irData          : Must be set to NULL                         */
/*        irLength        : Must be set to 0                            */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flVerifyVolume(ioreq)        bdCall(FL_VERIFY_VOLUME,ioreq)

/*----------------------------------------------------------------------*/
/*                   f l D i s m o u n t V o l u m e                    */
/*                                                                      */
/* Dismounts the volume.                                                */
/* This call is not normally necessary, unless it is known the volume   */
/* will soon be removed.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus                : 0 on success, otherwise failed      */
/*----------------------------------------------------------------------*/

#define flDismountVolume(ioreq)        bdCall(FL_DISMOUNT_VOLUME,ioreq)


/*----------------------------------------------------------------------*/
/*                     f l C h e c k V o l u m e                        */
/*                                                                      */
/* Verifies that the current volume is mounted.                         */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flCheckVolume(ioreq)        bdCall(FL_CHECK_VOLUME,ioreq)

/*----------------------------------------------------------------------*/
/*                        r e a d B B T                                 */
/*                                                                      */
/* Read Bad Blocks Table of device to user buffer                       */
/*                                                                      */
/* Note: The user buffer is filled with the address of the bad units    */
/*       the buffer maximum size is 2% of the number of TL units of the */
/*       specific device * 4 bytes. therfore a 8M device of 8KB erase   */
/*       zone will need a maximum size buffer of 1024 * 0.02 * 4 = 82B  */
/*       and a 192M with 16KB erase zones will need 960Bytes            */
/*                                                                      */
/* Note: the buffer is not initialized by the function                  */
/*                                                                      */
/* Parameters:                                                          */
/*      irData          : User buffer.                                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irLength        : returns the media size                        */
/*      irFlags         : returns the actual number of badBlocks        */
/*----------------------------------------------------------------------*/

#define flReadBBT(ioreq) bdCall(FL_READ_BBT,ioreq)

/*----------------------------------------------------------------------*/
/*                 f l S e c t o r s I n V o l u m e                    */
/*                                                                      */
/* Returns number of virtual sectors in volume.                         */
/*                                                                      */
/* In case the inserted volume is not mounted, returns current status.  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Drive number (0, 1, ...)                          */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*      irLength        : number of virtual sectors in volume           */
/*----------------------------------------------------------------------*/

#define flSectorsInVolume(ioreq)        bdCall(FL_SECTORS_IN_VOLUME,ioreq)



#ifndef FL_READ_ONLY
#ifdef DEFRAGMENT_VOLUME

/*----------------------------------------------------------------------*/
/*                      f l D e f r a g m e n t V o l u m e             */
/*                                                                      */
/* Performs a general defragmentation and recycling of non-writable     */
/* Flash areas, to achieve optimal write speed.                         */
/*                                                                      */
/* NOTE: The required number of sectors (in irLength) may be changed    */
/* (from another execution thread) while defragmentation is active. In  */
/* particular, the defragmentation may be cut short after it began by   */
/* modifying the irLength field to 0.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Drive number (0, 1, ...)                          */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irLength  : Minimum number of sectors to make available for   */
/*                    writes.                                           */
/*                                                                      */
/* Returns:                                                             */
/*        irLength  : Actual number of sectors available for writes     */
/*        FLStatus  : 0 on success, otherwise failed                    */
/*----------------------------------------------------------------------*/

#define flDefragmentVolume(ioreq)        bdCall(FL_DEFRAGMENT_VOLUME,ioreq)

#endif /* DEFRAGMENT_VOLUME */

#ifdef FORMAT_VOLUME

/*----------------------------------------------------------------------*/
/*                    f l F o r m a t V o l u m e                       */
/*                                                                      */
/* Performs  formatting of the DiskOnChip.                              */
/*  All existing data is destroyed.                                     */
/*                                                                      */
/* Note : This routine does not support some of the new feature         */
/*        introduces in OSAK 5.0 and was left in order to support       */
/*        backwards compatibility with application build on OSAK 4.2    */
/*        and down.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Socket number (0, 1, ...)                         */
/*                  : Partition number must be 0                        */
/*        irFlags   : TL_FORMAT          : Translation layer formatting */
/*                                         + FAT formating              */
/*                    TL_FORMAT_IF_NEEDED: Translation layer formatting */
/*                                         only if current format is    */
/*                                         invalid + FAT format         */
/*                  : FAT_ONLY_FORMAT    : FAT only formatting          */
/*                  : TL_FORMAT_ONLY     : Translation layer formatting */
/*                                         without FAT format           */
/*        irData    : Address of FormatParams structure to use          */
/*                              (defined in format.h)                   */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flFormatVolume(ioreq) bdCall(BD_FORMAT_VOLUME,ioreq)

/** Values of irFlags for flLowLevelFormat: */

#define FAT_ONLY_FORMAT     0
#define TL_FORMAT           1
#define TL_FORMAT_IF_NEEDED 2
#define TL_FORMAT_ONLY      8

/*----------------------------------------------------------------------*/
/*            f l F o r m a t P h i s i c a l D r i v e                 */
/*                                                                      */
/* Performs formatting of the DiskOnChip.                               */
/* All existing data is destroyed.                                      */
/*                                                                      */
/* Note : This routine is the format routine for OSAK 5.0 and up.       */
/* Note : This routine is the format routine for OSAK 5.0               */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle : Socket number (0, 1, ...)                          */
/*                   Partition number must be 0                         */
/*        irFlags  :                                                    */
/*              TL_NORMAL_FORMAT       : Normal format                  */
/*              TL_LEAVE_BINARY_AREA   : Leave the previous binary area */
/*        irData          : Address of FormatParams2 structure to use   */
/*                              (defined in format.h)                   */
/* Returns:                                                             */
/*        FLStatus  : 0 on success, otherwise failed                    */
/*----------------------------------------------------------------------*/

#define flFormatPhysicalDrive(ioreq) bdCall(BD_FORMAT_PHYSICAL_DRIVE,ioreq)
#define    TL_NORMAL_FORMAT            0
#define    TL_LEAVE_BINARY_AREA        8

/*----------------------------------------------------------------------*/
/*           f l F o r m a t L o g i c a l D r i v e                    */
/*                                                                      */
/* Performs formatting of a single block device partition of a          */
/* DiskOnChip. All existing data of the partition is destroyed.         */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Drive number (0, 1, ...)                          */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData    : Address of BDTLPartitionFormatParams structure    */
/*                    to use (defined in format.h)                      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flFormatLogicalDrive(ioreq) bdCall(BD_FORMAT_LOGICAL_DRIVE,ioreq)

/*----------------------------------------------------------------------*/
/*                        w r i t e B B T                               */
/*                                                                      */
/* Erase the flash medium while marking bad block with 2 zeros in the   */
/* first page of the unit. This state is the virgin state of the flash  */
/* device allowing it to be reformated while incorporating the written  */
/* bad blocks.                                                          */
/*                                                                      */
/* Note that tl units are marked and not actual erasable blocks         */
/*                                                                      */
/* Parameters:                                                          */
/*      irData          : User buffer.                                  */
/*      irLength        : Size of the media to erase.                   */
/*      irFlags         : User buffer length in bytes.                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/
#define flWriteBBT(ioreq) bdCall(FL_WRITE_BBT,ioreq)

#endif /* FORMAT_VOLUME */
#endif /*FL_READ_ONLY */

#ifdef ABS_READ_WRITE

/*----------------------------------------------------------------------*/
/*                           f l A b s R e a d                          */
/*                                                                      */
/* Reads absolute sectors by sector no.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData          : Address of user buffer to read into         */
/*        irSectorNo      : First sector no. to read (sector 0 is the   */
/*                          DOS boot sector).                           */
/*        irSectorCount   : Number of consectutive sectors to read      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irSectorCount        : Number of sectors actually read        */
/*----------------------------------------------------------------------*/

#define flAbsRead(ioreq)        bdCall(FL_ABS_READ,ioreq)

/*----------------------------------------------------------------------*/
/*                         f l A b s A d d r e s s                      */
/*                                                                      */
/* Returns the current physical media offset of an absolute sector by   */
/* sector no.                                                           */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irSectorNo      : Sector no. to address (sector 0 is the DOS  */
/*                          boot sector)                                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irCount         : Offset of the sector on the physical media  */
/*----------------------------------------------------------------------*/

#define flAbsAddress(ioreq)                bdCall(FL_ABS_ADDRESS,ioreq)

/*----------------------------------------------------------------------*/
/*                           f l G e t B P B                            */
/*                                                                      */
/* Reads the BIOS Parameter Block from the boot sector                  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData          : Address of user buffer to read BPB into     */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flGetBPB(ioreq)                bdCall(FL_GET_BPB,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                         f l A b s W r i t e                          */
/*                                                                      */
/* Writes absolute sectors by sector no.                                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData          : Address of user buffer to write from        */
/*        irSectorNo      : First sector no. to write (sector 0 is the  */
/*                          DOS boot sector).                           */
/*        irSectorCount   : Number of consectutive sectors to write     */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irSectorCount   : Number of sectors actually written          */
/*----------------------------------------------------------------------*/

#define flAbsWrite(ioreq)        bdCall(FL_ABS_WRITE,ioreq)

/*----------------------------------------------------------------------*/
/*                         f l A b s D e l e t e                        */
/*                                                                      */
/* Marks absolute sectors by sector no. as deleted.                     */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irSectorNo      : First sector no. to delete (sector 0 is the */
/*                          DOS boot sector).                           */
/*        irSectorCount   : Number of consectutive sectors to delete    */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irSectorCount        : Number of sectors actually deleted     */
/*----------------------------------------------------------------------*/

#define flAbsDelete(ioreq)        bdCall(FL_ABS_DELETE,ioreq)

#ifdef WRITE_PROTECTION
/*----------------------------------------------------------------------*/
/*              f l W r i t e P r o t e c t i o n                       */
/*                                                                      */
/* Put and remove write protection from the volume                      */
/*                                                                      */
/* Note partition number 0 protectes the binary partition as well       */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irFlags         : FL_PROTECT=remove, FL_UNPROTECT=put         */
/*                          and FL_UNLOCK=unlock                        */
/*        irData          : password (8 bytes)                          */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flWriteProtection(ioreq) bdCall(FL_WRITE_PROTECTION,ioreq)
#define FL_PROTECT   0
#define FL_UNPROTECT 1
#define FL_UNLOCK    2
#endif /* WRITE_PROTETION */
#endif /* FL_READ_ONLY */
#endif /* ABS_READ_WRITE */

#ifdef FL_LOW_LEVEL

/*----------------------------------------------------------------------*/
/*                          P h y s i c a l I n f o                     */
/*                                                                      */
/* A structure that holds physical information about the media. The     */
/* information includes JEDEC ID, unit size and media size. Pointer     */
/* to this structure is passed to the function flGetPhysicalInfo where  */
/* it receives the relevant data.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

typedef struct {
  unsigned short type;         /* Flash device type (JEDEC id)         */
  char           mediaType;    /* type of media see below              */
  long int       unitSize;     /* Smallest physically erasable size
                                  (with interleaving taken in account) */
  long int       mediaSize;    /* media size in bytes                  */
  long int       chipSize;     /* individual chip size in bytes        */
  int            interleaving; /* device interleaving                  */
} PhysicalInfo;

/* media types */
#define FL_NOT_DOC     0
#define FL_DOC         1
#define FL_MDOC        2
#define FL_DOC2000TSOP 3
#define FL_MDOCP_16    4
#define FL_MDOCP       5

 
/*----------------------------------------------------------------------*/
/*                         f l G e t P h y s i c a l I n f o            */
/*                                                                      */
/* Get physical information of the media. The information includes      */
/* JEDEC ID, unit size and media size.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0,1,..)                      */
/*        irData          : Address of user buffer to read physical     */
/*                          information into.                           */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irLength        : Window base address. note mast be cast to   */
/*                          unsigned.                                   */
/*----------------------------------------------------------------------*/

#define flGetPhysicalInfo(ioreq)        bdCall(FL_GET_PHYSICAL_INFO, ioreq)

/*----------------------------------------------------------------------*/
/*                             f l P h y s i c a l R e a d              */
/*                                                                      */
/* Read from a physical address.                                        */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle         : Socket number (0,1,..)                     */
/*        irAddress        : Physical address to read from.             */
/*        irByteCount      : Number of bytes to read.                   */
/*        irData           : Address of user buffer to read into.       */
/*        irFlags          : Method mode                                */
/*                        EDC:       Activate ECC/EDC                   */
/*                        EXTRA:     Read/write spare area              */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flPhysicalRead(ioreq)                bdCall(FL_PHYSICAL_READ,ioreq)


#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                    f l P h y s i c a l W r i t e                     */
/*                                                                      */
/* Write to a physical address.                                         */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0,1,..)                      */
/*        irAddress       : Physical address to write to.               */
/*        irByteCount     : Number of bytes to write.                   */
/*        irData          : Address of user buffer to write from.       */
/*        irFlags         : Method mode                                 */
/*                        EDC:       Activate ECC/EDC                   */
/*                        EXTRA:     Read/write spare area              */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flPhysicalWrite(ioreq)                bdCall(FL_PHYSICAL_WRITE,ioreq)

/* Bit assignment of irFlags for flPhysicalRead or flPhysicalWrite: */
/*   ( defined in file flflash.h )                                  */
/* #define OVERWRITE    1        *//* Overwriting non-erased area   */
/* #define EDC          2        *//* Activate ECC/EDC              */
/* #define EXTRA        4        *//* Read/write spare area         */

/*----------------------------------------------------------------------*/
/*                    f l P h y s i c a l E r a s e                     */
/*                                                                      */
/* Erase physical units.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle       : Socket number (0,1,..)                       */
/*        irUnitNo        : First unit to erase.                        */
/*        irUnitCount     : Number of units to erase.                   */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flPhysicalErase(ioreq)                bdCall(FL_PHYSICAL_ERASE,ioreq)

#endif /* FL_READ_ONLY */

#ifdef BDK_ACCESS

 /*-------------------------------------------------------------------
 * bdkReadInit - Init read operations on the DiskOnChip starting
 *       at 'startUnit', with a size of 'areaLen' bytes and 'signature'.
 *
 * Note: Blocks in the DiskOnChip are marked with a 4-character signature
 *       followed by a 4-digit hexadecimal number.
 *
 * Parameters:
 *             'irHandle'      - Drive number (0, 1, ...)
 *                        bits 7-4 - Partition # (zero based)           
 *                        bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                startingBlock - unit number of the sub-partition to start reading from
 *                length        - number of bytes to read
 *                oldSign       - signature of the sub-partition
 *                flags         - EDC or not
 *                signOffset    - signature offset 0 or 8
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWReadProtect     - HW read protection was triggerd
 *-------------------------------------------------------------------*/

#define bdkReadInit(ioreq) bdCall(FL_BINARY_READ_INIT,ioreq)

/*-------------------------------------------------------------------
 * bdkReadBlock - Read to 'buffer' from the DiskOnChip BDK Image area.
 *
 * Note: Before the first use of this function 'bdkCopyBootAreaInit'
 *       must be called
 *
 * Parameters:
 *             'irHandle'      - Drive number (0, 1, ...)
 *                    bits 7-4 - Partition # (zero based)           
 *                    bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                length        - number of bytes to read
 *                bdkBuffer     - buffer to read into
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWReadProtect     - HW read protection was triggerd
 *-------------------------------------------------------------------*/

#define bdkReadBlock(ioreq) bdCall(FL_BINARY_READ_BLOCK,ioreq)

/*-------------------------------------------------------------------
 * bdkWriteInit - Init update operations on the DiskOnChip starting
 *       at 'startUnit', with a size of 'areaLen' bytes and 'signature'.
 *
 * Note: Blocks in the DiskOnChip are marked with a 4-character signature
 *       followed by a 4-digit hexadecimal number.
 *
 * Parameters:
 *             'irHandle'       - Drive number (0, 1, ...)
 *                     bits 7-4 - Partition # (zero based)           
 *                     bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                startingBlock - unit number of the sub-partition to start writting to
 *                length        - number of bytes to write
 *                oldSign       - signature of the sub-partition
 *                flags         - EDC \ BDK_COMPLETE_IMAGE_UPDATE
 *                signOffset    - signature offset 0 or 8
 *
 * Return:     flOK              - success
 *             flGeneralFailure  - DiskOnChip ASIC was not found
 *             flUnknownMedia    - fail in Flash chips recognition
 *             flNoSpaceInVolume - 'areaLen' is bigger than BootImage length
 *-------------------------------------------------------------------*/

#define bdkWriteInit(ioreq) bdCall(FL_BINARY_WRITE_INIT,ioreq)

/*-------------------------------------------------------------------
 * bdkWriteBlock - Write 'buffer' to the DiskOnChip BDK Image area.
 *
 * Note: Before the first use of this function 'bdkUpdateBootAreaInit'
 *       must be called
 *
 * Parameters:
 *             'irHandle'       - Drive number (0, 1, ...)
 *                     bits 7-4 - Partition # (zero based)           
 *                     bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                length        - number of bytes to write
 *                bdkBuffer     - buffer to write from
 *                flags         - ERASE_BEFORE_WRITE
 *
 * Return:     flOK              - success
 *             flBadLength       - buffer length > Erasable Block Size
 *             flWriteFault      - fail in buffer writing
 *             flNoSpaceInVolume - end of media was prematurely reached
 *-------------------------------------------------------------------*/

#define bdkWriteBlock(ioreq) bdCall(FL_BINARY_WRITE_BLOCK,ioreq)

/*-------------------------------------------------------------------
 * bdkErase - erase given number of blockdsin the BDK area.
 *
 *  Erase given number of blockds in the binary sub partition.
 *
 * Parameters: ioreq
 *             'irHandle'       - Drive number (0, 1, ...)
 *                     bits 7-4 - Partition # (zero based)           
 *                     bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                startingBlock - unit number of the sub-partition to start erasing from
 *                length        - number of blocks to erase
 *                oldSign       - signature of the sub-partition
 *                signOffset    - signature offset 0 or 8
 *
 * Return:     flOK              - success
 *             flBadLength       - buffer length > Erasable Block Size
 *             flWriteFault      - fail in buffer writing
 *             flNoSpaceInVolume - end of media was prematurely reached
 *-------------------------------------------------------------------*/

#define bdkErase(ioreq) bdCall(FL_BINARY_ERASE,ioreq)

/*-------------------------------------------------------------------
 * bdkCreate - create new BDK partition .
 *
 *  Init create operations on the DiskOnChip starting at 'startUnit', with
 *  a # of 'units' and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-character signature
 *         followed by a 4-digit hexadecimal number.
 *
 * Parameters: ioreq
 *             'irHandle'       - Drive number (0, 1, ...)
 *                     bits 7-4 - Partition # (zero based)           
 *                     bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                length        - number of blocks to create
 *                oldSign       - signature of the sub-partition
 *                newSign       - the replacing signature
 *                signOffset    - signature offset 0 or 8
 *
 * Return:     flOK              - success
 *             flBadLength       - buffer length > Erasable Block Size
 *             flWriteFault      - fail in buffer writing
 *             flNoSpaceInVolume - end of media was prematurely reached
 *-------------------------------------------------------------------*/

#define bdkCreate(ioreq) bdCall(FL_BINARY_CREATE,ioreq)

/*----------------------------------------------------------------------*/
/*                    b d k P a r t i t i o n I n f o                   */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : volume number                               */
/*        irData          : pointer to structure that hold socket       */
/*                          parameters                                  */
/*        irLength        : Physical size of the binary volume          */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus         : 0 on success, otherwise failed.            */
/*----------------------------------------------------------------------*/

#define bdkPartitionInfo(ioreq) bdCall(FL_BINARY_PARTITION_INFO,ioreq)

#endif /* BDK_ACCESS */
#ifdef HW_OTP
/*----------------------------------------------------------------------*/
/*                         f l O T P S i z e                            */
/*                                                                      */
/* Get the OTP size and stated                                          */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irLength         : The size of the used OTP area in bytes           */
/*  irCount          : The size of the OTP ara in bytes                 */
/*  irFlags          : LOCKED_OTP for a locked area otherwise unlocked  */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flOTPSize(ioreq) bdCall(FL_OTP_SIZE,ioreq)

/* LOCKED_OTP 1  defined in flflash.h */

/*----------------------------------------------------------------------*/
/*                         f l O T P R e a d                            */
/*                                                                      */
/* Read from the OTP area                                               */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irData           : pointer to user buffer to read into              */
/*  irLength         : number of bytes to read                          */
/*  irCount          : offset to read from (starting at the begining of */
/*                     the OTP area                                     */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus   : 0 on success, otherwise failed                   */
/*----------------------------------------------------------------------*/

#define flOTPRead(ioreq) bdCall(FL_OTP_READ,ioreq)

/*----------------------------------------------------------------------*/
/*                 f l O T P W r i t e A n d L o c k                    */
/*                                                                      */
/* Write to the OTP area while locking it at the end.                   */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irData           : pointer to user buffer to write from             */
/*  irLength         : number of bytes to write                         */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus   : 0 on success, otherwise failed                   */
/*----------------------------------------------------------------------*/

#define flOTPWriteAndLock(ioreq) bdCall(FL_OTP_WRITE,ioreq)

/*----------------------------------------------------------------------*/
/*                     f l G e t U n i q u e I D                        */
/*                                                                      */
/* Returns the 16 bytes device unique ID                                */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irData           : pointer to a 16 bytes buffer to read into the    */
/*                     unique ID data                                   */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irData          : 16 bytes unique ID buffer                   */
/*----------------------------------------------------------------------*/

#define flGetUniqueID(ioreq) bdCall(FL_UNIQUE_ID,ioreq)

/*----------------------------------------------------------------------*/
/*                f l G e t C u s t o m e r I D                         */
/*                                                                      */
/* Returns the 4 bytes customer ID                                      */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irData           : pointer to a 4 bytes buffer to read into the     */
/*                     customer ID                                      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irData          : 4 bytes unique ID buffer                    */
/*----------------------------------------------------------------------*/

#define flGetCustomerID(ioreq) bdCall(FL_CUSTOMER_ID,ioreq)
#endif /* HW_OTP */

#ifdef FL_LOW_LEVEL
/*----------------------------------------------------------------------*/
/*             f l D e e p P o w e r D o w n M o d e                    */
/*                                                                      */
/* Forces the device into and out of the deep power down mode           */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irFlags          : DEEP_POWER_DOWN forces the low power consumption */
/*                     mode. otherwise turning to the regular mode      */
/*                                                                      */
/* Returns: None                                                        */
/*----------------------------------------------------------------------*/

#define flDeepPowerDownMode(ioreq) bdCall(FL_DEEP_POWER_DOWN_MODE,ioreq)

/* DEEP_POWER_DOWN 1 defined in flflash.h */

#endif /* FL_LOW_LEVEL */

/*----------------------------------------------------------------------*/
/*             f l I n q u i r e C a p a b i l i t i e s                */
/*                                                                      */
/* Get the specific device S/W and H/W capabilities                     */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*      irLength        : One of the capabilities below to examine      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irLength        : Either CAPABILITY_NOT_SUPPORTED or            */
/*                        CAPABILITY_SUPPORTED.                         */
/*----------------------------------------------------------------------*/

#define flInquireCapabilities(ioreq) bdCall(FL_INQUIRE_CAPABILITIES,ioreq)

/* capabilities flags */
typedef enum{
   CAPABILITY_NOT_SUPPORTED           = 0,
   CAPABILITY_SUPPORTED               = 1,
   SUPPORT_UNERASABLE_BBT             = 2,
   SUPPORT_MULTIPLE_BDTL_PARTITIONS   = 3,
   SUPPORT_MULTIPLE_BINARY_PARTITIONS = 4,
   SUPPORT_HW_PROTECTION              = 5,
   SUPPORT_HW_LOCK_KEY                = 6,
   SUPPORT_CUSTOMER_ID                = 7,
   SUPPORT_UNIQUE_ID                  = 8,
   SUPPORT_DEEP_POWER_DOWN_MODE       = 9,
   SUPPORT_OTP_AREA                   = 10,
   SUPPORT_WRITE_IPL_ROUTINE          = 11
}FLCapability;

/*----------------------------------------------------------------------*/
/*                   f l P l a c e E x b B y B u f f e r                */
/*                                                                      */
/* Place M-systems firmware file on the media.                          */
/* This routine analizes the exb file calclats the media space needed   */
/* for it taking only the device specific code.                         */
/* In addition the routine customizes the file and places it on the     */
/* media.                                                               */
/*                                                                      */
/* Note : The media must be already formated with enough binary area    */
/* already marked with the SPL signature. This routine is best used     */
/* with the format routine where the format routine is givven the first */
/* 512 bytes while the rest of the file is given with this routine      */
/*                                                                      */
/* Parameters:                                                          */
/*      irHandle      : Socket number (0,1,..)                          */
/*                      4 LSB - Socket number                           */
/*      irData        : Buffer containing the entire/part of EXB file   */
/*      irLength      : Size of the current buffer                      */
/*      irWindowBase  : Optional window base address to be loaded to    */
/*      irFlags       : One of the following exb flags                  */
/*                   : INSTALL_FIRST - Install device as drive C:       */
/*                     FLOPPY        - Install device as drive A:       */
/*                     QUIET          - Do not show TFFS titles         */
/*                     INT15_DISABLE - Do not hook int 15               */
/*                     SIS5598       - Support for SIS5598 platforms    */
/*                     NO_PNP_HEADER - Do not place the PNP bios header */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flPlaceExbByBuffer(ioreq) bdCall(FL_PLACE_EXB,ioreq)

/*----------------------------------------------------------------------*/
/*                   f l W r i t e I P L                                */
/*                                                                      */
/* Place a user buffer to both copies of the IPL area                   */
/*                                                                      */
/* Note : This routine is applicable only to docPlus famaly devices     */
/*        Doc2000 family devices will return flFeatureNotSupported      */
/*                                                                      */
/* Parameters:                                                          */
/*      irHandle      : Socket number (0,1,..)                          */
/*                      4 LSB - Socket number                           */
/*      irData        : Pointer to user buffer                          */
/*      irLength      : Size of the buffer                              */
/*      irFlags       : See flags bellow                                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flWriteIPL(ioreq) bdCall(FL_WRITE_IPL,ioreq)

/*
 * defined in flflash.h
 *
 * FL_IPL_MODE_NORMAL 0 - Written as usual
 * FL_IPL_DOWNLOAD    1 - Download new IPL when done
 * FL_IPL_MODE_SA     2 - Written with Strong Arm mode enabled
 * FL_IPL_MODE_XSCALE 4 - Written with X-Scale mode enabled
 */

/*----------------------------------------------------------------------*/
/*                           r e a d I P L                              */
/*                                                                      */
/* Read IPL to user buffer.                                             */
/*                                                                      */
/* Note : Read length must be a multiplication of 512 bytes             */
/* Note : Causes DiskOnChip Millennium Plus to download (i,e protection */
/*        key will be removed from all partitions.                      */
/*                                                                      */
/* Parameters:                                                          */
/*      irHandle      : Socket number (0,1,..)                          */
/*                      4 LSB - Socket number                           */
/*      irData        : Pointer to user buffer                          */
/*      irLength      : Size of the buffer                              */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flReadIPL(ioreq) bdCall(FL_READ_IPL,ioreq)

#endif /* FL_LOW_LEVEL */

/*----------------------------------------------------------------------*/
/*                 f l U p d a t e S o c k e t P a r a m s              */
/*                                                                      */
/* Pass socket parameters to the socket interface layer.                */
/* This function should be called after the socket parameters (like     */
/* size and base) are known. If these parameters are known at           */
/* registration time then there is no need to use this function, and    */
/* the parameters can be passed to the registration routine.            */
/* The structure passed in irData is specific for each socket interface.*/
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : volume number                               */
/*        irData          : pointer to structure that hold socket       */
/*                          parameters                                  */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus         : 0 on success, otherwise failed.            */
/*----------------------------------------------------------------------*/

#define flUpdateSocketParams(ioreq)        bdCall(FL_UPDATE_SOCKET_PARAMS,ioreq)

#ifdef HW_PROTECTION
/*----------------------------------------------------------------------*/
/*              f l I d e n t i f y P r o t e c t i o n                 */
/*              b d k I d e n t i f y P r o t e c t i o n               */
/*                                                                      */
/* Returns the specified partitions protection attributes               */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irFlags    CHANGEABLE_PROTECTION - changeable protection type  */
/*                   PROTECTABLE     - partition can recieve protection */
/*                   READ_PROTECTED  - partition is read protected      */
/*                   WRITE_PROTECTED - partition is write protected     */
/*                   LOCK_ENABLED    - HW lock signal is enabled        */
/*                   LOCK_ASSERTED   - HW lock signal is asserted       */
/*                   KEY_INSERTED    - key is inserted (not currently   */
/*                                     protected.                       */
/*----------------------------------------------------------------------*/

#define flIdentifyProtection(ioreq) bdCall(FL_PROTECTION_GET_TYPE,ioreq)
#define bdkIdentifyProtection(ioreq) bdCall(FL_BINARY_PROTECTION_GET_TYPE,ioreq)

/* Protection partition flags (see flbase.h)*/

/*----------------------------------------------------------------------*/
/*              f l I n s e r t P r o t e c t i o n K e y               */
/*              b d k I n s e r t P r o t e c t i o n K e y             */
/*                                                                      */
/* Insert the protection key in order to remove the protection of the   */
/* partititon specified by the drive handle                             */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*  irData           : pointer to an 8 bytes key array                  */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flInsertProtectionKey(ioreq) bdCall(FL_PROTECTION_INSERT_KEY,ioreq)
#define bdkInsertProtectionKey(ioreq) bdCall(FL_BINARY_PROTECTION_INSERT_KEY,ioreq)

/*----------------------------------------------------------------------*/
/*              f l R e m o v e P r o t e c t i o n K e y               */
/*              b d k R e m o v e P r o t e c t i o n K e y             */
/*                                                                      */
/* Remove the protection key making the partition protected again       */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flRemoveProtectionKey(ioreq) bdCall(FL_PROTECTION_REMOVE_KEY,ioreq)
#define bdkRemoveProtectionKey(ioreq) bdCall(FL_BINARY_PROTECTION_REMOVE_KEY,ioreq)

/*----------------------------------------------------------------------*/
/*         f l H a r d w a r e P r o t e c t i o n L o c k              */
/*         b d k H a r d w a r e P r o t e c t i o n L o c k            */
/*                                                                      */
/* Enabled or disabled the affect of the hardware LOCK signal           */
/* The hardware lock signal disables the removal of protection through  */
/* the key therfore the partition will remain protected until the       */
/* hardware LOCK signal will be removed                                 */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irFlags    : LOCK_ENABLED locks the partition otherwise       */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flHardwareProtectionLock(ioreq) bdCall(FL_PROTECTION_SET_LOCK,ioreq)
#define bdkHardwareProtectionLock(ioreq) bdCall(FL_BINARY_PROTECTION_CHANGE_LOCK,ioreq)

/*----------------------------------------------------------------------*/
/*          f l C h a n g e P r o t e c t i o n K e y                   */
/*          b d k C h a n g e P r o t e c t i o n K e y                 */
/*                                                                      */
/* Changes the current protection key with a new one.                   */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*  irData           : Pointer to the new 8 bytes key array             */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flChangeProtectionKey(ioreq) bdCall(FL_PROTECTION_CHANGE_KEY,ioreq)
#define bdkChangeProtectionKey(ioreq) bdCall(FL_BINARY_PROTECTION_CHANGE_KEY,ioreq)

/*----------------------------------------------------------------------*/
/*              f l C h a n g e P r o t e c t i o n T y p e             */
/*              b d k C h a n g e P r o t e c t i o n T y p e           */
/*                                                                      */
/* Changes the protection attributes of the partitions.                 */
/* In order for a partition to change its protection type (without      */
/* reformating the media) it must have the CHANGEABLE_PRTOECTION        */
/* attribute.                                                           */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flChangeProtectionType(ioreq) bdCall(FL_PROTECTION_CHANGE_TYPE,ioreq)
#define bdkChangeProtectionType(ioreq) bdCall(FL_BINARY_PROTECTION_SET_TYPE,ioreq)

#endif /* HW_PROTECTION */
#ifdef EXIT

/*----------------------------------------------------------------------*/
/*                            f l E x i t                               */
/*                                                                      */
/* If the application ever exits, flExit should be called before exit.  */
/* flExit flushes all buffers, closes all open files, powers down the   */
/* sockets and removes the interval timer.                              */
/*                                                                      */
/* Parameters:                                                          */
/*        None                                                          */
/*                                                                      */
/* Returns:                                                             */
/*        Nothing                                                       */
/*----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
void NAMING_CONVENTION flExit(void);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* EXIT */

#ifdef ENVIRONMENT_VARS
typedef enum {        /* Variable type code for flSetEnv routin */
      FL_ENV_VARS_PER_SYSTEM          = 0,
      FL_IS_RAM_CHECK_ENABLED         = 1,
      FL_TL_CACHE_ENABLED             = 2,
      FL_DOC_8BIT_ACCESS              = 3,
      FL_MULTI_DOC_ENABLED            = 4,      
      FL_SET_MAX_CHAIN                = 5,
      FL_MARK_DELETE_ON_FLASH         = 6,
      FL_MTL_POLICY                   = 7,
      FL_SECTORS_VERIFIED_PER_FOLDING = 8,
      FL_SUSPEND_MODE                 = 9,

      FL_ENV_VARS_PER_SOCKET          = 100,
      FL_VERIFY_WRITE_OTHER           = 101,
      FL_MTD_BUS_ACCESS_TYPE          = 102,

      FL_ENV_VARS_PER_VOLUME          = 200,
      FL_SET_POLICY                   = 201,
      FL_VERIFY_WRITE_BDTL            = 202,
      FL_VERIFY_WRITE_BINARY          = 203
      
} FLEnvVars;

/*----------------------------------------------------------------------*/
/*                   f l S e t E n v V o l u m e                        */
/*                                                                      */
/* Change one of TrueFFS environment variables for a specific partition */
/*                                                                      */
/* Note : This routine is used by all other flSetEnv routines.          */
/*        In order to effect variables that are common to several       */
/*        sockets or volumes use INVALID_VOLUME_NUMBER                  */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      socket          : Associated socket                             */
/*      volume          : Associated volume (partition)                 */
/*      value           : varaible value                                */
/*                                                                      */
/* Note: Variables common to al sockets must be addressed using socket  */
/*       0 and volume 0.                                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flSetEnvVolume(FLEnvVars variableType ,
                  byte socket,byte volume ,
                  dword value, dword FAR2 *prevValue);
#ifdef __cplusplus
}
#endif /* __cplusplus */

/*----------------------------------------------------------------------*/
/*                       f l S e t E n v S o c k e t                    */
/*                                                                      */
/* Change one of TrueFFS environment variables for a specific sockets.  */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      socket          : socket number                                 */
/*      value           : varaible value                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*                        if there are more then 1 partition in that    */
/*                        socket , the first partition value is returned*/
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flSetEnvSocket(FLEnvVars variableType , byte socket ,
                        dword value, dword FAR2 *prevValue);
#ifdef __cplusplus
}
#endif /* __cplusplus */

/*----------------------------------------------------------------------*/
/*                       f l S e t E n v All                            */
/*                                                                      */
/* Change one of TrueFFS environment variables for all systems, sockets */
/* and partitions.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      value           : varaible value                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flSetEnvAll(FLEnvVars variableType , dword value, dword FAR2 *prevValue);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* ENVIRONMENT_VARS */

/*----------------------------------------------------------------------*/
/*                   f l B u i l d G e o m e t r y                      */
/*                                                                      */
/* Get C/H/S information of the disk according to number of sectors.    */
/*                                                                      */
/* Parameters:                                                          */
/*  capacity    : Number of Sectors in Volume                           */
/*  cylinders   : Pointer to Number of Cylinders                        */
/*  heads       : Pointer to Number of Heads                            */
/*  sectors     : Pointer to Number of Sectors per Track                */
/*  oldFormat   : True for one sector per culoster                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
void NAMING_CONVENTION flBuildGeometry(dword capacity, dword FAR2 *cylinders,
             dword FAR2 *heads,dword FAR2 *sectors, FLBoolean oldFormat);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef FL_NO_USE_FUNC

/*----------------------------------------------------------------------*/
/*                  f l S e t D o c B u s R o u t i n e                 */
/*                                                                      */
/* Set user defined memory acces routines for DiskOnChip.               */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      : Socket number to install routine for.             */
/*      structPtr   : Pointer to function structure.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flSetDocBusRoutine(byte socket, FLAccessStruct FAR1 * structPtr);
#ifdef __cplusplus
}
#endif /* __cplusplus */

/*----------------------------------------------------------------------*/
/*                  f l G e t D o c B u s R o u t i n e                 */
/*                                                                      */
/* Get currently installed memory access routines for DiskOnChip.       */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      : Socket number to install routine for.             */
/*      structPtr   : Pointer to function structure.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flGetDocBusRoutine(byte socket, FLAccessStruct FAR1 * structPtr);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* FL_NO_USE_FUNC */
/*----------------------------------------------------------------------*/
/*                         b d C a l l                                  */
/*                                                                      */
/* Common entry-point to all file-system functions. Macros are          */
/* to call individual function, which are separately described below.   */
/*                                                                      */
/* Parameters:                                                          */
/*      function        : file-system function code (listed below)      */
/*      ioreq           : IOreq structure                               */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION bdCall(FLFunctionNo functionNo, IOreq FAR2 *ioreq);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifdef PARSE_PATH

/*----------------------------------------------------------------------*/
/*                      f l P a r s e P a t h                           */
/*                                                                      */
/* Converts a DOS-like path string to a simple-path array.              */
/*                                                                      */
/* Note: Array length received in irPath must be greater than the       */
/* number of path components in the path to convert.                    */
/*                                                                      */
/* Parameters:                                                          */
/*        irData          : address of path string to convert           */
/*        irPath          : address of array to receive parsed-path.    */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

extern FLStatus NAMING_CONVENTION flParsePath(IOreq FAR2 *ioreq);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* PARSE_PATH */
#endif /* BLOCKDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\diskonc.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DISKONC.C_V  $
 *
 *    Rev 1.33   Apr 15 2002 07:35:04   oris
 * Changed usage and logic of checkToggle to be more intuitive.
 * Added support for new access layer (docsys). MTD now initializes the
 * access layer accessing the DiskOnChip registers.
 * Bug fix - doc2write did not report write faults in case runtime verify
 *                write was not required.
 * Bug fix - bad compilation ifdef in readBBT routine might cause a write
 *                 operation while FL_READ_ONLY is defined or to compile the
 *                 reconstruct BBT code even if MTD_RECONSTRUCT_BBT is
 *                 not defined.
 *
 *    Rev 1.32   Jan 29 2002 20:07:30   oris
 * Changed sanity check of write IPL modes.
 *
 *    Rev 1.31   Jan 28 2002 21:23:58   oris
 * Removed the use of back-slashes in macro definitions.
 * Added FL_IPL_DOWNLOAD flag to writeIPL routine in order to control whether the IPL will be reloaded after the update.
 * Bug fix - writeIPL routine did not support buffers smaller then 1024 bytes.
 * Bug fix - writeIPL routine did not write the second copy of the IPL correctly (for both 512 bytes).
 * Changed docwrite and docset calls to separate DiskOnChip base window pointer and IO registers offset (for address shifting).
 * Replaced FLFlash argument with DiskOnChip memory base pointer in calls to docwrite , docset and docread.
 * Removed win_io initialization (one of FLFlash record fields).
 * Improved check for flSuspend.
 *
 *    Rev 1.30   Jan 23 2002 23:31:04   oris
 * Added writeIPL routine (copied from blockdev.c).
 * Made writeIPL and download routines available even when MTD_STANDALONE  is defined.
 * Bug fix - checkErase routine was unreasonably slow.
 * Changed DFORMAT_PRINT syntax.
 *
 *    Rev 1.29   Jan 21 2002 20:43:50   oris
 * Compilation errors for MTD_STANDALONE with BDK_VERIFY_WRITE.
 * Bug fix - PARTIAL_EDC flag to doc2read was negated prior to readOneSector.
 *
 *    Rev 1.28   Jan 20 2002 20:57:00   oris
 * physicalToPointer was called with wrong size argument.
 *
 *    Rev 1.27   Jan 20 2002 20:28:06   oris
 * Changed doc2000FreeWindow return type to remove warnings.
 *
 *    Rev 1.26   Jan 17 2002 22:57:56   oris
 * Replaced vol with *flash.
 * Removed flPreInit memory access routines.
 * Added new memory access routine implementation.
 * Compilation problems fixed with VERIFY_ERASE
 * Added support for flSuspendMode environment variable.
 *
 *    Rev 1.25   Nov 21 2001 11:39:10   oris
 * Changed FL_WITH_VERIFY_WRITE and FL_WITHOUT_VERIFY_WRITE to FL_ON and  FL_OFF.
 *
 *    Rev 1.24   Nov 20 2001 20:24:58   oris
 * Removed warnings.
 *
 *    Rev 1.23   Nov 16 2001 00:19:38   oris
 * Compilation problem for FL_READ_ONLY.
 *
 *    Rev 1.22   Nov 08 2001 10:44:30   oris
 * Added run-time control over verify write mode.
 * Added support for more up to 64K units - erase / readbbt
 * Restricted BBT block search to BBT_MAX_DISTANCE and not the entire floor.
 * Bug fix - Replacing a DiskOnChip Millennium with DiskOnChip 2000 failed identifying DiskOnChip2000 (gang).
 *
 *    Rev 1.21   Sep 24 2001 18:23:08   oris
 * Removed warnings.
 *
 *    Rev 1.20   Sep 15 2001 23:44:42   oris
 * Placed YIELD_CPU definition under ifdef to prevent redeclaration.
 * Changed doc2erase to support up to 64K erase blocks.
 * Added reconstruct flag to readBBT routine - stating whether to reconstruct BBT if it is not available.
 * Added support for block multiplication in readBBT - several erase blocks in a single unit.
 * Added support for 128MB flashes.
 *
 *    Rev 1.19   Jul 29 2001 16:14:06   oris
 * Support  for number of units per floor not power of 2
 *
 *    Rev 1.18   Jul 16 2001 22:47:58   oris
 * Compilation error when using the FL_READ_ONLY compilation flag.
 *
 *    Rev 1.17   Jul 15 2001 20:44:48   oris
 * Removed warnings.
 * Bug fix - virgin card dformat print was repeated for DiskOnChip with several floors.
 *
 *    Rev 1.16   Jul 13 2001 00:59:42   oris
 * Added docsys.h include.
 * Improved VERIFY_WRITE support - added socket readBack buffer.
 * Added PARTIAL_EDC read flag to the read routine.
 * Revised checkErase routine to include extra area.
 * Revised readBBT routine not to use MTD buffer.
 * Added dformat debug print massages.
 * Changed firstUsable block to 0 for DOC2000 tsop.
 *
 *    Rev 1.15   Jun 17 2001 08:17:02   oris
 * Added brackets to remove warnnings.
 * Changed NO_READ_BBT_CODE  to MTD_NO_READ_BBT_CODE.
 *
 *    Rev 1.14   May 16 2001 21:16:32   oris
 * Removed warnings.
 * Changed code variable name to flCode (avoid name clashes).
 *
 *    Rev 1.13   May 09 2001 00:31:28   oris
 * Changed the DOC2000_TSOP_SUPPORT and READ_BBT_CODE compilation flags to NO_READ_BBT_CODE.
 *
 *    Rev 1.12   May 07 2001 10:00:04   oris
 * Compilation problems under MTD_STANDLAONE compilation flag.
 *
 *    Rev 1.11   May 06 2001 22:41:22   oris
 * Added the READ_BBT_CODE to allow reading the BBT even in the MTD_STANDALONE mode.
 * Removed warnings.
 *
 *    Rev 1.10   May 02 2001 06:44:38   oris
 * Bug fix - readBBT routine.
 * Removed the lastUsableBlock variable.
 *
 *    Rev 1.9   Apr 30 2001 17:58:18   oris
 * Added EDC check when reading the BBT.
 *
 *    Rev 1.8   Apr 24 2001 17:06:22   oris
 * Removed warrnings.
 * Added lastUsableBlock initialization field in the FLFlash record.
 *
 *    Rev 1.7   Apr 16 2001 13:04:20   oris
 * Removed warrnings.
 *
 *    Rev 1.6   Apr 12 2001 06:49:06   oris
 * Added forceDownload routine
 * Changed checkWinForDoc routine to be under ifndef MTD_STANDALONE.
 *
 *    Rev 1.5   Apr 10 2001 16:39:16   oris
 * Added multiple floor support for readbbt routine.
 * Added call for docSocketInit which initializes the socket routines.
 * Added validity check after flMap call in order to support pccard premoutn routine.
 *
 *    Rev 1.4   Apr 09 2001 14:58:40   oris
 * Removed debug buffer from readBBT routine.
 * Bug fix in doc2000Identify if ASIC id was not mdoc 8 is was assumed to be doc2000.
 * Added if_cfg field initialization in doc2000Identify.
 *
 *    Rev 1.3   Apr 01 2001 07:38:58   oris
 * Moved include diskonc.h from docsys.h.
 * Removed waitForReadyWithYieldCPU for MTD_STANDALONE configuration.
 * Removed NO_PPP compilation flag support.
 * Left alligned all # directives.
 * Moved pageSize,noOfFloors filed from the MTDs internal stucture to FLFlash record.
 * Changed  writeOneSector,doc2Write,readOneSector,doc2Read prototype.
 * Added readbbt routine for alon.
 * Removed pageAndTailSize from mtdVars record.
 *
 *    Rev 1.2   Mar 01 2001 14:15:56   vadimk
 * Add proper MDOC and DOC2300 support
 *
 *    Rev 1.1   Feb 07 2001 18:28:38   oris
 * Bug fix - restored antialise mechanizm to flDocWindowBaseAddress
 * Added seperetaed floors compilation flag
 * Changed mdoc \ alon distingishing algorithm
 * Removed checkWinForDoc routine under the mtd_standalone comilation flag
 * removed MAX_FLASH_DEVICES_MDOC define since alone DiskOnChips can support 16 chips just like doc2000
 *
 *    Rev 1.0   Feb 02 2001 15:35:38   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*              FAT-FTL Lite Software Development Kit                   */
/*              Copyright (C) M-Systems Ltd. 1995-2001                  */
/*                                                                      */
/************************************************************************/

#include "reedsol.h"
#include "diskonc.h"

extern NFDC21Vars docMtdVars[SOCKETS];

/* When the MTD is used as a standalone package some of the routine     */
/* are replaced with the following macroes                              */

#ifdef MTD_STANDALONE

#define flReadBackBufferOf(a) &(globalReadBack[a][0])

#define flSocketNoOf(volume) 0 /* currently we support only a single device */

#define flMap(socket,address) addToFarPointer(socket->base,address & (socket->size - 1));

#endif /* MTD_STANDALONE */

/* Yield CPU time in msecs */
#ifndef YIELD_CPU
#define YIELD_CPU 10
#endif /* YIELD_CPU */

/* maximum waiting time in msecs */
#define MAX_WAIT  30

#ifndef NO_EDC_MODE

      /*.*/
      /*            EDC control     */
      /*.*/

/*----------------------------------------------------------------------*/
/*                        e c c O N r e a d                             */
/*                                                                      */
/* Enable ECC in read mode and reset it.                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void eccONread (FLFlash * flash)
{
  flWrite8bitReg(flash,NECCconfig,ECC_RESET);
  flWrite8bitReg(flash,NECCconfig,ECC_EN);
}
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                        e c c O n w r i t e                           */
/*                                                                      */
/* Enable ECC in write mode and reset it.                               */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*                                                                      */
/*----------------------------------------------------------------------*/
static void eccONwrite (FLFlash * flash)
{
  flWrite8bitReg(flash,NECCconfig,ECC_RESET);
  flWrite8bitReg(flash,NECCconfig,(ECC_RW | ECC_EN));
}
#endif /* FL_READ_ONLY */
#endif
/*----------------------------------------------------------------------*/
/*                        e c c O F F                                   */
/*                                                                      */
/* Disable ECC.                                                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void eccOFF (FLFlash * flash)
{
  flWrite8bitReg(flash,NECCconfig,ECC_RESERVED);
}

#ifndef NO_EDC_MODE
/*----------------------------------------------------------------------*/
/*                        e c c E r r o r                               */
/*                                                                      */
/* Check for EDC error.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*                                                                      */
/*----------------------------------------------------------------------*/
static FLBoolean  eccError (FLFlash * flash)
{
  register int i;
  volatile Reg8bitType junk = 0;
  Reg8bitType ret;

  if( NFDC21thisVars->flags & MDOC_ASIC ) {
    for(i=0;( i < 2 ); i++)
      junk += flRead8bitReg(flash,NECCconfig);
    ret = flRead8bitReg(flash,NECCconfig);
  }
  else {
    for(i=0;( i < 2 ); i++)
      junk += flRead8bitReg(flash,NECCstatus);
    ret = flRead8bitReg(flash,NECCstatus);
  }
  ret &= ECC_ERROR;
  return ((FLBoolean)ret);

}

#endif

      /*.*/
      /*   Miscellaneous routines   */
      /*.*/

/*----------------------------------------------------------------------*/
/*                        m a k e C o m m a n d                         */
/*                                                                      */
/* Set Page Pointer to Area A, B or C in page.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*      cmd     : receives command relevant to area                     */
/*      addr    : receives the address to the right area.               */
/*      modes   : mode of operation (EXTRA ...)                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void  makeCommand ( FLFlash * flash, PointerOp *cmd,
                           CardAddress *addr, int modes )
{
  dword offset;

#ifdef BIG_PAGE_ENABLED
  if ( !(flash->flags & BIG_PAGE) )
  {           /* 2 Mb components */
    if( modes & EXTRA )
    {
      offset = (*addr) & (SECTOR_SIZE - 1);
      *cmd = AREA_C;
      if( offset < EXTRA_LEN )         /* First half of extra area  */
    *addr += 0x100;                /* ... assigned to 2nd page  */
      else                             /* Second half of extra area */
    *addr -= EXTRA_LEN;            /* ... assigned to 1st page  */
    }
    else
      *cmd = AREA_A;
  }
  else
#endif /* BIG_PAGE_ENABLED */
  {                                           /* 4 Mb components */
    offset = (word)(*addr) & NFDC21thisVars->pageMask; /* offset within device Page */
    *addr -= offset;                             /* align at device Page */

    if(modes & EXTRA)
      offset += SECTOR_SIZE;

    if( offset < NFDC21thisVars->pageAreaSize )  /* starting in area A */
      *cmd = AREA_A;
    else if( offset < flash->pageSize ) /* starting in area B */
      *cmd = AREA_B;
    else                                   /* got into area C    */
      *cmd = AREA_C;

    offset &= (NFDC21thisVars->pageAreaSize - 1); /* offset within area of device Page */
    *addr += offset;
  }
}

/*----------------------------------------------------------------------*/
/*                        b u s y                                       */
/*                                                                      */
/* Check if the selected flash device is ready.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*                                                                      */
/* Returns:                                                             */
/*      Zero is ready.                                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
static FLBoolean busy (FLFlash * flash)
{
  register int i;
  Reg8bitType stat;
  volatile Reg8bitType junk = 0;
  Reg8bitType ret;
    /* before polling for BUSY status perform 4 read operations from
       CDSN_control_reg */

  for(i=0;( i < 4 ); i++ )
    junk += flRead8bitReg(flash,NNOPreg);

    /* read BUSY status */

  stat = flRead8bitReg(flash,Nsignals);

    /* after BUSY status is obtained perform 2 read operations from
       CDSN_control_reg */

  for(i=0;( i < 2 ); i++ )
    junk += flRead8bitReg(flash,NNOPreg);
  ret = (!(stat & (Reg8bitType)RB));
  return ((FLBoolean)ret);
}

/*----------------------------------------------------------------------*/
/*                        w a i t F o r R e a d y                       */
/*                                                                      */
/* Wait until flash device is ready or timeout.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/* Returns:                                                             */
/*      FALSE if timeout error, otherwise TRUE.                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLBoolean  waitForReady (FLFlash * flash)
{
  int i;
  for(i=0;( i < BUSY_DELAY ); i++)
  {
    if( busy(flash) )
    {
      continue;
    }

    return( TRUE );                     /* ready at last.. */
  }

  DEBUG_PRINT(("Debug: timeout error in NFDC 2148.\r\n"));
  return( FALSE );
}

#ifndef MTD_STANDALONE
#ifndef DO_NOT_YIELD_CPU
/*----------------------------------------------------------------------*/
/*              w a i t F o r R e a d y W i t h Y i e l d C P U         */
/*                                                                      */
/* Wait until flash device is ready or timeout.                         */
/* The function yields CPU while it waits till flash is ready           */
/*                                                                      */
/* Parameters:                                                          */
/*  flash   : Pointer identifying drive                                 */
/* Returns:                                                             */
/*  FALSE if timeout error, otherwise TRUE.                             */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLBoolean  waitForReadyWithYieldCPU (FLFlash * flash,
                                            int millisecToSleep)
{
   int i;

   for (i=0;  i < (millisecToSleep / YIELD_CPU); i++) {
    #ifndef NT5PORT
       flsleep(YIELD_CPU);
    #endif /*NT5PORT*/
       if( busy(flash) )
         continue;
       return( TRUE );                     /* ready at last.. */
   }

   return( FALSE );
}
#endif /* DO_NOT_YIELD_CPU */
#endif /* MTD_STANDALONE */
/*----------------------------------------------------------------------*/
/*                        w r i t e S i g n a l s                       */
/*                                                                      */
/* Write to CDSN_control_reg.                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      val     : Value to write to register                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void  writeSignals (FLFlash * flash, Reg8bitType val)
{
  register int i;
  volatile Reg8bitType junk = 0;

  flWrite8bitReg(flash,Nsignals,val);

  /* after writing to CDSN_control perform 2 reads from there */

  for(i = 0;( i < 2 ); i++ )
    junk += flRead8bitReg(flash,NNOPreg);
}

/*----------------------------------------------------------------------*/
/*                        s e l e c t C h i p                           */
/*                                                                      */
/* Write to deviceSelector register.                                    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      dev     : Chip to select.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void  selectChip (FLFlash * flash, Reg8bitType dev)
{
  flWrite8bitReg(flash,NdeviceSelector,dev);
}

/*----------------------------------------------------------------------*/
/*                        c h k A S I C m o d e                         */
/*                                                                      */
/* Check mode of ASIC and if RESET set to NORMAL.                       */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void chkASICmode (FLFlash * flash)
{
  if( flRead8bitReg(flash,NDOCstatus) == ASIC_CHECK_RESET ) {
    flWrite8bitReg(flash,NDOCcontrol,ASIC_NORMAL_MODE);
    flWrite8bitReg(flash,NDOCcontrol,ASIC_NORMAL_MODE);
#ifndef SEPARATED_CASCADED
    NFDC21thisVars->currentFloor = 0;
#endif /* SEPARATED_CASCADED */
  }
}

/*----------------------------------------------------------------------*/
/*                        s e t A S I C m o d e                         */
/*                                                                      */
/* Set mode of ASIC.                                                    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      mode    : mode to set.                                          */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setASICmode (FLFlash * flash, Reg8bitType mode)
{
  NDOC2window p = (NDOC2window)flMap(flash->socket, 0);
  if (p!=NULL)
  {
     flWrite8bitReg(flash,NDOCcontrol,mode);
     flWrite8bitReg(flash,NDOCcontrol,mode);
#ifdef SEPARATED_CASCADED
     flWrite8bitReg(flash,NASICselect,NFDC21thisVars->currentFloor);
#endif /* SEPARATED_CASCADED */
  }
}

/*----------------------------------------------------------------------*/
/*                        c h e c k T o g g l e                         */
/*                                                                      */
/* Check DiskOnChip toggle bit. Verify this is not simple RAM.          */
/*                                                                      */
/* Note : This routine assumes that the memory access routines have     */
/* already been initialized by the called routine.                      */
/*                                                                      */
/* Parameters:                                                          */
/*      FLFlash      : Pointer to flash structure.                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: TRUE if the bit toggles verifing that this is indeed  */
/*                a DiskOnChip device, otherwise FALSE.                 */
/*----------------------------------------------------------------------*/

static FLBoolean checkToggle(FLFlash * flash)
{
  volatile Reg8bitType toggle1;
  volatile Reg8bitType toggle2;

  if(flRead8bitReg(flash,NchipId) == CHIP_ID_MDOC ) {
    toggle1 = flRead8bitReg(flash,NECCconfig);
    toggle2 = toggle1 ^ flRead8bitReg(flash,NECCconfig);
  }
  else {
    toggle1 = flRead8bitReg(flash,NECCstatus);
    toggle2 = toggle1 ^ flRead8bitReg(flash,NECCstatus);
  }
  if( (toggle2 & TOGGLE) == 0 )
    return FALSE;
  return TRUE;
}

#ifndef MTD_STANDALONE

/*----------------------------------------------------------------------*/
/*                        c h e c k W i n F o r D O C                   */
/*                                                                      */
/* Check for a DiskOnChip on a specific socket and memory windows       */
/*                                                                      */
/* Parameters:                                                          */
/*      socketNo     : Number of socket to check.                       */
/*      memWinPtr    : Pointer to DiskOnChip memory window.             */
/*                                                                      */
/* Returns: TRUE if this is an MDOCP, otherwise FALSE.                  */
/*----------------------------------------------------------------------*/

FLBoolean checkWinForDOC(unsigned socketNo, NDOC2window memWinPtr)
{
  FLFlash * flash = flFlashOf(socketNo);

  /* Initialize socket memory access routine */
  flash->win = memWinPtr;

#ifndef FL_NO_USE_FUNC
  if(setBusTypeOfFlash(flash, flBusConfig[socketNo] |
                       FL_8BIT_DOC_ACCESS | FL_8BIT_FLASH_ACCESS))
    return FALSE;
#endif /* FL_NO_USE_FUNC */

  /* set ASIC to RESET MODE */
  flWrite8bitReg(flash,NDOCcontrol,ASIC_RESET_MODE);
  flWrite8bitReg(flash,NDOCcontrol,ASIC_RESET_MODE);

  flWrite8bitReg(flash,NDOCcontrol,ASIC_NORMAL_MODE);
  flWrite8bitReg(flash,NDOCcontrol,ASIC_NORMAL_MODE);

  if( (flRead8bitReg(flash,NchipId) != CHIP_ID_DOC ) &&
      (flRead8bitReg(flash,NchipId) != CHIP_ID_MDOC))
    return FALSE;

  return checkToggle(flash);
}

#endif /* MTD_STANDALONE */

#ifndef NO_IPL_CODE

/*----------------------------------------------------------------------*/
/*                       f o r c e D o w n l o a d                      */
/*                                                                      */
/* Force download of IPL code.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success                                  */
/*----------------------------------------------------------------------*/

static FLStatus forceDownLoad(FLFlash * flash)
{
   flWrite8bitReg(flash, NfoudaryTest, 0x36);
   flWrite8bitReg(flash, NfoudaryTest, 0x63);
   flDelayMsecs(1000);
   return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                        w r i t e I P L                               */
/*                                                                      */
/* Write new IPL.                                                       */
/*                                                                      */
/* Note : Can not start write operation from middle of IPL , unless     */
/*        previous operation started from offset 0.                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write - must use full 512 bytes.   */
/*      offset  : sector number to start from.                          */
/*      flags   : Modes to write IPL :                                  */
/*                FL_IPL_MODE_NORMAL - Normal mode (none Strong Arm).   */
/*                FL_IPL_DOWNLOAD    - Download new IPL when done       */
/*                FL_IPL_MODE_SA     - Strong Arm IPL mode              */
/*                FL_IPL_MODE_XSCALE - X-Scale IPL mode                 */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus writeIPL(FLFlash * flash, const void FAR1 * buffer,
                         word length,byte offset, unsigned flags)
{
   dword  curWrite;
   dword  addrOffset = (dword)offset << SECTOR_SIZE_BITS;

   if((flags & (FL_IPL_MODE_SA | FL_IPL_MODE_XSCALE)) != 0)
   {
      DFORMAT_PRINT(("ERROR - DiskOnChip does not support this IPL mode.\r\n"));
      return flFeatureNotSupported;
   }

   if ((flash->erase != NULL)||(flash->write != NULL))
   {
      if ((length + addrOffset > 1024) ||  /* required length to long    */
          (offset>1)                     ) /* only single sector or none */
      {
         DFORMAT_PRINT(("ERROR - IPL size or offset are too big for this DiskOnChip.\r\n"));
         return flBadLength;
      }
      if((length % SECTOR_SIZE) != 0)
      {
         DFORMAT_PRINT(("ERROR - IPL size must be a multiplication of 512 bytes.\r\n"));
         return flBadLength;
      }

      if(offset==0) /* Erase only if offset is 0 */
         checkStatus(flash->erase(flash,0,1));

      for (addrOffset = addrOffset << 1 ; length > 0 ;
           addrOffset += (SECTOR_SIZE<<1))
      {
         curWrite = TFFSMIN(length,SECTOR_SIZE);
         checkStatus(flash->write(flash,addrOffset,buffer,curWrite,PARTIAL_EDC));
         checkStatus(flash->write(flash,addrOffset+SECTOR_SIZE,buffer,curWrite,PARTIAL_EDC));
         buffer   = (byte FAR1 *)BYTE_ADD_FAR(buffer,SECTOR_SIZE);
         length  -= (word)curWrite;
      }
      if((flags & FL_IPL_DOWNLOAD) == 0)
        return flOK;

      if(flash->download != NULL)
         return flash->download(flash);
      DFORMAT_PRINT(("ERROR - IPL was not downloaded since MTD does not support the feature\r\n"));
   }
   DFORMAT_PRINT(("ERROR - IPL was not written since MTD is in read only mode\r\n"));
   return flFeatureNotSupported;
}

#endif /* FL_READ_ONLY */
#endif /* NO_IPL_CODE */


/*----------------------------------------------------------------------*/
/*                f l D o c W i n d o w B a s e A d d r e s s           */
/*                                                                      */
/* Return the host base address of the window.                          */
/* If the window base address is programmable, this routine selects     */
/* where the base address will be programmed to.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      socketNo        FLite socket No (0..SOCKETS-1)                  */
/*      lowAddress,                                                     */
/*      highAddress :   host memory range to search for DiskOnChip 2000 */
/*                      memory window                                   */
/*                                                                      */
/* Returns:                                                             */
/*      Host physical address of window divided by 4 KB                 */
/*      nextAddress :   The address of the next DiskOnChip.             */
/*----------------------------------------------------------------------*/
static unsigned flDocWindowBaseAddress(byte socketNo, dword lowAddress,
                                dword highAddress, dword *nextAddress)
{
#ifndef NT5PORT
  FLBoolean     stopSearch = FALSE;
  volatile byte deviceSearch;
  dword         winSize;
  FLFlash      *flash;


#ifdef SEPARATED_CASCADED
  /* This flag is used to seperate the cascaded devices into SEPARATED volumes  */
  /* Only the first floor responds therfore once it is found all the others are */
  /* reported without searching                                                 */

  static byte noOfFloors    = 0; /* floor counter of the cascaded device  */
  static socketOfFirstFloor = 0; /* Number of sockets already found       */
  static dword savedNextAddress; /* Next search address (skipping aliases */

  switch ( noOfFloors )
  {
     case 0 :                         /* First access to a device */
        socketOfFirstFloor = noOfSockets;
        break;

     case 1 :                  /* Last floor of a cascaded device */
        *nextAddress = savedNextAddress;

     default :                 /* One of a cascaded device floors */
        docMtdVars[noOfSockets].currentFloor = noOfSockets - socketOfFirstFloor;
        noOfFloors--;
        return((unsigned)(lowAddress >> 12));
  }
#endif /* SEPARATED_CASCADED */

  /* if memory range to search for DiskOnChip 2000 window is not specified */
  /* assume the standard x86 PC architecture where DiskOnChip 2000 appears */
  /* in a memory range reserved for BIOS expansions                        */
  if (lowAddress == 0x0L) {
    lowAddress  = START_ADR;
    highAddress = STOP_ADR;
  }

  flash = flFlashOf(socketNo);

#ifndef FL_NO_USE_FUNC
  /* Initialize socket memory access routine */
  if(setBusTypeOfFlash(flash, flBusConfig[socketNo] |
                       FL_8BIT_DOC_ACCESS | FL_8BIT_FLASH_ACCESS))
     return ( 0 );
#endif /* FL_NO_USE_FUNC */

  winSize = DOC_WIN;

  /* set all possible controllers to RESET MODE */

  for(*nextAddress = lowAddress ; *nextAddress <= highAddress ;
      *nextAddress += winSize)
  {
     flash->win = (NDOC2window )physicalToPointer(*nextAddress,winSize,socketNo);
     flWrite8bitReg(flash,NDOCcontrol,ASIC_RESET_MODE);
     flWrite8bitReg(flash,NDOCcontrol,ASIC_RESET_MODE);
  }

  /* set controller (ASIC) to NORMAL MODE and try and detect it */
  *nextAddress = lowAddress;       /* current address initialization */
  for( ; *nextAddress <= highAddress; *nextAddress += winSize)
  {
    flash->win = (NDOC2window)physicalToPointer(*nextAddress,winSize,socketNo);
    /* set controller (ASIC) to NORMAL MODE */
    flWrite8bitReg(flash,NDOCcontrol,ASIC_NORMAL_MODE);
    flWrite8bitReg(flash,NDOCcontrol,ASIC_NORMAL_MODE);

    if( (flRead8bitReg(flash,NchipId) != CHIP_ID_DOC &&
         flRead8bitReg(flash,NchipId) != CHIP_ID_MDOC))
    {
      if( stopSearch == TRUE )  /* DiskOnChip was found */
        break;
      else continue;
    }
    if( stopSearch == FALSE ) {
      /* detect card - identify bit toggles on consequitive reads */
      if(checkToggle(flash) == FALSE)
        continue;
      /* DiskOnChip found */
      if( flRead8bitReg(flash,NchipId)) {
          flWrite8bitReg(flash,NaliasResolution,ALIAS_RESOLUTION);
      }
      else {
        flWrite8bitReg(flash,NdeviceSelector,ALIAS_RESOLUTION);
      }
      stopSearch = TRUE;
      lowAddress = *nextAddress;   /* save DiskOnChip address */
    }
    else { /* DiskOnChip found, continue to skip aliases */
        if( (flRead8bitReg(flash,NchipId) != CHIP_ID_DOC) &&
          (flRead8bitReg(flash,NchipId) != CHIP_ID_MDOC) )
        break;
      /* detect card - identify bit toggles on consequitive reads */
      if(checkToggle(flash) == FALSE)
        break;
      /* check for Alias */
      deviceSearch = (byte)((flRead8bitReg(flash,NchipId) == CHIP_ID_MDOC) ?
                             flRead8bitReg(flash,NaliasResolution) :
                             flRead8bitReg(flash,NdeviceSelector));
      if( deviceSearch != ALIAS_RESOLUTION )
        break;
    }
  }
  if( stopSearch == FALSE )  /* DiskOnChip 2000 memory window not found */
    return( 0 );

#ifdef SEPARATED_CASCADED
    /* count the number of floors cascaded to this address */

    flash->win = (NDOC2window)physicalToPointer(lowAddress,winSize,socketNo);
    for ( noOfFloors=1; noOfFloors < MAX_FLASH_DEVICES_DOC ;noOfFloors++)
    {
       flWrite8bitReg(flash,NASICselect,noOfFloors);
       if(checkToggle(flash) == FALSE)
          break;
    }
    /* If there are more then 1 floor on this address save the next device address and report
       that the next device is actualy on the same address as the current */

    if ( noOfFloors > 1)
    {
       flWrite8bitReg(flash,NASICselect,0);
       savedNextAddress = *nextAddress;
       *nextAddress     = lowAddress;
    }
    noOfFloors--;
#endif /* SEPARATED_CASCADED */
  return((unsigned)(lowAddress >> 12));
#else  /*NT5PORT*/
        DEBUG_PRINT(("Tffsport mdocplus.c :flDocWindowBaseAddress(): Before returning baseAddress()\n"));
        return (unsigned)(((ULONG_PTR)pdriveInfo[socketNo].winBase)>> 12);
#endif /*NT5PORT*/

}
/*----------------------------------------------------------------------*/
/*                        s e t A d d r e s s                           */
/*                                                                      */
/* Latch address to selected flash device.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : address to set.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setAddress (FLFlash * flash, CardAddress address)
{
  address &= (flash->chipSize * flash->interleaving - 1);  /* address within flash device */

#ifdef BIG_PAGE_ENABLED
  if ( flash->flags & BIG_PAGE )
#endif /* BIG_PAGE_ENABLED */
  {
    /*
       bits  0..7     stays as are
       bit      8     is thrown away from address
       bits 31..9 ->  bits 30..8
    */
    address = ((address >> 9) << 8)  |  ((byte)address);
  }

  writeSignals (flash, FLASH_IO | ALE | CE);

#ifdef SLOW_IO_FLAG
  flWrite8bitReg(flash,NslowIO,(Reg8bitType)address);
  flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)address);
  flWrite8bitReg(flash,NslowIO,(Reg8bitType)(address >> 8));
  flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(address >> 8));
  flWrite8bitReg(flash,NslowIO,(Reg8bitType)(address >> 16));
  flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(address >> 16));
  if( flash->flags & BIG_ADDR ) {
    flWrite8bitReg(flash,NslowIO,(Reg8bitType)(address >> 24));
    flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(address >> 24));
  }
#else
  flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)address);
  flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(address >> 8));
  flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(address >> 16));
  if( flash->flags & BIG_ADDR )
    flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(address >> 24));
#endif
  if( NFDC21thisVars->flags & MDOC_ASIC )
    flWrite8bitReg(flash,NwritePipeTerm,(Reg8bitType)0);

  writeSignals (flash, ECC_IO | FLASH_IO | CE);
}

/*----------------------------------------------------------------------*/
/*                        c o m m a n d                                 */
/*                                                                      */
/* Latch command byte to selected flash device.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      code    : Command to set.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void command(FLFlash * flash, Reg8bitType flCode)
{
  writeSignals (flash, FLASH_IO | CLE | CE);

#ifdef SLOW_IO_FLAG
  flWrite8bitReg(flash,NslowIO,flCode);
#endif

  flWrite8bitReg(flash,NFDC21thisIO,flCode);
  if( NFDC21thisVars->flags & MDOC_ASIC )
    flWrite8bitReg(flash,NwritePipeTerm,flCode);
}

/*----------------------------------------------------------------------*/
/*                        s e l e c t F l o o r                         */
/*                                                                      */
/* Select floor (0 .. totalFloors-1).                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : Select floor for this address.                        */
/*                                                                      */
/*----------------------------------------------------------------------*/

#ifndef SEPARATED_CASCADED

static void selectFloor (FLFlash * flash, CardAddress *address)
{
  if( flash->noOfFloors > 1 )
  {
    byte floorToUse = (byte)((*address) / NFDC21thisVars->floorSize);

    NFDC21thisVars->currentFloor = floorToUse;
    flWrite8bitReg(flash,NASICselect,floorToUse);
    *address -= (floorToUse * NFDC21thisVars->floorSize);
  }
}

#endif /* SEPARATED_CASCADED */

/*----------------------------------------------------------------------*/
/*                        m a p W i n                                   */
/*                                                                      */
/* Map window to selected flash device.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : Map window to this address.                           */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void mapWin (FLFlash * flash, CardAddress *address)
{
  /* NOTE: normally both ways to obtain DOC 2000 window segment should
         return the same value. */
  NFDC21thisWin = (NDOC2window)flMap(flash->socket, 0);
#ifndef SEPARATED_CASCADED
  selectFloor (flash, address);
#else
  flWrite8bitReg(flash,NASICselect,NFDC21thisVars->currentFloor);
#endif /* SEPARATED_CASCADED */
  /* select chip within floor */
  selectChip (flash, (Reg8bitType)((*address) / (flash->chipSize * flash->interleaving))) ;
}

/*----------------------------------------------------------------------*/
/*                        r d B u f                                     */
/*                                                                      */
/* Auxiliary routine for Read(), read from page.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      buf     : Buffer to read into.                                  */
/*      howmany : Number of bytes to read.                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void rdBuf (FLFlash * flash, byte FAR1 *buf, word howmany)
{
  volatile Reg8bitType junk = 0;
  register word i;
#ifdef SLOW_IO_FLAG
  /* slow flash requires first read to be done from CDSN_Slow_IO
     and only second one from CDSN_IO - this extends read access */

  for( i = 0 ;( i < howmany ); i++ ) {
    junk = flRead8bitReg(flash,NslowIO);
    buf[i] = (byte)flRead8bitReg(flash,NFDC21thisIO+(i & 0x01));
  }
#else
  if( NFDC21thisVars->flags & MDOC_ASIC ) {
    junk += flRead8bitReg(flash,NreadPipeInit);
    howmany--;
    i = TFFSMIN( howmany, MDOC_ALIAS_RANGE );
    docread(flash->win,NFDC21thisIO,buf,i);
  }
  else i = 0;
  if( howmany > i )
    docread(flash->win,NFDC21thisIO,buf+i,(word)(howmany-i));

  if( NFDC21thisVars->flags & MDOC_ASIC )
    buf[howmany] = flRead8bitReg(flash,NreadLastData);
#endif
}
#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                        w r B u f                                     */
/*                                                                      */
/* Auxiliary routine for Write(), write to page from buffer.            */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      buf     : Buffer to write from.                                 */
/*      howmany : Number of bytes to write.                             */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void  wrBuf (FLFlash * flash, const byte FAR1 *buf, word howmany )
{
#ifdef SLOW_IO_FLAG
  register int i;
  /* slow flash requires first write go to CDSN_Slow_IO and
     only second one to CDSN_IO - this extends write access */

  for ( i = 0 ;( i < howmany ); i++ ) {
    flWrite8bitReg(flash,NslowIO,(Reg8bitType)buf[i]);
    flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)buf[i]);
  }
#else
  docwrite(flash->win,NFDC21thisIO,(byte FAR1 *)buf,howmany);
  if( NFDC21thisVars->flags & MDOC_ASIC )
    flWrite8bitReg(flash,NwritePipeTerm,(Reg8bitType)0);
#endif
}

/*----------------------------------------------------------------------*/
/*                        w r S e t                                     */
/*                                                                      */
/* Auxiliary routine for Write(), set page data.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      ch      : Set page to this byte                                 */
/*      howmany : Number of bytes to set.                               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void  wrSet (FLFlash * flash, const Reg8bitType ch, word howmany )
{
#ifdef SLOW_IO_FLAG
    register int i;
    /* slow flash requires first write go to CDSN_Slow_IO and
       only second one to CDSN_IO - this extends write access */

    for (i = 0 ;( i < howmany ); i++ ) {
      flWrite8bitReg(flash,NslowIO,(Reg8bitType)ch);
      flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)ch);
    }
#else
    docset(flash->win,NFDC21thisIO,howmany,ch);
    if( NFDC21thisVars->flags & MDOC_ASIC )
      flWrite8bitReg(flash,NwritePipeTerm,(Reg8bitType)0);
#endif
}

/*----------------------------------------------------------------------*/
/*                        r e a d S t a t u s                           */
/*                                                                      */
/* Read status of selected flash device.                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*                                                                      */
/* Returns:                                                             */
/*      Chip status.                                                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static Reg8bitType readStatus (FLFlash * flash)
{
  Reg8bitType chipStatus;
  volatile Reg8bitType junk = 0;

  flWrite8bitReg(flash,NFDC21thisIO,READ_STATUS);
  if( NFDC21thisVars->flags & MDOC_ASIC )
    flWrite8bitReg(flash,NwritePipeTerm,READ_STATUS);
  writeSignals (flash, FLASH_IO | CE | WP);

  if( NFDC21thisVars->flags & MDOC_ASIC ) {
    junk += flRead8bitReg(flash,NreadPipeInit); /* load first data into pipeline */
    chipStatus = flRead8bitReg(flash,NreadLastData); /* read flash status */
  }
  else {
    junk += flRead8bitReg(flash,NslowIO);
    chipStatus = flRead8bitReg(flash,NFDC21thisIO);
  }
  return chipStatus;
}
#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                        r e a d C o m m a n d                         */
/*                                                                      */
/* Issue read command.                                                  */
/*                                                                      */
/* Parametes:                                                           */
/*      flash     : Pointer identifying drive                           */
/*      cmd     : Command to issue (according to area).                 */
/*      addr    : address to read from.                                 */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void readCommand (FLFlash * flash, PointerOp  cmd, CardAddress addr)
{
  command (flash, (Reg8bitType)cmd);  /* move flash pointer to respective area of the page */
  setAddress (flash, addr);
  waitForReady(flash);
}
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                        w r i t e C o m m a n d                       */
/*                                                                      */
/* Issue write command.                                                 */
/*                                                                      */
/* Parametes:                                                           */
/*      flash     : Pointer identifying drive                           */
/*      cmd     : Command to issue (according to area).                 */
/*      addr    : address to write to.                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void writeCommand (FLFlash * flash, PointerOp  cmd, CardAddress addr)
{
  if( flash->flags & FULL_PAGE ) {
    command (flash, RESET_FLASH);
    waitForReady(flash);
    if( cmd != AREA_A ) {
#ifdef SLOW_IO_FLAG
      flWrite8bitReg(flash,NslowIO,(byte)cmd);
#endif
      flWrite8bitReg(flash,NFDC21thisIO,(byte)cmd);
      if( NFDC21thisVars->flags & MDOC_ASIC )
         flWrite8bitReg(flash,NwritePipeTerm,(byte)cmd);
    }
  }
  else
    command (flash, (Reg8bitType)cmd); /* move flash pointer to respective area of the page */

#ifdef SLOW_IO_FLAG
  flWrite8bitReg(flash,NslowIO,SERIAL_DATA_INPUT);
#endif

  flWrite8bitReg(flash,NFDC21thisIO,SERIAL_DATA_INPUT);
  if( NFDC21thisVars->flags & MDOC_ASIC )
    flWrite8bitReg(flash,NwritePipeTerm,SERIAL_DATA_INPUT);

  setAddress (flash, addr);

  waitForReady(flash);
}

/*----------------------------------------------------------------------*/
/*                        w r i t e E x e c u t e                       */
/*                                                                      */
/* Execute write.                                                       */
/*                                                                      */
/* Parametes:                                                           */
/*      flash     : Pointer identifying drive                           */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus writeExecute (FLFlash * flash)
{
  command (flash, SETUP_WRITE);             /* execute page program */
  waitForReady(flash);

  if( readStatus(flash) & (byte)(FAIL) ) {
    DEBUG_PRINT(("Debug: NFDC 2148 write failed.\r\n"));
    return( flWriteFault );
  }

  return( flOK );
}

/*----------------------------------------------------------------------*/
/*                        w r i t e O n e S e c t o r                   */
/*                                                                      */
/* Write data in one 512-byte block to flash.                           */
/* Assuming that EDC mode never requested on partial block writes.      */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : Address of sector to write to.                        */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write (up to sector size).         */
/*      modes   : OVERWRITE, EDC flags etc.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus writeOneSector(FLFlash * flash,
                   CardAddress address,
                   const void FAR1 *buffer,
                   word length,
                   word modes)
{
  byte FAR1 *pbuffer = (byte FAR1 *)buffer; /* to write from */
  FLStatus  status;
#ifndef NO_EDC_MODE
  byte syndrom[SYNDROM_BYTES];
  static byte anandMark[2] = { 0x55, 0x55 };
#endif
  PointerOp cmd = AREA_A ;
  word prePad;
#ifdef BIG_PAGE_ENABLED
  word toFirstPage = 0, toSecondPage = 0;
#endif /* BIG_PAGE_ENABLED */

#ifndef MTD_STANDALONE
  if (flWriteProtected(flash->socket))
    return( flWriteProtect );
#endif

  mapWin(flash, &address);                  /* select flash device */

  /* move flash pointer to areas A,B or C of page */
  makeCommand(flash, &cmd, &address, modes);

  if( (flash->flags & FULL_PAGE)  &&  (cmd == AREA_B) ) {
    prePad = (word)(2 + ((word) address & NFDC21thisVars->pageMask));
    writeCommand(flash, AREA_A, address + NFDC21thisVars->pageAreaSize - prePad);
    wrSet(flash, 0xFF, prePad);
  }
  else
    writeCommand(flash, cmd, address);

#ifndef NO_EDC_MODE
  if( modes & EDC )
    eccONwrite(flash);                /* ECC ON for write */
#endif

#ifdef BIG_PAGE_ENABLED
  if( !(flash->flags & BIG_PAGE) )             /* 2M on INLV=1 */
  {
            /* write up to two pages separately */
    if( modes & EXTRA )
      toFirstPage = EXTRA_LEN - ((word)address & (EXTRA_LEN-1));
    else
      toFirstPage = CHIP_PAGE_SIZE - ((word)address & (CHIP_PAGE_SIZE-1));

    if(toFirstPage > length)
      toFirstPage = length;
    toSecondPage = length - toFirstPage;

    wrBuf(flash, pbuffer, toFirstPage);                  /* starting page .. */

    if ( toSecondPage > 0 )
    {
      if (toFirstPage > 0)                       /* started on 1st page */
         checkStatus( writeExecute(flash) );       /* done with 1st page */
      if( modes & EXTRA )
        address -= (CHIP_PAGE_SIZE + ((word)address & (EXTRA_LEN-1)));
      writeCommand(flash, cmd, address + toFirstPage);
      wrBuf (flash, pbuffer + toFirstPage, toSecondPage);  /* user data */
    }
  }
  else                                     /* 4M or 8M */
#endif /* BIG_PAGE_ENABLED */

    wrBuf (flash, pbuffer, length);               /* user data */

#ifndef NO_EDC_MODE
  if(modes & EDC)
  {
    register int i;

    writeSignals (flash, ECC_IO | CE );             /* disable flash access */
     /* 3 dummy zero-writes to clock the data through pipeline */
    if( NFDC21thisVars->flags & MDOC_ASIC ) {
      for( i = 0;( i < 3 ); i++ ) {
         flWrite8bitReg(flash,NNOPreg,(Reg8bitType)0);
      }
    }
    else {
      wrSet (flash, 0x00, 3 );
    }
    writeSignals (flash, ECC_IO | FLASH_IO | CE );  /* enable flash access */

    docread(flash->win,Nsyndrom,syndrom,SYNDROM_BYTES);
#ifdef D2TST
    tffscpy(saveSyndromForDumping,syndrom,SYNDROM_BYTES);
#endif
    eccOFF(flash);                           /* ECC OFF  */

    wrBuf (flash, (const byte FAR1 *)syndrom, SYNDROM_BYTES);

    wrBuf (flash, (const byte FAR1 *)anandMark, sizeof(anandMark) );
  }
#endif /* NO_EDC_MODE */

  status = writeExecute(flash);             /* abort if write failure */
  if(status != flOK)
    return status;

  writeSignals(flash, FLASH_IO | WP);

#ifdef VERIFY_WRITE

#ifndef MTD_STANDALONE
  if (flash->socket->verifyWrite==FL_OFF)
      return status;
#endif /* MTD_STANDALONE */

  /* Read back after write and verify */

  if( modes & OVERWRITE )
    pbuffer = (byte FAR1 *) buffer;     /* back to original data */

  readCommand (flash, cmd, address); /* move flash pointer to areas A,B or C of page */

#ifdef BIG_PAGE_ENABLED

  if( !(flash->flags & BIG_PAGE) )
  {
    rdBuf (flash, NFDC21thisVars->readBackBuffer, toFirstPage);

    if(tffscmp (pbuffer, NFDC21thisVars->readBackBuffer, toFirstPage) ) {
      DEBUG_PRINT(("Debug: NFDC 2148 write failed in verification.\r\n"));
      return( flWriteFault );
    }

    if ( toSecondPage > 0 )
    {
      readCommand (flash, AREA_A, address + toFirstPage);

      rdBuf (flash, NFDC21thisVars->readBackBuffer + toFirstPage, toSecondPage);

      if( tffscmp (pbuffer + toFirstPage, NFDC21thisVars->readBackBuffer + toFirstPage, toSecondPage)) {
    DEBUG_PRINT(("Debug: NFDC 2148 write failed in verification.\r\n"));
    return( flWriteFault );
      }
    }
  }
  else
#endif /* BIG_PAGE_ENABLED */
  {
    rdBuf (flash, NFDC21thisVars->readBackBuffer, length);

    if( tffscmp (pbuffer, NFDC21thisVars->readBackBuffer, length) ) {
      DEBUG_PRINT(("Debug: NFDC 2148 write failed in verification.\r\n"));
      return( flWriteFault );
    }
  }
         /* then ECC and special ANAND mark */

#ifndef NO_EDC_MODE
  if( modes & EDC )
  {
    rdBuf (flash, NFDC21thisVars->readBackBuffer, SYNDROM_BYTES);
    if( tffscmp (syndrom, NFDC21thisVars->readBackBuffer, SYNDROM_BYTES) )
      return( flWriteFault );

    rdBuf (flash, NFDC21thisVars->readBackBuffer, sizeof(anandMark));
    if( tffscmp (anandMark, NFDC21thisVars->readBackBuffer, sizeof(anandMark)) )
      return( flWriteFault );
  }
#endif /* NO_EDC_MODE */

  writeSignals (flash, FLASH_IO | WP);
  waitForReady(flash);                            /* Serial Read Cycle Entry */
#endif /* VERIFY_WRITE */

  return( flOK );
}

/*----------------------------------------------------------------------*/
/*                        d o c 2 W r i t e                             */
/*                                                                      */
/* Write some data to the flash. This routine will be registered as the */
/* write routine for this MTD.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : Address of sector to write to.                        */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write (up to sector size).         */
/*      modes   : OVERWRITE, EDC flags etc.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus doc2Write(FLFlash * flash,
              CardAddress address,
              const void FAR1 *buffer,
              dword length,
              word modes)
{
  char FAR1 *temp = (char FAR1 *)buffer;
  FLStatus status;
#ifdef BIG_PAGE_ENABLED
  word block = (word)((modes & EXTRA) ? EXTRA_LEN : SECTOR_SIZE);
#else
  word block = (word)((modes & EXTRA) ? SECTOR_EXTRA_LEN : SECTOR_SIZE);
#endif /* BIG_PAGE_ENABLED */
  word writeNow = block - ((word)address & (block - 1));

#ifdef ENVIRONMENT_VARS
  if(flSuspendMode & FL_SUSPEND_WRITE)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

  /* write in BLOCKs; first and last might be partial */
  chkASICmode(flash);

  while( length > 0 )
  {
     if(writeNow > length)
       writeNow = (word)length;
          /* turn off EDC on partial block write */

    status = writeOneSector(flash, address, temp, writeNow,
             (word)((writeNow != SECTOR_SIZE) ? (modes &= ~EDC) : modes) );
    if(status!=flOK)
      return status;

    length -= writeNow;
    address += writeNow;
    temp += writeNow;
    writeNow = block;          /* align at BLOCK */
  }
  return( flOK );
}
#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                        r e a d O n e S e c t o r                     */
/*                                                                      */
/* Read up to one 512-byte block from flash.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : Address to read from.                                 */
/*      buffer  : buffer to read to.                                    */
/*      length  : number of bytes to read (up to sector size).          */
/*      modes   : EDC flag etc.                                         */
/*                                                                      */
/* Notes: big_page_enabled does not support PARTIAL_EDC FLAG            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus readOneSector (FLFlash * flash,
                   CardAddress address,
                   void FAR1 *buffer,
                   word length,
                   word modes)
{
#ifndef NO_EDC_MODE
  byte        extraBytes[SYNDROM_BYTES];
#ifdef MTD_STANDALONE
  int         index;
#endif
#endif
  FLStatus    stat = flOK;
  PointerOp   cmd   = AREA_A;            /* default for .... */
  CardAddress addr  = address;           /* .... KM29N16000  */
#ifdef BIG_PAGE_ENABLED
  int  toFirstPage, toSecondPage;
#endif /* BIG_PAGE_ENABLED */

  mapWin(flash, &addr);

  makeCommand(flash, &cmd, &addr, modes);  /* move flash pointer to areas A,B or C of page */

  readCommand(flash, cmd, addr);

#ifndef NO_EDC_MODE
  if( modes & EDC )
    eccONread(flash);
#endif
#ifdef BIG_PAGE_ENABLED
  if( !(flash->flags & BIG_PAGE) )
  {
    /* read up to two pages separately */
    if( modes & EXTRA )
      toFirstPage = EXTRA_LEN - ((word)addr & (EXTRA_LEN-1));
    else
      toFirstPage = CHIP_PAGE_SIZE - ((word)addr & (CHIP_PAGE_SIZE-1));

    if(toFirstPage > length)
      toFirstPage = length;
    toSecondPage = length - toFirstPage;

    rdBuf (flash, (byte FAR1 *)buffer, toFirstPage ); /* starting page */

    if ( toSecondPage > 0 )                  /* next page */
    {
      if( modes & EXTRA )
         addr -= (CHIP_PAGE_SIZE + ((word)addr & (EXTRA_LEN-1)));
      readCommand (flash, cmd, addr + toFirstPage);
      rdBuf(flash, (byte FAR1 *)buffer + toFirstPage, toSecondPage );
    }
  }
  else
#endif /* BIG_PAGE_ENABLED */
  {
    rdBuf(flash, (byte FAR1 *)buffer, length );

#ifndef NO_EDC_MODE
    if((modes & PARTIAL_EDC) &&
       (((word)address & NFDC21thisVars->pageMask) == 0))
    {
       /* Partial page read with EDC must let rest of page through
          the HW edc mechanism */

       word unreadBytes;

       for (unreadBytes = SECTOR_SIZE - length;unreadBytes > 0;unreadBytes--)
       {
          cmd = (PointerOp)flRead8bitReg(flash, NFDC21thisIO);
       }
    }
#endif /* NO_EDC_MODE */
  }

#ifndef NO_EDC_MODE
  if( modes & EDC )
  {       /* read syndrom to let it through the ECC unit */

    rdBuf(flash, extraBytes, SYNDROM_BYTES );

    if( eccError(flash) )  /* An EDC error was found */
    {
#ifdef MTD_STANDALONE
    /* Check if all of the EDC bytes are FF's. If so ignore the EDC     */
    /* assuming that it has'nt been used due to programing of less then */
    /* 512 bytes                                                        */

      for(index=0;index<SYNDROM_BYTES;index++)
      {
        if (extraBytes[index]!=0xFF)
        break;
      }

      if (index!=SYNDROM_BYTES) /* not all of the EDC bytes are FF's */
#endif /* MTD_STANDALONE */

      {
              /* try to fix ECC error */
     if ( modes & NO_SECOND_TRY )             /* 2nd try */
     {
        byte syndrom[SYNDROM_BYTES];
        byte tmp;

        docread(flash->win,Nsyndrom,syndrom,SYNDROM_BYTES);
        tmp = syndrom[0];                     /* Swap 1 and 3 words */
        syndrom[0] = syndrom[4];
        syndrom[4] = tmp;
        tmp = syndrom[1];
        syndrom[1] = syndrom[5];
        syndrom[5] = tmp;

        if( flCheckAndFixEDC( (char FAR1 *)buffer, (char*)syndrom, 1) != NO_EDC_ERROR)
        {
           DEBUG_PRINT(("Debug: EDC error for NFDC 2148.\r\n"));
           stat = flDataError;
        }
     }
     else                                 /* 1st try - try once more */
       return( readOneSector( flash, address, buffer, length,
                  (word)(modes | NO_SECOND_TRY) ) );
      }
    }
    eccOFF(flash);
  }
#endif /* NO_EDC_MODE */

  writeSignals (flash, FLASH_IO | WP);
  if( (modes & EXTRA) &&                    /* Serial Read Cycle Entry */
      ((length + (((word)addr) & (NFDC21thisVars->tailSize - 1)))
    == NFDC21thisVars->tailSize) )
    waitForReady(flash);

  return( stat );
}

/*----------------------------------------------------------------------*/
/*                        d o c 2 R e a d                               */
/*                                                                      */
/* Read some data from the flash. This routine will be registered as    */
/* the read routine for this MTD.                                       */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : Address to read from.                                 */
/*      buffer  : buffer to read to.                                    */
/*      length  : number of bytes to read (up to sector size).          */
/*      modes   : EDC flag etc.                                         */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus doc2Read(FLFlash * flash,
             CardAddress address,
             void FAR1 *buffer,
             dword length,
             word modes)
{
  char FAR1 *temp = (char FAR1 *)buffer;
  FLStatus   status;
  word       readNow;

#ifdef BIG_PAGE_ENABLED
  word block = (word)(( modes & EXTRA ) ? EXTRA_LEN : SECTOR_SIZE );
#else
  word block = (word)(( modes & EXTRA ) ? SECTOR_EXTRA_LEN : SECTOR_SIZE );
#endif /* BIG_PAGE_ENABLED */

#ifdef ENVIRONMENT_VARS
  if((flSuspendMode & FL_SUSPEND_IO) == FL_SUSPEND_IO)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

  chkASICmode(flash);
          /* read in BLOCKs; first and last might be partial */

  readNow = block - ((word)address & (block - 1));

  while( length > 0 ) {
    if( readNow > length )
      readNow = (word)length;
          /* turn off EDC on partial block read */
    status = readOneSector(flash, address, temp, readNow, (word)(
             ((readNow != SECTOR_SIZE) && (modes != PARTIAL_EDC)) ?
             modes &=~PARTIAL_EDC : modes));
    if(status != flOK)
      return status;

    length -= readNow;
    address += readNow;
    temp += readNow;
    readNow = block;       /* align at BLOCK */
  }
  return( flOK );
}

#ifndef FL_READ_ONLY

#if (defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT))

/*----------------------------------------------------------------------*/
/*                        c h e c k E r a s e                           */
/*                                                                      */
/* Check if media is truly erased (main areas of page only).            */
/*                                                                      */
/* Note to save on memory consumption the 1k read back buffer is used   */
/* Only when the VERIFY_ERASE compilation flag is set.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : Address of page to check.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 if page is erased, otherwise writeFault.    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus checkErase( FLFlash * flash, CardAddress address )
{
  register int i, j;
  word inc = READ_BACK_BUFFER_SIZE;
  dword * bufPtr = (dword *)NFDC21thisVars->readBackBuffer;
  CardAddress curAddress = address;
  word block = (word)(flash->erasableBlockSize / inc);
  dword * endBufPtr = bufPtr+(inc / sizeof(dword));
  dword * curBufPtr;

  /* Check main area */
  for ( i = 0 ; i < block ; i++, curAddress += inc )
  {
    if ( doc2Read(flash,curAddress,(void FAR1 *)bufPtr,(dword)inc,0) != flOK )
      return( flWriteFault );

    for ( curBufPtr = bufPtr ;
          curBufPtr < endBufPtr ; curBufPtr++)
      if ( *bufPtr != 0xFFFFFFFFL )
        return( flWriteFault );
  }

  /* Check extra area */
  for ( i = 0 ; i < NFDC21thisVars->pagesPerBlock ; i++,address+=SECTOR_SIZE)
  {
    if ( doc2Read(flash,address,(void FAR1 *)bufPtr,
                  NFDC21thisVars->tailSize, EXTRA) !=  flOK )
      return( flWriteFault );

    for (j=0;j<(NFDC21thisVars->tailSize>>2);j++)
    {
       if (bufPtr[j] != 0xFFFFFFFFL)
         return( flWriteFault );
    }
  }
  return( flOK );
}

#endif /* VERIFY_ERASE or MTD_RECONSTRUCT_BBT */

/*----------------------------------------------------------------------*/
/*                        d o c 2 E r a s e                             */
/*                                                                      */
/* Erase number of blocks. This routine will be registered as the       */
/* erase routine for this MTD.                                          */
/*                                                                      */
/* Note - can not erase all units of 1GB DiskOnChip.                    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*      blockNo         : First block to erase.                         */
/*      blocksToErase   : Number of blocks to erase.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus                : 0 on success, otherwise failed.       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus doc2Erase(FLFlash * flash,
              word blockNo,
              word blocksToErase)
{
  FLStatus status = flOK;
  word  floorToUse;
  word  nextFloorBlockNo, i;
  CardAddress startAddress = (CardAddress)blockNo * flash->erasableBlockSize;
  CardAddress address      = startAddress;

#ifdef ENVIRONMENT_VARS
  if(flSuspendMode & FL_SUSPEND_WRITE)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

#ifndef MTD_STANDALONE
  if (flWriteProtected(flash->socket))
    return( flWriteProtect );
#endif /* MTD_STANDALONE */

  if( (dword)((dword)blockNo + (dword)blocksToErase) >
      (dword)((dword)NFDC21thisVars->noOfBlocks * (dword)flash->noOfChips))
    return( flWriteFault );                             /* out of media */

  chkASICmode(flash);
          /* handle erase accross floors */
#ifndef SEPARATED_CASCADED
  floorToUse = (word)(startAddress / NFDC21thisVars->floorSize) + 1;

  if (floorToUse != flash->noOfFloors)
  {
     nextFloorBlockNo = (word)(floorToUse * (NFDC21thisVars->floorSize /
                        flash->erasableBlockSize));

     if( blockNo + blocksToErase > nextFloorBlockNo )
     {           /* erase on higher floors */
        status = ( doc2Erase( flash, nextFloorBlockNo,
        (word)(blocksToErase - (nextFloorBlockNo - blockNo))) );
        blocksToErase = nextFloorBlockNo - blockNo;
        if(status!=flOK)
          return status;
     }
  }
#endif /* SEPARATED_CASCADED */

  /* erase on this floor */

  mapWin (flash, &address);

  for (i = 0; i < blocksToErase ; i++, blockNo++ ) {
    dword pageNo = ((dword)blockNo * NFDC21thisVars->pagesPerBlock);

    command(flash, RESET_FLASH);
    writeSignals (flash, FLASH_IO | CE);
    waitForReady(flash);

    command(flash, SETUP_ERASE);

    writeSignals (flash, FLASH_IO | ALE | CE);
#ifdef SLOW_IO_FLAG
    flWrite8bitReg(flash,NslowIO,(Reg8bitType)pageNo);
    flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)pageNo);
    flWrite8bitReg(flash,NslowIO,(Reg8bitType)(pageNo >> 8));
    flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(pageNo >> 8));
    if( flash->flags & BIG_ADDR ) {
      flWrite8bitReg(flash,NslowIO,(Reg8bitType)(pageNo >> 16));
      flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(pageNo >> 16));
    }
#else
    flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)pageNo);
    flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(pageNo >> 8));
    if( flash->flags & BIG_ADDR )
      flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)(pageNo >> 16));
    if( NFDC21thisVars->flags & MDOC_ASIC )
      flWrite8bitReg(flash,NwritePipeTerm,(Reg8bitType)0);
#endif /* SLOW_IO_FLAG */
    writeSignals(flash, FLASH_IO | CE);

    /* if only one block may be erase at a time then do it */
    /* otherwise leave it for later                        */

    command(flash, CONFIRM_ERASE);

#ifndef MTD_STANDALONE
#ifndef DO_NOT_YIELD_CPU
    if(waitForReadyWithYieldCPU(flash,MAX_WAIT)==FALSE)
#endif /* DO_NOT_YIELD_CPU */
#endif /* MTD_STANDALONE */
    {
       waitForReady(flash);
    }
    if ( readStatus(flash) & (byte)(FAIL) ) {         /* erase operation failed */
      DEBUG_PRINT(("Debug: NFDC 2148 erase failed.\r\n"));
      status = flWriteFault;

        /* reset flash device and abort */

      command(flash, RESET_FLASH);
      waitForReady(flash);

      break;
    }
    else {                                    /* no failure reported */
#ifdef VERIFY_ERASE

      if ( checkErase( flash, startAddress + i * flash->erasableBlockSize) != flOK ) {
         DEBUG_PRINT(("Debug: NFDC 2148 erase failed in verification.\r\n"));
         return flWriteFault ;
      }

#endif  /* VERIFY_ERASE */
    }
  }       /* block loop */

#ifdef MULTI_ERASE
    /* do multiple block erase as was promised */

  command(flash, CONFIRM_ERASE);
#ifndef MTD_STANDALONE
#ifndef DO_NOT_YIELD_CPU
  waitForReadyWithYieldCPU(flash,MAX_WAIT);
#endif /* DO_NOT_YIELD_CPU */
#endif /* MTD_STANDALONE */
  if ( readStatus(flash) & (byte)(FAIL) ) {        /* erase operation failed */
    DEBUG_PRINT(("Debug: NFDC 2148 erase failed.\r\n"));
    status = flWriteFault;

        /* reset flash device and abort */

    command(flash, RESET_FLASH);
    waitForReady(flash);
  }
#endif   /* MULTI_ERASE */

  writeSignals (flash, FLASH_IO | WP);
  return( status );
}
#endif /* FL_READ_ONLY */

#ifndef MTD_STANDALONE

/*----------------------------------------------------------------------*/
/*                        d o c 2 M a p                                 */
/*                                                                      */
/* Map through buffer. This routine will be registered as the map       */
/* routine for this MTD.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash     : Pointer identifying drive                           */
/*      address : Flash address to be mapped.                           */
/*      length  : number of bytes to map.                               */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to the buffer data was mapped to.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void FAR0 *doc2Map ( FLFlash * flash, CardAddress address, int length )
{
  doc2Read(flash,address,NFDC21thisBuffer,length, 0);
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
  return( (void FAR0 *)NFDC21thisBuffer );
}
#endif /* MTD_STANDALONE */

#ifdef MTD_READ_BBT

/*----------------------------------------------------------------------*/
/*                           R e a d B B T                              */
/*                                                                      */
/*  Read the media Bad Blocks Table to a user buffer.                   */
/*                                                                      */
/*  Parameters:                                                         */
/*  flash         : Pointer identifying drive                           */
/*  unitNo      : indicated which unit number to start checking from.   */
/*  unitToRead  : indicating how many units to check                    */
/*  buffer      : buffer to read into.                                  */
/*  reconstruct : TRUE for reconstruct BBT from virgin card             */
/*                                                                      */
/*  Note: blocks is a minimal flash erasable area.                      */
/*  Note: unit can contain several blocks.                              */
/*  Note: There is no current implementation of a unit that contains    */
/*        more then a single block.                                     */
/*  Note: The format of the BBT is byte per unit 0 for bad any other    */
/*        value for good.                                               */
/*  Note: global variables changed at doc2Read:                         */
/*      global variable NFDC21thisVars->currentFloor is updated         */
/*      flash->socket.window.currentPage = pageToMap;                   */
/*      flash->socket.remapped = TRUE;                                  */
/*  Note: At least 4 bytes must be read                                 */
/*                                                                      */
/*  RETURNS:                                                            */
/*     flOK on success                                                  */
/*     flBadLength if one of the units is out of the units range        */
/*     flBadBBT on read fault                                           */
/*----------------------------------------------------------------------*/
static FLStatus readBBT(FLFlash * flash, dword unitNo, dword unitsToRead,
                        byte blockMultiplier, byte FAR1 * buffer,
                        FLBoolean reconstruct)
{
   CardAddress bbtAddr,floorEndAddr;
   CardAddress addr,floorStartAddr,alignAddr;
   dword       unitsPerFloor = NFDC21thisVars->floorSize >> flash->erasableBlockSizeBits;
   word        curRead,actualRead;
   CardAddress mediaSize = (CardAddress)flash->chipSize*flash->noOfChips;
   FLStatus    status = flOK;
   dword       unitOffset;
   dword       sizeOfBBT;
   word        counter;

   byte FAR1*  bufPtr = buffer;
#if (defined (MTD_RECONSTRUCT_BBT) && !defined(FL_READ_ONLY))
   CardAddress bbtCurAddr;
   dword       i;
   byte        reconstructBBT = 0;
#endif  /* MTD_RECONSTRUCT_BBT && not FL_READ_ONLY */

   /* Arg sanity check */
   if (((dword)(unitNo+unitsToRead) <<
        (blockMultiplier+flash->erasableBlockSizeBits)) > mediaSize)
     return flBadParameter;

   /* Calculate size of BBT blocks */
   for(sizeOfBBT = flash->erasableBlockSize;
       sizeOfBBT < unitsPerFloor ;sizeOfBBT = sizeOfBBT<<1);
#ifndef MTD_STANDALONE
   /* Force remapping of internal catched sector */
   flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */
   /* Adjust no' of blocks per floor according to blocks multiplier */
   unitsPerFloor = unitsPerFloor >> blockMultiplier;
   /* Mark all user buffer as good units */
   tffsset(buffer,BBT_GOOD_UNIT,unitsToRead);

   /* Loop over all of the floors */
   for (floorStartAddr  = 0 ; (floorStartAddr < mediaSize) && (unitsToRead > 0);
        floorStartAddr += NFDC21thisVars->floorSize)
   {
      floorEndAddr = TFFSMIN(floorStartAddr+NFDC21thisVars->floorSize,mediaSize);
      /* Look for bbt signature in extra area start looking from last unit */
      for(bbtAddr = floorEndAddr - sizeOfBBT,
          counter = BBT_MAX_DISTANCE;
          (bbtAddr > floorStartAddr) && (counter > 0);
          bbtAddr -= flash->erasableBlockSize , counter--)
      {
         status = doc2Read(flash,bbtAddr+8,NFDC21thisBuffer,BBT_SIGN_SIZE,EXTRA);
         if (status != flOK)
            return flBadBBT;
         if(tffscmp(NFDC21thisBuffer,BBT_SIGN,BBT_SIGN_SIZE)==0)
            break;
      }

      /* No BBT was found virgin card */

      if((bbtAddr==floorStartAddr) || (counter == 0))
      {
#if (defined (MTD_RECONSTRUCT_BBT) && !defined(FL_READ_ONLY))
        if (reconstruct == TRUE)
        {
           reconstructBBT++;
           if (reconstructBBT == 1)
              DFORMAT_PRINT(("\rVirgin card rebuilding unit map.\r\n\n"));

           /* Find good unit for BBT */

           for(bbtAddr = floorEndAddr - sizeOfBBT ;
               bbtAddr > floorStartAddr ;
               bbtAddr -= flash->erasableBlockSize , status = flOK)
           {
              /* Find enough consequtive units for the BBT */
              for(i=0;(status == flOK)&&(i<sizeOfBBT);i+=flash->erasableBlockSize)
              {
                 status = checkErase(flash, bbtAddr+i);
              }
              if(status == flOK)
                 break;
           }
           if (bbtAddr == floorStartAddr) /* Could not find place for BBT */
           {
              DFORMAT_PRINT(("Debug: no good block found.\r\n"));
              return flBadBBT;
           }

           /* Search and mark the entire floor BBT (512 at a time) */

           bbtCurAddr = bbtAddr;
           for (addr=floorStartAddr;
                addr<floorEndAddr; bbtCurAddr+=SECTOR_SIZE)
           {
              /* Mark all blocks as good */
              tffsset(NFDC21thisBuffer,BBT_GOOD_UNIT,SECTOR_SIZE);
              /* Mark IPL as unused */
              for (i=0;i<SECTOR_SIZE;i++,addr+=flash->erasableBlockSize)
              {
            #ifndef NT5PORT
                 DFORMAT_PRINT(("Checking block %u\r",(word)(addr>>flash->erasableBlockSizeBits)));
            #endif// NT5PORT
                 /* Bad block table is marked as unavailable */
                 if ((addr>=bbtAddr) && (addr<bbtAddr+sizeOfBBT))
                 {
                    NFDC21thisBuffer[i] = BBT_UNAVAIL_UNIT;
                 }
                 else /* The unerased blocks are marked as bad */
                 {
                    if(checkErase(flash, addr) != flOK)
                    {
                       NFDC21thisBuffer[i] = BBT_BAD_UNIT;
                    }
                 }
              }
              if(addr == (flash->erasableBlockSize<<SECTOR_SIZE_BITS))
              {
                 /* If IPL unit is good mark it as unavailable */
                 if(NFDC21thisBuffer[0] != BBT_BAD_UNIT)
                   NFDC21thisBuffer[0] = BBT_UNAVAIL_UNIT;
              }
              status = doc2Write(flash,bbtCurAddr,NFDC21thisBuffer,SECTOR_SIZE,EDC);
              if (status != flOK)
              {
                 DFORMAT_PRINT(("ERROR - Failed writting bad block table.\r\n"));
                 return flBadBBT;
              }
           }
           /* Mark bad blocks table with special mark */
           status = doc2Write(flash,bbtAddr+8,BBT_SIGN, BBT_SIGN_SIZE,EXTRA);
        }
        else
#endif  /* MTD_RECONSTRUCT_BBT && not FL_READ_ONLY */
        {
            return flBadBBT;
        }
      }

      /* Return only blocks that are in this floor */
      addr = floorStartAddr >> (flash->erasableBlockSizeBits + blockMultiplier);

      if ((unitNo >= addr) && (unitNo < addr + unitsPerFloor))
      {
         unitOffset   = (unitNo % unitsPerFloor);
         curRead      = ((word)TFFSMIN(unitsToRead,unitsPerFloor - unitOffset));
         unitsToRead -= curRead;

         /* Convert to real number of bytes to read and address */
         unitOffset <<= blockMultiplier;
         curRead    <<= blockMultiplier;
         alignAddr    = ((bbtAddr + unitOffset) >> SECTOR_SIZE_BITS)<<SECTOR_SIZE_BITS;

         do /* Read and copy into buffer 512 blocks at a time */
         {
           if (doc2Read(flash,alignAddr, NFDC21thisBuffer,SECTOR_SIZE,EDC) != flOK)
              return flBadBBT;

           unitOffset = unitOffset % SECTOR_SIZE;
           actualRead = (word)TFFSMIN(SECTOR_SIZE - unitOffset,curRead);
           curRead   -= actualRead;
           /* Copy relevant blocks into user buffer */
           for (actualRead += (word)unitOffset ;
                unitOffset < actualRead ;
                bufPtr = BYTE_ADD_FAR(bufPtr,1)) /* increment buffer */
           {
             for (counter = 1 << blockMultiplier ; counter > 0 ;
                  counter-- , unitOffset++)
             {
                if (NFDC21thisBuffer[unitOffset] != BBT_GOOD_UNIT)
                {
                  *bufPtr = NFDC21thisBuffer[unitOffset];
                }
             }
           }
           alignAddr+=SECTOR_SIZE;
         }while(curRead > 0);

         if (unitsToRead > 0)
            unitNo = addr + unitsPerFloor;
      }
   }

#if (defined (MTD_RECONSTRUCT_BBT) && !defined(FL_READ_ONLY))
   if (reconstructBBT > 0)
      DFORMAT_PRINT(("\rMedia has been scanned.       \r\n"));
#endif  /* MTD_RECONSTRUCT_BBT && not FL_READ_ONLY */

   return flOK;
}
#endif /* MTD_READ_BBT */

/*----------------------------------------------------------------------*/
/*                        i s K n o w n M e d i a                       */
/*                                                                      */
/* Check if this flash media is supported. Initialize relevant fields   */
/* in data structures.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*      vendorId_P      : vendor ID read from chip.                     */
/*      chipId_p        : chip ID read from chip.                       */
/*      dev             : dev chips were accessed before this one.      */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if this media is supported, FALSE otherwise.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLBoolean isKnownMedia( FLFlash * flash, Reg8bitType vendorId_p, Reg8bitType chipId_p, int dev )
{
  if((dev == 0)
#ifndef SEPARATED_CASCADED
     && (NFDC21thisVars->currentFloor == 0)
#endif /* SEPARATED_CASCADED */
    ) {  /* First Identification */
    NFDC21thisVars->vendorID = (word)vendorId_p;  /* remember for next chips */
    NFDC21thisVars->chipID = (word)chipId_p;
    NFDC21thisVars->pagesPerBlock = PAGES_PER_BLOCK;
    flash->maxEraseCycles = 1000000L;
    flash->flags       |= BIG_PAGE;
    flash->pageSize = 0x200;
    switch( (byte)vendorId_p ) {
      case 0xEC :                  /* Samsung */
     switch( (byte)chipId_p ) {
#ifdef BIG_PAGE_ENABLED
       case 0x64 :             /* 2 Mb */
       case 0xEA :
          flash->type    = KM29N16000_FLASH;
          flash->pageSize = 0x100;
          flash->chipSize     = 0x200000L;
          flash->flags       &= ~BIG_PAGE;
          break;
#endif /* BIG_PAGE_ENABLED */
       case 0xE3 :             /* 4 Mb */
       case 0xE5 :
          flash->type    = KM29N32000_FLASH;
          flash->chipSize     = 0x400000L;
          break;

       case 0xE6 :             /* 8 Mb */
          flash->type    = KM29V64000_FLASH;
          flash->chipSize     = 0x800000L;
          break;

       case 0x73 :             /* 16 Mb  */
          flash->type    = KM29V128000_FLASH;
          flash->chipSize     = 0x1000000L;
          NFDC21thisVars->pagesPerBlock *= 2;
          break;

       case 0x75 :             /* 32 Mb */
          flash->type    = KM29V256000_FLASH;
          flash->chipSize     = 0x2000000L;
          NFDC21thisVars->pagesPerBlock *= 2;
          break;

       case 0x76 :             /* 64 Mb */
          flash->type    = KM29V512000_FLASH;
          flash->chipSize     = 0x4000000L;
          flash->flags       |= BIG_ADDR;
          NFDC21thisVars->pagesPerBlock *= 2;
          break;

       default :                    /* Undefined Flash */
          return(FALSE);
     }
     break;

      case 0x98 :                  /* Toshiba */
     switch( chipId_p ) {
#ifdef BIG_PAGE_ENABLED
       case 0x64 :             /* 2 Mb */
       case 0xEA :
          flash->type    = TC5816_FLASH;
          flash->pageSize = 0x100;
          flash->chipSize     = 0x200000L;
          flash->flags       &= ~BIG_PAGE;
          break;
#endif /* BIG_PAGE_ENABLED */
       case 0x6B :             /* 4 Mb */
       case 0xE5 :
          flash->type    = TC5832_FLASH;
          flash->chipSize     = 0x400000L;
          break;

       case 0xE6 :             /* 8 Mb */
          flash->type    = TC5864_FLASH;
          flash->chipSize     = 0x800000L;
          break;

       case 0x73 :             /* 16 Mb */
          flash->type    = TC58128_FLASH;
          flash->chipSize     = 0x1000000L;
          NFDC21thisVars->pagesPerBlock *= 2;
          break;

       case 0x75 :             /* 32 Mb */
          flash->type    = TC58256_FLASH;
          flash->chipSize     = 0x2000000L;
          NFDC21thisVars->pagesPerBlock *= 2;
          break;

       case 0x76 :             /* 64 Mb */
          flash->type    = TC58512_FLASH;
          flash->chipSize     = 0x4000000L;
          flash->flags       |= BIG_ADDR;
          NFDC21thisVars->pagesPerBlock *= 2;
          break;

       case 0x79:             /* 128 Mb */
          flash->type    = TC581024_FLASH;
          flash->chipSize     = 0x8000000L;
          flash->flags       |= BIG_ADDR;
          NFDC21thisVars->pagesPerBlock *= 2;
          break;

       default :                    /* Undefined Flash */
          return( FALSE );
     }
     flash->flags |= FULL_PAGE;    /* no partial page programming */
     break;

      default :                         /* Undefined Flash */
     return( FALSE );
    }
    return( TRUE );
  }
  else                                  /* dev != 0 */
    if( (vendorId_p == NFDC21thisVars->vendorID) && (chipId_p == NFDC21thisVars->chipID) )
      return( TRUE );

  return( FALSE );
}

/*----------------------------------------------------------------------*/
/*                        r e a d F l a s h I D                         */
/*                                                                      */
/* Read vendor and chip IDs, count flash devices. Initialize relevant   */
/* fields in data structures.                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*      dev             : dev chips were accessed before this one.      */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if this media is supported, FALSE otherwise.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static int  readFlashID ( FLFlash * flash, int dev )
{
  byte vendorId_p, chipId_p;
  register int i;
  volatile Reg8bitType junk = 0;

  command (flash, READ_ID);

  writeSignals (flash, FLASH_IO | ALE | CE | WP);
#ifdef SLOW_IO_FLAG
  flWrite8bitReg(flash,NslowIO,(Reg8bitType)0);
#endif
  flWrite8bitReg(flash,NFDC21thisIO,(Reg8bitType)0);
  if( NFDC21thisVars->flags & MDOC_ASIC )
    flWrite8bitReg(flash,NwritePipeTerm,(Reg8bitType)0);
  writeSignals (flash, FLASH_IO | CE | WP);

        /* read vendor ID */

  flDelayMsecs( 10 );                         /* 10 microsec delay */
  for( i = 0;( i < 2 ); i++ )   /* perform 2 reads from NOP reg for delay */
    junk += flRead8bitReg(flash,NNOPreg);
  if( NFDC21thisVars->flags & MDOC_ASIC ) {
    junk += flRead8bitReg(flash,NreadPipeInit); /* load first data into pipeline */
    vendorId_p = flRead8bitReg(flash,NreadLastData); /* finally read vendor ID */
  }
  else {
    junk += flRead8bitReg(flash,NslowIO); /* read CDSN_slow_IO ignoring the data */
    vendorId_p = flRead8bitReg(flash,NFDC21thisIO); /* finally read vendor ID */
  }

        /* read chip ID */

  flDelayMsecs( 10 );                         /* 10 microsec delay */
  for( i = 0;( i < 2 ); i++ )   /* perform 2 reads from NOP reg for delay */
    junk += flRead8bitReg(flash,NNOPreg);
  if( NFDC21thisVars->flags & MDOC_ASIC ) {
    junk += flRead8bitReg(flash,NreadPipeInit); /* load first data into pipeline */
    chipId_p = flRead8bitReg(flash,NreadLastData); /* finally read chip ID */
  }
  else {
    junk += flRead8bitReg(flash,NslowIO); /* read CDSN_slow_IO ignoring the data */
    chipId_p = flRead8bitReg(flash,NFDC21thisIO); /* finally read chip ID */
  }

  if ( isKnownMedia(flash, vendorId_p, chipId_p, dev) != TRUE )    /* no chip or diff. */
    return( FALSE );                                              /* type of flash    */

  flash->noOfChips++;

  writeSignals (flash, FLASH_IO);

        /* set flash parameters */
   if((dev == 0)
#ifndef SEPARATED_CASCADED
    && (NFDC21thisVars->currentFloor == 0)
#endif /* SEPARATED_CASCADED */
     )
  {
    NFDC21thisVars->pageAreaSize   = 0x100;

#ifdef BIG_PAGE_ENABLED
    if ( !(flash->flags & BIG_PAGE) )
      NFDC21thisVars->tailSize = EXTRA_LEN;      /* = 8 */
    else
#endif /* BIG_PAGE_ENABLED */
      NFDC21thisVars->tailSize = SECTOR_EXTRA_LEN;  /* = 16 */

    NFDC21thisVars->pageMask   = (word)(flash->pageSize  - 1);
    flash->erasableBlockSize   = NFDC21thisVars->pagesPerBlock * flash->pageSize;
    NFDC21thisVars->noOfBlocks = (word)( flash->chipSize / flash->erasableBlockSize );
    NFDC21thisVars->if_cfg     = 8;
  }

  return( TRUE );
}

/*----------------------------------------------------------------------*/
/*                        d o c 2 I d e n t i f y                       */
/*                                                                      */
/* Identify flash. This routine will be registered as the               */
/* identification routine for this MTD.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash             : Pointer identifying drive                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, flUnknownMedia failed.          */
/*                                                                      */
/*----------------------------------------------------------------------*/
#ifndef MTD_STANDALONE
static
#endif
FLStatus doc2000Identify(FLFlash * flash)
{
  dword  address = 0L;
  int maxDevs, dev;
  volatile Reg8bitType toggle1;
  volatile Reg8bitType toggle2;
  byte     floorCnt = 0;
  byte     floor = 0;

#ifdef NT5PORT
  byte     socketNo = (byte)flSocketNoOf(flash->socket);
#else
  byte     socketNo = flSocketNoOf(flash->socket);
#endif NT5PORT


  DEBUG_PRINT(("Debug: entering NFDC 2148 identification routine.\r\n"));

  flash->mtdVars = &docMtdVars[socketNo];

#ifndef FL_NO_USE_FUNC
  /* Initialize socket memory access routine */
  if(setBusTypeOfFlash(flash, flBusConfig[socketNo] |
                       FL_8BIT_DOC_ACCESS | FL_8BIT_FLASH_ACCESS))
     return flUnknownMedia;
#endif /* FL_NO_USE_FUNC */


#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT))
  /* Get pointer to read back buffer */
  NFDC21thisVars->readBackBuffer = flReadBackBufferOf(socketNo);
#endif /* VERIFY_WRITE || VERIFY_ERASE || MTD_RECONSTRUCT_BBT */

#ifndef MTD_STANDALONE
  /* get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  NFDC21thisVars->buffer = flBufferOf(socketNo);

  flSetWindowBusWidth(flash->socket, 16);/* use 8-bits */
  flSetWindowSpeed(flash->socket, 250);  /* 250 nsec. */
#else
#ifdef MTD_READ_BBT
  NFDC21thisVars->buffer = &globalMTDBuffer;
#endif /* MTD_READ_BBT */
#endif /* MTD_STANDALONE */

  /* assume flash parameters for KM29N16000 */

  NFDC21thisVars->floorSize = 1L;
#ifdef SEPARATED_CASCADED
/*  NFDC21thisVars->currentFloor = flSocketNoOf(flash->socket);*/
#else
  flash->noOfFloors = MAX_FLOORS;
  NFDC21thisVars->currentFloor = MAX_FLOORS;
#endif /* SEPARATED_CASCADED */
  flash->noOfChips = 0;
  flash->chipSize = 0x200000L;     /* Assume something ... */
  flash->interleaving = 1;       /* unimportant for now  */

  /* detect card - identify bit toggles on consequitive reads */

  NFDC21thisWin = (NDOC2window)flMap(flash->socket, 0);
  flash->win    = NFDC21thisWin;
  if (NFDC21thisWin == NULL)
     return flUnknownMedia;

  setASICmode (flash, ASIC_RESET_MODE);
  setASICmode (flash, ASIC_NORMAL_MODE);

  switch (flRead8bitReg(flash,NchipId))
  {
     case CHIP_ID_MDOC:
        /* Mdoc and alon asics have the same ID only on
           the forth read distigushes them */
        for(dev=0;dev<3;dev++)
          toggle1 = flRead8bitReg(flash,NchipId);
        if (toggle1 != CHIP_ID_MDOC)
        {
           flash->mediaType = DOC2000TSOP_TYPE;
        }
        else
        {
           flash->mediaType = MDOC_TYPE;
        }
        NFDC21thisVars->flags |= MDOC_ASIC;
        NFDC21thisVars->win_io = NIPLpart2;
        break;

     case CHIP_ID_DOC: /* Doc2000 */
        NFDC21thisVars->flags &= ~MDOC_ASIC;
        NFDC21thisVars->win_io = Nio;
        flash->mediaType = DOC_TYPE;
        break;

    default:
       DEBUG_PRINT(("Debug: failed to identify NFDC 2148.\r\n"));
       return( flUnknownMedia );
  }
  mapWin (flash, &address);

  if( NFDC21thisVars->flags & MDOC_ASIC ) {
    toggle1 = flRead8bitReg(flash,NECCconfig);
    toggle2 = toggle1 ^ flRead8bitReg(flash,NECCconfig);
  }
  else {
    toggle1 = flRead8bitReg(flash,NECCstatus);
    toggle2 = toggle1 ^ flRead8bitReg(flash,NECCstatus);
  }
  if ( (toggle2 & TOGGLE) == 0 ) {
    DEBUG_PRINT(("Debug: failed to identify NFDC 2148.\r\n"));
    return( flUnknownMedia );
  }

       /* reset all flash devices */
  maxDevs = MAX_FLASH_DEVICES_DOC;

#ifndef SEPARATED_CASCADED
  for ( NFDC21thisVars->currentFloor = 0 ;
    NFDC21thisVars->currentFloor < MAX_FLOORS ;
    NFDC21thisVars->currentFloor++ )
  {
  /* select floor */
    flWrite8bitReg(flash,NASICselect,(Reg8bitType)NFDC21thisVars->currentFloor);
#endif /* SEPARATED_CASCADED  */
    for ( dev = 0 ; dev < maxDevs ; dev++ ) {
      selectChip(flash, (Reg8bitType)dev );
      command(flash, RESET_FLASH);
    }
#ifndef SEPARATED_CASCADED
  }

  NFDC21thisVars->currentFloor = (byte)0;
  /* back to ground floor */
  flWrite8bitReg(flash,NASICselect,(Reg8bitType)NFDC21thisVars->currentFloor);
#endif /* SEPARATED_CASCADED  */
  writeSignals (flash, FLASH_IO | WP);

       /* identify and count flash chips, figure out flash parameters */
#ifndef SEPARATED_CASCADED
  for( floor = 0; floor < MAX_FLOORS;  floor++ )
#endif /* SEPARATED_CASCADED  */
  for ( dev = 0; dev < maxDevs;  dev++ )
  {
     dword  addr = address;

     mapWin(flash, &addr);

     if ( readFlashID(flash, dev) == TRUE ) /* identified OK */
     {
        floorCnt = (byte)(floor + 1);
#ifndef SEPARATED_CASCADED
    if (floor == 0)
#endif /* SEPARATED_CASCADED  */
      NFDC21thisVars->floorSize += flash->chipSize * flash->interleaving;
      address += flash->chipSize * flash->interleaving;
     }
     else
     {
#ifndef SEPARATED_CASCADED
        if (floor != 0)
        {
       dev = maxDevs;
       floor = MAX_FLOORS;
    }
        else
#endif /* SEPARATED_CASCADED  */
        {
       maxDevs = dev;
       NFDC21thisVars->floorSize = maxDevs * flash->chipSize * flash->interleaving;
    }
     }
  }
#ifndef SEPARATED_CASCADED
  NFDC21thisVars->currentFloor = (byte)0;
#endif /* SEPARATED_CASCADED  */
  flWrite8bitReg(flash,NASICselect,(Reg8bitType)NFDC21thisVars->currentFloor); /* back to ground floor */

  if (flash->noOfChips == 0) {
    DEBUG_PRINT(("Debug: failed to identify NFDC 2148.\r\n"));
    return( flUnknownMedia );
  }

  address = 0L;
  mapWin (flash, &address);

  flash->noOfFloors = floorCnt;

  eccOFF(flash);

  /* Register our flash handlers */
#ifndef FL_READ_ONLY
  flash->write = doc2Write;
  flash->erase = doc2Erase;
#else
  flash->erase = NULL;
  flash->write = NULL;
#endif
  flash->read = doc2Read;
#ifndef MTD_STANDALONE
  flash->map = doc2Map;
#else
  flash->map = NULL;
#endif /* MTD_STANDALONE */

  /* doc2000 tsop uses INFTL instead of NFTL , does not use
   * the last block and has a readBBT routine
   */

  if (flash->mediaType == DOC2000TSOP_TYPE)
  {
#ifdef MTD_READ_BBT
     flash->readBBT         = readBBT;
#endif /* MTD_READ_BBT */
#ifndef NO_IPL_CODE
     flash->download        = forceDownLoad;
#ifndef FL_READ_ONLY
     flash->writeIPL        = writeIPL;
#endif /* FL_READ_ONLY */
#endif /* NO_IPL_CODE */
     flash->flags          |= INFTL_ENABLED;
  }
  else
  {
     flash->flags  |= NFTL_ENABLED;
  }
#ifndef SEPARATED_CASCADED
  if (flash->mediaType == MDOC_TYPE)
      flash->flags |= EXTERNAL_EPROM; /* Supports external eprom */
#endif /* SEPARATED_CASCADED */

  DEBUG_PRINT(("Debug: identified NFDC 2148.\r\n"));
  return( flOK );
}

#ifndef MTD_STANDALONE

/*----------------------------------------------------------------------*/
/*                  f l R e g i s t e r D O C S O C                     */
/*                                                                      */
/* Installs routines for DiskOnChip 2000 family.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      lowAddress,                                                     */
/*      highAddress     : host memory range to search for DiskOnChip    */
/*                        2000 memory window                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failure                     */
/*----------------------------------------------------------------------*/
#ifndef NT5PORT
FLStatus flRegisterDOCSOC(dword lowAddress, dword highAddress)
{
  int serialNo;

  if( noOfSockets >= SOCKETS )
    return flTooManyComponents;

  for(serialNo=0;( noOfSockets < SOCKETS );serialNo++,noOfSockets++)
  {
     FLSocket * socket = flSocketOf(noOfSockets);

     socket->volNo = noOfSockets;

     docSocketInit(socket);

     /* call DiskOnChip MTD's routine to search for memory window */

     flSetWindowSize(socket, 2);    /* 4 KBytes */

     socket->window.baseAddress = flDocWindowBaseAddress
          ((byte)socket->volNo, lowAddress, highAddress, &lowAddress);

     if (socket->window.baseAddress == 0)    /* DiskOnChip not detected */
       break;
  }
  if( serialNo == 0 )
    return flAdapterNotFound;

  return flOK;
}
#endif /*NT5PORT*/
#else /* MTD_STANDALONE */

/*----------------------------------------------------------------------*/
/*            d o c 2 0 0 0 S e a r c h F o r W i n d o w               */
/*                                                                      */
/* Search for the DiskOnChip ASIC in a given memory range and           */
/* initialize the given socket record.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      :   Record used to store the sockets parameters     */
/*      lowAddress  :   host memory range to search for DiskOnChip 2000 */
/*      highAddress :   memory window                                   */
/*                                                                      */
/* Output:  initialize the following fields in the FLFlash record:      */
/*                                                                      */
/*      base  -  Pointer to DiskOnChip window                           */
/*      size  -  DiskOnChip window size usualy 8K                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus    : 0 on success, flDriveNotAvailable on failure.     */
/*                                                                      */
/* NOTE: This routine is not used by OSAK. It is used by standalone     */
/*       applications using the MTD (BDK for example) as a replacement  */
/*       for the OSAK DOCSOC.C file.                                    */
/*       The FLSocket record used by this function is not the one used  */
/*       by OSAK defined in flsocket.h but a replacement record defined */
/*       in flflash.h.                                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus doc2000SearchForWindow(FLSocket * socket,
             dword lowAddress,
             dword highAddress)
{
    dword baseAddress;   /* Physical base as a 4K page */

    socket->size = 2 * 0x1000L;         /* 4 KBytes */
    baseAddress = (dword) flDocWindowBaseAddress(0, lowAddress, highAddress, &lowAddress);
    socket->base = physicalToPointer(baseAddress << 12, socket->size,0);
    if (baseAddress)    /* DiskOnChip detected */
      return flOK;
    else                        /* DiskOnChip not detected */
      return flDriveNotAvailable;
}

/*----------------------------------------------------------------------*/
/*                d o c 2 0 0 0 F r e e W i n d o w                     */
/*                                                                      */
/* Free any resources used for the DiskOnChip window                    */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      :   Record used to store the sockets parameters     */
/*                                                                      */
/* Returns: None                                                        */
/*                                                                      */
/* NOTE: This routine is used only by virtual memory systems in order   */
/*       to unmap the DiskOnChip window.                                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void doc2000FreeWindow(FLSocket * socket)
{
   freePointer(socket->base,DOC_WIN);
}
#endif /* MTD_STANDALONE */

/*----------------------------------------------------------------------*/
/*                      f l R e g i s t e r D O C 2 0 0 0               */
/*                                                                      */
/* Registers this MTD for use                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*----------------------------------------------------------------------*/

FLStatus flRegisterDOC2000(void)
{
  if (noOfMTDs >= MTDS)
    return( flTooManyComponents );

#ifdef MTD_STANDALONE
  socketTable[noOfMTDs] = doc2000SearchForWindow;
  freeTable[noOfMTDs]   = doc2000FreeWindow;
#endif /* MTD_STANDALONE */

  mtdTable[noOfMTDs++]  = doc2000Identify;

  return( flOK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\doc2exb.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOC2EXB.H_V  $
 * 
 *    Rev 1.11   Apr 15 2002 07:35:22   oris
 * Make sure all relevant structures will allow easy little endian conversion.
 * 
 *    Rev 1.10   Feb 19 2002 20:58:38   oris
 * Moved include directive and routine  prototypes to C file.
 * 
 *    Rev 1.9   Jan 21 2002 20:44:12   oris
 * Added DiskOnChip Millennium Plus 16MB firmware family definition.
 * 
 *    Rev 1.8   Jan 17 2002 22:58:42   oris
 * Added INFTL_NEAR_HEAP_SIZE, FIRMWARE_NO_MASK, STRONG_ARM_IPL  definitions.
 * Removed different firmware STACK sizes.
 * Added parameter to getExbInfo() (firmware add to).
 * Added tffsFarHeapSize to exbStruct record.
 * 
 *    Rev 1.7   Jul 13 2001 01:01:06   oris
 * Added constant stack space for each of the different DiskOnChip.
 * 
 *    Rev 1.6   Jun 17 2001 08:17:24   oris
 * Changed placeExbByBuffer exbflags argument to word instead of byte to  support /empty flag.
 * Added LEAVE_EMPTY and EXB_IN_ROM flags.
 * 
 *    Rev 1.5   Apr 09 2001 15:05:14   oris
 * End with an empty line.
 * 
 *    Rev 1.4   Apr 03 2001 14:39:54   oris
 * Add iplMod512 and splMod512 fields to the exbStruct record.
 *
 *    Rev 1.3   Apr 02 2001 00:56:48   oris
 * Added EBDA_SUPPORT flag.
 * Bug fix of NO_PNP_HEADER flag.
 * Changed ifdef of h file from doc2hdrs_h to doc2exb_h.
 *
 *    Rev 1.2   Apr 01 2001 07:50:00   oris
 * Updated copywrite notice.
 * Changed LEmin to dword
 * Added DOC2300_FAMILY_FIRMWARE firmware types.
 *
 *    Rev 1.1   Feb 08 2001 10:32:06   oris
 * Seperated file signature into 2 fields signature and TrueFFS vesion to make it eligned
 *
 *    Rev 1.0   Feb 02 2001 13:10:58   oris
 * Initial revision.
 *
 */


/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Project : TrueFFS source code                                              *
*                                                                            *
* Name : doc2exb.h                                                           *
*                                                                            *
* Description : M-Systems EXB firmware files and media definitions and       *
*               data structures                                              *
*                                                                            *
*****************************************************************************/

#ifndef DOC2EXB_H
#define DOC2EXB_H

#include "docbdk.h"

#ifdef BDK_ACCESS
extern BDKVol*  bdkVol;         /* pointer to current binary partition */
#endif

/**********************************/
/* EXB file structure definitions */
/**********************************/

/* EXB Flag definitions */
#define INSTALL_FIRST     1
#define EXB_IN_ROM        2
#define QUIET             4
#define INT15_DISABLE     8
#define FLOPPY            0x10
#define SIS5598           0x20
#define EBDA_SUPPORT      0x40
#define NO_PNP_HEADER     0x80
#define LEAVE_EMPTY       0x100 
#define FIRMWARE_NO_MASK  0xd00 /* Up to 8 firmwares */
#define FIRMWARE_NO_SHIFT 9

/* Firmware types */
#define DOC2000_FAMILY_FIRMWARE      1
#define DOCPLUS_FAMILY_FIRMWARE      2
#define DOC2300_FAMILY_FIRMWARE      3
#define DOCPLUS_INT1_FAMILY_FIRMWARE 4

/* Firmware stack constant */
#ifdef VERIFY_WRITE
#define INFTL_NEAR_HEAP_SIZE sizeof(FLBuffer)+(SECTOR_SIZE<<1)+READ_BACK_BUFFER_SIZE
#else
#define INFTL_NEAR_HEAP_SIZE sizeof(FLBuffer)+(SECTOR_SIZE<<1)
#endif /* VERIFY_WRITE */
#define DEFAULT_DOC_STACK 2*1024

/*General definitions */
#define MAX_CODE_MODULES        6
#define ANAND_MARK_ADDRESS      0x406
#define ANAND_MARK_SIZE         2
#define EXB_SIGN_OFFSET         8
#define INVALID_MODULE_NO       0xff
#define SIGN_SPL                ""    /* EXB binary signature */
#define SIGN_MSYS               "OSAK"    /* EXB file signature   */
#define SIGN_MSYS_SIZE          4
/* File specific record specifing data for all firmwares in the file */

typedef struct {
  byte  mSysSign[SIGN_MSYS_SIZE];       /* identification signature */
  byte  osakVer[SIGN_MSYS_SIZE];        /* identification signature */
  LEmin fileSize;                       /* Total file size */
  LEmin noOfFirmwares;                  /* Number of firmware supported by this file */
} ExbGlobalHeader;
/*-------------------------------------*/

/* File specific record specifing data for a specific firmwares in the file */

typedef struct {
  LEmin type;                           /* Firmware type (must fit the H/W)  */
  LEmin startOffset;                    /* Firmware start offset in the file */
  LEmin endOffset;                      /* Firmware end offset in the file   */
  LEmin splStartOffset;                 /* SPL start offset in the file      */
  LEmin splEndOffset;                   /* SPL end offset in the file        */
} FirmwareHeader;
/*-------------------------------------*/

/* data structure representing BIOS extention header */

typedef struct{
  unsigned char  signature[2]; /* BIOS extention signature (0xAA55) */
  unsigned char  lenMod512; /* length in unsigned chars modulo 512 */
} BIOSHeader;
/*-------------------------------------*/

/* data structure representing IPL header */

typedef struct{
  BIOSHeader     biosHdr;
  byte           jmpOpcode[3];     /* jmp start_of_code                      */
  byte           dummy;            /* dummy byte                             */
  byte           msysStr[17];      /* ORG  7h ManStr DB '(C)M-Systems1998',0 */
  word           pciHeader;        /* ORG 18h   ; PCI header                 */
  word           pnpHeader;        /* ORG 1Ah   ; P&P header                 */
  byte           dummy0[4];        /* Actual address must be shifted by 4 '0'*/
  LEushort       windowBase;       /* ORG 20h   ; explicit DOC window base   */
  Unaligned      spl_offset;       /* DFORMAT !!!                            */
  Unaligned      spl_size;         /* spl actual size                        */
  byte           spl_chksum;       /* 55                                     */
} IplHeader;
/*-------------------------------------*/

/* data structure representing SPL header */

typedef struct{
  unsigned char  jmpOpcode[2];
  BIOSHeader     biosHdr;
      /* Note: At run-time biosHdr.lenMod512 contains size of entire DOC 2000
      boot area modulo 512 as set by DFORMAT  */
  Unaligned      runtimeID;        /* filled in by DFORMAT  */
  Unaligned      tffsHeapSize;     /* filled in by DFORMAT  */
  unsigned char  chksumFix;        /* changed by DFORMAT */
  unsigned char  version;
  unsigned char  subversion;
  char           copyright[29];    /* "SPL_DiskOnChip (c) M-Systems", 0 */
  Unaligned      windowBase;       /* filled in by DFORMAT */
  Unaligned4     exbOffset;        /* filled in by DFORMAT */
} SplHeader;
/*------------------------------------- */

/* data structure representing TFFS header */

typedef struct{
  BIOSHeader     biosHdr;
  unsigned char  jmpOpcode[3];
  char           tffsId[4];         /* "TFFS" */
  unsigned char  exbFlags;          /* filled in by writeExbDriverImage() */
  Unaligned      heapLen;           /* not used for now */
  Unaligned      windowBase;        /* passed by SPL and saved here */
  unsigned char  chksumFix;         /* changed by writeExbDriverImage() */
  Unaligned      runtimeID;         /* passed by SPL and saved here */
  unsigned char  firstDiskNumber;   /* filled in............  */
  unsigned char  lastDiskNumber;    /* ..........at run-time */
  Unaligned      versionNo;         /* filled in at run-time */
} TffsHeader;
/* ------------------------------------- */

/* data structure representing Socket Services  header */

typedef struct{
  BIOSHeader     biosHdr;
  unsigned char  jmpOpcode[3];
  char           tffsId[4];         /* "TFFS" */
  unsigned char  exbFlags;          /* filled in by writeExbDriverImage() */
  unsigned char  heapLen;           /* not used for now */
  Unaligned      windowBase;        /* filled in at run-time */
  unsigned char  chksumFix;         /* changed by writeExbDriverImage() */
} SSHeader;
/* ------------------------------------- */

/* Work space for writting the exb file */

typedef struct{
  word  exbFlags;            /* For the complete list see doc2hdrs.h     */
  word  iplMod512;           /* Size of the IPL module divided by 512    */
  word  splMod512;           /* Size of the SPL module divided by 512    */
  dword splMediaAddr;        /* Start of the SPL module media address    */
  dword ssMediaAddr;         /* Start of the SS module media address     */
  dword exbRealSize;         /* Actual binary area + bad blocks          */
  word  moduleLength;        /* Length of the modules in divided by 512  */
  dword tffsHeapSize;        /* TFFS needed heap size                    */
  word  tffsFarHeapSize;     /* TFFS needed far heap size                */
  word  bufferOffset;        /* Curret Offset inside the internal buffer */
  dword exbFileEnd;          /* Offset of the last Byte of the files     */
  dword exbFileOffset;       /* Current Offset inside the EXB file       */
  dword splStart;            /* First SPL byte offset                    */
  dword splEnd;              /* Last SPL byte offset                     */
  dword firmwareEnd;         /* End offset of the specific firmware      */
  dword firmwareStart;       /* Start offset of the specific firmware    */
  FLBuffer *buffer;          /* Internal 512 byte buffer                 */
} exbStruct;

#endif /* DOC2EXB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\docbdk.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCBDK.C_V  $
 * 
 *    Rev 1.32   Apr 15 2002 20:14:30   oris
 * Bug fix - No longer ignore the last binary block of high capacity (512MB and up) INFTL formatted device. This bug caused the placeExbByBuffer routine to fail.
 * Bug fix - Physical size of INFTL formatted binary partition was 1 unit smaller then the real size.
 * 
 *    Rev 1.31   Apr 15 2002 07:35:38   oris
 * Bug fix - bdkErase routine did not made sure not to erase OTP and DPS 
 *                units of floors > 0.
 * 
 *    Rev 1.30   Feb 19 2002 20:58:44   oris
 * Changed debug print.
 * Bug fix - binary partition physical length was not reported properly , due to bad casting.
 * 
 *    Rev 1.29   Jan 20 2002 11:09:42   oris
 * Added debug print. 
 * 
 *    Rev 1.28   Jan 17 2002 22:58:56   oris
 * Force calling bdkInit if not called.
 * Moved declaration of internal variables to mtdsa.c
 * Bug fix NO_INFTL_FAMILY_SUPPORT and NO_NFTL_FAMILY_SUPPORT where  changed to NO_INFTL_SUPPORT and NO_INFTL_SUPPORT to comply with header  file.
 * Prevent creating binary partition with signature 0xffff ffff
 * bdkInit uses tffsset instead of zeroing all the structure fields.
 * Bug fix - retrieveHeader routine used a word variable instead of dword.
 * freePointer call uses DOC_WIN_SIZE instead of DOC_WIN (part of new docsys ,mechanism).
 * BDK now take socket and flash records using flSocketOf() and flFlashOf(). The records themselves are defined in mtdsa.c
 * Use PROTECTABLE definition instead of 1 in calls to protectionSet.
 * Added support for flVerifyWrite runtime variable for binary partitions
 * 
 *    Rev 1.27   Nov 16 2001 00:19:48   oris
 * Bug fix - TrueFFS with verify write calling erase and then update block without erase flag, will fail.
 * 
 *    Rev 1.26   Nov 08 2001 10:45:04   oris
 * Removed warnings.
 * Bug fix - DiskOnChip with different number of blocks in the last floor.
 * 
 *    Rev 1.25   Oct 18 2001 22:17:02   oris
 * Bug fix - Missing support for binary partiiton on M+ that spans over a single floor.
 * 
 *    Rev 1.24   Oct 10 2001 19:48:14   oris
 * Bug fix - missing return statment caused the bdkGetProtectionType routine to call bdkSetProtectionType and therfore return a failing status.
 * 
 *    Rev 1.23   Sep 25 2001 17:37:00   oris
 * Bug fix - bdkIdentifyProtection routine did not update after change protection call.
 * 
 *    Rev 1.22   Sep 15 2001 23:45:04   oris
 * Bug fix - Changeable protection type was reported by the MTD even if user did not ask for it.
 * Bug fix - Big endian casting caused wrong protection type to be returned.
 * 
 *    Rev 1.21   Jul 13 2001 01:00:48   oris
 * Bug fix - when skipping bad blocks we no longer mark the bad block with the signature.
 * Send default key before any protection change operation.
 * 
 *    Rev 1.20   May 30 2001 21:10:22   oris
 * Bug fix - meida header was converted from little indien twice therefore suppling wrong data.
 * 
 *    Rev 1.19   May 17 2001 21:17:50   oris
 * Improoved documentation of error codes.
 * 
 *    Rev 1.18   May 17 2001 16:51:08   oris
 * Removed warnings.
 * 
 *    Rev 1.17   May 16 2001 21:17:04   oris
 * Bug fix - One of the "ifndef" statement of NO_DOCPLUS_FAMILY_SUPPORT was coded as "ifdef".
 * Bug fix - bdkEraseBootArea routine.
 * Changed bdkCopyBootAreaFile and bdkUpdateBootAreaFile interface. The signature is not an unsigned char pointer and not signed.
 * Removed warnings.
 * Added arguments check in bdkSetProtectionType routine and forced the presence of PROTECTABLE flag.
 * Compilation problems for MTD_STANDALONE were fixed.
 * Changed DATA definition to FL_DATA.
 * 
 *    Rev 1.16   May 09 2001 00:32:02   oris
 * Removed the DOC2000_FAMILY and DOCPLUS_FAMILY defintion and replaced it with NO_DOC2000_FAMILY_SUPPORT, NO_DOCPLUS_FAMILY_SUPPORT, NO_NFTL_SUPPORT and NO_INFTL_SUPPORT.
 * Bug fix - bdkEraseBootArea did not erase more then a single unit.
 * Bug fix - protection routine did not support floors properly.
 * Added OTP and unique ID routines for Millennium Plus .
 *
 *    Rev 1.15   May 06 2001 22:41:42   oris
 * Removed warnings.
 *
 *    Rev 1.14   May 02 2001 06:43:56   oris
 * Bug fix - bdkRetrieveHeader routine with cascaded floors.
 *
 *    Rev 1.13   May 01 2001 14:23:28   oris
 * Removed warrnings.
 *
 *    Rev 1.12   Apr 30 2001 17:59:04   oris
 * Removed misleading debug massage when calling bdkCheckSignOffset.
 * Reviced bdkRetrieveHeader routine not to use the MTD readBBT routine.
 * Added initialization of the erasbleBlockSizeBits variable in order to simplify multiplications.
 * Changed bdkSetBootPartitonNo, bdkGetProtectionType, bdkSetProtection prototypes.
 * Bug fix - bdkGetPartitionType routine. Missing case caused type to be 0 at all times.
 *
 *    Rev 1.11   Apr 16 2001 13:30:54   oris
 * Bug fix - bad comparison with bdk flag.
 * Bug fix - proection prevented read binary area since the dps were read protected.
 * Removed warrnings.
 *
 *    Rev 1.10   Apr 12 2001 06:49:50   oris
 * Added forceDownload routine
 * Changed checkWinForDoc routine to be under ifndef MTD_STANDALONE.
 *
 *    Rev 1.9   Apr 10 2001 16:40:56   oris
 * bug fixed for big_endien in bdkmount routine.
 *
 *    Rev 1.8   Apr 09 2001 14:59:24   oris
 * Bug fix in retreave header routine - header was searched on the first floor only.
 * End with an empty line.
 *
 *    Rev 1.7   Apr 01 2001 07:50:18   oris
 * Updated copywrite notice.
 * Removed nested comments.
 * Removed static type from bdkVol for placinf exb file and standlone applications.
 * Changed readBBT function call since prototype was changed.
 * Bug fix in bdkretreave header routine - added casting to bbt pointer and iUnit.
 * Fix for Big endien compilation problems.
 * Remove unneeded variables.
 * Bad spelling of "..changable..".
 * Changed h\w to h/w.
 * Changed 2400 family to doc plus family.
 * Adde casting in calls to protection routine.
 *
 *    Rev 1.6   Feb 20 2001 15:55:28   oris
 * Bug fix - global partiton and socket variables were redaclared in bdcall routine.
 *
 *    Rev 1.5   Feb 14 2001 02:36:44   oris
 * Changed FLFlash and FLScoket records (used for the BDK) from static to global for the putImage utility.
 *
 *    Rev 1.4   Feb 13 2001 01:41:50   oris
 * bdkPartitionInfo returns the number of binary partitions in flags field of the bdkStruct and not irFlags
 *
 *    Rev 1.3   Feb 07 2001 18:15:24   oris
 * Changed else in bdkRetreaveHeader routine otherwise would not compiling bdk with a single doc family.
 * Changed the socketTable and mtdTable so BDK package can compile.
 *
 *    Rev 1.2   Feb 05 2001 20:46:30   oris
 * Read the changable protection flag in protectionChangeInit routine
 * from the media header and not from the MTD.
 *
 *    Rev 1.1   Feb 05 2001 20:10:56   oris
 * Removed // comments and added missing ;
 *
 *    Rev 1.0   Feb 02 2001 13:19:44   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/************************************************/
/* B i n a r y   D e v e l o p m e n t   K i t  */
/* -------------------------------------------  */
/************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : docbdk.c                                                            *
*                                                                            *
* Description : This file contains the binary partition handling routines.   *
*                                                                            *
* Note : The file has 2 interfaces each under its own compilation flag:      *
*                                                                            *
*        BDK package - Standalone package that exports routines for binary   *
*                      partitions handling(MTD_STANDALONE compilation flag). *
*        OSAK module - Separated module of the OSAK package that exports a   *
*                      common entry point to the same routines. (BDK_ACCESS  *
*                      compilation flag).                                    *
*                                                                            *
* Warning : Do not use this file with the BDK_ACCESS compilation flag unless *
*           you own the full OSAK package.                                   *
*****************************************************************************/

#include "docbdk.h"
#ifndef MTD_STANDALONE
#include "doc2exb.h"
#include "blockdev.h"
#endif /* MTD_STANDALONE */

#if (defined(MTD_STANDALONE) && defined(ACCESS_BDK_IMAGE)) || defined(BDK_ACCESS)

/*********************** Global Variables Start******************************/

/* conversion table from OSAK handles to binary partition handles */
static byte handleTable[SOCKETS][MAX_BINARY_PARTITIONS_PER_DRIVE];
static byte noOfPartitions=0;           /* number of mounted binary partition  */
static byte globalPartitionNo=0;        /* The current partition number        */
static byte globalSocketNo = 0;
BDKVol  bdkVols[BINARY_PARTITIONS]; /* binary partitions records */
BDKVol* bdkVol=bdkVols;          /* pointer to current binary partition */
#ifdef MTD_STANDALONE
FLBoolean             globalInitStatus = FALSE;
#endif /* MTD_STANDALONE */
/*********************** Internal Function Protoype *************************/

static   FLStatus    bdkMount            (void);
static   FLStatus    getBootAreaInfo     (word startUnit , byte FAR2* signature);
static   CardAddress getPhysAddressOfUnit(word startUnit);

/*--------------------------------------------------------------------------*
 *                             b d k I n i t
 *
 *  Initialize all binary partition global variables
 *
 *  Note : This function is called automaticly by bdkFindDiskOnChip.
 *
 *  Parameters: None
 *
 *  global variable output:
 *               bdkVols    - initialized array of binary partitions records
 *               bdkVol     - current binary partition record set to the first
 *
 *  Return:     Nothing
 *
 * Routine for both OSAK and the BDK stand alone package.
 *--------------------------------------------------------------------------*/

void bdkInit(void)
{
   byte index;

   /* initialize binary partitions records with defaultive values */

   tffsset(bdkVols,0,sizeof(bdkVols));
   tffsset(handleTable,BDK_INVALID_VOLUME_HANDLE,sizeof(handleTable));

   for (bdkVol=bdkVols,index=0;index<BINARY_PARTITIONS;bdkVol++,index++)
   {
     bdkVol->bdkGlobalStatus       = BDK_S_INIT;
     bdkVol->bdkSignOffset         = BDK_SIGN_OFFSET;
#ifdef EDC_MODE
     bdkVol->bdkEDC                = EDC;
#endif /* EDC_MODE */
#ifdef UPDATE_BDK_IMAGE
     bdkVol->updateImageFlag       = BDK_COMPLETE_IMAGE_UPDATE;
#endif /* UPDATE_BDK_IMAGE */
   }

   /* Initialize binary handles conversion table with invalid values */
#ifdef MTD_STANDALONE
   noOfMTDs = 0;
   globalPartitionNo=0;
   globalSocketNo = 0;
   globalInitStatus = TRUE;
#endif /* MTD_STANDALONE */
   noOfPartitions=0;
   bdkVol=bdkVols;
}

/*--------------------------------------------------------------------------*
 *               g e t P h y s A d d r e s s O f U n i t
 *
 *  Return the physical address of a unit according to its number
 *  in the binary sub partition.
 *
 *  Note : The sub partition is assumed to be mounted (BDK_S_INFO_FOUND is on).
 *
 *  Parameters :
 *       startUnit : unit number in the binary sub partition.
 *
 *  global variable input:
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               signBuffer          - the sub partition signature
 *               bdkSignOffset       - current signature offset
 *               erasableBlockBits   - number of bits representing a unit
 *
 *  Return :
 *       Physical address of the unit in the BDK partition or 0 if failed
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

static CardAddress getPhysAddressOfUnit(word startUnit)
{
  word iBlock;
  byte signRead[BDK_SIGNATURE_NAME];
  FLFlash * flash=bdkVol->flash;
  FLStatus status;

  for(iBlock=bdkVol->startImageBlock;
      ((startUnit > 0) && (iBlock <= bdkVol->endImageBlock));iBlock++)
  {
     if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
     {
        iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
        if (iBlock > bdkVol->endImageBlock)
          break;
     }
     status = flash->read( flash , bdkVol->bdkSignOffset +
               ((CardAddress)iBlock << bdkVol->erasableBlockBits) ,
                signRead , BDK_SIGNATURE_NAME , EXTRA);
     if(status!=flOK)
     {
        DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
        return 0L;
     }

     if(tffscmp((void FAR1*)signRead,(void FAR1*)(bdkVol->signBuffer),BDK_SIGNATURE_NAME)==0)
        startUnit--;
  }
  return( (CardAddress)iBlock << bdkVol->erasableBlockBits );
}

/*--------------------------------------------------------------------------*
 *                    g e t B o o t A r e a I n f o
 *
 *  Mount the binary sub partitions by reading the signature area of each
 *  unit of the entire partition.
 *
 *  Note : Assume that the DiskOnChip was already found (bdkFoundDiskOnChip).
 *
 *  Parameters :
 *       startUnit : unit number in the binary sub partition.
 *       signature : signature of the binary sub partition.
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *           bdkGlobalStatus     - partition predsent status.
 *               bdkSavedStartUnit   - start unit of previous access
 *               bdkSavedSignOffset  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *               bdkDocWindow        - explicitly sets the windows address
 *
 *  global variable output :
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedStartUnit   - save start unit for next access
 *               bdkSavedSignOffset  - save current signature for next access
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *     flFeatureNotSupported - Not a DiskOnChip device.
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

static FLStatus getBootAreaInfo( word startUnit , byte FAR2* signature )
{
  FLFlash    *   flash;
  word           iBlock;
  word           numBlock;
#ifdef MTD_STANDALONE
  dword          temp;

  checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
  DEBUG_PRINT(("Debug: getBootAreaInfo() - DiskOnChip found.\r\n"));
#endif /* MTD_STANDALONE */

  /* set bdkVol pointer to the proper binary partition */

  checkStatus(bdkMount());
  DEBUG_PRINT(("Debug: getBootAreaInfo() - BDK mount succeed.\r\n"));
  /* Check if this sub-partition was already analized */

  if ((!(bdkVol->bdkGlobalStatus & BDK_S_INFO_FOUND))           ||
      (tffscmp((void FAR1 *)(bdkVol->signBuffer),
               (void FAR1 *)signature,BDK_SIGNATURE_NAME) != 0) ||
      (bdkVol->bdkSignOffset!=bdkVol->bdkSavedSignOffset)       ||
      (startUnit<bdkVol->bdkSavedStartUnit)                     ||
      (bdkVol->bdkSavedStartUnit + (bdkVol->realBootImageSize >>
       bdkVol->erasableBlockBits)<= startUnit))
  {

    /* The partition needs mounting */

     tffscpy((void FAR1 *)(bdkVol->signBuffer),(void FAR1 *)signature,
           BDK_SIGNATURE_NAME);
     bdkVol->bdkSavedSignOffset = bdkVol->bdkSignOffset;
     bdkVol->bdkSavedStartUnit  = startUnit;

     bdkVol->startImageBlock   = 0;
     bdkVol->bootImageSize     = 0L;
     bdkVol->realBootImageSize = 0L;

  /* Find the boundries and number of the units marked with the signature */

     DEBUG_PRINT(("Debug: searching for signtured blocks.\r\n"));

     flash = bdkVol->flash;

     numBlock = 0;
     

     for (numBlock = 0 , iBlock   = bdkVol->startPartitionBlock;
          iBlock<=bdkVol->endPartitionBlock;iBlock++)
     {
        if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
        {
           iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
           if (iBlock > bdkVol->endPartitionBlock)
             break;
        }
        /* check for unit signature */
        DEBUG_PRINT(("Debug: getBootAreaInfo() - Reading unit signature...\r\n"));
        checkStatus(flash->read(flash,bdkVol->bdkSignOffset +
                 ((CardAddress)iBlock << bdkVol->erasableBlockBits),
                 bdkVol->signBuffer,SIGNATURE_LEN,EXTRA));
	DEBUG_PRINT(("Debug: getBootAreaInfo() - Signature read done.\r\n"));

        if(tffscmp( (void FAR1 *)signature , (void FAR1 *)bdkVol->signBuffer,
              BDK_SIGNATURE_NAME ) == 0 )
        {
           if( numBlock == 0 )
              bdkVol->startImageBlock = iBlock;

           numBlock++;
           bdkVol->endImageBlock = iBlock;
           if(( bdkVol->realBootImageSize == 0L ) && (numBlock>startUnit) &&
             (tffscmp((void FAR1 *)&bdkVol->signBuffer[BDK_SIGNATURE_NAME],
                  (void FAR1 *)"FFFF", SIGNATURE_NUM) == 0 ))
           {
              bdkVol->realBootImageSize =
              ((dword)(numBlock - startUnit) << bdkVol->erasableBlockBits);
           }
        }
     }
     if (numBlock<=startUnit)
     {
	DEBUG_PRINT(("Debug: getBootAreaInfo() - No space in volume.\r\n"));
        return( flNoSpaceInVolume );
     }

     bdkVol->bootImageSize = (dword)numBlock << bdkVol->erasableBlockBits;
     if( bdkVol->realBootImageSize == 0L ) /* In case the image without FFFF */
     bdkVol->realBootImageSize =
        ((dword)(numBlock - startUnit) << bdkVol->erasableBlockBits);

     tffscpy((void FAR1 *)(bdkVol->signBuffer),(void FAR1 *)signature,
           BDK_SIGNATURE_NAME);

     bdkVol->bdkGlobalStatus |= BDK_S_INFO_FOUND;
   }

  return( flOK );
}

#ifndef NO_INFTL_SUPPORT
/*----------------------------------------------------------------------*/
/*                   b d k R e t r i e v e H e a d e r                  */
/*                                                                      */
/* Retreave media header by oring the headers of each floor             */
/*                                                                      */
/* Note:  The header of each floor is read to the first half of the     */
/* buffer and then ORed to the second half therfore constructing the    */
/* real header in the upper half. The data is copied to the first half  */
/* while cast back from little endian                                   */
/*                                                                      */
/* Parameters:                                                          */
/*    headerBuffer - buffer returning the retieved header.              */
/*                                                                      */
/* Returns:                                                             */
/*        flOK on success any other value on error                      */
/*----------------------------------------------------------------------*/

FLStatus bdkRetrieveHeader (dword * headerBuffer)
{
  word  iUnit;
  dword endUnit; /* Might be larger then word */
  dword * bbt = (headerBuffer+BDK_HEADER_FIELDS);
  FLFlash * flash=bdkVol->flash;
  byte floorNo;
  FLBoolean flag;
  byte index;
  FLStatus status;

  tffsset(headerBuffer,0,BDK_HEADER_FIELDS * 2 * sizeof(LEmin));

  for (endUnit = 0,floorNo = 0 ; floorNo < flash->noOfFloors ; floorNo++)
  {
     iUnit = (word)(endUnit + flash->firstUsableBlock);

     endUnit += bdkVol->blockPerFloor;
     for (flag = FALSE;(iUnit<endUnit)&&(flag==FALSE);iUnit++)
     {
        for (index=0;index<BDK_NO_OF_MEDIA_HEADERS;index++) /* all copies */
        {
           status = flash->read(flash,((CardAddress)iUnit<<flash->erasableBlockSizeBits)
                                + index * BDK_HEADERS_SPACING,bbt,
                BDK_HEADER_FIELDS*sizeof(LEmin),FL_DATA);
           if (status != flOK)
           {
              DEBUG_PRINT(("Debug: ERROR reading original unit header.\r\n"));
              return flBadFormat;
           }
           if (tffscmp(bbt, "BNAND", sizeof("BNAND")) == 0)
           {
              flag=TRUE;
              break;
           }
        }
     }
     if (flag == FALSE) /* Header not found in all header copies */
     {
        DEBUG_PRINT(("Debug: binary partition data could not be found.\r\n"));
        return flBadFormat;
     }
     /* merge with previous headers */
     for (index = 0 ; index < BDK_HEADER_FIELDS; index++)
     {
        headerBuffer[index] |= bbt[index];
     }
  } /* loop of the floors */
  return flOK;
}

#endif /* NO_INFTL_SUPPORT */
/*--------------------------------------------------------------------------*
 *                         b d k M o u n t
 *
 *  Routine that finds the media header unit and initializes it. The header
 *  supplies the number of binary partition in the DiskOnChip and their
 *  boundries. If the header is valid the curent partition pointer is set to
 *  the required partition.
 *
 *  Note : 1) Drive argument is assumed to be O.K and DiskOnChip already found
 *         2) If there are no binary partitions O.K will be returned but the
 *            bdkVol pointer will not be changed.
 *
 *  Parameters : None
 *
 *  global variable input :
 *           globalSocketNo     : DiskOnChip drive number (always 0 for BDK)
 *           globalPartitionNo  : Binary partition number in the DiskOnChip
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *               noOfPartitions      - the current amount of partitions
 *               bdkVols             - array of the binary partitions records
 *
 *  global variable output :
 *           bdkVol              - new current binary partition record
 *           handleTable         - partition to record converion table
 *           bdkGlobalStatus     - set to BDK_S_HEADER_FOUND
 *           erasableBlockBits   - number of bits representing a unit
 *           startPartitionBlock - physical unit number of first unit
 *           endPartitionBlock   - and last units of the partition
 *           noOfPartitions      - increment with the new found partitions
 *
 * Return:
 *     flOK                  - success
 *     flBadFormat           - TL format does not exists
 *     flFeatureNotSupported - Not a DiskOnChip device.
 *     flNoSpaceInVolume     - No binary partition at all
 *     flBadDriveHandle      - No such binary partition on the media or number
 *                             binary partitions exceeds the cusomized limit.
 *     flDataError           - fail in buffer reading codes
 *     flHWProtect           - HW read protection was triggerd
 *
 * Routine for both OSAK and the BDK stand alone package.
 *--------------------------------------------------------------------------*/

static FLStatus bdkMount(void)
{
  FLFlash    *   flash        = bdkVol->flash;
  dword          iBlock;
  dword          noOfBlocks;
  byte           blockMultiplierBits;
  byte           maxPartition = 0;
  byte           buf1[TL_SIGNATURE];
  byte           buf2[TL_SIGNATURE];
#ifndef NO_INFTL_SUPPORT
  LEmin          headerBuffer[BDK_HEADER_FIELDS*2]; /* assume big enough */
  VolumeRecord * volume;
#endif /* NO_INFTL_SUPPORT */

  if ((bdkVol->bdkGlobalStatus & BDK_S_HEADER_FOUND)==0)/* header not found */
  {
     /* Find number of bits used to represent erasable block */

     bdkVol->erasableBlockBits = flash->erasableBlockSizeBits;
     noOfBlocks = (dword)(flash->chipSize * flash->noOfChips)
                                >> bdkVol->erasableBlockBits;
     bdkVol->blockPerFloor = (word)
       (flash->chipSize >> flash->erasableBlockSizeBits) *
       ((flash->noOfChips + (flash->noOfChips % flash->noOfFloors)) /
        flash->noOfFloors);

     DEBUG_PRINT(("Debug: searching for TL media header.\r\n"));

#ifndef NO_NFTL_SUPPORT
     if (flash->flags & NFTL_ENABLED)
     {
    tffscpy(buf1,"ANAND",TL_SIGNATURE);
     }
#endif /* NO_NFTL_SUPPORT */
#ifndef NO_INFTL_SUPPORT
     if (flash->flags & INFTL_ENABLED)
     {
    tffscpy(buf1,"BNAND",TL_SIGNATURE);
     }
#endif /* NO_INFTL_SUPPORT */
     if ((flash->flags & (NFTL_ENABLED | INFTL_ENABLED))==0)
     {
       DEBUG_PRINT(("Debug: Not a DiskOnChip device therfore Binary partitions are not supported.\r\n"));
    return( flFeatureNotSupported );
     }

     /* Find the medium boot record in order to get partition boundries */

     for(iBlock=flash->firstUsableBlock;( iBlock < noOfBlocks );iBlock++)
     {
    checkStatus(flash->read(flash,(CardAddress)iBlock << bdkVol->erasableBlockBits,
                buf2,TL_SIGNATURE,0));

    if(tffscmp((void FAR1 *)buf2,(void FAR1 *)buf1,TL_SIGNATURE) == 0 )
    {
       break;
    }
     }

     if (iBlock==noOfBlocks)
     {
       DEBUG_PRINT(("Debug: TL format does not exists.\r\n"));
       return( flBadFormat );
     }

     /* Analize The media header */

#ifndef NO_NFTL_SUPPORT
     if (flash->flags & NFTL_ENABLED)     /* NFTL - only a single partition */
     {
         DEBUG_PRINT(("NFTL media header encounterd.\r\n"));
         bdkVol->startPartitionBlock = 0;
         bdkVol->endPartitionBlock   = (word)((iBlock) ? iBlock-1 : 0);
         maxPartition                = 1;
     }
#endif /* NO_NFTL_SUPPORT */
#ifndef NO_INFTL_SUPPORT
     if (flash->flags & INFTL_ENABLED)    /* INFTL - parse media header */
     {
         DEBUG_PRINT(("INFTL media header encounterd.\r\n"));
         maxPartition = 0;
         checkStatus(bdkRetrieveHeader((dword *)headerBuffer));
         volume = (VolumeRecord *) (headerBuffer+BDK_FIELDS_BEFORE_HEADER);
         if (((LE4(volume->flags) & BDK_BINARY_FLAG)==0) && (globalPartitionNo == 0))
         {
            DEBUG_PRINT(("Device is not formated with a binary partition.\r\n"));
            return flNoSpaceInVolume;
         }
         blockMultiplierBits = (byte)LE4(headerBuffer[MULTIPLIER_OFFSET]);
         bdkVol = &bdkVols[noOfPartitions];
         for (;(BINARY_PARTITIONS >= maxPartition + noOfPartitions) &&
             (LE4(volume->flags) & BDK_BINARY_FLAG) ; bdkVol++,volume++)
        {
            maxPartition++;
            bdkVol->startPartitionBlock = (word)LE4(volume->firstUnit) << blockMultiplierBits;
            bdkVol->endPartitionBlock   = (word)((LE4(volume->lastUnit)+1) << blockMultiplierBits) - 1;
            bdkVol->flash = bdkVols[noOfPartitions].flash;
#ifdef PROTECT_BDK_IMAGE
            bdkVol->protectionArea = (byte)LE4(volume->protectionArea);
            bdkVol->protectionType = (word)LE4(volume->flags);
#endif /* PROTECT_BDK_IMAGE */
            bdkVol->blockPerFloor     = bdkVols[noOfPartitions].blockPerFloor;
            bdkVol->erasableBlockBits = bdkVols[noOfPartitions].erasableBlockBits;
        }
     }
#endif /* NO_INFTL_SUPPORT */

     /* Initialize the partitions that had been found */

     for (blockMultiplierBits=0;blockMultiplierBits<maxPartition;
          blockMultiplierBits++) /* reused blockMultiplierBits as counter */
     {
        bdkVol                              = &bdkVols[noOfPartitions];
        handleTable[globalSocketNo][blockMultiplierBits] = noOfPartitions++;
        bdkVol->bdkGlobalStatus             = BDK_S_DOC_FOUND |
                                              BDK_S_HEADER_FOUND;
     }
  }

  /* set the current partition by changing the bdkVol global pointer */

  if ((globalPartitionNo>MAX_BINARY_PARTITIONS_PER_DRIVE) ||
      (handleTable[globalSocketNo][globalPartitionNo] == BDK_INVALID_VOLUME_HANDLE))
  {
     DEBUG_PRINT(("Device is not formated the specified binary partition.\r\n"));
     return flBadDriveHandle;
  }
  else
  {
    bdkVol = &bdkVols[handleTable[globalSocketNo][globalPartitionNo]];
  }
  return flOK;
}

#ifdef MTD_STANDALONE

/*-------------------------------------------------------------------
 *                         b d k E x i t
 *
 * Reset BDK variables and Free 'bdkWin' memory.
 *
 * Parameters: None
 *
 * Return:     Nothing
 *-------------------------------------------------------------------*/

void bdkExit( void )
{
  if( bdkVol->bdkGlobalStatus & BDK_S_DOC_FOUND )  /* DiskOnChip was found */
  {
    freePointer(bdkWin,DOC_WIN);
  }
  bdkInit();
}

/*-------------------------------------------------------------------
 *                   b d k S e t D o c W i n d o w
 *
 *  Set DiskOnChip window explicitly
 *
 *  Note : This routine should not be used after a DiskOnChip was already
 *         found since it does not initialize the Global binary variables.
 *         In order to switch between DiskOnChip call bdkexists before
 *         calling this routine.
 *
 *  Parameters : 'docWindow' - DiskOnChip physical address
 *
 *  global variable input :
 *               bdkVol           - current binary partition record
 *
 *  global variable output :
 *           bdkDocWindow     - initialized with the given address
 *
 *  Return:     Nothing
 *
 * Routine for BDK stand alone package.
 *-------------------------------------------------------------------*/

void bdkSetDocWindow( dword docWindow )
{
   bdkVol->bdkDocWindow = docWindow;
}

/*--------------------------------------------------------------------------
 *                     b d k F i n d D i s k O n C h i p
 *
 *  Find DiskOnChip in the specified memory range and identify the flash
 *  media (initialize flash). Update 'docSize' and 'docAddress' according
 *  to the DiskOnChip size and address respectively.
 *
 *  Note : If the DiskOnChip location is known, specify the same address
 *         for DOC_LOW_ADDRESS and DOC_HIGH_ADDRESS.
 *
 *  Parameters : 'docAddress'      - pointer to the DiskOnChip address
 *               'docSize'         - pointer to the returned size
 *
 *  global variable input :
 *           bdkGlobalStatus  - was this device found before
 *               bdkVol           - current binary partition record
 *               bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *               flash            - flash record enabling media I\O
 *           bdkGlobalStatus  - set to BDK_S_DOC_FOUND
 *               bdkDocWindow     - save physical window address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *
 * Routine for BDK stand alone package.
 *------------------------------------------------------------------------*/

FLStatus bdkFindDiskOnChip(dword FAR2 *docAddress, dword FAR2 *docSize )
{
  FLStatus status;
  byte     mtdIndex;
  dword    blockSize;
  FLSocket *socket = flSocketOf(0);
  FLFlash  *flash  = flFlashOf(0);

  if(globalInitStatus==FALSE)
      bdkInit();

  if ((bdkVol->bdkGlobalStatus & BDK_S_DOC_FOUND) == 0) /* initialize MTD */
  {

      bdkVol        = bdkVols;
      bdkVol->flash = flash;

#ifndef NO_DOC2000_FAMILY_SUPPORT
      flRegisterDOC2000();
#endif
#ifndef NO_DOCPLUS_FAMILY_SUPPORT
      flRegisterDOCPLUS();
#endif

      /* Search for ASIC in the given memory boundries */

      for(mtdIndex=0;mtdIndex < noOfMTDs;mtdIndex++)
      {
         if( bdkVol->bdkDocWindow > 0 )       /* Set range explicitely */
         {
            status = socketTable[mtdIndex](socket,
                     bdkVol->bdkDocWindow,bdkVol->bdkDocWindow);
         }
         else
         {
            status = socketTable[mtdIndex](socket,
                     DOC_LOW_ADDRESS,DOC_HIGH_ADDRESS);
         }
         if (status == flOK)
         {
              /* Identify flash connected to the ASIC */

            bdkVol->bdkDocWindow = pointerToPhysical(socket->base);

            flash->socket = socket;
            checkStatus(mtdTable[mtdIndex](flash));
            break;
         }
      }
      if (status != flOK)
         return status;

      bdkVol->bdkGlobalStatus |= BDK_S_DOC_FOUND;

      /* Calculate erasable Block Size Bits */
      for(blockSize = flash->erasableBlockSize>>1,flash->erasableBlockSizeBits = 0;
         blockSize>0; flash->erasableBlockSizeBits++,blockSize = blockSize >> 1);
  }

  *docAddress  = pointerToPhysical(socket->base);
  *docSize     = flash->chipSize * flash->noOfChips;

  return flOK;
}

/*--------------------------------------------------------------------------
 *               b d k S e t B o o t P a r t i t i o n N o
 *
 *  Set current binary partiton pointer to a specific binary partition
 *
 *  Note : This routine is neccesay only for partitions > 0 .
 *         This routine can replace the bdkFindDiskOnChip call.
 *
 *  Parameters : 'partitionNo'     - serial number of binary partition
 *
 *  global variable output :
 *           globalPartitionNo  - changed to the current partition number.
 *
 *  Return:
 *     flOK on success
 *     flBadParameter if BDK is not customized to support that many partitions.
 *
 * Routine for BDK stand alone package only.
 *------------------------------------------------------------------------*/

FLStatus bdkSetBootPartitionNo(byte partitionNo)
{
  if (partitionNo < TFFSMIN(BINARY_PARTITIONS,MAX_BINARY_PARTITIONS_PER_DRIVE))
  {
     globalPartitionNo = partitionNo;
     return flOK;
  }
  else
  {
     DEBUG_PRINT(("BDK is not customized to support the specified partition number.\r\n"));
     return flBadParameter;
  }
}

/*-------------------------------------------------------------------
 *                    b d k C h e c k S i g n O f f s e t
 *
 *  Set BDK signature offset
 *
 *  Note : Offset 0 does not support the use of EDC\ECC mechanizm and
 *         therfore it reconmended not to be used.
 *         The new found offset is stored in the bdkSignOffset field of the
 *         partitions global record.
 *
 *  Parameters : 'signature'       - 4-character signature of storage units
 *
 *  global variable input :
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkVol              - current binary partition record
 *               bdkDocWindow        - DiskOnChip window physical address
 *                                     (used to narrow search for DiskOnChip)
 *
 *  global variable output :
 *           bdkSignOffset - the offset of the signature (either 0 or 8)
 *
 *               bdkSavedStartUnit   - save start unit for next access
 *               bdkSavedSignOffset  - save current signatur for next access
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               signBuffer          - initialize with given signature
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *
 * Routine for BDK stand alone package only.
 *-------------------------------------------------------------------*/

FLStatus bdkCheckSignOffset( byte FAR2 *signature )
{
  FLStatus status;

  bdkVol->bdkSignOffset = 0;  /* Look for signature units with offset 0 */

  status = getBootAreaInfo( 0 , signature );

  if (status!=flOK)
  {
     bdkVol->bdkSignOffset = BDK_SIGN_OFFSET; /* Now try with offset 8 */
     checkStatus(getBootAreaInfo( 0 , signature ));
  }
  return( flOK );
}

 /*-------------------------------------------------------------------
 *                   b d k C o p y B o o t A r e a
 *
 * Copy the BDK Image from the DiskOnChip to a RAM area starting at
 * 'startAddress', with a size of 'areaLen' bytes.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-byteacter signature
 *         followed by a 4-digit hexadecimal number.
 *
 *        This routine simple calls bdkCopyBootAreaInit and loops over
 *        bdkCopyBootAreaBlock.
 *
 * Parameters: 'startAddress'  - pointer to the beginning of the RAM area
 *             'startUnit'     - start block in image for reading
 *             'areaLen'       - BDK image size
 *             'checkSum'      - pointer to the checksum modulo 0x100
 *             'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *           bdkGlobalStatus     - partition predsent status.
 *               bdkSavedStartUnit   - start unit of previous access
 *               bdkSavedSignOffset  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *               bdkDocWindow        - explicitly sets the windows address
 *
 *  global variable output :
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedStartUnit   - save start unit for next access
 *               bdkSavedSignOffset  - save current signature for next access
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD dependent.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for BDK stand alone package only.
 *-------------------------------------------------------------------*/

FLStatus bdkCopyBootArea( byte FAR1 *startAddress,word startUnit,dword  areaLen,
                          byte FAR2 *checkSum, byte FAR2 *signature )
{
  dword  curLen;
  word  copyLen;

  checkStatus(bdkCopyBootAreaInit( startUnit, areaLen, signature ));
  DEBUG_PRINT(("Debug: bdkCopyBootArea() - bdkCopyBootAreaInit was done succefully.\r\n"));

#ifdef BDK_CHECK_SUM
  if (checkSum!=NULL)
    *checkSum=0;
#endif /* BDK_CHECK_SUM */

  for(curLen=0L;( curLen < areaLen );curLen+=bdkVol->flash->erasableBlockSize)
  {
	copyLen = (word)BDK_MIN((areaLen - curLen), bdkVol->flash->erasableBlockSize);
    checkStatus(bdkCopyBootAreaBlock( (byte FAR1 *)startAddress, copyLen, checkSum ));
    startAddress = (byte FAR1 *)addToFarPointer( startAddress, copyLen);
  }
  return flOK;
}

#endif /* MTD_STANDALONE */

/*-------------------------------------------------------------------
 *             b d k G e t B o o t P a r t i t i o n I n f o
 *
 *  Get DiskOnChip binary sub partition Information.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-byteacter signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'startUnit'     - start Unit for Actual sub Partition Size
 *              'partitionSize' - pointer to return sub Partition Size parameter
 *              'realPartitionSize' - pointer to return Actual sub Partition Size
 *              'unitSize'      - pointer to return Unit Size parameter
 *              'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *           bdkGlobalStatus     - partition predsent status.
 *               bdkSavedStartUnit   - start unit of previous access
 *               bdkSavedSignOffset  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *               bdkDocWindow        - explicitly sets the windows address
 *
 *  global variable output :
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedStartUnit   - save start unit for next access
 *               bdkSavedSignOffset  - save current signature for next access
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD dependent.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for BDK stand alone package only.*
 *-------------------------------------------------------------------*/

FLStatus bdkGetBootPartitionInfo( word startUnit, dword  FAR2 *partitionSize,
                      dword  FAR2 *realPartitionSize,
                      dword  FAR2 *unitSize, byte FAR2 *signature)
{
  FLStatus st = flOK;
  *partitionSize = 0L;
  *unitSize = 0L;

  st = getBootAreaInfo( startUnit , signature );

  *partitionSize      = bdkVol->bootImageSize;
  *realPartitionSize  = bdkVol->realBootImageSize;
  *realPartitionSize -= ((startUnit - bdkVol->bdkSavedStartUnit) << bdkVol->erasableBlockBits);
  *unitSize           = bdkVol->flash->erasableBlockSize;

  return( st );
}


/*-------------------------------------------------------------------
 *                   b d k C o p y B o o t A r e a I n i t
 *
 * Initialize read operations on the DiskOnChip starting at 'startUnit', with
 * a size of 'areaLen' bytes and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-byteacter signature
 *         followed by a 4-digit hexadecimal number.
 *
 * Parameters: 'startUnit'     - start block in image for reading
 *             'areaLen'       - BDK image size
 *             'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               curReadImageAddress - current address to read from
 *               actualReadLen       - length left to read
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkCopyBootAreaInit(word startUnit ,
                    dword areaLen ,
                    byte FAR2 *signature)
{
  dword       realSize;  /* remaining real size from start unit */

  checkStatus(getBootAreaInfo( startUnit , signature ));

  realSize  = bdkVol->realBootImageSize;
  realSize -= (startUnit - bdkVol->bdkSavedStartUnit) << bdkVol->erasableBlockBits;
  if (areaLen>realSize)
  {
     DEBUG_PRINT(("got out of the partition.\r\n"));
     return( flNoSpaceInVolume );
  }

  bdkVol->curReadImageBlock   = startUnit;
  bdkVol->actualReadLen       = areaLen;
  bdkVol->curReadImageAddress = getPhysAddressOfUnit( startUnit );
  return( flOK );
}

/*-------------------------------------------------------------------
 * bdkCopyBootAreaBlock - Read to 'buffer' from the DiskOnChip BDK Image area.
 *
 *  Note : Before the first use of this function 'bdkCopyBootAreaInit'
 *         must be called
 *
 *  Parameters: 'buf'           - buffer to read into
 *              'bufferLen'     - buffer length in bytes
 *              'checkSum'      - pointer to the checksum modulo 0x100
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *               signBuffer          - sub partition signature
 *               bdkSignOffset       - current signature offset
 *               curReadImageAddress - current address to read from
 *               actualReadLen       - length left to read
 *               endImageBlock       - last signatured block in sub partition
 *               erasableBlockBits   - no' of bits used to represent a block
 *
 *  global variable output :
 *               curReadImageAddress - updated address to read from
 *               actualReadLen       - updated length left to read
 *
 *  Return :
 *      flOK                - success
 *      flBadLength         - required length will cause crossing unit boundry
 *      flNoSpaceInVolume   - no more signatured units found
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkCopyBootAreaBlock( byte FAR1 *buf, word bufferLen, byte FAR2 *checkSum )
{
  word iBlock, readLen;
  byte modes;
  byte signRead[BDK_SIGNATURE_NAME];
  FLFlash * flash = bdkVol->flash;
  FLStatus status;

  if( (bufferLen > flash->erasableBlockSize ) ||
      (bufferLen > bdkVol->actualReadLen))
    return( flBadLength );

  /* find next good unit */

  if( (bdkVol->curReadImageAddress & (flash->erasableBlockSize-1)) == 0 )
  {
     iBlock = (word)( bdkVol->curReadImageAddress >> bdkVol->erasableBlockBits );
     for(;( iBlock <= bdkVol->endImageBlock ); iBlock++)
     {
        if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
        {
           iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
           if (iBlock > bdkVol->endImageBlock)
             break;
        }

        status = flash->read (flash , bdkVol->bdkSignOffset +
                ((CardAddress)iBlock << bdkVol->erasableBlockBits) ,
                (byte FAR1 *)signRead, BDK_SIGNATURE_NAME,EXTRA);
        if(status!=flOK)
        {
           DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
           return status;
        }
        if( tffscmp((void FAR1 *)signRead, (void FAR1 *)(bdkVol->signBuffer),
               BDK_SIGNATURE_NAME ) == 0 )
               break;
     }

     if( iBlock > bdkVol->endImageBlock )
       return( flNoSpaceInVolume );             /* Finish (last block) */

     bdkVol->curReadImageAddress = (CardAddress )iBlock << bdkVol->erasableBlockBits;
     bdkVol->curReadImageBlock++;
  }

  /* read data */

  readLen = (word)BDK_MIN(bdkVol->actualReadLen, (dword)bufferLen);
  if((bdkVol->bdkEDC)&&(bdkVol->bdkSignOffset!=0))
  {
     modes=EDC;
  }
  else
  {
     modes=0;
  }

  status = (flash->read(flash, bdkVol->curReadImageAddress, buf, readLen, modes));
  if(status!=flOK)
  {
     DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
     return status;
  }

  bdkVol->curReadImageAddress += (CardAddress )readLen;
  bdkVol->actualReadLen  -= (dword)readLen;

#ifdef BDK_CHECK_SUM
  if (checkSum!=NULL)
  {
     while (readLen>0)
     {
        readLen--;
        *checkSum+=buf[readLen];
     }
  }
#endif /* BDK_CHECK_SUM */
  return( flOK );
}

#ifdef UPDATE_BDK_IMAGE
/*-------------------------------------------------------------------
 *              b d k U p d a t e B o o t A r e a I n i t
 *
 * Initialize update operations on the DiskOnChip starting at 'startUnit',
 * with a size of 'areaLen' bytes and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-byteacter signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'startUnit'     - start unit in image for updating
 *              'areaLen'       - BDK image size
 *              'updateFlag'    - update whole image or part of it
 *                                BDK_COMPLETE_IMAGE_UPDATE
 *              'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               actualUpdateLen     - length left to write
 *               curUpadateImageAddress - current address to write to
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkUpdateBootAreaInit( word startUnit, dword  areaLen,
                    byte updateFlag, byte FAR2 *signature )
{
  word imageBlockSize;

  checkStatus(getBootAreaInfo( startUnit , signature ));

  imageBlockSize = (word)( bdkVol->bootImageSize >> bdkVol->erasableBlockBits);

  if( ((dword)(imageBlockSize-startUnit) << bdkVol->erasableBlockBits) < areaLen )
    return( flNoSpaceInVolume );

  bdkVol->actualUpdateLen       = areaLen;
  bdkVol->curUpdateImageBlock   = startUnit;
  bdkVol->updateImageFlag       = updateFlag;
  bdkVol->curUpdateImageAddress = getPhysAddressOfUnit( startUnit );
  bdkVol->bdkGlobalStatus      &= ~BDK_S_INFO_FOUND;
  return( flOK );
}

/*-------------------------------------------------------------------
 *             b d k U p d a t e B o o t A r e a B l o c k
 *
 *  Write 'buffer' to the DiskOnChip BDK Image area.
 *
 *  Note : Before the first use of this function 'bdkUpdateBootAreaInit'
 *         must be called
 *
 *  Parameters: 'buf'             - BDK image buffer
 *              'bufferLen'       - buffer length in bytes
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *               signBuffer          - sub partition signature
 *               bdkSignOffset       - current signature offset
 *               curUpdateImageAddress - current address to read from
 *               actualUpdateLen     - length left to read
 *               endImageBlock       - last signatured block in sub partition
 *               erasableBlockBits   - no' of bits used to represent a block
 *
 *  global variable output :
 *               curUpdateImageAddress - updated address to read from
 *               actualUpdateLen       - updated length left to read
 *
 *  Return :
 *      flOK                - success
 *      flBadLength         - required length will cause crossing unit boundry
 *      flNoSpaceInVolume   - no more signatured units found
 *      flDataError         - MTD read fault
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkUpdateBootAreaBlock( byte FAR1 *buf, word bufferLen )
{
  word iBlock, writeLen, i0, j;
  FLStatus status;
  FLFlash* flash = bdkVol->flash;
  byte modes;
  byte signRead[SIGNATURE_LEN];

  if( (bufferLen > flash->erasableBlockSize) ||
      (bufferLen > bdkVol->actualUpdateLen))
    return( flBadLength );

  /* find next good unit and prepare it for work */

  if( (bdkVol->curUpdateImageAddress & (flash->erasableBlockSize-1)) == 0 )
  {
      /* find next signatured unit */

    iBlock = (word)( bdkVol->curUpdateImageAddress >> bdkVol->erasableBlockBits );
    for(;( iBlock <= bdkVol->endImageBlock ); iBlock++)
    {
      if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
      {
        iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
        if (iBlock > bdkVol->endImageBlock)
          break;
      }
      status = flash->read(flash , bdkVol->bdkSignOffset +
                 ((CardAddress)iBlock << bdkVol->erasableBlockBits),
                 (byte FAR1 *)signRead, BDK_SIGNATURE_NAME ,EXTRA);
      if(status!=flOK)
      {
         DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
         return status;
      }

      if( tffscmp( (void FAR1 *)signRead, (void FAR1 *)(bdkVol->signBuffer),
       BDK_SIGNATURE_NAME ) == 0 )
       break;
    }
    if( iBlock > bdkVol->endImageBlock )
      return( flNoSpaceInVolume );

      /* Erase the newly found unit */

#ifdef BDK_ACCESS
    if(bdkVol->updateImageFlag & ERASE_BEFORE_WRITE)
#endif
      checkStatus(flash->erase (flash, iBlock, 1 ));

       /* Update signature number */

    if( (bdkVol->actualUpdateLen <= flash->erasableBlockSize) &&
     (bdkVol->updateImageFlag & BDK_COMPLETE_IMAGE_UPDATE)     )
    {
       /* Last block FFFF */
       tffscpy( (void FAR1 *)&bdkVol->signBuffer[BDK_SIGNATURE_NAME],
          (void FAR1 *)"FFFF", SIGNATURE_NUM );
    }
    else
    {
      for(i0=bdkVol->curUpdateImageBlock,j=SIGNATURE_LEN;(j>BDK_SIGNATURE_NAME);j--)
      {
         bdkVol->signBuffer[j-1] = (i0 % 10) + '0';
         i0 /= 10;
      }
    }
    /* update internal pointers */

    bdkVol->curUpdateImageAddress = (CardAddress )iBlock << bdkVol->erasableBlockBits;
    bdkVol->curUpdateImageBlock++;

    /* Mark new block */
    status = flash->write(flash,
          (bdkVol->bdkSignOffset + bdkVol->curUpdateImageAddress),
          (byte FAR1 *)bdkVol->signBuffer, SIGNATURE_LEN, EXTRA);
#ifdef VERIFY_WRITE
    if (status == flWriteFault) /* Check if failed due to erase operation */
    {
       /* Check signature is written properly */
       flash->read(flash , (bdkVol->bdkSignOffset + bdkVol->curUpdateImageAddress),            
                  (byte FAR1 *)signRead, SIGNATURE_LEN ,EXTRA);
       if(tffscmp(signRead,bdkVol->signBuffer,BDK_SIGNATURE_NAME))
       {
         return flWriteFault;
       }
       /* Check unit number is not "FFFF" */
       if(tffscmp(signRead+BDK_SIGNATURE_NAME,"FFFF",BDK_SIGNATURE_NAME))
       {
          dword tmp=0;
          checkStatus(flash->write(flash,(bdkVol->bdkSignOffset + 
                      bdkVol->curUpdateImageAddress), &tmp, sizeof (dword), EXTRA));
       }   
    }
#endif /* VERIFY_WRITE */
  }

  /* Write the data to the flash and update internal pointers */

  writeLen = (word)BDK_MIN(bdkVol->actualUpdateLen, (dword)bufferLen);

  if((bdkVol->bdkEDC)&&(bdkVol->bdkSignOffset!=0))
  {
     modes=EDC;
  }
  else
  {
     modes=0;
  }
  checkStatus(flash->write(flash,bdkVol->curUpdateImageAddress,buf,writeLen,modes));

  bdkVol->curUpdateImageAddress += (CardAddress)writeLen;
  bdkVol->actualUpdateLen       -= (dword)writeLen;
  return( flOK );
}

#ifdef ERASE_BDK_IMAGE
/*-------------------------------------------------------------------
 *                   b d k E r a s e A r e a
 *
 *  Erase given number of blockds in the binary sub partition.
 *
 *  Parameters: 'startUnit'     - start unit in image for updating
 *              'noOfBlocks'    - number of blocks to erase
 *              'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               realBootImageSize   - number of units writen in the sub partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               actualUpdateLen     - 0
 *               curUpadateImageAddress - address of first block to erase.
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkEraseBootArea(word startUnit, word noOfBlocks, byte FAR2 * signature)
{
  word iBlock,index;
  FLStatus status;
  FLFlash* flash;

  flash = bdkVol->flash;

  checkStatus(bdkUpdateBootAreaInit(startUnit,
         (dword)noOfBlocks << bdkVol->erasableBlockBits,0,signature));

  tffscpy( (void FAR1 *)&bdkVol->signBuffer, (void FAR1 *) signature, BDK_SIGNATURE_NAME);
  tffscpy( (void FAR1 *)&bdkVol->signBuffer[BDK_SIGNATURE_NAME],  /* Last block FFFF */
        (void FAR1 *)"FFFF", SIGNATURE_NUM );

  iBlock = (word)(bdkVol->curUpdateImageAddress >> bdkVol->erasableBlockBits);

  for (index=0;index<noOfBlocks;index++,iBlock++)

     /* find next good unit erase it and rewrite its signature */
  {
     do
     {
         if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
         {
           /* Skip OTP and DPS if relevant */
           iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
           if (iBlock > bdkVol->endImageBlock)
             return flGeneralFailure;
         }

         status = flash->read(flash , bdkVol->bdkSignOffset +
         ((CardAddress)iBlock << bdkVol->erasableBlockBits),
          (byte FAR1 *)bdkVol->signBuffer, BDK_SIGNATURE_NAME ,EXTRA);
         if(status!=flOK)
         {
            DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
            return status;
         }
         if (tffscmp((void FAR1 *)bdkVol->signBuffer,
                 (void FAR1 *)signature, BDK_SIGNATURE_NAME ) == 0)
         {
            break;
         }
         else
         {
            iBlock++;
         }
         if (iBlock > bdkVol->endImageBlock)
            return( flNoSpaceInVolume );
     }while(1);

     checkStatus(flash->erase(flash, iBlock, 1 ));
     checkStatus(flash->write(flash, bdkVol->bdkSignOffset +
         ((CardAddress)iBlock << bdkVol->erasableBlockBits),
         (byte FAR1 *)bdkVol->signBuffer, SIGNATURE_LEN, EXTRA));
  }

  bdkVol->actualUpdateLen = 0L;
  return( flOK );
}

#endif /* ERASE_BDK_IMAGE */

#ifdef CREATE_BDK_IMAGE

/*-------------------------------------------------------------------
 *                b d k C r e a t e B o o t A r e a
 *  Init create operations on the DiskOnChip starting at 'startUnit', with
 *  a # of 'units' and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-character signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'noOfBlocks'    - number of blocks to erase
 *              'oldSign'     - 4-byteacter signature of the source units
 *              'newSign'     - 4-byteacter signature of the new units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               realBootImageSize   - number of units writen in the sub partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               actualUpdateLen     - 0
 *               curUpadateImageAddress - address of first block to erase.
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/
FLStatus bdkCreateBootArea(word noOfBlocks, byte FAR2 * oldSign,
                  byte FAR2 * newSign)
{
  word iBlock, index;
  byte signRead[BDK_SIGNATURE_NAME];
  FLStatus status;
  FLFlash* flash;

  flash = bdkVol->flash;

  /* FFFF is not a valid signature */
  if(*((dword FAR2*)newSign)==0xffffffffL)
  {
     DEBUG_PRINT(("Debug: can not use 'FFFF' signature for Binary partition.\r\n"));
     return flBadParameter;
  }

  checkStatus(bdkUpdateBootAreaInit(0,(dword)noOfBlocks<<flash->erasableBlockSizeBits,
                        BDK_PARTIAL_IMAGE_UPDATE,oldSign));

  tffscpy( (void FAR1 *)&bdkVol->signBuffer, (void FAR1 *) newSign, BDK_SIGNATURE_NAME);
  tffscpy( (void FAR1 *)&bdkVol->signBuffer[BDK_SIGNATURE_NAME],  /* Last block FFFF */
        (void FAR1 *)"FFFF", SIGNATURE_NUM );

  iBlock = (word)(bdkVol->curUpdateImageAddress >> bdkVol->erasableBlockBits);

  for (index=0;index<noOfBlocks;index++)

     /* find next good unit erase it and write its new signature */
  {
    for(;( iBlock <= bdkVol->endImageBlock ); iBlock++)
    {
      if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
      {
        iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
        if (iBlock > bdkVol->endImageBlock)
          break;
      }

      status = flash->read(flash , bdkVol->bdkSignOffset +
                 ((CardAddress)iBlock << bdkVol->erasableBlockBits),
                 (byte FAR1 *)signRead, BDK_SIGNATURE_NAME ,EXTRA);
      if(status!=flOK)
      {
        DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
        return status;
      }

      if( tffscmp( (void FAR1 *)oldSign,
             (void FAR1 *)(signRead), BDK_SIGNATURE_NAME ) == 0 )
     break;
    }
    if( iBlock > bdkVol->endImageBlock )
       return( flNoSpaceInVolume );

    checkStatus(flash->erase(flash, iBlock, 1 ));
    checkStatus(flash->write(flash, bdkVol->bdkSignOffset +
          ((CardAddress)iBlock << bdkVol->erasableBlockBits),
          (byte FAR1 *)bdkVol->signBuffer, SIGNATURE_LEN, EXTRA));
  }

  bdkVol->actualUpdateLen = 0L;
  return( flOK );
}
#endif /* CREATE_BDK_IMAGE */
#endif /* UPDATE_BDK_IMAGE */

#ifdef BDK_IMAGE_TO_FILE
#include <stdio.h>

/*-------------------------------------------------------------------
 *               b d k C o p y B o o t A r e a F i l e
 *
 *  Copy the BDK Image from the DiskOnChip to file 'fname' starting at
 *  'startAddress', with a size of 'areaLen' bytes.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-character signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'fname'         - pointer to file name
 *              'startUnit'     - start block in image for reading
 *              'areaLen'       - BDK image size
 *              'checkSum'      - pointer to the checksum modulo 0x100
 *              'signature'     - 4-character signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               curReadImageAddress - address of last unit read
 *               actualReadLen       - 0
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flGeneralFailure    - could not open file
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for BDK stand alone package.
 *-------------------------------------------------------------------*/
FLStatus bdkCopyBootAreaFile( Sbyte FAR2 *fname, word startUnit, dword areaLen,
          byte FAR2 *checkSum, byte FAR2 *signature )
{
  dword curLen;
  word copyLen;
  FILE *fout;
  byte buf[BLOCK];

  checkStatus(bdkCopyBootAreaInit( startUnit, areaLen, signature ));

  if( (fout = fopen(fname,"wb")) == NULL )
    return( flGeneralFailure );

#ifdef BDK_CHECK_SUM
  *checkSum = 0;
#endif /* BDK_CHECK_SUM */
  for(curLen=0L;( curLen < areaLen );curLen+=BLOCK)
  {
    copyLen = (word)BDK_MIN((areaLen - curLen), BLOCK);
    checkStatus(bdkCopyBootAreaBlock( (byte FAR1 *)buf, copyLen, checkSum ));
    fwrite( buf, 1, copyLen, fout );
  }
  fclose(fout);
  return( flOK );
}

#ifdef UPDATE_BDK_IMAGE

/*-------------------------------------------------------------------
 *                 b d k U p d a t e B o o t A r e a F i l e
 *
 *  Copy the BDK Image to the DiskOnChip from the file 'fname' starting at
 *  'startUnit', with a size of 'areaLen' bytes and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-character signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'fname'         - pointer to file name
 *              'startUnit'    - start block in image for reading
 *              'areaLen'       - BDK image size
 *              'signature'     - 4-character signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               actualUpdateLen     - 0
 *               curUpadateImageAddress - address of last written unit
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flGeneralFailure    - could not open file
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *
 * Routine for BDK stand alone package.
 *-------------------------------------------------------------------*/
FLStatus bdkUpdateBootAreaFile( Sbyte FAR2 *fname, word startUnit,
            dword areaLen   , byte FAR2 *signature )
{
  dword curLen;
  word copyLen;
  FILE *fout;
  byte buf[BLOCK];

  checkStatus(bdkUpdateBootAreaInit( startUnit, areaLen,
                     BDK_COMPLETE_IMAGE_UPDATE, signature ));

  if( (fout = fopen(fname,"rb")) == NULL )
    return(flGeneralFailure);

  for(curLen=0L;( curLen < areaLen );curLen+=BLOCK)
  {
    copyLen = (word)BDK_MIN((areaLen - curLen), BLOCK);
    fread( buf, 1, copyLen, fout );
    checkStatus(bdkUpdateBootAreaBlock( (byte FAR1 *)buf, copyLen ));
  }
  fclose(fout);
  return( flOK );
}
#endif /* UPDATE_BDK_IMAGE  */
#endif /* BDK_IMAGE_TO_FILE */

#ifdef PROTECT_BDK_IMAGE

/*--------------------------------------------------------------------------
 *               p r o t e c t i o n I n i t
 *
 *  Makes suer the volume is mounted before calling protection calls.
 *
 *  Note this routine is called directly by each of the protection routines
 *
 *  return
 *    FLStatus flOK otherwise respective error code.
 *
 *--------------------------------------------------------------------------*/

static FLStatus protectionInit(void)
{
  /* Check that the partition is mounted */
#ifdef MTD_STANDALONE
  dword temp;

  checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
#endif /* MTD_STANDALONE */
  checkStatus(bdkMount());
  if (bdkVol->flash->flags & NFTL_ENABLED)
  {
     DEBUG_PRINT(("NFTL does not support protection.\r\n"));
     return flFeatureNotSupported;
  }

  if ((bdkVol->protectionType & PROTECTABLE) == 0)
  {
     DEBUG_PRINT(("Not a protectable partition.\r\n"));
     return flNotProtected;
  }
  return flOK;
}

/*--------------------------------------------------------------------------
 *               p r o t e c t i o n C h a n g e I n i t
 *
 *  Makes sure the volume is mounted before calling protection calls.
 *  Makes sure the protection can be updated and functions arae vailable
 *
 *  Note this routine is called directly by each of the protection routines
 *
 *  return
 *    FLStatus flOK on success non zero otherwise
 *
 *--------------------------------------------------------------------------*/

static FLStatus protectionChangeInit(word * type)
{
  checkStatus(protectionInit());

  if (!(bdkVol->protectionType & CHANGEABLE_PROTECTION))
  {
     DEBUG_PRINT(("Uncheangable protection.\r\n"));
     return flFeatureNotSupported;
  }

  if ((bdkVol->flash->protectionBoundries == NULL)  ||
      (bdkVol->flash->protectionSet       == NULL)  ||
      (bdkVol->flash->protectionKeyInsert == NULL)  ||
      (bdkVol->flash->protectionType      == NULL))
  {
     DEBUG_PRINT(("H/W does not support protection.\r\n"));
     return flFeatureNotSupported;
  }

  /* get the protection type */
  checkStatus(bdkVol->flash->protectionType(bdkVol->flash,
               bdkVol->protectionArea, (word *)type));
  return (bdkVol->flash->protectionKeyInsert(bdkVol->flash,
          bdkVol->protectionArea, (byte *)DEFAULT_KEY));
}

/*--------------------------------------------------------------------------
 *               b d k G e t P r o t e c t i o n T y p e
 *
 *  Return the current partition protection type.
 *
 *
 *  Parameters : 'protectionType' - return the protection type as a
 *                                combination of the following flags:
 *
 *    PROTECTABLE     - A protection area is allocated for this volume
 *    LOCK_ENABLED    - HW Lock signal is enabled.
 *    LOCK_ASSERTED   - HW Lock signal is asserted.
 *    KEY_INSERTED    - Key is currently inserted (protection is down).
 *    READ_PROTECTED  - Area is protected against read operations.
 *    WRITE_PROTECTED - Area is protected against write operations.
 *    CHANGEABLE_PROTECTION - The area is protected against write operations.
 *
 *  global variable input :
 *           bdkGlobalStatus  - was this device found before
 *               bdkVol           - current binary partition record
 *               bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *               bdkVol           - current binary partition record
 *                   bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *               flash            - identify flash media and its socket
 *               bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *     flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus     bdkGetProtectionType    (word * protectionType)
{
  FLStatus status;
  status = protectionInit();

  switch (status)
  {
     case flOK:
        if (bdkVol->flash->protectionType==NULL)
           return flFeatureNotSupported;
        checkStatus (bdkVol->flash->protectionType(bdkVol->flash,
                    bdkVol->protectionArea, (word *)protectionType));

        *protectionType &= ~((word)(PROTECTABLE | CHANGEABLE_PROTECTION));
        *protectionType |=  (word)(bdkVol->protectionType & (word)(PROTECTABLE | CHANGEABLE_PROTECTION));
        return status;
     case flNotProtected:
        *protectionType  = 0;
     default:
        return status;
  }
}

/*--------------------------------------------------------------------------
 *                         b d k I n s e r t K e y
 *
 *  Insert the protection key to disable the HW protection.
 *
 *  Parameters : 'key' - The key to send
 *
 *  global variable input :
 *       bdkGlobalStatus  - was this device found before
 *       bdkVol           - current binary partition record
 *       bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *       bdkVol           - current binary partition record
 *       bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *       flash            - identify flash media and its socket
 *       bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus bdkInsertKey            (byte FAR1* key)
{
  checkStatus(protectionInit());

  if (bdkVol->flash->protectionKeyInsert==NULL)
     return flFeatureNotSupported;
  return (bdkVol->flash->protectionKeyInsert(bdkVol->flash,
          bdkVol->protectionArea, key));
}

/*--------------------------------------------------------------------------
 *                           b d k R e m o v e K e y
 *
 *  Return the current partition protection type.
 *
 *  Parameters : None
 *
 *  global variable input :
 *       bdkGlobalStatus  - was this device found before
 *       bdkVol           - current binary partition record
 *       bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *       bdkVol           - current binary partition record
 *       bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *       flash            - identify flash media and its socket
 *       bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus bdkRemoveKey            (void)
{
  checkStatus(protectionInit());

  if ((bdkVol->flash->flags & NFTL_ENABLED) ||
      (bdkVol->flash->protectionKeyRemove==NULL))
     return flFeatureNotSupported;
  return (bdkVol->flash->protectionKeyRemove(bdkVol->flash,
          bdkVol->protectionArea));

}
/*--------------------------------------------------------------------------
 *                           b d k L o c k E n a b l e
 *
 *  Enable or disable the HW LOCK signal.
 *
 *  Note  : The protction key must be off before calling this routine.
 *          While asserted the HW LOCK signal can not be disabled.
 *
 *  Parameters : 'enabled' - LOCK_ENABLED - enables the HW LOCK
 *                           otherwise disabled
 *
 *  global variable input :
 *         bdkGlobalStatus  - was this device found before
 *         bdkVol           - current binary partition record
 *         bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *         bdkVol           - current binary partition record
 *         bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *         flash            - identify flash media and its socket
 *         bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus bdkLockEnable           (byte enabled)
{
  CardAddress low,high;
  word type;
  byte floorNo;

  checkStatus(protectionChangeInit(&type));

  if (enabled == LOCK_ENABLED)
  {
     type |= LOCK_ENABLED;
  }
  else
  {
     type &= ~LOCK_ENABLED;
  }

  for (floorNo=0;floorNo<bdkVol->flash->noOfFloors;floorNo++)
  {
      /* Find boundries */
     checkStatus(bdkVol->flash->protectionBoundries(bdkVol->flash,
              bdkVol->protectionArea,&low,&high,floorNo));

     /* Set new protection values */
     checkStatus(bdkVol->flash->protectionSet(bdkVol->flash,
         bdkVol->protectionArea,(word)((high == 0) ? PROTECTABLE : type),low,high,
         NULL,(byte)((floorNo == bdkVol->flash->noOfFloors - 1) ?
         COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo));
  }
  return flOK;
}

/*--------------------------------------------------------------------------
 *                          b d k C h a n g e K e y
 *
 *  Change the protection key of a protected binary partition..
 *
 *  Note : The protction key must be off before calling this routine.
 *
 *  Parameters : 'key' - The new protection key.
 *
 *  global variable input :
 *           bdkGlobalStatus  - was this device found before
 *               bdkVol           - current binary partition record
 *               bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *               bdkVol           - current binary partition record
 *                   bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *               flash            - identify flash media and its socket
 *               bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/

FLStatus bdkChangeKey(byte FAR1 * key)
{
  CardAddress low,high;
  word type;
  byte floorNo;

  checkStatus(protectionChangeInit(&type));

  for (floorNo=0;floorNo<bdkVol->flash->noOfFloors;floorNo++)
  {
      /* Find boundries */
     checkStatus(bdkVol->flash->protectionBoundries(bdkVol->flash,
                      bdkVol->protectionArea,&low,&high,floorNo));

     /* Set new protection values */
     checkStatus(bdkVol->flash->protectionSet(bdkVol->flash,
         bdkVol->protectionArea,(word)((high == 0) ? PROTECTABLE : type),
         low,high,key,(byte)((floorNo == bdkVol->flash->noOfFloors - 1)
         ? COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo));
  }
  return flOK;
}

/*--------------------------------------------------------------------------
 *               b d k S e t P r o t e c t i o n T y p e
 *
 *  Change the current partition protection type.
 *
 *
 *  Parameters : 'protectionType' - change the protection type as a
 *                                combination of the following flags:
 *
 *    PROTECTABLE     - Must be added for the routine to work.
 *    READ_PROTECTED  - Area is protected against read operations.
 *    WRITE_PROTECTED - Area is protected against write operations.
 *
 *  Note - To add extra protection only a combination of the above 3 flags is
 *         aceptable and the PROTECTABLE flag must be on.
 *
 *  global variable input :
 *           bdkGlobalStatus  - was this device found before
 *               bdkVol           - current binary partition record
 *               bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *               bdkVol           - current binary partition record
 *               bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *               flash            - identify flash media and its socket
 *               bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus bdkSetProtectionType           (word newType)
{
  CardAddress low,high;
  word type;
  byte floorNo;

  checkStatus(protectionChangeInit(&type));

  if (((newType & (READ_PROTECTED | WRITE_PROTECTED | PROTECTABLE)) != newType) ||
      ((newType & PROTECTABLE) == 0))
     return flBadParameter;

  newType |= type & ~(READ_PROTECTED | WRITE_PROTECTED);

  for (floorNo=0;floorNo<bdkVol->flash->noOfFloors;floorNo++)
  {
     /* Find boundries */
     checkStatus(bdkVol->flash->protectionBoundries(bdkVol->flash,
              bdkVol->protectionArea,&low,&high,floorNo));

     /* Set new protection values */
     checkStatus(bdkVol->flash->protectionSet(bdkVol->flash,
         bdkVol->protectionArea,(word)((high == 0) ? PROTECTABLE : newType),
         low,high,NULL,(byte)((floorNo == bdkVol->flash->noOfFloors - 1)
         ? COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo));
  }
  return flOK;
}

#endif /* PROTECT_BDK_IMAGE */

#if (defined(HW_OTP) && defined (MTD_STANDALONE))
/*----------------------------------------------------------------------*/
/*                   b d k G e t U n i q u e I d                        */
/*                                                                      */
/* Retreave the device 16 bytes unique ID.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      buffer  : buffer to read into.                                  */
/*                                                                      */
/* Returns:                                                             */
/*      flOK                - success                                   */ 
/*      flDriveNotAvailable - DiskOnChip ASIC was not found             */
/*      flUnknownMedia      - Failed in Flash chips recognition         */
/*      flBadDownload       - MdocPlus device has unrecoverable         */  
/*                            protection violation.                     */
/*      flHWProtection      - HW read protection violation.             */ 
/*      flTimedOut          - Flash delay not long enough.              */
/*----------------------------------------------------------------------*/

FLStatus bdkGetUniqueID(byte FAR1* buf)
{
   dword temp;

   checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
   if (bdkVol->flash->getUniqueId == NULL)
      return flFeatureNotSupported;
   return(bdkVol->flash->getUniqueId(bdkVol->flash,buf));
}

/*----------------------------------------------------------------------*/
/*                       b d k R e a d O T P                            */
/*                                                                      */
/* Read data from the customer OTP.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      offset  : Offset from the beginning of OTP area to read from.   */
/*      buffer  : buffer to read into.                                  */
/*      length  : number of bytes to read.                              */
/*                                                                      */
/* Returns:                                                             */
/*      flOK                - success                                   */ 
/*      flDriveNotAvailable - DiskOnChip ASIC was not found             */
/*      flUnknownMedia      - Failed in Flash chips recognition         */
/*      flBadDownload       - MdocPlus device has unrecoverable         */  
/*                            protection violation.                     */
/*      flHWProtection      - HW read protection violation.             */ 
/*      flTimedOut          - Flash delay not long enough.              */
/*----------------------------------------------------------------------*/

FLStatus bdkReadOtp(word offset,byte FAR1 * buffer,word length)
{
   dword temp;

   checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
   if (bdkVol->flash->readOTP == NULL)
      return flFeatureNotSupported;
   return(bdkVol->flash->readOTP(bdkVol->flash,offset,buffer,length));
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                 b d k W r i t e A n d L o c k O T P                  */
/*                                                                      */
/* Write and lock the customer OTP.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write.                             */
/*                                                                      */
/* Note - Once writen (even a single byte) the entire section is        */
/*        locked forever. The data is written with EDC.                 */
/*                                                                      */
/* Returns:                                                             */
/*      flOK                - success                                   */ 
/*      flDriveNotAvailable - DiskOnChip ASIC was not found             */
/*      flUnknownMedia      - Failed in Flash chips recognition         */
/*      flBadDownload       - MdocPlus device has unrecoverable         */  
/*                            protection violation.                     */
/*      flHWProtection      - HW protection violation.                  */ 
/*      flTimedOut          - Flash delay not long enough.              */
/*----------------------------------------------------------------------*/

FLStatus bdkWriteAndLockOtp(const byte FAR1 * buffer,word length)
{
   dword temp;

   checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
   if (bdkVol->flash->writeOTP == NULL)
      return flFeatureNotSupported;
   return(bdkVol->flash->writeOTP(bdkVol->flash,buffer,length));
}
#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                        b d k G e t O t p S i z e                     */
/*                                                                      */
/* Returns the size and state of the OTP area.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      sectionSize : Total OTP size.                                   */
/*      usedSize    : Used OTP size.                                    */
/*      locked      : Lock state (LOCKED_OTP for locked).               */
/*                                                                      */
/* Returns:                                                             */
/*      flOK                - success                                   */ 
/*      flDriveNotAvailable - DiskOnChip ASIC was not found             */
/*      flUnknownMedia      - Failed in Flash chips recognition         */
/*      flBadDownload       - MdocPlus device has unrecoverable         */  
/*                            protection violation.                     */
/*      flHWProtection      - HW read protection violation.             */ 
/*      flTimedOut          - Flash delay not long enough.              */
/*----------------------------------------------------------------------*/

FLStatus bdkGetOtpSize(dword FAR2* sectionSize, dword FAR2* usedSize, word FAR2* locked)
{
   dword temp;

   checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
   if (bdkVol->flash->otpSize == NULL)
      return flFeatureNotSupported;
   return(bdkVol->flash->otpSize(bdkVol->flash,sectionSize,usedSize,locked));
}
#endif /* HW_OTP */
#ifdef BDK_ACCESS

/*----------------------------------------------------------------------*/
/*                     b d k C a l l                                    */
/*                                                                      */
/* Common entry-point to all binary partition functions.                */
/*                                                                      */
/* Note : the error codes and global variable changed by this routin    */
/* depened on the functionNo parameter and can be deduced from the      */
/* coresponding routine in the BDK package or from the OSAK manual      */
/*                                                                      */
/* Parameters:                                                          */
/*     functionNo : file-system function code (listed below)            */
/*     ioreq        : IOreq structure                                   */
/*      flash      : flash record supplied hardware information and     */
/*               flash access routines                                  */
/* Returns:                                                             */
/*     FLStatus     : 0 on success, otherwise failed                    */
/*                                                                      */
/* Routine for OSAK package.                                            */
/*----------------------------------------------------------------------*/

FLStatus bdkCall(FLFunctionNo functionNo, IOreq FAR2 *ioreq, FLFlash* flash)
{
  FLStatus     status;
  BDKStruct*     bdkParam = (BDKStruct*)ioreq->irData;
  byte volNo;

  globalSocketNo     = FL_GET_SOCKET_FROM_HANDLE(ioreq);
  globalPartitionNo  = FL_GET_PARTITION_FROM_HANDLE(ioreq);

     /* convert drive handle to the appropriate binary partition record */

  if (globalSocketNo>SOCKETS)
    return flBadDriveHandle;
  if (globalPartitionNo>MAX_BINARY_PARTITIONS_PER_DRIVE)
    return flBadDriveHandle;

  volNo = handleTable[globalSocketNo][globalPartitionNo];

  if (volNo!=BDK_INVALID_VOLUME_HANDLE) /* not first access to this device */
  {
     bdkVol = &bdkVols[volNo];
  }
  else       /* first access to this device */
  {
     bdkVol                  = &bdkVols[noOfPartitions];
     bdkVol->flash           = flash;
     bdkVol->bdkGlobalStatus = BDK_S_DOC_FOUND;
  }

#ifdef VERIFY_WRITE
  /* Set binary partition verify write state */
  flash->socket->verifyWrite = flVerifyWrite[globalSocketNo][globalPartitionNo+MAX_TL_PARTITIONS];
#endif /* VERIFY_WRITE */

  /* Call the proper binary partition function */

  switch (functionNo)
  {
     case FL_BINARY_READ_INIT:

        bdkVol->bdkEDC = bdkParam->flags & EDC;
        bdkVol->bdkSignOffset = bdkParam->signOffset;
        return bdkCopyBootAreaInit((word)bdkParam->startingBlock,
                                   bdkParam->length,bdkParam->oldSign);
     case FL_BINARY_READ_BLOCK:

        return bdkCopyBootAreaBlock(bdkParam->bdkBuffer,
                                    (word)bdkParam->length,NULL);

     case FL_BINARY_PARTITION_INFO:
     {
        dword unitSize;

#ifndef NT5PORT
		int volNo;
#else /*NT5PORT*/
        int nIndex;
#endif /*NT5PORT*/

        status = bdkGetBootPartitionInfo((word)bdkParam->startingBlock,
                 &(bdkParam->startingBlock), &(bdkParam->length),&unitSize,
                 bdkParam->oldSign);
        ioreq->irLength = (long)(bdkVol->endPartitionBlock -
                          bdkVol->startPartitionBlock + 1)<<(long)bdkVol->flash->erasableBlockSizeBits;
        bdkParam->flags = 0;

#ifndef NT5PORT
        for (volNo = 0;volNo < MAX_BINARY_PARTITIONS_PER_DRIVE;volNo++)
        {
           if (handleTable[globalSocketNo][volNo]!=
                          BDK_INVALID_VOLUME_HANDLE)
           bdkParam->flags++;
        }
#else /*NT5PORT*/
        for (nIndex = 0;nIndex < MAX_BINARY_PARTITIONS_PER_DRIVE; nIndex++)
        {
           if (handleTable[globalSocketNo][nIndex]!=
                          BDK_INVALID_VOLUME_HANDLE)
           bdkParam->flags++;
        }
#endif /*NT5PORT*/

        return status;
     }
#ifdef UPDATE_BDK_IMAGE

     case FL_BINARY_WRITE_INIT:
     bdkVol->bdkEDC        = bdkParam->flags & EDC;
     bdkVol->bdkSignOffset = bdkParam->signOffset;
     return bdkUpdateBootAreaInit((word)bdkParam->startingBlock, bdkParam->length,
                         bdkParam->flags , bdkParam->oldSign);
     case FL_BINARY_WRITE_BLOCK:
     if (bdkParam->flags & ERASE_BEFORE_WRITE)
     {
        bdkVol->updateImageFlag |= ERASE_BEFORE_WRITE;
     }
     else
     {
        bdkVol->updateImageFlag &= ~ ERASE_BEFORE_WRITE;
     }
     return bdkUpdateBootAreaBlock(bdkParam->bdkBuffer, (word)bdkParam->length);

#ifdef CREATE_BDK_IMAGE
     case FL_BINARY_CREATE:

       bdkVol->bdkSignOffset = bdkParam->signOffset;
       return bdkCreateBootArea((word)bdkParam->length,bdkParam->oldSign,
                    bdkParam->newSign);
#endif /* CREATE_BDK_IMAGE */
#ifdef ERASE_BDK_IMAGE

     case FL_BINARY_ERASE:

       bdkVol->bdkSignOffset = bdkParam->signOffset;
       return bdkEraseBootArea((word)bdkParam->startingBlock,(word)bdkParam->length,
                      bdkParam->oldSign);
#endif /* ERASE_BDK_IMAGE */
#endif /* UPDATE_BDK_IMAGE */
#ifdef PROTECT_BDK_IMAGE
     case FL_BINARY_PROTECTION_GET_TYPE:
        {
           word tmpFlags;
           checkStatus ( bdkGetProtectionType    (&tmpFlags));
           ioreq->irFlags = (unsigned) tmpFlags;
           return flOK;  
        }             

     case FL_BINARY_PROTECTION_SET_TYPE:
        return bdkSetProtectionType    ((word)ioreq->irFlags);

     case FL_BINARY_PROTECTION_INSERT_KEY:
        return bdkInsertKey            ((byte FAR1*)ioreq->irData);

     case FL_BINARY_PROTECTION_REMOVE_KEY:
        return bdkRemoveKey            ();

     case FL_BINARY_PROTECTION_CHANGE_KEY:
        return bdkChangeKey            ((byte FAR1*)ioreq->irData);

     case FL_BINARY_PROTECTION_CHANGE_LOCK:
        return bdkLockEnable           ((byte)ioreq->irFlags);
#endif /* PROTECT_BDK_IMAGE */
     default:     /* not a binary partition routine */
     return flBadFunction;
  }
}
#endif /* BDK_ACCESS */

#endif /* BDK_ACCESS || MTD_STANDALONE || ACCESS_BDK_IMAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\cfiscs.c ===
/*
 * $Log:   P:/user/amir/lite/vcs/cfiscs.c_v  $
 *
 *    Rev 1.19	 06 Oct 1997  9:53:30	danig
 * VPP functions under #ifdef
 *
 *    Rev 1.18	 18 Sep 1997 10:05:40	danig
 * Warnings
 *
 *    Rev 1.17	 10 Sep 1997 16:31:16	danig
 * Got rid of generic names
 *
 *    Rev 1.16	 04 Sep 1997 18:19:34	danig
 * Debug messages
 *
 *    Rev 1.15	 31 Aug 1997 14:50:52	danig
 * Registration routine return status
 *
 *    Rev 1.14	 27 Jul 1997 15:00:38	danig
 * FAR -> FAR0
 *
 *    Rev 1.13	 21 Jul 1997 19:58:24	danig
 * No watchDogTimer
 *
 *    Rev 1.12	 15 Jul 1997 19:18:32	danig
 * Ver 2.0
 *
 *    Rev 1.11	 09 Jul 1997 10:58:52	danig
 * Fixed byte erase bug & changed identification routines
 *
 *    Rev 1.10	 20 May 1997 14:48:02	danig
 * Changed overwrite to mode in write routines
 *
 *    Rev 1.9	18 May 1997 13:54:58   danig
 * JEDEC ID independent
 *
 *    Rev 1.8	13 May 1997 16:43:10   danig
 * Added getMultiplier.
 *
 *    Rev 1.7	08 May 1997 19:56:12   danig
 * Added cfiscsByteSize
 *
 *    Rev 1.6	04 May 1997 14:01:16   danig
 * Changed cfiscsByteErase and added multiplier
 *
 *    Rev 1.4	15 Apr 1997 11:38:52   danig
 * Changed word identification and IDs.
 *
 *    Rev 1.3	15 Jan 1997 18:21:40   danig
 * Bigger ID string buffers and removed unused definitions.
 *
 *    Rev 1.2	08 Jan 1997 14:54:06   danig
 * Changes in specification
 *
 *    Rev 1.1	25 Dec 1996 18:21:44   danig
 * Initial revision
 */

/************************************************************************/
/*									*/
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1997			*/
/*									*/
/************************************************************************/


/*----------------------------------------------------------------------*/
/* This MTD supports the SCS/CFI technology.				*/
/*----------------------------------------------------------------------*/

#include "flflash.h"
#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif

/* JEDEC-IDs */

#define VOYAGER_ID		0x8915
#define KING_COBRA_ID		0xb0d0

/* command set IDs */

#define INTEL_COMMAND_SET      0x0001
#define AMDFUJ_COMMAND_SET     0x0002
#define INTEL_ALT_COMMAND_SET  0x0001
#define AMDFUJ_ALT_COMMAND_SET 0x0004
#define ALT_NOT_SUPPORTED      0x0000


/* CFI identification strings */

#define ID_STR_LENGTH	   3
#define QUERY_ID_STR	   "QRY"
#define PRIMARY_ID_STR	   "PRI"
#define ALTERNATE_ID_STR   "ALT"


/* commands */

#define CONFIRM_SET_LOCK_BIT	0x01
#define SETUP_BLOCK_ERASE	0x20
#define SETUP_QUEUE_ERASE	0x28
#define SETUP_CHIP_ERASE	0x30
#define CLEAR_STATUS		0x50
#define SET_LOCK_BIT		0x60
#define CLEAR_LOCK_BIT		0x60
#define READ_STATUS		0x70
#define READ_ID 		0x90
#define QUERY			0x98
#define SUSPEND_WRITE		0xb0
#define SUSPEND_ERASE		0xb0
#define CONFIG			0xb8
#define CONFIRM_WRITE		0xd0
#define RESUME_WRITE		0xd0
#define CONFIRM_ERASE		0xd0
#define RESUME_ERASE		0xd0
#define CONFIRM_CLEAR_LOCK_BIT	0xd0
#define WRITE_TO_BUFFER 	0xe8
#define READ_ARRAY		0xff


/* status register bits */

#define WSM_ERROR		0x3a
#define SR_BLOCK_LOCK		0x02
#define SR_WRITE_SUSPEND	0x04
#define SR_VPP_ERROR		0x08
#define SR_WRITE_ERROR		0x10
#define SR_LOCK_SET_ERROR	0x10
#define SR_ERASE_ERROR		0x20
#define SR_LOCK_RESET_ERROR	0x20
#define SR_ERASE_SUSPEND	0x40
#define SR_READY		0x80


/* optional commands support */

#define CHIP_ERASE_SUPPORT	     0x0001
#define SUSPEND_ERASE_SUPPORT	     0x0002
#define SUSPEND_WRITE_SUPPORT	     0x0004
#define LOCK_SUPPORT		     0x0008
#define QUEUED_ERASE_SUPPORT	     0x0010


/* supported functions after suspend */

#define WRITE_AFTER_SUSPEND_SUPPORT  0x0001


/* a structure that hold important CFI data. */
typedef struct {

  ULONG 	commandSetId;		 /* id of a specific command set. */
  ULONG 	altCommandSetId;	    /* id of alternate command set.  */
  FLBoolean	   wordMode;		    /* TRUE - word mode.	     */
					    /* FALSE - byte mode.	     */
  LONG		   multiplier;		    /* the number of times each byte */
					    /* of data appears in READ_ID    */
					    /* and QUERY commands.	     */
  ULONG 	maxBytesWrite;		    /* maximum number of bytes	     */
					    /* in multi-byte write.	     */
  FLBoolean	   vpp; 		    /* if = TRUE, need vpp.	     */
  LONG		   optionalCommands;	    /* optional commands supported   */
					    /* (1 = yes, 0 = no):	     */
					    /* bit 0 - chip erase.	     */
					    /* bit 1 - suspend erase.	     */
					    /* bit 2 - suspend write	     */
					    /* bit 3 - lock/unlock.	     */
					    /* bit 4 - queued erase.	     */
  ULONG    afterSuspend;	    /* functions supported after     */
					    /* suspend (1 = yes, 0 = no):    */
					    /* bit 0 - write after erase     */
					    /*	       suspend. 	     */
} CFI;

CFI mtdVars_cfiscs[SOCKETS];

#define thisCFI   ((CFI *)vol.mtdVars)

/*----------------------------------------------------------------------*/
/*			    c f i s c s B y t e S i z e 		*/
/*									*/
/* Identify the card size for byte mode.				*/
/* Sets the value of flash.noOfChips.					*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	amdCmdRoutine	: Routine to read-id AMD/Fujitsu style at	*/
/*			  a specific location. If null, Intel procedure */
/*			  is used.					*/
/*	idOffset	: Chip offset to use for identification 	*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/

FLStatus cfiscsByteSize(FLFlash vol)
{
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;

  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket, 0);
  tffsWriteByteFlash(flashPtr + (0x55 * vol.interleaving), QUERY);
  /* We leave the first chip in QUERY mode, so that we can		*/
  /* discover an address wraparound.					*/

  for (vol.noOfChips = 0;	/* Scan the chips */
       vol.noOfChips < 2000;  /* Big enough ? */
       vol.noOfChips += vol.interleaving) {
    LONG i;

    flashPtr = (FlashPTR) flMap(vol.socket, vol.noOfChips * vol.chipSize);

    /* Check for address wraparound to the first chip */
    if (vol.noOfChips > 0 &&
	(queryIdStr[0] == tffsReadByteFlash(flashPtr +
			  0x10 * vol.interleaving * thisCFI->multiplier) &&
	 queryIdStr[1] == tffsReadByteFlash(flashPtr +
			  0x11 * vol.interleaving * thisCFI->multiplier) &&
	 queryIdStr[2] == tffsReadByteFlash(flashPtr +
			  0x12 * vol.interleaving * thisCFI->multiplier)))
      goto noMoreChips;    /* wraparound */

    /* Check if chip displays the "QRY" ID string */
    for (i = (vol.noOfChips ? 0 : 1); i < vol.interleaving; i++) {
       tffsWriteByteFlash(flashPtr + vol.interleaving * 0x55 + i, QUERY);
       if (queryIdStr[0] != tffsReadByteFlash(flashPtr +
			    0x10 * vol.interleaving * thisCFI->multiplier + i) ||
	   queryIdStr[1] != tffsReadByteFlash(flashPtr +
			    0x11 * vol.interleaving * thisCFI->multiplier + i) ||
	   queryIdStr[2] != tffsReadByteFlash(flashPtr +
			    0x12 * vol.interleaving * thisCFI->multiplier + i))
	goto noMoreChips;  /* This "chip" doesn't respond correctly, so we're done */

      tffsWriteByteFlash(flashPtr+i, READ_ARRAY);
    }
  }

noMoreChips:
  flashPtr = (FlashPTR) flMap(vol.socket, 0);
  tffsWriteByteFlash(flashPtr, READ_ARRAY);		/* reset the original chip */

  return (vol.noOfChips == 0) ? flUnknownMedia : flOK;
}


/*----------------------------------------------------------------------*/
/*			 c f i s c s B y t e I d e n t i f y		*/
/*									*/
/* Identify the Flash type for cards in byte mode.			*/
/* Sets the value of flash.type (JEDEC id) & flash.interleaving.	*/
/* Calculate the number of times each byte of data appears in READ_ID	*/
/* and QUERY commands.							*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsByteIdentify(FLFlash vol)
{
  LONG inlv, mul;
  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket, 0);

  for (inlv = 1; inlv <= 8; inlv++) /* let us assume that interleaving is 8 */
    tffsWriteByteFlash(flashPtr+inlv, READ_ARRAY);    /* and reset all the interleaved chips  */

  for (inlv = 1; inlv <= 8; inlv++) {
    for (mul = 1; mul <= 8; mul++) {   /* try all possibilities */
      LONG letter;

      tffsWriteByteFlash(flashPtr + 0x55 * inlv, QUERY);

      for (letter = 0; letter < ID_STR_LENGTH; letter++) {  /* look for "QRY" id string */
    CHAR idChar = '?';
	LONG offset, counter;

	switch (letter) {
	  case 0:
	    idChar = 'Q';
	    break;
	  case 1:
	    idChar = 'R';
	    break;
	  case 2:
	    idChar = 'Y';
	    break;
	}

	for (counter = 0, offset = (0x10 + letter) * inlv * mul;
	     counter < mul;
	     counter++, offset += inlv)  /*  each character should appear mul times */
	  if (tffsReadByteFlash(flashPtr+offset) != idChar)
	    break;

	if (counter < mul)  /* no match */
	  break;
      }

      tffsWriteByteFlash(flashPtr + 0x55 * inlv, READ_ARRAY);  /* reset the chip */
      if (letter >= ID_STR_LENGTH)
	goto checkInlv;
    }
  }

checkInlv:

  if (inlv > 8) 		  /* too much */
    return flUnknownMedia;

  if (inlv & (inlv - 1))
    return flUnknownMedia;	    /* not a power of 2, no way ! */

  vol.interleaving = (unsigned short)inlv;
  thisCFI->multiplier = mul;
  tffsWriteByteFlash(flashPtr + 0x55 * inlv, QUERY);
  vol.type = (FlashType) ((tffsReadByteFlash(flashPtr) << 8) |
			    tffsReadByteFlash(flashPtr + inlv * thisCFI->multiplier));
  tffsWriteByteFlash(flashPtr+inlv, READ_ARRAY);

  return flOK;

}


/*----------------------------------------------------------------------*/
/*		      c f i s c s W o r d S i z e			*/
/*									*/
/* Identify the card size for a word-mode Flash array.			*/
/* Sets the value of flash.noOfChips.					*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsWordSize(FLFlash vol)
{
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;

  FlashWPTR flashPtr = (FlashWPTR) flMap(vol.socket, 0);
  tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
  tffsWriteWordFlash(flashPtr+0x55, QUERY);
  /* We leave the first chip in QUERY mode, so that we can		*/
  /* discover an address wraparound.					*/

  for (vol.noOfChips = 1;	/* Scan the chips */
       vol.noOfChips < 2000;  /* Big enough ? */
       vol.noOfChips++) {
    flashPtr = (FlashWPTR) flMap(vol.socket, vol.noOfChips * vol.chipSize);

    if ((tffsReadWordFlash(flashPtr+0x10) == (USHORT)queryIdStr[0]) &&
	(tffsReadWordFlash(flashPtr+0x11) == (USHORT)queryIdStr[1]) &&
	(tffsReadWordFlash(flashPtr+0x12) == (USHORT)queryIdStr[2]))
      break;	  /* We've wrapped around to the first chip ! */

    tffsWriteWordFlash(flashPtr+0x55, QUERY);
    if ((tffsReadWordFlash(flashPtr+0x10) != (USHORT)queryIdStr[0]) ||
	(tffsReadWordFlash(flashPtr+0x11) != (USHORT)queryIdStr[1]) ||
	(tffsReadWordFlash(flashPtr+0x12) != (USHORT)queryIdStr[2]))
      break;

    tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }

  flashPtr = (FlashWPTR) flMap(vol.socket, 0);
  tffsWriteWordFlash(flashPtr, READ_ARRAY);

  return flOK;
}

/*----------------------------------------------------------------------*/
/*		      g e t B y t e C F I				*/
/*									*/
/* Load important CFI data to the CFI structure in a byte-mode. 	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed.			*/
/*----------------------------------------------------------------------*/

FLStatus getByteCFI(FLFlash vol)
{
  ULONG primaryTable, secondaryTable;
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;
  CHAR priIdStr[ID_STR_LENGTH + 1] = PRIMARY_ID_STR;
  FlashPTR flashPtr;

  DEBUG_PRINT(("Debug: reading CFI for byte mode.\n"));

  flashPtr = (FlashPTR)flMap(vol.socket, 0);
  tffsWriteByteFlash(flashPtr + 0x55 * vol.interleaving, QUERY);

  vol.interleaving *= (unsigned short)thisCFI->multiplier; /* jump over the copies of the
						same byte */

  /* look for the query identification string "QRY" */
  if (queryIdStr[0] != tffsReadByteFlash(flashPtr + 0x10 * vol.interleaving) ||
      queryIdStr[1] != tffsReadByteFlash(flashPtr + 0x11 * vol.interleaving) ||
      queryIdStr[2] != tffsReadByteFlash(flashPtr + 0x12 * vol.interleaving)) {
    DEBUG_PRINT(("Debug: did not recognize CFI.\n"));
    return flUnknownMedia;
  }

  /* check the command set ID */
  thisCFI->commandSetId = tffsReadByteFlash(flashPtr +0x13 * vol.interleaving) |
			  ((ULONG)tffsReadByteFlash(flashPtr + 0x14 * vol.interleaving) << 8);
  if (thisCFI->commandSetId != INTEL_COMMAND_SET &&
      thisCFI->commandSetId != AMDFUJ_COMMAND_SET) {
    DEBUG_PRINT(("Debug: did not recognize command set.\n"));
    return flUnknownMedia;
  }
  /* get address for primary algorithm extended table. */
  primaryTable = tffsReadByteFlash(flashPtr + 0x15 * vol.interleaving) |
		 ((ULONG)tffsReadByteFlash(flashPtr + 0x16 * vol.interleaving) << 8);

  /* check alternate command set ID. */
  thisCFI->altCommandSetId = tffsReadByteFlash(flashPtr + 0x17 * vol.interleaving) |
			     ((ULONG)tffsReadByteFlash(flashPtr + 0x18 * vol.interleaving) << 8);
  if (thisCFI->altCommandSetId != INTEL_ALT_COMMAND_SET &&
      thisCFI->altCommandSetId != AMDFUJ_ALT_COMMAND_SET &&
      thisCFI->altCommandSetId != ALT_NOT_SUPPORTED)
    return flUnknownMedia;

  /* get address for secondary algorithm extended table. */
  secondaryTable = tffsReadByteFlash(flashPtr + 0x19 * vol.interleaving) |
		   ((ULONG)tffsReadByteFlash(flashPtr + 0x1a * vol.interleaving) << 8);

  thisCFI->vpp = tffsReadByteFlash(flashPtr + 0x1d * vol.interleaving);

  vol.chipSize = 1L << tffsReadByteFlash(flashPtr + 0x27 * vol.interleaving);

  thisCFI->maxBytesWrite = 1L << (tffsReadByteFlash(flashPtr + 0x2a * vol.interleaving) |
			   ((ULONG)tffsReadByteFlash(flashPtr + 0x2b * vol.interleaving) << 8));


  /* divide by multiplier because interleaving is multiplied by multiplier */
  vol.erasableBlockSize = (tffsReadByteFlash(flashPtr + 0x2f * vol.interleaving) |
			    ((ULONG)tffsReadByteFlash(flashPtr + 0x30 * vol.interleaving)) << 8) *
			    0x100L * vol.interleaving / thisCFI->multiplier;

  /* In this part we access the primary extended table implemented by Intel.
     If the device uses a different extended table, it should be accessed
     according to the vendor specifications. */
  if ((primaryTable) && (thisCFI->commandSetId == INTEL_COMMAND_SET)) {
    /* look for the primary table identification string "PRI" */
    if (priIdStr[0] != tffsReadByteFlash(flashPtr + primaryTable * vol.interleaving) ||
	priIdStr[1] != tffsReadByteFlash(flashPtr + (primaryTable + 1) * vol.interleaving) ||
	priIdStr[2] != tffsReadByteFlash(flashPtr + (primaryTable + 2) * vol.interleaving))
      return flUnknownMedia;

    thisCFI->optionalCommands = tffsReadByteFlash(flashPtr + (primaryTable + 5) * vol.interleaving) |
				((LONG)tffsReadByteFlash(flashPtr + (primaryTable + 6) *
						  vol.interleaving) << 8) |
				((LONG)tffsReadByteFlash(flashPtr + (primaryTable + 7) *
						  vol.interleaving) << 16) |
				((LONG)tffsReadByteFlash(flashPtr + (primaryTable + 8) *
						  vol.interleaving) << 24);

    thisCFI->afterSuspend = tffsReadByteFlash(flashPtr + (primaryTable + 9) * vol.interleaving);
  }
  else {
    thisCFI->optionalCommands = 0;
    thisCFI->afterSuspend = 0;
  }

  tffsWriteByteFlash(flashPtr, READ_ARRAY);

  vol.interleaving /= (unsigned short)thisCFI->multiplier; /* return to the real interleaving*/

  return flOK;
}

/*----------------------------------------------------------------------*/
/*		      g e t W o r d C F I				*/
/*									*/
/* Load important CFI data to the CFI structure in a word-mode. 	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed.			*/
/*----------------------------------------------------------------------*/

FLStatus getWordCFI(FLFlash vol)
{
  ULONG primaryTable, secondaryTable;
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;
  CHAR priIdStr[ID_STR_LENGTH + 1] = PRIMARY_ID_STR;
  FlashWPTR flashPtr;

  DEBUG_PRINT(("Debug: reading CFI for word mode.\n"));

  flashPtr = (FlashWPTR)flMap(vol.socket, 0);
  tffsWriteWordFlash(flashPtr+0x55, QUERY);

  /* look for the query identification string "QRY" */
  if (queryIdStr[0] != (CHAR)tffsReadWordFlash(flashPtr+0x10) ||
      queryIdStr[1] != (CHAR)tffsReadWordFlash(flashPtr+0x11) ||
      queryIdStr[2] != (CHAR)tffsReadWordFlash(flashPtr+0x12)) {
    DEBUG_PRINT(("Debug: did not recognize CFI.\n"));
    return flUnknownMedia;
  }

  /* check the command set ID */
  thisCFI->commandSetId = tffsReadWordFlash(flashPtr+0x13) |
			 (tffsReadWordFlash(flashPtr+0x14) << 8);
  if (thisCFI->commandSetId != INTEL_COMMAND_SET &&
      thisCFI->commandSetId != AMDFUJ_COMMAND_SET) {
    DEBUG_PRINT(("Debug: did not recognize command set.\n"));
    return flUnknownMedia;
  }

  /* get address for primary algorithm extended table. */
  primaryTable = tffsReadWordFlash(flashPtr+0x15) |
		(tffsReadWordFlash(flashPtr+0x16) << 8);

  /* check alternate command set ID. */
  thisCFI->altCommandSetId = tffsReadWordFlash(flashPtr+0x17) |
			    (tffsReadWordFlash(flashPtr+0x18) << 8);
  if (thisCFI->altCommandSetId != INTEL_ALT_COMMAND_SET &&
      thisCFI->altCommandSetId != AMDFUJ_ALT_COMMAND_SET &&
      thisCFI->altCommandSetId != ALT_NOT_SUPPORTED)
    return flUnknownMedia;

  /* get address for secondary algorithm extended table. */
  secondaryTable = tffsReadWordFlash(flashPtr+0x19) |
		  (tffsReadWordFlash(flashPtr+0x1a) << 8);

  thisCFI->vpp = tffsReadWordFlash(flashPtr+0x1d);

  vol.chipSize = 1L << tffsReadWordFlash(flashPtr+0x27);

  thisCFI->maxBytesWrite = 1L << (tffsReadWordFlash(flashPtr+0x2a) |
				 (tffsReadWordFlash(flashPtr+0x2b) << 8));

  vol.erasableBlockSize = (tffsReadWordFlash(flashPtr+0x2f) |
			  (tffsReadWordFlash(flashPtr+0x30) << 8)) * 0x100L;

  /* In this part we access the primary extended table implemented by Intel.
     If the device uses a different extended table, it should be accessed
     according to the vendor specifications. */
  if ((primaryTable) && (thisCFI->commandSetId == INTEL_COMMAND_SET)) {
    /* look for the primary table identification string "PRI" */
    if (priIdStr[0] != (CHAR)tffsReadWordFlash(flashPtr+primaryTable) ||
	priIdStr[1] != (CHAR)tffsReadWordFlash(flashPtr+primaryTable + 1) ||
	priIdStr[2] != (CHAR)tffsReadWordFlash(flashPtr+primaryTable + 2))
      return flUnknownMedia;

    thisCFI->optionalCommands = tffsReadWordFlash(flashPtr+primaryTable + 5) |
				(tffsReadWordFlash(flashPtr+primaryTable + 6) << 8) |
				((LONG)tffsReadWordFlash(flashPtr+primaryTable + 7) << 16) |
				((LONG)tffsReadWordFlash(flashPtr+primaryTable + 8) << 24);

    thisCFI->afterSuspend = tffsReadWordFlash(flashPtr+primaryTable + 9);
  }
  else {
    thisCFI->optionalCommands = 0;
    thisCFI->afterSuspend = 0;
  }

  tffsWriteWordFlash(flashPtr, READ_ARRAY);

  return flOK;
}

/*----------------------------------------------------------------------*/
/*			c f i s c s B y t e W r i t e			*/
/*									*/
/* Write a block of bytes to Flash in a byte-mode.			*/
/*									*/
/* This routine will be registered as the MTD flash.write routine	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	mode		: write mode (overwrite yes/no) 		*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsByteWrite(FLFlash vol,
				CardAddress address,
				const VOID FAR1 *buffer,
				dword length,
				word mode)
{
  FLStatus status = flOK;
  FlashPTR flashPtr;
  ULONG i, from, eachWrite;
  const CHAR FAR1 *temp = (const CHAR FAR1 *)buffer;
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    checkStatus(flNeedVpp(vol.socket));
#endif

  if (thisCFI->maxBytesWrite > 1) /* multi-byte write supported */
    eachWrite = thisCFI->maxBytesWrite * vol.interleaving;
  else
    eachWrite = vol.interleaving;

  for (from = 0; from < (ULONG) length && status == flOK; from += eachWrite) {
    LONG thisLength = length - from;
    FlashPTR currPtr;
    ULONG tailBytes, lengthByte;
    CHAR FAR1 *fromPtr;
    UCHAR byteToWrite;

    if ((ULONG)thisLength > eachWrite)
      thisLength = eachWrite;

    lengthByte = thisLength / vol.interleaving;
    tailBytes = thisLength % vol.interleaving;

    flashPtr = (FlashPTR) flMap(vol.socket, address + from);

    for (i = 0, currPtr = flashPtr;
	 i < (ULONG) vol.interleaving && i < (ULONG) thisLength;
	 i++, currPtr++) {
      do {
	tffsWriteByteFlash(currPtr, WRITE_TO_BUFFER);
      } while (!(tffsReadByteFlash(currPtr) & SR_READY) && (flMsecCounter < writeTimeout));
      if (!(tffsReadByteFlash(currPtr) & SR_READY)) {
	DEBUG_PRINT(("Debug: timeout error in CFISCS write.\n"));
	status = flWriteFault;
      }
      byteToWrite = i < tailBytes ? (UCHAR) lengthByte : (UCHAR) (lengthByte - 1);
      tffsWriteByteFlash(currPtr, byteToWrite);
    }

    for(i = 0, currPtr = flashPtr,fromPtr = (CHAR *)temp + from;
	i < (ULONG) thisLength;
	i++, flashPtr++, fromPtr++)
      tffsWriteByteFlash(currPtr, *fromPtr);


    for (i = 0, currPtr = flashPtr;
	 i < (ULONG) vol.interleaving && i < (ULONG) thisLength;
	 i++, currPtr++)
      tffsWriteByteFlash(currPtr, CONFIRM_WRITE);

    for (i = 0, currPtr = flashPtr;
	 i < (ULONG) vol.interleaving && i < (ULONG) thisLength;
	 i++, currPtr++) {
      while (!(tffsReadByteFlash(currPtr) & SR_READY) && (flMsecCounter < writeTimeout))
	;
      if (!(tffsReadByteFlash(currPtr) & SR_READY)) {
	DEBUG_PRINT(("Debug: timeout error in CFISCS write.\n"));
	status = flWriteFault;
      }
      if (tffsReadByteFlash(currPtr) & WSM_ERROR) {
	DEBUG_PRINT(("Debug: error in CFISCS write.\n"));
	status = (tffsReadByteFlash(currPtr) & SR_VPP_ERROR) ? flVppFailure : flWriteFault;
	tffsWriteByteFlash(currPtr, CLEAR_STATUS);
      }
      tffsWriteByteFlash(currPtr, READ_ARRAY);
    }
  }

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    flDontNeedVpp(vol.socket);
#endif

  flashPtr = (FlashPTR) flMap(vol.socket, address);
  /* verify the data */
  if (status == flOK) {
    for(i = 0; i < (ULONG) length - 4; i += 4) {
      if (tffsReadDwordFlash((PUCHAR)(flashPtr+i)) != *(ULONG *)(temp+i)) {
	DEBUG_PRINT(("Debug: CFISCS write failed in verification.\n"));
	status = flWriteFault;
      }
    }
    for(; i < (ULONG) length; i++) {
      if (tffsReadByteFlash(flashPtr+i) != *(UCHAR *)(temp+i)) {
	DEBUG_PRINT(("Debug: CFISCS write failed in verification.\n"));
	status = flWriteFault;
      }
    }
  }

  return status;

}

/*----------------------------------------------------------------------*/
/*			c f i s c s W o r d W r i t e			*/
/*									*/
/* Write a block of bytes to Flash in a word-mode.			*/
/*									*/
/* This routine will be registered as the MTD flash.write routine	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	mode		: write mode (overwrite yes/no) 		*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsWordWrite(FLFlash vol,
				CardAddress address,
				const VOID FAR1 *buffer,
				dword length,
				word mode)
{
  FLStatus status = flOK;
  FlashPTR byteFlashPtr;
  FlashWPTR flashPtr;
  ULONG from;
	ULONG i, eachWrite;
  const CHAR FAR1 *temp = (const CHAR FAR1 *)buffer;
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  if ((length & 1) || (address & 1))	/* Only write words on word-boundary */
    return flBadParameter;

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    checkStatus(flNeedVpp(vol.socket));
#endif

  if (thisCFI->maxBytesWrite > 1) /* multi-byte write supported */
    eachWrite = thisCFI->maxBytesWrite / 2;   /* we are counting words */
  else
    eachWrite = 1;

  /* we assume that the interleaving is 1. */
  for (from = 0; (from < length / 2) && (status == flOK); from += eachWrite) {
    USHORT *fromPtr;
    ULONG thisLength = (length / 2) - from;

    if (thisLength > eachWrite)
      thisLength = eachWrite;

    flashPtr = (FlashWPTR)flMap(vol.socket, address + from * 2);

    do {
      tffsWriteWordFlash(flashPtr, WRITE_TO_BUFFER);
    } while (!(tffsReadByteFlash(flashPtr) & SR_READY) && (flMsecCounter < writeTimeout));
    if (!(tffsReadByteFlash(flashPtr) & SR_READY)) {
      DEBUG_PRINT(("Debug: timeout error in CFISCS write.\n"));
      status = flWriteFault;
    }
    tffsWriteWordFlash(flashPtr, (USHORT) (thisLength - 1));

    for(i = 0, fromPtr = (USHORT *)(temp + from * 2);
	i < thisLength;
	i++, fromPtr++)
      tffsWriteWordFlash(flashPtr + i, *fromPtr);


    tffsWriteWordFlash(flashPtr, CONFIRM_WRITE);

    while (!(tffsReadByteFlash(flashPtr) & SR_READY) && (flMsecCounter < writeTimeout))
      ;
    if (!(tffsReadByteFlash(flashPtr) & SR_READY)) {
      DEBUG_PRINT(("Debug: timeout error in CFISCS write.\n"));
      status = flWriteFault;
    }
    if (tffsReadByteFlash(flashPtr) & WSM_ERROR) {
      DEBUG_PRINT(("Debug: CFISCS write error.\n"));
      status = (tffsReadByteFlash(flashPtr) & SR_VPP_ERROR) ? flVppFailure : flWriteFault;
      tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
    }
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    flDontNeedVpp(vol.socket);
#endif

  byteFlashPtr = (FlashPTR) flMap(vol.socket, address);
  /* verify the data */
  if (status == flOK) {
    for(i = 0; i < length - 4; i += 4) {
      if (tffsReadDwordFlash((PUCHAR)(byteFlashPtr+i)) != *(ULONG *)(temp+i)) {
	DEBUG_PRINT(("Debug: CFISCS write failed in verification.\n"));
	status = flWriteFault;
      }
    }
    for(; i < length; i++) {
      if (tffsReadByteFlash(byteFlashPtr+i) != *(UCHAR *)(temp+i)) {
	DEBUG_PRINT(("Debug: CFISCS write failed in verification.\n"));
	status = flWriteFault;
      }
    }
  }

  return status;
}


/************************************************************************/
/*		  Auxiliary routines for cfiscsByteErase		*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*			m a k e C o m m a n d				*/
/*									*/
/* Create a command to write to the flash. This routine is used for	*/
/* byte mode, write command to the relevant chip and 0xff to the other	*/
/* chip if interleaving is greater than 1, or write the command if	*/
/* interleaving is 1.							*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	command 	: Command to be written to the media		*/
/*	chip		: first chip (0) or second chip (1)		*/
/*									*/
/* Returns:								*/
/*	The command that should be written to the media 		*/
/*----------------------------------------------------------------------*/

USHORT makeCommand(FLFlash vol, USHORT command, LONG chip)
{
  if ((vol.interleaving == 1) || (chip == 0))
    return command | 0xff00;
  else
    return (command << 8) | 0xff;
}

/*----------------------------------------------------------------------*/
/*			g e t D a t a					*/
/*									*/
/* Read the lower byte or the upper byte from a given word.		*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	wordData	: the given word				*/
/*	chip		: if chip = 0 read lower byte			*/
/*			  if chip = 1 read upper byte			*/
/*									*/
/* Returns:								*/
/*	The byte that was read. 					*/
/*----------------------------------------------------------------------*/

UCHAR getData(FLFlash vol, USHORT wordData, LONG chip)
{
  if ((vol.interleaving == 1) || (chip == 0))
    return (UCHAR)wordData;	     /* lower byte */
  else
    return (UCHAR)(wordData >> 8);   /* upper byte */
}

/*----------------------------------------------------------------------*/
/*			c f i s c s B y t e E r a s e			*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks in a byte-mode.	*/
/*									*/
/* This routine will be registered as the MTD flash.erase routine	*/
/*									*/
/* Parameters:								*/
/*	vol		   : Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	   : 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus cfiscsByteErase(FLFlash vol,
				word firstErasableBlock,
				word numOfErasableBlocks)
{
  LONG iBlock;
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  FLStatus status = flOK;	/* unless proven otherwise */

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    checkStatus(flNeedVpp(vol.socket));
#endif

  for (iBlock = 0; iBlock < numOfErasableBlocks && status == flOK; iBlock++) {
    LONG j;
    FLBoolean finished;

    FlashWPTR flashPtr = (FlashWPTR)
			 flMap(vol.socket, (firstErasableBlock + iBlock) * vol.erasableBlockSize);

    for (j = 0; j * 2 < vol.interleaving; j++) {  /* access chips in pairs */
      LONG i;

      for (i = 0; i < (vol.interleaving == 1 ? 1 : 2); i++) { /* write to each chip seperately */
	if (thisCFI->optionalCommands & QUEUED_ERASE_SUPPORT) {
	  do {
	    tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, SETUP_QUEUE_ERASE, i));
	  } while (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY) &&
		   (flMsecCounter < writeTimeout));
	  if (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY)) {
	    DEBUG_PRINT(("Debug: timeout error in CFISCS erase.\n"));
	    status = flWriteFault;
	  }
	  else
	    tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, CONFIRM_ERASE, i));
	}
	else {
	  tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, SETUP_BLOCK_ERASE, i));
	  tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, CONFIRM_ERASE, i));
	}
      }
    }

    do {
#ifdef FL_BACKGROUND
      if (thisCFI->optionalCommands & SUSPEND_ERASE_SUPPORT) {
	while (flForeground(1) == BG_SUSPEND) { 	 /* suspend */
	  for (j = 0; j < vol.interleaving; j += 2, flashPtr++) {
	    LONG i;

	    for (i = 0; i < (vol.interleaving == 1 ? 1 : 2); i++) {
	      tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_STATUS, i));
	      if (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY)) {
		tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, SUSPEND_ERASE, i));
		tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_STATUS, i));
		while (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY))
		;
	      }
	      tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_ARRAY, i));
	    }
	  }
	}
      }
#endif
      finished = TRUE;
      for (j = 0; j * 2 < vol.interleaving; j++) {
	LONG i;

	for (i = 0; i < (vol.interleaving == 1 ? 1 : 2); i++) {
	  tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_STATUS, i));
	  if (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY))
	    finished = FALSE;
	  else if (getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_ERASE_SUSPEND) {
	    tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, RESUME_ERASE, i));
	    finished = FALSE;
	  }
	  else {
	    if (getData(&vol, tffsReadWordFlash(flashPtr+j), i) & WSM_ERROR) {
	      DEBUG_PRINT(("Debug: CFISCS erase error.\n"));
	      status = (getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_VPP_ERROR) ?
			flVppFailure : flWriteFault;
	      tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, CLEAR_STATUS, i));
	    }
	    tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_ARRAY, i));
	  }
	}
      }
      flDelayMsecs(1);
    } while (!finished);
  }

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    flDontNeedVpp(vol.socket);
#endif

  return status;
}

/*----------------------------------------------------------------------*/
/*			c f i s c s W o r d E r a s e			*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks in a word-mode	*/
/*									*/
/* This routine will be registered as the MTD flash.erase routine	*/
/*									*/
/* Parameters:								*/
/*	vol		   : Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	   : 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsWordErase(FLFlash vol,
				word firstErasableBlock,
				word numOfErasableBlocks)
{
  FLStatus status = flOK;	/* unless proven otherwise */
  LONG iBlock;
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    checkStatus(flNeedVpp(vol.socket));
#endif

  for (iBlock = 0; iBlock < numOfErasableBlocks && status == flOK; iBlock++) {
    FLBoolean finished;

    FlashWPTR flashPtr = (FlashWPTR)
			 flMap(vol.socket,(firstErasableBlock + iBlock) * vol.erasableBlockSize);

    if (thisCFI->optionalCommands & QUEUED_ERASE_SUPPORT) {
      do {
	tffsWriteWordFlash(flashPtr, SETUP_QUEUE_ERASE);
      } while (!(tffsReadByteFlash(flashPtr) & SR_READY) && (flMsecCounter < writeTimeout));
      if (!(tffsReadByteFlash(flashPtr) & SR_READY)) {
	DEBUG_PRINT(("Debug: timeout error in CFISCS erase.\n"));
	status = flWriteFault;
      }
      else
	tffsWriteWordFlash(flashPtr, CONFIRM_ERASE);
    }
    else {
      tffsWriteWordFlash(flashPtr, SETUP_BLOCK_ERASE);
      tffsWriteWordFlash(flashPtr, CONFIRM_ERASE);
    }

    do {
#ifdef FL_BACKGROUND
      if (thisCFI->optionalCommands & SUSPEND_ERASE_SUPPORT) {
	while (flForeground(1) == BG_SUSPEND) { 	/* suspend */
	  if (!(tffsReadByteFlash(flashPtr) & SR_READY)) {
	    tffsWriteWordFlash(flashPtr, SUSPEND_ERASE);
	    tffsWriteWordFlash(flashPtr, READ_STATUS);
	    while (!(tffsReadByteFlash(flashPtr) & SR_READY))
	      ;
	  }
	  tffsWriteWordFlash(flashPtr, READ_ARRAY);
	}
      }
#endif

      finished = TRUE;

      if (!(tffsReadByteFlash(flashPtr) & SR_READY))
	finished = FALSE;
      else if (tffsReadByteFlash(flashPtr) & SR_ERASE_SUSPEND) {
	tffsWriteWordFlash(flashPtr, RESUME_ERASE);
	finished = FALSE;
      }
      else {
	if (tffsReadByteFlash(flashPtr) & WSM_ERROR) {
	  DEBUG_PRINT(("Debug: CFISCS erase error.\n"));
	  status = (tffsReadByteFlash(flashPtr) & SR_VPP_ERROR) ? flVppFailure : flWriteFault;
	  tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
	}
	tffsWriteWordFlash(flashPtr, READ_ARRAY);
      }
      flDelayMsecs(1);
    } while (!finished);
  }

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    flDontNeedVpp(vol.socket);
#endif

  return status;
}


/*----------------------------------------------------------------------*/
/*			  c f i s c s M a p				*/
/*									*/
/* Map through buffer. This routine will be registered as the map	*/
/* routine for this MTD.						*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Flash address to be mapped.				*/
/*	length	: number of bytes to map.				*/
/*									*/
/* Returns:								*/
/*	Pointer to the buffer data was mapped to.			*/
/*									*/
/*----------------------------------------------------------------------*/

VOID FAR0 *cfiscsMap (FLFlash vol, CardAddress address, int length)
{
  vol.socket->remapped = TRUE;
  return mapThroughBuffer(&vol,address,length);
}


/*----------------------------------------------------------------------*/
/*			  c f i s c s R e a d				*/
/*									*/
/* Read some data from the flash. This routine will be registered as	*/
/* the read routine for this MTD.					*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Address to read from. 				*/
/*	buffer	: buffer to read to.					*/
/*	length	: number of bytes to read (up to sector size).		*/
/*	modes	: EDC flag etc. 					*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failed.		*/
/*									*/
/*----------------------------------------------------------------------*/

FLStatus cfiscsRead(FLFlash vol,
			 CardAddress address,
			 VOID FAR1 *buffer,
			 dword length,
			 word modes)
{
  ULONG i;
  UCHAR * byteBuffer;
  FlashPTR byteFlashPtr;
  ULONG * doubleWordBuffer = (ULONG *)buffer;
  FlashDPTR doubleWordFlashPtr = (FlashDPTR)flMap(vol.socket, address);

  for (i = 0; i < length - 4; i += 4, doubleWordBuffer++, doubleWordFlashPtr++) {
    *doubleWordBuffer = tffsReadDwordFlash(doubleWordFlashPtr);
  }
  byteBuffer = (UCHAR *)doubleWordBuffer;
  byteFlashPtr = (FlashPTR)doubleWordFlashPtr;
  for(; i < length; i++, byteBuffer++, byteFlashPtr++) {
    *byteBuffer = tffsReadByteFlash(byteFlashPtr);
  }
  return flOK ;
}


/*----------------------------------------------------------------------*/
/*		       c f i s c s I d e n t i f y			*/
/*									*/
/* Identifies media based on SCS/CFI and registers as an MTD for	*/
/* such.								*/
/*									*/
/* This routine will be placed on the MTD list in custom.h. It must be	*/
/* an extern routine.							*/
/*									*/
/* On successful identification, the Flash structure is filled out and	*/
/* the write and erase routines registered.				*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on positive identificaion, failed otherwise */
/*----------------------------------------------------------------------*/
FLStatus cfiscsIdentify(FLFlash vol)
{
  FlashWPTR flashPtr;
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;

  DEBUG_PRINT(("Debug: entering CFISCS identification routine.\n"));

  flSetWindowBusWidth(vol.socket, 16);/* use 16-bits */
  flSetWindowSpeed(vol.socket, 150);  /* 120 nsec. */
  flSetWindowSize(vol.socket, 2);	/* 8 KBytes */

  vol.mtdVars = &mtdVars_cfiscs[flSocketNoOf(vol.socket)];

  /* try word mode first */
  flashPtr = (FlashWPTR)flMap(vol.socket, 0);
  tffsWriteWordFlash(flashPtr+0x55, QUERY);
  if ((tffsReadWordFlash(flashPtr+0x10) == (USHORT)queryIdStr[0]) &&
      (tffsReadWordFlash(flashPtr+0x11) == (USHORT)queryIdStr[1]) &&
      (tffsReadWordFlash(flashPtr+0x12) == (USHORT)queryIdStr[2])) {
    vol.type = (tffsReadWordFlash(flashPtr) << 8) |
		tffsReadWordFlash(flashPtr+1);
    vol.interleaving = 1;
    thisCFI->wordMode = TRUE;
    vol.write = cfiscsWordWrite;
    vol.erase = cfiscsWordErase;
    checkStatus(getWordCFI(&vol));
    DEBUG_PRINT(("Debug: identified 16-bit CFISCS.\n"));
  }
  else {      /* Use standard identification routine to detect byte-mode */
    checkStatus(cfiscsByteIdentify(&vol));
    thisCFI->wordMode = FALSE;
    vol.write = cfiscsByteWrite;
    vol.erase = cfiscsByteErase;
    checkStatus(getByteCFI(&vol));
    DEBUG_PRINT(("Debug: identified 8-bit CFISCS.\n"));
  }

  checkStatus(thisCFI->wordMode ? cfiscsWordSize(&vol) : cfiscsByteSize(&vol));

  vol.map = cfiscsMap;
  vol.read = cfiscsRead;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		     f l R e g i s t e r C F I S C S			*/
/*									*/
/* Registers this MTD for use						*/
/*									*/
/* Parameters:								*/
/*	None								*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterCFISCS(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = cfiscsIdentify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\blockdev.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/BLOCKDEV.C_V  $
 * 
 *    Rev 1.43   Apr 15 2002 20:14:20   oris
 * Prevent any change to the flPolicy environment variable. It must be set to FL_DEFAULT_POLICY.
 * 
 *    Rev 1.42   Apr 15 2002 07:33:56   oris
 * Moved doc2exb functions declaration to blockdev.c
 * Moved bdkCall function declaration to docbdk.h
 * Bug fix - Bad arguments sanity check for FL_MTD_BUS_ACCESS_TYPE.
 * Bug fix - Missing initialization of global variables:
 *  - bus access in flSetDocBusRoutine() and flGetDocBusRoutine() and when ENVIRONMENT_VARS compilation flag is not defined.
 *  - verify write when ENVIRONMENT_VARS  compilation flag is not defined.
 *  - All global (for all sockets and volumes) environment variables where not reinitialized after flExit call.
 *  - Renamed initEnvVarsDone to initGlobalVarsDone.
 *  - Renamed flInitEnvVars() to flInitGlobalVars().
 * Changed flBusConfig environment array to dword variables instead of single byte.
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * Placed multi-doc environment variable under the MULTI_DOC compilation flag.
 * VolumeInfo routine - remove warning by placing eraseCyclesPerUnit variable under FL_LOW_LEVEL compilation flag.
 * 
 *    Rev 1.41   Feb 19 2002 20:58:08   oris
 * Moved include directives to blockdev.h file.
 * Bug fix - findFreeVolume routine did not initialize flfash records of the volume. It caused exception when formatting a DiskOnChip with more then 1 partition.
 * Compilation error missing ifdef EXIT.
 * Convert TL_LEAVE_BINARY_AREA to FL_LEAVE_BINARY_AREA before sending it to the TL.
 * Bug fix - volumeInfo routine might cause exception if osak version or driver version is larger the designated field.
 * use intermediate variable before sending irFlags to otpSize routine.
 * 
 *    Rev 1.40   Jan 29 2002 20:07:42   oris
 * Added NAMING_CONVENTION prefix and extern "C" for cpp files to all public routines:
 * flSetEnvVolume, flSetEnvSocket , flSetEnvAll , flSetDocBusRoutine , flGetDocBusRoutine, flBuildGeometry , bdCall and flExit
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * Removed warnings.
 * Moved writeIPL sanity check to MTD level.
 * Removed download operation after writeIPL call (it is now one of the routines parameters).
 * Added sanity check (null pointer passed) to flSetEnvVolume, flSetDocBusRoutine and flGetDocBusRoutine.
 * 
 *    Rev 1.39   Jan 28 2002 21:23:32   oris
 * Bug fix - initialization of flPolicy variable caused a memory lick (set max unit chain to 0).
 * Changed FL_NFTL_CACHE_ENABLED to FL_TL_CACHE_ENABLED.
 * Changed flSetDocBusRoutine interface and added flGetDocBusRoutine. 
 * Added FL_IPL_DOWNLOAD flag to writeIPL routine in order to control whether the IPL will be reloaded after the update.
 * 
 *    Rev 1.38   Jan 23 2002 23:30:46   oris
 * Added a call to flExit() in case flSuspend was restored to FL_OFF.
 * Moved Alon based DiskOnChip write IPL routine from blockdev, to diskonc.
 * Added sanity check to flCheckVolume() - Make sure irData is NULL and irLength is set to 0.
 * 
 *    Rev 1.37   Jan 21 2002 20:43:36   oris
 * Bug fix - Missing\bad support for FL_SECTORS_VERIFIED_PER_FOLDING and FL_VERIFY_WRITE_BDTL environment variables.
 * 
 *    Rev 1.36   Jan 20 2002 20:40:20   oris
 * Improved documentation of bdFormatPhisycalDrive - Added TL_NORMAL_FORMAT flag was added.
 * Removed ifdef NO_PHYSICAL_IO from flGetBPB routine.
 * 
 *    Rev 1.35   Jan 17 2002 22:56:22   oris
 * Placed docbdk.h under BDK_ACCESS ifdef
 * Added include directive to docsys.h   
 * Removed function prototypes from header.
 * Changed FLFlash record in the volume structure into a pointer
 * Added flBusConfig variable and flSetDocBusRoutine() routine for runtime control over memory access routines - under the FL_NO_USE_FUNC definition.
 * Added flSectorsVerfiedPerFolding environment variable was added
 * Added   flSuspendMode environment variable was added.
 * Changed flVerifyWrite environment variable : 4 for Disk partitions 3 for Binary and 1 for the rest.
 * Changed flPolicy to be partition specific.
 * Changed flSetEnv() routine was changed into 3 different routines: flSetEnvVolume / flSetEnvSocket / flSetEnvAll
 * Variables types for environment variables were changed to the minimal size needed.
 * Added flInitEnvVars() routine for setting default values to environment variables.
 * Use single FLFlash record for each volume - (change vol.flash to a pointer instead of the record itself).
 * Added \r to all DEBUG_PRINT routines.
 * Removed SINGLE_BUFFER ifdef.
 * Added volume verification after format for faster write performance with FL_OFF.
 * Removed FLFlash parameter to all TL calls (flMount / flFormat / flPreMount )  
 * Added support for firmware other then the 3 defaults (getExbInfo additional parameter)
 * Added support for M+ 16MB
 * Added partition parameter to setBusy - Stores current partition in the socket record for the use of lower TrueFFS layers .
 * Changed tffsmin to TFFSMIN
 * Added FL_VERIFY_VOLUME functionNo.
 * Made sure flInit() initializes all sockets and flashes volumes
 * Added flClearQuickMountInfo() routine (FL_CLEAR_QUICK_MOUNT_INFO)
 * readIPL routine now supports all DiskOnChip 
 * 
 *    Rev 1.34   Nov 29 2001 20:53:44   oris
 * Bug fix - flInquireCapabilities() returned bad status for SUPPORT_WRITE_IPL_ROUTINE.
 * 
 *    Rev 1.33   Nov 21 2001 11:40:44   oris
 * Changed FL_MULTI_DOC_NOT_ACTIVE to FL_OFF, FL_VERIFY_WRITE_MODE to FL_MTD_VERIFY_WRITE , FL_WITHOUT_VERIFY_WRITE to FL_OFF , FL_MARK_DELETE to FL_ON.
 * 
 *    Rev 1.32   Nov 08 2001 10:44:04   oris
 * Added flVerifyWrite environment variable that controls the verify write mode at run-time. 
 * Added support for large DiskOnChip in flBuildGeometry.
 * Remove s/w protection from binary partition.
 * Placed flAbsMount under ABS_READ_WRITE compilation flag.
 *
 *    Rev 1.31   Sep 24 2001 18:23:04   oris
 * Removed warnings.
 * 
 *    Rev 1.30   Sep 15 2001 23:44:22   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 * 
 *    Rev 1.29   Aug 02 2001 20:04:04   oris
 * Added support for 1k IPL for DiskOnChip 2000 TSOP - writeIPL() 
 * 
 *    Rev 1.28   Jul 29 2001 19:14:24   oris
 * Bug fix for TrueFFS internal mutex when using multi-doc and environment variables (when no multi-doc feature is disbaled)
 * 
 *    Rev 1.27   Jul 13 2001 00:59:28   oris
 * Changed flash lifetime calculation according to specific flash.
 * 
 *    Rev 1.26   Jun 17 2001 08:16:50   oris
 * Added NO_PHISICAL_IO compilation flag to reduce code size.
 * Added NO_READ_BBT_CODE compilation flag to reduce code size.
 * Changed placeExbByBuffer exbflags argument to word instead of byte to  support /empty flag.
 * Deleted redundent #ifdef MULTI_DOC in flInit().
 * 
 *    Rev 1.25   May 31 2001 18:11:52   oris
 * Removed readBBT routine from under the #ifndef FL_READ_ONLY.
 * 
 *    Rev 1.24   May 16 2001 21:16:08   oris
 * Changed the Binary state (0,1) of the environment variables to meaningful definitions.
 * Added flMtlDefragMode environment variable.
 * Added the FL_ prefix to the following defines: ON, OFF
 * Bug fix - One of the "ifndef" statement of NO_IPL_CODE was coded as "ifdef"
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.23   May 09 2001 00:31:00   oris
 * Added NO_PHYSICAL_IO , NO_IPL_CODE and NO_INQUIRE_CAPABILITY compilation flags to reduce code size.
 *
 *    Rev 1.22   May 06 2001 22:41:04   oris
 * Bug fix - flInquireCapabilities routine did not return the correct value when capability was not supported.
 * Added SUPPORT_WRITE_IPL_ROUTIN capability.
 * Removed warnings.
 * 
 *    Rev 1.21   May 01 2001 17:05:10   oris
 * Bug fix - bad argument check in flSetEnv routine.
 * 
 *    Rev 1.20   Apr 30 2001 17:57:00   oris
 * Added new environment variable flMarkDeleteOnFlash.
 * 
 *    Rev 1.19   Apr 24 2001 17:05:38   oris
 * Bug fix flMoutVolume routine return the correct hidden sectors even if high level mount fails.
 * Bug fix Write IPL routine supports Doc2000 TSOP as well as Millennium Plus.
 * Support readBBT new interface.
 * 
 *    Rev 1.18   Apr 18 2001 20:43:00   oris
 * Added force download call after writing IPL.
 * 
 *    Rev 1.17   Apr 18 2001 19:14:24   oris
 * Bug fix - binary partition insert and remove key routine no longer stop the place exb proccess.
 * 
 *    Rev 1.16   Apr 18 2001 09:26:22   oris
 * noOfDrives variable was changed to unsigned. This is a bug fix for vxWorks boot code.
 * Make sure blockdev does not try to mount more volumes then the VOLUMES definition.
 * 
 *    Rev 1.15   Apr 16 2001 13:02:38   oris
 * Removed warrnings.
 * 
 *    Rev 1.14   Apr 12 2001 06:48:22   oris
 * Added call to download routine after physical format in order 
 * to load new IPL and to initialize new protection information.
 * Removed warnings.
 *
 *    Rev 1.13   Apr 03 2001 16:33:10   oris
 * Removed unused variables.
 * Added proper casting in otpSize call.
 * 
 *    Rev 1.12   Apr 03 2001 14:33:16   oris
 * Bug fix in absRead sectors when reading multiple sectors.
 *
 *    Rev 1.11   Apr 01 2001 14:57:58   oris
 * Bug fix in read multiple sectors.
 *
 *    Rev 1.10   Mar 28 2001 06:19:12   oris
 * Removed flChangeEnvVar prototype.
 * Left alligned all # directives.
 * Bug fix in flSetEnv ((value !=0)||(value!=1)) => ((value !=0)&&(value!=1)) + downcast for given argument + add return status code
 * Removed unused variables.
 * Remove casting warnnings.
 * Add arg check in bdFormatPhysicalDrive for BDTLPartitionInfo != NULL.
 * Bug fix for absWrite - multi-secotr write should be initialized with zeros to prevent sector found return code.
 * Replaced the numbers in writeProtect routine to defines (moved from ioctl.h to blockdev.h).
 * Add break for mdocp identification in getPhysicalInfo.
 * Added readIPL routine.
 * Added LOG_FILE compilation flag for EDC errors for mdocp.
 * Added initialization of tl table in flInit.
 * flExit mutex bug fix.
 *
 *    Rev 1.9   Mar 05 2001 21:00:34   oris
 * Bug fix - initialize exbLen argument in bdFormatVolume.
 * Bug fix - initialize bdtlFp flags fiels in bdFormatVolume.
 * Restored the flExit pragma under __BORLANDC__ compilation flag
 *
 *    Rev 1.8   Feb 22 2001 20:21:34   oris
 * Bug fix in flExit with multi-doc release uncreated mutxe.
 *
 *    Rev 1.7   Feb 20 2001 15:44:58   oris
 * Bug fix for mutex initialization in flInit.
 *
 *    Rev 1.6   Feb 18 2001 23:29:28   oris
 * Bug fix - Added findFreeVolume call in flFormatPhysicalDrive.
 * bug fix - Added partition sanity check in bdcall entrence.
 * bug fix - Increamented pVol before entering loop in flExit.
 *
 *    Rev 1.5   Feb 18 2001 14:13:22   oris
 * Restored FL_BACKGROUND.
 * Place bdkCall extern prototype under BDK_ACCESS compilation flag.
 * Changed multiple volume mechanism - Replaced removeVolumeHandles and
 * flConvertDriveHandle routines with flInit + findFreeVolume and changed
 * dismountPhysicalDrive + flEacit to comply.
 * Changed bdcall volume validity check.
 * Added new volume flag VOLUME_ACCUPIED.
 * Moved all the new environment variable (flPolicy,flUseMultiDoc and flMaxUnitChain)
 * from flcustom.c in order to allow backwards competability.
 * Removed globalMutex (for now).
 * Allocate only 1 mutex when multi-doc is registered therfore setBusy takes only 1 mutex .
 * Bug fix - absRead and absWrite add bootSectors to the given sectors.
 * Bug fix - INVALID_VOLUME_HANDLE changed to INVALID_VOLUME_NUMBER.
 * Bug fix - Added (byte FAR1 *) casting in readBBT call.
 * Bug fix - Added (FLCapability FAR2 *) casting in inquire capability call.
 *
 *    Rev 1.4   Feb 14 2001 01:51:32   oris
 * Completly revised flInquireCapabilities routine.
 * Added oldFormat flag to flBuildGeometry routine.
 * Remove FL_BACKGROUND compilation flag.
 * Added arg check for flSetEnv + new FL_SET_MAX_CHAIN.
 * Changed FL_COMPLETE_ASAP_POLICY to FL_SET_POLICY.
 * Moved argument check in flFormatPhysicalDrive to fltl.c.
 * Moved readBBT routine inside bdcall.
 * Placed volumeInfo C\H\S data under ABS_READ_WRITE.
 *
 *    Rev 1.3   Feb 13 2001 02:10:48   oris
 * Changed flChangeEnvVar routine name to flSetEnv
 *
 *    Rev 1.2   Feb 12 2001 11:51:12   oris
 * Added function prototype in begining of the file.
 * Change routine order in the file.
 * Added mutex support for TrueFFS 5.0 partitions while changing bdcall order.
 * flMountVolume returns the number of boot sectors.
 * Moved the writeBBT routine to FLTL.C.
 * Added static before changePassword.
 * Added static before writeProtect.
 * Added static before dismountLowLevel.
 * Added static before writeIPL.
 * Added static before inquireCapabilities.
 * window base is returned by getPhysicalInfo in irLength.
 * Added MULTI_DOC compliation flag.
 *
 *    Rev 1.1   Feb 07 2001 17:55:06   oris
 * Buf fix for writeBBT of no bad blocks
 * Moved readBBT routine from under the fl_read_only define
 * Added casting in calls to readBBT and writeBBT
 * Added checkStatus check for flAbsWrite and flAbsRead routines
 * Added initialization of noOfMTDs and noOfSockets in flInit
 *
 *    Rev 1.0   Feb 04 2001 18:53:04   oris
 * Initial revision.
 *
 */


/*************************************************************************/
/*                    M-Systems Confidential                             */
/*       Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001      */
/*                     All Rights Reserved                               */
/*************************************************************************/
/*                        NOTICE OF M-SYSTEMS OEM                        */
/*                      SOFTWARE LICENSE AGREEMENT                       */
/*                                                                       */
/*  THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE           */
/*  AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT     */
/*  FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                        */
/*  OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                         */
/*  E-MAIL = info@m-sys.com                                              */
/*************************************************************************/

#include "bddefs.h"
#include "blockdev.h"

#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif


/********************* Extern Function Prototype Start *******************/
#ifdef WRITE_EXB_IMAGE
extern FLStatus getExbInfo(Volume vol, void FAR1 * buf, dword bufLen, word exbFlags);
extern FLStatus placeExbByBuffer(Volume vol, byte FAR1 * buf, dword bufLen,
                 word windowBase,word exbFlags);
#endif /* WRITE_EXB_IMAGE */

#if (defined(FORMAT_VOLUME) && defined(COMPRESSION))
extern FLStatus flFormatZIP(unsigned volNo, TL *baseTL , FLFlash * flash);
#endif
#if defined(FILES) && FILES > 0
extern File     fileTable[FILES];       /* the file table */
extern FLStatus flushBuffer(Volume vol);
extern FLStatus openFile(Volume vol, IOreq FAR2 *ioreq);
extern FLStatus closeFile(File *file);
extern FLStatus joinFile (File *file, IOreq FAR2 *ioreq);
extern FLStatus splitFile (File *file, IOreq FAR2 *ioreq);
extern FLStatus readFile(File *file,IOreq FAR2 *ioreq);
extern FLStatus writeFile(File *file, IOreq FAR2 *ioreq);
extern FLStatus seekFile(File *file, IOreq FAR2 *ioreq);
extern FLStatus findFile(Volume vol, File *file, IOreq FAR2 *ioreq);
extern FLStatus findFirstFile(Volume vol, IOreq FAR2 *ioreq);
extern FLStatus findNextFile(File *file, IOreq FAR2 *ioreq);
extern FLStatus getDiskInfo(Volume vol, IOreq FAR2 *ioreq);
extern FLStatus deleteFile(Volume vol, IOreq FAR2 *ioreq, 
                           FLBoolean isDirectory);
extern FLStatus renameFile(Volume vol, IOreq FAR2 *ioreq);
extern FLStatus makeDir(Volume vol, IOreq FAR2 *ioreq);
#endif /* FILES > 0 */

/********************* Extern Function Prototype End *******************/

/********************* Internal Function Prototype Start ***************/

void flInitGlobalVars(void);

/********************* Internal Function Prototype End *****************/

/********************* Global variables Start **************************/

Volume    vols[VOLUMES];
FLMutex   flMutex[SOCKETS];
byte      handleConversionTable[SOCKETS][MAX_TL_PARTITIONS];
FLBoolean initDone = FALSE;           /* Initialization not done yet   */
FLBoolean initGlobalVarsDone = FALSE; /* Initialization of environment */
                                      /* and access type variables not */
                                      /* done yet.                     */
unsigned  noOfDrives;

dword flMsecCounter = 0;

/* bus configuration
 *
 * DiskOnChip minimal bus width
 */
#ifndef FL_NO_USE_FUNC
dword   flBusConfig[SOCKETS];
#endif /* FL_NO_USE_FUNC */

/* Verify write state
 *
 * BDTL   partitions : 0-(MAX_TL_PARTITIONS-1)
 * Binary partitions : MAX_TL_PARTITIONS - (2*MAX_TL_PARTITIONS-2)
 * Last              : 2*MAX_TL_PARTITIONS-1
 */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
byte   flVerifyWrite[SOCKETS][MAX_TL_PARTITIONS<<1];
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

#ifdef ENVIRONMENT_VARS
cpyBuffer tffscpy; /* Pointer to memory copy routine    */
cmpBuffer tffscmp; /* Pointer to memory compare routine */
setBuffer tffsset; /* Pointer to memory set routine     */

/********************************************/
/* default values for environment variables */
/********************************************/

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
/* Max sectors verified per write operation (must be even number) */
dword  flSectorsVerifiedPerFolding = 64;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#ifdef MULTI_DOC
/* No multi-doc (MTL)                        */
byte   flUseMultiDoc;
/* MTL defragmentaion mode (0 - standard)    */
byte   flMTLdefragMode;
#endif /* MULTI_DOC */
/* Set the TL operation policy               */
byte   flPolicy[SOCKETS][MAX_TL_PARTITIONS];
/* Maximum chain length                      */
byte   flMaxUnitChain;
/* Mark the delete sector on the flash       */
byte   flMarkDeleteOnFlash;
/* Read Only mode                            */
byte   flSuspendMode;

/********************* Global variables End *****************************/

/*----------------------------------------------------------------------*/
/*                   f l S e t E n v V o l u m e                        */
/*                                                                      */
/* Change one of TrueFFS environment variables for a specific partition */
/*                                                                      */
/* Note : This routine is used by all other flSetEnv routines.          */
/*        In order to effect variables that are common to several       */
/*        sockets or volumes use INVALID_VOLUME_NUMBER                  */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      socket          : Associated socket                             */
/*      volume          : Associated volume (partition)                 */
/*      value           : varaible value                                */
/*                                                                      */
/* Note: Variables common to al sockets must be addressed using socket  */
/*       0 and volume 0.                                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flSetEnvVolume(FLEnvVars variableType ,
                  byte socket,byte volume ,
                  dword value, dword FAR2 *prevValue)
{
   /* Arg sanity check */
   if(prevValue == NULL)
   {
      DEBUG_PRINT(("ERROR - prevValue argument is NULL.\r\n"));
      return flBadParameter;
   }
   switch (variableType) /* Check value argument is a valid mode */
   {
      case FL_SET_MAX_CHAIN:
         if ((value > 31) || (value < 1))
         {
            DEBUG_PRINT(("Debug: Error - Chains length must between 0 and 32.\r\n"));
            return flBadParameter;
         }
         break;
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_SECTORS_VERIFIED_PER_FOLDING:
         if (value & 1) /* odd number */
         {
            DEBUG_PRINT(("Debug: Error - sector verification numbr must be even.\r\n"));
            return flBadParameter;
         }
         break;
      case FL_VERIFY_WRITE_BDTL:
         if ((value != FL_UPS) && (value != FL_OFF) && (value != FL_ON))
         {
            DEBUG_PRINT(("Debug: Error - verify write of BDTL can not accept this value.\r\n"));
            return flBadParameter;
         }
         break;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
      case FL_SUSPEND_MODE:
         if((value != FL_OFF)           && 
            (value != FL_SUSPEND_WRITE) && 
            (value != FL_SUSPEND_IO)      )
         {
            DEBUG_PRINT(("Debug: Error - verify write of BDTL can not accept this value.\r\n"));
            return flBadParameter;
         }
         break;
#ifndef FL_NO_USE_FUNC
      case FL_MTD_BUS_ACCESS_TYPE:
         break;
#endif /* FL_NO_USE_FUNC */
      default:
         if ((value != FL_ON)&&(value!=FL_OFF))
         {
            DEBUG_PRINT(("Debug: Error - Value must be either FL_ON (1) or FL_OFF(0).\r\n"));
            return flBadParameter;
         }
   }

   switch (variableType) /* Check volume and socket sanity */
   {
      /* Volume specfic variables */

      case FL_SET_POLICY:
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_VERIFY_WRITE_BDTL:
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_BINARY:
#endif /* VERIFY_WRITE */
         if ((       volume >= MAX_TL_PARTITIONS          ) ||
             ((variableType == FL_VERIFY_WRITE_BINARY) &&
              (volume       == MAX_TL_PARTITIONS - 1 )    )   )
         {
            DEBUG_PRINT(("Debug: Error - No such volume, therefore can not change environment variable.\r\n"));
            return flBadParameter;
         }
         if (socket>=SOCKETS)
         {
            DEBUG_PRINT(("Debug: Error - No such socket, therefore can not change environment variable.\r\n"));
            return flBadParameter;
         }
         break;

      /* Socket specfic variables */

#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_OTHER:
#endif /* VERIFY_WRITE */
      case FL_MTD_BUS_ACCESS_TYPE:
         if (socket>=SOCKETS)
         {
            DEBUG_PRINT(("Debug: Error - No such socket, therefore can not change environment variable.\r\n"));
            return flBadParameter;
         }
         if (volume!=INVALID_VOLUME_NUMBER)
         {
            DEBUG_PRINT(("Debug: Error - This global variable is common to all volumes.\r\n"));
            return flBadParameter;
         }
         break;

      /* Global variables for all sockets and volumes */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_SECTORS_VERIFIED_PER_FOLDING:
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
      case FL_IS_RAM_CHECK_ENABLED:
      case FL_TL_CACHE_ENABLED:
      case FL_DOC_8BIT_ACCESS:
      case FL_MULTI_DOC_ENABLED:
      case FL_SET_MAX_CHAIN:
      case FL_MARK_DELETE_ON_FLASH:
      case FL_SUSPEND_MODE:
      case FL_MTL_POLICY:
         if ((socket!=INVALID_VOLUME_NUMBER) || (volume!=INVALID_VOLUME_NUMBER))
         {
            DEBUG_PRINT(("Debug: Error - This global variable is common to all sockets and volumes.\r\n"));
            return flBadParameter;
         }
         break;

      default:

         DEBUG_PRINT(("Debug: Unknown variable type.\r\n"));
         return flFeatureNotSupported;
   }

   /* Make sure environement variables are */
   /* initialized to their default values  */
   flInitGlobalVars();


   /***************************************************/
   /* Arguments have been checked now change variable */
   /* and report the previous value.                  */
   /***************************************************/

   switch (variableType)
   {
      case FL_IS_RAM_CHECK_ENABLED:
         *prevValue                  = (dword)flUseisRAM;
         flUseisRAM                  = (byte)value;
         break;
      case FL_TL_CACHE_ENABLED:
         *prevValue                  = (dword)flUseNFTLCache;
         flUseNFTLCache              = (byte)value;
         break;
      case FL_DOC_8BIT_ACCESS:
         *prevValue                  = (dword)flUse8Bit;
         flUse8Bit                   = (byte)value;
         break;
      case FL_SET_MAX_CHAIN:
         *prevValue                  = (dword)flMaxUnitChain;
         flMaxUnitChain              = (byte)value;
         break;
      case FL_MARK_DELETE_ON_FLASH:
         *prevValue                  = (dword)flMarkDeleteOnFlash;
         flMarkDeleteOnFlash         = (byte)value;
         break;
#ifdef MULTI_DOC
      case FL_MULTI_DOC_ENABLED:
         *prevValue                  = (dword)flUseMultiDoc;
         flUseMultiDoc               = (byte)value;
         break;
      case FL_MTL_POLICY:
         *prevValue                  = (dword)flMTLdefragMode;
         flMTLdefragMode             = (byte)value;
         break;
#endif /* MULTI_DOC */
      case FL_SUSPEND_MODE:
         if((value == FL_OFF) && (flSuspendMode != FL_OFF))
#ifdef EXIT
            flExit();
#endif /* EXIT */
         *prevValue                  = (dword)flSuspendMode;
         flSuspendMode               = (byte)value;
         break;
      case FL_SET_POLICY:
         *prevValue                  = (dword)flPolicy[socket][volume];
/*       flPolicy[socket][volume]    = (byte)value; */
         break;
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_SECTORS_VERIFIED_PER_FOLDING:
         *prevValue                  = flSectorsVerifiedPerFolding;
         flSectorsVerifiedPerFolding = value;
         break;
      case FL_VERIFY_WRITE_BDTL:
         *prevValue                    = (dword)flVerifyWrite[socket][volume];
         flVerifyWrite[socket][volume] = (byte)value;
         break;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_BINARY:
         *prevValue      = (dword)flVerifyWrite[socket][volume+MAX_TL_PARTITIONS];
         flVerifyWrite[socket][volume+MAX_TL_PARTITIONS] = (byte)value;
         break;
      case FL_VERIFY_WRITE_OTHER:
         *prevValue      = (dword)flVerifyWrite[socket][(MAX_TL_PARTITIONS<<1)-1];
         flVerifyWrite[socket][(MAX_TL_PARTITIONS<<1)-1] = (byte)value;
         break;
#endif /* VERIFY_WRITE */

      default: /* FL_MTD_BUS_ACCESS_TYPE */
#ifndef FL_NO_USE_FUNC
         *prevValue          = flBusConfig[socket];
         flBusConfig[socket] = (dword)value;
#endif /* FL_NO_USE_FUNC */
         break;
   }
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                       f l S e t E n v S o c k e t                    */
/*                                                                      */
/* Change one of TrueFFS environment variables for a specific sockets.  */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      socket          : socket number                                 */
/*      value           : varaible value                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*                        if there are more then 1 partition in that    */
/*                        socket , the first partition value is returned*/
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flSetEnvSocket(FLEnvVars variableType , byte socket , dword value, dword FAR2 *prevValue)
{
   FLStatus status = flOK;
   byte     volume = 0;

   switch (variableType) /* Check volume and socket sanity */
   {
      /* Volume specific variables */

      case FL_SET_POLICY:
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_VERIFY_WRITE_BDTL:
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
         status = flSetEnvVolume(variableType,socket,MAX_TL_PARTITIONS-1,value,prevValue);
#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_BINARY:
#endif /* VERIFY_WRITE */
         for (;(volume<MAX_TL_PARTITIONS-1)&&(status == flOK);volume++)
            status = flSetEnvVolume(variableType,socket,volume,value,prevValue);
         break;

      /* Socket specific variables */

#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_OTHER:
#endif /* VERIFY_WRITE */
#ifndef FL_NO_USE_FUNC
      case FL_MTD_BUS_ACCESS_TYPE:
#endif /* FL_NO_USE_FUNC */
#if (defined(VERIFY_WRITE) || !defined(FL_NO_USE_FUNC))
         status = flSetEnvVolume(variableType,socket,INVALID_VOLUME_NUMBER,value,prevValue);
         break; 
#endif /* not FL_NO_USE_FUNC || VERIFY_WRITE */

      /* Either global variables , or unknown */

      default:
         if(socket != INVALID_VOLUME_NUMBER) /* Was not called from flSetEnv */
         {
            DEBUG_PRINT(("Debug: Variable type is either unknown or not socket related.\r\n"));
            return flBadParameter;
         }
         status = flSetEnvVolume(variableType,INVALID_VOLUME_NUMBER,INVALID_VOLUME_NUMBER,value,prevValue);
         break; 
   }
   return status;
}

/*----------------------------------------------------------------------*/
/*                       f l S e t E n v All                            */
/*                                                                      */
/* Change one of TrueFFS environment variables for all systems, sockets */
/* and partitions.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      value           : varaible value                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flSetEnvAll(FLEnvVars variableType , dword value, dword FAR2 *prevValue)
{
   FLStatus status = flOK;
   byte     socket;

   switch (variableType) /* Check volume and socket sanity */
   {
      case FL_SET_POLICY:           /* Per volume */
      case FL_VERIFY_WRITE_BDTL:    /* Per volume */
      case FL_VERIFY_WRITE_BINARY:  /* Per volume */
      case FL_VERIFY_WRITE_OTHER:   /* Per socket */
      case FL_MTD_BUS_ACCESS_TYPE:  /* Per socket */
         for (socket=0;(socket<SOCKETS)&&(status == flOK);socket++)
            status = flSetEnvSocket(variableType,socket,value,prevValue);
         return status;
      default:
         return flSetEnvVolume(variableType,INVALID_VOLUME_NUMBER,INVALID_VOLUME_NUMBER,value,prevValue);
   }
}

#endif /* ENVIRONMENT_VARS */

#ifndef FL_NO_USE_FUNC
/*----------------------------------------------------------------------*/
/*                  f l S e t D o c B u s R o u t i n e                 */
/*                                                                      */
/* Set user defined memory acces routines for DiskOnChip.               */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      : Socket number to install routine for.             */
/*      structPtr   : Pointer to function structure.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flSetDocBusRoutine(byte socket, FLAccessStruct FAR1 * structPtr)
{
   FLFlash* flash;

   /* Arg sanity check */
   if (socket >= SOCKETS)
   {
      DEBUG_PRINT(("Error : change SOCKETS definition in flcustom.h to support that many sockets.\r\n"));
      return flFeatureNotSupported;
   }
   if(structPtr == NULL)
   {
      DEBUG_PRINT(("ERROR - structPtr argument is NULL.\r\n"));
      return flBadParameter;
   }

   /* Make sure global variables are initialized to their default values */
   flInitGlobalVars();

   flash = flFlashOf(socket);

   flash->memWindowSize = structPtr->memWindowSize;
   flash->memRead       = structPtr->memRead;
   flash->memWrite      = structPtr->memWrite;
   flash->memSet        = structPtr->memSet;
   flash->memRead8bit   = structPtr->memRead8bit;
   flash->memRead16bit  = structPtr->memRead16bit;
   flash->memWrite8bit  = structPtr->memWrite8bit;
   flash->memWrite16bit = structPtr->memWrite16bit;

   flBusConfig[socket]  = FL_ACCESS_USER_DEFINED;
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                  f l G e t D o c B u s R o u t i n e                 */
/*                                                                      */
/* Get currently installed memory access routines for DiskOnChip.       */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      : Socket number to install routine for.             */
/*      structPtr   : Pointer to function structure.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flGetDocBusRoutine(byte socket, FLAccessStruct FAR1 * structPtr)
{
   FLFlash* flash;

   /* Arg sanity check */
   if (socket >= SOCKETS)
   {
      DEBUG_PRINT(("Error : change SOCKETS definition in flcustom.h to support that many sockets.\r\n"));
      return flFeatureNotSupported;
   }
   if(structPtr == NULL)
   {
      DEBUG_PRINT(("ERROR - structPtr argument is NULL.\r\n"));
      return flBadParameter;
   }

   /* Make sure global variables are initialized to their default values */
   flInitGlobalVars();

   flash = flFlashOf(socket);

   structPtr->memWindowSize = flash->memWindowSize;
   structPtr->memRead       = flash->memRead;
   structPtr->memWrite      = flash->memWrite;
   structPtr->memSet        = flash->memSet;
   structPtr->memRead8bit   = flash->memRead8bit;
   structPtr->memRead16bit  = flash->memRead16bit;
   structPtr->memWrite8bit  = flash->memWrite8bit;
   structPtr->memWrite16bit = flash->memWrite16bit;
   structPtr->access        = flBusConfig[socket];

   return flOK;
}

#endif /* FL_NO_USE_FUNC */

/*----------------------------------------------------------------------*/
/*                     f l I n i t G l o b a l V a r s                  */
/*                                                                      */
/* Initializes the FLite system, environment and access type variables. */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      None                                                            */
/*----------------------------------------------------------------------*/

void flInitGlobalVars(void)
{
   int i;
#ifdef ENVIRONMENT_VARS
   int j;
#endif /* ENVIRONMENT_VARS */

   if(initGlobalVarsDone == TRUE)
     return;

   /* Do not initialize variables on next call */
   initGlobalVarsDone     = TRUE;

   /*
    * Set default values to per socket/volume variables
    */

   for(i=0;i<SOCKETS;i++)
   {
#ifndef FL_NO_USE_FUNC
      flBusConfig[i] = FL_NO_ADDR_SHIFT        |
                       FL_BUS_HAS_8BIT_ACCESS  |
                       FL_BUS_HAS_16BIT_ACCESS |
                       FL_BUS_HAS_32BIT_ACCESS;
#endif /* FL_NO_USE_FUNC */
#ifdef ENVIRONMENT_VARS
      for (j=0;j<MAX_TL_PARTITIONS;j++)
      {
         flPolicy[i][j]   = FL_DEFAULT_POLICY; /* FL_COMPLETE_ASAP */
      }
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      for (j=0;j<MAX_TL_PARTITIONS<<1;j++)
      {
         flVerifyWrite[i][j] = FL_OFF; /* FL_ON , FL_UPS */
      }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#endif /* ENVIRONMENT_VARS */
   }

   /*
    * Set default values to per platform variables
    */

#ifdef ENVIRONMENT_VARS
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
/* Max sectors verified per write operation (must be even number) */
   flSectorsVerifiedPerFolding = 64;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#ifdef MULTI_DOC
/* No multi-doc (MTL)                        */
   flUseMultiDoc               = FL_OFF;
/* MTL defragmentaion mode (0 - standard)    */
   flMTLdefragMode             = FL_MTL_DEFRAGMENT_ALL_DEVICES;
#endif /* MULTI_DOC */
/* Maximum chain length                      */
   flMaxUnitChain              = 20;
/* Mark the delete sector on the flash       */
   flMarkDeleteOnFlash         = FL_ON;
/* Read Only mode                            */
   flSuspendMode               = FL_OFF;
#endif /* ENVIRONMENT_VARS */
}

/*----------------------------------------------------------------------*/
/*                           m o u n t L o w L e v e l                  */
/*                                                                      */
/* Mount a volume for low level operations. If a low level routine is   */
/* called and the volume is not mounted for low level operations, this  */
/* routine is called atomatically.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus mountLowLevel(Volume vol)
{
  checkStatus(flIdentifyFlash(vol.socket,vol.flash));
  vol.flash->setPowerOnCallback(vol.flash);
  vol.flags |= VOLUME_LOW_LVL_MOUNTED;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                           d i s m o u n t L o w L e v e l            */
/*                                                                      */
/* Dismount the volume for low level operations.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void dismountLowLevel(Volume vol)
{
  /* mark the volume as unmounted for low level operations.
     And does not change any of the other flags */
  vol.flags &= ~VOLUME_LOW_LVL_MOUNTED;
}


#ifdef FORMAT_VOLUME

/*----------------------------------------------------------------------*/
/*                  f i n d F r e e V o l u m e                         */
/*                                                                      */
/* Search the vols array for an empty cell to hold the new volume  .    */
/*                                                                      */
/* Parameters:                                                          */
/*      socket        : Socket number for the new volume.               */
/*      partition     : Partition number of the new volume.             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus      : 0 on success, flGeneralFailure if no more       */
/*                      volumes left.                                   */
/*----------------------------------------------------------------------*/

static FLStatus findFreeVolume(byte socket, byte partition)
{
   byte volNo;

   for (volNo = noOfSockets;volNo < VOLUMES;volNo++)
   {
     if ((vols[volNo].flags & VOLUME_ACCUPIED) == 0)
       break;
   }
   if (volNo == VOLUMES)
     return flGeneralFailure;

   handleConversionTable[socket][partition] = volNo;
   vols[volNo].volExecInProgress = &flMutex[socket];
   vols[volNo].socket            = vols[socket].socket;
   vols[volNo].flash             = vols[socket].flash;
   vols[volNo].tl.socketNo       = socket;
   vols[volNo].tl.partitionNo    = partition;
   vols[volNo].flags             = VOLUME_ACCUPIED;
   return flOK;
}

/*----------------------------------------------------------------------*/
/*             d i s m o u n t P h y s i c a l D r i v e                */
/*                                                                      */
/* Dismounts all the volumes on a specfic socket, closing all files.    */
/* This call is not normally necessary, unless it is known the volume   */
/* will soon be removed. The routine also clears the volumes entries in */
/* the volume convertion table, except for partition 0                  */
/*                                                                      */
/* Parameters:                                                          */
/*      socketNo        : Socket number to dismount.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus dismountPhysicalDrive(byte socketNo)
{
  byte volNo;
  byte partition;

  /* Dismount all physical drive volumes  */

  checkStatus(dismountVolume(&vols[socketNo]));
  for(partition = 1;partition < MAX_TL_PARTITIONS; partition++)
  {
      volNo = handleConversionTable[socketNo][partition];
      if (volNo != INVALID_VOLUME_NUMBER)
      {
         checkStatus(dismountVolume(&vols[volNo]));
         handleConversionTable[socketNo][partition]=INVALID_VOLUME_NUMBER;
         vols[volNo].flags = 0;
      }
  }
  return flOK;
}
#endif /* FORMAT_VOLUME */

/*----------------------------------------------------------------------*/
/*                    d i s m o u n t V o l u m e                       */
/*                                                                      */
/* Dismounts the volume, closing all files.                             */
/* This call is not normally necessary, unless it is known the volume   */
/* will soon be removed.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus dismountVolume(Volume vol)
{
  if (vol.flags & VOLUME_ABS_MOUNTED)
  {
    FLStatus status = flOK;
#ifndef FIXED_MEDIA
    status = flMediaCheck(vol.socket);
#endif
    if (status != flOK)
      vol.flags = 0;
#if FILES>0
    status = dismountFS(&vol,status);
#endif
    vol.tl.dismount(vol.tl.rec);
  }
  vol.flags = VOLUME_ACCUPIED;        /* mark volume unmounted */

  return flOK;
}

/*----------------------------------------------------------------------*/
/*                         s e t B u s y                                */
/*                                                                      */
/* Notifies the start and end of a file-system operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      state           : FL_ON (1) = operation entry                   */
/*                        FL_OFF(0) = operation exit                    */
/*      partition       : Partition number of the drive                 */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus setBusy(Volume vol, FLBoolean state, byte partition)
{
  FLStatus status = flOK;

  if (state == FL_ON) {

    if (!flTakeMutex(execInProgress))
       return flDriveNotAvailable;
    
    /* Mark current partition for MTD verify write */
    vol.socket->curPartition = partition; 
    flSocketSetBusy(vol.socket,FL_ON);
    flNeedVcc(vol.socket);
    if (vol.flags & VOLUME_ABS_MOUNTED)
      status = vol.tl.tlSetBusy(vol.tl.rec,FL_ON);
  }
  else {
    if (vol.flags & VOLUME_ABS_MOUNTED)
      status = vol.tl.tlSetBusy(vol.tl.rec,FL_OFF);

    flDontNeedVcc(vol.socket);
    flSocketSetBusy(vol.socket,FL_OFF);
    flFreeMutex(execInProgress);
  }

  return status;
}

/*----------------------------------------------------------------------*/
/*                        f i n d S e c t o r                           */
/*                                                                      */
/* Locates a sector in the buffer or maps it                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to locate                          */
/*                                                                      */
/*----------------------------------------------------------------------*/


const void FAR0 *findSector(Volume vol, SectorNo sectorNo)
{
  return
#if FILES > 0
  (sectorNo == vol.volBuffer.sectorNo && &vol == vol.volBuffer.owner) ?
    vol.volBuffer.flData :
#endif
    vol.tl.mapSector(vol.tl.rec,sectorNo,NULL);
}

/*----------------------------------------------------------------------*/
/*                a b s M o u n t V o l u m e                           */
/*                                                                      */
/* Mounts the Flash volume and assume that volume has no FAT            */
/*                                                                      */
/* In case the inserted volume has changed, or on the first access to   */
/* the file system, it should be mounted before file operations can be  */
/* done on it.                                                          */
/* Mounting a volume has the effect of discarding all open files (the   */
/* files cannot be properly closed since the original volume is gone),  */
/* and turning off the media-change indication to allow file processing */
/* calls.                                                               */
/*                                                                      */
/* The volume automatically becomes unmounted if it is removed or       */
/* changed.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus absMountVolume(Volume vol)
{
  unsigned volNo     = (unsigned)(&vol - vols);
#ifdef WRITE_PROTECTION
  PartitionTable FAR0 *partitionTable;
#endif

  checkStatus(dismountVolume(&vol));

  /* Try to mount translation layer */

  checkStatus(flMount(volNo,vol.tl.socketNo,&vol.tl,TRUE,vol.flash));

  vol.bootSectorNo = 0; /*  assume sector 0 is DOS boot block */
#ifdef WRITE_PROTECTION
  partitionTable = (PartitionTable FAR0 *) findSector(&vol,0);
  if((partitionTable == NULL)||
     (partitionTable==dataErrorToken)||
     (LE2(partitionTable->signature) != PARTITION_SIGNATURE))
      vol.password[0] = vol.password[1] = 0;
  else
  {
     vol.password[0] = vol.password[1] = 0;
     if (UNAL4(partitionTable->passwordInfo[0]) == 0 &&
        (UNAL4(partitionTable->passwordInfo[1]) != 0 ||
        UNAL4(partitionTable->passwordInfo[2]) != 0)) {
        vol.password[0] = UNAL4(partitionTable->passwordInfo[1]);
        vol.password[1] = UNAL4(partitionTable->passwordInfo[2]);
        vol.flags |= VOLUME_WRITE_PROTECTED;
     }
  }
#endif   /* WRITE_PROTECTION */
  /* Disable FAT monitoring */
  vol.firstFATSectorNo = vol.secondFATSectorNo = 0; 
  vol.flags |= VOLUME_ABS_MOUNTED;  /* Enough to do abs operations */

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                     m o u n t V o l u m e                            */
/*                                                                      */
/* Mounts the Flash volume.                                             */
/*                                                                      */
/* In case the inserted volume has changed, or on the first access to   */
/* the file system, it should be mounted before file operations can be  */
/* done on it.                                                          */
/* Mounting a volume has the effect of discarding all open files (the   */
/* files cannot be properly closed since the original volume is gone),  */
/* and turning off the media-change indication to allow file processing */
/* calls.                                                               */
/*                                                                      */
/* The volume automatically becomes unmounted if it is removed or       */
/* changed.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      bootSectors     : Returns the number of sectors, flMountVolume  */
/*                        skipps.                                       */
/*----------------------------------------------------------------------*/

static FLStatus mountVolume(Volume vol,unsigned FAR2* bootSectors)
{
  SectorNo noOfSectors;
  PartitionTable FAR0 *partitionTable;
  Partition ptEntry;
  DOSBootSector FAR0 *bootSector;
  unsigned ptCount,extended_depth,ptSector;
  FLBoolean primaryPtFound = FALSE, extendedPtFound = TRUE;

  *bootSectors=0;
  checkStatus(absMountVolume(&vol));

  for(extended_depth = 0,ptSector = 0;
      (extended_depth<MAX_PARTITION_DEPTH) &&
      (primaryPtFound==FALSE) &&
      (extendedPtFound==TRUE);
      extended_depth++) {

    extendedPtFound=FALSE;
    /* Read in paritition table */

    partitionTable = (PartitionTable FAR0 *) findSector(&vol,ptSector);

    if(partitionTable == NULL) {
      vol.tl.dismount(vol.tl.rec);
      return flSectorNotFound;
    }
    if(partitionTable==dataErrorToken) {
      vol.tl.dismount(vol.tl.rec);
      return flDataError;
    }

    if (LE2(partitionTable->signature) != PARTITION_SIGNATURE)
      break;
    for(ptCount=0;
    (ptCount<4) && (primaryPtFound==FALSE) && (extendedPtFound==FALSE);
    ptCount++) {

      ptEntry = partitionTable->ptEntry[ptCount];

      switch (ptEntry.type) {
    case FAT12_PARTIT:
    case FAT16_PARTIT:
    case DOS4_PARTIT:
      primaryPtFound = TRUE;
      vol.bootSectorNo =
          (unsigned) UNAL4(ptEntry.startingSectorOfPartition);
      *bootSectors=vol.bootSectorNo;
      break;
    case EX_PARTIT:
      extendedPtFound = TRUE;
      ptSector = (unsigned)UNAL4(ptEntry.startingSectorOfPartition);
      break;
    default:
      break;
      }
    }
  }

  bootSector = (DOSBootSector FAR0 *) findSector(&vol,vol.bootSectorNo);
  if(bootSector == NULL)
    return flSectorNotFound;

  if(bootSector==dataErrorToken)
    return flDataError;

  /* Do the customary sanity checks */
  if (!(bootSector->bpb.jumpInstruction[0] == 0xe9 ||
    (bootSector->bpb.jumpInstruction[0] == 0xeb &&
     bootSector->bpb.jumpInstruction[2] == 0x90))) {
    DEBUG_PRINT(("Debug: did not recognize format.\r\n"));
    return flNonFATformat;
  }

  /* See if we handle this sector size */
  if (UNAL2(bootSector->bpb.bytesPerSector) != SECTOR_SIZE)
    return flFormatNotSupported;

  vol.sectorsPerCluster = bootSector->bpb.sectorsPerCluster;
  vol.numberOfFATS = bootSector->bpb.noOfFATS;
  vol.sectorsPerFAT = LE2(bootSector->bpb.sectorsPerFAT);
  vol.firstFATSectorNo = vol.bootSectorNo +
                LE2(bootSector->bpb.reservedSectors);
  vol.secondFATSectorNo = vol.firstFATSectorNo +
                 LE2(bootSector->bpb.sectorsPerFAT);
  vol.rootDirectorySectorNo = vol.firstFATSectorNo +
           bootSector->bpb.noOfFATS * LE2(bootSector->bpb.sectorsPerFAT);
  vol.sectorsInRootDirectory =
    (UNAL2(bootSector->bpb.rootDirectoryEntries) * DIRECTORY_ENTRY_SIZE - 1) /
        SECTOR_SIZE + 1;
  vol.firstDataSectorNo = vol.rootDirectorySectorNo +
                 vol.sectorsInRootDirectory;

  noOfSectors = UNAL2(bootSector->bpb.totalSectorsInVolumeDOS3);
  if (noOfSectors == 0)
    noOfSectors = (SectorNo) LE4(bootSector->bpb.totalSectorsInVolume);


  vol.maxCluster = (unsigned) ((noOfSectors + vol.bootSectorNo - vol.firstDataSectorNo) /
                vol.sectorsPerCluster) + 1;

  if (vol.maxCluster < 4085) {
#ifdef FAT_12BIT
    vol.flags |= VOLUME_12BIT_FAT;      /* 12-bit FAT */
#else
    DEBUG_PRINT(("Debug: FAT_12BIT must be defined.\r\n"));
    return flFormatNotSupported;
#endif
  }
  vol.bytesPerCluster = vol.sectorsPerCluster * SECTOR_SIZE;
  vol.allocationRover = 2;      /* Set rover at first cluster */
  vol.flags |= VOLUME_MOUNTED;  /* That's it */
  return flOK;
}

#ifndef FL_READ_ONLY
#ifdef DEFRAGMENT_VOLUME

/*----------------------------------------------------------------------*/
/*                       d e f r a g m e n t V o l u m e                */
/*                                                                      */
/* Performs a general defragmentation and recycling of non-writable     */
/* Flash areas, to achieve optimal write speed.                         */
/*                                                                      */
/* NOTE: The required number of sectors (in irLength) may be changed    */
/* (from another execution thread) while defragmentation is active. In  */
/* particular, the defragmentation may be cut short after it began by   */
/* modifying the irLength field to 0.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      ioreq->irLength : Minimum number of sectors to make available   */
/*                        for writes.                                   */
/*                                                                      */
/* Returns:                                                             */
/*      ioreq->irLength : Actual number of sectors available for writes */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus defragmentVolume(Volume vol, IOreq FAR2 *ioreq)
{
  return vol.tl.defragment(vol.tl.rec,&ioreq->irLength);
}

#endif /* DEFRAGMENT_VOLUME */

#ifdef FORMAT_VOLUME

/*-----------------------------------------------------------------------*/
/*                    f l F o r m a t V o l u m e                        */
/*                                                                       */
/* Formats a volume, writing a new and empty file-system. All existing   */
/* data is destroyed. Optionally, a low-level FTL formatting is also     */
/* done.                                                                 */
/* Formatting leaves the volume in the dismounted state, so that a       */
/* flMountVolume call is necessary after it.                             */
/*                                                                       */
/* Note: This routine was left for backwards compatibility with OSAK 4.2 */
/*       and down therfore it is strongly recommended to use the         */
/*       flFormatPhysicalDrive routine instead.                          */
/*                                                                       */
/* Parameters:                                                           */
/*      vol             : Pointer identifying drive                      */
/*      irHandle        : Drive number (0, 1, ...)                       */
/*      irFlags         : FAT_ONLY_FORMAT : Do FAT formatting only       */
/*                        TL_FORMAT_ONLY  : Do TL format only            */
/*                        TL_FORMAT       : Translation layer + FAT      */
/*                        TL_FORMAT_IF_NEEDED: Do TL formatting only if  */
/*                                             current format is invalid */
/*                                             but perform FAT anyway    */
/*      irData          : Address of FormatParams structure to use       */
/*                        (defined in flformat.h)                        */
/*                                                                       */
/* Returns:                                                              */
/*      FLStatus        : 0 on success, otherwise failed                 */
/*-----------------------------------------------------------------------*/

static FLStatus bdFormatVolume(Volume vol, IOreq FAR2 *ioreq)
{
  FormatParams FAR2 *userFp = (FormatParams FAR2 *) ioreq->irData;
  BDTLPartitionFormatParams bdtlFp;
  TLFormatParams tlFp;
  FLBoolean mountOK = FALSE;
  FLStatus status;
  byte socket = FL_GET_SOCKET_FROM_HANDLE(ioreq);

  /* Convert argument to TLFormatParmas */

  tlFp.noOfBinaryPartitions = 0;
  tlFp.noOfBDTLPartitions   = 1;
  tlFp.BDTLPartitionInfo    = NULL;
  tlFp.binaryPartitionInfo  = NULL;
  tlFp.bootImageLen         = userFp->bootImageLen;
  tlFp.percentUse           = (byte)userFp->percentUse;
  tlFp.noOfSpareUnits       = (byte)userFp->noOfSpareUnits;
  tlFp.noOfCascadedDevices  = 0;
  tlFp.progressCallback     = userFp->progressCallback;
  tlFp.vmAddressingLimit    = userFp->vmAddressingLimit;
  tlFp.embeddedCISlength    = (word)userFp->embeddedCISlength;
  tlFp.embeddedCIS          = (byte FAR1 *)userFp->embeddedCIS;
  tlFp.flags                = FL_LEAVE_BINARY_AREA;
#ifdef WRITE_EXB_IMAGE
  tlFp.exbLen               = 0;
#endif /* WRITE_EXB_IMAGE */
#ifdef HW_PROTECTION
  /* protectionKey[8]; */
  tlFp.protectionType       = 0;
#endif /* HW_PROTECTION */

  /* Dismount all physical drive volumes and set handle to the first */

  checkStatus(dismountPhysicalDrive(socket));
  pVol = &vols[socket];

  /* Format according to the irFlags argument */

  if ((ioreq->irFlags & TL_FORMAT)||(ioreq->irFlags & TL_FORMAT_ONLY))
  {
     checkStatus(flFormat(socket,&tlFp,vol.flash));
  }
  else
  {
     status = flMount(socket,socket,&vol.tl,FALSE,vol.flash); /* Try to mount translation layer */
     mountOK = TRUE;
     if ((status == flUnknownMedia || status == flBadFormat) &&
     (ioreq->irFlags & TL_FORMAT_IF_NEEDED))
     {
        status = flFormat(socket,&tlFp,vol.flash);
        mountOK = FALSE;
     }
     else
     {
        /*  assume sector 0 is DOS boot block */
        vol.bootSectorNo     = 0;     
        /* Disable FAT monitoring */
        vol.firstFATSectorNo = vol.secondFATSectorNo = 0; 
        /* Enough to do abs operations */
        vol.flags |= VOLUME_ABS_MOUNTED; 
     }
     if (status != flOK)
        return status;
  }

  if (!mountOK)
    checkStatus(absMountVolume(&vol)); /* Mount the first partition */

#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  if(vol.tl.checkVolume != NULL)
    checkStatus(vol.tl.checkVolume(vol.tl.rec));
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

  if(!(ioreq->irFlags & TL_FORMAT_ONLY))
  {
    /* build BDTL record for dos format routine */

    tffscpy(bdtlFp.volumeId,userFp->volumeId,4);
    bdtlFp.volumeLabel              = (byte FAR1 *)userFp->volumeLabel;
    bdtlFp.noOfFATcopies            = (byte)userFp->noOfFATcopies;
    bdtlFp.flags                    = TL_FORMAT_FAT;
    checkStatus(flDosFormat(&vol.tl,&bdtlFp));
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*            f l F o r m a t P h y s i c a l D r i v e                 */
/*                                                                      */
/* Low Level formats the media while partitioning it.                   */
/* optionaly the followng additional formats are placed                 */
/* 1) writing a new and empty file-system                               */
/* 2) Compressed media format                                           */
/* 3) Quick Mount format                                                */
/*                                                                      */
/* 4) Place M-systems EXB file on the media                             */
/* All existing data is destroyed.                                      */
/* Formatting leaves the volume in the dismounted state, so that a      */
/* flMountVolume call is necessary after it.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol      : Pointer identifying drive                            */
/*      irHandle : Drive number (0, 1, ...)                             */
/*      irFlags  :                                                      */
/*       TL_NORMAL_FORMAT          : Normal format                      */
/*       TL_LEAVE_BINARY_AREA      : Leave binary area unchanged        */
/*                                                                      */
/*      irData   : Address of FormatParams2 structure to use            */
/*                            (defined in flformat.h)                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus bdFormatPhysicalDrive(Volume vol, IOreq FAR2 *ioreq)
{
  FormatParams2  FAR2* userFp = (FormatParams2 FAR2 *) ioreq->irData;
  BDTLPartitionFormatParams FAR2* bdtl;
  TLFormatParams                  tlFp;
  byte     socket = FL_GET_SOCKET_FROM_HANDLE(ioreq);
  byte     partition;
  byte     volNo;
#ifdef COMPRESSION
  FLStatus status;
#endif /* COMPRESSION */

  /***********************************************/
  /* Convert format parameters to TLFormatParams */
  /***********************************************/

  if (userFp->BDTLPartitionInfo == NULL)
     return flBadParameter;

/* Note that the the BDTL partition are shiftet so that the second
   becomes the first ... . This is for backwards compatibility with
   FTP \ NFTL where the first partition is not given as an array    */

  tlFp.bootImageLen         = -1; /* either all or nothing */
  tlFp.percentUse           = userFp->percentUse;
  tlFp.noOfBDTLPartitions   = userFp->noOfBDTLPartitions;
  tlFp.noOfBinaryPartitions = userFp->noOfBinaryPartitions;
  tlFp.BDTLPartitionInfo    = userFp->BDTLPartitionInfo;
  tlFp.binaryPartitionInfo  = userFp->binaryPartitionInfo;
  tlFp.progressCallback     = userFp->progressCallback;
  tlFp.vmAddressingLimit    = userFp->vmAddressingLimit;
  tlFp.embeddedCISlength    = userFp->embeddedCISlength;
  tlFp.embeddedCIS          = userFp->embeddedCIS;
  tlFp.cascadedDeviceNo     = userFp->cascadedDeviceNo;
  tlFp.noOfCascadedDevices  = userFp->noOfCascadedDevices;
  tlFp.flags                = (byte)ioreq->irFlags;

/* Convert last partition arguments from array to dedicated fields */

  bdtl                      = userFp->BDTLPartitionInfo;
  bdtl                     += (userFp->noOfBDTLPartitions - 1);
  tffscpy(tlFp.volumeId,bdtl->volumeId,4);
  tlFp.noOfSpareUnits       = (byte)bdtl->noOfSpareUnits;
  tlFp.volumeLabel          = bdtl->volumeLabel;
  tlFp.noOfFATcopies        = bdtl->noOfFATcopies;
#ifdef HW_PROTECTION
  tffscpy(tlFp.protectionKey,bdtl->protectionKey,PROTECTION_KEY_LENGTH);
  tlFp.protectionType   = bdtl->protectionType;
#endif /* HW_PROTECTION */

  /* Dismount all physical drive volumes  */

  checkStatus(dismountPhysicalDrive(socket));

  /**********************/
  /* Analize EXB buffer */
  /**********************/

  pVol = &vols[socket];
#ifdef WRITE_EXB_IMAGE
  if ((ioreq->irFlags & TL_LEAVE_BINARY_AREA) ||
      ((userFp->exbBufferLen <= 0) && (userFp->exbLen == 0)))
  {
     tlFp.exbLen = 0;
  }
  else
  {
     if (userFp->exbLen <= 0)
     {
        checkStatus(getExbInfo(&vol, userFp->exbBuffer, 
                               userFp->exbBufferLen,
                               userFp->exbFlags));
        tlFp.exbLen = vol.binaryLength;
     }
     else
     {
        tlFp.exbLen = userFp->exbLen;
     }
  }
#endif /* WRITE_EXB_IMAGE */

  /*************************************************/
  /* Perform low level format and write EXB buffer */
  /*************************************************/

  checkStatus(flFormat(socket,&tlFp,vol.flash));

  /****************************************/
  /* perform FAT and ZIP format if needed */
  /****************************************/

  for(partition=0, bdtl = userFp->BDTLPartitionInfo;
      partition<userFp->noOfBDTLPartitions;
      partition++,bdtl++)
  {
     if ( partition > 0)
        checkStatus(findFreeVolume(socket,partition));
     volNo = handleConversionTable[socket][partition];
     pVol = &vols[volNo];
#ifdef COMPRESSION
     if(bdtl->flags & TL_FORMAT_COMPRESSED)
     {
        checkStatus(flMount(volNo,socket,&(vol.tl),FALSE,vol.flash));
        status = flFormatZIP(volNo,&vol.tl);
        vol.tl.dismount(vol.tl.rec);
        if(status!=flOK)
           return status;
     }
#endif /* COMPRESSION */

     checkStatus(absMountVolume(&vol));
#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
     if(vol.tl.checkVolume != NULL)
        checkStatus(vol.tl.checkVolume(vol.tl.rec));
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
     if(bdtl->flags & TL_FORMAT_FAT) /* perform FAT format as well */
        checkStatus(flDosFormat(&vol.tl,bdtl));
     checkStatus(dismountVolume(&vol));
  }

#ifdef WRITE_EXB_IMAGE
  if (userFp->exbBufferLen > 0 )
  {
     pVol = &vols[socket];
     checkStatus(placeExbByBuffer(&vol,(byte FAR1 *)userFp->exbBuffer,
     userFp->exbBufferLen,userFp->exbWindow,userFp->exbFlags));
  }
#endif /* WRITE_EXB_IMAGE */

  checkStatus(mountLowLevel(&vol));
  if (vol.flash->download!=NULL)
  {
     return vol.flash->download(vol.flash); /* download IPL */
  }
  return flOK;
}

/*-----------------------------------------------------------------------*/
/*            f l F o r m a t L o g i c a l D r i v e                    */
/*                                                                       */
/* Formats a logical drive, optionaly writing a new and empty            */
/* file-system and or a compressed format. All existing                  */
/* data is destroyed.                                                    */
/* Formatting leaves the volume in the dismounted state, so that a       */
/* flMountVolume call is necessary after it.                             */
/*                                                                       */
/* Parameters:                                                           */
/*      vol             : Pointer identifying drive                      */
/*      irHandle        : Drive number (0, 1, ...)                       */
/*      irData          : Address of BDTLPartitionFormatParams to use    */
/*                        (defined in flformat.h)                        */
/*                                                                       */
/* Returns:                                                              */
/*      FLStatus        : 0 on success, otherwise failed                 */
/*-----------------------------------------------------------------------*/

static FLStatus bdFormatLogicalDrive(Volume vol, IOreq FAR2 *ioreq)
{
   BDTLPartitionFormatParams FAR2 *userFp =
        (BDTLPartitionFormatParams FAR2 *) ioreq->irData;
   byte       volNo = (byte)(&vol-vols);
#ifdef COMPRESSION
   FLStatus   status;
#endif /* COMPRESSION */

   checkStatus(flMount(volNo,vol.tl.socketNo,&(vol.tl),FALSE,vol.flash));
   /*  assume sector 0 is DOS boot block */
   vol.bootSectorNo     = 0;
   /* Disable FAT monitoring */
   vol.firstFATSectorNo = vol.secondFATSectorNo = 0; 
   /* Enough to do abs operations */
   vol.flags |= VOLUME_ABS_MOUNTED;  

#ifdef COMPRESSION
   if(userFp->flags & TL_FORMAT_COMPRESSED)
   {
      status = flFormatZIP(volNo,&vol.tl,vol.flash);
      vol.tl.dismount(vol.tl.rec);
      if(status!=flOK)
        return status;
   }
#endif /* COMPRESSION */

   if(userFp->flags & TL_FORMAT_FAT) /* perform FAT format as well */
   {
      checkStatus(absMountVolume(&vol));
      checkStatus(flDosFormat(&vol.tl,userFp));
      checkStatus(dismountVolume(&vol));
   }
   return flOK;
}
#endif /* FORMAT_VOLUME */

#endif  /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                  s e c t o r s I n V o l u m e                       */
/*                                                                      */
/* Defines actual number of virtual sectors according to the low-level  */
/* format of the media.                                                 */
/*                                                                      */
/* Returns:                                                             */
/*      vol             : Pointer identifying drive                     */
/*      ioreq->irLength : Actual number of virtual sectors in volume    */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/
static FLStatus sectorsInVolume(Volume vol, IOreq FAR2 *ioreq)
{
  dword sectorsInVol = vol.tl.sectorsInVolume(vol.tl.rec);
  if(sectorsInVol<=vol.bootSectorNo) {
    ioreq->irLength = 0;
    return flGeneralFailure;
  }

  ioreq->irLength = sectorsInVol-vol.bootSectorNo;
  return flOK;
}


#ifdef ABS_READ_WRITE

/*----------------------------------------------------------------------*/
/*                           a b s R e a d                              */
/*                                                                      */
/* Reads absolute sectors by sector no.                                 */
/*                                                                      */
/* Note that if readSecots is not implemented irSectoCount will not     */
/* return the actual number of sectors written in case the operation    */
/* failed in the middle.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irData          : Address of user buffer to read into           */
/*      irSectorNo      : First sector no. to read (sector 0 is the     */
/*                        DOS boot sector).                             */
/*      irSectorCount   : Number of consectutive sectors to read        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irSectorCount   : Number of sectors actually read               */
/*----------------------------------------------------------------------*/

static FLStatus absRead(Volume vol, IOreq FAR2 *ioreq)
{
  char FAR1 *userBuffer = (char FAR1 *) ioreq->irData;
  SectorNo  currSector   = vol.bootSectorNo + ioreq->irSectorNo;
  void FAR0 *mappedSector;
  FLStatus  status;

  if (vol.tl.readSectors != NULL)
  {
     status = vol.tl.readSectors(vol.tl.rec , currSector,
              (byte FAR1* )ioreq->irData , ioreq->irSectorCount);

     if (status == flSectorNotFound)
     {
        /* Do not report unassigned sectors. Simply report all 0's */
        if(vol.tl.sectorsInVolume(vol.tl.rec) >=
           (currSector+ioreq->irSectorCount))
           return flOK;
     }
     return status;
  }
  else
  {
     SectorNo sectorCount  = (SectorNo)ioreq->irSectorCount;
     for (ioreq->irSectorCount = 0;
         (SectorNo)(ioreq->irSectorCount) < sectorCount;
          ioreq->irSectorCount++, currSector++, userBuffer += SECTOR_SIZE)
     {
#ifdef SCATTER_GATHER
        userBuffer = *((char FAR1 **)(ioreq->irData) + 
                    (int)(ioreq->irSectorCount));
#endif
        mappedSector = (void FAR0 *)findSector(&vol,currSector);
        if (mappedSector)
        {
           if(mappedSector==dataErrorToken)
             return flDataError;

           tffscpy(userBuffer,mappedSector,SECTOR_SIZE);
        }
        else
        {
           if(vol.tl.sectorsInVolume(vol.tl.rec)<=(currSector))
              return flSectorNotFound;
           tffsset(userBuffer,0,SECTOR_SIZE);
        }
     }
  }
  return flOK;
}


#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                    r e p l a c e F A T s e c t o r                   */
/*                                                                      */
/* Monitors sector deletions in the FAT.                                */
/*                                                                      */
/* When a FAT block is about to be written by an absolute write, this   */
/* routine will first scan whether any sectors are being logically      */
/* deleted by this FAT update, and if so, it will delete-sector them    */
/* before the actual FAT update takes place.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : FAT Sector no. about to be written            */
/*      newFATsector    : Address of FAT sector about to be written     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus replaceFATsector(Volume vol,
            SectorNo sectorNo,
            const char FAR1 *newFATsector)
{
  const char FAR0 *oldFATsector = (const char FAR0 *)findSector(&vol,sectorNo);
  SectorNo firstSector;
  unsigned firstCluster;
#ifdef FAT_12BIT
  word FAThalfBytes;
  word halfByteOffset;
#else
  word byteOffset;
#endif

  if((oldFATsector==NULL) || oldFATsector==dataErrorToken)
    return flOK;

#ifdef FAT_12BIT
  FAThalfBytes = vol.flags & VOLUME_12BIT_FAT ? 3 : 4;

  firstCluster = (FAThalfBytes == 3) ?
    (((unsigned) (sectorNo - vol.firstFATSectorNo) * (2 * SECTOR_SIZE) + 2) / 3) :
    ((unsigned) (sectorNo - vol.firstFATSectorNo) * (SECTOR_SIZE>>1));
  firstSector    = ((SectorNo) firstCluster - 2) * 
                   vol.sectorsPerCluster + vol.firstDataSectorNo;
  halfByteOffset = (firstCluster * FAThalfBytes) & ((SECTOR_SIZE<<1) - 1);

  /* Find if any clusters were logically deleted, and if so, delete them */
  /* NOTE: We are skipping over 12-bit FAT entries which span more than  */
  /*       one sector. Nobody's perfect anyway.                          */
  for (; halfByteOffset < ((SECTOR_SIZE<<1) - 2);
       firstSector += vol.sectorsPerCluster, 
       halfByteOffset += FAThalfBytes)
  {
    unsigned short oldFATentry, newFATentry;

#ifdef FL_BIG_ENDIAN
    oldFATentry = LE2(*(LEushort FAR0 *)(oldFATsector + (halfByteOffset>>1)));
    newFATentry = LE2(*(LEushort FAR1 *)(newFATsector + (halfByteOffset>>1)));
#else
    oldFATentry = UNAL2(*(Unaligned FAR0 *)(oldFATsector + (halfByteOffset / 2)));
    newFATentry = UNAL2(*(Unaligned FAR1 *)(newFATsector + (halfByteOffset / 2)));
#endif
    if (halfByteOffset & 1) {
      oldFATentry >>= 4;
      newFATentry >>= 4;
    }
    else if (FAThalfBytes == 3) {
      oldFATentry &= 0xfff;
      newFATentry &= 0xfff;
    }
#else
  firstCluster = ((unsigned) (sectorNo - vol.firstFATSectorNo) << (SECTOR_SIZE_BITS-1));
  firstSector = ((SectorNo) firstCluster - 2) * vol.sectorsPerCluster + 
	            vol.firstDataSectorNo;

  /* Find if any clusters were logically deleted, and if so, delete them */
  for (byteOffset = 0; byteOffset < SECTOR_SIZE;
       firstSector += vol.sectorsPerCluster, byteOffset += 2) {
    unsigned short oldFATentry = LE2(*(LEushort FAR0 *)(oldFATsector + byteOffset));
    unsigned short newFATentry = LE2(*(LEushort FAR1 *)(newFATsector + byteOffset));
#endif

    if (oldFATentry != FAT_FREE && newFATentry == FAT_FREE)
      checkStatus(vol.tl.deleteSector(vol.tl.rec,firstSector,vol.sectorsPerCluster));

    /* make sure sector is still there */
    oldFATsector = (const char FAR0 *) findSector(&vol,sectorNo);
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                         a b s W r i t e                              */
/*                                                                      */
/* Writes absolute sectors by sector no.                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irData          : Address of user buffer to write from          */
/*      irSectorNo      : First sector no. to write (sector 0 is the    */
/*                        DOS boot sector).                             */
/*      irSectorCount   : Number of consectutive sectors to write       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irSectorCount   : Number of sectors actually written            */
/*----------------------------------------------------------------------*/

static FLStatus absWrite(Volume vol, IOreq FAR2 *ioreq)
{
  char FAR1 *userBuffer = (char FAR1 *) ioreq->irData;
  SectorNo currSector = vol.bootSectorNo + ioreq->irSectorNo;
  SectorNo sectorCount = (SectorNo)ioreq->irSectorCount;

  if (currSector < vol.secondFATSectorNo &&
      currSector + sectorCount > vol.firstFATSectorNo) {
    SectorNo iSector;

    for (iSector = 0; iSector < sectorCount;
    iSector++, currSector++, userBuffer += SECTOR_SIZE) {

      if (currSector >= vol.firstFATSectorNo &&
      currSector < vol.secondFATSectorNo)
    replaceFATsector(&vol,currSector,userBuffer);
    }

    userBuffer = (char FAR1 *) ioreq->irData;
    currSector = (SectorNo)vol.bootSectorNo + (SectorNo)ioreq->irSectorNo;
  }
  if (vol.tl.writeMultiSector != NULL)
  {
      checkStatus(vol.tl.writeMultiSector(vol.tl.rec, currSector,
                  ioreq->irData,ioreq->irSectorCount));
  }
  else
  {
     for (ioreq->irSectorCount = 0;
          (SectorNo)(ioreq->irSectorCount) < sectorCount;
          ioreq->irSectorCount++, currSector++, userBuffer += SECTOR_SIZE)
     {
#if FILES>0
        if ((currSector == vol.volBuffer.sectorNo) &&
            (&vol == vol.volBuffer.owner))
        {
           vol.volBuffer.sectorNo = UNASSIGNED_SECTOR; /* no longer valid */
           vol.volBuffer.dirty = vol.volBuffer.checkPoint = FALSE;
        }
#endif

#ifdef SCATTER_GATHER
        userBuffer = *((char FAR1 **)(ioreq->irData)+(int)(ioreq->irSectorCount));
#endif
        checkStatus(vol.tl.writeSector(vol.tl.rec,currSector,userBuffer));
     }
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                        a b s D e l e t e                             */
/*                                                                      */
/* Marks absolute sectors by sector no. as deleted.                     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irSectorNo      : First sector no. to write (sector 0 is the    */
/*                        DOS boot sector).                             */
/*      irSectorCount   : Number of consectutive sectors to delete      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus absDelete(Volume vol, IOreq FAR2 *ioreq)
{
  SectorNo first;
  first = (SectorNo)(vol.bootSectorNo + ioreq->irSectorNo);
  return vol.tl.deleteSector(vol.tl.rec,first,(SectorNo)ioreq->irSectorCount);
}

#endif /* FL_READ_ONLY */

#ifndef NO_PHYSICAL_IO
/*----------------------------------------------------------------------*/
/*                       f l A b s A d d r e s s                        */
/*                                                                      */
/* Returns the current physical media offset of an absolute sector by   */
/* sector no.                                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irSectorNo      : Sector no. to address (sector 0 is the DOS    */
/*                        boot sector)                                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irCount         : Offset of the sector on the physical media    */
/*----------------------------------------------------------------------*/

static FLStatus absAddress(Volume vol, IOreq FAR2 *ioreq)
{
  CardAddress cardOffset;
  const void FAR0 * sectorData =
    vol.tl.mapSector(vol.tl.rec,vol.bootSectorNo + ioreq->irSectorNo,&cardOffset);

  if (sectorData) {
    if(sectorData==dataErrorToken)
    return flDataError;

    ioreq->irCount = cardOffset;
    return flOK;
  }
  else
    return flSectorNotFound;
}

#endif /* NO_PHYSICAL_IO */

/*----------------------------------------------------------------------*/
/*                           g e t B P B                                */
/*                                                                      */
/* Reads the BIOS Parameter Block from the boot sector                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irData          : Address of user buffer to read BPB into       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus getBPB(Volume vol, IOreq FAR2 *ioreq)
{
  BPB FAR1 *userBPB = (BPB FAR1 *) ioreq->irData;
  DOSBootSector FAR0 *bootSector;

  bootSector = (DOSBootSector FAR0 *) findSector(&vol,vol.bootSectorNo);
  if(bootSector == NULL)
    return flSectorNotFound;
  if(bootSector==dataErrorToken)
    return flDataError;

  *userBPB = bootSector->bpb;
  return flOK;
}

#ifndef FL_READ_ONLY
#ifdef WRITE_PROTECTION
/*----------------------------------------------------------------------*/
/*              c h a n g e P a s s w o r d                             */
/*                                                                      */
/* Change password for write protectipon.                               */
/*                                                                      */
/* Parameters:                                                          */
/*  vol         : Pointer identifying drive                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus changePassword(Volume vol)
  {
  PartitionTable partitionTable;
  IOreq ioreq;
  FLStatus status;
#ifdef SCATTER_GATHER
  void FAR1 *iovec[1];
#endif

  ioreq.irHandle=(unsigned)(&vol-vols);
  ioreq.irSectorNo=0-(int)vol.bootSectorNo;
  ioreq.irSectorCount=1;
#ifdef SCATTER_GATHER
  iovec[0]     = (void FAR1 *) &partitionTable;
  ioreq.irData = (void FAR1 *) iovec;
#else
  ioreq.irData=&partitionTable;
#endif
    if((status=absRead(&vol,&ioreq))!=flOK)
     return status;
  toUNAL4(partitionTable.passwordInfo[0], 0);
  toUNAL4(partitionTable.passwordInfo[1],vol.password[0]);
  toUNAL4(partitionTable.passwordInfo[2],vol.password[1]);

  vol.flags &= ~VOLUME_WRITE_PROTECTED;

  return absWrite(&vol,&ioreq);
}

/*----------------------------------------------------------------------*/
/*              w r i t e P r o t e c t                                 */
/*                                                                      */
/* Put and remove write protection from the volume                      */
/*                                                                      */
/* Parameters:                                                          */
/*  vol      : Pointer identifying drive                                */
/*  irHandle : Drive number ( 0,1,2...  )                               */
/*  irFlags  : FL_PROTECT   = place protection                          */
/*             FL_UNPROTECT = remove protection                         */
/*             FL_UNLOCK    = remove protection until next dismount     */
/*  irData   : password (8 bytes)                                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus writeProtect(Volume vol,IOreq FAR2*ioreq)
{
  FLStatus status=flWriteProtect;
  dword *flData=(dword *)ioreq->irData;
  dword passCode1 = flData[0] ^ SCRAMBLE_KEY_1;
  dword passCode2 = flData[1] ^ SCRAMBLE_KEY_2;

    switch (ioreq->irFlags) {

      case FL_UNLOCK:     /* unlock volume */
     if((vol.password[0] == passCode1 && vol.password[1] == passCode2)||
        (vol.password[0] == 0 && vol.password[1] == 0))
     {
         vol.flags &= ~VOLUME_WRITE_PROTECTED;
         status=flOK;
     }
     else
        status=flWriteProtect;
     break;

      case FL_UNPROTECT:     /* remove password */
     if(vol.password[0] == passCode1 && vol.password[1] == passCode2)
     {
        vol.password[0] = vol.password[1] = 0;
        status = changePassword(&vol);
     }
     else
        status=flWriteProtect;
     break;

      case FL_PROTECT: /* set password */
    if(vol.password[0] == 0 && vol.password[1] == 0)
       {
       vol.password[0] = passCode1;
       vol.password[1] = passCode2;
       status = changePassword(&vol);
       vol.flags|=VOLUME_WRITE_PROTECTED;
       }
    else
       status=flWriteProtect;
          break;

       default:
    status = flGeneralFailure;
      }
return status;
}
#endif  /* WRITE_PROTECTION */

#endif /* FL_READ_ONLY   */

#endif /* ABS_READ_WRITE */

/*----------------------------------------------------------------------*/
/*                   s o c k e t I n f o                */
/*                                                                      */
/* Get socket Information (window base address)          */
/*                                                                      */
/* Parameters:                                                          */
/*  vol         : Pointer identifying drive         */
/*  baseAddress : pointer to receive window base address   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus socketInfo(Volume vol, dword FAR2 *baseAddress)
{
  *baseAddress = (long)(vol.socket->window.baseAddress) << 12;
  return flOK;
}

#ifdef FL_LOW_LEVEL

/*----------------------------------------------------------------------*/
/*                           g e t P h y s i c a l I n f o              */
/*                                                                      */
/* Get physical information of the media. The information includes      */
/* JEDEC ID, unit size and media size.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irData          : Address of user buffer to read physical       */
/*                        information into.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irLength        : Physical base address of device               */
/*----------------------------------------------------------------------*/

static FLStatus getPhysicalInfo(Volume vol, IOreq FAR2 *ioreq)
{
  PhysicalInfo FAR2 *physicalInfo = (PhysicalInfo FAR2 *)ioreq->irData;

  physicalInfo->type = vol.flash->type;
  physicalInfo->unitSize = vol.flash->erasableBlockSize;
  physicalInfo->mediaSize = vol.flash->chipSize * vol.flash->noOfChips;
  physicalInfo->chipSize = vol.flash->chipSize;
  physicalInfo->interleaving = vol.flash->interleaving;
  switch(vol.flash->mediaType) {
    case NOT_DOC_TYPE:
    physicalInfo->mediaType = FL_NOT_DOC;
    break;
    case DOC_TYPE :
    physicalInfo->mediaType = FL_DOC;
    break;
    case MDOC_TYPE :
    physicalInfo->mediaType = FL_MDOC;
    break;
    case MDOCP_TYPE :
    physicalInfo->mediaType = FL_MDOCP;
    break;
    case DOC2000TSOP_TYPE :
    physicalInfo->mediaType = FL_DOC2000TSOP;
    break;
    case MDOCP_16_TYPE :
    physicalInfo->mediaType = FL_MDOCP_16;
    break;
  }
  socketInfo(&vol,(dword FAR2 *) &(ioreq->irLength));
  return flOK;
}

#ifndef NO_PHYSICAL_IO

/*----------------------------------------------------------------------*/
/*                           p h y s i c a l R e a d                    */
/*                                                                      */
/* Read from a physical address.                                        */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irAddress       : Physical address to read from.                */
/*      irByteCount     : Number of bytes to read.                      */
/*      irData          : Address of user buffer to read into.          */
/*      irFlags         : Mode of the operation.                        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus physicalRead(Volume vol, IOreq FAR2 *ioreq)
{
  /* check that we are reading whithin the media boundaries */
  if (ioreq->irAddress + (long)ioreq->irByteCount > (long)vol.flash->chipSize *
                vol.flash->noOfChips)
    return flBadParameter;

  /* We don't read accross a unit boundary */
  if ((long)ioreq->irByteCount > (long)(vol.flash->erasableBlockSize -
           (ioreq->irAddress % vol.flash->erasableBlockSize)))
    return flBadParameter;

  checkStatus(vol.flash->read(vol.flash, ioreq->irAddress, ioreq->irData,
     (word)ioreq->irByteCount, (word)ioreq->irFlags));
  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                           p h y s i c a l W r i t e                  */
/*                                                                      */
/* Write to a physical address.                                         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irAddress       : Physical address to write to.                 */
/*      irByteCount     : Number of bytes to write.                     */
/*      irData          : Address of user buffer to write from.         */
/*      irFlags         : Mode of the operation.                        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus physicalWrite(Volume vol, IOreq FAR2 *ioreq)
{
  /* check that we are writing whithin the media boundaries */
  if (ioreq->irAddress + (long)ioreq->irByteCount > (long)(vol.flash->chipSize *
      vol.flash->noOfChips))
    return flBadParameter;

  /* We don't write accross a unit boundary */
  if (ioreq->irByteCount > (long)(vol.flash->erasableBlockSize -
      (ioreq->irAddress % vol.flash->erasableBlockSize)))
    return flBadParameter;

  checkStatus(vol.flash->write(vol.flash, ioreq->irAddress, ioreq->irData,
      (dword)ioreq->irByteCount, (word)ioreq->irFlags));
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                           p h y s i c a l E r a s e                  */
/*                                                                      */
/* Erase physical units.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irUnitNo        : First unit to erase.                          */
/*      irUnitCount     : Number of units to erase.                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus physicalErase(Volume vol, IOreq FAR2 *ioreq)
{
  if (ioreq->irUnitNo + (long)ioreq->irUnitCount > (long)
      (vol.flash->chipSize * vol.flash->noOfChips / vol.flash->erasableBlockSize))
    return flBadParameter;

  checkStatus(vol.flash->erase(vol.flash, (word)ioreq->irUnitNo, (word)ioreq->irUnitCount));
  return flOK;
}
#endif /* NO_PHYSICAL_IO */
#endif /* FL_READ_ONLY */


#ifndef NO_IPL_CODE
/*----------------------------------------------------------------------*/
/*                           r e a d I P L                              */
/*                                                                      */
/* Read IPL to user buffer.                                             */
/*                                                                      */
/* Note : Read length must be a multiplication of 512 bytes             */
/* Note : Causes DiskOnChip Millennium Plus to download (i,e protection */
/*        key will be removed from all partitions.                      */
/*                                                                      */
/* Parameters:                                                          */
/*  flash            : Pointer identifying flash medium of the volume   */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*  buf              : User buffer to read into                         */
/*  bufLen           : Size of user buffer                              */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus readIPL(FLFlash* flash, byte FAR1 * buf , dword bufLen)
{
   FLStatus status;
   dword    secondCopyOffset = 1024;

   if(bufLen & 512)
   {
      DEBUG_PRINT(("ERROR - Must read a multiplication of 512 bytes.\r\n"));
      return flBadLength;
   }

   switch (flash->mediaType)
   {
      case MDOCP_TYPE:     /* have a special place for the IPL */
      case MDOCP_16_TYPE:  
         if (flash->readIPL != NULL)
         {
            checkStatus(flash->readIPL(flash,buf,(word)bufLen));
            return flOK;
         }
         break;
      case MDOC_TYPE:
         if(bufLen != 512)
         {
            DEBUG_PRINT(("ERROR - DiskOnChip Millennium 8M has only 512 Bytes of XIP.\r\n"));
            return flBadLength;
         }
         secondCopyOffset = 512;

      case DOC2000TSOP_TYPE: /* Have a special place for the IPL */
         if(bufLen > 1024)
         {
            DEBUG_PRINT(("ERROR - DiskOnChip 2000 TSOP has only 1024 Bytes of XIP.\r\n"));
            return flBadLength;
         }
         if(flash->read != NULL)
         {
            status = flash->read(flash,0,buf,bufLen,EDC);
            if(status != flOK)
               return flash->read(flash,secondCopyOffset,buf,bufLen,EDC);
            return status;
         }
         break;
      default :
         if(bufLen != 512)
         {
            DEBUG_PRINT(("ERROR - DiskOnChip 2000 has only 512 Bytes of XIP.\r\n"));
            return flBadLength;
         }
         if(flash->win != NULL)
         {
            tffscpy(buf,(const void FAR1*)flash->win,bufLen);
         }
         break;
   }
   return flGeneralFailure;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                           w r i t e I P L                            */
/*                                                                      */
/* Write IPL to the proper media location                               */
/*                                                                      */
/* Parameters:                                                          */
/*  flash            : Pointer identifying flash medium of the volume   */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*  buf              : User buffer containin data to write to the IPL   */
/*  bufLen           : Size of user buffer                              */
/*  flags            : FL_IPL_MODE_NORMAL : None Strong Arm mode        */
/*                     FL_IPL_DOWNLOAD    : Download new IPL when done  */
/*                     FL_IPL_MODE_SA     : Strong Arm mode             */
/*                     FL_IPL_MODE_XSCALE : X-Scale mode                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus writeIPL(FLFlash* flash, byte FAR1 * buf , dword bufLen , unsigned flags)
{
   switch (flash->mediaType)
   {
      case DOC2000TSOP_TYPE: /* Have a special place for the IPL */
      case MDOCP_TYPE      :
      case MDOCP_16_TYPE   :
         if (flash->writeIPL != NULL)
            return (flash->writeIPL(flash,buf,(word)bufLen,0,flags));
         DFORMAT_PRINT(("ERROR - MTD does not support write IPL (Please reconfigure MTD).\r\n"));
         break;
      case MDOC_TYPE:
         DFORMAT_PRINT(("ERROR - DiskOnChip Millennium does not support write IPL, use the /BDFK flag.\r\n"));
         break;
      default :
         DFORMAT_PRINT(("ERROR - DiskOnChip 2000 does not support a writiable IPL.\r\n"));
         break;
   }
   return flFeatureNotSupported;
}
#endif /* FL_READ_ONLY */
#endif /* NO_IPL_CODE */

#ifndef NO_INQUIRE_CAPABILITIES

/*----------------------------------------------------------------------*/
/*                  i n q u i r e C a p a b i l i t i e s               */
/*                                                                      */
/* Get the specific device S/W and H/W capabilities                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Record discribing the media                   */
/*                        4 LSB - Socket number                         */
/*      capability      : Enumarator representing the capability        */
/* Returns:                                                             */
/*      capability      : CAPABILITY_SUPPORTED if the capability is     */
/*                        supported                                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void inquireCapabilities(FLFlash* flash , FLCapability FAR2* capability)
{
   FLCapability inquiredCapability = *capability;

   *capability = CAPABILITY_NOT_SUPPORTED;

   switch (inquiredCapability)
   {
#ifdef HW_OTP
      case SUPPORT_UNERASABLE_BBT:
      case SUPPORT_OTP_AREA:
        if(flash->otpSize != NULL)
           *capability = CAPABILITY_SUPPORTED;
        break;
      case SUPPORT_CUSTOMER_ID:
      case SUPPORT_UNIQUE_ID:
        if(flash->getUniqueId != NULL)
           *capability = CAPABILITY_SUPPORTED;
        break;
#endif /* HW_OTP */
      case SUPPORT_MULTIPLE_BDTL_PARTITIONS:
      case SUPPORT_MULTIPLE_BINARY_PARTITIONS:
        if(flash->flags & INFTL_ENABLED)
           *capability = CAPABILITY_SUPPORTED;
        break;

#ifdef HW_PROTECTION
      case SUPPORT_HW_PROTECTION:
      case SUPPORT_HW_LOCK_KEY:
        if(flash->protectionKeyInsert != NULL)
           *capability = CAPABILITY_SUPPORTED;
        break;
#endif /* HW_PROTECTION */
      case SUPPORT_DEEP_POWER_DOWN_MODE:
        if(flash->enterDeepPowerDownMode != NULL)
           *capability = CAPABILITY_SUPPORTED;
    break;
      case SUPPORT_WRITE_IPL_ROUTINE:
    if((flash->mediaType == DOC2000TSOP_TYPE) ||
       (flash->mediaType == MDOC_TYPE))
       *capability = CAPABILITY_SUPPORTED;
    break;
      default:
    break;
   }
}
#endif /* NO_INQUIRE_CAPABILITIES */
#endif /* FL_LOW_LEVEL */

/*----------------------------------------------------------------------*/
/*                   f l B u i l d G e o m e t r y                      */
/*                                                                      */
/* Get C/H/S information of the disk according to number of sectors.    */
/*                                                                      */
/* Parameters:                                                          */
/*  capacity    : Number of Sectors in Volume                           */
/*  cylinders   : Pointer to Number of Cylinders                        */
/*  heads       : Pointer to Number of Heads                            */
/*  sectors     : Pointer to Number of Sectors per Track                */
/*  oldFormat   : True for one sector per culoster                      */
/*                                                                      */
/*----------------------------------------------------------------------*/

void NAMING_CONVENTION flBuildGeometry(dword capacity, dword FAR2 *cylinders,
         dword FAR2 *heads,dword FAR2 *sectors, FLBoolean oldFormat)
{
  dword temp;

  *cylinders = 1024;                 /* Set number of cylinders to max value */

  if (oldFormat == TRUE)
  {
    *sectors = 62L;                     /* Max out number of sectors per track */
    temp = (*cylinders) * (*sectors);   /* Compute divisor for heads           */
    (*heads) = capacity / temp;         /* Compute value for number of heads   */
    if (capacity % temp) {              /* If no remainder, done!              */
      (*heads)++;                       /* Else, increment number of heads     */
      temp = (*cylinders) * (*heads);   /* Compute divisor for sectors         */
      (*sectors) = capacity / temp;     /* Compute value for sectors per track */
      if (capacity % temp) {            /* If no remainder, done!              */
        (*sectors)++;                   /* Else, increment number of sectors   */
        temp = (*heads) * (*sectors);   /* Compute divisor for cylinders       */
        (*cylinders) = capacity / temp; /* Compute number of cylinders         */
      }
    }
  }
  else
  {
     *heads = 16L;                              /* Max out number of heads             */
     temp = (*cylinders) * (*heads);            /* Compute divisor for heads           */
     *sectors = capacity / temp;                /* Compute value for sectors per track */
     while (*sectors > 0x3f ){                  /* While number of sectors too big     */
       *heads *= 2;                             /* use one more head                   */
       temp = (*cylinders) * (*heads);          /* Recompute divisor for heads         */
       *sectors = capacity / temp;              /* Recompute sectors per track         */
     }
     if (capacity % temp) {                     /* If no remainder, done!              */
       (*sectors)++;                            /* Else, increment number of sectors   */
       temp = (*cylinders) * (*sectors);        /* Compute divisor for heads           */
       *heads = capacity / temp;                /* Compute value for heads             */
       if (capacity % temp) {                   /* If no remainder, done!              */
         (*heads)++;                            /* Else, increment number of heads     */
         temp = (*heads) * (*sectors);          /* Compute divisor for cylinders       */
         *cylinders = (dword)(capacity / temp); /* Compute number of cylinders         */
       }
     }
  }
}

/*----------------------------------------------------------------------*/
/*                   v o l u m e I n f o                                */
/*                                                                      */
/* Get general volume Information.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*  vol         : Pointer identifying drive                             */
/*  irHandle    : Drive number (0, 1, ...)                              */
/*  irData      : pointer to VolumeInfoRecord                           */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus volumeInfo(Volume vol, IOreq FAR2 *ioreq)
{
  VolumeInfoRecord FAR2 *info = (VolumeInfoRecord FAR2 *)(ioreq->irData);
#ifdef FL_LOW_LEVEL
  IOreq ioreq2;
  PhysicalInfo physicalInfo;
  char wasLowLevelMounted = 1;
#endif
  TLInfo tlInfo;
#ifdef FL_LOW_LEVEL
  dword eraseCyclesPerUnit;
#endif /* FL_LOW_LEVEL */

#ifdef FL_LOW_LEVEL
  ioreq2.irHandle = ioreq->irHandle;
  if (!(vol.flags & VOLUME_LOW_LVL_MOUNTED)) {
    checkStatus(mountLowLevel(&vol));
    wasLowLevelMounted = 0;
  }
  ioreq2.irData = &physicalInfo;
  checkStatus(getPhysicalInfo(&vol, &ioreq2));
  info->flashType = physicalInfo.type;
  info->physicalUnitSize = (unsigned short)physicalInfo.unitSize;
  info->physicalSize = physicalInfo.mediaSize;
  info->DOCType = physicalInfo.mediaType;
#endif /* FL_LOW_LEVEL */
  tffsset(info->driverVer,0,sizeof(info->driverVer));
  tffsset(info->OSAKVer,0,sizeof(info->OSAKVer));
  tffscpy(info->driverVer,driverVersion,
          TFFSMIN(sizeof(info->driverVer),sizeof(driverVersion)));
  tffscpy(info->OSAKVer,OSAKVersion,
          TFFSMIN(sizeof(info->OSAKVer),sizeof(OSAKVersion)));
  checkStatus(socketInfo(&vol, &(info->baseAddress)));
  checkStatus(vol.tl.getTLInfo(vol.tl.rec,&tlInfo));
  info->logicalSectors = tlInfo.sectorsInVolume;
  info->bootAreaSize = tlInfo.bootAreaSize;

#ifdef ABS_READ_WRITE
  flBuildGeometry( tlInfo.sectorsInVolume,
       (dword FAR2 *)&(info->cylinders),
       (dword FAR2 *)&(info->heads),
       (dword FAR2 *)&(info->sectors),FALSE);
#endif /* ABS_READ_WRITE */

#ifdef FL_LOW_LEVEL

  eraseCyclesPerUnit = vol.flash->maxEraseCycles;
  info->lifeTime = (char)(((tlInfo.eraseCycles /
       (eraseCyclesPerUnit * (physicalInfo.mediaSize / physicalInfo.unitSize)))
       % 10) + 1);
  if(!wasLowLevelMounted)
    dismountLowLevel(&vol);
#endif /* FL_LOW_LEVEL */
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                         b d C a l l                                  */
/*                                                                      */
/* Common entry-point to all file-system functions. Macros are          */
/* to call individual function, which are separately described below.   */
/*                                                                      */
/* Parameters:                                                          */
/*      function        : file-system function code (listed below)      */
/*      ioreq           : IOreq structure                               */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION bdCall(FLFunctionNo functionNo, IOreq FAR2 *ioreq)
{
  Volume vol = NULL;
  FLStatus status;
  byte volNo;
#if defined(FILES) && FILES>0
  File *file;
#endif
  byte socket    = FL_GET_SOCKET_FROM_HANDLE(ioreq);
  byte partition = FL_GET_PARTITION_FROM_HANDLE(ioreq);
  byte curPartitionForEnvVars;

/***********************************************/
/***                                         ***/
/***    find the volume record to work on    ***/
/***                                         ***/
/***********************************************/

  if (initDone == FALSE)
    checkStatus(flInit());

/** ori - We are not taking mutex befre cheking fileTable */

/**************************************/
/* working with open files operations */
/**************************************/

#if defined(FILES) && FILES>0
  /* Verify file handle if applicable */
  if ((functionNo <  INDEX_OPENFILES_END) &&
      ((functionNo != FL_FIND_FILE)||(ioreq->irFlags & FIND_BY_HANDLE)))
  {
     if ((ioreq->irHandle < FILES) &&
     (fileTable[ioreq->irHandle].flags & FILE_IS_OPEN))
     {
        file = fileTable + ioreq->irHandle;
        pVol = file->fileVol;
        socket = vol.tl.socketNo;
        partition = vol.tl.partitionNo;
     }
     else
     {
        return flBadFileHandle;
     }
  }

#endif  /* FILES>0 */

  /* Set environment variable current partition. */
  curPartitionForEnvVars = partition;


/****************************************************/
/* None files operations are divided into 3 groups: */
/*  1. Uses the specific partition volume record.   */
/*  2. Must be called with partition number 0.      */
/*  3. Must use partition number 0 and ignore       */
/*     the given partition (binary operations).     */
/****************************************************/

  if (pVol == NULL)     /* irHandle is drive no. */
  {

     /* Handle sanity check */

     if ((socket    >= noOfSockets) ||
         (partition >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

     volNo = handleConversionTable[socket][partition];

     /* Some operation must not be checked ONLY for socket sanity */

     if((functionNo < INDEX_BINARY_END) &&     /* Group 3 */
        (functionNo > INDEX_BINARY_START))
     {
        volNo = socket;

        /* Binary partitions are numbered after BDTL partitions */
        curPartitionForEnvVars = (byte)(MAX_TL_PARTITIONS+partition);
     }

     /* The rest must be checked for socket and volume sanity */

     else
     {
        if (volNo == INVALID_VOLUME_NUMBER)    /* Group 1 + 2 */
          return flBadDriveHandle;

        /* Some operation must be called with partition 0 */

        if ((functionNo > INDEX_NEED_PARTITION_0_START) &&   /* Group 2 */
            (functionNo < INDEX_NEED_PARTITION_0_END))
        {
            if(partition != 0)
            {
               return flBadDriveHandle;
            }
            else /* Use general verify write environement variable */
            {
               curPartitionForEnvVars = (MAX_TL_PARTITIONS<<1)-1;
            }
        }
     }
     pVol = &vols[volNo];
  }

/********************************************************************/
/***                                                              ***/
/***   Volume record has been found. Now verify that the volume   ***/
/***   record is ready for the specific operation.                ***/
/***                                                              ***/
/********************************************************************/

  status = setBusy(&vol,FL_ON,curPartitionForEnvVars); /* Let everyone know we are here */

/*******************************/
/* Verify S/W write protection */
/*******************************/

#if defined(WRITE_PROTECTION)&& !defined(FL_READ_ONLY)
  if(vol.flags&VOLUME_WRITE_PROTECTED)
     if(
#if defined(FILES) && FILES>0
    ((functionNo > INDEX_WRITE_FILE_START) &&
     (functionNo < FL_LAST_FAT_FUNCTION))  ||
#endif /* FILES > 0 */
#ifdef FORMAT_VOLUME
    (functionNo==BD_FORMAT_VOLUME)         ||
    (functionNo==BD_FORMAT_PHYSICAL_DRIVE) ||
    (functionNo==BD_FORMAT_LOGICAL_DRIVE)  ||
#endif /* FORMAT_VOLUME */
#ifdef WRITE_EXB_IMAGE
    (functionNo==FL_PLACE_EXB)             ||
#endif /* WRITE_EXB_IMAGE */
    (functionNo==FL_DEFRAGMENT_VOLUME)     ||
#ifdef ABS_READ_WRITE
    (functionNo==FL_ABS_WRITE)             ||
    (functionNo==FL_ABS_DELETE)            ||
#endif /* ABS_READ_WRITE */
#ifdef FL_LOW_LEVEL
    (functionNo==FL_PHYSICAL_WRITE)        ||
    (functionNo==FL_PHYSICAL_ERASE)        ||
#endif /* FL_LOW_LEVEL */
#ifdef VERIFY_VOLUME
    (functionNo==FL_VERIFY_VOLUME)         ||
#endif /* VERIFY_VOLUME */
    0)
  {
     status = flWriteProtect;
     goto flCallExit;
  }

#endif /* WRITE_PROTECTION  && !FL_READ_ONLY */

/***********************************************/
/* Binary partition operations                 */
/* Low level mount and direct call the routine */
/***********************************************/

#ifdef BDK_ACCESS
  if ((functionNo > INDEX_BINARY_START) &&
      (functionNo < INDEX_BINARY_END  )    )
  {
#ifdef WRITE_EXB_IMAGE
     if ((functionNo != FL_BINARY_PROTECTION_INSERT_KEY) &&
         (functionNo != FL_BINARY_PROTECTION_REMOVE_KEY))
        vol.moduleNo = INVALID_MODULE_NO; /* Stop place EXB operation */
#endif
     /* Mount flash and call binary module to proccess request */

     if (!(pVol->flags & VOLUME_LOW_LVL_MOUNTED))
        status = mountLowLevel(&vol);
     if (status == flOK)
        status = bdkCall(functionNo,ioreq,pVol->flash);
     goto flCallExit;
  }
#endif /* BDK_ACCESS */

/***********************************/
/* None binary routine             */
/* Nag about mounting if necessary */
/***********************************/

  switch (functionNo) {
#if FILES > 0
    case FL_LAST_FAT_FUNCTION:
      status = flBadFunction;
      goto flCallExit;
#endif

/* Pre mount routine - Make sure the volume is low level disMounted */

    case FL_ABS_MOUNT:
    case FL_MOUNT_VOLUME:
#ifndef FL_READ_ONLY
#ifdef FORMAT_VOLUME
    case BD_FORMAT_VOLUME:
    case BD_FORMAT_LOGICAL_DRIVE:
#endif /* FORMAT_VOLUME */
#endif /* FL_READ_ONLY */
#ifdef FL_LOW_LEVEL
      if (vol.flags & VOLUME_LOW_LVL_MOUNTED)
         dismountLowLevel(&vol);  /* mutual exclusive mounting */
#endif /* FL_LOW_LEVEL */
      break;

/* Physical operation must have the device low level (MTD) mounted */

/* Do not need any special operation */

    case FL_UPDATE_SOCKET_PARAMS:
    case FL_COUNT_VOLUMES:
#if (defined(FORMAT_VOLUME) && !defined(FL_READ_ONLY))
    case FL_WRITE_BBT:
#endif
#ifdef HW_PROTECTION
    case FL_PROTECTION_GET_TYPE:
    case FL_PROTECTION_REMOVE_KEY:
    case FL_PROTECTION_INSERT_KEY:
#ifndef FL_READ_ONLY
    case FL_PROTECTION_SET_LOCK:
    case FL_PROTECTION_CHANGE_KEY:
    case FL_PROTECTION_CHANGE_TYPE:
#endif /* FL_READ_ONLY */
#endif /* HW_PROTECTION */
#ifdef QUICK_MOUNT_FEATURE
    case FL_CLEAR_QUICK_MOUNT_INFO:
#endif /* QUICK_MOUNT_FEATURE */ 
       break;

/* MTD must be mounted first */

#ifdef FL_LOW_LEVEL

/* Some physical operation must not be done while abs mounted */
    case FL_GET_PHYSICAL_INFO:
    case FL_PHYSICAL_READ:
#ifndef FL_READ_ONLY
    case FL_PHYSICAL_WRITE:
    case FL_PHYSICAL_ERASE:
#endif /* FL_READ_ONLY */
#ifndef BDK_ACCESS
#ifdef MULTI_DOC
#ifdef ENVIRONMENT_VARS
      if (flUseMultiDoc == FL_ON)
#endif
      {
         volNo = handleConversionTable[0][0];
         if ((volNo != INVALID_VOLUME_NUMBER) &&
             (pVol[volNo].flags & VOLUME_ABS_MOUNTED))
#else
      {
         if(vol.flags & VOLUME_ABS_MOUNTED)
#endif
         {
            status = flGeneralFailure;  /* mutual exclusive mounting */
            goto flCallExit;
         }
      }
#endif /* BDK_ACCESS */
#ifndef NO_INQUIRE_CAPABILITIES
    case FL_INQUIRE_CAPABILITIES:
#endif /* NO_INQUIRE_CAPABILITIES */
    case FL_DEEP_POWER_DOWN_MODE:
#ifdef HW_OTP
    case FL_OTP_SIZE:
    case FL_OTP_READ:
#ifndef FL_READ_ONLY
    case FL_OTP_WRITE:
#endif /* FL_READ_ONLY */
    case FL_UNIQUE_ID:
    case FL_CUSTOMER_ID:
#endif /* HW_OTP */
#ifndef NO_IPL_CODE
    case FL_READ_IPL:
#ifndef FL_READ_ONLY
    case FL_WRITE_IPL:
#endif /* FL_READ_ONLY */
#endif /* NO_IPL_CODE */
#ifndef FL_READ_ONLY
#ifdef WRITE_EXB_IMAGE
    case FL_PLACE_EXB:
#endif /* WRITE_EXB_IMAGE */
#ifdef FORMAT_VOLUME
    case BD_FORMAT_PHYSICAL_DRIVE:
#endif /* FORMAT_VOLUME */
#endif /* FL_READ_ONLY */

      if (!(vol.flags & VOLUME_LOW_LVL_MOUNTED))
      {
         status = mountLowLevel(&vol);  /* automatic low level mounting */
      }
      else
      {
         status = flOK;
#ifndef FIXED_MEDIA
         status = flMediaCheck(vol.socket);
         if (status == flDiskChange)
            status = mountLowLevel(&vol); /* card was changed, remount */
#endif /* FIXED_MEDIA */
      }
      if (status != flOK)
      {
         dismountLowLevel(&vol);
         goto flCallExit;
      }
      break;
#endif /* FL_LOW_LEVEL */

/* Check for abs mount */


	

	
	default:
      if (vol.flags & VOLUME_ABS_MOUNTED)
      {
#ifndef NT5PORT
         FLStatus status = flOK;
#else /*NT5PORT*/
         FLStatus istatus = flOK;
#endif /*NT5PORT*/

#ifndef FIXED_MEDIA
#ifndef NT5PORT
         status = flMediaCheck(vol.socket);
#else /*NT5PORT*/
         istatus = flMediaCheck(vol.socket);
#endif /*NT5PORT*/
#endif /*FIXED_MEDIA*/

#ifndef NT5PORT
         if (status != flOK)
#else /*NT5PORT*/
         if (istatus != flOK)
#endif /*NT5PORT*/
            dismountVolume(&vol);
      }
      if (!(vol.flags & VOLUME_ABS_MOUNTED)
#if defined(FILES) && FILES>0
          && (functionNo > FL_LAST_FAT_FUNCTION)
#endif
      )
      {
         status = flNotMounted;
         goto flCallExit;
      }

/* We know that the tl is abs mounted (except for files )
   now check for high level mounted                       */

      if (!( vol.flags  & VOLUME_MOUNTED        ) &&
           ( functionNo != FL_DISMOUNT_VOLUME   ) &&
           ( functionNo != FL_CHECK_VOLUME      ) &&
#ifndef FL_READ_ONLY
           ( functionNo != FL_DEFRAGMENT_VOLUME ) &&
#endif  /* FL_READ_ONLY */
#ifdef ABS_READ_WRITE
           ( functionNo != FL_ABS_READ          ) &&
           ( functionNo != FL_ABS_ADDRESS       ) &&
#ifndef FL_READ_ONLY
           ( functionNo != FL_ABS_WRITE         ) &&
           ( functionNo != FL_ABS_DELETE        ) &&
#endif  /* FL_READ_ONLY */
#endif /* ABS_READ_WRITE */
#if (defined(WRITE_PROTECTION) && !defined(FL_READ_ONLY))
           ( functionNo != FL_WRITE_PROTECTION  ) &&
#endif /* WRITE_PROTECTION */
#ifdef VERIFY_VOLUME
           ( functionNo != FL_VERIFY_VOLUME     ) &&
#endif /* VERIFY_VOLUME */
           ( functionNo != FL_READ_BBT          ) &&
           ( functionNo != FL_SECTORS_IN_VOLUME ) &&
           ( functionNo != FL_VOLUME_INFO       ))
      {
         status = flNotMounted;
         goto flCallExit;
      }
  }

/*****************************************************/
/***                                               ***/
/***   The Volume record is already initialized.   ***/
/***   Exceute the proper function.                ***/
/***                                               ***/
/*****************************************************/

  switch (functionNo) {

#if defined(FILES) && FILES > 0
#ifndef FL_READ_ONLY
    case FL_FLUSH_BUFFER:
      status = flushBuffer(&vol);
      break;
#endif /* FL_READ_ONLY  */
    case FL_OPEN_FILE:
      status = openFile(&vol,ioreq);
      break;

    case FL_CLOSE_FILE:
      status = closeFile(file);
      break;
#ifndef FL_READ_ONLY
#ifdef SPLIT_JOIN_FILE
    case FL_JOIN_FILE:
      status = joinFile(file, ioreq);
      break;

    case FL_SPLIT_FILE:
      status = splitFile(file, ioreq);
      break;
#endif
#endif  /* FL_READ_ONLY */
    case FL_READ_FILE:
      status = readFile(file,ioreq);
      break;
#ifndef FL_READ_ONLY
    case FL_WRITE_FILE:
      status = writeFile(file,ioreq);
      break;
#endif
    case FL_SEEK_FILE:
      status = seekFile(file,ioreq);
      break;

    case FL_FIND_FILE:
      status = findFile(&vol,file,ioreq);
      break;

    case FL_FIND_FIRST_FILE:
      status = findFirstFile(&vol,ioreq);
      break;

    case FL_FIND_NEXT_FILE:
      status = findNextFile(file,ioreq);
      break;

    case FL_GET_DISK_INFO:
      status = getDiskInfo(&vol,ioreq);
      break;
#ifndef FL_READ_ONLY
    case FL_DELETE_FILE:
      status = deleteFile(&vol,ioreq,FALSE);
      break;

#ifdef RENAME_FILE
    case FL_RENAME_FILE:
      status = renameFile(&vol,ioreq);
      break;
#endif

#ifdef SUB_DIRECTORY
    case FL_MAKE_DIR:
      status = makeDir(&vol,ioreq);
      break;

    case FL_REMOVE_DIR:
      status = deleteFile(&vol,ioreq,TRUE);
      break;
#endif
#endif /* FL_READ_ONLY */
#endif /* FILES > 0 */

    case FL_MOUNT_VOLUME:
      status = mountVolume(&vol,&(ioreq->irFlags));
      break;

    case FL_DISMOUNT_VOLUME:
      status = dismountVolume(&vol);
      break;

    case FL_CHECK_VOLUME:
      status = flOK;            /* If we got this far */
      break;

    case FL_UPDATE_SOCKET_PARAMS:
      status = updateSocketParameters(flSocketOf(ioreq->irHandle), ioreq->irData);
      break;

#ifndef NO_READ_BBT_CODE
    case FL_READ_BBT:
      if(vol.tl.readBBT != NULL)
      {
         status = vol.tl.readBBT(vol.tl.rec,(CardAddress FAR1 *)ioreq->irData,
                 &(ioreq->irLength),&(ioreq->irFlags));
      }
      else
      {
         status = flFeatureNotSupported;
      }
      break;
#endif /* NO_READ_BBT_CODE */

#ifndef FL_READ_ONLY
#ifdef DEFRAGMENT_VOLUME
    case FL_DEFRAGMENT_VOLUME:
      status = defragmentVolume(&vol,ioreq);
      break;
#endif /* DEFRAGMENT_VOLUME */

#if defined (FORMAT_VOLUME) && !defined(FL_READ_ONLY)
    case BD_FORMAT_VOLUME:
      status = bdFormatVolume(&vol,ioreq);
      break;

    case BD_FORMAT_PHYSICAL_DRIVE:
      status = bdFormatPhysicalDrive(&vol,ioreq);
      break;

    case BD_FORMAT_LOGICAL_DRIVE:
      status = bdFormatLogicalDrive(&vol,ioreq);
      break;

#endif /* FORMAT_VOLUME AND NOT FL_READ_ONLY */
#ifdef WRITE_EXB_IMAGE
    case FL_PLACE_EXB:
      status = placeExbByBuffer(&vol,(byte FAR1*)ioreq->irData,
           ioreq->irLength,(word)ioreq->irWindowBase ,(word)ioreq->irFlags);
      break;

#endif /* WRITE_EXB_IMAGE */
#endif  /* FL_READ_ONLY */

    case FL_SECTORS_IN_VOLUME:
      status = sectorsInVolume(&vol,ioreq);
      break;

    case FL_ABS_MOUNT:
      status = absMountVolume(&vol);
      break;

#ifdef ABS_READ_WRITE
    case FL_ABS_READ:
      status = absRead(&vol,ioreq);
      break;

#ifndef NO_PHYSICAL_IO
    case FL_ABS_ADDRESS:
      status = absAddress(&vol,ioreq);
      break;
#endif /* NO_PHYSICAL_IO */

#ifndef FL_READ_ONLY
    case FL_ABS_DELETE:
      status = absDelete(&vol,ioreq);
      break;

    case FL_ABS_WRITE:
      status = absWrite(&vol,ioreq);
      break;

#endif  /* FL_READ_ONLY */

    case FL_GET_BPB:
      status = getBPB(&vol,ioreq);
      break;

#ifndef FL_READ_ONLY
#if (defined(WRITE_PROTECTION) && !defined(FL_READ_ONLY))
    case FL_WRITE_PROTECTION :
     status = writeProtect(&vol,ioreq);
     break;

#endif /* WRITE_PROTECTION */
#endif /* FL_READ_ONLY     */
#endif /* ABS_READ_WRITE   */

#ifdef VERIFY_VOLUME
    case FL_VERIFY_VOLUME :
     if ((vol.tl.checkVolume != NULL) &&
         (ioreq->irData      == NULL) &&
         (ioreq->irLength    == 0   )   )
     {
        status = vol.tl.checkVolume(vol.tl.rec);
     }
     else
     {
        status = flFeatureNotSupported;
     }
     break;
#endif /* VERIFY_VOLUME */

#ifdef FL_LOW_LEVEL
    case FL_GET_PHYSICAL_INFO:
      status = getPhysicalInfo(&vol, ioreq);
      break;

#ifndef NO_PHYSICAL_IO
    case FL_PHYSICAL_READ:
      status = physicalRead(&vol, ioreq);
      break;

#ifndef FL_READ_ONLY
    case FL_PHYSICAL_WRITE:
      status = physicalWrite(&vol, ioreq);
      break;

    case FL_PHYSICAL_ERASE:
      status = physicalErase(&vol, ioreq);
      break;
#endif /* FL_READ_ONLY */
#endif /* NO_PHYSICAL_IO */

      /* direct calls to the MTD */
#ifdef HW_OTP
    case FL_OTP_SIZE:
      if (vol.flash->otpSize != NULL)
      {
        word tmp = (word)ioreq->irFlags;
        status = vol.flash->otpSize(vol.flash, (dword FAR2 *)(&ioreq->irCount ),
                                               (dword FAR2 *)(&ioreq->irLength),
                                               &tmp);
        ioreq->irFlags = (unsigned)tmp;
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;

    case FL_OTP_READ:
      if (vol.flash->readOTP != NULL)
      {
        status = vol.flash->readOTP(vol.flash, (word)ioreq->irCount,
                       ioreq->irData, (word)ioreq->irLength);
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;

#ifndef FL_READ_ONLY
    case FL_OTP_WRITE:
      if (vol.flash->writeOTP != NULL)
      {
         status = vol.flash->writeOTP(vol.flash,ioreq->irData,
                         (word)ioreq->irLength);
      }
      else
      {
         status = flFeatureNotSupported;
      }
      break;

#endif /* FL_READ_ONLY */

    case FL_UNIQUE_ID:
      if (vol.flash->getUniqueId !=NULL)
      {
         status = vol.flash->getUniqueId(vol.flash, ioreq->irData);
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;

    case FL_CUSTOMER_ID:
      if (vol.flash->getUniqueId !=NULL)
      {
        byte buf[UNIQUE_ID_LEN];
        status = vol.flash->getUniqueId (vol.flash, buf);
        tffscpy (ioreq->irData,buf,CUSTOMER_ID_LEN);
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;
#endif /* HW_OTP */

#ifndef NO_IPL_CODE
#ifndef FL_READ_ONLY
    case FL_WRITE_IPL:
      status = writeIPL(vol.flash,(byte FAR1*)ioreq->irData,ioreq->irLength,ioreq->irFlags);
      break;
#endif /* FL_READ_ONLY */
    case FL_READ_IPL:
      status = readIPL(vol.flash,(byte FAR1*)ioreq->irData,ioreq->irLength);
      break;
#endif /* NO_IPL_CODE */

    case FL_DEEP_POWER_DOWN_MODE:
      if (vol.flash->enterDeepPowerDownMode !=NULL)
      {
        vol.flash->enterDeepPowerDownMode(vol.flash,(word)ioreq->irFlags);
        status = flOK;
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;

#ifndef NO_INQUIRE_CAPABILITIES
    case FL_INQUIRE_CAPABILITIES:
      inquireCapabilities(vol.flash,(FLCapability FAR2 *)&(ioreq->irLength));
      break;
#endif /* NO_INQUIRE_CAPABILITIES */

#endif /* FL_LOW_LEVEL */

    case FL_VOLUME_INFO:
      status = volumeInfo(&vol, ioreq);
      break;

     /* Pre mount routines */
#if (defined(FORMAT_VOLUME) && !defined(FL_READ_ONLY))
    case FL_WRITE_BBT:
#ifndef NT5PORT
		checkStatus(dismountPhysicalDrive(socket));
#else /*NT5PORT*/
		status = dismountPhysicalDrive(socket);
	    if (status != flOK)
		  goto flCallExit;
#endif /*NT5PORT*/
#endif
    case FL_COUNT_VOLUMES:
#ifdef QUICK_MOUNT_FEATURE
    case FL_CLEAR_QUICK_MOUNT_INFO:
#endif /* QUICK_MOUNT_FEATURE */ 
#ifdef HW_PROTECTION
    case FL_PROTECTION_GET_TYPE:
    case FL_PROTECTION_REMOVE_KEY:
    case FL_PROTECTION_INSERT_KEY:
#ifndef FL_READ_ONLY
    case FL_PROTECTION_SET_LOCK:
    case FL_PROTECTION_CHANGE_KEY:
    case FL_PROTECTION_CHANGE_TYPE:
#endif /* FL_READ_ONLY */
#endif  /* HW_PROTECTION */
      status = flPreMount(functionNo , ioreq , vol.flash);
      break;
    default:
      status = flBadFunction;
  }

#if ((defined(FILES)) && (FILES > 0) && (!defined(FL_READ_ONLY)))
  if (vol.volBuffer.checkPoint)
  {
     FLStatus st = flushBuffer(&vol);
     if (status == flOK)
        status = st;
  }
#endif

/*********************************************/
/* Exit nicely - Release mutex of the socket */
/*********************************************/

flCallExit:
  if(status==flOK)
    status = setBusy(&vol,FL_OFF,curPartitionForEnvVars);
  else
    setBusy(&vol,FL_OFF,curPartitionForEnvVars); /* We're leaving */

  return status;
}

#if POLLING_INTERVAL != 0

/*----------------------------------------------------------------------*/
/*                 s o c k e t I n t e r v a l R o u t i n e            */
/*                                                                      */
/* Routine called by the interval timer to perform periodic socket      */
/* actions and handle the watch-dog timer.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

/* Routine called at time intervals to poll sockets */
static void socketIntervalRoutine(void)
{
  unsigned volNo;
  Volume vol = vols;

  flMsecCounter += POLLING_INTERVAL;

  for (volNo = 0; volNo < noOfSockets; volNo++, pVol++)
    if (flTakeMutex(&flMutex[volNo])) {
#ifdef FL_BACKGROUND
      if (vol.flags & VOLUME_ABS_MOUNTED)
    /* Allow background operation to proceed */
    vol.tl.tlSetBusy(vol.tl.rec,FL_OFF);
#endif
      flIntervalRoutine(vol.socket);
      flFreeMutex(&flMutex[volNo]);
    }
}

#endif /* POLLING_INTERVAL != 0 */

/*----------------------------------------------------------------------*/
/*                          f l I n i t                                 */
/*                                                                      */
/* Initializes the FLite system, sockets and timers.                    */
/*                                                                      */
/* Calling this function is optional. If it is not called,              */
/* initialization will be done automatically on the first FLite call.   */
/* This function is provided for those applications who want to         */
/* explicitly initialize the system and get an initialization status.   */
/*                                                                      */
/* Calling flInit after initialization was done has no effect.          */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus flInit(void)
{
  if (!initDone) {
    FLStatus status;
    unsigned volNo;
    Volume vol = vols;
    IOreq req;
#ifdef LOG_FILE
    FILE *out;

    out=FL_FOPEN("EDCerr.txt","w");
    FL_FPRINTF(out,"EDC error LOG\n");
    FL_FCLOSE(out);
#endif /* LOG_FILE */

 flInitGlobalVars();

#ifdef ENVIRONMENT_VARS

 /* Call users initialization routine for :
  *  flUse8Bit,flUseNFTLCache,flUseisRAM
  */
 flSetEnvVar();

 if(flUse8Bit==1)
 {
    tffscpy = flmemcpy;
    tffscmp = flmemcmp;
    tffsset = flmemset;
 }
 else
 {
    tffscpy = flcpy;
    tffsset = flset;
    tffscmp = flcmp;
 }

#endif /* ENVIRONMENT_VARS */

   /*
    * 1) Mark all the volumes as not used and free to be allocated.
    * 2) Clear passowrd in order to make it invald.
    */
   
    tffsset(vols,0,sizeof(vols));

    for (volNo = 0,pVol = vols; volNo < VOLUMES; volNo++,pVol++)
    {     
      /* The actual number of sockets is not yet known and will be retreaved by
       * flRegisterComponents routine by the socket componenets. For now supply
       * each of the possible sockets with its buffer and socket number.
       */
       if ( volNo < SOCKETS)
       {
          vol.socket = flSocketOf(volNo);
          vol.flash  = flFlashOf(volNo);
          tffsset(vol.socket,0,sizeof(FLSocket));          
          tffsset(vol.flash,0,sizeof(FLFlash));
          vol.socket->volNo = volNo;         
#ifdef WRITE_EXB_IMAGE
          vol.moduleNo = INVALID_MODULE_NO; /* Ready for exb write operation */
#endif
       }
       else
       {
           vol.flash = NULL;
       }
       vol.volExecInProgress = NULL;
    }

#if FILES > 0
    initFS();
#endif

    flSysfunInit();

#ifdef FL_BACKGROUND
    flCreateBackground();
#endif
    /* Initialize variales */
    for (noOfTLs = 0 ;noOfTLs < TLS;noOfTLs++)
    {
       tlTable[noOfTLs].mountRoutine     = NULL;
       tlTable[noOfTLs].preMountRoutine  = NULL;
       tlTable[noOfTLs].formatRoutine    = NULL;
    }
    initDone    = TRUE;
    noOfTLs     = 0;
    noOfDrives  = 0;
    noOfSockets = 0;
    noOfMTDs    = 0;

    checkStatus(flRegisterComponents());

#ifdef COMPRESSION
    checkStatus(flRegisterZIP());
#endif

#ifdef MULTI_DOC
#ifdef ENVIRONMENT_VARS
    if(flUseMultiDoc==FL_ON)
    {
      checkStatus(flRegisterMTL());
    }
#else
    checkStatus(flRegisterMTL());
#endif /* ENVIRONMENT_VARS */
#endif /* MULT_DOC */

#ifdef BDK_ACCESS
    bdkInit();
#endif

    checkStatus(flInitSockets());

#if POLLING_INTERVAL > 0
    checkStatus(flInstallTimer(socketIntervalRoutine,POLLING_INTERVAL));
#endif

  /*
   * Now that the number of actual sockets is known, create a mutex for
   * each of the systems sockets. Multi-doc uses only 1 mutex.
   */

#ifdef MULTI_DOC
   if ((noOfSockets)
#ifdef ENVIRONMENT_VARS
       &&(flUseMultiDoc == FL_ON)
#endif /* ENVIRONMENT_VARS */
      )
   {   /* All sockets use the same mutex */

      if (flCreateMutex(&flMutex[0]) != flOK)
         return flGeneralFailure;

      for (volNo = 0; volNo < noOfSockets ; volNo++)
      {
         vols[volNo].volExecInProgress = &flMutex[0];
      }
   }
   else
#endif /* MULTI_DOC */
   {   /* Each socket uses a diffren mutex */

      for (volNo = 0; volNo < noOfSockets ; volNo++)
      {
         if (flCreateMutex(&flMutex[volNo]) != flOK)
            return flGeneralFailure;
         vols[volNo].volExecInProgress   = &flMutex[volNo];
      }
   }

    /* Count the number of volumes on all the systems sockets and
     * initialize conversion table. The table is used to convert a socket
     * and a partition numbers to the correct volume index in the vols record.
     * Partition 0 of each of the sockets will recieve the volume record
     * indexed with the socket number in the vols array. The rest of the
     * volumes will be serialy allocated. New volume records can be allocated
     * By the format routine. The format and the write BBT routines clear all
     * volume records taken by the sockets except for the first.
     *
     * The partition and socket are passed to the TL module using 2 dedicated
     * fields in the TL record. Both those values are also initiaized.
     * All volumes on a specific socket will share the same mutex.
     */

    tffsset(handleConversionTable,INVALID_VOLUME_NUMBER, /* Clear table */
      sizeof(handleConversionTable));

    for (pVol = vols , noOfDrives = (unsigned)noOfSockets , req.irHandle = 0;
     req.irHandle < noOfSockets; req.irHandle++, pVol++)
    {
       /* Initialize partition 0 */

       handleConversionTable[req.irHandle][0] = (byte)req.irHandle;
       vol.tl.socketNo         = (byte)req.irHandle;
       vol.tl.partitionNo      = 0;
       vol.flags = VOLUME_ACCUPIED;

       /* The rest of the partitions are initialzed only if multi-doc
    * is not active since Multi-doc supports only the first volume
    * of each socket.
    */

       status =  flPreMount(FL_COUNT_VOLUMES , &req , vol.flash);
       if (status == flOK)
       {
          vol.volExecInProgress = &flMutex[req.irHandle];
          for(volNo = 1;(volNo < req.irFlags) && (noOfDrives < VOLUMES); volNo++,noOfDrives++)
          {
             handleConversionTable[req.irHandle][volNo] = (byte)noOfDrives;
             vols[noOfDrives].socket         = vol.socket;
             vols[noOfDrives].flash          = vol.flash;
             vols[noOfDrives].tl.socketNo    = (byte)req.irHandle;
             vols[noOfDrives].tl.partitionNo = (byte)volNo;
             vols[noOfDrives].volExecInProgress =
             vol.volExecInProgress;
             vol.flags = VOLUME_ACCUPIED;
          }
       }
    }
  }
  return flOK;
}

#ifdef EXIT

/*----------------------------------------------------------------------*/
/*                          f l E x i t                                 */
/*                                                                      */
/* If the application ever exits, flExit should be called before exit.  */
/* flExit flushes all buffers, closes all open files, powers down the   */
/* sockets and removes the interval timer.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      Nothing                                                         */
/*----------------------------------------------------------------------*/

void NAMING_CONVENTION flExit(void)
{
  unsigned volNo;
  Volume vol = vols;
  FLBoolean mutexTaken = FALSE;

  if(flInit==FALSE)
      return;

  /* Dismount the TL and MTD */

  for (volNo = 0; (volNo < VOLUMES); volNo++,pVol++)
  {
     if ((vol.flags & VOLUME_ACCUPIED) && (setBusy(&vol,FL_ON,vol.tl.partitionNo) == flOK))
     {
        dismountVolume(&vol);

#ifdef FL_LOW_LEVEL
        dismountLowLevel(&vol);
#endif
        setBusy(&vol,FL_OFF,vol.tl.partitionNo);
     }
  }

  /* Dismount SOCKET  */

  pVol = vols;
  for (volNo = 0; volNo < noOfSockets ; volNo++,pVol++)
  {
#ifdef MULTI_DOC
#ifdef ENVIRONMENT_VARS
      if (flUseMultiDoc == FL_ON)     /* multi-doc not active */
#endif /* ENVIRONMENT_VARS */
     if (volNo == 0)
#endif /* MULTI_DOC */
        mutexTaken = (setBusy(&vol,FL_ON,vol.tl.partitionNo) == flOK) ? TRUE:FALSE;

     if (mutexTaken == TRUE)
     {
        flFreeMutex(execInProgress);  /* free the mutex that was taken in setBusy(FL_ON) */
        /* delete mutex protecting FLite volume access */
        flDeleteMutex(execInProgress);
        mutexTaken = FALSE;
     }
     flExitSocket(vol.socket);
  }

#if POLLING_INTERVAL != 0
  flRemoveTimer();
#endif

#ifdef ALLOCTST
  out_data_sz();
#endif
  initDone           = FALSE;
  initGlobalVarsDone = FALSE;
  pVol = NULL;
}

#ifdef __BORLANDC__
#ifdef EXIT
#pragma exit flExit
#endif /* EXIT */
#include <dos.h>

static int cdecl flBreakExit(void)
{
  flExit();

  return 0;
}

static void setCBreak(void)
{
  ctrlbrk(flBreakExit);
}

#pragma startup setCBreak

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\docsys.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCSYS.C_V  $
 * 
 *    Rev 1.16   Apr 15 2002 08:30:30   oris
 * Added support for USE_TFFS_COPY compilation flag. This flag is used by bios driver a Boot SDK in order to improove performance.
 * 
 *    Rev 1.15   Apr 15 2002 07:35:56   oris
 * Reorganized for final release.
 * 
 *    Rev 1.14   Jan 28 2002 21:24:10   oris
 * Removed static prefix to all runtime configurable memory access routines.
 * Replaced FLFlash argument with DiskOnChip memory base pointer.
 * Changed interface of write and set routines (those that handle more then 8/16 bits) so that instead of FLFlash record they receive the DiskOnChip memory window base pointer and offset (2 separated arguments). The previous implementation did not support address shifting properly.
 * Changed tffscpy and tffsset to flcpy and flset when flUse8bit equals 0.
 * Changed memWinowSize to memWindowSize
 * 
 *    Rev 1.13   Jan 17 2002 22:59:30   oris
 * Completely revised, to support runtime customization and all M-Systems
 * DiskOnChip devices.
 * 
 *    Rev 1.12   Sep 25 2001 15:35:02   oris
 * Restored to OSAK 4.3 implementation.
 * 
 */

/************************************************************************/
/*                                                                      */
/*      FAT-FTL Lite Software Development Kit                           */
/*      Copyright (C) M-Systems Ltd. 1995-2001                          */
/*                                                                      */
/************************************************************************/

#include "docsys.h" 

/*                                                                   
 * Uncomment the FL_INIT_MMU_PAGES definition for:
 *                                                                        
 * Initializes the first and last byte of the given buffer.               
 * When the user buffer resides on separated memory pages the read        
 * operation may cause a page fault. Some CPU's return from a page        
 * fault (after loading the new page) and reread the bytes that caused    
 * the page fault from the new loaded page. In order to prevent such a    
 * case the first and last bytes of the buffer are written.
 *                                                                        
 */

#define FL_INIT_MMU_PAGES

#ifndef FL_NO_USE_FUNC

/*********************************************************/
/*     Report DiskOnChip Memory size                     */
/*********************************************************/

/*---------------------------------------------------------------------- 
   f l D o c M e m W i n S i z e N o S h i f t

   This routine is called from MTD to quary the size of the DiskOnChip
   memory window for none shifted DiskOnChip.
------------------------------------------------------------------------*/

dword flDocMemWinSizeNoShift(void)
{
  return 0x2000;
}

/*---------------------------------------------------------------------- 
   f l D o c M e m W i n S i z e S i n g l e S h i f t

   This routine is called from MTD to quary the size of the DiskOnChip
   memory window for DiskOnChip connected with a single addres shift.
------------------------------------------------------------------------*/

dword flDocMemWinSizeSingleShift(void)
{
  return 0x4000;
}

/*---------------------------------------------------------------------- 
   f l D o c M e m W i n S i z e D o u b l e S h i f t

   This routine is called from MTD to quary the size of the DiskOnChip
   memory window for DiskOnChip connected with a double addres shift.
------------------------------------------------------------------------*/

dword flDocMemWinSizeDoubleShift(void)
{
  return 0x8000;
}

/*********************************************************/
/*     Write 16 bits to DiskOnChip memory window         */
/*********************************************************/

/*---------------------------------------------------------------------- 
   f l W r i t e 1 6 b i t D u m m y
                                                                         
   Dummy routine - write 16-bits to memory (does nothing).              
------------------------------------------------------------------------*/

void flWrite16bitDummy(volatile  byte FAR0 * win, word offset,Reg16bitType val)
{
  DEBUG_PRINT(("Wrong customization - 16bit write was used with no implemented.\r\n"));
}

/*---------------------------------------------------------------------- 
   f l W r i t e 1 6 b i t U s i n g 1 6 b i t s N o S h i f t
                                                                       
   Note : offset must be 16-bits aligned.

   Write 16-bit Using 16-bits operands with no address shifted.       
------------------------------------------------------------------------*/

void flWrite16bitUsing16bitsNoShift(volatile  byte FAR0 * win, word offset,Reg16bitType val)
{
  ((volatile word FAR0*)win)[offset>>1] = val;
}

/*---------------------------------------------------------------------- 
   f l W r i t e 1 6 b i t U s i n g 3 2 b i t s S i n g l e S h i f t  

   Note : offset must be 16-bits aligned.
                                                                         
   Write 16-bit Using 16-bits operands with a single address shifted.   
------------------------------------------------------------------------*/

void flWrite16bitUsing32bitsSingleShift(volatile  byte FAR0 * win, word offset,Reg16bitType val)
{
#ifdef FL_BIG_ENDIAN  
  ((volatile dword FAR0*)win)[offset>>1] = ((dword)val)<<16; 
#else
  ((volatile dword FAR0*)win)[offset>>1] = (dword)val; 
#endif /* FL_BIG_ENDIAN */
}

/*********************************************************/
/*     Read 16 bits from DiskOnChip memory window        */
/*********************************************************/

/*----------------------------------------------------------------------
   f l R e a d 1 6 b i t D u m m y                     
                                                                         
   Dummy routine - read 16-bits from memory (does nothing).              
------------------------------------------------------------------------*/

Reg16bitType flRead16bitDummy(volatile  byte FAR0 * win,word offset)
{
  DEBUG_PRINT(("Wrong customization - 16bit read was issued with no implementation.\r\n"));
  return 0;
}

/*----------------------------------------------------------------------
   f l R e a d 1 6 b i t U s i n g 1 6 b i t s N o S h i f t    

   Note : offset must be 16-bits aligned.

   Read 16-bit Using 16-bits operands with no address shifted.       
------------------------------------------------------------------------*/

Reg16bitType flRead16bitUsing16bitsNoShift(volatile  byte FAR0 * win,word offset)
{
  return ((volatile word FAR0*)win)[offset>>1];
}

/*----------------------------------------------------------------------
   f l R e a d 1 6 b i t U s i n g 3 2 b i t s S i n g l e S h i f t    

   Note : offset must be 16-bits aligned.

   Read 16-bit Using 16-bits operands with single address shifted.
------------------------------------------------------------------------*/

Reg16bitType flRead16bitUsing32bitsSingleShift(volatile  byte FAR0 * win,word offset)
{
#ifdef FL_BIG_ENDIAN
  return  (Reg16bitType)(((volatile dword FAR0*)win)[offset>>1]<<16);
#else
  return  (Reg16bitType)((volatile dword FAR0*)win)[offset>>1];     
#endif /* FL_BIG_ENDIAN */
}

/*********************************************************/
/*     Write 8 bits to DiskOnChip memory window          */
/*********************************************************/

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 8 b i t s N o S h i f t
                                                                       
   Write 8-bits Using 8-bits operands with no address shifted.       
------------------------------------------------------------------------*/

void flWrite8bitUsing8bitsNoShift(volatile byte FAR0 * win, word offset,Reg8bitType val)
{
  win[offset] = val;
}

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 16 b i t s N o S h i f t

   Note : DiskOnChip is connected with 16-bit data bus.
   Note : Data is written only to lower memory addresses.
                                                                       
   Write 8-bits Using 16-bits operands with no address shifted.       
------------------------------------------------------------------------*/

void flWrite8bitUsing16bitsNoShift(volatile  byte FAR0 * win, word offset,Reg8bitType val)
{
#ifdef FL_BIG_ENDIAN
  ((volatile word FAR0 *)win)[offset>>1] = ((word)val)<<8;
#else
  ((volatile word FAR0 *)win)[offset>>1] = (word)val;
#endif /* FL_BIG_ENDIAN */
}

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 16 b i t s S i n g l e S h i f t

   Note : Data is written only to 8-LSB.

   Write 8-bits Using 16-bits operands with Single address shifted.       
------------------------------------------------------------------------*/

void flWrite8bitUsing16bitsSingleShift(volatile  byte FAR0 * win, word offset,Reg8bitType val)
{
  ((volatile word FAR0 *)win)[offset] = (word)val;
}

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 32 b i t s S i n g l e S h i f t

   Note : DiskOnChip is connected with 16-bit data bus.
   Note : Data is written to both data bus 8-bits
                                                                       
   Write 8-bits Using 32-bits operands with single address shifted.
------------------------------------------------------------------------*/

void flWrite8bitUsing32bitsSingleShift(volatile  byte FAR0 * win, word offset,Reg8bitType val)
{
#ifdef FL_BIG_ENDIAN
  ((volatile dword FAR0 *)win)[offset>>1] = (dword)val*0x01010101L;
#else
  ((volatile dword FAR0 *)win)[offset>>1] = (dword)val;
#endif /* FL_BIG_ENDIAN */
}

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 32 b i t s D o u b l e S h i f t

   Note : Data is written only to 8-LSB.  

   Write 8-bits Using 32-bits operands with Double address shifted.
------------------------------------------------------------------------*/

void flWrite8bitUsing32bitsDoubleShift(volatile  byte FAR0 * win, word offset,Reg8bitType val)
{
  ((volatile dword FAR0 *)win)[offset] = (dword)val;
}

/*********************************************************/
/*     Read 8 bits to DiskOnChip memory window           */
/*********************************************************/

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 8 b i t s N o S h i f t
                                                                       
   Read 8-bits Using 8-bits operands with no address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing8bitsNoShift(volatile  byte FAR0 * win,word offset)
{
  return win[offset];
}

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 16 b i t s N o S h i f t
  
   Note : DiskOnChip is connected with 16-bit data bus.

   Read 8-bits Using 16-bits operands with no address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing16bitsNoShift(volatile  byte FAR0 * win,word offset)
{
#ifdef FL_BIG_ENDIAN
   return (((offset & 0x1) == 0) ?
#else
   return (( offset & 0x1      ) ?
#endif /* FL_BIG_ENDIAN */
           (Reg8bitType)(((volatile word FAR0 *)win)[offset>>1]>>8) :
           (Reg8bitType) ((volatile word FAR0 *)win)[offset>>1]    );
}

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 16 b i t s S i n g l e S h i f t

   Note : Assume data is found in 8-LSB of DiskOnChip

   Read 8-bits Using 16-bits operands with Single address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing16bitsSingleShift(volatile  byte FAR0 * win,word offset)
{
   return (Reg8bitType)((volatile word FAR0 *)win)[offset];  
}

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 32 b i t s S i n g l e S h i f t

   Note : DiskOnChip is connected with 16-bit data bus.

   Read 8-bits Using 16-bits operands with Single address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing32bitsSingleShift(volatile  byte FAR0 * win,word offset)
{
#ifdef FL_BIG_ENDIAN
   return (((offset & 0x1) == 0) ?
#else
   return (( offset & 0x1      ) ?
#endif /* FL_BIG_ENDIAN */
           (Reg8bitType)(((volatile dword FAR0 *)win)[offset>>1]>>24) :
           (Reg8bitType) ((volatile dword FAR0 *)win)[offset>>1]    );
}

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 32 b i t s D o u b l e S h i f t

   Note : Assume data is found in 8-LSB of DiskOnChip

   Read 8-bits Using 16-bits operands with Single address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing32bitsDoubleShift(volatile  byte FAR0 * win,word offset)
{
   return (Reg8bitType)((volatile dword FAR0 *)win)[offset];  
}

/*********************************************************/
/*********************************************************/
/***    Operation on several bytes (read/write/set)    ***/
/*********************************************************/
/*********************************************************/

/*************************************************/
/*         8-Bit DiskOnChip - No Shift           */
/*************************************************/

/*----------------------------------------------------------------------
   f l 8 b i t D o c R e a d N o S h i f t

   Read 'count' bytes, from a none shifted address bus using tffscpy.
------------------------------------------------------------------------*/

void fl8bitDocReadNoShift(volatile  byte FAR0 * win,word offset,byte FAR1* dest,word count)
{
#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

  tffscpy(dest,(void FAR0*)(win+offset),count);
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c W r i t e N o S h i f t
 
   Write 'count' bytes, from a none shifted address bus using tffscpy.
------------------------------------------------------------------------*/

void fl8bitDocWriteNoShift(volatile  byte FAR0 * win,word offset,byte FAR1* src,word count)
{
  tffscpy((void FAR0*)( win+offset),src,count);
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c S e t N o S h i f t
 
   Set 'count' bytes, from a none shifted address bus using tffsset.
------------------------------------------------------------------------*/

void fl8bitDocSetNoShift(volatile  byte FAR0 * win,word offset,word count, byte val)
{
  tffsset((void FAR0*)( win+offset),val,count);
}

/*************************************************/
/*        8-Bit DiskOnChip - Single Shift        */
/*************************************************/

/*----------------------------------------------------------------------
   f l 8 b i t D o c R e a d S i n g l e S h i f t
 
   Note : Assume data is found in 8-LSB of DiskOnChip

   Read 'count' bytes, from data bus's LSB lane with 1 address shifted
------------------------------------------------------------------------*/

void fl8bitDocReadSingleShift(volatile  byte FAR0 * win,word offset,byte FAR1* dest,word count)
{
  volatile word FAR0 * doc = (volatile word FAR0 *) win + offset;
  register int         i;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

  for(i=0;( i < count );i++)
    dest[i] = (Reg8bitType)doc[i];
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c W r i t e S i n g l e S h i f t
 
   Note : Assume data is found in 8-LSB of DiskOnChip

   Write 'count' bytes, to data bus's LSB lane with 1 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocWriteSingleShift(volatile  byte FAR0 * win,word offset,byte FAR1* src,word count)
{
  volatile word FAR0 * doc = (volatile word FAR0 *) win + offset;
  register int  i;

  for(i=0;( i < count );i++)
    doc[i] = (word)src[i];    
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c S e t S i n g l e S h i f t

   Note : Assume data is found in 8-LSB of DiskOnChip  

   Set 'count' bytes, of data bus's LSB lane with 1 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocSetSingleShift(volatile  byte FAR0 * win,word offset,word count, byte val)
{
  volatile word FAR0 * doc = (volatile word FAR0 *) win + offset;
  register int  i;

  for(i=0;( i < count );i++)
    doc[i] = (word)val;
}

/*************************************************/
/*        8-Bit DiskOnChip - Double Shift        */
/*************************************************/

/*----------------------------------------------------------------------
   f l 8 b i t D o c R e a d D o u b l e S h i f t

   Note : Assume data is found in 8-LSB of DiskOnChip    

   Read 'count' bytes, from data bus's LSB lane with 2 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocReadDoubleShift(volatile  byte FAR0 * win,word offset,byte FAR1* dest,word count)
{
  volatile dword FAR0 * doc = (volatile dword FAR0 *) win + offset;
  register int         i;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

  for(i=0;( i < count );i++)
    dest[i] = (Reg8bitType)doc[i];
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c W r i t e D o u b l e S h i f t
 
   Note : Assume data is found in 8-LSB of DiskOnChip    

   Write 'count' bytes, to data bus's LSB lane with 2 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocWriteDoubleShift(volatile  byte FAR0 * win,word offset,byte FAR1* src,word count)
{
  volatile dword FAR0 * doc = (volatile dword FAR0 *) win + offset;
  register int         i;

  for(i=0;( i < count );i++)
    doc[i] = (dword)src[i];
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c S e t D o u b l e S h i f t
 
   Note : Assume data is found in 8-LSB of DiskOnChip    

   Set 'count' bytes, of data bus's LSB lane with 2 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocSetDoubleShift(volatile  byte FAR0 * win,word offset,word count, byte val)
{
  volatile dword FAR0 * doc = (volatile dword FAR0 *) win+offset;
  register int         i;

  for(i=0;( i < count );i++)
    doc[i] = (dword)val;
}

/*************************************************/
/*        16-Bit DiskOnChip - No Shift           */
/*************************************************/

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c R e a d N o S h i f t
 
   Read 'count' bytes from M+ DiskOnChip with none shifted address bus.
------------------------------------------------------------------------*/

void fl16bitDocReadNoShift (volatile  byte FAR0 * win, word offset, byte FAR1 * dest, word count )
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;
   register word        tmp;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

   if( pointerToPhysical(dest) & 0x1 )
   {
      /* rare case: unaligned target buffer */
      for (i = 0; i < (int)count; )
      {
         tmp = *swin;
#ifdef FL_BIG_ENDIAN
         dest[i++] = (byte)(tmp>>8);
         dest[i++] = (byte)tmp;
#else
         dest[i++] = (byte)tmp;
         dest[i++] = (byte)(tmp>>8);
#endif /* FL_BIG_ENDIAN */
      }
   }
   else
   {   /* mainstream case */
#ifdef USE_TFFS_COPY
      tffscpy( dest, (void FAR0 *)( win + offset), count );
#else
#ifdef ENVIRONMENT_VARS
      if (flUse8Bit == 0)
      {
         flcpy( dest, (void FAR0 *)( win + offset), count );
      }
      else
#endif /* ENVIRONMENT_VARS */
      {   /* read in short words */
         for (i = 0, count = count >> 1; i < (int)count; i++)
            ((word FAR1 *)dest)[i] = swin[i];
      }
#endif /* USE_TFFS_COPY */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c W r i t e N o S h i f t
 
   Write 'count' bytes to M+ DiskOnChip with none shifted address bus.
------------------------------------------------------------------------*/

void fl16bitDocWriteNoShift ( volatile  byte FAR0 * win , word offset ,
                             byte FAR1 * src, word count )
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;
   register word        tmp;

   if( pointerToPhysical(src) & 0x1 ) /* rare case: unaligned source buffer */
   {       
       for (i = 0; i < (int)count; i+=2)
       {
          /* tmp variable is just a precation from compiler optimizations */
#ifdef FL_BIG_ENDAIN
          tmp = ((word)src[i]<<8) + (word)src[i+1];
#else
          tmp = (word)src[i] + ((word)src[i+1]<<8);
#endif /* FL_BIG_ENDAIN */
          *swin = tmp;
		 }
   }
   else /* mainstream case */
   {
#ifdef USE_TFFS_COPY
      tffscpy( (void FAR0 *)(win + offset), src, count );
#else
#ifdef ENVIRONMENT_VARS
      if (flUse8Bit == 0)
      {
         flcpy( (void FAR0 *)(win + offset), src, count );
      }
      else
#endif /* ENVIRONMENT_VARS */
      {   /* write in short words */
         for (i = 0, count = count >> 1; i < (int)count; i++)
           *swin = ((word FAR1 *)src)[i];
      }
#endif /* USE_TFFS_COPY */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c S e t N o S h i f t
 
   Set 'count' bytes of M+ DiskOnChip with none shifted address bus
------------------------------------------------------------------------*/

void fl16bitDocSetNoShift ( volatile  byte FAR0 * win , word offset ,
                                  word count , byte val)
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;
   word                 tmpVal = (word)val * 0x0101;

#ifdef USE_TFFS_COPY
   tffsset( (void FAR0 *)(win + offset), val, count );
#else
#ifdef ENVIRONMENT_VARS
   if (flUse8Bit == 0)
   {
       flset( (void FAR0 *)(win + offset), val, count );
   }
   else
#endif /* ENVIRONMENT_VARS */
   {   /* write in short words */
      for (i = 0; i < (int)count; i+=2)
         *swin = tmpVal;
   }
#endif /* USE_TFFS_COPY */

}

/*************************************************************/
/*    16-Bit DiskOnChip - No Shift - Only 8 bits are valid   */
/*************************************************************/

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c R e a d N o S h i f t I g n o r e H i g h e r 8 B i t s

   Note : offset must be 16-bits aligned.
  
   Read 'count' bytes from M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8 bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocReadNoShiftIgnoreHigher8bits(volatile  byte FAR0 * win, word offset, byte FAR1 * dest, word count )
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

   for (i = 0; i < (int)count; i++)
   {
#ifdef FL_BIG_ENDIAN
      dest[i] = (byte)(swin[i]>>8);
#else
      dest[i] = (byte)swin[i];
#endif /* FL_BIG_ENDIAN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 D o c W r i t e N o S h i f t I g n o r e H i g h e r 8 b i t s

   Note : offset must be 16-bits aligned.

   Write 'count' bytes to M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocWriteNoShiftIgnoreHigher8bits ( volatile  byte FAR0 * win , word offset ,
                             byte FAR1 * src, word count )
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;

   for (i = 0; i < (int)count; i++)
   {
#ifdef FL_BIG_ENDIAN
      *swin  = ((word)src[i])<<8;
#else
      *swin  = (word)src[i];
#endif /* FL_BIG_ENDIAN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 D o c S e t N o S h i f t I g n o r e H i g h e r 8 b i t s

   Note : offset must be 16-bits aligned.

   Set 'count' bytes to M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocSetNoShiftIgnoreHigher8bits ( volatile  byte FAR0 * win , word offset ,
                                  word count , byte val)
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;
   word                 tmpVal = val * 0x0101;

   for (i = 0; i < (int)count; i++)
      *swin = tmpVal;
}

/****************************************/
/*   16-Bit DiskOnChip - Single Shift   */
/****************************************/

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c R e a d S i n g l e S h i f t
 
   Read 'count' bytes from M+ DiskOnChip with none shifted address bus.
------------------------------------------------------------------------*/

void fl16bitDocReadSingleShift (volatile  byte FAR0 * win, word offset, byte FAR1 * dest, word count )
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;
   register dword       tmp;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

   if( pointerToPhysical(dest) & 0x1 )
   {
      /* rare case: unaligned target buffer */
      for (i = 0; i < (int)count; )
      {
         tmp = *swin;
#ifdef FL_BIG_ENDAIN
         dest[i++] = (byte)(tmp>>24);
         dest[i++] = (byte)(tmp>>16);
#else
         dest[i++] = (byte)tmp;
         dest[i++] = (byte)(tmp>>8);
#endif /* FL_BIG_ENDAIN */
      }
   }
   else
   {   /* mainstream case */
      for (i = 0, count = count >> 1; i < (int)count; i++)
      {
#ifdef FL_BIG_ENDAIN         
         ((word FAR1 *)dest)[i] = (word)(swin[i]>>16);
#else
         ((word FAR1 *)dest)[i] = (word)swin[i];
#endif /* FL_BIG_ENDAIN */
      }
   }
}

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c W r i t e S i n g l e S h i f t
 
   Write 'count' bytes to M+ DiskOnChip with none shifted address bus.
------------------------------------------------------------------------*/

void fl16bitDocWriteSingleShift ( volatile  byte FAR0 * win , word offset ,
                             byte FAR1 * src, word count )
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;
   register dword       tmp;

   if( pointerToPhysical(src) & 0x1 ) /* rare case: unaligned source buffer */
   {       
       for (i = 0; i < (int)count; i+=2)
       {
#ifdef FL_BIG_ENDAIN
           tmp = (((dword)src[i])<<24) + (((dword)src[i+1])<<16);
#else
           tmp = (dword)src[i] + (((dword)src[i+1])<<8);
#endif /* FL_BIG_ENDAIN */
           *swin  = tmp;
		 }
   }
   else /* mainstream case */
   {    
      for (i = 0, count = count >> 1; i < (int)count; i++)
#ifdef FL_BIG_ENDIAN
        *swin = ((dword)((word FAR1 *)src)[i])<<16;
#else
        *swin = (dword)((word FAR1 *)src)[i];
#endif /* FL_BIG_ENDIAN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c S e t S i n g l e S h i f t
 
   Set 'count' bytes of M+ DiskOnChip with none shifted address bus
------------------------------------------------------------------------*/

void fl16bitDocSetSingleShift ( volatile  byte FAR0 * win , word offset ,
                                  word count , byte val)
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int          i;
   register dword        tmpVal = (dword)val * 0x01010101L;

   for (i = 0; i < (int)count; i+=2)
      *swin = tmpVal;
}


/**************************************************************/
/*  16-Bit DiskOnChip - Single Shift - Only 8 bits are valid  */
/**************************************************************/

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c R e a d S i n g l e S h i f t I g n o r e H i g h e r 8 B i t s

   Note : offset must be 16-bits aligned.
  
   Read 'count' bytes from M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8 bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocReadSingleShiftIgnoreHigher8bits(volatile  byte FAR0 * win, word offset, byte FAR1 * dest, word count )
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

   for (i = 0; i < (int)count; i++)
   {
#ifdef FL_BIG_ENDAIN
      dest[i] = (byte)(swin[i]>>24);
#else
      dest[i] = (byte)swin[i];
#endif /* FL_BIG_ENDAIN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 D o c W r i t e S i n g l e S h i f t I g n o r e H i g h e r 8 b i t s

   Note : offset must be 16-bits aligned.

   Write 'count' bytes to M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocWriteSingleShiftIgnoreHigher8bits ( volatile  byte FAR0 * win , word offset ,
                             byte FAR1 * src, word count )
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;

   for (i = 0; i < (int)count; i++)
   {
#ifdef FL_BIG_ENDAIN
      *swin = ((dword)src[i]<<24);
#else
      *swin = (dword)src[i];
#endif /* FL_BIG_ENDAIN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 D o c S e t S i n g l e S h i f t I g n o r e H i g h e r 8 b i t s

   Note : offset must be 16-bits aligned.

   Set 'count' bytes to M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocSetSingleShiftIgnoreHigher8bits ( volatile  byte FAR0 * win , word offset ,
                                  word count , byte val)
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;
   dword                tmpVal = (dword)val * 0x01010101L;

   for (i = 0; i < (int)count; i++)
         *swin = tmpVal;
}


/**********************************************************/
/* Set proper access type routines into the proper record */
/**********************************************************/

/*----------------------------------------------------------------------*/
/*                 s e t B u s T y p e O f F l a s h                    */
/*                                                                      */
/* Set DiskOnChip socket / flash memory access routine.                 */
/* This routine must be called by the MTD prior to any access to the    */
/* DiskOnChip                                                           */
/*                                                                      */
/* Parameters:                                                          */
/*    flflash    : Pointer to sockets flash record.                     */
/*    access     : Type of memory access routines to install            */
/*                                                                      */
/* Note: The possible type of memory access routine are comprised of:   */
/*                                                                      */
/*    Address shift:                                                    */
/*         FL_NO_ADDR_SHIFT         - No address shift                  */
/*         FL_SINGLE_ADDR_SHIFT     - Single address shift              */
/*         FL_DOUBLE_ADDR_SHIFT     - Double address shift              */
/*                                                                      */
/*    Platform bus capabilities (access width):                         */
/*         FL_BUS_HAS_8BIT_ACCESS   -  Bus can access 8-bit             */
/*         FL_BUS_HAS_16BIT_ACCESS  -  Bus can access 16-bit            */
/*         FL_BUS_HAS_32BIT_ACCESS  -  Bus can access 32-bit            */
/*                                                                      */
/*    Number of data bits connected to the DiskOnChip (if_cfg):         */
/*         FL_8BIT_DOC_ACCESS       - DiskOnChip has 8 data bits        */
/*         FL_16BIT_DOC_ACCESS      - DiskOnChip has 16 data bits       */
/*                                                                      */
/*    Flash data bits that can be accessed in a bus cycle (interleave): */
/*         FL_8BIT_FLASH_ACCESS     - 8 bits of flash per cycle         */
/*         FL_16BIT_FLASH_ACCESS    - 16 bits of flash per cycle        */
/*                                                                      */
/*    Ignore all of the above and use user defined access routines:     */
/*         FL_ACCESS_USER_DEFINED - Do not install any routine since    */
/*                                  user already installed custome made */
/*                                  routines                            */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

FLStatus  setBusTypeOfFlash(FLFlash * flash,dword access)
{
   /* sanity checks here if needed */
   if(flash==NULL)
   {
      DEBUG_PRINT(("Flash record passed to setBusTypeOfFlash is NULL.\r\n"));
      return flBadParameter;
   }

   /* check if user already defined the memory access routines */
   if ((access & FL_ACCESS_USER_DEFINED) != 0)
      return flOK;

   /************************************/
   /* install requested access methods */
   /************************************/

   switch(access & FL_XX_ADDR_SHIFT_MASK)
   {
      case FL_NO_ADDR_SHIFT:

         flash->memWindowSize = &flDocMemWinSizeNoShift;
         switch(access & FL_XX_DATA_BITS_MASK)
         {
            case FL_8BIT_DOC_ACCESS:  /* if_cfg set to 8-bits */

               /* Make sure bus supports 8 bit access */
               if((access & FL_BUS_HAS_8BIT_ACCESS) == 0)
               {                   
                  DEBUG_PRINT(("ERROR: TrueFFS requires 8-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 8-bit DiskOnChip connected with no address shift.\r\n"));
                  return flBadParameter;
               }

               flash->memWrite8bit  = &flWrite8bitUsing8bitsNoShift;
               flash->memRead8bit   = &flRead8bitUsing8bitsNoShift;
               flash->memRead16bit  = &flRead16bitDummy;
               flash->memWrite16bit = &flWrite16bitDummy;
               flash->memRead       = &fl8bitDocReadNoShift;
               flash->memWrite      = &fl8bitDocWriteNoShift;
               flash->memSet        = &fl8bitDocSetNoShift;
               break;

            case FL_16BIT_DOC_ACCESS: /* if_cfg set to 16-bits (Plus family) */

               /* Make sure bus supports 16 bit access */
               if((access & FL_BUS_HAS_16BIT_ACCESS) == 0)
               {
                  DEBUG_PRINT(("ERROR: TrueFFS requires 16-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 16-bit DiskOnChip connected with no address shift.\r\n"));
                  return flBadParameter;
               }

               flash->memWrite8bit  = &flWrite8bitUsing16bitsNoShift;
               flash->memRead8bit   = &flRead8bitUsing16bitsNoShift;
               flash->memRead16bit  = &flRead16bitUsing16bitsNoShift;
               flash->memWrite16bit = &flWrite16bitUsing16bitsNoShift;

               switch(access & FL_XX_FLASH_ACCESS_MASK) /* Interleave */
               {
                  case FL_8BIT_FLASH_ACCESS:  /* Interleave - 1 */
                     flash->memRead       = &fl16bitDocReadNoShiftIgnoreHigher8bits;
                     flash->memWrite      = &fl16bitDocWriteNoShiftIgnoreHigher8bits;
                     flash->memSet        = &fl16bitDocSetNoShiftIgnoreHigher8bits;
                     break;
                  case FL_16BIT_FLASH_ACCESS: /* Interleave - 2 */
                     flash->memRead       = &fl16bitDocReadNoShift;
                     flash->memWrite      = &fl16bitDocWriteNoShift;
                     flash->memSet        = &fl16bitDocSetNoShift;
                     break;
                  default:
                     DEBUG_PRINT(("TrueFFS does not support this flash access type (setBusTypeOfFlash).\r\n"));
                     return flBadParameter;
               }
               break;

            default:
               DEBUG_PRINT(("TrueFFS does not support this number of DiskOnChip data bits (setBusTypeOfFlash).\r\n"));
               return flBadParameter;
         }
         break;

      case FL_SINGLE_ADDR_SHIFT:

         /* Install memory window size routine */
         flash->memWindowSize = &flDocMemWinSizeSingleShift;
         switch(access & FL_XX_DATA_BITS_MASK)
         {
            case FL_8BIT_DOC_ACCESS:  /* if_cfg set to 8bits (None plus family)*/

               /* Make sure bus supports 16 bit access */
               if((access & FL_BUS_HAS_16BIT_ACCESS) == 0)
               {
                  DEBUG_PRINT(("ERROR: TrueFFS requires 16-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 8-bit DiskOnChip connected with a single address shift.\r\n"));
                  return flBadParameter;
               }

               flash->memWrite8bit  = &flWrite8bitUsing16bitsSingleShift;
               flash->memRead8bit   = &flRead8bitUsing16bitsSingleShift;
               flash->memRead16bit  = &flRead16bitDummy;
               flash->memWrite16bit = &flWrite16bitDummy;
               flash->memRead       = &fl8bitDocReadSingleShift;
               flash->memWrite      = &fl8bitDocWriteSingleShift;
               flash->memSet        = &fl8bitDocSetSingleShift;
               break;

            case FL_16BIT_DOC_ACCESS: /* if_cfg set to 8bits (Plus family) */

               /* Make sure bus supports 32 bit access */
               if((access & FL_BUS_HAS_32BIT_ACCESS) == 0)
               {
                  DEBUG_PRINT(("ERROR: TrueFFS requires 32-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 16-bit DiskOnChip connected with a single address shift.\r\n"));
                  return flBadParameter;
               }
    
               flash->memWrite8bit  = &flWrite8bitUsing32bitsSingleShift;
               flash->memRead8bit   = &flRead8bitUsing32bitsSingleShift;
               flash->memRead16bit  = &flRead16bitUsing32bitsSingleShift;
               flash->memWrite16bit = &flWrite16bitUsing32bitsSingleShift;

               switch(access & FL_XX_FLASH_ACCESS_MASK) /* Interleave */
               {
                  case FL_8BIT_FLASH_ACCESS:  /* Interleave - 1 */
                     flash->memRead       = &fl16bitDocReadSingleShiftIgnoreHigher8bits;
                     flash->memWrite      = &fl16bitDocWriteSingleShiftIgnoreHigher8bits;
                     flash->memSet        = &fl16bitDocSetSingleShiftIgnoreHigher8bits;
                     break;
                  case FL_16BIT_FLASH_ACCESS: /* Interleave - 2 */
                     flash->memRead       = &fl16bitDocReadSingleShift;
                     flash->memWrite      = &fl16bitDocWriteSingleShift;
                     flash->memSet        = &fl16bitDocSetSingleShift;
                     break;
                  default:
                     DEBUG_PRINT(("TrueFFS does not support this flash access type (setBusTypeOfFlash).\r\n"));
                     return flBadParameter;
               }
               break;

            default:
               DEBUG_PRINT(("TrueFFS does not support this number of DiskOnChip data bits (setBusTypeOfFlash).\r\n"));
               return flBadParameter;
         }
         break;

      case FL_DOUBLE_ADDR_SHIFT:

         /* Install memory window size routine */
         flash->memWindowSize = &flDocMemWinSizeDoubleShift;
         switch(access & FL_XX_DATA_BITS_MASK)
         {
            case FL_8BIT_DOC_ACCESS:  /* if_cfg set to 8bits or none plus family */

               /* Make sure bus supports 32 bit access */
               if((access & FL_BUS_HAS_32BIT_ACCESS) == 0)
               {
                  DEBUG_PRINT(("ERROR: TrueFFS requires 32-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 8-bit DiskOnChip connected with a double address shift.\r\n"));
                  return flBadParameter;
               }

               flash->memWrite8bit  = &flWrite8bitUsing32bitsDoubleShift;
               flash->memRead8bit   = &flRead8bitUsing32bitsDoubleShift;
               flash->memRead16bit  = &flRead16bitDummy;
               flash->memWrite16bit = &flWrite16bitDummy;
               flash->memRead       = &fl8bitDocReadDoubleShift;
               flash->memWrite      = &fl8bitDocWriteDoubleShift;
               flash->memSet        = &fl8bitDocSetDoubleShift;
               break;

            default:
               DEBUG_PRINT(("TrueFFS does not support this number of DiskOnChip data bits\r\n"));
               DEBUG_PRINT(("when connected with a double address shift (setBusTypeOfFlash).\r\n"));
               return flBadParameter;
         }
         break;

      default:
         DEBUG_PRINT(("TrueFFS does not support this kind of address shifting (setBusTypeOfFlash).\r\n"));
         return flBadParameter;
   }

   /* Store access type in flash record */
   flash->busAccessType = access;
   return flOK;
}

#endif /* FL_NO_USE_FUNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\docsoc.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCSOC.C_V  $
 *
 *    Rev 1.5   Jan 17 2002 22:59:06   oris
 * mtdVars for DiskOnChip MTD were moved from diskonc.c and  mdocplus.c to save RAM.
 * Added include for NANDDEFS.H
 *
 *    Rev 1.4   Jun 17 2001 16:39:10   oris
 * Improved documentation and remove warnings.
 *
 *    Rev 1.3   Apr 10 2001 16:41:46   oris
 * Restored all DiskOnChip socket routines from flsocket.c
 *
 *    Rev 1.2   Apr 09 2001 14:59:50   oris
 * Added an empty routine to avoid warnings.
 *
 *    Rev 1.1   Apr 01 2001 07:44:38   oris
 * Updated copywrite notice
 *
 *    Rev 1.0   Feb 02 2001 13:26:30   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "flsocket.h"
#include "nanddefs.h"

#ifdef NT5PORT
#include "scsi.h"
#include "tffsport.h"

extern NTsocketParams driveInfo[SOCKETS];
NTSTATUS updateDocSocketParams(PDEVICE_EXTENSION fdoExtension)
{
  NTSTATUS status;
  ULONG    device;

  device = (fdoExtension->UnitNumber &0x0f);
  driveInfo[device].windowSize = fdoExtension->pcmciaParams.windowSize;
  driveInfo[device].physWindow = fdoExtension->pcmciaParams.physWindow;
  driveInfo[device].winBase = fdoExtension->pcmciaParams.windowBase;
  driveInfo[device].fdoExtension = (PVOID) fdoExtension;
  driveInfo[device].interfAlive = 1;
  return STATUS_SUCCESS;
}
#endif /* NT5PORT */

NFDC21Vars docMtdVars[SOCKETS];

/************************************************************************/
/*                                                                        */
/* Beginning of controller-customizable code                                */
/*                                                                        */
/* The function prototypes and interfaces in this section are standard        */
/* and are used in this form by the non-customizable code. However, the */
/* function implementations are specific to the 82365SL controller.        */
/*                                                                        */
/* You should replace the function bodies here with the implementation        */
/* that is appropriate for your controller.                                */
/*                                                                        */
/* All the functions in this section have no parameters. This is        */
/* because the parameters needed for an operation may be themselves        */
/* dependent on the controller. Instead, you should use the value in         */
/* the 'vol' structure as parameters.                                   */
/* If you need socket-state variables specific to your implementation,        */
/* it is recommended to add them to the 'vol' structure rather than     */
/* define them as separate static variables.                                */
/*                                                                        */
/************************************************************************/


/************************************************************************/
/* c a r d D e t e c t e d                                                */
/*                                                                        */
/* Detect if a card is present (inserted)                                */
/*                                                                        */
/* Parameters:                                                                */
/*        vol : Pointer identifying drive                                        */
/*                                                                        */
/* Returns:                                                                */
/*        0 = card not present, other = card present                        */
/************************************************************************/

static FLBoolean cardDetected(FLSocket vol)
{
  return TRUE;
}


/************************************************************************/
/* V c c O n                                                                */
/*                                                                        */
/* Turns on Vcc (3.3/5 Volts). Vcc must be known to be good on exit.        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/************************************************************************/

static void VccOn(FLSocket vol)
{
}


/************************************************************************/
/* V c c O f f                                                                */
/*                                                                        */
/* Turns off Vcc.                                                        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/************************************************************************/

static void VccOff(FLSocket vol)
{
}


#ifdef SOCKET_12_VOLTS

/************************************************************************/
/* V p p O n                                                                */
/*                                                                        */
/* Turns on Vpp (12 Volts. Vpp must be known to be good on exit.)        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/* Returns:                                                                */
/*        FLStatus        : 0 on success, failed otherwise                */
/************************************************************************/

static FLStatus VppOn(FLSocket vol)
{
  return flOK;
}

/************************************************************************/
/* V p p O f f                                                                */
/*                                                                        */
/* Turns off Vpp.                                                        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/************************************************************************/

static void VppOff(FLSocket vol)
{
}

#endif        /* SOCKET_12_VOLTS */

/************************************************************************/
/* i n i t S o c k e t                                                        */
/*                                                                        */
/* Perform all necessary initializations of the socket or controller        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/* Returns:                                                                */
/*        FLStatus                : 0 on success, failed otherwise        */
/************************************************************************/

static FLStatus initSocket(FLSocket vol)
{
  return flOK;
}


/************************************************************************/
/* s e t W i n d o w                                                        */
/*                                                                        */
/* Sets in hardware all current window parameters: Base address, size,        */
/* speed and bus width.                                                 */
/* The requested settings are given in the 'vol.window' structure.      */
/*                                                                        */
/* If it is not possible to set the window size requested in                */
/* 'vol.window.size', the window size should be set to a larger value,  */
/* if possible. In any case, 'vol.window.size' should contain the       */
/* actual window size (in 4 KB units) on exit.                                */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/************************************************************************/

static void setWindow(FLSocket vol)
{
#ifdef NT5PORT
    vol.window.size = driveInfo[vol.volNo].windowSize;
  vol.window.base = driveInfo[vol.volNo].winBase;
#endif/*NT5PORT*/

}


/************************************************************************/
/* s e t M a p p i n g C o n t e x t                                        */
/*                                                                        */
/* Sets the window mapping register to a card address.                        */
/*                                                                        */
/* The window should be set to the value of 'vol.window.currentPage',        */
/* which is the card address divided by 4 KB. An address over 128KB,        */
/* (page over 32K) specifies an attribute-space address.                */
/*                                                                        */
/* The page to map is guaranteed to be on a full window-size boundary.        */
/*                                                                        */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                        */
/*        page                : page to map                                        */
/*                                                                      */
/************************************************************************/

static void setMappingContext(FLSocket vol, unsigned page)
{
}


/************************************************************************/
/* g e t A n d C l e a r C a r d C h a n g e I n d i c a t o r                */
/*                                                                        */
/* Returns the hardware card-change indicator and clears it if set.        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/* Returns:                                                                */
/*        0 = Card not changed, other = card changed                        */
/************************************************************************/

static FLBoolean getAndClearCardChangeIndicator(FLSocket vol)
{
  /* Note: On the 365, the indicator is turned off by the act of reading */
  return FALSE;
}



/************************************************************************/
/* w r i t e P r o t e c t e d                                                */
/*                                                                        */
/* Returns the write-protect state of the media                         */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/* Returns:                                                                */
/*        0 = not write-protected, other = write-protected                */
/************************************************************************/

static FLBoolean writeProtected(FLSocket vol)
{
  return FALSE;
}

#ifdef EXIT
/************************************************************************/
/* f r e e S o c k e t                                                        */
/*                                                                        */
/* Free resources that were allocated for this socket.                        */
/* This function is called when TrueFFS exits.                                */
/*                                                                        */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                        */
/*                                                                      */
/************************************************************************/

static void freeSocket(FLSocket vol)
{
   freePointer(vol.window.base,vol.window.size);
}
#endif  /* EXIT */

void docSocketInit(FLSocket vol)
{
    vol.cardDetected = cardDetected;
    vol.VccOn        = VccOn;
    vol.VccOff       = VccOff;
#ifdef SOCKET_12_VOLTS
    vol.VppOn        = VppOn;
    vol.VppOff       = VppOff;
#endif
    vol.initSocket   = initSocket;
    vol.setWindow    = setWindow;
    vol.setMappingContext  = setMappingContext;
    vol.getAndClearCardChangeIndicator = getAndClearCardChangeIndicator;
    vol.writeProtected     = writeProtected;
    vol.updateSocketParams = NULL /* updateSocketParameters */;
#ifdef EXIT
    vol.freeSocket = freeSocket;
#endif
}


#ifdef NT5PORT
/*----------------------------------------------------------------------*/
/*                  f l R e g i s t e r D O C S O C         */
/*                                  */
/* Installs routines for DiskOnChip.                    */
/*                                  */
/* Parameters:                                                          */
/*  None                                                            */
/*                                                                      */
/* Returns:                             */
/*  FLStatus    : 0 on success, otherwise failure       */
/*----------------------------------------------------------------------*/
ULONG windowBaseAddress(ULONG driveNo)
{
  return (ULONG) (driveInfo[driveNo].physWindow >> 12);
}
FLStatus flRegisterDOCSOC(ULONG startAddr,ULONG stopAddr)
{
  if (noOfSockets >= DOC_DRIVES)
    return flTooManyComponents;

  for (; noOfSockets < DOC_DRIVES; noOfSockets++) {

        FLSocket vol = flSocketOf(noOfSockets);
        vol.volNo = noOfSockets;
        docSocketInit(&vol);
        flSetWindowSize(&vol, 2);   /* 4 KBytes */

             //vol.window.baseAddress = flDocWindowBaseAddress(vol.volNo, 0, 0, NULL);
        vol.window.baseAddress = windowBaseAddress(vol.volNo);
        vol.window.base = pdriveInfo[vol.volNo & 0x0f].winBase;
        // if(((void *)vol.window.baseAddress) == NULL){
        // }

        }
        if (noOfSockets == 0)
            return flAdapterNotFound;

  return flOK;
}
#endif /*NT5PORT*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\docsysp.c ===
/*****************************************************************************
 *                                                                           *
 *    FAT-FTL Lite Software Development Kit                                  *
 *    Copyright (C) M-Systems Ltd. 1995-2001                                 *
 *                                                                           *
 *****************************************************************************
 *                                                                           *
 *  In order to make your code faster:                                       *
 *                                                                           *
 *  1. Get rid of routines flRead8bitRegPlus()/flPreInitRead8bitReg()Plus,   *
 *     and make M+ MTD calling routine mplusReadReg8() directly.             *
 *                                                                           *
 *  2. Get rid of routines flWrite8bitRegPlus()/flPreInitWrite8bitReg()Plus, *
 *     and make M+ MTD calling routine mplusWriteReg8() directly.            *
 *                                                                           *
 *  3. Eliminate overhead of calling routines tffscpy/tffsset() by           *
 *     adding these routines' code into docPlusRead/docPlusWrite/docPlusSet  *
 *     routines.                                                             *
 *                                                                           *
 *****************************************************************************/




/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/docsysp.c_V  $
 * 
 *    Rev 1.4   Nov 18 2001 20:26:50   oris
 * Bug fix- Bad implementation of 8-bit access when ENVIRNOMENT_VARS is not defined.
 * 
 *    Rev 1.3   Nov 16 2001 00:26:54   oris
 * When ENVIRONMENT_VARS is not defined use for loop of bytes instead of tffscpy.
 * 
 *    Rev 1.2   Sep 25 2001 15:39:38   oris
 * Bug fix - Add special support for flUse8Bit environement variable.
 *
 *          Rev 1.1      Sep 24 2001 18:23:32      oris
 * Completely revised to support runtime true 16-bit access.
 */




/*
 * configuration
 */

/* #define FL_INIT_MMU_PAGES */




/*
 * includes
 */

#include "docsysp.h"




/*
 * macros
 */

/* types of access to M+: 8 or 16-bit */

#define FL_MPLUS_ACCESS_8BIT      0x10
#define FL_MPLUS_ACCESS_16BIT     0x20
#define FL_MPLUS_ACCESS_MASK      0xf0  /* mask for the above */

/* in case of 16-bit access to M+ */

#define FL_MPLUS_ACCESS_BE        0x100




/*
 * routines
 */

#ifdef FL_INIT_MMU_PAGES

static void     flInitMMUpages (byte FAR1 *buf, int bufsize);

#endif




/*
 * vars
 */

/* run-time configuration of DiskOnChip access */

int     flMplusAccessType = FL_MPLUS_ACCESS_8BIT;
/*                          FL_MPLUS_ACCESS_8BIT
                            FL_MPLUS_ACCESS_16BIT
                            FL_MPLUS_ACCESS_BE */



/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                    m p l u s R e a d R e g 8                           *
 *                                                                        *
 *     Read single byte from memory mapped 8-bit M+ register.             *
 *                                                                        *
 * ---------------------------------------------------------------------- */

unsigned char     mplusReadReg8 ( void FAR0 * win, int offset )
{
   if( flMplusAccessType & FL_MPLUS_ACCESS_16BIT ) {

      /* can't read byte, only short word */

      unsigned short     sval;

      sval = *((volatile unsigned short FAR0 *)win + (offset >> 1));

      return *(((unsigned char *) &sval) + (offset & 0x1));
   }

   /* FL_MPLUS_ACCESS_8BIT case */

   return *((volatile unsigned char FAR0 *)win + offset);
}




/* ---------------------------------------------------------------------- *
 *                                                                                                *
 *                          m p l u s W r i t e R e g 8                                 *
 *                                                                                                *
 *     Write single byte to memory mapped 8-bit M+ register.                    *
 *                                                                                                *
 * ---------------------------------------------------------------------- */

void     mplusWriteReg8 ( void FAR0 * win, int offset, unsigned char val )
{
   switch( flMplusAccessType & FL_MPLUS_ACCESS_MASK ) {

      case FL_MPLUS_ACCESS_16BIT:

         *((volatile unsigned short FAR0 *)win + (offset >> 1)) =
                                 (unsigned short)(val * 0x0101);
         break;

      default: /* FL_MPLUS_ACCESS_8BIT */

         *((volatile unsigned char FAR0 *)win + offset) = val;
         break;
   }
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *               f l R e a d 1 6 b i t R e g P l u s                      *
 *                                                                        *
 *     Read single word from memory mapped 16-bit M+ register.            *
 *                                                                        *
 * ---------------------------------------------------------------------- */

Reg16bitType     flRead16bitRegPlus ( FLFlash vol, unsigned offset )
{
   return (Reg16bitType)
      (*((volatile unsigned short FAR0 *)((char FAR0 *)NFDC21thisVars->win + (int)offset)));
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *               f l W r i t e 1 6 b i t R e g P l u s                    *
 *                                                                        *
 *     Write single word to memory mapped 16-bit M+ register.             *
 *                                                                        *
 * ---------------------------------------------------------------------- */

void     flWrite16bitRegPlus ( FLFlash vol, unsigned offset, Reg16bitType val )
{
   *((volatile unsigned short FAR0 *)((char FAR0 *)NFDC21thisVars->win + (int)offset)) =
      (unsigned short) val;
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                        d o c P l u s R e a d                           *
 *                                                                        *
 *     This routine is called from M+ MTD to read data block from M+.     *
 *                                                                        *
 * ---------------------------------------------------------------------- */

void docPlusRead ( FLFlash vol, unsigned offset, void FAR1 * dest, unsigned int count )
{
   volatile unsigned short FAR0 * swin;
   register int                   i;
   register unsigned short        tmp;

   if (count == 0)
      return;

#ifdef FL_INIT_MMU_PAGES

   flInitMMUpages( (byte FAR1 *)dest, (int)count );

#endif

   if ((vol.interleaving == 1) && (NFDC21thisVars->if_cfg == 16)) {

      /* rare case: 16-bit hardware interface AND interleave == 1 */

      for (i = 0; i < (int)count; i++) {

         *((unsigned char FAR1 *)dest + i) =
            mplusReadReg8 ((void FAR0 *)NFDC21thisVars->win, ((int)offset));
      }
   }
   else {

      switch( flMplusAccessType & FL_MPLUS_ACCESS_MASK ) {

         case FL_MPLUS_ACCESS_16BIT:

            swin = (volatile unsigned short FAR0 *)NFDC21thisVars->win + ((int)offset >> 1);

            if( pointerToPhysical(dest) & 0x1 ) {

               /* rare case: unaligned target buffer */

               if( flMplusAccessType & FL_MPLUS_ACCESS_BE ) {     /* big endian */

                  for (i = 0; i < (int)count; ) {

                     tmp = *(swin + (i >> 1));

                     *((unsigned char FAR1 *)dest + (i++)) = (unsigned char) (tmp >> 8);
                     *((unsigned char FAR1 *)dest + (i++)) = (unsigned char) tmp;
                  }
               }
               else {    /* little endian */

                  for (i = 0; i < (int)count; ) {

                     tmp = *(swin + (i >> 1));

                     *((unsigned char FAR1 *)dest + (i++)) = (unsigned char) tmp;
                     *((unsigned char FAR1 *)dest + (i++)) = (unsigned char) (tmp >> 8);
				  }
			   }
			}
			else {   /* mainstream case */
#ifdef ENVIRONMENT_VARS
			   if (flUse8Bit == 0) {

				  tffscpy( dest, (void FAR0 *)((NDOC2window)NFDC21thisWin + offset), count );
			   }
			   else
#endif /* ENVIRONMENT_VARS */
			   {   /* read in short words */ /* andrayk: do we need this ? */

				  for (i = 0; i < ((int)count >> 1); i++)
					 *((unsigned short FAR1 *)dest + i) = *(swin + i);
               }
            }
            break;

         default:     /* FL_MPLUS_ACCESS_8BIT */
#ifdef ENVIRONMENT_VARS
            tffscpy( dest, (void FAR0 *)((NDOC2window)NFDC21thisWin + offset), count );
#else
            for (i = 0; i < (int)count; i++)
               ((byte FAR1 *)dest)[i] = *((NDOC2window)NFDC21thisWin + offset);
#endif /* ENVIRONMENT_VARS */
            break;
      }
   }
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                      d o c P l u s W r i t e                           *
 *                                                                        *
 *    This routine is called from M+ MTD to write data block to M+.       *
 *                                                                        *
 * ---------------------------------------------------------------------- */

void     docPlusWrite ( FLFlash vol, void FAR1 * src, unsigned int count )
{
   volatile unsigned short FAR0 * swin;
   register int                   i;
   register unsigned short        tmp;

   if (count == 0)
      return;

   if ((vol.interleaving == 1) && (NFDC21thisVars->if_cfg == 16)) {

      /* rare case: 16-bit hardware interface AND interleave == 1 */

      for (i = 0; i < (int)count; i++) {

         mplusWriteReg8( (void FAR0 *)NFDC21thisVars->win, ((int)NFDC21thisIO),
                                                                                                 *((unsigned char FAR1 *)src + i) );
      }
   }
   else {

      switch( flMplusAccessType & FL_MPLUS_ACCESS_MASK ) {

          case FL_MPLUS_ACCESS_16BIT:

             swin = (volatile unsigned short FAR0 *)NFDC21thisVars->win + ((int)NFDC21thisIO >> 1);

             if( pointerToPhysical(src) & 0x1 ) {

                /* rare case: unaligned source buffer */

                if( flMplusAccessType & FL_MPLUS_ACCESS_BE ) {     /* big endian */

                   for (i = 0; i < (int)count; ) {

                      tmp  = ((unsigned short) (*((unsigned char FAR1 *)src + (i++)))) << 8;
                      tmp |= (*((unsigned char FAR1 *)src + (i++)));

                      *(swin + (i >> 1)) = tmp;
				   }
				}
				else {

				   for (i = 0; i < (int)count; ) {    /* little endian */

					  tmp  = (*((unsigned char FAR1 *)src + (i++)));
					  tmp |= ((unsigned short) (*((unsigned char FAR1 *)src + (i++)))) << 8;

					  *(swin + (i >> 1)) = tmp;
				   }
				}
			 }
			 else {    /* mainstream case */
#ifdef ENVIRONMENT_VARS 
				if (flUse8Bit == 0) {

				   tffscpy( (void FAR0 *)((NDOC2window)NFDC21thisWin + NFDC21thisIO), src, count );
				}
				else
#endif /* ENVIRONMENT_VARS */
				{   /* write in short words */ /* andrayk: do we need this ? */

                   for (i = 0; i < ((int)count >> 1); i++)
                      *(swin + i) = *((unsigned short FAR1 *)src + i);
                }
             }
             break;

          default:     /* FL_MPLUS_ACCESS_8BIT */
#ifdef ENVIRONMENT_VARS
             tffscpy( (void FAR0 *)((NDOC2window)NFDC21thisWin + NFDC21thisIO), src, count );
#else
             for (i = 0; i < (int)count; i++)
                *((NDOC2window)NFDC21thisWin + NFDC21thisIO) =
                ((byte FAR1 *)src)[i];
#endif /* ENVIRONMENT_VARS */
             break;
       }
    }
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                        d o c P l u s S e t                             *
 *                                                                        *
 *   This routine is called from M+ MTD to set data block on M+ to 'val'. *
 *                                                                        *
 * ---------------------------------------------------------------------- */

void     docPlusSet ( FLFlash vol, unsigned int count, unsigned char val )
{
   volatile unsigned short FAR0 * swin;
   register int                   i;
   register unsigned short        sval;

   if (count == 0)
      return;

   if ((vol.interleaving == 1) && (NFDC21thisVars->if_cfg == 16)) {

      /* rare case: 16-bit hardware interface AND interleave == 1 */

      for (i = 0; i < (int)count; i++)
         mplusWriteReg8( (void FAR0 *)NFDC21thisVars->win, (int)NFDC21thisIO, val );
   }
   else {    /* mainstream case */

      switch( flMplusAccessType & FL_MPLUS_ACCESS_MASK ) {

         case FL_MPLUS_ACCESS_16BIT:
#ifdef ENVIRONMENT_VARS
			if (flUse8Bit == 0) {

			   tffsset( (void FAR0 *)((NDOC2window)NFDC21thisWin + NFDC21thisIO), val, count );
			}
			else
#endif /* ENVIRONMENT_VARS */
			{  /* do short word access */ /* andrayk: do we need this ? */

               swin = (volatile unsigned short FAR0 *)NFDC21thisVars->win +
                      ((int)NFDC21thisIO >> 1);

               sval = ((unsigned short)val << 8) | val;

               for (i = 0; i < ((int)count >> 1); i++)
                  *(swin + i) = sval;
            }
            break;

         default:     /* FL_MPLUS_ACCESS_8BIT */
#ifdef ENVIRONMENT_VARS
            tffsset( (void FAR0 *)((NDOC2window)NFDC21thisWin + NFDC21thisIO), val, count );
#else
            for (i = 0; i < (int)count; i++)
               *((NDOC2window)NFDC21thisWin + NFDC21thisIO) = val;
#endif /* ENVIRONMENT_VARS */
            break;
      }
   }
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                      m p l u s W i n S i z e                           *
 *                                                                        *
 *    This routine is called from M+ MTD to find out size of M+ window in *
 *    bytes.                                                              *
 *                                                                        *
 * ---------------------------------------------------------------------- */

unsigned long     mplusWinSize ( void )
{
   return 0x2000L;
}




#ifdef FL_INIT_MMU_PAGES

/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                      f l I n i t M M U p a g e s                       *
 *                                                                        *
 * Initializes the first and last byte of the given buffer.               *
 * When the user buffer resides on separated memory pages the read        *
 * operation may cause a page fault. Some CPU's return from a page        *
 * fault (after loading the new page) and reread the bytes that caused    *
 * the page fault from the new loaded page. In order to prevent such a    *
 * case the first and last bytes of the buffer are written                *
 *                                                                        *
 * ---------------------------------------------------------------------- */

static void     flInitMMUpages ( byte FAR1 *buf, int bufsize )
{
   *buf = (byte)0;

   *( addToFarPointer(buf, (bufsize - 1)) ) = (byte)0;
}

#endif /* FL_INIT_MMU_PAGES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\dosformt.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOSFORMT.C_V  $
 * 
 *    Rev 1.7   Feb 19 2002 20:59:12   oris
 * Replaced dosformt.h with blockdev.h
 * 
 *    Rev 1.6   Jan 29 2002 20:07:56   oris
 * Removed prototype of flBuildGeometry (already found in blockdev.h).
 * 
 *    Rev 1.5   Jan 28 2002 21:24:58   oris
 * Removed the use of back-slashes in macro definitions.
 * 
 *    Rev 1.4   Apr 16 2001 13:33:44   oris
 * Removed warrnings.
 * 
 *    Rev 1.3   Apr 09 2001 15:06:42   oris
 * End with an empty line.
 * 
 *    Rev 1.2   Apr 01 2001 07:44:48   oris
 * Updated copywrite notice
 * 
 *    Rev 1.1   Feb 14 2001 02:00:26   oris
 * Added oldFormat.
 *
 *    Rev 1.0   Feb 02 2001 13:48:44   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "fltl.h"
#ifdef FORMAT_VOLUME

#include "blockdev.h"

#define FAT12bit  (LE4(bpb->totalSectorsInVolume) < 4086LU * bpb->sectorsPerCluster)

 /*----------------------------------------------------------------------*/
/*      	      g e t D r i v e G e o m e t r y			            */
/*									                                    */
/* Calculates the geometry parameters for BIOS/DOS media		        */
/*                                                                      */
/* Parameters:                                                          */
/*	vol		  : Pointer identifying drive			                    */
/*  oldFormat : Format media with coluster size of 1 sector             */
/*                                                                      */
/* Returns:                                                             */
/*	bpb		: volume BIOS parameter block			                    */
/*	cylinders	: Number of "cylinders" in volume		                */
/*	noOfFATs	: Number of FAT copies				                    */
/*----------------------------------------------------------------------*/

static void getDriveGeometry(TL vol,
			     BPB FAR2 *bpb,
			     dword FAR2 *cylinders,
			     unsigned noOfFATs,
				 FLBoolean oldFormat)
{
  dword heads, sectors;
  long int sizeInSectors, noOfClusters;
  int directorySectors, sectorsPerFAT;
  int minClusterSize;
  SectorNo sectorAlignment;

  SectorNo capacity = vol.sectorsInVolume(vol.rec); /* Volume size in sectors */

  minClusterSize = ((oldFormat == TRUE) ? 1: MIN_CLUSTER_SIZE);

  flBuildGeometry( (dword)capacity, (dword FAR2 *)cylinders,
                 (dword FAR2 *)&heads, (dword FAR2 *)&sectors,oldFormat);

  if (vol.recommendedClusterInfo)
    vol.recommendedClusterInfo(vol.rec,&minClusterSize,&sectorAlignment);

  toLE2(bpb->sectorsPerTrack,(word) sectors);
  toLE2(bpb->noOfHeads,(word) heads);
  toUNAL2(bpb->bytesPerSector,SECTOR_SIZE);
  bpb->noOfFATS = (byte)noOfFATs;
  bpb->mediaDescriptor = 0xf8;	/* hard disk */
  toLE4(bpb->noOfHiddenSectors,sectors);

  sizeInSectors = (long) (*cylinders) * heads * sectors - sectors;

  toLE4(bpb->totalSectorsInVolume,sizeInSectors);
  toUNAL2(bpb->totalSectorsInVolumeDOS3,
         (word)(sizeInSectors > 65535l ? 0 : sizeInSectors));

  noOfClusters = sizeInSectors / minClusterSize;
  for (bpb->sectorsPerCluster = (byte)minClusterSize;
       noOfClusters > (!oldFormat && bpb->sectorsPerCluster < 8 ? 32766l : 65534l);
       bpb->sectorsPerCluster <<= 1, noOfClusters >>= 1);

  if (FAT12bit)
    sectorsPerFAT =
      (word) ((((noOfClusters + 2L) * 3 + 1) / 2 - 1) / SECTOR_SIZE + 1);
  else
    sectorsPerFAT =
      (word) (((noOfClusters + 2L) * 2 - 1) / SECTOR_SIZE + 1);
  toLE2(bpb->sectorsPerFAT,(word)sectorsPerFAT);

  directorySectors = (int)(capacity / 200);
  if (directorySectors < 1) directorySectors = 1;
  if (directorySectors > 15) directorySectors = 15;
  toUNAL2(bpb->rootDirectoryEntries,
         (word)(directorySectors * (SECTOR_SIZE / sizeof(DirectoryEntry))));

  if (vol.recommendedClusterInfo) {
    int sectorPadding = (int)((sectorAlignment - (sectors + 1 + noOfFATs * sectorsPerFAT + directorySectors)) % bpb->sectorsPerCluster);

    if (sectorPadding < 0)
      sectorPadding += bpb->sectorsPerCluster;
    toLE2(bpb->reservedSectors,sectorPadding + 1);
  }
  else
    toLE2(bpb->reservedSectors,1);
}


/*----------------------------------------------------------------------*/
/*      	 c r e a t e M a s t e r B o o t R e c o r d		*/
/*									*/
/* Creates the Master Boot Record (Sector 0)				*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	bpb		: volume BIOS parameter block			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*	cylinders	: Number of "cylinders" in volume		*/
/*----------------------------------------------------------------------*/

static FLStatus createMasterBootRecord(TL vol,
				     BPB *bpb,
				     dword cylinders)
{
  static byte bootCode[] = {
    0xFA, 0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C,
    0x8B, 0xF4, 0x50, 0x07, 0x50, 0x1F, 0xFB, 0xFC,
    0xBF, 0x00, 0x06, 0xB9, 0x00, 0x01, 0xF2, 0xA5,
    0xEA, 0x1D, 0x06, 0x00, 0x00, 0xBE, 0xBE, 0x07,
    0xB3, 0x04, 0x80, 0x3C, 0x80, 0x74, 0x0E, 0x80,
    0x3C, 0x00, 0x75, 0x1C, 0x83, 0xC6, 0x10, 0xFE,
    0xCB, 0x75, 0xEF, 0xCD, 0x18, 0x8B, 0x14, 0x8B,
    0x4C, 0x02, 0x8B, 0xEE, 0x83, 0xC6, 0x10, 0xFE,
    0xCB, 0x74, 0x1A, 0x80, 0x3C, 0x00, 0x74, 0xF4,
    0xBE, 0x8B, 0x06, 0xAC, 0x3C, 0x00, 0x74, 0x0B,
    0x56, 0xBB, 0x07, 0x00, 0xB4, 0x0E, 0xCD, 0x10,
    0x5E, 0xEB, 0xF0, 0xEB, 0xFE, 0xBF, 0x05, 0x00,
    0xBB, 0x00, 0x7C, 0xB8, 0x01, 0x02, 0x57, 0xCD,
    0x13, 0x5F, 0x73, 0x0C, 0x33, 0xC0, 0xCD, 0x13,
    0x4F, 0x75, 0xED, 0xBE, 0xA3, 0x06, 0xEB, 0xD3,
    0xBE, 0xC2, 0x06, 0xBF, 0xFE, 0x7D, 0x81, 0x3D,
    0x55, 0xAA, 0x75, 0xC7, 0x8B, 0xF5, 0xEA, 0x00,
    0x7C, 0x00, 0x00, 0x49, 0x6E, 0x76, 0x61, 0x6C,
    0x69, 0x64, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69,
    0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x61, 0x62,
    0x6C, 0x65, 0x00, 0x45, 0x72, 0x72, 0x6F, 0x72,
    0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67,
    0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65,
    0x6D, 0x00, 0x4D, 0x69, 0x73, 0x73, 0x69, 0x6E,
    0x67, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74,
    0x65, 0x6D};

  /* create partition table */
  PartitionTable partitionTable;
  Partition* ptEntry;

  tffsset(&partitionTable,0,sizeof partitionTable);
  tffscpy(&partitionTable,bootCode,sizeof bootCode);

  ptEntry = partitionTable.ptEntry;
  ptEntry->activeFlag = 0x80;	/* bootable */
  if (LE2(bpb->noOfHeads) > 1) {
    ptEntry->startingHead = 1;
    toLE2(ptEntry->startingCylinderSector,CYLINDER_SECTOR(0,1));
  }
  else {
    ptEntry->startingHead = 0;
    toLE2(ptEntry->startingCylinderSector,CYLINDER_SECTOR(1,1));
  }
  ptEntry->type = FAT12bit ? 1 : 4;
  ptEntry->endingHead = LE2(bpb->noOfHeads) - 1;
  toLE2(ptEntry->endingCylinderSector,
    (word)CYLINDER_SECTOR((cylinders - 1),LE2(bpb->sectorsPerTrack)));
  toUNAL4(ptEntry->startingSectorOfPartition,LE2(bpb->sectorsPerTrack));
  toUNAL4(ptEntry->sectorsInPartition,LE4(bpb->totalSectorsInVolume));

  toLE2(partitionTable.signature,PARTITION_SIGNATURE);

  return vol.writeSector(vol.rec,0,&partitionTable);
}


/*----------------------------------------------------------------------*/
/*      	     c r e a t e D O S B o o t S e c t o r		*/
/*									*/
/* Creates the DOS boot sector						*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	bpb		: volume BIOS parameter block			*/
/*	volumeId	: 32-bit volume id				*/
/*	volumeLabel	: volume label					*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus createDOSbootSector(TL vol,
				  BPB *bpb,
				  const byte FAR1 *volumeId,
				  const byte FAR1 *volumeLabel)
{
  DOSBootSector bootSector;

  tffsset(&bootSector,0,sizeof bootSector);
  bootSector.physicalDriveNo = 0x80;
  bootSector.extendedBootSignature = 0x29;
  tffscpy(bootSector.volumeId,volumeId,sizeof bootSector.volumeId);
  tffsset(bootSector.volumeLabel,' ',sizeof bootSector.volumeLabel);
  if (volumeLabel)
    tffscpy(bootSector.volumeLabel,volumeLabel,sizeof bootSector.volumeLabel);
  tffscpy(bootSector.systemId,
	  FAT12bit ? "FAT12   " : "FAT16   ",
	  sizeof bootSector.systemId);

  bootSector.bpb = *bpb;
  bootSector.bpb.jumpInstruction[0] = 0xe9;
  tffscpy(bootSector.bpb.OEMname,"MSystems",sizeof bootSector.bpb.OEMname);
  toLE2(bootSector.signature,PARTITION_SIGNATURE);

  return vol.writeSector(vol.rec,(SectorNo) LE4(bpb->noOfHiddenSectors),&bootSector);
}


/*----------------------------------------------------------------------*/
/*      	          c r e a t e F A T s				*/
/*									*/
/* Creates the FAT's							*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	bpb		: volume BIOS parameter block			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus createFATs(TL vol, BPB *bpb)
{
  int iFAT;

  SectorNo sectorNo = (SectorNo) (LE4(bpb->noOfHiddenSectors) +
				  LE2(bpb->reservedSectors));

  /* create the FATs */
  for (iFAT = 0; iFAT < bpb->noOfFATS; iFAT++) {
    int iSector;
    byte FATEntry[SECTOR_SIZE];

    for (iSector = 0; iSector < LE2(bpb->sectorsPerFAT); iSector++) {
      tffsset(FATEntry,0,SECTOR_SIZE);
      if (iSector == 0) {		/* write the reserved FAT entries */
	FATEntry[0] = bpb->mediaDescriptor;
	FATEntry[1] = 0xff;
	FATEntry[2] = 0xff;
	if (!FAT12bit)
	  FATEntry[3] = 0xff;
      }
      checkStatus(vol.writeSector(vol.rec,sectorNo++,FATEntry));
    }
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	     c r e a t e R o o t D i r e c t o r y		*/
/*									*/
/* Creates the root directory						*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	bpb		: volume BIOS parameter block			*/
/*	volumeLabel	: volume label					*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus createRootDirectory(TL vol,
				  BPB *bpb,
				  const byte FAR1 *volumeLabel)
{
  int iEntry;

  SectorNo sectorNo = (SectorNo) (LE4(bpb->noOfHiddenSectors) +
				  LE2(bpb->reservedSectors) +
				  bpb->noOfFATS * LE2(bpb->sectorsPerFAT));

  /* create the root directory */
  for (iEntry = 0; iEntry < UNAL2(bpb->rootDirectoryEntries);
       iEntry += (SECTOR_SIZE / sizeof(DirectoryEntry))) {
    DirectoryEntry rootDirectorySector[SECTOR_SIZE / sizeof(DirectoryEntry)];

    tffsset(rootDirectorySector,0,SECTOR_SIZE);
    if (iEntry == 0 && volumeLabel) {
      tffsset(rootDirectorySector[0].name,' ',sizeof rootDirectorySector[0].name);
      tffscpy(rootDirectorySector[0].name,volumeLabel,sizeof rootDirectorySector[0].name);
      rootDirectorySector[0].attributes = 0x28;	/* VOL + ARC */
      toLE2(rootDirectorySector[0].updateTime,0);
      toLE2(rootDirectorySector[0].updateDate,0x21);	/* 1/1/80 */
    }
    checkStatus(vol.writeSector(vol.rec,sectorNo++,rootDirectorySector));
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	          f l D o s F o r m a t				                */
/*								                        	            */
/* Writes a DOS-FAT file system on the Flash volume			            */
/*									                                    */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			                        */
/*	formatParams	: Address of FormatParams structure to use	        */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		                */
/*----------------------------------------------------------------------*/

FLStatus flDosFormat(TL vol, BDTLPartitionFormatParams FAR1 *formatParams)
{
  dword cylinders;
  BPB bpb;

  getDriveGeometry(&vol,&bpb,&cylinders,formatParams->noOfFATcopies,
	          (formatParams->flags & TL_OLD_FORMAT) ? TRUE : FALSE);

  checkStatus(createMasterBootRecord(&vol,&bpb,cylinders));

  checkStatus(createDOSbootSector(&vol,&bpb,formatParams->volumeId,formatParams->volumeLabel));

  checkStatus(createFATs(&vol,&bpb));

  checkStatus(createRootDirectory(&vol,&bpb,formatParams->volumeLabel));

  return flOK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\docbdk.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCBDK.H_V  $
 * 
 *    Rev 1.13   Apr 15 2002 07:35:48   oris
 * Moved bdkCall to blockdev.h
 * Added include for flreq.h and flfuncno.h when BDK_ACCESS is defined.
 * 
 *    Rev 1.12   Feb 19 2002 20:58:56   oris
 * Removed flflash.h include directive.
 * Moved bdkCall prototype to blockdev.
 * 
 *    Rev 1.11   Nov 08 2001 10:45:10   oris
 * Moved BDK module ifdef statement in order to allow the use of basic definitions.
 * 
 *    Rev 1.10   Oct 18 2001 22:17:12   oris
 * Added number of blocks per floor in the bdkVol structure.
 * 
 *    Rev 1.9   Oct 10 2001 19:48:28   oris
 * More afficient way to store the Binary module internal structure (bdkVol).
 * 
 *    Rev 1.8   May 20 2001 14:35:00   oris
 * Removed mtdsa.h include file.
 * 
 *    Rev 1.7   May 17 2001 16:51:08   oris
 * Removed warnings.
 * 
 *    Rev 1.6   May 16 2001 21:17:12   oris
 * Added OTP routines declaration.
 * Removed redefinitions of SOCKETS and BINARY_PARTITIONS.
 * Changed variable types to TrueFFS standard types.
 * Added EXTRA_SIZE definition and removed SYNDROM_BYTES.
 * 
 *    Rev 1.5   May 09 2001 00:32:14   oris
 * Removed the DOC2000_FAMILY and DOCPLUS_FAMILY defintion and replaced it with NO_DOC2000_FAMILY_SUPPORT, NO_DOCPLUS_FAMILY_SUPPORT, NO_NFTL_SUPPORT and NO_INFTL_SUPPORT.
 * Added BINARY_PARTITIONS and SOCKETS defintions.
 * 
 *    Rev 1.4   Apr 30 2001 17:59:38   oris
 * Changed bdkSetBootPartitonNo, bdkGetProtectionType, bdkSetProtection prototypes
 * 
 *    Rev 1.3   Apr 16 2001 13:32:02   oris
 * Removed warrnings.
 * 
 *    Rev 1.2   Apr 09 2001 15:06:18   oris
 * End with an empty line.
 * 
 *    Rev 1.1   Apr 01 2001 07:50:38   oris
 * Updated copywrite notice.
 * Removed nested comments.
 * Changed #include "base2400.h" to "mdocplus.h"
 * Fix for Big endien compilation problems - changed LEmin to LEulong
 * Changed MULTIPLIER_OFFSET define.
 * Changed protectionType to word instead of unsigned.
 * Added extern prototype of bdkVol pointer.
 *
 *    Rev 1.0   Feb 02 2001 13:24:56   oris
 * Initial revision.
 */

/***************************************************************************/
/*                  M-Systems Confidential                                 */
/*       Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001        */
/*                     All Rights Reserved                                 */
/***************************************************************************/
/*                         NOTICE OF M-SYSTEMS OEM                         */
/*                        SOFTWARE LICENSE AGREEMENT                       */
/*                                                                         */
/*   THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE            */
/*   AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT      */
/*   FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                         */
/*   OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                          */
/*   E-MAIL = info@m-sys.com                                               */
/***************************************************************************/
/************************************************************************/
/* Caution: The BDK_ACCESS compilation flag is for M-SYSTEMS internal   */
/*          use ONLY. This flag is used by M-SYSTEMS drivers and        */
/*          therfore it is SHOULD NOT be used by this package           */
/************************************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : docbdk.h                                                            *
*                                                                            *
* Description : This file contains the binary partition defintions , data    *
*               structures and function prototypes.                          *
*                                                                            *
* Note : The file exports 2 interfaces each under its own compilation flag:  *
*                                                                            *
*        BDK package - Standalone package that exports routines for binary   *
*                      partitions handling(MTD_STANDALONE compilation flag). *
*        OSAK module - Separated module of the OSAK package that exports a   *
*                      common entry point to the same routines. (BDK_ACCESS  *
*                      compilation flag).                                    *
*                                                                            *
* Warning : Do not use this file with the BDK_ACCESS compilation flag unless *
*           you own the full OSAK package.                                   *
*****************************************************************************/

#ifndef _DOC_BDK_H_
#define _DOC_BDK_H_

/*---------------------------------------------------------------------*/
/* Include the proper header files.                                    */
/*---------------------------------------------------------------------*/

#include "nanddefs.h"  /* The MTD for the doc2000 and millennium DiskOnChips */

#ifdef BDK_ACCESS
#include "flfuncno.h"
#include "flreq.h"
#endif /* BDK_ACCESS */



/*---------------------------------------------------------------------
 *
 *       Binary Development Kit Stand Alone Customization Area
 *
 *---------------------------------------------------------------------*/

/*---------------------------------------------------------------------*/
/* Boundries of the memory location to look for the DiskOnChip         */
/*---------------------------------------------------------------------*/

#define DOC_LOW_ADDRESS                 0xC8000L
#define DOC_HIGH_ADDRESS                0xE0000L

/*----------------------- Mtd selection -------------------------------
 *
 * Uncomment the following uneeded MTD or TL to reduce code size.
 *
 *---------------------------------------------------------------------*/

/* DiskOnChip2000, DiskOnChip Millennium and DiskOnChip 2000 Tsop devices */
/* #define NO_DOC2000_FAMILY_SUPPORT */

/* DiskOnChip Millennium plus device */
/* #define NO_DOCPLUS_FAMILY_SUPPORT */

/* NFTL format - DiskOnChip2000 and DiskOnChip Millennium */
/* #define NO_NFTL_SUPPORT */

/* INFTL format - DiskOnChip2000 Tsop and DiskOnChip Millennium Plus */
/* #define NO_INFTL_SUPPORT */

/*---------------------------------------------------------------------
 *
 *     End of Binary Development Kit Stand Alone Customization Area
 *
 *---------------------------------------------------------------------*/

/*---------------------------------------------------------------------*/
/* general constant                                                    */
/*---------------------------------------------------------------------*/

#define MAX_BINARY_PARTITIONS_PER_DRIVE 3
#define SIGNATURE_LEN                   8
#define BDK_SIGNATURE_NAME              4
#define SIGNATURE_NUM                   4
#define MBYTE                           0x100000L
#define KBYTE                           0x400
#define BLOCK                           0x200
#define BDK_SIGN_OFFSET                 8
#define ANAND_LEN                       5
#define BDK_COMPLETE_IMAGE_UPDATE       16
#define BDK_PARTIAL_IMAGE_UPDATE        0
#define BDK_MIN(a,b)   ((a) < (b) ? (a) : (b))

#define MULTIPLIER_OFFSET               5
#define BDK_INVALID_VOLUME_HANDLE       0xff
#define BDK_HEADERS_SPACING             (SECTOR_SIZE * 4)
#define BDK_UNIT_BAD                    0
#define BDK_NO_OF_MEDIA_HEADERS         2
#define BDK_FIELDS_BEFORE_HEADER        9 /* number of LEmin fieldsr to skip
                                             to reach  the volume records */
#define BDK_HEADER_FIELDS              35 /* number of LEmin fields used for
                                             volumes infromation record */
#define BDK_BINARY_FLAG       0x20000000L /* flag representing a binary volume
                                             in the volume information record */
/*  BDK specific flag area */
#define ERASE_BEFORE_WRITE 8
#define EXTRA_SIZE         16
/*---------------------------------------------------------------------*/
/* The maximum number of binary partitions                             */
/*---------------------------------------------------------------------*/

#ifndef BINARY_PARTITIONS
#define BINARY_PARTITIONS  SOCKETS /* for backwards compatibility */
#endif /* BINARY_PARITITON */

/*-------------------------- BDK Global Status Values --------------------*/
#define BDK_S_INIT          0    /* uninitialized binary partition record */
#define BDK_S_DOC_FOUND     0x01 /* DiskOnChip device was found           */
#define BDK_S_HEADER_FOUND  0X04 /* Partition information was found       */
#define BDK_S_INFO_FOUND    0x08 /* Sub partition information was found   */
/*------------------------------------------------------------------------*/

#if defined(BDK_ACCESS) || defined(MTD_STANDALONE)

/*------------------------------------------------------------------------*/
/* Global binary partition data structures                                */
/*------------------------------------------------------------------------*/

typedef struct { 

   byte  bdkGlobalStatus;            /* BDK global status variable         */
   byte  bdkEDC;                     /* ECC mode flag                      */
   byte  bdkSignOffset;              /* BDK signature offset ( 0 or 8)     */
   byte  bdkSavedSignOffset;         /* signature offset of last access    */
   word  bdkSavedStartUnit;          /* starting unit of last access       */
   word  startPartitionBlock, endPartitionBlock;   /* partition boundries  */
   word  startImageBlock, endImageBlock;       /* sub partition boundries  */
   word  curReadImageBlock;          /* current block number to read from  */
   word  blockPerFloor;              /* Blocks per floor                   */
   byte  signBuffer[SIGNATURE_LEN];  /* signature of binary sub partition  */
   dword bootImageSize;            /* available sub binary partition size  */
   dword realBootImageSize;  /* size used by an image on the sub partition */
   dword actualReadLen;              /* length needed to be read           */
   dword bdkDocWindow;               /* DiskOnChip window start address    */
   CardAddress curReadImageAddress;  /* current address to read from       */
#ifdef UPDATE_BDK_IMAGE
   CardAddress curUpdateImageAddress; /* current address to write to       */
   dword actualUpdateLen;      /* length needed to be write                */
   word  curUpdateImageBlock;  /* current block number to write to         */
   byte  updateImageFlag;/* BDK_COMPLETE_IMAGE_UPDATE \ ERASE_BEFORE_WRITE */
#endif /* UPDATE_BDK_IMAGE */
#ifdef PROTECT_BDK_IMAGE
   byte  protectionArea;       /* protection area no protecting the volume */
   word  protectionType;       /* PROTECTABLE , CHANGEABLE_PROTECTION      */
#endif /* PROTECT_BDK_IMAGE */

   byte  erasableBlockBits;    /* number of bits used to represen a block  */
   FLFlash * flash;            /* flash record representing the media      */

} BDKVol;

/*------------------------------------------------------------------------*/
/* Extern variables for low level operations.                             */
/*------------------------------------------------------------------------*/

extern BDKVol*  bdkVol;

/*------------------------------------------------------------------------*/
/* OSAK Routines argument packet                                          */
/*------------------------------------------------------------------------*/

#ifdef BDK_ACCESS
typedef struct {
byte oldSign[BDK_SIGNATURE_NAME];
byte newSign[BDK_SIGNATURE_NAME];
byte signOffset;
dword startingBlock;
dword length;
byte flags;
byte FAR1 *bdkBuffer;
} BDKStruct;
#endif /* BDK_ACCESS */

/*------------------------------------------------------------------------*/
/* Diffrent records used by the media header                              */
/*------------------------------------------------------------------------*/

typedef struct {
  LEulong    virtualSize;  /* Virtual size exported by the trasnaltion layer */
  LEulong    firstUnit;    /* First erasable block of the partition */
  LEulong    lastUnit;     /* Last erasable block of the partition */
  LEulong    flags;        /* PROTECTABLE , BDK_BINARY_FLAG */
  LEulong    not_used1;
  LEulong    not_used2;
  LEulong    protectionArea; /* protection area no' */
} VolumeRecord;

/************************ Function Prototype Begin ************************/

#ifdef MTD_STANDALONE

/*************************/
/* BDK specific routines */
/*************************/

void     bdkExit                 (void);
void     bdkSetDocWindow         (CardAddress docWindow);
FLStatus bdkSetBootPartitionNo   (byte partitionNo);
FLStatus bdkFindDiskOnChip       (CardAddress FAR2 *docAddress,
                 dword FAR2 *docSize );
FLStatus bdkCheckSignOffset      (byte FAR2 *signature );
FLStatus bdkCopyBootArea         (byte FAR1 *startAddress,
                 word startUnit,
                 dword areaLen,
                 byte FAR2 *checkSum,
                 byte FAR2 *signature);

/**************************************************/
/* common functions which are exported by the BDK */
/**************************************************/

FLStatus bdkGetBootPartitionInfo (word startUnit,
                 dword FAR2 *partitionSize,
                 dword FAR2 *realPartitionSize,
                 dword FAR2 *unitSize,
                 byte FAR2 *signature);

FLStatus bdkCopyBootAreaInit     (word startUnit,
                 dword areaLen,
                 byte FAR2 *signature);
FLStatus bdkCopyBootAreaBlock    (byte FAR1 *buf ,
                 word bufferLen,
                 byte FAR2 *checkSum);

#ifdef BDK_IMAGE_TO_FILE

FLStatus bdkCopyBootAreaFile     ( char FAR2 *fname,
                   word startUnit,
                   dword areaLen,
                   byte FAR2 *checkSum,
                   byte FAR2 *signature );
#endif /* BDK_IMAGE_TO_FILE */

#ifdef UPDATE_BDK_IMAGE

FLStatus bdkUpdateBootAreaInit   (word  startUnit,
                 dword  areaLen,
                 byte updateFlag,
                 byte FAR2 *signature );
FLStatus bdkUpdateBootAreaBlock  (byte FAR1 *buf ,
                 word bufferLen );

#ifdef ERASE_BDK_IMAGE
FLStatus bdkEraseBootArea        (word startUnit,
                 word noOfBlocks,
                 byte FAR2 * signature);
#endif /* ERASE_BDK_IMAGE */
#ifdef CREATE_BDK_IMAGE
FLStatus bdkCreateBootArea       (word noOfBlocks,
                 byte FAR2 * oldSign,
                 byte FAR2 * newSign);
#endif /* CREATE_BDK_IMAGE */

#ifdef HW_OTP
FLStatus bdkGetUniqueID(byte FAR1* buf);
FLStatus bdkReadOtp(word offset,byte FAR1 * buffer,word length);
FLStatus bdkWriteAndLockOtp(const byte FAR1 * buffer,word length);
FLStatus bdkGetOtpSize(dword FAR2* sectionSize, dword FAR2* usedSize,
               word FAR2* locked);
#endif /* HW_OTP */

#ifdef BDK_IMAGE_TO_FILE

FLStatus bdkUpdateBootAreaFile(char FAR2 *fname, word startUnit,
                   dword areaLen, byte FAR2 *signature);
#endif /* BDK_IMAGE_TO_FILE */

#endif /* UPDATE_BDK_IMAGE */

#ifdef PROTECT_BDK_IMAGE

FLStatus bdkGetProtectionType    (word * protectionType);

FLStatus bdkSetProtectionType    (word newType);

FLStatus bdkInsertKey            (byte FAR1* key);

FLStatus bdkRemoveKey            (void);

FLStatus bdkLockEnable           (byte enable);

FLStatus bdkChangeKey            (byte FAR1* key);

#endif /* PROTECT_BDK_IMAGE */

#else /* MTD_STANDALONE */

extern FLStatus bdkCall(FLFunctionNo functionNo,
                        IOreq FAR2 *ioreq, FLFlash* flash);

#endif /* MTD_STANDALONE */

/********************/
/* common functions */
/********************/

void     bdkInit( void );

/************************ Function Prototype End **************************/

#endif /* BDK_ACCESS || MTD_STANDALONE */
#endif /* _DOC_BDK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\dosformt.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOSFORMT.H_V  $
 * 
 *    Rev 1.2   Feb 19 2002 20:59:22   oris
 * Moved fltl.h include directive to the head of the file.
 *
 *    Rev 1.1   Apr 01 2001 07:45:06   oris
 * Updated copywrite notice
 *
 *    Rev 1.0   Feb 02 2001 13:51:48   oris
 * Initial revision.
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef DOSFORMT_H
#define DOSFORMT_H

#include "flformat.h"
#include "fltl.h"

/* The BIOS parameter block (a part of the boot sector)		*/
/* Note that this is NOT the customary definition of the BPB    */
/* (customary is to start it on 'bytesPerSector'). To avoid the */
/* nuisance of a structure that starts at an odd offset, we add */
/* the first 11 bytes of the boot sector here.			*/
typedef struct {
  unsigned char	jumpInstruction[3];
  char		OEMname[8];
  Unaligned	bytesPerSector;
  unsigned char	sectorsPerCluster;
  LEushort	reservedSectors;
  unsigned char	noOfFATS;
  Unaligned	rootDirectoryEntries;
  Unaligned	totalSectorsInVolumeDOS3;
  unsigned char	mediaDescriptor;
  LEushort	sectorsPerFAT;
  LEushort	sectorsPerTrack;
  LEushort	noOfHeads;
  LEulong	noOfHiddenSectors;
  LEulong	totalSectorsInVolume;
} BPB;


typedef struct {
  BPB		bpb;
  unsigned char	physicalDriveNo;
  char		reserved0;
  char		extendedBootSignature;
  char		volumeId[4];
  char		volumeLabel[11];
  char		systemId[8];
  char		bootstrap[448];
  LEushort	signature;
} DOSBootSector;


typedef struct {
  char		name[11];
  unsigned char	attributes;		/* mapped below */
  unsigned char	reserved[10];
  LEushort	updateTime;
	/* The date field is encoded as follows:	      		*/
	/* 	bit 0-4:	Day of month (1-31)			*/
	/* 	bit 5-8:	Month (1-12)				*/
	/*	bit 9-15:	Year relative to 1980			*/
  LEushort	updateDate;
	/* The DOS time field is encoded as follows:			*/
	/*	bit 0-4:	seconds divided by 2 (0-29)		*/
	/*      bit 5-10:	minutes (0-59)				*/
	/*	bit 11-15:	hours (0-23)				*/
  LEushort	startingCluster;
  LEulong	fileSize;
} DirectoryEntry;


/* Directory entry attribute bits */

#define	ATTR_READ_ONLY	1
#define	ATTR_HIDDEN	2
#define	ATTR_SYSTEM	4
#define	ATTR_VOL_LABEL	8
#define	ATTR_DIRECTORY	0x10
#define	ATTR_ARCHIVE	0x20

#define DIRECTORY_ENTRY_SIZE	sizeof(DirectoryEntry)

#define DIRECTORY_ENTRIES_PER_SECTOR	(SECTOR_SIZE / DIRECTORY_ENTRY_SIZE)

#define	NEVER_USED_DIR_ENTRY	0
#define	DELETED_DIR_ENTRY	((char) 0xe5)

/* FAT definitions */

#define	FAT_FREE	 0
#define	FAT_BAD_CLUSTER	 0xfff7
#define	FAT_LAST_CLUSTER 0xffff		/* actually any of 0xfff8-0xffff */

/* Partition table definitions */

#define PARTITION_SIGNATURE	0xaa55

#define CYLINDER_SECTOR(cylinder,sector) ((sector) + ((cylinder & 0xff) << 8) + ((cylinder & 0x300) >> 2))

#define FAT12_PARTIT 0x01
#define FAT16_PARTIT 0x04
#define EX_PARTIT    0x05
#define DOS4_PARTIT  0x06
#define MAX_PARTITION_DEPTH 8

typedef struct {
  /* First partition entry starts here. We do not map it as a	*/
  /* separate structure because it is not longword aligned	*/
  unsigned char	activeFlag;	/* 80h = bootable */
  unsigned char startingHead;
  LEushort	startingCylinderSector;
  char		type;
  unsigned char	endingHead;
  LEushort	endingCylinderSector;
  Unaligned4	startingSectorOfPartition;
  Unaligned4	sectorsInPartition;
  /* Partition entries 2,3 and 4 are structured as the 1st partition */
} Partition;

typedef struct {
  char          reserved1[0x1A6];
  Unaligned4      passwordInfo[3];  /* M-Systems proprietary */
  char          reserved2[0xC];   /* NT4 or NT5 signature place */

  /* First partition entry starts here. We do not map it as a	*/
  /* separate structure because it is not longword aligned	*/
  Partition ptEntry[4];
  LEushort	signature;	/* = PARTITION_SIGNATURE */
} PartitionTable;

#ifdef FORMAT_VOLUME

extern FLStatus flDosFormat(TL *, BDTLPartitionFormatParams FAR1 *formatParams);

#endif /* FORMAT_VOLUME */

#endif /* DOSFORMT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\docsys.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCSYS.H_V  $
 * 
 *    Rev 1.12   Apr 15 2002 07:36:04   oris
 * Reorganized for final release.
 * 
 *    Rev 1.11   Feb 19 2002 20:59:04   oris
 * Removed flflash.h include directive.
 * 
 *    Rev 1.10   Jan 28 2002 21:24:20   oris
 * Removed the use of back-slashes in macro definitions.
 * Replaced FLFlash argument with DiskOnChip memory base pointer.
 * Changed interface of write and set routines (those that handle more then 8/16 bits) so that instead of FLFlash record they receive the DiskOnChip memory window base pointer and offset (2 separated arguments). The previous implementation did not support address
 * shifting properly.
 * Changed memWinowSize to memWindowSize
 * Removed FL_ACCESS_NO_STRING.
 * 
 *    Rev 1.9   Jan 17 2002 22:59:46   oris
 * Completely revised, to support runtime customization and all M-Systems
 * DiskOnChip devices
 * 
 *    Rev 1.8   Nov 16 2001 00:19:58   oris
 * Added new line in the end, to remove warning.
 * 
 *    Rev 1.7   Sep 25 2001 15:35:04   oris
 * Restored to OSAK 4.3 implementation.
 *
 */

/************************************************************************/
/*                                                                      */
/*        FAT-FTL Lite Software Development Kit                         */
/*        Copyright (C) M-Systems Ltd. 1995-2001                        */
/*                                                                      */
/************************************************************************/

/************************************************************************/
/*                          I M P O R T E N T                           */ 
/*                                                                      */
/* The file contains DiskOnChip memory access routines and macros       */
/* defintions.                                                          */
/*                                                                      */
/* In order to use the complete set of TrueFFS memory access routine    */
/* that allows runtime configuration of each socket access type make    */
/* sure the FL_NO_USE_FUNC is not defined in either:                    */
/* FLCUSTOME.H - when using TrueFFS SDK based application               */
/* MTDSA.H     - when using Boot SDK based application                  */
/*                                                                      */
/* If you know the exact configuration of your application you can      */
/* uncomment the FL_NO_USE_FUNC definition and set the proper access    */
/* type using the macroe defintion bellow.                              */
/************************************************************************/

#ifndef DOCSYS_H
#define DOCSYS_H

#include "nanddefs.h"

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

#ifdef FL_NO_USE_FUNC 

#error "current version does not support the FL_NO_USE_FUNC compilation flag\r\n"

/* 
 * If you chose to customize the memory access routine using macroes, simply
 * add your implementation here.
 */
  
#define flWrite8bitReg(flash,offset,val)      
#define flRead8bitReg(flash,offset)           

#define docread     
#define docwrite    
#define docset      

/* DiskOnChip Plus memory access routines */

#define flWrite8bitRegPlus(flash,offset,val)  
#define flRead8bitRegPlus(flash,offset)         0x0
#define flWrite16bitRegPlus(flash,offset,val) 
#define flRead16bitRegPlus(flash,offset)        0x0

#define docPlusRead(win,offset,dest,count)    
#define docPlusWrite(win,offset,src,count)  
#define docPlusSet(win,offset,count,val)    

#define DOC_WIN                                 0x2000
#define setBusTypeOfFlash(flash,access)         flOK

#else

/* DiskOnChip memory access routines */

#define flWrite8bitReg(flash,offset,val)      flash->memWrite8bit(flash->win,offset,val)
#define flRead8bitReg(flash,offset)           flash->memRead8bit(flash->win,offset)

#define docread     flash->memRead
#define docwrite    flash->memWrite
#define docset      flash->memSet

/* DiskOnChip Plus memory access routines */

#define flWrite8bitRegPlus(flash,offset,val)  flash->memWrite8bit(flash->win,offset,val)
#define flRead8bitRegPlus(flash,offset)       flash->memRead8bit(flash->win,offset)
#define flWrite16bitRegPlus(flash,offset,val) flash->memWrite16bit(flash->win,offset,val)
#define flRead16bitRegPlus(flash,offset)      flash->memRead16bit(flash->win,offset)

#define docPlusRead(win,offset,dest,count)    flash->memRead(win,offset,dest,count)
#define docPlusWrite(win,offset,src,count)    flash->memWrite(win,offset,src,count)
#define docPlusSet(win,offset,count,val)      flash->memSet(win,offset,count,val)

#define DOC_WIN                               flash->memWindowSize()

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

/*
 * DiskOnChip Access routines types
 */

/* (public) types of DiskOnChip access configurations */

#define FL_BUS_HAS_8BIT_ACCESS     0x00000001L /* Bus can access 8-bit  */
#define FL_BUS_HAS_16BIT_ACCESS    0x00000002L /* Bus can access 16-bit */
#define FL_BUS_HAS_32BIT_ACCESS    0x00000004L /* Bus can access 32-bit */
#define FL_BUS_HAS_XX_ACCESS_MASK  0x0000000FL /* Bus can access mask   */

#define FL_NO_ADDR_SHIFT           0x00000000L /* No address shift     */
#define FL_SINGLE_ADDR_SHIFT       0x00000010L /* Single address shift */
#define FL_DOUBLE_ADDR_SHIFT       0x00000020L /* Double address shift */
#define FL_XX_ADDR_SHIFT_MASK      0x000000F0L /* Address shift mask   */

/* (private) types of DiskOnChip access configurations */

#define FL_8BIT_DOC_ACCESS         0x00000000L /* Has 8 data bits            */
#define FL_16BIT_DOC_ACCESS        0x00000100L /* Has 16 data bits           */
#define FL_XX_DATA_BITS_MASK       0x00000300L /* Mask of the above          */
#define FL_8BIT_FLASH_ACCESS       0x00000400L /* 8 bits of flash per cycle  */
#define FL_16BIT_FLASH_ACCESS      0x00000800L /* 16 bits of flash per cycle */
#define FL_XX_FLASH_ACCESS_MASK    0x00000C00L /* Mask of the above          */

#define FL_ACCESS_USER_DEFINED     0x00001000L /* User defined routines */

/* DiskOnChip routines prototypes */

extern FLStatus  setBusTypeOfFlash(FLFlash * flash,dword access);

#endif /* FL_NO_USE_FUNC */
#endif /* DOCSYS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\docsysp.h ===
/*********************************************************************
 *                                                                   *
 *   FAT-FTL Lite Software Development Kit                           *
 *   Copyright (C) M-Systems Ltd. 1995-2001                          *
 *                                                                   *
 *********************************************************************
 *                                                                   *
 *   Notes for the future:                                           *
 *                                                                   *
 *   1. Get rid of both macros and routines flRead8bitRegPlus/       *
 *      flPreInitRead8bitRegPlus/flWrite8bitRegPlus/                 *
 *      flPreInitWrite8bitRegPlus by calling routines mplusReadReg8/ *
 *      mplusWriteReg8 directly from M+ MTD.                         *
 *                                                                   *
 *********************************************************************/

/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/docsysp.h_V  $
 * 
 *    Rev 1.2   Sep 25 2001 15:39:46   oris
 * Removed FL_MPLUS_FAST_ACCESS.
 *
 *        Rev 1.1     Sep 24 2001 18:23:34     oris
 * Completely revised to support runtime true 16-bit access.
 */




#ifndef DOCSYSP_H
#define DOCSYSP_H




/*
 * includes
 */

#include "flflash.h"
#include "nanddefs.h"




/*
 * macros
 */


#define DOC_WIN    mplusWinSize()

#define flRead8bitRegPlus(vol,offset)                       ((Reg8bitType)mplusReadReg8((void FAR0 *)NFDC21thisVars->win, (int)offset))

#define flPreInitRead8bitRegPlus(driveNo,win,offset)        ((Reg8bitType)mplusReadReg8((void FAR0 *)win, (int)offset))

#define flWrite8bitRegPlus(vol,offset,val)                  mplusWriteReg8((void FAR0 *)NFDC21thisVars->win, (int)offset, (unsigned char)val)

#define flPreInitWrite8bitRegPlus(driveNo,win,offset,val)   mplusWriteReg8((void FAR0 *)win, (int)offset, (unsigned char)val)




/*
 * routines
 */

extern unsigned char   mplusReadReg8 (void FAR0 *win, int offset);

extern void            mplusWriteReg8 (void FAR0 *win, int offset, unsigned char val);

extern Reg16bitType    flRead16bitRegPlus (FLFlash vol, unsigned offset);

extern void    flWrite16bitRegPlus (FLFlash vol, unsigned offset, Reg16bitType val);

extern void    docPlusRead (FLFlash vol, unsigned regOffset, void FAR1 *dest,
                                                                             unsigned int count);

extern void    docPlusWrite (FLFlash vol, void FAR1 *src, unsigned int count);

extern void    docPlusSet (FLFlash vol, unsigned int count, unsigned char val);

extern unsigned long mplusWinSize (void);




#endif /* DOCSYSP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\fatlite.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FATLITE.H_V  $
 * 
 *    Rev 1.1   Apr 01 2001 08:03:02   oris
 * copywrite notice.
 * Alligned left all # directives.
 *
 *    Rev 1.0   Feb 04 2001 11:04:18   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef FATLITE_H
#define FATLITE_H

#include "blockdev.h"
#include "dosformt.h"
#include "fatfilt.h"
#include "flioctl.h"
#include "docbdk.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\fatfilt.h ===
/******************************************************************************* 
 *                                                                             * 
 *                         M-Systems Confidential                              * 
 *           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001        * 
 *                         All Rights Reserved                                 * 
 *                                                                             * 
 ******************************************************************************* 
 *                                                                             * 
 *                         NOTICE OF M-SYSTEMS OEM                             * 
 *                         SOFTWARE LICENSE AGREEMENT                          * 
 *                                                                             * 
 *  THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE AGREEMENT       * 
 *  BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT FOR THE SPECIFIC    * 
 *  TERMS AND CONDITIONS OF USE, OR CONTACT M-SYSTEMS FOR LICENSE              * 
 *  ASSISTANCE:                                                                * 
 *  E-MAIL = info@m-sys.com                                                    * 
 *                                                                             * 
 *******************************************************************************
 *                                                                             * 
 *                         Module: FATFILT                                     * 
 *                                                                             * 
 *  This module implements installable FAT12/16 filters. It supports up to     *
 *  SOCKETS sockets, with up to FL_MAX_DISKS_PER_SOCKET disks per socket.      * 
 *  Each disk can contain up to FL_MAX_PARTS_PER_DISK partitions on it, with   * 
 *  maximum depth of partition nesting in extended partitions equal to         * 
 *  MAX_PARTITION_DEPTH.                                                       *
 *                                                                             * 
 *  In order for this module to work, disks must be abs.mounted rather then    * 
 *  mounted. In latter case, this module won't detect any of disk's            * 
 *  partitions, and won't install FAT filters.                                 * 
 *                                                                             * 
 *  This module uses more then 512 bytes of stack space in case if MALLOC is   * 
 *  not enabled.                                                               * 
 *                                                                             * 
 *******************************************************************************/

/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FATFILT.H_V  $
 * 
 *    Rev 1.3   Apr 10 2001 23:54:52   oris
 * Removed FL_MAX_DISKS_PER_SOCKET  definition.
 * 
 *    Rev 1.2   Apr 09 2001 15:01:00   oris
 * Change static allocation to dynamic allocations.
 * 
 *    Rev 1.1   Apr 01 2001 07:51:24   oris
 * New implementation of fat filter.
 * 
 *    Rev 1.0   19 Feb 2001 21:16:14   andreyk
 * Initial revision.
 */


#ifndef FLFF_H
#define FLFF_H



#include "dosformt.h"
#include "flreq.h"




/* number of entries in disk's partition table */

#define  FL_PART_TBL_ENTRIES  4

/* max number of partitions (filesystem volumes) per disk */
 
#define  FL_MAX_PARTS_PER_DISK  (FL_PART_TBL_ENTRIES + MAX_PARTITION_DEPTH)




/* 
 * Generic 'initialization status' type 
 */

typedef enum { 

    flStateNotInitialized = 0, 
    flStateInitInProgress = 1, 
    flStateInitialized    = 2 

    } FLState; 


/* 
 * Disk partition (filesystem volume). Multiple partitions are allowed
 * on the disk.
 */

typedef struct {

    int        handle;             /* disk's TFFS handle                  */
    int        type;               /* FAT16_PARTIT                        */
    int        flags;              /* VOLUME_12BIT_FAT etc.               */
    FLBoolean  ffEnabled;          /* FAT filter is enabled on that part. */
    SectorNo   startSecNo;         /* sectorNo where partition starts     */
    SectorNo   sectors;            /* (info) total sectors in partition   */
    SectorNo   firstFATsecNo;      /* sectorNo of 1st sector of 1st FAT   */
    SectorNo   lastFATsecNo;       /* sectorNo of last sector of 1st FAT  */
    SectorNo   firstDataSecNo;
    unsigned   clusterSize;        /* Cluster size in sectors             */

} FLffVol;


/*
 * Disk with multiple partitions. Multiple disks are allowed on socket. 
 */

typedef struct {

    int        handle;             /* disk's TFFS handle              */
    FLState    ffstate;            /* FAT filter init. state          */
    int        parts;              /* total FAT12/16 partitions found */
    FLffVol  * part[FL_MAX_PARTS_PER_DISK];
    SectorNo   secToWatch;         /* used to track disk partitioning */
    char     * buf;                /* scratch buffer                  */

} FLffDisk;


/* 
 * Master Boot Record/Extended Boot Record of the disk 
 */

typedef struct {

    char               reserved[0x1be];

    struct {
        unsigned char  activeFlag;    /* 80h = bootable */
        unsigned char  startingHead;
        LEushort       startingCylinderSector;
        char           type;
        unsigned char  endingHead;
        LEushort       endingCylinderSector;
        Unaligned4     startingSectorOfPartition;
        Unaligned4     sectorsInPartition;
    } parts [FL_PART_TBL_ENTRIES];

    LEushort           signature;    /* = PARTITION_SIGNATURE */

} flMBR;




/*
 * FAT Filter API 
 */

#if defined(ABS_READ_WRITE) && !defined(FL_READ_ONLY)

  extern FLStatus     ffCheckBeforeWrite (IOreq FAR2 *ioreq);
  extern FLStatus     flffControl (int devNo, int partNo, FLState state);
  extern FLffDisk*    flffInfo    (int devNo);

#endif

#endif /* FLFF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flbuffer.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLBUFFER.H_V  $
 * 
 *    Rev 1.3   Jul 13 2001 01:03:58   oris
 * Added read Back buffer size definition.
 * 
 *    Rev 1.2   May 16 2001 21:29:24   oris
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.2   May 16 2001 21:17:44   oris
 * Added backwards compatibility check for FL_MALLOC the new definition replacing MALLOC.
 * 
 *    Rev 1.1   Apr 01 2001 07:45:44   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 11:17:06   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLBUFFER_H
#define FLBUFFER_H

#include "flbase.h"

#define READ_BACK_BUFFER_SIZE    1024 /* Size of read back buffer
                                         Must be multiplication of 512 */
typedef struct {
  unsigned char flData[SECTOR_SIZE];	/* sector buffer */
  SectorNo	sectorNo;		/* current sector in buffer */
  void		*owner;			/* owner of buffer */
  FLBoolean	dirty;			/* sector in buffer was changed */
  FLBoolean	checkPoint;		/* sector in buffer must be flushed */
} FLBuffer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\fatfilt.c ===
/******************************************************************************* 
 *                                                                             * 
 *                         M-Systems Confidential                              * 
 *           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001        * 
 *                         All Rights Reserved                                 * 
 *                                                                             * 
 ******************************************************************************* 
 *                                                                             * 
 *                         NOTICE OF M-SYSTEMS OEM                             * 
 *                         SOFTWARE LICENSE AGREEMENT                          * 
 *                                                                             * 
 *  THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE AGREEMENT       * 
 *  BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT FOR THE SPECIFIC    * 
 *  TERMS AND CONDITIONS OF USE, OR CONTACT M-SYSTEMS FOR LICENSE              * 
 *  ASSISTANCE:                                                                * 
 *  E-MAIL = info@m-sys.com                                                    * 
 *                                                                             * 
 *******************************************************************************
 *                                                                             * 
 *                                                                             * 
 *                         Module: FATFILT                                     * 
 *                                                                             * 
 *  This module implements installable FAT12/16 filters. It supports up to     *
 *  SOCKETS sockets, with up to MAX_TL_PARTITIONS disks per socket.      * 
 *  Each disk can contain up to FL_MAX_PARTS_PER_DISK partitions on it, with   * 
 *  maximum depth of partition nesting in extended partitions equal to         * 
 *  MAX_PARTITION_DEPTH.                                                       *
 *                                                                             * 
 *  In order for this module to work, disks must be abs.mounted rather then    * 
 *  mounted. In latter case, this module won't detect any of disk's            * 
 *  partitions, and won't install FAT filters.                                 * 
 *                                                                             * 
 *  This module uses more then 512 bytes of stack space in case if MALLOC is   * 
 *  not enabled.                                                               * 
 *                                                                             * 
 *******************************************************************************/

/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FATFILT.C_V  $
 * 
 *    Rev 1.10   Jan 17 2002 23:00:14   oris
 * Changed debug print added \r.
 * 
 *    Rev 1.9   Sep 15 2001 23:45:50   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 * 
 *    Rev 1.8   Jun 17 2001 16:39:10   oris
 * Improved documentation and remove warnings.
 * 
 *    Rev 1.7   May 16 2001 21:17:18   oris
 * Added the FL_ prefix to the following defines: MALLOC and FREE.
 * 
 *    Rev 1.6   May 01 2001 14:21:02   oris
 * Remove warnings.
 * 
 *    Rev 1.5   Apr 30 2001 18:00:10   oris
 * Added casting to remove warrnings.
 * 
 *    Rev 1.4   Apr 24 2001 17:07:32   oris
 * Missing casting of MALLOC calls.
 * 
 *    Rev 1.3   Apr 10 2001 23:54:24   oris
 * FL_MAX_DISKS_PER_SOCKET changed to MAX_TL_PARTITIONS.
 * 
 *    Rev 1.2   Apr 09 2001 15:00:42   oris
 * Change static allocation to dynamic allocations.
 * Renamed flffCheck back to ffCheckBeforeWrite to be backwards compatible with OSAK 4.2.
 * 
 *    Rev 1.1   Apr 01 2001 07:51:16   oris
 * New implementation of fat filter.
 * 
 *    Rev 1.0   19 Feb 2001 21:14:14   andreyk
 * Initial revision.
 */




/* 
 * Includes
 */

#include "fatfilt.h"
#include "blockdev.h"
#include "flflash.h"
#include "bddefs.h"


#if defined(ABS_READ_WRITE) && !defined(FL_READ_ONLY)




/*
 * Module configuration
 */

#define  FL_INCLUDE_FAT_MONITOR     /* undefine it to remove FAT filter code */




/*
 * Defines
 */

/* extract pointer to user's buffer from IOreq */

#ifdef SCATTER_GATHER
#define  FLBUF(ioreq,i)  (*((char FAR1 **)((ioreq)->irData) + (int)(i)))
#else
#define  FLBUF(ioreq,i)  ((char FAR1 *)(ioreq->irData) + (SECTOR_SIZE * ((int)(i))))
#endif

/* extract socket# and disk# from TFFS handle */

#define  H2S(handle)     (((int)(handle)) & 0xf)
#define  H2D(handle)     ((((int)(handle)) >> 4) & 0xf)

/* construct TFFS handle from socket# and disk# */

#define  SD2H(socNo,diskNo)  ((int)((((diskNo) & 0xf) << 4) | ((socNo) & 0xf)))

/* unformatted ("raw") disk partition */

#define  FL_RAW_PART  (-1)




/*
 * Local routines 
 */

static FLStatus   reset (void);
static FLStatus   discardDisk (int handle);
static FLStatus   newDisk (int handle);
static FLStatus   parseDisk (int handle);
static FLStatus   discardDiskParts (FLffDisk *pd);
static FLStatus   addDiskPart (FLffDisk *pd, int partNo);
static FLStatus   addNewDiskPart (FLffDisk *pd);
static FLBoolean  isPartTableWrite (FLffDisk *pd, IOreq FAR2 *ioreq);
static FLStatus   isExtPartPresent (char FAR1 *buf, SectorNo *nextExtPartSec);


#ifdef FL_INCLUDE_FAT_MONITOR

static FLStatus   partEnableFF (FLffVol* pv);
static FLStatus   partFreeDelClusters (FLffVol *pv, SectorNo secNo, char FAR1 *newFAT);

#endif




/*
 * Local data
 */

/* module reset flag */

static FLBoolean  resetDone = FALSE; 

/* disks (BDTL partitions in OSAK terminology) */

static FLffDisk*  ffDisk[SOCKETS][MAX_TL_PARTITIONS] = { { NULL } };


#ifndef FL_MALLOC

/*          
 *        WARNING: Large static arrays ! 
 *
 *  sizeof(ffAllDisks[x][y])    is 64 bytes. 
 *  sizeof(ffAllParts[x][y][z]) is 40 bytes.
 *
 */

static FLffDisk ffAllDisks[SOCKETS][MAX_TL_PARTITIONS];
static FLffVol  ffAllParts[SOCKETS][MAX_TL_PARTITIONS][FL_MAX_PARTS_PER_DISK];

#endif /* FL_MALLOC */

static const char zeroes[SECTOR_SIZE] = {0};




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                    d i s c a r d D i s k P a r t s                          *
 *                                                                             * 
 *  Discard all the partition info (if any) associated with particular disk.   * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      pd                 : disk (BDTL volume)                                   * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      Always flOK.                                                           * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  discardDiskParts ( FLffDisk * pd )
{
    register int  i;

    if (pd != NULL) {

        for (i = 0; i < FL_MAX_PARTS_PER_DISK; i++) {

#ifdef FL_MALLOC
        if (pd->part[i] != NULL)
            FL_FREE(pd->part[i]);
#endif

            pd->part[i] = NULL;
        }

        pd->parts = 0;
    }

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                      a d d D i s k P a r t                                  *
 *                                                                             * 
 *  If there is partition record #partNo associated with the disk, discard     * 
 *  this info. Attach new partition record #partNo.                            * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      pd                 : disk (BDTL volume)                                   * 
 *      partNo             : partition (0 ... FL_MAX_PARTS_PER_DISK-1)            * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK if success, otherwise respective error code                       * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  addDiskPart ( FLffDisk * pd, 
                               int        partNo )
{
    FLffVol  * pv;    
    FLStatus   status;
    int        socNo, diskNo;

    /* arg. sanity check */

    if ((pd == NULL) || (partNo >= FL_MAX_PARTS_PER_DISK))
        return flBadDriveHandle;

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(pd->handle);
    diskNo = H2D(pd->handle);
 
    if ((socNo >= SOCKETS) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    status = flNotEnoughMemory;

#ifdef FL_MALLOC
    pv = (FLffVol *)FL_MALLOC( sizeof(FLffVol) );
#else
    pv = &ffAllParts[socNo][diskNo][partNo];
#endif

    if (pv != NULL) {

        /* initialize fields in struct FLffDisk to safe values */
 
        pv->handle         = pd->handle; 
        pv->type           = FL_RAW_PART;
        pv->flags          = 0;          
        pv->ffEnabled      = FALSE;                  /* turn off FAT minitor */
        pv->sectors        = (SectorNo) 0;
        pv->firstFATsecNo  = (SectorNo) -1;          /* none */
        pv->lastFATsecNo   = pv->firstFATsecNo;      /* none */
        pv->firstDataSecNo = (SectorNo) 0;
        pv->clusterSize    = (unsigned) 0;

#ifdef FL_MALLOC
        if( pd->part[partNo] != NULL )
        FL_FREE(pd->part[partNo]);
#endif
        
        pd->part[partNo] = pv;

        status = flOK;
    }

    return status;    
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                    a d d N e w D i s k P a r t                              *
 *                                                                             * 
 *  Add one more partition record to the disk.                                 * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      pd                 : disk (BDTL volume)                                   * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK if success, otherwise respective error code                       * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  addNewDiskPart ( FLffDisk * pd )
{
    if (pd->parts < FL_MAX_PARTS_PER_DISK) {

        checkStatus( addDiskPart (pd, pd->parts) );
    pd->parts++;
    }

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                       d i s c a r d D i s k                                 *
 *                                                                             * 
 *  Remove disk record (with all the associated partition records).            * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      handle             : TFFS handle                                          * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK if success, otherwise respective error code                       * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  discardDisk ( int  handle )
{
    int  socNo, diskNo;

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= SOCKETS) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    if( ffDisk[socNo][diskNo] != NULL ) {

    /* discard associated partition info */

    (void) discardDiskParts( ffDisk[socNo][diskNo] );

#ifdef FL_MALLOC

        /* release disk's scratch buffer */
 
        if( (ffDisk[socNo][diskNo])->buf != NULL)
            FL_FREE( (ffDisk[socNo][diskNo])->buf );

        FL_FREE( ffDisk[socNo][diskNo] );

#endif

        ffDisk[socNo][diskNo] = NULL;
    }

    return flOK;    
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                           n e w D i s k                                     *
 *                                                                             * 
 *  Discard existing disk record (if any), and create new one.                 * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      handle             : TFFS handle                                       * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK if success, otherwise respective error code                       * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  newDisk ( int  handle )
{
    int        socNo, diskNo;
    int        i;
    FLffDisk * pd;

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= SOCKETS) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* discard current disk and associated partition info (if any) */

    checkStatus( discardDisk(handle) );

#ifdef FL_MALLOC

    pd = (FLffDisk *) FL_MALLOC( sizeof(FLffDisk) );

    if (pd == NULL)
        return flNotEnoughMemory;

    /* allocate and attach disk's scratch buffer */

    pd->buf = (char *)FL_MALLOC( SECTOR_SIZE );

    if (pd->buf == NULL) {

        FL_FREE (pd);
        return flNotEnoughMemory;
    }

#else /* !FL_MALLOC */

    pd = &ffAllDisks[socNo][diskNo];

#endif /* FL_MALLOC */


    pd->handle  = handle;
    pd->ffstate = flStateNotInitialized;

    /* don't know partition layout yet */

    pd->parts   = 0;
    for (i = 0; i < FL_MAX_PARTS_PER_DISK; i++)
        pd->part[i] = NULL;

    /* watch Master Boot Record for update */

    pd->secToWatch = (SectorNo) 0;

    ffDisk[socNo][diskNo] = pd;

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   i s P a r t T a b l e W r i t e                           *
 *                                                                             * 
 *  Check if any of the sectors specified by 'ioreq' points to Master Boot     * 
 *  Record or next extended partition in the extended partitions list.         * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      pd                 : pointer to disk structure                         * 
 *      ioreq              : standard I/O request                              * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      TRUE if write to MBR or extended partition list is detected, otherwise * 
 *      FALSE                                                                  * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLBoolean isPartTableWrite ( FLffDisk   * pd, 
                                    IOreq FAR2 * ioreq )
{
    register long  i;

    if (pd != NULL) {

        for (i = (long)0; i < ioreq->irSectorCount; i++) {

            if( (ioreq->irSectorNo + i) == (long)pd->secToWatch )
                return TRUE;
        }
    }

    return FALSE;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   i s E x t P a r t P r e s e n t                           *
 *                                                                             * 
 *  Check if extended partition persent in the partition table. If it is,      * 
 *  calculate the sector # where next partition table will be written to.      * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      buf                : partition table                                   * 
 *      nextExtPartSec  : sector where next partition table will be written to * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  isExtPartPresent ( char FAR1 * buf, 
                                    SectorNo  * nextExtPartSec )
{
    Partition FAR1 * p;
    register int     i;
  
    /* does it look like partition table ? */

    if (LE2(((PartitionTable FAR1 *) buf)->signature) != PARTITION_SIGNATURE)
        return flBadFormat;   

    /* if extended. part. present, get sector# that will contain next part. in list */

    p = &( ((PartitionTable FAR1 *) buf)->ptEntry[0] );

    for (i = 0;  i < FL_PART_TBL_ENTRIES;  i++, p++) {

        if (p->type == EX_PARTIT) {

            *nextExtPartSec = (SectorNo) UNAL4( (void *) p[i].startingSectorOfPartition );
            return flOK;
        }
    }

    /* no extended partition found */

    return flFileNotFound;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                           r e s e t                                         *
 *                                                                             * 
 *  Resets this software module to it's initial state upon boot.               * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    none                                                                   * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK in case of success, otherwise respective error code               * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  reset (void)
{
    int iSoc, iDisk;

    for (iSoc = 0; iSoc < SOCKETS; iSoc++) {

        /* discard existing disk structures for that socket */

        for (iDisk = 0; iDisk < MAX_TL_PARTITIONS; iDisk++)
        (void) discardDisk( SD2H(iSoc, iDisk) );

        /* pre-allocate disk structure for first disk of every socket */

        checkStatus( newDisk(SD2H(iSoc, 0)) );
    }

    resetDone = TRUE;

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                          p a r s e D i s k                                  *
 *                                                                             * 
 *  Read partition table(s), install and enable FAT filters on all FAT12/16    * 
 *  partitions.                                                                * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    handle         : TFFS handle                                          * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 *  NOTE:  This routine uses disk's scratch buffer.                            * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  parseDisk ( int handle )
{
    int          socNo, diskNo;
    SectorNo     extPartStartSec, sec;
    int          i, depth;
    int          type;
    FLffDisk   * pd;
    FLffVol    * pv;
    Partition  * pp;
    IOreq        ioreq;

#ifdef  FL_MALLOC
    char       * buf;
#else
    char         buf[SECTOR_SIZE];
#endif

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* if disk structure hasn't been allocated yet, do it now */

    if (ffDisk[socNo][diskNo] == NULL)
        checkStatus( newDisk(handle) );

    pd = ffDisk[socNo][diskNo];
    
#ifdef  FL_MALLOC

    /* make sure scratch buffer is available */

    if (pd->buf == NULL)
        return flBufferingError;

    buf = pd->buf;

#endif /* FL_MALLOC */ 
 
    /* discard obsolete disk's partition info */

    (void) discardDiskParts (pd);

    /* read Master Boot Record */

    ioreq.irHandle      = handle;
    ioreq.irSectorNo    = (SectorNo) 0;
    ioreq.irSectorCount = (SectorNo) 1;
    ioreq.irData        = (void FAR1 *) buf;
    checkStatus( flAbsRead(&ioreq) );

    /* is it MBR indeed ? */

    if (LE2(((PartitionTable *) buf)->signature) != PARTITION_SIGNATURE)
        return flPartitionNotFound;                         

    /* do primary partitions only (we will do extended partitions later) */

    pp = &( ((PartitionTable *) buf)->ptEntry[0] );

    for (i = 0; i < FL_PART_TBL_ENTRIES; i++, pp++) {

        if( pp->type == ((char)0) )          /* skip empty slot */
            continue;

        if( pp->type == ((char)EX_PARTIT) )  /* skip extended partition */
        continue;

    /* primary partition found (not necessarily FAT12/16) */

        if( addNewDiskPart(pd) != flOK )
        break;

        pv = pd->part[pd->parts - 1];

        /* remember partition's type, and where it starts */

        pv->type       = (int) pp->type;
        pv->startSecNo = (SectorNo) UNAL4( (void *) pp->startingSectorOfPartition );
    } 

    /* do extended partitions in depth */

    for (i = 0; i < FL_PART_TBL_ENTRIES; i++) {

        /* re-read Master Boot Record */

        ioreq.irHandle      = handle;
        ioreq.irSectorNo    = (SectorNo) 0;
        ioreq.irSectorCount = (SectorNo) 1;
        ioreq.irData        = (void FAR1 *) buf;
        checkStatus( flAbsRead(&ioreq) );

        /* is it MBR indeed ? */

        if (LE2(((PartitionTable *) buf)->signature) != PARTITION_SIGNATURE)
            return flOK;

        /* pick up next extended partition in MBR */

        pp = &( ((PartitionTable *) buf)->ptEntry[i] );

        if( pp->type == ((char)EX_PARTIT) ) {

            /* remember where extended partition starts */

            extPartStartSec = (SectorNo) UNAL4( (void *) pp->startingSectorOfPartition );   

            /* follow the list of partition tables */

            sec = extPartStartSec;

            for (depth = 0;  depth < MAX_PARTITION_DEPTH;  depth++) {

                /* read next partition table in the list */

                ioreq.irHandle      = handle;
                ioreq.irSectorNo    = sec;
                ioreq.irSectorCount = (SectorNo) 1;
                ioreq.irData        = (void FAR1 *) buf;
                checkStatus( flAbsRead(&ioreq) );

                /* is it valid partition table ? */

                if (LE2(((PartitionTable *) buf)->signature) != PARTITION_SIGNATURE)
                    break;

                /* if 1st entry is zero, it's the end of part. table list */

                pp = &( ((PartitionTable *) buf)->ptEntry[0] );
                if( pp->type == ((char)0) )
                    break;

                /* Take this partition. Remember it's type, and where it starts */

                if( addNewDiskPart(pd) != flOK )
                break;

                pv = pd->part[pd->parts - 1];

                pv->type       = (int) pp->type;
                pv->startSecNo = 
                    (SectorNo) UNAL4( (void *) pp->startingSectorOfPartition) + sec;

                /* 2nd entry must be extended partition */

                pp = &( ((PartitionTable *) buf)->ptEntry[1] );
                if( pp->type != ((char)EX_PARTIT) )
              break;

                /* sector where next part. table in the list resides */

                sec = extPartStartSec + 
                      (SectorNo) UNAL4( (void *) pp->startingSectorOfPartition );

        }   /* for(depth) */
        }
    }   /* for(i) */ 

#ifdef FL_INCLUDE_FAT_MONITOR

    /* turn on FAT filters on FAT12/16 partition(s) */

    if (pd->parts > 0) {

        for (i = 0;  i < pd->parts;  i++) {

            pv   = pd->part[i];
            type = pv->type;

            /*
             *  WARNING : Routine partEnableFF() uses disk's scratch buffer !
             */

        if((type == FAT12_PARTIT) || (type == FAT16_PARTIT) || (type == DOS4_PARTIT))
                partEnableFF (pv);
    }
    }

#endif /* FL_INCLUDE_FAT_MONITOR */

    /* watch for MBR (sector #0) update */

    pd->secToWatch = (SectorNo) 0;

    pd->ffstate    = flStateInitialized;

    return flOK;
}




#ifdef FL_INCLUDE_FAT_MONITOR

/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                     p a r t E n a b l e F F                                 *
 *                                                                             * 
 *  Installs and enables FAT filter on partition.                              * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    pv            : disk partition (filesystem volume)                   * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 *  NOTE:  This routine uses disk's scratch buffer.                            * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  partEnableFF ( FLffVol * pv )
{
    int        socNo, diskNo;
    FLffDisk * pd;
    BPB      * bpb;
    SectorNo   sectors;
    SectorNo   rootDirSecNo;
    SectorNo   rootDirSectors;
    SectorNo   sectorsPerFAT;
    unsigned   maxCluster;
    int        partNo;
    IOreq      ioreq;

#ifdef  FL_MALLOC
    char     * buf;
#else
    char       buf[SECTOR_SIZE];
#endif

    /* arg. sanity check */

    if (pv == NULL)
        return flBadDriveHandle;
 
    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(pv->handle);
    diskNo = H2D(pv->handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* check if 'pv' belongs to this disk */

    pd = ffDisk[socNo][diskNo];

    if (pd == NULL)
        return flBadDriveHandle;

    for (partNo = 0; partNo < pd->parts; partNo++) {

        if (pd->part[partNo] == pv)
        break;
    }

    if (partNo >= pd->parts)
        return flBadDriveHandle;

#ifdef  FL_MALLOC

    /* make sure scratch buffer is available */

    if (pd->buf == NULL)
        return flBufferingError;

    buf = pd->buf;
 
#endif /* FL_MALLOC */ 

    /* make sure FAT filter is off on this partition */

    pv->ffEnabled       = FALSE;

    pv->firstFATsecNo   = (SectorNo) -1;
    pv->lastFATsecNo    = pv->firstFATsecNo;
    pv->clusterSize     = (unsigned) 0;

    /* read the BPB */

    ioreq.irHandle      = pv->handle;
    ioreq.irSectorNo    = pv->startSecNo;
    ioreq.irSectorCount = (SectorNo) 1;
    ioreq.irData        = (void FAR1 *) buf;
    checkStatus( flAbsRead(&ioreq) );

    /* Does it look like DOS bootsector ? */

    bpb = &( ((DOSBootSector *) buf)->bpb );

    if( !((bpb->jumpInstruction[0] == 0xe9) 
            || 
         ((bpb->jumpInstruction[0] == 0xeb) && (bpb->jumpInstruction[2] == 0x90)))) {

        return flNonFATformat;
    }

    /* Do we handle this sector size ? */

    if (UNAL2(bpb->bytesPerSector) != SECTOR_SIZE)
        return flFormatNotSupported;

    /* 
     * Is it a bogus BPB (leftover from previous disk partitioning) ? 
     * Check that there is no overlap with next partition (if one exists).
     */

    sectors = UNAL2(bpb->totalSectorsInVolumeDOS3);
    if (sectors == (SectorNo)0)
        sectors = (SectorNo) LE4(bpb->totalSectorsInVolume);

    if ((partNo+1 < pd->parts) && (pd->part[partNo+1] != NULL)) {

        if( sectors > (pd->part[partNo+1])->startSecNo - pv->startSecNo )
            return flNonFATformat;
    }

    /* number of sectors in partition as reported by BPB */

    pv->sectors        = sectors;

    /* valid BPB; get the rest of partition info from it */

    pv->firstFATsecNo  = pv->startSecNo + (SectorNo)( LE2(bpb->reservedSectors) );
    sectorsPerFAT      = (SectorNo) LE2(bpb->sectorsPerFAT);
    pv->lastFATsecNo   = pv->firstFATsecNo + sectorsPerFAT - (SectorNo)1;
    rootDirSecNo       = pv->firstFATsecNo + (sectorsPerFAT * bpb->noOfFATS);
    rootDirSectors     = (SectorNo)1 + (SectorNo)
        (((UNAL2(bpb->rootDirectoryEntries) * DIRECTORY_ENTRY_SIZE) - 1) / SECTOR_SIZE);
    pv->firstDataSecNo = rootDirSecNo + rootDirSectors;

    pv->clusterSize    = bpb->sectorsPerCluster;

    /* decide which type of FAT is it */

    maxCluster         = (unsigned)1 + (unsigned) 
        ((pv->sectors - (pv->firstDataSecNo - pv->startSecNo)) / pv->clusterSize);

    if (maxCluster < 4085) {
        pv->flags |= VOLUME_12BIT_FAT;    /* 12-bit FAT */

#ifndef FAT_12BIT
        DEBUG_PRINT(("Debug: FAT_12BIT must be defined.\r\n"));
        return flFormatNotSupported;
#endif
    }

    /* turn on FAT filter on this partition */

    pv->ffEnabled = TRUE;

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   p a r t F r e e D e l C l u s t e r s                     *
 *                                                                             * 
 *  Compare the new contents of the specified FAT sector against the old       * 
 *  one on the disk. If any freed clusters are found, issue 'sector delete'    * 
 *  calls for all sectors that are occupied by these freed clusters.           * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    pv            : disk partition (filesystem volume)                   * 
 *      secNo           : abs. sector # of the FAT sector                      * 
 *      newFAT          : new contents of this FAT sector                      * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 *  NOTE:  This routine uses disk's scratch buffer.                            * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  partFreeDelClusters ( FLffVol   * pv,
                                       SectorNo    secNo,
                                       char FAR1 * newFAT)
{
    FLffDisk * pd;
    int        socNo, diskNo;
    unsigned   short oldFATentry, newFATentry;
    SectorNo   iSec;
    unsigned   firstCluster;
    IOreq      ioreq;
    int        offset;
    int        iPart;

#ifdef FAT_12BIT
    int        halfBytes;
#endif

#ifdef  FL_MALLOC
    char     * oldFAT;
#else
    char       oldFAT[SECTOR_SIZE];
#endif

    /* arg. sanity check */

    if (pv == NULL)
        return flBadDriveHandle;
 
    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(pv->handle);
    diskNo = H2D(pv->handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* check if 'pv' belongs to this disk */

    pd = ffDisk[socNo][diskNo];

    if (pd == NULL)
        return flBadDriveHandle;

    for (iPart = 0; iPart < pd->parts; iPart++) {

        if (pd->part[iPart] == pv)
        break;
    }

    if (iPart >= pd->parts)
        return flBadDriveHandle;

#ifdef  FL_MALLOC

    /* make sure scratch buffer is available */

    if (pd->buf == NULL)
        return flBufferingError;

    oldFAT = pd->buf;
 
#endif /* FL_MALLOC */

    /* read in the FAT sector from the disk */

    ioreq.irHandle      = pv->handle;
    ioreq.irSectorNo    = secNo;
    ioreq.irSectorCount = 1;
    ioreq.irData        = (void FAR1 *) oldFAT;
    checkStatus( flAbsRead(&ioreq) );

#ifdef FAT_12BIT

    /* size of FAT entry in half-bytes */

    halfBytes = ((pv->flags & VOLUME_12BIT_FAT) ? 3 : 4);

    /* starting cluster */

    if (halfBytes == 3) {

    firstCluster = 
            ((((unsigned)(secNo - pv->firstFATsecNo)) * (2 * SECTOR_SIZE)) + 2) / 3;
    }
    else {
        firstCluster = ((unsigned)(secNo - pv->firstFATsecNo)) * (SECTOR_SIZE / 2);
    }

    /* staring data sector */

    iSec = (((SectorNo)firstCluster - 2) * pv->clusterSize) + pv->firstDataSecNo;

    offset = (firstCluster * ((unsigned) halfBytes)) & ((2 * SECTOR_SIZE) - 1);

    /* 
     *  Find if any clusters were logically deleted, and if so, delete them.
     *
     *  NOTE: We are skipping over 12-bit FAT entries which span more than
     *        one sector.
     */

    for (; offset < ((2 * SECTOR_SIZE) - 2); 
               offset += halfBytes, iSec += pv->clusterSize) {

#ifdef FL_BIG_ENDIAN
        oldFATentry = LE2( *(LEushort FAR0 *)(oldFAT + (offset / 2)) );
        newFATentry = LE2( *(LEushort FAR1 *)(newFAT + (offset / 2)) );
#else
        oldFATentry = UNAL2( *(Unaligned FAR0 *)(oldFAT + (offset / 2)) );
        newFATentry = UNAL2( *(Unaligned FAR1 *)(newFAT + (offset / 2)) );
#endif /* FL_BIG_ENDIAN */

        if (offset & 1) {
            oldFATentry >>= 4;
            newFATentry >>= 4;
        }
        else { 
            if (halfBytes == 3) {
                oldFATentry &= 0xfff;
                newFATentry &= 0xfff;
        }
        }

#else /* !FAT_12BIT */

    firstCluster = ((unsigned) (secNo - pv->firstFATsecNo) * (SECTOR_SIZE / 2));
    iSec  = pv->firstDataSecNo + 
            (((SectorNo)(firstCluster - (unsigned)2)) * pv->clusterSize);

    /* Find if any clusters were logically deleted, and if so, delete them */

    for (offset = 0;  offset < SECTOR_SIZE;  offset += 2, iSec += pv->clusterSize) {

        oldFATentry = LE2( *(LEushort FAR0 *)(oldFAT + offset) );
        newFATentry = LE2( *(LEushort FAR1 *)(newFAT + offset) );

#endif /* FAT_12BIT */

        if ((oldFATentry != FAT_FREE) && (newFATentry == FAT_FREE)) {

            ioreq.irHandle      = pv->handle;
            ioreq.irSectorNo    = iSec;
            ioreq.irSectorCount = pv->clusterSize;
            checkStatus( flAbsDelete(&ioreq) );
        }
    }

    return flOK;
}

#endif /* FL_INCLUDE_FAT_MONITOR */




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   f f C h e c k B e f o r e W r i t e                       *
 *                                                                             *
 *  Catch all the FAT updates. Detect disk partitioning operation, track it    *
 *  to completion, re-read partition tables, and re-install FAT filters on     *
 *  all FAT12/16 partitions.                                                   *
 *                                                                             *
 *  Parameters:                                                                *
 *      ioreq              : standard I/O request to be checked                   *
 *                                                                             *
 *  Returns:                                                                   *
 *      flOK on success, otherwise error code                                  *
 *                                                                             *
 * --------------------------------------------------------------------------- */

FLStatus  ffCheckBeforeWrite ( IOreq FAR2 * ioreq )
{
    int         socNo, diskNo;
    FLffDisk  * pd;
    FLffVol   * pv;
    long          iSec;
    int         iPart;
    IOreq       ioreq2;
    char FAR1 * usrBuf;

    /* if module hasn't been reset yet, do it now */

    if (resetDone == FALSE)
        (void) reset();

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(ioreq->irHandle);
    diskNo = H2D(ioreq->irHandle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* if disk structure hasn't been allocated yet, do it now */

    if (ffDisk[socNo][diskNo] == NULL)
        checkStatus( newDisk((int)ioreq->irHandle) );

    pd = ffDisk[socNo][diskNo];

    /* read partition table(s) and install FAT filters is needed */

    if (pd->ffstate == flStateNotInitialized)
        checkStatus( parseDisk((int)ioreq->irHandle) );

    /* catch writes to MBR, and track the whole disk partitioning operations */

    while( isPartTableWrite(pd, ioreq) == TRUE ) {

        /* disk re-partitioning is in progress */

        if( pd->secToWatch == (SectorNo)0 ) {

            /* it's write to MBR, so trash BPBs in all disk's partitions */

            if (pd->parts > 0) {

                for (iPart = 0;  iPart < pd->parts;  iPart++) {

                    ioreq2.irHandle      = ioreq->irHandle;
                    ioreq2.irSectorNo    = (pd->part[iPart])->startSecNo;
                    ioreq2.irSectorCount = (SectorNo) 1;
                    ioreq2.irData        = (void FAR1 *) zeroes;
                    (void) flAbsWrite(&ioreq2);
        }
        }
        }

        /* keep FAT filters disabled while disk partitioning is in progress */

        pd->ffstate = flStateInitInProgress;

        /* partition table which is about to be written to disk */

        usrBuf = FLBUF( ioreq, (pd->secToWatch - ioreq->irSectorNo) );

        switch( isExtPartPresent(usrBuf, &(pd->secToWatch)) ) {

            case flOK: 

                /* 
                 * Found valid partition table with extended partition.
                 * The pd->secToWatch has been updated to point to the
                 * sector where next partition table will be written to. 
                 */
                continue;

            case flFileNotFound:

                /* 
                 * Valid partition table, but no extended partition in it. 
                 * Partitioning has been completed. Set pd->ffstate to 
                 * 'flStateNotInitialized' to initiate parsing of partition
                 * table(s) and FAT filter installation next time this routine
                 * is called. 
                 */

                pd->ffstate = flStateNotInitialized;
                break;

            case flBadFormat:
        default:

                /* No valid partition table. */

                break;
        }

        return flOK;
    }

#ifdef FL_INCLUDE_FAT_MONITOR

    /* check for FAT update */

    if (pd->ffstate == flStateInitialized) {

        /* NOTE: We can handle 'write' request that spans disk partition boundaries */

        for (iSec = ioreq->irSectorNo; 
             iSec < (ioreq->irSectorNo + ioreq->irSectorCount); iSec++) {

            for (iPart = 0; iPart < pd->parts; iPart++) {

                pv = pd->part[iPart];

                /* we monitor only FAT12/16 partitions */

                if ((pv->type != FAT12_PARTIT) && (pv->type != FAT16_PARTIT) && 
                                                  (pv->type != DOS4_PARTIT))
            continue;

                /* FAT filters can be disabled on individual partitions */

                if (pv->ffEnabled != TRUE)
                    continue;

                if ((iSec >= (long)pv->firstFATsecNo) && (iSec <= (long)pv->lastFATsecNo)) {

                    /* compare new and old contents of FAT sectors(s) */

                    usrBuf = FLBUF( ioreq, (iSec - ioreq->irSectorNo) );

                    checkStatus( partFreeDelClusters(pv, iSec, usrBuf) ); 
            }
            }
        }
    }

#endif /* FL_INCLUDE_FAT_MONITOR */

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   f l f f C o n t r o l                                     *
 *                                                                             * 
 *  Enable/disable/install FAT filters. See comments inside the routine for    * 
 *  the list of supported operations.                                          * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    handle         : TFFS handle                                          * 
 *      partNo             : partition # (0 .. FL_MAX_PARTS_PER_DISK)             * 
 *      state              : see list of supported operations below               * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 * --------------------------------------------------------------------------- *
 *                                                                             *
 *  The following FAT monitor control requests are supported:                  *
 *                                                                             *
 *      state  : flStateNotInitialized                                         *
 *      partNo : [0 ... pd->parts-1]                                           *
 *      action : turn off FAT monitor on specified partition                   *
 *                                                                             *
 *      state  : flStateNotInitialized                                         *
 *      partNo : < 0                                                           *
 *      action : turn off FAT monitor on all partitions                        *
 *                                                                             *
 *      state  : flStateInitialized                                            *
 *      partNo : [0 ... pd->parts-1]                                           *
 *      action : if FAT monitor has been installed on specified partition,     *
 *               turn it on                                                    *
 *                                                                             *
 *      state  : flStateInitInProgress                                         *
 *      partNo : ignored                                                       *
 *      action : re-read partition table(s), and install FAT filters on all    *
 *               partitions                                                    *
 *                                                                             *
 * --------------------------------------------------------------------------- */

FLStatus  flffControl ( int      handle,
                        int      partNo, 
                        FLState  state )
{
    int        socNo, diskNo;
    FLffDisk * pd;
    int        i;
    FLStatus   status;

    /* if module hasn't been reset yet, do it now */

    if (resetDone == FALSE)
        (void) reset();

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* if disk structure hasn't been allocated yet, do it now */

    if (ffDisk[socNo][diskNo] == NULL)
        checkStatus( newDisk(handle) );

    pd = ffDisk[socNo][diskNo];

    /* abort if disk re-partitioning is in progress */

    if (pd->ffstate == flStateInitInProgress)
        return flDriveNotReady;

    /* read partition table(s) and install FAT filters is needed */

    if (pd->ffstate == flStateNotInitialized) {

        if (state == flStateNotInitialized)
          return flOK;

        checkStatus( parseDisk(handle) );
    }

    /* check 'partNo' arguement for sanity */
 
    if ((partNo >= pd->parts) || (partNo >= FL_MAX_PARTS_PER_DISK))
        return flBadDriveHandle;

    /* do requested operation */

    status = flBadParameter;

    switch (state) {

        case flStateInitInProgress: 

            /* read partition table(s), install FAT filters on all partitions */

        pd->ffstate = flStateNotInitialized; 
            status = parseDisk(handle);
            break;

        case flStateNotInitialized:         

            /* turn off FAT monitor */

        if (partNo < 0) {                      /* all partitions */

            for (i = 0; i < FL_MAX_PARTS_PER_DISK; i++) {

            if (pd->part[i] != NULL)
                    (pd->part[i])->ffEnabled = FALSE;
        }
        }
        else {                                 /* specified partition */

        if (pd->part[partNo] != NULL)
                (pd->part[partNo])->ffEnabled = FALSE;
        }
            status = flOK;
            break;

#ifdef FL_INCLUDE_FAT_MONITOR

        case flStateInitialized:            

            /* turn on FAT monitor */

        if ((pd->ffstate == flStateInitialized) && (partNo >= 0)) {

            if (pd->part[partNo] != NULL) {

                switch( (pd->part[partNo])->type ) {

                        case FAT12_PARTIT:
                    case FAT16_PARTIT:
                    case DOS4_PARTIT:
                        (pd->part[partNo])->ffEnabled = TRUE;
                            status = flOK;
                            break;

            case FL_RAW_PART:
                            DEBUG_PRINT(("Debug: can't ctrl non-existent partition.\r\n"));
                            break;

            default:
                            DEBUG_PRINT(("Debug: can't ctrl non-FAT12/16 partition.\r\n"));
                            break;
            }
        }
        }
            break;

#endif /* FL_INCLUDE_FAT_MONITOR */

    }  /* switch(state) */ 

    return status;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   f l f f I n f o                                           *
 *                                                                             * 
 *  Obtain complete partition info for specified disk.                         *
 *                                                                             * 
 *  Parameters:                                                                * 
 *    handle         : TFFS handle                                          * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      NULL if error, otherwise pointer to partitioning info                  * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

FLffDisk * flffInfo ( int  handle )
{
    int        socNo, diskNo;
    FLffDisk * pd;

    /* if module hasn't been reset yet, do it now */

    if (resetDone == FALSE)
        (void) reset();

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return NULL;

    /* if disk structure hasn't been allocated yet, do it now */

    if (ffDisk[socNo][diskNo] == NULL) {

        if( newDisk(handle) != flOK )
        return NULL;
    }

    pd = ffDisk[socNo][diskNo];

    /* read partition table(s) and install FAT filters is needed */

    if (pd->ffstate == flStateNotInitialized) {

        if( parseDisk(handle) != flOK )
            return NULL;
    }

    return pd;
}




#endif /* ABS_READ_WRITE && FL_READ_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flchkdef.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/flchkdef.h_V  $
 * 
 *    Rev 1.12   Apr 15 2002 07:36:30   oris
 * Moved binary module definitions from mtdsa.h. 
 * Changed automatic definition of missing compilation flags to error massages.
 * 
 *    Rev 1.11   Feb 19 2002 20:59:36   oris
 * Added check for  TL_LEAVE_BINARY_AREA and FL_LEAVE_BINARY_AREA compatibility.
 * 
 *    Rev 1.10   Jan 29 2002 20:08:18   oris
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * 
 *    Rev 1.9   Jan 23 2002 23:31:26   oris
 * Added prevention of multiple include directives.
 * 
 *    Rev 1.8   Jan 17 2002 23:00:56   oris
 * Changed TrueFFSVersion to "5100"
 * Made sure FL_FAR_MALLOC exists
 * Made sure MTD_RECONSTRUCT_BBT is defined if FORMAT_VOLUME is defined.
 * Made sure QUICK_MOUNT_FEATURE is defined
 * 
 *    Rev 1.7   Nov 20 2001 20:25:08   oris
 * Changed TrueFFS version to "5040". This version is written by the format routine on the media header.
 * 
 *    Rev 1.6   Jul 15 2001 20:44:56   oris
 * Changed default DFORMAT_PRINT from nothing to DEBUG_PRINT in order to remove warrnings.
 * 
 *    Rev 1.5   Jul 13 2001 01:04:20   oris
 * Added definition check for DFORMAT_PRINT,FL_FOPEN , FL_FCLOSE, FL_FPRINTF macros.
 * 
 *    Rev 1.4   May 16 2001 21:18:14   oris
 * Added backwards compatibility check for FL_MALLOC the new definition replacing MALLOC.
 * 
 *    Rev 1.3   Apr 01 2001 07:52:06   oris
 * copywrite notice.
 * Alligned left all # directives.
 * 
 *    Rev 1.2   Feb 13 2001 02:19:44   oris
 * Added TrueFFSVersion (internal version label) define.
 *
 *    Rev 1.1   Feb 07 2001 18:55:44   oris
 * Added check if LOW_LEVEL is not defined before defining it in Validity check for LOW_LEVEL
 *
 *    Rev 1.0   Feb 05 2001 18:41:14   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/************************/
/* TrueFFS source files */
/* -------------------- */
/************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : flchkdef.h                                                          *
*                                                                            *
* Description : Sanity check for flcustom.h files.                           *
*                                                                            *
*****************************************************************************/

#ifndef _FL_CHK_DEFS_H_
#define _FL_CHK_DEFS_H_


/* Osak version
 *
 * Number written on the flash by INFTL format specifing the OSAK version
 * The media was formated with. the number bellow specifies version
 * 5.1.0.0
 */

#define TrueFFSVersion "5100"           /* Internal TrueFFS version number */

/*******************************************/
/* Validity check and overlapping defines  */
/*******************************************/

/* The TL uses a diffrent defintion from the one the public interface uses 
 * but when format parameters are sent to the TL no convertion is made. 
 * the result is that both definitions must be the same.
 */

#if (defined(TL_LEAVE_BINARY_AREA) && defined(FL_LEAVE_BINARY_AREA))
#if TL_LEAVE_BINARY_AREA != FL_LEAVE_BINARY_AREA
#error "FL_LEAVE_BINARY_AREA and FL_LEAVE_BINARY_AREA must have the same value"
#endif
#endif /* TL_LEAVE_BINARY_AREA && FL_LEAVE_BINARY_AREA */

/* Validiy check for FL_LOW_LEVEL compilation flag.
 *
 * Starting from TrueFFS 5.1 the LOW_LEVEL was changed to FL_LOW_LEVEL
 * The reason was that it clashed with Windows NT LOW_LEVEL macro.
 */

#ifndef FL_LOW_LEVEL
#ifdef LOW_LEVEL
#define FL_LOW_LEVEL
#endif /* LOW_LEVEL */
#endif /* FL_LOW_LEVEL */


/* Validiy check for FL_MALLOC and FL_FREE macroes
 *
 * Starting from TrueFFS 5.0 the FREE and MALLOC macroes were
 * changed to FL_MALLOC and FL_FREE in order to avoid name clashes.
 * In order to keep backwards compatibility with previous flsystem.h
 * files the following new defintions checks were added.
 * if your system uses the FREE and MALLOC defintion simply comment
 * them out and customized the FL_MALLOC and FL_FREE macroes in your
 * flsystem.h file.
 */

#if (defined(MALLOC) && !defined(FL_MALLOC))
#define FL_MALLOC MALLOC
#endif /* MALLOC && ! FL_MALLOC */
#if (defined(FREE) && !defined(FL_FREE))
#define FL_FREE   FREE
#endif /* FREE && ! FL_FREE */

/* Validity check for FL_FAR_MALLOC and FL_FAR_FREE
 * Due to the BIOS driver memory limitations a dedicated routine 
 * is used for allocating the large ram arrays.
 */

#if (defined(FL_MALLOC) && !defined(FL_FAR_MALLOC))
#define FL_FAR_MALLOC FL_MALLOC 
#endif /* FL_MALLOC && ! FL_FAR_MALLOC */

#if (defined(FL_FREE) && !defined(FL_FAR_FREE))
#define FL_FAR_FREE FL_FREE 
#endif /* FL_MALLOC && ! FL_FAR_MALLOC */

/* Validity check for BDK_ACCESS */

#if (defined (WRITE_EXB_IMAGE) && !defined (BDK_ACCESS))
#error "Please make sure BDK_ACCESS is defined in your flcustom.h file\r\n"
#endif

/* The format option needs some internal defintions */

#ifdef FORMAT_VOLUME
#ifndef MTD_RECONSTRUCT_BBT
#define MTD_RECONSTRUCT_BBT /* Compile code to scan virgin cards for BBT */
#endif /* MTD_RECONSTRUCT_BBT */
#endif /* FORMAT_VOLUME */


/*
 * Make sure TrueFFS has all the neccesary definition for the
 * Binary partition module.
 */

#ifdef  BDK_ACCESS
#define ACCESS_BDK_IMAGE    /* Compile the Binary read routines          */
#ifndef FL_READ_ONLY
#define UPDATE_BDK_IMAGE    /* Compile the Binary write routines         */
#define ERASE_BDK_IMAGE     /* Compile the Binary erase routine          */
#define CREATE_BDK_IMAGE    /* Compile the Binary create routine         */
#endif /* FL_READ_ONLY */
#ifdef  HW_PROTECTION
#define PROTECT_BDK_IMAGE /* Compile the Binary protection routines  */
#endif /* HW_PROTECTION */
#endif /* BDK_ACCESS */

/* Validity check for system files MACROES */
#ifndef DFORMAT_PRINT
#define DFORMAT_PRINT DEBUG_PRINT
#endif /* DFORMAT_PRINT */
#ifndef FL_FOPEN
#define FL_FOPEN
#endif /* FL_FOPEN */
#ifndef FL_FCLOSE
#define FL_FCLOSE
#endif /* FL_FCLOSE */
#ifndef FL_FPRINTF
#define FL_FPRINTF
#endif /* FL_FPRINTF */

/* Validity check of DRIVES , VOLUMES and SOCKETS parameters.
 * Note that DRIVES definition was left for abckwards compatibility
 */

#if (defined(DRIVES) && (defined(SOCKETS) || defined(VOLUMES)))
#error "Drives is permited only as long as SOCKETS and VOLUMES are not defined"
#else
#ifdef DRIVES
#define SOCKETS DRIVES
#define VOLUMES DRIVES
#else
#if (!defined(VOLUMES) && !defined(SOCKETS))
#error "Neither DRIVER, VOLUMES and SOCKETS are defined"
#else
#if (!defined(VOLUMES) && defined(SOCKETS))
#define VOLUMES SOCKETS /* both VOLUMES and SOCKETS must be defined */
#else
#if !defined(SOCKETS) && defined(VOLUMES)
#define SOCKETS VOLUMES /* both VOLUMES and SOCKETS must be defined */
#else
#if (SOCKETS>VOLUMES)
#error "SOCKETS should not be bigger then VOLUMES"
#endif /*   SOCKETS >    VOLUMES */
#endif /* ! SOCKETS &&   VOLUMES */
#endif /*   SOCKETS && ! VOLUMES */
#endif /* ! SOCKETS && ! VOLUMES */
#endif /*         DRIVES         */
#endif /* DRIVES && (SOCKETS || VOLUMES) */

/*****************************/
/* M-Systems forced defaults */
/*****************************/

/* Since TrueFFS 5.1 Quick mount is a default for all INFTL formated devices */

#define QUICK_MOUNT_FEATURE

/* Some S/W modules like boot SDK  do not need the read bad blocks tables routine.
 * However for TrueFFS these defintion is vital
 */
#define MTD_READ_BBT        /* Compile the read BBT routine code         */

#endif /* _FL_CHK_DEFS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\fatlite.c ===
/*!!*/
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FATLITE.C_V  $
 * 
 *    Rev 1.10   Jan 17 2002 23:00:28   oris
 * Removed SINGLE_BUFFER ifdef.
 * Changed debug print added \r.
 * Removed warnings.
 * 
 *    Rev 1.9   Nov 16 2001 00:26:46   oris
 * Removed warnings.
 * 
 *    Rev 1.8   Nov 08 2001 10:45:28   oris
 * Removed warnings.
 * 
 *    Rev 1.7   May 16 2001 21:17:30   oris
 * Added the FL_ prefix to the following defines: ON, OFF
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.6   Apr 18 2001 09:31:02   oris
 * added new line at the end of the file.
 * 
 *    Rev 1.5   Apr 16 2001 10:42:16   vadimk
 * Emty file bug was fixed ( we should not allocate cluster for an empty file )
 *
 *    Rev 1.4   Apr 09 2001 15:07:10   oris
 * End with an empty line.
 *
 *    Rev 1.3   Apr 03 2001 14:42:02   oris
 * Bug fix - 64 sectors in directory return flInvalidFatChain.
 *
 *    Rev 1.2   Apr 01 2001 08:02:46   oris
 * copywrite notice.
 *
 *    Rev 1.1   Feb 12 2001 12:16:42   oris
 * Changed mutexs for TrueFFS 5.0
 *
 *    Rev 1.0   Feb 04 2001 11:02:28   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#include "bddefs.h"
#include "blockdev.h"
#include "dosformt.h"

#if defined(FILES) && FILES>0

File        fileTable[FILES];       /* the file table */

#define directory ((DirectoryEntry *) vol.volBuffer.flData)

FLStatus closeFile(File *file);       /* forward */
FLStatus flushBuffer(Volume vol);       /* forward */

/*----------------------------------------------------------------------*/
/*                    d i s m o u n t V o l u m e                     */
/*                                                               */
/* Closing all files.                            */
/*                                                               */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus dismountFS(Volume vol,FLStatus status)
{
  int i;
#ifndef FL_READ_ONLY
  if (status == flOK)
    checkStatus(flushBuffer(&vol));
#endif
       /* Close or discard all files and make them available */
  for (i = 0; i < FILES; i++)
    if (fileTable[i].fileVol == &vol)
      if (vol.flags & VOLUME_MOUNTED)
       closeFile(&fileTable[i]);
      else
       fileTable[i].flags = 0;

  vol.volBuffer.sectorNo = UNASSIGNED_SECTOR;       /* Current sector no. (none) */
  vol.volBuffer.dirty = vol.volBuffer.checkPoint = FALSE;
  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                       f l u s h B u f f e r                            */
/*                                                               */
/* Writes the buffer contents if it is dirty.                           */
/*                                                               */
/* If this is a FAT sector, all FAT copies are written.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus flushBuffer(Volume vol)
{
  if (vol.volBuffer.dirty) {
    FLStatus status;
    unsigned i;
    Volume *bufferOwner = &vol;

    status = (*bufferOwner).tl.writeSector((*bufferOwner).tl.rec, vol.volBuffer.sectorNo,
                                      vol.volBuffer.flData);
    if (status == flOK) {
      if (vol.volBuffer.sectorNo >= (*bufferOwner).firstFATSectorNo &&
         vol.volBuffer.sectorNo < (*bufferOwner).secondFATSectorNo)
       for (i = 1; i < (*bufferOwner).numberOfFATS; i++)
         checkStatus((*bufferOwner).tl.writeSector((*bufferOwner).tl.rec,
                                              vol.volBuffer.sectorNo + i * (*bufferOwner).sectorsPerFAT,
                                              vol.volBuffer.flData));
    }
    else
      vol.volBuffer.sectorNo = UNASSIGNED_SECTOR;

    vol.volBuffer.dirty = vol.volBuffer.checkPoint = FALSE;

    return status;
  }
  else
    return flOK;
}


/*----------------------------------------------------------------------*/
/*                      u p d a t e S e c t o r                            */
/*                                                               */
/* Prepares a sector for update in the buffer                            */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       sectorNo       : Sector no. to read                            */
/*       read              : Whether to initialize buffer by reading, or       */
/*                        clearing                                   */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus updateSector(Volume vol, SectorNo sectorNo, FLBoolean read)
{
  if (sectorNo != vol.volBuffer.sectorNo || &vol != vol.volBuffer.owner) {
    const void FAR0 *mappedSector;

    checkStatus(flushBuffer(&vol));
    vol.volBuffer.sectorNo = sectorNo;
    vol.volBuffer.owner = &vol;
    if (read) {
      mappedSector = vol.tl.mapSector(vol.tl.rec,sectorNo,NULL);
      if (mappedSector) {
        if(mappedSector==dataErrorToken)
          return flDataError;
       tffscpy(vol.volBuffer.flData,mappedSector,SECTOR_SIZE);
      }
      else
       return flSectorNotFound;
    }
    else
      tffsset(vol.volBuffer.flData,0,SECTOR_SIZE);
  }

  vol.volBuffer.dirty = TRUE;

  return flOK;
}

#endif /* FL_READ_ONLY   */
/*----------------------------------------------------------------------*/
/*                 f i r s t S e c t o r O f C l u s t e r              */
/*                                                               */
/* Get sector no. corresponding to cluster no.                            */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       cluster              : Cluster no.                                   */
/*                                                                      */
/* Returns:                                                             */
/*       first sector no. of cluster                                   */
/*----------------------------------------------------------------------*/

static SectorNo firstSectorOfCluster(Volume vol, unsigned cluster)
{
  return (SectorNo) (cluster - 2) * vol.sectorsPerCluster +
        vol.firstDataSectorNo;
}


/*----------------------------------------------------------------------*/
/*                     g e t D i r E n t r y                         */
/*                                                               */
/* Get a read-only copy of a directory entry.                            */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : File belonging to directory entry              */
/*                                                                      */
/* Returns:                                                             */
/*       dirEntry       : Pointer to directory entry                     */
/*----------------------------------------------------------------------*/

static const DirectoryEntry FAR0 *getDirEntry(File *file)
{
  return (DirectoryEntry FAR0 *) findSector(file->fileVol,file->directorySector) +
        file->directoryIndex;
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                g e t D i r E n t r y F o r U p d a t e              */
/*                                                               */
/* Read a directory sector into the sector buffer and point to an       */
/* entry, with the intention of modifying it.                            */
/* The buffer will be flushed on operation exit.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : File belonging to directory entry              */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*       dirEntry       : Pointer to directory entry in buffer              */
/*----------------------------------------------------------------------*/

static FLStatus getDirEntryForUpdate(File *file, DirectoryEntry * *dirEntry)
{
  Volume vol = file->fileVol;

  checkStatus(updateSector(file->fileVol,file->directorySector,TRUE));
  *dirEntry = directory + file->directoryIndex;
  vol.volBuffer.checkPoint = TRUE;

  return flOK;
}

#endif  /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*                s e t C u r r e n t D a t e T i m e                   */
/*                                                               */
/* Set current time/date in directory entry                             */
/*                                                                      */
/* Parameters:                                                          */
/*       dirEntry       : Pointer to directory entry                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setCurrentDateTime(DirectoryEntry *dirEntry)
{
  toLE2(dirEntry->updateTime,flCurrentTime());
  toLE2(dirEntry->updateDate,flCurrentDate());
}


/*----------------------------------------------------------------------*/
/*                      g e t F A T e n t r y                            */
/*                                                               */
/* Get an entry from the FAT. The 1st FAT copy is used.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       cluster              : Cluster no. of enrty.                            */
/*                                                                      */
/* Returns:                                                             */
/*       Value of FAT entry.                                          */
/*----------------------------------------------------------------------*/

static FLStatus getFATentry(Volume vol, unsigned* entry)
{
  unsigned cluster = *entry;
  LEushort FAR0 *fat16Sector;

  unsigned fatSectorNo = vol.firstFATSectorNo;
#ifdef FAT_12BIT
  if (vol.flags & VOLUME_12BIT_FAT)
    fatSectorNo += (cluster * 3) >> (SECTOR_SIZE_BITS + 1);
  else
#endif
    fatSectorNo += cluster >> (SECTOR_SIZE_BITS - 1);
#ifndef FL_READ_ONLY
  if (!vol.volBuffer.dirty) {
    /* If the buffer is free, use it to store this FAT sector */
    checkStatus(updateSector(&vol,fatSectorNo,TRUE));
    vol.volBuffer.dirty = FALSE;
  }

#endif /* FL_READ_ONLY */
  fat16Sector = (LEushort FAR0 *) findSector(&vol,fatSectorNo);

  if(fat16Sector==NULL)
    return flSectorNotFound;

  if(fat16Sector==dataErrorToken)
    return flDataError;

#ifdef FAT_12BIT
  if (vol.flags & VOLUME_12BIT_FAT) {
    unsigned char FAR0 *fat12Sector = (unsigned char FAR0 *) fat16Sector;
    unsigned halfByteOffset = (cluster * 3) & (SECTOR_SIZE * 2 - 1);
    unsigned char firstByte = fat12Sector[halfByteOffset / 2];
    halfByteOffset += 2;
    if (halfByteOffset >= SECTOR_SIZE * 2) {
      /* Entry continues on the next sector. What a mess */
      halfByteOffset -= SECTOR_SIZE * 2;
      fat12Sector = (unsigned char FAR0 *) findSector(&vol,fatSectorNo + 1);
      if(fat12Sector==NULL)
        return flSectorNotFound;

      if(fat12Sector==dataErrorToken)
        return flDataError;
    }
    if (halfByteOffset & 1)
      *entry = ((firstByte & 0xf0) >> 4) + (fat12Sector[halfByteOffset / 2] << 4);
    else
      *entry = firstByte + ((fat12Sector[halfByteOffset / 2] & 0xf) << 8);

    if (*entry == 0xfff)    /* in 12-bit fat, 0xfff marks the last cluster */
      *entry = FAT_LAST_CLUSTER; /* return 0xffff instead */
    return flOK;
  }
  else {
#endif
    *entry = LE2(fat16Sector[cluster & (SECTOR_SIZE / 2 - 1)]);
    return flOK;
#ifdef FAT_12BIT
  }
#endif
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                       s e t F A T e n t r y                            */
/*                                                               */
/* Writes a new value to a given FAT cluster entry.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       cluster              : Cluster no. of enrty.                            */
/*       entry              : New value of FAT entry.                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus setFATentry(Volume vol, unsigned cluster, unsigned entry)
{
  LEushort *fat16Sector;

  unsigned fatSectorNo = vol.firstFATSectorNo;
#ifdef FAT_12BIT
  if (vol.flags & VOLUME_12BIT_FAT)
    fatSectorNo += (cluster * 3) >> (SECTOR_SIZE_BITS + 1);
  else
#endif
    fatSectorNo += cluster >> (SECTOR_SIZE_BITS - 1);

  checkStatus(updateSector(&vol,fatSectorNo,TRUE));
  fat16Sector = (LEushort *) vol.volBuffer.flData;

#ifdef FAT_12BIT
  if (vol.flags & VOLUME_12BIT_FAT) {
    unsigned char *fat12Sector = (unsigned char *) vol.volBuffer.flData;
    unsigned halfByteOffset = (cluster * 3) & (SECTOR_SIZE * 2 - 1);
    if (halfByteOffset & 1) {
      fat12Sector[halfByteOffset / 2] &= 0xf;
      fat12Sector[halfByteOffset / 2] |= (entry & 0xf) << 4;
    }
    else
      fat12Sector[halfByteOffset / 2] = entry;
    halfByteOffset += 2;
    if (halfByteOffset >= SECTOR_SIZE * 2) {
      /* Entry continues on the next sector. What a mess */
      halfByteOffset -= SECTOR_SIZE * 2;
      fatSectorNo++;
      checkStatus(updateSector(&vol,fatSectorNo,TRUE));
    }
    if (halfByteOffset & 1)
      fat12Sector[halfByteOffset / 2] = entry >> 4;
    else {
      fat12Sector[halfByteOffset / 2] &= 0xf0;
      fat12Sector[halfByteOffset / 2] |= (entry & 0x0f00) >> 8;
    }
  }
  else
#endif
    toLE2(fat16Sector[cluster & (SECTOR_SIZE / 2 - 1)],entry);

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                      a l l o c a t e C l u s t e r                     */
/*                                                               */
/* Allocates a new cluster for a file and adds it to a FAT chain or     */
/* marks it in a directory entry.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : File to extend. It should be positioned at    */
/*                       end-of-file.                                   */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus allocateCluster(File *file)
{
  Volume vol = file->fileVol;
  unsigned originalRover;
  unsigned fatEntry;

  if (file->flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  /* Look for a free cluster. Start at the allocation rover */
  originalRover = vol.allocationRover;

  do {
    vol.allocationRover++;
    if (vol.allocationRover > vol.maxCluster)
      vol.allocationRover = 2;       /* wraparound to start of volume */
    if (vol.allocationRover == originalRover)
      return flNoSpaceInVolume;
    fatEntry = vol.allocationRover;
    checkStatus(getFATentry(&vol,&fatEntry));
  } while ( fatEntry!= FAT_FREE);

  /* Found a free cluster. Mark it as an end of chain */
  checkStatus(setFATentry(&vol,vol.allocationRover,FAT_LAST_CLUSTER));

  /* Mark previous cluster or directory to point to it */
  if (file->currentCluster == 0) {
    DirectoryEntry *dirEntry;
    checkStatus(getDirEntryForUpdate(file,&dirEntry));

    toLE2(dirEntry->startingCluster,vol.allocationRover);
    setCurrentDateTime(dirEntry);
  }
  else
    checkStatus(setFATentry(&vol,file->currentCluster,vol.allocationRover));

  /* Set our new current cluster */
  file->currentCluster = vol.allocationRover;

  return flOK;
}

#endif /* FL_READ_ONLY  */
/*----------------------------------------------------------------------*/
/*                   g e t S e c t o r A n d O f f s e t              */
/*                                                               */
/* Based on the current position of a file, gets a sector number and    */
/* offset in the sector that marks the file's current position.              */
/* If the position is at the end-of-file, and the file is opened for    */
/* write, this routine will extend the file by allocating a new cluster.*/
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus getSectorAndOffset(File *file,
                             SectorNo *sectorNo,
                             unsigned *offsetInSector)
{
  Volume vol = file->fileVol;
  unsigned offsetInCluster =
             (unsigned) file->currentPosition & (vol.bytesPerCluster - 1);

  if (file->flags & FILE_IS_ROOT_DIR) {
    if (file->currentPosition >= file->fileSize)
      return flRootDirectoryFull;
  }

  if (offsetInCluster == 0) {       /* This cluster is finished. Get next */
    if (!(file->flags & FILE_IS_ROOT_DIR)) {
      if (((file->currentPosition >= file->fileSize) && (file->currentPosition>0))||((file->fileSize==0)&&!(file->flags & FILE_IS_DIRECTORY))) {
#ifndef FL_READ_ONLY
        checkStatus(allocateCluster(file));
#else
        return flSectorNotFound;
#endif
      }
      else {
        unsigned nextCluster;
        if (file->currentCluster == 0) {
          const DirectoryEntry FAR0 *dirEntry;
          dirEntry = getDirEntry(file);
          if(dirEntry==NULL)
            return flSectorNotFound;
          if(dirEntry==dataErrorToken)
            return flDataError;
          nextCluster = LE2(dirEntry->startingCluster);
        }
       else {
          nextCluster = file->currentCluster;
          checkStatus(getFATentry(&vol,&nextCluster));
        }
        if (nextCluster < 2 || nextCluster > vol.maxCluster)
          /* We have a bad file size, or the FAT is bad */
          return flInvalidFATchain;
        file->currentCluster = nextCluster;
      }
    }
  }

  *offsetInSector = offsetInCluster & (SECTOR_SIZE - 1);
  if (file->flags & FILE_IS_ROOT_DIR)
    *sectorNo = vol.rootDirectorySectorNo +
                  (SectorNo) (file->currentPosition >> SECTOR_SIZE_BITS);
  else
    *sectorNo = firstSectorOfCluster(&vol,file->currentCluster) +
                  (SectorNo) (offsetInCluster >> SECTOR_SIZE_BITS);

  return flOK;
}




/*----------------------------------------------------------------------*/
/*                      c l o s e F i l e                            */
/*                                                               */
/* Closes an open file, records file size and dates in directory and    */
/* releases file handle.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : File to close.                              */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus closeFile(File *file)
{
#ifndef FL_READ_ONLY
  if ((file->flags & FILE_MODIFIED) && !(file->flags & FILE_IS_ROOT_DIR)) {
    DirectoryEntry *dirEntry;
    checkStatus(getDirEntryForUpdate(file,&dirEntry));

    dirEntry->attributes |= ATTR_ARCHIVE;
    if (!(file->flags & FILE_IS_DIRECTORY))
      toLE4(dirEntry->fileSize,file->fileSize);
    setCurrentDateTime(dirEntry);
  }
#endif
  file->flags = 0;              /* no longer open */

  return flOK;
}

#ifndef FL_READ_ONLY
#ifdef SUB_DIRECTORY

/*----------------------------------------------------------------------*/
/*                      e x t e n d D i r e c t o r y                     */
/*                                                               */
/* Extends a directory, writing empty entries and the mandatory '.' and */
/* '..' entries.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : Directory file to extend. On entry,               */
/*                       currentPosition == fileSize. On exit, fileSize*/
/*                       is updated.                                   */
/*       ownerDir       : Cluster no. of owner directory              */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus extendDirectory(File *file, unsigned ownerDir)
{
  Volume vol = file->fileVol;
  unsigned i;
  SectorNo sectorOfDir;
  unsigned offsetInSector;

  /* Assuming the current position is at the end-of-file, this will     */
  /* extend the directory.                                          */
  checkStatus(getSectorAndOffset(file,&sectorOfDir,&offsetInSector));

  for (i = 0; i < vol.sectorsPerCluster; i++) {
    /* Write binary zeroes to indicate never-used entries */
    checkStatus(updateSector(&vol,sectorOfDir + i,FALSE));
    vol.volBuffer.checkPoint = TRUE;
    if (file->currentPosition == 0 && i == 0) {
      /* Add the mandatory . and .. entries */
      tffscpy(directory[0].name,".          ",sizeof directory[0].name);
      directory[0].attributes = ATTR_ARCHIVE | ATTR_DIRECTORY;
      toLE2(directory[0].startingCluster,file->currentCluster);
      toLE4(directory[0].fileSize,0);
      setCurrentDateTime(&directory[0]);
      tffscpy(&directory[1],&directory[0],sizeof directory[0]);
      directory[1].name[1] = '.';       /* change . to .. */
      toLE2(directory[1].startingCluster,ownerDir);
    }
    file->fileSize += SECTOR_SIZE;
  }
  /* Update the parent directory by closing the file */
  file->flags |= FILE_MODIFIED;
  return closeFile(file);
}

#endif       /* SUB_DIRECTORY */
#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                      f i n d D i r E n t r y                            */
/*                                                               */
/* Finds a directory entry by path-name, or finds an available directory*/
/* entry if the file does not exist.                                   */
/* Most fields necessary for opening a file are set by this routine.       */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       path              : path to find                                   */
/*      file            : File in which to record directory information.*/
/*                        Specific fields on entry:                     */
/*                         flags: if FILE_MUST_OPEN = 1, directory        */
/*                               will be extended if necessary.       */
/*                       on exit:                                   */
/*                         flags: FILE_IS_DIRECTORY and                   */
/*                               FILE_IS_ROOT_DIR set if true.       */
/*                         fileSize: Set for non-directory files.         */
/*                          currentCluster: Set to 0 (unknown)              */
/*                         ownerDirCluster: Set to 1st cluster of      */
/*                                  owning directory.                     */
/*                         directorySector: Sector of directory. If 0  */
/*                                  entry not found and directory full*/
/*                         directoryEntry: Entry # in directory sector */
/*                         currentPosition: not set by this routine.   */
/*                                                               */
/* Returns:                                                             */
/*       FLStatus       : 0 on success and file found                     */
/*                       flFileNotFound on success and file not found       */
/*                       otherwise failed.                            */
/*----------------------------------------------------------------------*/

static FLStatus findDirEntry(Volume vol, FLSimplePath FAR1 *path, File *file)
{
  File scanFile;              /* Internal file of search */
  unsigned dirBackPointer = 0;       /* 1st cluster of previous directory */

  FLStatus status = flOK;              /* root directory exists */

  file->flags |= (FILE_IS_ROOT_DIR | FILE_IS_DIRECTORY);
  file->fileSize = (long) (vol.sectorsInRootDirectory) << SECTOR_SIZE_BITS;
  file->fileVol = &vol;

#ifdef SUB_DIRECTORY
  for (; path->name[0]; path++) /* while we have another path segment */
#else
  if (path->name[0])    /* search the root directory */
#endif
  {
    status = flFileNotFound;              /* not yet */
    if (!(file->flags & FILE_IS_DIRECTORY))
      return flPathNotFound;  /* if we don't have a directory,
                            we have no business here */

    scanFile = *file;           /* the previous file found becomes the scan file */
    scanFile.currentPosition = 0;

    file->directorySector = 0;       /* indicate no entry found yet */
    file->flags &= ~(FILE_IS_ROOT_DIR | FILE_IS_DIRECTORY | FILE_READ_ONLY);
    file->ownerDirCluster = dirBackPointer;
    file->fileSize = 0;
    file->currentCluster = 0;

    /* Scan directory */
    while (scanFile.currentPosition < scanFile.fileSize) {
      int i;
      DirectoryEntry FAR0 *dirEntry;
      SectorNo sectorOfDir;
      unsigned offsetInSector;
      FLStatus readStatus = getSectorAndOffset(&scanFile,&sectorOfDir,&offsetInSector);
      if (readStatus == flInvalidFATchain) {
       scanFile.fileSize = scanFile.currentPosition;       /* now we know */
       break;              /* we ran into the end of the directory file */
      }
      else if (readStatus != flOK)
       return readStatus;

      dirEntry = (DirectoryEntry FAR0 *) findSector(&vol,sectorOfDir);
      if (dirEntry == NULL)
       return flSectorNotFound;
      if(dirEntry==dataErrorToken)
        return flDataError;

      scanFile.currentPosition += SECTOR_SIZE;

      for (i = 0; i < DIRECTORY_ENTRIES_PER_SECTOR; i++, dirEntry++) {
       if (tffscmp(path,dirEntry->name,sizeof dirEntry->name) == 0 &&
           !(dirEntry->attributes & ATTR_VOL_LABEL)) {
         /* Found a match */
         file->directorySector = sectorOfDir;
         file->directoryIndex = i;
         file->fileSize = LE4(dirEntry->fileSize);
         if (dirEntry->attributes & ATTR_DIRECTORY) {
           file->flags |= FILE_IS_DIRECTORY;
           file->fileSize = 0x7fffffffl;
           /* Infinite. Directories don't have a recorded size */
         }
         if (dirEntry->attributes & ATTR_READ_ONLY)
           file->flags |= FILE_READ_ONLY;
         dirBackPointer = LE2(dirEntry->startingCluster);
         status = flOK;
         goto endOfPathSegment;
       }
       else if (dirEntry->name[0] == NEVER_USED_DIR_ENTRY ||
               dirEntry->name[0] == DELETED_DIR_ENTRY) {
         /* Found a free entry. Remember it in case we don't find a match */
         if (file->directorySector == 0) {
           file->directorySector = sectorOfDir;
           file->directoryIndex = i;
         }
         if (dirEntry->name[0] == NEVER_USED_DIR_ENTRY)       /* end of dir */
           goto endOfPathSegment;
       }
      }
    }

endOfPathSegment:
    ;
  }
#ifndef FL_READ_ONLY
  if (status == flFileNotFound && (file->flags & FILE_MUST_OPEN) &&
      file->directorySector == 0) {
    /* We did not find a place in the directory for this new entry. The */
    /* directory should be extended. 'scanFile' refers to the directory */
    /* to extend, and the current pointer is at its end                     */
#ifdef SUB_DIRECTORY
    checkStatus(extendDirectory(&scanFile,(unsigned) file->ownerDirCluster));
    file->directorySector = firstSectorOfCluster(&vol,scanFile.currentCluster);
    file->directoryIndex = 0;             /* Has to be. This is a new cluster */
#else
    status = flRootDirectoryFull;
#endif
  }
#endif /* FL_READ_ONLY */
  return status;
}


/*----------------------------------------------------------------------*/
/*                                                               */
/*                       r e a d M u l t i S e c t o r                       */
/*                                                               */
/* Checks if file was written on consequent sectors.                     */
/* Parameters:                                                          */
/*      file              : File to check                                   */
/*       stillToRead           : Number of bytes to read. If the read extends  */
/*                       beyond the end-of-file, the read is truncated */
/*                       at the end-of-file.                            */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*       sectors               : Number of consequent sectors                  */
/*                                                               */
/*----------------------------------------------------------------------*/

static FLStatus readMultiSector(Volume vol,File *file,
                                  unsigned long stillToRead,
                                  SectorNo* sectors)
{
  SectorNo sectorCount = 1;
  unsigned offsetInCluster = (unsigned)((file->currentPosition & (vol.bytesPerCluster - 1))+512);

  while(stillToRead>=((sectorCount+1)<<SECTOR_SIZE_BITS)){
    if(offsetInCluster>=vol.bytesPerCluster) {
      unsigned nextCluster;
      nextCluster = file->currentCluster;
      checkStatus(getFATentry(&vol,&nextCluster));
      if (nextCluster < 2 || nextCluster > vol.maxCluster)
        /* We have a bad file size, or the FAT is bad */
       return flInvalidFATchain;
      if(nextCluster!=file->currentCluster+1)
       break;
      file->currentCluster = nextCluster;
      offsetInCluster = 0;
    }
    offsetInCluster+=SECTOR_SIZE;
    sectorCount++;
  }
  *sectors = sectorCount;
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                            r e a d F i l e                            */
/*                                                               */
/* Reads from the current position in the file to the user-buffer.       */
/* Parameters:                                                          */
/*      file              : File to read.                                   */
/*      ioreq->irData       : Address of user buffer                     */
/*       ioreq->irLength       : Number of bytes to read. If the read extends  */
/*                       beyond the end-of-file, the read is truncated */
/*                       at the end-of-file.                            */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*       ioreq->irLength       : Actual number of bytes read                     */
/*----------------------------------------------------------------------*/

FLStatus readFile(File *file,IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  unsigned char FAR1 *userData = (unsigned char FAR1 *) ioreq->irData;   /* user buffer address */
  unsigned long stillToRead = ioreq->irLength;
  unsigned long remainingInFile = file->fileSize - file->currentPosition;
  ioreq->irLength = 0;              /* read so far */

  /* Should we return an end of file status ? */
  if (stillToRead > remainingInFile)
    stillToRead = (unsigned) remainingInFile;

  while (stillToRead > 0) {
    SectorNo sectorToRead;
    unsigned offsetInSector;
    unsigned long readThisTime;
    const char FAR0 *sector;

    checkStatus(getSectorAndOffset(file,&sectorToRead,&offsetInSector));

    if (stillToRead < SECTOR_SIZE || offsetInSector > 0 || vol.tl.readSectors==NULL) {
      sector = (const char FAR0 *) findSector(&vol,sectorToRead);
      if(sector==NULL)
       {
    DEBUG_PRINT(("readFile : sector was not found\r\n"));
       return flSectorNotFound;
       }
      if(sector==dataErrorToken)
        return flDataError;

      readThisTime = SECTOR_SIZE - offsetInSector;
      if (readThisTime > stillToRead)
        readThisTime = (unsigned) stillToRead;
      if (sector)
        tffscpy(userData,sector + offsetInSector,(unsigned short)readThisTime);
      else
        return flSectorNotFound;              /* Sector does not exist */
    }
    else {
      SectorNo sectorCount;
      checkStatus(readMultiSector(&vol,file,stillToRead,&sectorCount));
      checkStatus(vol.tl.readSectors(vol.tl.rec,sectorToRead,userData,sectorCount));
      readThisTime = (sectorCount<<SECTOR_SIZE_BITS);
    }
    stillToRead -= readThisTime;
    ioreq->irLength += readThisTime;
    userData = (unsigned char FAR1 *)flAddLongToFarPointer(userData,readThisTime);
    file->currentPosition += readThisTime;
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*               f l F i n d N e x t F i l e                            */
/*                                                                      */
/* See the description of 'flFindFirstFile'.                            */
/*                                                                      */
/* Parameters:                                                          */
/*       irHandle       : File handle returned by flFindFirstFile.       */
/*       irData              : Address of user buffer to receive a              */
/*                       DirectoryEntry structure                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus findNextFile(File *file, IOreq FAR2 *ioreq)
{
  DirectoryEntry FAR1 *irDirEntry = (DirectoryEntry FAR1 *) ioreq->irData;
  FLStatus status;
  /* Do we have a directory ? */
  if (!(file->flags & FILE_IS_DIRECTORY))
    return flNotADirectory;

  ioreq->irLength = DIRECTORY_ENTRY_SIZE;
  do {
    /*checkStatus(readFile(file,ioreq));*/
     /*Vadim: add treatment for a full cluster sub-directory */
    status=readFile(file,ioreq);
    if ((ioreq->irLength != DIRECTORY_ENTRY_SIZE) ||
        (irDirEntry->name[0] == NEVER_USED_DIR_ENTRY)||
        (!(file->flags&FILE_IS_ROOT_DIR)&&(status==flInvalidFATchain)))
         {
      checkStatus(closeFile(file));
      return flNoMoreFiles;
    }
    else
      {
       if(status!=flOK)
           return status;
      }
  } while (irDirEntry->name[0] == DELETED_DIR_ENTRY ||
          (irDirEntry->attributes & ATTR_VOL_LABEL));

  return flOK;
}
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                       d e l e t e F i l e                            */
/*                                                               */
/* Deletes a file or directory.                                         */
/*                                                                      */
/* Parameters:                                                          */
/*       ioreq->irPath       : path of file to delete                     */
/*       isDirectory       : 0 = delete file, other = delete directory       */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus deleteFile(Volume vol, IOreq FAR2 *ioreq, FLBoolean isDirectory)
{
  File file;              /* Our private file */
  DirectoryEntry *dirEntry;

  file.flags = 0;
  checkStatus(findDirEntry(&vol,ioreq->irPath,&file));

  if (file.flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  if (isDirectory) {
    DirectoryEntry fileFindInfo;
    ioreq->irData = &fileFindInfo;

    if (!(file.flags & FILE_IS_DIRECTORY))
      return flNotADirectory;
    /* Verify that directory is empty */
    file.currentPosition = 0;
    for (;;) {
      FLStatus status = findNextFile(&file,ioreq);
      if (status == flNoMoreFiles)
       break;
      if (status != flOK)
       return status;
      if (!((fileFindInfo.attributes & ATTR_DIRECTORY) &&
           (tffscmp(fileFindInfo.name,".          ",sizeof fileFindInfo.name) == 0 ||
            tffscmp(fileFindInfo.name,"..         ",sizeof fileFindInfo.name) == 0)))
       return flDirectoryNotEmpty;
    }
  }
  else {
    /* Did we find a directory ? */
    if (file.flags & FILE_IS_DIRECTORY)
      return flFileIsADirectory;
  }

  /* Mark directory entry deleted */
  checkStatus(getDirEntryForUpdate(&file,&dirEntry));
  dirEntry->name[0] = DELETED_DIR_ENTRY;

  /* Delete FAT entries */
  file.currentPosition = 0;
  file.currentCluster = LE2(dirEntry->startingCluster);
  while (file.currentPosition < file.fileSize) {
    unsigned nextCluster;

    if (file.currentCluster < 2 || file.currentCluster > vol.maxCluster)
      /* We have a bad file size, or the FAT is bad */
      return isDirectory ? flOK : flInvalidFATchain;
    nextCluster = file.currentCluster;
    checkStatus(getFATentry(&vol,&nextCluster));

    /* mark FAT free */
    checkStatus(setFATentry(&vol,file.currentCluster,FAT_FREE));
    vol.volBuffer.checkPoint = TRUE;

    /* mark sectors free */
    checkStatus(vol.tl.deleteSector(vol.tl.rec,
                                firstSectorOfCluster(&vol,file.currentCluster),
                                vol.sectorsPerCluster));

    file.currentPosition += vol.bytesPerCluster;
    file.currentCluster = nextCluster;
  }
  if (file.currentCluster > 1 && file.currentCluster <= vol.maxCluster) {
    checkStatus(setFATentry(&vol,file.currentCluster,FAT_FREE));
    vol.volBuffer.checkPoint = TRUE;

    /* mark sectors free */
    checkStatus(vol.tl.deleteSector(vol.tl.rec,
                                firstSectorOfCluster(&vol,file.currentCluster),
                                vol.sectorsPerCluster));
  }
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                   s e t N a m e I n D i r E n t r y                     */
/*                                                               */
/* Sets the file name in a directory entry from a path name             */
/*                                                                      */
/* Parameters:                                                          */
/*       dirEntry       : directory entry                            */
/*       path              : path the last segment of which is the name       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setNameInDirEntry(DirectoryEntry *dirEntry, FLSimplePath FAR1 *path)
{
  FLSimplePath FAR1 *lastSegment;

  for (lastSegment = path;              /* Find null terminator */
       lastSegment->name[0];
       lastSegment++);

  tffscpy(dirEntry->name,--lastSegment,sizeof dirEntry->name);
}

#endif /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*                       o p e n F i l e                            */
/*                                                               */
/* Opens an existing file or creates a new file. Creates a file handle  */
/* for further file processing.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*       ioreq->irFlags       : Access and action options, defined below       */
/*       ioreq->irPath       : path of file to open                           */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*       ioreq->irHandle       : New file handle for open file                 */
/*                                                                      */
/*----------------------------------------------------------------------*/


FLStatus openFile(Volume vol, IOreq FAR2 *ioreq)
{
  int i;
  FLStatus status;

  /* Look for an available file */
  File *file = fileTable;
  for (i = 0; i < FILES && (file->flags & FILE_IS_OPEN); i++, file++);
  if (i >= FILES)
    return flTooManyOpenFiles;
  file->fileVol = &vol;
  ioreq->irHandle = i;              /* return file handle */
#ifndef FL_READ_ONLY
  /* Delete file if exists and required */
  if (ioreq->irFlags & ACCESS_CREATE) {
    FLStatus status = deleteFile(&vol,ioreq,FALSE);
    if (status != flOK && status != flFileNotFound)
      return status;
  }

  /* Find the path */
  if (ioreq->irFlags & ACCESS_CREATE)
    file->flags |= FILE_MUST_OPEN;
#endif /* FL_READ_ONLY */
  status =  findDirEntry(file->fileVol,ioreq->irPath,file);
  if (status != flOK &&
      (status != flFileNotFound || !(ioreq->irFlags & ACCESS_CREATE)))
    return status;

  /* Did we find a directory ? */
  if (file->flags & FILE_IS_DIRECTORY)
    return flFileIsADirectory;

#ifndef FL_READ_ONLY
  /* Create file if required */
  if (ioreq->irFlags & ACCESS_CREATE) {
    DirectoryEntry *dirEntry;
    /* Look for a free cluster. Start at the allocation rover */
    checkStatus(getDirEntryForUpdate(file,&dirEntry));
    setNameInDirEntry(dirEntry,ioreq->irPath);
    dirEntry->attributes = ATTR_ARCHIVE;
    toLE2(dirEntry->startingCluster,0);
    toLE4(dirEntry->fileSize,0);
    setCurrentDateTime(dirEntry);
  }
#endif /* FL_READ_ONLY  */
  if (!(ioreq->irFlags & ACCESS_READ_WRITE))
    file->flags |= FILE_READ_ONLY;

  file->currentPosition = 0;       /* located at file beginning     */
  file->flags |= FILE_IS_OPEN;     /* this file now officially open */

  return flOK;
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                                                                      */
/*                     w r i t e M u l t i S e c t o r                  */
/*                                                                      */
/* Checks the possibility of writing file on consequent sectors.        */
/* Parameters:                                                          */
/*      file           : File to check                                  */
/*      stillToWrite   : Number of bytes to read. If the read extends   */
/*                       beyond the end-of-file, the read is truncated  */
/*                       at the end-of-file.                            */
/* Returns:                                                             */
/*       FLStatu       : 0 on success, otherwise failed                 */
/*       sectors       : Number of consequent sectors                   */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus writeMultiSector(Volume vol,File *file,
                                  unsigned long stillToWrite,
                                  SectorNo* sectors)
{
  SectorNo sectorCount = 1;
  unsigned offsetInCluster = (unsigned)((file->currentPosition & (vol.bytesPerCluster - 1))+512);

  while(stillToWrite>=((sectorCount+1)<<SECTOR_SIZE_BITS)){
    if(offsetInCluster>=vol.bytesPerCluster) {
      if ((long)(file->currentPosition+(sectorCount<<SECTOR_SIZE_BITS))>= file->fileSize) {
        if(file->currentCluster <= vol.maxCluster) {
          unsigned fatEntry;
          if(file->currentCluster+1>vol.maxCluster)
            break;/*There is not free consequent cluster*/
          fatEntry = file->currentCluster+1;
         checkStatus(getFATentry(&vol,&fatEntry));
          if(fatEntry==FAT_FREE) {
            /* Found a free cluster. Mark it as an end of chain */
            checkStatus(setFATentry(&vol,file->currentCluster+1,FAT_LAST_CLUSTER));

            /* Mark previous cluster or directory to point to it */
            checkStatus(setFATentry(&vol,file->currentCluster,file->currentCluster+1));

            /* Set our new current cluster */
            file->currentCluster = file->currentCluster+1;
            offsetInCluster = 0;
          }
          else /*There is not free consequent cluster*/
            break;
        }
        else
          return flInvalidFATchain;
      }
      else { /* We did not passed end of file*/
        unsigned nextCluster = file->currentCluster;
        checkStatus(getFATentry(&vol,&nextCluster));
        if (nextCluster < 2 || nextCluster > vol.maxCluster)
         /* We have a bad file size, or the FAT is bad */
         return flInvalidFATchain;
       if(nextCluster!=file->currentCluster+1)
          break;
       file->currentCluster = nextCluster;
        offsetInCluster = 0;
      }
    }
    offsetInCluster+=SECTOR_SIZE;
    sectorCount++;
  }
  *sectors = sectorCount;
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                       w r i t e F i l e                              */
/*                                                                      */
/* Writes from the current position in the file from the user-buffer.   */
/*                                                                      */
/* Parameters:                                                          */
/*       file              : File to write.                             */
/*       ioreq->irData     : Address of user buffer                     */
/*       ioreq->irLength   : Number of bytes to write.                  */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus          : 0 on success, otherwise failed             */
/*       ioreq->irLength   : Actual number of bytes written             */
/*----------------------------------------------------------------------*/

FLStatus writeFile(File *file, IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  char FAR1 *userData = (char FAR1 *) ioreq->irData;   /* user buffer address */
  unsigned long stillToWrite = ioreq->irLength;

  if (file->flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  file->flags |= FILE_MODIFIED;

  ioreq->irLength = 0;              /* written so far */

  while (stillToWrite > 0) {
    SectorNo sectorToWrite;
    unsigned offsetInSector;
    unsigned long writeThisTime;

    checkStatus(getSectorAndOffset(file,&sectorToWrite,&offsetInSector));

    if (stillToWrite < SECTOR_SIZE || offsetInSector > 0) {
      unsigned short shortWrite;
      /* Not on full sector boundary */
      checkStatus(updateSector(&vol,sectorToWrite,
                  ((file->currentPosition < file->fileSize) || (offsetInSector > 0))));

#ifdef HIGH_SECURITY
      if ((file->flags & FILE_IS_DIRECTORY)||(file->currentPosition < file->fileSize))
#else
      if(file->flags & FILE_IS_DIRECTORY)
#endif
        vol.volBuffer.checkPoint = TRUE;
      writeThisTime = SECTOR_SIZE - offsetInSector;
      if (writeThisTime > stillToWrite)
                            writeThisTime = stillToWrite;

      shortWrite = (unsigned short)writeThisTime;
      tffscpy(vol.volBuffer.flData + offsetInSector,userData,shortWrite);
    }
    else {
      SectorNo sectorCount;
      if(vol.tl.writeMultiSector!=NULL) {
        checkStatus(writeMultiSector(&vol,file,stillToWrite,&sectorCount));
      }
      else
        sectorCount = 1;

      if (((sectorToWrite+sectorCount > vol.volBuffer.sectorNo) && (sectorToWrite <= vol.volBuffer.sectorNo)) &&
          (&vol == vol.volBuffer.owner)) {
       vol.volBuffer.sectorNo = UNASSIGNED_SECTOR;              /* no longer valid */
       vol.volBuffer.dirty = vol.volBuffer.checkPoint = FALSE;
      }

      if(vol.tl.writeMultiSector==NULL) {
        checkStatus(vol.tl.writeSector(vol.tl.rec,sectorToWrite,userData));
      }
      else {
        checkStatus(vol.tl.writeMultiSector(vol.tl.rec,sectorToWrite,userData,sectorCount));
      }
      writeThisTime = (sectorCount<<SECTOR_SIZE_BITS);
    }
    stillToWrite -= writeThisTime;
    ioreq->irLength += writeThisTime;
    userData = (char FAR1 *)flAddLongToFarPointer(userData,writeThisTime);
    file->currentPosition += writeThisTime;
    if (file->currentPosition > file->fileSize)
      file->fileSize = file->currentPosition;
  }

  return flOK;
}

#endif /*  FL_READ_ONLY  */
/*----------------------------------------------------------------------*/
/*                        s e e k F i l e                               */
/*                                                                      */
/* Sets the current position in the file, relative to file start, end   */
/* or current position.                                                 */
/* Note: This function will not move the file pointer beyond the        */
/* beginning or end of file, so the actual file position may be         */
/* different from the required. The actual position is indicated on     */
/* return.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*       file              : File to set position.                      */
/*       ioreq->irLength   : Offset to set position.                    */
/*       ioreq->irFlags    : Method code                                */
/*                     SEEK_START: absolute offset from start of file   */
/*                     SEEK_CURR:  signed offset from current position  */
/*                     SEEK_END:   signed offset from end of file       */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus        : 0 on success, otherwise failed               */
/*       ioreq->irLength : Actual absolute offset from start of file    */
/*----------------------------------------------------------------------*/

FLStatus seekFile(File *file, IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  long int seekPosition = ioreq->irLength;

  switch (ioreq->irFlags) {

    case SEEK_START:
      break;

    case SEEK_CURR:
      seekPosition += file->currentPosition;
      break;

    case SEEK_END:
      seekPosition += file->fileSize;
      break;

    default:
      return flBadParameter;
  }

  if (seekPosition < 0)
    seekPosition = 0;
  if (seekPosition > file->fileSize)
    seekPosition = file->fileSize;

  /* now set the position ... */
  if (seekPosition < file->currentPosition) {
    file->currentCluster = 0;
    file->currentPosition = 0;
  }
  while (file->currentPosition < seekPosition) {
    SectorNo sectorNo;
    unsigned offsetInSector;
    checkStatus(getSectorAndOffset(file,&sectorNo,&offsetInSector));

    file->currentPosition += vol.bytesPerCluster;
    file->currentPosition &= - (long) (vol.bytesPerCluster);
  }
  ioreq->irLength = file->currentPosition = seekPosition;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                        f l F i n d F i l e                            */
/*                                                                      */
/* Finds a file entry in a directory, optionally modifying the file     */
/* time/date and/or attributes.                                         */
/* Files may be found by handle no. provided they are open, or by name. */
/* Only the Hidden, System or Read-only attributes may be modified.       */
/* Entries may be found for any existing file or directory other than   */
/* the root. A DirectoryEntry structure describing the file is copied   */
/* to a user buffer.                                                 */
/*                                                                      */
/* The DirectoryEntry structure is defined in dosformt.h              */
/*                                                                      */
/* Parameters:                                                          */
/*       irHandle       : If by name: Drive number (0, 1, ...)              */
/*                       else      : Handle of open file              */
/*       irPath              : If by name: Specifies a file or directory path*/
/*       irFlags              : Options flags                                   */
/*                       FIND_BY_HANDLE: Find open file by handle.        */
/*                                     Default is access by path.    */
/*                        SET_DATETIME:       Update time/date from buffer       */
/*                       SET_ATTRIBUTES: Update attributes from buffer       */
/*       irDirEntry       : Address of user buffer to receive a              */
/*                       DirectoryEntry structure                     */
/*                                                                      */
/* Returns:                                                             */
/*       irLength       : Modified                                   */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus findFile(Volume vol, File *file, IOreq FAR2 *ioreq)
{
  File tFile;                     /* temporary file for searches */

  if (ioreq->irFlags & FIND_BY_HANDLE)
    tFile = *file;
  else {
    tFile.flags = 0;
    checkStatus(findDirEntry(&vol,ioreq->irPath,&tFile));
  }

  if (tFile.flags & FILE_IS_ROOT_DIR)
    if (ioreq->irFlags & (SET_DATETIME | SET_ATTRIBUTES))
      return flPathIsRootDirectory;
    else {
      DirectoryEntry FAR1 *irDirEntry = (DirectoryEntry FAR1 *) ioreq->irData;

      tffsset(irDirEntry,0,sizeof(DirectoryEntry));
      irDirEntry->attributes = ATTR_DIRECTORY;
      return flOK;
    }

#ifndef FL_READ_ONLY
  if (ioreq->irFlags & (SET_DATETIME | SET_ATTRIBUTES)) {
    DirectoryEntry FAR1 *irDirEntry = (DirectoryEntry FAR1 *) ioreq->irData;
    DirectoryEntry *dirEntry;

    checkStatus(getDirEntryForUpdate(&tFile,&dirEntry));
    if (ioreq->irFlags & SET_DATETIME) {
      COPY2(dirEntry->updateDate,irDirEntry->updateDate);
      COPY2(dirEntry->updateTime,irDirEntry->updateTime);
    }
    if (ioreq->irFlags & SET_ATTRIBUTES) {
      unsigned char attr;
      attr = dirEntry->attributes & ATTR_DIRECTORY;
      attr |= irDirEntry->attributes &
            (ATTR_ARCHIVE | ATTR_HIDDEN | ATTR_READ_ONLY | ATTR_SYSTEM);
      dirEntry->attributes = attr;
    }
    tffscpy(irDirEntry, dirEntry, sizeof(DirectoryEntry));

  }
  else
#endif /* FL_READ_ONLY */
{
    const DirectoryEntry FAR0 *dirEntry;
    dirEntry = getDirEntry(&tFile);

    if(dirEntry==NULL)
      return flSectorNotFound;
    if(dirEntry==dataErrorToken)
      return flDataError;

    tffscpy(ioreq->irData,dirEntry,sizeof(DirectoryEntry));
    if (ioreq->irFlags & FIND_BY_HANDLE)
      toLE4(((DirectoryEntry FAR1 *) (ioreq->irData))->fileSize, tFile.fileSize);
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*               f l F i n d F i r s t F i l e                            */
/*                                                                      */
/* Finds the first file entry in a directory.                            */
/* This function is used in combination with the flFindNextFile call,   */
/* which returns the remaining file entries in a directory sequentially.*/
/* Entries are returned according to the unsorted directory order.       */
/* flFindFirstFile creates a file handle, which is returned by it. Calls*/
/* to flFindNextFile will provide this file handle. When flFindNextFile */
/* returns 'noMoreEntries', the file handle is automatically closed.    */
/* Alternatively the file handle can be closed by a 'closeFile' call    */
/* before actually reaching the end of directory.                     */
/* A DirectoryEntry structure is copied to the user buffer describing   */
/* each file found. This structure is defined in dosformt.h.              */
/*                                                                      */
/* Parameters:                                                          */
/*       irHandle       : Drive number (0, 1, ...)                     */
/*       irPath              : Specifies a directory path                     */
/*       irData              : Address of user buffer to receive a              */
/*                       DirectoryEntry structure                     */
/*                                                                      */
/* Returns:                                                             */
/*       irHandle       : File handle to use for subsequent operations. */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus findFirstFile(Volume vol, IOreq FAR2 *ioreq)
{
  int i;

  /* Look for an available file */
  File *file = fileTable;
  for (i = 0; i < FILES && (file->flags & FILE_IS_OPEN); i++, file++);
  if (i >= FILES)
    return flTooManyOpenFiles;
  file->fileVol = &vol;
  ioreq->irHandle = i;              /* return file handle */

  /* Find the path */
  checkStatus(findDirEntry(file->fileVol,ioreq->irPath,file));

  file->currentPosition = 0;              /* located at file beginning */
  file->flags |= FILE_IS_OPEN | FILE_READ_ONLY; /* this file now officially open */

  return findNextFile(file,ioreq);
}


/*----------------------------------------------------------------------*/
/*                       g e t D i s k I n f o                            */
/*                                                               */
/* Returns general allocation information.                            */
/*                                                               */
/* The bytes/sector, sector/cluster, total cluster and free cluster       */
/* information are returned into a DiskInfo structure.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       ioreq->irData       : Address of DiskInfo structure                 */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus getDiskInfo(Volume vol, IOreq FAR2 *ioreq)
{
  unsigned i;
  unsigned fatEntry;

  DiskInfo FAR1 *diskInfo = (DiskInfo FAR1 *) ioreq->irData;

  diskInfo->bytesPerSector = SECTOR_SIZE;
  diskInfo->sectorsPerCluster = vol.sectorsPerCluster;
  diskInfo->totalClusters = vol.maxCluster - 1;
  diskInfo->freeClusters = 0;              /* let's count them */

  for (i = 2; i <= vol.maxCluster; i++) {
    fatEntry = i;
    checkStatus(getFATentry(&vol,&fatEntry));
    if ( fatEntry== 0)
      diskInfo->freeClusters++;
  }

  return flOK;
}

#ifndef FL_READ_ONLY
#ifdef RENAME_FILE

/*----------------------------------------------------------------------*/
/*                      r e n a m e F i l e                            */
/*                                                               */
/* Renames a file to another name.                                   */
/*                                                               */
/* Parameters:                                                          */
/*       ioreq->irPath       : path of existing file                            */
/*      ioreq->irData       : path of new name.                            */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus renameFile(Volume vol, IOreq FAR2 *ioreq)
{
  File file, file2;              /* temporary files for searches */
  DirectoryEntry *dirEntry, *dirEntry2;
  FLStatus status;
  FLSimplePath FAR1 *irPath2 = (FLSimplePath FAR1 *) ioreq->irData;

  file.flags = 0;
  checkStatus(findDirEntry(&vol,ioreq->irPath,&file));

  file2.flags = FILE_MUST_OPEN;
  status = findDirEntry(file.fileVol,irPath2,&file2);
  if (status != flFileNotFound)
    return status == flOK ? flFileAlreadyExists : status;

#ifndef VFAT_COMPATIBILITY
  if (file.ownerDirCluster == file2.ownerDirCluster) {       /* Same directory */
    /* Change name in directory entry */
    checkStatus(getDirEntryForUpdate(&file,&dirEntry));
    setNameInDirEntry(dirEntry,irPath2);
  }
  else
#endif
  {       /* not same directory */
    /* Write new directory entry */
    const DirectoryEntry FAR0 *dir;
    checkStatus(getDirEntryForUpdate(&file2,&dirEntry2));

    dir = getDirEntry(&file);
    if(dir==NULL)
      return flSectorNotFound;
    if(dir==dataErrorToken)
      return flDataError;
    *dirEntry2 = *dir;

     setNameInDirEntry(dirEntry2,irPath2);

    /* Delete original entry */
    checkStatus(getDirEntryForUpdate(&file,&dirEntry));
    dirEntry->name[0] = DELETED_DIR_ENTRY;
  }

  return flOK;
}

#endif /* RENAME_FILE */
#endif /* FL_READ_ONLY  */


#ifndef FL_READ_ONLY
#ifdef SUB_DIRECTORY

/*----------------------------------------------------------------------*/
/*                           m a k e D i r                            */
/*                                                               */
/* Creates a new directory.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*       ioreq->irPath       : path of new directory.                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus makeDir(Volume vol, IOreq FAR2 *ioreq)
{
  File file;                     /* temporary file for searches */
  unsigned dirBackPointer;
  DirectoryEntry *dirEntry;
  FLStatus status;
  unsigned originalRover;
  unsigned fatEntry;

  file.flags = FILE_MUST_OPEN;
  status = findDirEntry(&vol,ioreq->irPath,&file);
  if (status != flFileNotFound)
    return status == flOK ? flFileAlreadyExists : status;


  /* Look for a free cluster. Start at the allocation rover */
  originalRover = vol.allocationRover;
  do {
    vol.allocationRover++;
    if (vol.allocationRover > vol.maxCluster)
      vol.allocationRover = 2;       /* wraparound to start of volume */
    if (vol.allocationRover == originalRover)
      return flNoSpaceInVolume;

    fatEntry = vol.allocationRover;
    checkStatus(getFATentry(&vol,&fatEntry));
  } while ( fatEntry!= FAT_FREE);
    /* Found a free cluster. Mark it as an end of chain */
  checkStatus(setFATentry(&vol,vol.allocationRover,FAT_LAST_CLUSTER));

  /* Create the directory entry for the new dir */
  checkStatus(getDirEntryForUpdate(&file,&dirEntry));

  setNameInDirEntry(dirEntry,ioreq->irPath);
  dirEntry->attributes = ATTR_ARCHIVE | ATTR_DIRECTORY;
  toLE2(dirEntry->startingCluster,vol.allocationRover);
  toLE4(dirEntry->fileSize,0);
  setCurrentDateTime(dirEntry);

  /* Remember the back pointer to owning directory for the ".." entry */
  dirBackPointer = (unsigned) file.ownerDirCluster;

  file.flags |= FILE_IS_DIRECTORY;
  file.currentPosition = 0;
  file.fileSize = 0;
  return extendDirectory(&file,dirBackPointer);
}


#endif /* SUB_DIRECTORY */

#ifdef SPLIT_JOIN_FILE

/*------------------------------------------------------------------------*/
/*                        j o i n F i l e                                 */
/*                                                                        */
/* joins two files. If the end of the first file is on a cluster          */
/* boundary, the files will be joined there. Otherwise, the data in       */
/* the second file from the beginning until the offset that is equal to   */
/* the offset in cluster of the end of the first file will be lost. The   */
/* rest of the second file will be joined to the first file at the end of */
/* the first file. On exit, the first file is the expanded file and the   */
/* second file is deleted.                                                */
/* Note: The second file will be open by this function, it is advised to  */
/*        close it before calling this function in order to avoid          */
/*        inconsistencies.                                                 */
/*                                                                        */
/* Parameters:                                                            */
/*       file            : file to join to.                                */
/*       irPath          : Path name of the file to be joined.             */
/*                                                                        */
/* Returns:                                                               */
/*       FLStatus        : 0 on success, otherwise failed.                 */
/*                                                                        */
/*------------------------------------------------------------------------*/

FLStatus joinFile (File *file, IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  File joinedFile;
  DirectoryEntry *joinedDirEntry;
  unsigned offsetInCluster = (unsigned)(file->fileSize % vol.bytesPerCluster);

  if (file->flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  if (file->flags & FILE_IS_DIRECTORY)
    return flFileIsADirectory;

  /* open the joined file. */
  joinedFile.flags = 0;
  checkStatus(findDirEntry(file->fileVol,ioreq->irPath,&joinedFile));
  joinedFile.currentPosition = 0;

  /* Check if the two files are the same file. */
  if (file->directorySector == joinedFile.directorySector &&
      file->directoryIndex == joinedFile.directoryIndex)
    return flBadFileHandle;

  file->flags |= FILE_MODIFIED;

  if (joinedFile.fileSize > (long)offsetInCluster) { /* the joined file extends
                                             beyond file's end of file.*/
    unsigned lastCluster, nextCluster, firstCluster;
    const DirectoryEntry FAR0 *dir;
    dir = getDirEntry(&joinedFile);

    if(dir==NULL)
      return flSectorNotFound;
    if(dir==dataErrorToken)
      return flDataError;

    /* get the first cluster of the joined file. */
    firstCluster = LE2(dir->startingCluster);

    if (file->fileSize) {  /* the file is not empty.*/
      /* find the last cluster of file by following the FAT chain.*/
      if (file->currentCluster == 0) {    /* start from the first cluster.*/
        const DirectoryEntry FAR0 *dir;
        dir = getDirEntry(file);

        if(dir==NULL)
          return flSectorNotFound;
        if(dir==dataErrorToken)
          return flDataError;
        nextCluster = LE2(dir->startingCluster);
      }
      else                               /* start from the current cluster.*/
       nextCluster = file->currentCluster;
      /* follow the FAT chain.*/
      while (nextCluster != FAT_LAST_CLUSTER) {
       if (nextCluster < 2 || nextCluster > vol.maxCluster)
         return flInvalidFATchain;
       lastCluster = nextCluster;
        checkStatus(getFATentry(&vol,&nextCluster));
      }
    }
    else                   /* the file is empty. */
      lastCluster = 0;

    if (offsetInCluster) {      /* join in the middle of a cluster.*/
      SectorNo sectorNo, joinedSectorNo, tempSectorNo;
      unsigned offset, joinedOffset, numOfSectors = 1, i;
      const char FAR0 *startCopy;
      unsigned fatEntry;

      /* get the sector and offset of the end of the file.*/
      file->currentPosition = file->fileSize;
      file->currentCluster = lastCluster;
      checkStatus(getSectorAndOffset(file, &sectorNo, &offset));

      /* load the sector of the end of the file to the buffer.*/
      checkStatus(updateSector(&vol, sectorNo, TRUE));

      /*  copy the second part of the first cluster of the joined file
         to the end of the last cluster of the original file.*/
      /* first set the current position of the joined file.*/
      joinedFile.currentPosition = offsetInCluster;
      joinedFile.currentCluster = firstCluster;
      /* get the relevant sector in the joined file.*/
      checkStatus(getSectorAndOffset(&joinedFile, &joinedSectorNo, &joinedOffset));
      /* map sector and offset.*/
      startCopy = (const char FAR0 *) findSector(&vol,joinedSectorNo) + joinedOffset;
      if (startCopy == NULL)
       return flSectorNotFound;
      if(startCopy==dataErrorToken)
        return flDataError;

      /* copy.*/
      tffscpy(vol.volBuffer.flData + offset, startCopy, SECTOR_SIZE - offset);
      checkStatus(flushBuffer(&vol));

      /* find how many sectors should still be copied (the number of sectors
        until the end of the current cluster).*/
      tempSectorNo = firstSectorOfCluster(&vol,lastCluster);
      while(tempSectorNo != sectorNo) {
       tempSectorNo++;
       numOfSectors++;
      }

      /* copy the rest of the sectors in the current cluster.
        this is done by loading a sector from the joined file to the buffer,
        changing the sectoNo of the buffer to the relevant sector in file
        and then flushing the buffer.*/
      sectorNo++;
      joinedSectorNo++;
      for(i = 0; i < vol.sectorsPerCluster - numOfSectors; i++) {
       checkStatus(updateSector(&vol,joinedSectorNo, TRUE));
       vol.volBuffer.sectorNo = sectorNo;
       checkStatus(flushBuffer(&vol));
       sectorNo++;
       joinedSectorNo++;
      }
      fatEntry = firstCluster;
      checkStatus(getFATentry(&vol,&fatEntry));
      /* adjust the FAT chain.*/
      checkStatus(setFATentry(&vol,
                           lastCluster,
                           fatEntry));

      /* mark the first cluster of the joined file as free */
      checkStatus(setFATentry(&vol,firstCluster,FAT_FREE));
      vol.volBuffer.checkPoint = TRUE;

      /* mark sectors free */
      checkStatus(vol.tl.deleteSector(vol.tl.rec,firstSectorOfCluster(&vol,firstCluster),
                                  vol.sectorsPerCluster));
    }
    else {    /* join on a cluster boundary.*/
      if (lastCluster) {      /* file is not empty. */
       checkStatus(setFATentry(&vol,lastCluster, firstCluster));
      }
      else {                  /* file is empty.*/
       DirectoryEntry *dirEntry;

       checkStatus(getDirEntryForUpdate(file, &dirEntry));
       toLE2(dirEntry->startingCluster, firstCluster);
       setCurrentDateTime(dirEntry);
      }
    }
    /*adjust the size of the expanded file.*/
    file->fileSize += joinedFile.fileSize - offsetInCluster;

    /* mark the directory entry of the joined file as deleted.*/
    checkStatus(getDirEntryForUpdate(&joinedFile, &joinedDirEntry));
    joinedDirEntry->name[0] = DELETED_DIR_ENTRY;
  }
  else        /* the joined file is too small all is left to do is delete it */
    checkStatus(deleteFile (&vol, ioreq, FALSE));

  return flOK;
}


/*------------------------------------------------------------------------*/
/*                    s p l i t F i l e                                   */
/*                                                                        */
/* Splits the file into two files. The original file contains the first   */
/* part, and a new file (which is created for that purpose) contains      */
/* the second part. If the current position is on a cluster               */
/* boundary, the file will be split at the current position. Otherwise,   */
/* the cluster of the current position is duplicated, one copy is the     */
/* first cluster of the new file, and the other is the last cluster of the*/
/* original file, which now ends at the current position.                 */
/*                                                                        */
/* Parameters:                                                            */
/*       file            : file to split.                                  */
/*       irPath          : Path name of the new file.                      */
/*                                                                        */
/* Returns:                                                               */
/*       irHandle        : handle of the new file.                         */
/*       FLStatus        : 0 on success, otherwise failed.                 */
/*                                                                        */
/*------------------------------------------------------------------------*/

FLStatus splitFile (File *file, IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  File *newFile, dummyFile;
  IOreq ioreq2;
  FLStatus status;
  unsigned fatEntry;

  if (file->flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  if (file->flags & FILE_IS_DIRECTORY)
    return flFileIsADirectory;

  /* check if the path of the new file already exists.*/
  dummyFile.flags = 0;
  status = findDirEntry(&vol,ioreq->irPath,&dummyFile);
  if (status != flFileNotFound) {
    if (status == flOK)              /* there is a file with that path.*/
      return flFileAlreadyExists;
    else
      return status;
  }

  /* open the new file.*/
  ioreq2.irFlags = OPEN_FOR_WRITE;
  ioreq2.irPath = ioreq->irPath;
  checkStatus(openFile(&vol,&ioreq2));

  newFile = fileTable + ioreq2.irHandle;
  newFile->flags |= FILE_MODIFIED;
  file->flags |= FILE_MODIFIED;

  if (file->currentPosition % vol.bytesPerCluster) { /* not on a cluster boundary.*/
    SectorNo sectorNo, newSectorNo, lastSector;
    int i;
    if((status = allocateCluster(newFile)) != flOK) {
      newFile->flags = 0;                             /* close the new file */
      return status;
    }
    sectorNo = firstSectorOfCluster(&vol,file->currentCluster);
    newSectorNo = firstSectorOfCluster(&vol,newFile->currentCluster);
    /* deal with split in a last not full cluster */
    fatEntry = file->currentCluster;
    checkStatus(getFATentry(&vol,&fatEntry));
    if (fatEntry == FAT_LAST_CLUSTER)
      lastSector = ((file->fileSize - 1) % vol.bytesPerCluster)/SECTOR_SIZE +
                   sectorNo;
    else
      lastSector = sectorNo + vol.sectorsPerCluster; /* out of the cluster */

    /* copy the current cluster of the original file to the first cluster
       of the new file, sector after sector.*/
    for(i = 0; i < (int)vol.sectorsPerCluster; i++) {
      if((status = updateSector(&vol,sectorNo, TRUE)) != flOK) {
        newFile->flags = 0;                             /* close the new file */
       return status;
      }

      vol.volBuffer.sectorNo = newSectorNo;
      if((status = flushBuffer(&vol)) != flOK) {
        newFile->flags = 0;                             /* close the new file */
        return status;
      }

      sectorNo++;
      newSectorNo++;

      if(sectorNo > lastSector)
        break;
    }
    fatEntry = file->currentCluster;
    checkStatus(getFATentry(&vol,&fatEntry));

    /* adjust the FAT chain of the new file.*/
    if((status = setFATentry(&vol,newFile->currentCluster,
                             fatEntry)) != flOK) {
      newFile->flags = 0;                             /* close the new file */
      return status;
    }

    /* mark current cluster 0 (as current position).*/
    newFile->currentCluster = 0;
  }
  else {                                  /* on a cluster boundary.*/
    DirectoryEntry *newDirEntry;

    /* adjust the directory entry of the new file.*/
    if((status = getDirEntryForUpdate(newFile,&newDirEntry)) != flOK) {
      newFile->flags = 0;                             /* close the new file */
      return status;
    }

    if (file->currentPosition) { /* split at the middle of the file.*/
      fatEntry = file->currentCluster;
      checkStatus(getFATentry(&vol,&fatEntry));

      toLE2(newDirEntry->startingCluster, fatEntry);
      setCurrentDateTime(newDirEntry);
    }
    else {                     /* split at the beginning of the file.*/
      DirectoryEntry *dirEntry;

      const DirectoryEntry FAR0 *dir;
      dir = getDirEntry(file);
      if(dir==NULL)
       return flSectorNotFound;
      if(dir==dataErrorToken)
       return flDataError;

      /* first cluster of file becomes the first cluster of the new file.*/
      toLE2(newDirEntry->startingCluster,LE2(dir->startingCluster));
      setCurrentDateTime(newDirEntry);

      /* starting cluster of file becomes 0.*/
      if((status = getDirEntryForUpdate(file, &dirEntry)) != flOK) {
       newFile->flags = 0;                             /* close the new file */
       return status;
      }

      toLE2(dirEntry->startingCluster, 0);
      setCurrentDateTime(dirEntry);
    }
  }

  /* adjust the size of the new file.*/
  newFile->fileSize = file->fileSize - file->currentPosition +
                   (file->currentPosition % vol.bytesPerCluster);

  /* adjust the chain and size of the original file.*/
  if (file->currentPosition)    /* we didn't split at the beginning.*/
    if((status = setFATentry(&vol,file->currentCluster, FAT_LAST_CLUSTER)) != flOK) {
      newFile->flags = 0;                             /* close the new file */
      return status;
    }

  file->fileSize = file->currentPosition;

  /* return to the user the handle of the new file.*/
  ioreq->irHandle = ioreq2.irHandle;

  return flOK;
}

#endif /* SPLIT_JOIN_FILE */
#endif /*  FL_READ_ONLY  */


/*----------------------------------------------------------------------*/
/*                       I n i t F S                                */
/*                                                               */
/* Initializes the FLite file system.                                     */
/*                                                               */
/* Calling this function is optional. If it is not called,              */
/* initialization will be done automatically on the first FLite call.       */
/* This function is provided for those applications who want to              */
/* explicitly initialize the system and get an initialization status.       */
/*                                                               */
/* Calling flInit after initialization was done has no effect.              */
/*                                                               */
/* Parameters:                                                          */
/*       None                                                        */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

void initFS()
{
  unsigned i;
  unsigned volNo;
  Volume vol = vols;

  for (volNo = 0; volNo < VOLUMES; volNo++, pVol++) {
    vol.volBuffer.dirty = FALSE;
    vol.volBuffer.owner = NULL;
    vol.volBuffer.sectorNo = UNASSIGNED_SECTOR;       /* Current sector no. (none) */
    vol.volBuffer.checkPoint = FALSE;
  }

  for (i = 0; i < FILES; i++)
    fileTable[i].flags = 0;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flbase.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLBASE.C_V  $
 * 
 *    Rev 1.3   Sep 15 2001 23:45:32   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 * 
 *    Rev 1.2   Apr 09 2001 15:07:34   oris
 * End with an empty line.
 * 
 *    Rev 1.1   Apr 01 2001 07:45:30   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 11:05:28   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "flbase.h"

#ifdef FL_BIG_ENDIAN

/*----------------------------------------------------------------------*/
/*         Little / Big - Endian Conversion Routines			*/
/*----------------------------------------------------------------------*/

void toLEushort(unsigned char FAR0 *le, unsigned short n)
{
  le[1] = (unsigned char)(n >> 8);
  le[0] = (unsigned char)n;
}


unsigned short fromLEushort(unsigned char const FAR0 *le)
{
  return ((unsigned short)le[1] << 8) + le[0];
}


void toLEulong(unsigned char FAR0 *le, unsigned long n)
{
  le[3] = (unsigned char)(n >> 24);
  le[2] = (unsigned char)(n >> 16);
  le[1] = (unsigned char)(n >> 8);
  le[0] = (unsigned char)n;
}

unsigned long fromLEulong(unsigned char const FAR0 *le)
{
  return ((unsigned long)le[3] << 24) +
	 ((unsigned long)le[2] << 16) +
	 ((unsigned long)le[1] << 8) +
	 le[0];
}

extern void copyShort(unsigned char FAR0 *to, unsigned char const FAR0 *from)
{
  to[0] = from[0];
  to[1] = from[1];
}

extern void copyLong(unsigned char FAR0 *to, unsigned char const FAR0 *from)
{
  to[0] = from[0];
  to[1] = from[1];
  to[2] = from[2];
  to[3] = from[3];
}


#else

void toUNAL(unsigned char FAR0 *unal, unsigned short n)
{
  unal[1] = (unsigned char)(n >> 8);
  unal[0] = (unsigned char)n;
}


unsigned short fromUNAL(unsigned char const FAR0 *unal)
{
  return ((unsigned short)unal[1] << 8) + unal[0];
}


void toUNALLONG(Unaligned FAR0 *unal, unsigned long n)
{
  toUNAL(unal[0],(unsigned short)n);
  toUNAL(unal[1],(unsigned short)(n >> 16));
}


unsigned long fromUNALLONG(Unaligned const FAR0 *unal)
{
  return fromUNAL(unal[0]) +
	 ((unsigned long)fromUNAL(unal[1]) << 16);
}

#endif /* FL_BIG_ENDIAN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flbase.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLBASE.H_V  $
 * 
 *    Rev 1.19   Apr 15 2002 07:36:18   oris
 * Moved all include directive to head of file.
 * Moved OS names definitions to mtdsa.h
 * Changed flBusConfig environment array to dword variables instead of single byte.
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.18   Feb 19 2002 20:59:28   oris
 * Changed order of include directives.
 * 
 *    Rev 1.17   Jan 29 2002 20:08:08   oris
 * Added NAMING_CONVENTION prefix and extern "C" for cpp files to all public routines:
 * tffsset, tffscmp and tffsset.
 * 
 *    Rev 1.16   Jan 20 2002 20:26:42   oris
 * Added casting to byte to FL_GET_PARTITION_FROM_HANDLE and to FL_GET_SOCKET_FROM_HANDLE
 * 
 *    Rev 1.15   Jan 17 2002 23:00:42   oris
 * Removed MAX and MIN definitions and replaced them with TFFSMIN and  TFFSMAX.
 * Added extern for the following environment variables: 
 *    extern dword  flSectorsVerifiedPerFolding;
 *    extern byte    flSuspendMode;
 *    extern byte    flBusConfig[SOCKETS];
 * Changed the following environment variables
 *    extern byte    flVerifyWrite[SOCKETS][MAX_TL_PARTITIONS<<1] - 4 for  disk partition 3 for binary and one for the rest.
 *    extern byte    flPolicy[SOCKETS][MAX_TL_PARTITIONS] - 1 for each disk  partition.
 * Changed all environment variables to byte (except for flSectorsVerifiedPerFolding)
 * Added FL_UPS  for flVerifyWrite
 * Added FL_SUSPEND_WRITE and FL_SUSPEND_IO for flSuspendMode.
 * Added define CUR_OS_WINCE for boot SDK customization.
 * Exchanged CUR_OS_VX_WORKS and CUR_NO_OS
 * Added FL_GET_SOCKET_FROM_HANDLE and FL_GET_PARTITION_FROM_HANDLE instead of HANDLE_VOLUME_MASK and HANDLE_PARTITION_MASK.
 * 
 *    Rev 1.14   Nov 21 2001 11:38:52   oris
 * Removed FL_MULTI_DOC_NOT_ACTIVE , FL_MULTI_DOC_ACTIVE ,  FL_DO_NOT_MARK_DELETE , FL_MARK_DELETE , FL_WITHOUT_VERIFY_WRITE ,  FL_WITH_VERIFY_WRITE definition (unsing FL_ON and FL_OFF instead).
 * 
 *    Rev 1.13   Nov 08 2001 10:49:14   oris
 * Moved environment variable states definitions from blockdev.h
 * Added flVerifyWrite environment variable that controls the verify write mode at run-time. 
 * 
 *    Rev 1.12   Sep 15 2001 23:45:40   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 * Changed checkStatus definition in order not to get compilation warnings.
 * 
 *    Rev 1.11   Jul 29 2001 16:44:16   oris
 * Added CUR_OS_NO definition
 * 
 *    Rev 1.10   May 21 2001 16:09:52   oris
 * Removed flsleep prototype and moved tffscpy tffscmp and tffsset prototypes under USE_STD_FUNC copmpilation flag.
 * 
 *    Rev 1.9   May 21 2001 13:51:06   oris
 * Reorganized and added the CUS_OS_DOS, CUS_OS_PSOS and CUS_OS_VX_WORKS defintions.
 * 
 *    Rev 1.8   May 16 2001 21:17:38   oris
 * Added the FL_ prefix to the following defines: ON, OFF
 * Changed c variable name to cval (avoid name clashes). 
 * Added flMtlDefragMode environment variable forward definition.
 * 
 *    Rev 1.7   Apr 30 2001 18:00:32   oris
 * Added new environment variable flMarkDeleteOnFlash declaration.
 * 
 *    Rev 1.6   Apr 10 2001 23:53:54   oris
 * Added flAddLongToFarPointer declaration for the standalone version.
 * 
 *    Rev 1.5   Apr 09 2001 15:01:56   oris
 * UNAL4(arg) definition was changed.
 *
 *    Rev 1.4   Apr 01 2001 07:51:46   oris
 * copywrite notice.
 * Moved MIN,MAX,BYTE_ADD_FAR,WORD_ADD_FAR macroes from base2400.c.
 * Moved protection attributes definition to flflash.h.
 * Aliggned left all # directives.
 * Added FAR0 to cpyBuffer,setBuffer,cmpBuffer,flmemcpy,flmemset and flmemcmp
 *
 *    Rev 1.3   Feb 18 2001 14:18:02   oris
 * remove osak version redundent definition.
 *
 *    Rev 1.2   Feb 14 2001 02:12:08   oris
 * Added flMaxUnitChain environment variable.
 * Changed flUseMultiDoc and flPolicy variables type and names.
 *
 *    Rev 1.1   Feb 05 2001 18:45:20   oris
 * Removed flcustm.h include directive since it is already included in mtdsa.h
 * Added flchkdef.h include directive for sanity check on compilation flags.
 *
 *    Rev 1.0   Feb 04 2001 11:14:30   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLBASE_H
#define FLBASE_H

/***************************************************************************/
/*                                                                         */
/* Include customization files                                             */
/* Note the following files are used for :                                 */
/*   mtdsa.h    - Complete customization - standaloe applications          */
/*                                         like Binary SDK                 */
/*   flsystem.h - System customization - TrueFFS applications like drivers */
/*   flchkdef.h - Customized defintion check of TrueFFS applications.      */
/*                                                                         */
/***************************************************************************/

#include "mtdsa.h"
#ifndef    MTD_STANDALONE
#include "flcustom.h"
#include "flsystem.h"
#include "flchkdef.h"
#endif    /* MTD_STANDALONE */
#include "flstatus.h"

 /* Number of translation layer partitions
 *
 * Defines Maximum Number of Traslation layer partitons on a physical device
 *
 * The actual number of partitions depends on the format placed on each device.
 */

#define MAX_TL_PARTITIONS 4

/* Sector size
 *
 * Define the log2 of sector size for the FAT & translation layers. Note
 * that the default 512 bytes is the de-facto standard and practically
 * the only one that provides real PC interoperability.
 */

#define SECTOR_SIZE_BITS   9

/* standard type definitions */
typedef int         FLBoolean;

/* Boolean constants */

#ifndef FALSE
#define FALSE    0
#endif
#ifndef TRUE
#define    TRUE    1
#endif

#ifndef FL_ON
#define    FL_ON    1
#endif
#ifndef FL_OFF
#define    FL_OFF    0
#endif

/* Geral purpose macroes */

#define BYTE_ADD_FAR(x,y) ((byte FAR1 *)addToFarPointer(x,y))
#define WORD_ADD_FAR(x,y) ((word FAR1 *)addToFarPointer(x,y))

/* Drive handle masks */

#define FL_GET_SOCKET_FROM_HANDLE(ioreq)    (byte)(ioreq->irHandle & 0x0f)
#define FL_GET_PARTITION_FROM_HANDLE(ioreq) (byte)((ioreq->irHandle & 0xf0) >> 4)
#define INVALID_VOLUME_NUMBER 0xff
#define TL_SIGNATURE          6

/* General types definitions */

typedef unsigned char  byte;        /* 8  bit unsigned variable */
typedef unsigned short word;        /* 16 bit unsigned variable */
typedef unsigned long  dword;       /* 32 bit unsigned variable */

typedef signed char  Sbyte;         /* 8  bit signed variable */
typedef signed short Sword;         /* 16 bit signed variable */
typedef signed long  Sdword;        /* 32 bit signed variable */


#define SECTOR_SIZE        (1 << SECTOR_SIZE_BITS)
#define BITS_PER_BITE            8

/* General purpose Macroes adjusted according to the above customization files. */

/* define SectorNo range according to media maximum size */
#if (MAX_VOLUME_MBYTES * 0x100000l) / SECTOR_SIZE > 0x10000l
typedef unsigned long SectorNo;
#define    UNASSIGNED_SECTOR 0xffffffffl
#else
typedef unsigned short SectorNo;
#define UNASSIGNED_SECTOR 0xffff
#endif

/* x86 pointer far level dictated several of the TrueFFS pointers types. */
#if FAR_LEVEL > 0
#define FAR0    far
#else
#define FAR0
#endif

#if FAR_LEVEL > 1
#define FAR1    far
#else
#define FAR1
#endif

#if FAR_LEVEL > 2
#define FAR2    far
#else
#define FAR2
#endif

/* Call a procedure returning status and fail if it fails. This works only in */
/* routines that return Status: */
#define checkStatus(exp)      {    FLStatus fl__status = (exp);if (fl__status != flOK) return fl__status; }

#define vol (*pVol)
#define TFFSMIN(a,b) ((a>b) ? b:a)
#define TFFSMAX(a,b) ((a<b) ? b:a)

/***************************************************************************/
/* Big \ Little endien architecture conversion macroes.                    */
/***************************************************************************/

#ifndef FL_BIG_ENDIAN

typedef unsigned short LEushort;
typedef unsigned long LEulong;

#define LE2(arg)         arg
#define toLE2(to,arg)    (to) = (arg)
#define LE4(arg)         arg
#define toLE4(to,arg)    (to) = (arg)
#define COPY2(to,arg)    (to) = (arg)
#define COPY4(to,arg)    (to) = (arg)

typedef unsigned char Unaligned[2];
typedef Unaligned     Unaligned4[2];

#define UNAL2(arg)       fromUNAL(arg)
#define toUNAL2(to,arg)  toUNAL(to,arg)

#define UNAL4(arg)       fromUNALLONG((Unaligned const FAR0 *)(arg))
#define toUNAL4(to,arg)  toUNALLONG(to,arg)

extern void toUNAL(unsigned char FAR0 *unal, unsigned short n);

extern unsigned short fromUNAL(unsigned char const FAR0 *unal);

extern void toUNALLONG(Unaligned FAR0 *unal, unsigned long n);

extern unsigned long fromUNALLONG(Unaligned const FAR0 *unal);

#else

typedef unsigned char LEushort[2];
typedef unsigned char LEulong[4];

#define LE2(arg)      fromLEushort(arg)
#define toLE2(to,arg) toLEushort(to,arg)
#define LE4(arg)      fromLEulong(arg)
#define toLE4(to,arg) toLEulong(to,arg)
#define COPY2(to,arg) copyShort(to,arg)
#define COPY4(to,arg) copyLong(to,arg)

#define Unaligned     LEushort
#define Unaligned4    LEulong

extern void toLEushort(unsigned char FAR0 *le, unsigned short n);

extern unsigned short fromLEushort(unsigned char const FAR0 *le);

extern void toLEulong(unsigned char FAR0 *le, unsigned long n);

extern unsigned long fromLEulong(unsigned char const FAR0 *le);

extern void copyShort(unsigned char FAR0 *to,
              unsigned char const FAR0 *from);

extern void copyLong(unsigned char FAR0 *to,
             unsigned char const FAR0 *from);

#define UNAL2        LE2
#define toUNAL2      toLE2

#define UNAL4        LE4
#define toUNAL4      toLE4

#endif /* FL_BIG_ENDIAN */

typedef LEulong LEmin;

#ifndef MTD_STANDALONE
#include "flsysfun.h"
#endif /* MTD_STANDALONE */

/*************************************************/
/* Use routines instead of 'c' standard librarys */
/*************************************************/

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
extern byte  flVerifyWrite[SOCKETS][MAX_TL_PARTITIONS<<1];
/* Vefrify write */
#define FL_UPS 2
/* 
 * See also FL_ON and FL_OFF
 */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

#ifdef ENVIRONMENT_VARS

typedef void FAR0 *  (NAMING_CONVENTION FAR0* cpyBuffer)(void FAR0 * ,const void FAR0 * ,size_t);
typedef void FAR0 *  (NAMING_CONVENTION FAR0* setBuffer)(void FAR0 * ,int ,size_t);
typedef int          (NAMING_CONVENTION FAR0* cmpBuffer)(const void FAR0 * ,const void FAR0 * ,size_t);

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
extern cpyBuffer tffscpy;
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
extern cmpBuffer tffscmp;
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
extern setBuffer tffsset;
#ifdef __cplusplus
}
#endif /* __cplusplus */

extern void FAR0* NAMING_CONVENTION FAR0 flmemcpy(void FAR0* dest,const void FAR0 *src,size_t count);
extern void FAR0* NAMING_CONVENTION FAR0 flmemset(void FAR0* dest,int cval,size_t count);
extern int  NAMING_CONVENTION FAR0 flmemcmp(const void FAR0* dest,const void FAR0 *src,size_t count);

/**********************************************/
/* Declare the TrueFFS environment variables  */
/**********************************************/

extern byte   flUse8Bit;
extern byte   flUseNFTLCache;
extern byte   flUseisRAM;

extern byte   flUseMultiDoc;
extern byte   flMTLdefragMode;
extern byte   flMaxUnitChain;
extern byte   flMarkDeleteOnFlash;
extern byte   flPolicy[SOCKETS][MAX_TL_PARTITIONS];
extern byte   flSuspendMode;

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
extern dword  flSectorsVerifiedPerFolding;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

/* Policies definitions (FL_SET_POLICY) */
#define FL_DEFAULT_POLICY             0
#define FL_COMPLETE_ASAP              1
/* Mtl policies defintions (FL_MTL_POLICY) */
#define FL_MTL_DEFRAGMENT_ALL_DEVICES 0
#define FL_MTL_DEFRAGMENT_SEQUANTIAL  1
/* Suspend mode other then FL_OF */
#define FL_SUSPEND_WRITE 1
#define FL_SUSPEND_IO    3


extern void flSetEnvVar(void);

#endif /* ENVIRONMENT_VARS */

#ifndef FL_NO_USE_FUNC
extern dword  flBusConfig[SOCKETS];
#endif /* FL_NO_USE_FUNC */

#ifdef MTD_STANDALONE

/* When the using the application standalone mode (mtdsa.h), the following routines can be */
/* used provided they are implemented in mtdsa.c file.                                       */

extern void flDelayMsecs(unsigned long msec);

extern void FAR0* flAddLongToFarPointer(void FAR0 *ptr, unsigned long offset);

#ifndef USE_STD_FUNC
/**********************************************/
/* Declare tffscpy, tffsset, tffscmp routines */
/* Not using the standard 'c' libraries.      */
/**********************************************/

extern void tffscpy(void FAR1 *dst, void FAR1 *src, unsigned len);
extern int  tffscmp(void FAR1 *s1, void FAR1 *s2, unsigned len);
extern void tffsset(void FAR1 *dst, unsigned char value, unsigned len);
#endif /* USE_STD_FUNC */

#endif /* MTD_STANDALONE */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flcustom.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Custom/FLCUSTOM.C_V  $
 *
 *    Rev 1.2   Feb 18 2001 23:42:04   oris
 * Moved flPolicy, flUseMultiDoc and flMaxUnitChain to blockdev.c.
 *
 *    Rev 1.1   Feb 14 2001 02:19:28   oris
 * Added flMaxUnitChain environment variable.
 * Changed flUseMultiDoc and flPolicy variables type and names.
 *
 *    Rev 1.0   Feb 04 2001 13:31:02   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*              FAT-FTL Lite Software Development Kit                   */
/*              Copyright (C) M-Systems Ltd. 1995-1998                  */
/*                                                                      */
/************************************************************************/

#include "flsystem.h"
#include "stdcomp.h"

/* environment variables */
#ifdef ENVIRONMENT_VARS

unsigned char flUse8Bit;
unsigned char flUseNFTLCache;
unsigned char flUseisRAM;

/*-----------------------------------------------------------------------*/
/*                 f l s e t E n v V a r                                 */
/*  Sets the value of all env variables                                  */
/*  Parameters : None                                                    */
/*-----------------------------------------------------------------------*/
void flSetEnvVar(void)
{
 flUse8Bit               = 0;
 flUseNFTLCache          = 1;
 flUseisRAM              = 0;
}

#endif /* ENVIRONMENT_VARS */

/*----------------------------------------------------------------------*/
/*            f l R e g i s t e r C o m p o n e n t s       */
/*                                  */
/* Register socket, MTD and translation layer components for use    */
/*                                  */
/* This function is called by FLite once only, at initialization of the */
/* FLite system.                            */
/*                                  */
/* Parameters:                                                          */
/*  None                                */
/*                                                                      */
/*----------------------------------------------------------------------*/

unsigned long window = 0L;

FLStatus
flRegisterComponents(void)
{
    flRegisterDOCSOC(window, window);

    #ifdef NT5PORT
    checkStatus(flRegisterNT5PCIC());
    #endif /*NT5PORT */

    flRegisterDOC2000();
    flRegisterDOCPLUS();

    checkStatus(flRegisterI28F008());   /* Register NOR-flash MTDs */
    checkStatus(flRegisterI28F016());

    checkStatus(flRegisterAMDMTD());
    checkStatus(flRegisterCFISCS());

    checkStatus(flRegisterINFTL());
    checkStatus(flRegisterNFTL());
    checkStatus(flRegisterFTL());

    return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flflash.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLFLASH.C_V  $
 * 
 *    Rev 1.12   Apr 15 2002 07:36:38   oris
 * Bug fix - do not initialize access routines in case of user defined routines - as a result docsys must be included.
 * 
 *    Rev 1.11   Jan 28 2002 21:24:38   oris
 * Changed memWinowSize to memWindowSize.
 * 
 *    Rev 1.10   Jan 17 2002 23:09:30   oris
 * Added flFlashOf() routine to allow the use of a single FLFlash record  per socket .
 * Added memory access routines initialization for FLFlash.
 * Bug fix - if M+ device was registered after 8-bit DiskOnChip and the M+  had a bad download problem , the error would not be reported, but only  flUnknown media.
 * 
 *    Rev 1.9   Sep 15 2001 23:46:00   oris
 * Changed erase routine to support up to 64K erase blocks.
 * 
 *    Rev 1.8   Jul 13 2001 01:04:38   oris
 * Added new field initialization in FLFlash record - Max Erase Cycles of the flash.
 * 
 *    Rev 1.7   May 16 2001 21:18:24   oris
 * Removed warnings.
 * 
 *    Rev 1.6   May 02 2001 06:41:26   oris
 * Removed the lastUsableBlock variable.
 * 
 *    Rev 1.5   Apr 24 2001 17:07:52   oris
 * Bug fix - missing NULL initialization for several compilation flags.
 * Added lastUsableBlock field defualt initialization.
 * 
 *    Rev 1.4   Apr 16 2001 13:39:14   oris
 * Bug fix read and write default routines were not initialized.
 * Initialize the firstUsableBlock.
 * Removed warrnings.
 * 
 *    Rev 1.3   Apr 12 2001 06:50:22   oris
 * Added initialization of download routine pointer.
 * 
 *    Rev 1.2   Apr 09 2001 15:09:04   oris
 * End with an empty line.
 * 
 *    Rev 1.1   Apr 01 2001 07:54:08   oris
 * copywrite notice.
 * Changed prototype of :flashRead.
 * Removed interface b initialization (experimental MTD interface for mdocp).
 * Spelling mistake "changableProtectedAreas".
 * Added check for bad download in flash recognition.
 *
 *    Rev 1.0   Feb 04 2001 11:21:16   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#include "flflash.h"
#include "docsys.h"

#define    READ_ID            0x90
#define    INTEL_READ_ARRAY        0xff
#define    AMD_READ_ARRAY        0xf0

/* MTD registration information */

int noOfMTDs = 0;

MTDidentifyRoutine mtdTable[MTDS];
static FLFlash vols[SOCKETS];

FLStatus dataErrorObject;

/*----------------------------------------------------------------------*/
/*                    f l F l a s h O f                   */
/*                                    */
/* Gets the flash connected to a volume no.                */
/*                                    */
/* Parameters:                                                          */
/*    volNo        : Volume no. for which to get flash        */
/*                                                                      */
/* Returns:                                                             */
/*     flash of volume no.                        */
/*----------------------------------------------------------------------*/

FLFlash *flFlashOf(unsigned volNo)
{
  return &vols[volNo];
}


/*----------------------------------------------------------------------*/
/*                      f l a s h M a p                */
/*                                    */
/* Default flash map method: Map through socket window.            */
/* This method is applicable for all NOR Flash                */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*      address        : Card address to map                */
/*    length        : Length to map (irrelevant here)        */
/*                                                                      */
/* Returns:                                                             */
/*    Pointer to required card address                */
/*----------------------------------------------------------------------*/

static void FAR0 *flashMap(FLFlash vol, CardAddress address, int length)
{
  return flMap(vol.socket,address);
}


/*----------------------------------------------------------------------*/
/*                      f l a s h R e a d                */
/*                                    */
/* Default flash read method: Read by copying from mapped address    */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*      address        : Card address to read                */
/*    buffer        : Area to read into                */
/*    length        : Length to read                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus flashRead(FLFlash vol,
            CardAddress address,
            void FAR1 *buffer,
            dword length,
            word mode)
{
  tffscpy(buffer,vol.map(&vol,address,(word)length),(word)length);

  return flOK;
}



/*----------------------------------------------------------------------*/
/*                   f l a s h N o W r i t e            */
/*                                    */
/* Default flash write method: Write not allowed (read-only mode)    */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*      address        : Card address to write                */
/*    buffer        : Area to write from                */
/*    length        : Length to write                */
/*                                                                      */
/* Returns:                                                             */
/*    Write-protect error                        */
/*----------------------------------------------------------------------*/

static FLStatus flashNoWrite(FLFlash vol,
               CardAddress address,
               const void FAR1 *from,
               dword length,
               word mode)
{
  return flWriteProtect;
}


/*----------------------------------------------------------------------*/
/*                   f l a s h N o E r a s e            */
/*                                    */
/* Default flash erase method: Erase not allowed (read-only mode)    */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*      firstBlock    : No. of first erase block            */
/*    noOfBlocks    : No. of contiguous blocks to erase        */
/*                                                                      */
/* Returns:                                                             */
/*    Write-protect error                        */
/*----------------------------------------------------------------------*/

static FLStatus flashNoErase(FLFlash vol,
               word firstBlock,
               word noOfBlocks)
{
  return flWriteProtect;
}

/*----------------------------------------------------------------------*/
/*                   s e t N o C a l l b a c k            */
/*                                    */
/* Register power on callback routine. Default: no routine is         */
/* registered.                                */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setNoCallback(FLFlash vol)
{
  flSetPowerOnCallback(vol.socket,NULL,NULL);
}

/*----------------------------------------------------------------------*/
/*                   f l I n t e l I d e n t i f y            */
/*                                    */
/* Identify the Flash type and interleaving for Intel-style Flash.    */
/* Sets the value of vol.type (JEDEC id) & vol.interleaving.            */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*    amdCmdRoutine    : Routine to read-id AMD/Fujitsu style at    */
/*              a specific location. If null, Intel procedure    */
/*              is used.                                      */
/*      idOffset    : Chip offset to use for identification        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/

void flIntelIdentify(FLFlash vol,
                     void (*amdCmdRoutine)(FLFlash vol, CardAddress,
                     unsigned char, FlashPTR),
                     CardAddress idOffset)
{
  int inlv;

  unsigned char vendorId = 0;
  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket,idOffset);
  unsigned char firstByte = 0;
  unsigned char resetCmd = amdCmdRoutine ? AMD_READ_ARRAY : INTEL_READ_ARRAY;

  for (inlv = 0; inlv < 15; inlv++) {    /* Increase interleaving until failure */
    flashPtr[inlv] = resetCmd;    /* Reset the chip */
    flashPtr[inlv] = resetCmd;    /* Once again for luck */
    if (inlv == 0)
      firstByte = flashPtr[0];     /* Remember byte on 1st chip */
    if (amdCmdRoutine)    /* AMD: use unlock sequence */
      amdCmdRoutine(&vol,idOffset + inlv, READ_ID, flashPtr);
    else
      flashPtr[inlv] = READ_ID;    /* Read chip id */
    if (inlv == 0)
      vendorId = flashPtr[0];    /* Assume first chip responded */
    else if (flashPtr[inlv] != vendorId || firstByte != flashPtr[0]) {
      /* All chips should respond in the same way. We know interleaving = n */
      /* when writing to chip n affects chip 0.                    */

      /* Get full JEDEC id signature */
      vol.type = (FlashType) ((vendorId << 8) | flashPtr[inlv]);
      flashPtr[inlv] = resetCmd;
      break;
    }
    flashPtr[inlv] = resetCmd;
  }

  if (inlv & (inlv - 1))
    vol.type = NOT_FLASH;        /* not a power of 2, no way ! */
  else
#ifndef NT5PORT
    vol.interleaving = inlv;
#else
		vol.interleaving = (Sword)inlv;
#endif /*NT5PORT*/

}


/*----------------------------------------------------------------------*/
/*                      i n t e l S i z e                */
/*                                    */
/* Identify the card size for Intel-style Flash.            */
/* Sets the value of vol.noOfChips.                    */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*    amdCmdRoutine    : Routine to read-id AMD/Fujitsu style at    */
/*              a specific location. If null, Intel procedure    */
/*              is used.                                      */
/*      idOffset    : Chip offset to use for identification        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/

FLStatus flIntelSize(FLFlash vol,
             void (*amdCmdRoutine)(FLFlash vol, CardAddress,
                       unsigned char, FlashPTR),
             CardAddress idOffset)
{
  unsigned char resetCmd = amdCmdRoutine ? AMD_READ_ARRAY : INTEL_READ_ARRAY;
  FlashPTR flashPtr = (FlashPTR) vol.map(&vol,idOffset,0);

  if (amdCmdRoutine)    /* AMD: use unlock sequence */
    amdCmdRoutine(&vol,0,READ_ID, flashPtr);
  else
    flashPtr[0] = READ_ID;
  /* We leave the first chip in Read ID mode, so that we can        */
  /* discover an address wraparound.                    */

  for (vol.noOfChips = 0;    /* Scan the chips */
       vol.noOfChips < 2000;  /* Big enough ? */
       vol.noOfChips += vol.interleaving) {
    int i;

    flashPtr = (FlashPTR) vol.map(&vol,vol.noOfChips * vol.chipSize + idOffset,0);

    /* Check for address wraparound to the first chip */
    if (vol.noOfChips > 0 &&
    (FlashType) ((flashPtr[0] << 8) | flashPtr[vol.interleaving]) == vol.type)
      goto noMoreChips;       /* wraparound */

    /* Check if chip displays the same JEDEC id and interleaving */
    for (i = (vol.noOfChips ? 0 : 1); i < vol.interleaving; i++) {
      if (amdCmdRoutine)    /* AMD: use unlock sequence */
    amdCmdRoutine(&vol,vol.noOfChips * vol.chipSize + idOffset + i,
              READ_ID, flashPtr);
      else
    flashPtr[i] = READ_ID;
      if ((FlashType) ((flashPtr[i] << 8) | flashPtr[i + vol.interleaving]) !=
      vol.type)
    goto noMoreChips;  /* This "chip" doesn't respond correctly, so we're done */

      flashPtr[i] = resetCmd;
    }
  }

noMoreChips:
  flashPtr = (FlashPTR) vol.map(&vol,idOffset,0);
  flashPtr[0] = resetCmd;        /* reset the original chip */

  return (vol.noOfChips == 0) ? flUnknownMedia : flOK;
}


/*----------------------------------------------------------------------*/
/*                           i s R A M                */
/*                                    */
/* Checks if the card memory behaves like RAM                */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*                                                                      */
/* Returns:                                                             */
/*    0 = not RAM-like, other = memory is apparently RAM        */
/*----------------------------------------------------------------------*/

static FLBoolean isRAM(FLFlash vol)
{
#ifndef NT5PORT
  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket,0);
  unsigned char firstByte = flashPtr[0];
  char writeChar = (firstByte != 0) ? 0 : 0xff;
  volatile int zero=0;
#else
  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket,0);
  unsigned char firstByte;
  char writeChar;
  volatile int zero=0;
  if(flashPtr == NULL){
	 DEBUG_PRINT(("Debug:isRAM(): NULL Pointer.\n"));
  }
  firstByte = flashPtr[0];
  writeChar = (firstByte != 0) ? 0 : 0xff;
#endif //NT5PORT
  flashPtr[zero] = writeChar;              /* Write something different */
  if (flashPtr[zero] == writeChar) {       /* Was it written ? */
    flashPtr[zero] = firstByte;            /* must be RAM, undo the damage */

    DEBUG_PRINT(("Debug: error, socket window looks like RAM.\r\n"));
    return TRUE;
  }
  return FALSE;
}


/*----------------------------------------------------------------------*/
/*                  f l I d e n t i f y F l a s h            */
/*                                    */
/* Identify the current Flash medium and select an MTD for it        */
/*                                    */
/* Parameters:                                                          */
/*    socket        : Socket of flash                */
/*    vol        : New volume pointer                */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 = Flash was identified            */
/*              other = identification failed                 */
/*----------------------------------------------------------------------*/

FLStatus flIdentifyFlash(FLSocket *socket, FLFlash vol)
{
  FLStatus status = flUnknownMedia;
  int iMTD;
  dword blockSize;

  vol.socket = socket;

#ifndef FIXED_MEDIA
  /* Check that we have a media */
  flResetCardChanged(vol.socket);        /* we're mounting anyway */
  checkStatus(flMediaCheck(vol.socket));
#endif

#ifdef ENVIRONMENT_VARS
   if(flUseisRAM==1)
   {
#endif
     if ( isRAM(&vol))
       return flUnknownMedia;    /* if it looks like RAM, leave immediately */
#ifdef ENVIRONMENT_VARS
   }
#endif

  /* Install default methods */
  vol.type                   = NOT_FLASH;
  vol.mediaType              = NOT_DOC_TYPE;
  vol.pageSize               = 0;
  vol.flags                  = 0;
  vol.map                    = flashMap;
  vol.read                   = flashRead;
  vol.setPowerOnCallback     = setNoCallback;
  vol.erase                  = flashNoErase;
  vol.write                  = flashNoWrite;
  vol.readBBT                = NULL;
  vol.writeIPL               = NULL;
  vol.readIPL                = NULL;
#ifdef HW_OTP
  vol.otpSize                = NULL;
  vol.readOTP                = NULL;
  vol.writeOTP               = NULL;
  vol.getUniqueId            = NULL;
#endif /* HW_OTP */
#ifdef  HW_PROTECTION
  vol.protectionBoundries    = NULL;
  vol.protectionKeyInsert    = NULL;
  vol.protectionKeyRemove    = NULL;
  vol.protectionType         = NULL;
  vol.protectionSet          = NULL;
#endif /* HW_PROTECTION */
  vol.download               = NULL;
  vol.enterDeepPowerDownMode = NULL;
#ifndef FL_NO_USE_FUNC
  if(flBusConfig[flSocketNoOf(socket)] != FL_ACCESS_USER_DEFINED);
  {
     vol.memRead                = NULL;
     vol.memWrite               = NULL;
     vol.memSet                 = NULL;
     vol.memRead8bit            = NULL;
     vol.memWrite8bit           = NULL;
     vol.memRead16bit           = NULL;
     vol.memWrite16bit          = NULL;
     vol.memWindowSize          = NULL;
  }
#endif /* FL_NO_USE_FUNC */
  /* Setup arbitrary parameters for read-only mount */
  vol.chipSize                 = 0x100000L;
  vol.erasableBlockSize        = 0x1000L;
  vol.noOfChips                = 1;
  vol.interleaving             = 1;
  vol.noOfFloors               = 1;
  vol.totalProtectedAreas      = 0;
  vol.changeableProtectedAreas = 0;
  vol.ppp                      = 5;
  vol.firstUsableBlock         = 0;
  vol.maxEraseCycles           = 100000L; /* Defaul for NOR */

#ifdef NT5PORT
  vol.readBufferSize = 0;
  vol.readBuffer = NULL;
#endif  /*NT5PORT*/


  /* Attempt all MTD's */
  for (iMTD = 0; (iMTD < noOfMTDs) && (status != flOK) &&
       (status != flBadDownload); iMTD++)
    status = mtdTable[iMTD](&vol);

  if (status == flBadDownload)
  {
    DEBUG_PRINT(("Debug: Flash media reported bad download error.\r\n"));
    return flBadDownload;
  }

  if (status != flOK) /* No MTD recognition */
  {
    DEBUG_PRINT(("Debug: did not identify flash media.\r\n"));
    return flUnknownMedia;
  }

  /* Calculate erasable Block Size Bits */
  for(blockSize = vol.erasableBlockSize>>1,vol.erasableBlockSizeBits = 0;
      blockSize>0; vol.erasableBlockSizeBits++,blockSize = blockSize >> 1);

  return flOK;


}


#ifdef NT5PORT
VOID * mapThroughBuffer(FLFlash vol, CardAddress address, LONG length)
{
  if ((ULONG) length > vol.readBufferSize) {
    vol.readBufferSize = 0;
    if (vol.readBuffer) {
	FREE(vol.readBuffer);
    }
    vol.readBuffer = MALLOC(length);
    if (vol.readBuffer == NULL) {
      return vol.readBuffer;
    }
    vol.readBufferSize = length;
  }
  vol.read(&vol,address,vol.readBuffer,length,0);
  return vol.readBuffer;
}
#endif /* NT5PORT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flformat.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLFORMAT.H_V  $
 * 
 *    Rev 1.9   Apr 15 2002 07:36:52   oris
 * Bug fix - Standard format was changed
 *  - includes only 1 Disk partitions and not 2.
 *  - leave 2 spare units in case power failure occurs while writing into the last unit.
 * 
 *    Rev 1.8   Feb 19 2002 20:59:52   oris
 * Changed default spare units to 2
 * 
 *    Rev 1.7   Jan 21 2002 20:44:44   oris
 * Changed comments.
 * 
 *    Rev 1.6   Sep 15 2001 23:46:24   oris
 * Changed progress callback routine to support up to 64K units.
 * 
 *    Rev 1.5   Jun 17 2001 08:18:54   oris
 * Changed exbFlag field to word
 * Added typedef FLStatus (*FLProgressCallback)(int totalUnitsToFormat, int totalUnitsFormattedSoFar);
 * 
 *    Rev 1.4   Apr 16 2001 13:42:22   oris
 * Removed warrnings by changing some of the fields types.
 * 
 *    Rev 1.3   Apr 01 2001 07:54:42   oris
 * copywrite notice.
 * Spelling mistake "changable".
 * Compression parameters were changed in order to prevent floating point math.
 * 
 *    Rev 1.2   Feb 18 2001 12:03:32   oris
 * Added TL_OLD_FORMAT defintion.
 *
 *    Rev 1.1   Feb 13 2001 01:44:40   oris
 * Moved the TL_FORMAT_COMPRESSION and TL_FORMAT_FAT defintion from blockdev.h
 *
 *    Rev 1.0   Feb 02 2001 13:57:58   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : flformat.h                                                          *
*                                                                            *
* Description : This file contains data strucutres passed to the format      *
*               routines.                                                    *
*                                                                            *
* Note : If dos format is also needed include dosformt.h instead             *
*                                                                            *
*****************************************************************************/

#ifndef FORMAT_H
#define FORMAT_H

#include "flbase.h"

/*********************************************/
/* Formatting parameter structure definition */
/*********************************************/

/*----------------------------------------------*/
/* User BDTL Partition Format Parameters record */
/*----------------------------------------------*/

typedef struct {
dword   length;
        /* The size of the usable storage space. The size will be
           rounded upwards to a multiplication of a block size.
           The size of the last partition will calculated automatically,
           but if the requested size is greater then the remaining space
           an error code will be returned,. Requesting zero size for any
	   partition but the last will generate an flBadParameters status. */

unsigned        noOfSpareUnits;
        /* BDTL needs at least one spare erase unit in order to function
           as a read/write media. It is possible to specify more than one
           spare unit, which takes more media space. The advantage of
           specifying more than one spare unit is that if one of the flash
           erase units becomes bad and inerasable in the future, then one
           of the spare units can replace it. In that case, a second spare
           unit enables TrueFFS to continue its read/write functionality,
           whereas if no second spare unit is available the media goes into
           read-only mode. The standard value used is 1 */

byte   flags;

#define TL_FORMAT_COMPRESSION  1  /* Add ZIP format on the media      */
#define TL_FORMAT_FAT          2  /* Add FAT format on the media      */
#define TL_OLD_FORMAT          4  /* Format with 1 sector per cluster */

byte            volumeId[4];  /* DOS partition identification number		  */

byte FAR1 *     volumeLabel;  /*DOS partition label string. If NULL, no label */

byte         noOfFATcopies;
        /* It is customary to format DOS media with two FAT copies. The
           first copy is always used, but more copies make it possible
           to recover if the FAT becomes corrupted (a rare occurrence).
           On the other hand, this slows down performance and uses media
           space. The standard value used is 2. */
#ifdef HW_PROTECTION
byte   protectionKey[8];   /* The key for the protection*/
byte   protectionType;
       /* PROTECTABLE          - Can recieve protection           */
       /* READ_PROTECTED       - Protect against read operations  */
       /* WRITE_PROTECTED      - Protect against write operations */
       /* LOCK_ENABLED         - Enables the hardware lock signal */
       /* PROTECTABLE          - This partition can be protected  */
       /* CHANGEABLE_PROTECTION - protection type can be changed */
#endif /* HW_PROTECTION */
#ifdef COMPRESSION
  word          ratioDenominator;
  word          ratioNominator;
#endif /* COMPRESSION */
       /* The ratio between the real media size and the virtual size
          reported to the file system when compression is active. */
} BDTLPartitionFormatParams;

/*------------------------------------------------*/
/* User binary Partition Format Parameters record */
/*------------------------------------------------*/

typedef struct {
dword length;	/* Required number of good blocks in the  partition.*/

byte sign[4];	/* signature of the binary  partition to format. 
                   The signature 0xFFFF FFFF is not a valid signature */

byte signOffset;
	/* offset of the signature. This value should  always be 8, but it
	   can also accept 0 for backwards compatibility reasons. Note that
	   if the offset is 0 EDC\ECC is neutralized */
#ifdef HW_PROTECTION
byte   protectionKey[8];   /* The key for the protection*/
byte   protectionType;
       /* PROTECTABLE          - Can recieve protection           */
       /* READ_PROTECTED       - Protect against read operations  */
       /* WRITE_PROTECTED      - Protect against write operations */
       /* LOCK_ENABLED         - Enables the hardware lock signal */
       /* PROTECTABLE          - This partition can be protected  */
       /* CHANGEABLE_PROTECTION - protection type can be changed */
#endif /* HW_PROTECTION */
} BinaryPartitionFormatParams;


/*-----------------------------------------------------------------*/
/* User Format Parameters record for flFormatPhysicalDrive routine */
/*-----------------------------------------------------------------*/

typedef FLStatus (*FLProgressCallback)(word totalUnitsToFormat, word totalUnitsFormattedSoFar);

typedef struct {

/*****************************/
/* Device formatting section */
/*****************************/

byte        percentUse;
     	/* BDTL performance depends on how full the flash media is,
		   becoming slower as the media becomes closer to 100% full.
		   It is possible to avoid the worst-case performance
		   (at 100% full) by formatting the media to less than 100%
		   capacity, thus guaranteeing free space at all times. This
		   of course sacrifices some capacity. The standard value
		   used is 98 */

byte             noOfBDTLPartitions;
		/* Indicates the number of BDTL partitions (1 to 4). 0 will
           cause a single STD_BDTL_PARAMS BDTL partition */

byte             noOfBinaryPartitions;
       /* Indicates the number of binary partitions (up to 3). 0 will
	      cause formatting with no binary partition. This value is ignored
	  unless the TL_BINARY_FORMAT flag is set in the irFlags f the ioreq */

BDTLPartitionFormatParams   FAR2* BDTLPartitionInfo;
       /* BDTL partition information array  */

BinaryPartitionFormatParams FAR2* binaryPartitionInfo;
       /* Binary partition information array*/

/***********************************/
/* Special format features section */
/***********************************/

#ifdef WRITE_EXB_IMAGE

void FAR1 *     exbBuffer;
	/* A buffer containing the EXB file. Optionaly this file can
	   contain only the first 512 bytes of the file while the rest
	   will be sent using consequitive calls to flPlaceExbByBuffer */

dword           exbBufferLen;     /* Size of the given EXB buffer */

dword           exbLen; /* The specific size to leave for the EXB */

word            exbWindow; /* Set explicit DiskOnChip window base */

word            exbFlags;  /* For the flags list see doc2exb.h */

#endif /* WRITE_EXB_IMAGE */

byte            cascadedDeviceNo;    /* Not used */

byte            noOfCascadedDevices; /* Not used */

FLProgressCallback progressCallback;
	/* Progress callback routine, will be called if not NULL.
	   The callback routine is called after erasing each unit,
	   and its parameters are the total number of erase units
	   to format and the number erased so far.
	   The callback routine returns a Status value. A value of
	   OK (0) allows formatting to continue. Any other value
	   will abort the formatting with the returned status code. */

/* Note the following section is not used by for DiskOnChips */
/*************************************************************/

dword        	vmAddressingLimit;
	    /* A part of the FTL Virtual Map always resides in RAM. The
	       RAM part is the one that is used to address the part of
	       the media below the VM addressing limit. Reading and
		   writing to this part is usually faster to some degree.
		   The downside is that the bigger the limit, the more RAM
		   size is required.
		   To get the extra RAM requirement in bytes, divide the
		   limit by 128 or by 256, depending on whether you
		   specified in #2.9 more than 32 or not, respectively.
		   The minimum VM limit is 0.
		   The standard value to use is 0x10000 (first 64 KBytes) */

word	    embeddedCISlength;
		/* Length in bytes of CIS to embed after the unit header */

byte FAR1 *	    embeddedCIS;
		/* The unit header is structured as a beginning of a PCMCIA
		   'tuple' chain (a CIS). The unit header contains a
		   data-organization tuple, which points past the end of the
		   unit header to a location which usually just contains
		   hex FF's which mark an 'end-of-tuple-chain'. Optionally,
		   it is possible to embed an entire CIS chain at this
		   location. If so, 'embeddedCISlength' marks the length in
		   bytes */
} FormatParams2;

/*----------------------------------------------------------*/
/* User Format Parameters record for flFormatVolume routine */
/*----------------------------------------------------------*/

typedef struct {
  /* FTL formatting section */
  long int	bootImageLen;
		/* Space to reserve for a boot-image at the start of the
		   medium. The FLite volume will begin at the next higher
		   erase unit boundary */

  unsigned	percentUse;
		/* FTL performance depends on how full the Flash media is,
		   getting slower when the media is close to 100%. It is
		   possible to avoid the worst consequences of this effect by
		   formatting the media to less than 100% capacity, so
		   guaranteeing some free space at all times. This of course
		   sacrifices some capcity.
		   The standard value to use is 98 */

  unsigned	noOfSpareUnits;
		/* BDTL partitions needs at least one spare erase unit to function as
           a read/write media. That unit is normally taken from the transfer
           units specified by the percentUsed field, but it is possible to 
           specify additional units (which takes more media space). This 
           ensures that if all the transfer units become bad and inerasable,
           the spare unit enables TrueFFS to continue its read/write
           functionality. Conversely, if no spare units are available the
           media may switch into read-only mode. The standard value used is 1 */


  dword	    vmAddressingLimit;
		/* A part of the FTL Virtual Map always resides in RAM. The
		   RAM part is the one that is used to address the part of
		   the media below the VM addressing limit. Reading and
		   writing to this part is usually faster to some degree.
		   The downside is that the bigger the limit, the more RAM
		   size is required.
		   To get the extra RAM requirement in bytes, divide the
		   limit by 128 or by 256, depending on whether you
		   specified in #2.9 more than 32 or not, respectively.
		   The minimum VM limit is 0.
		   The standard value to use is 0x10000 (first 64 KBytes) */


FLProgressCallback progressCallback;
		/* Progress callback routine, will be called if not NULL.
		   The callback routine is called after erasing each unit,
		   and its parameters are the total number of erase units
		   to format and the number erased so far.
		   The callback routine returns a Status value. A value of
		   OK (0) allows formatting to continue. Any other value
		   will abort the formatting with the returned status code. */

  /* DOS formatting section */
  char		volumeId[4];
		/* Volume identification number */

  char FAR1 *	volumeLabel;
		/* Volume label string. If NULL, no label */

  unsigned 	noOfFATcopies;
		/* It is customary to format DOS media with 2 FAT copies.
		   The first copy is always used, but more copies make it
		   possible to recover if the FAT becomes corrupted (a
		   rare occurrence). On the other hand, this slows down
		   performance and uses media space.
		   The standard value to use is 2 */

  unsigned	embeddedCISlength;
		/* Length in bytes of CIS to embed after the unit header */

  char FAR1 *	embeddedCIS;
		/* The unit header is structured as a beginning of a PCMCIA
		   'tuple' chain (a CIS). The unit header contains a
		   data-organization tuple, which points past the end of the
		   unit header to a location which usually just contains
		   hex FF's which mark an 'end-of-tuple-chain'. Optionally,
		   it is possible to embed an entire CIS chain at this
		   location. If so, 'embeddedCISlength' marks the length in
		   bytes */

} FormatParams;

/*----------------------------------------------------------*/
/* Format Parameters record passed to the translation layer */
/*----------------------------------------------------------*/

typedef struct {

  /* Global device info */

  Sdword	  bootImageLen;

  byte            percentUse;

  byte            noOfBDTLPartitions;

  byte            noOfBinaryPartitions;

  BDTLPartitionFormatParams   FAR2* BDTLPartitionInfo;

  BinaryPartitionFormatParams FAR2* binaryPartitionInfo;

  byte            flags;

  /* First volume info */

#ifdef HW_PROTECTION
  byte            protectionKey[8];

  byte            protectionType;
#endif /* HW_PROTECTION */
#ifdef COMPRESSION
  word            ratioDenominator;
  word            ratioNominator;
#endif /* COMPRESSION */

  byte            noOfSpareUnits;

  byte        	  volumeId[4];

  byte FAR1 *	  volumeLabel;

  byte            noOfFATcopies;

  /* Special features */

#ifdef WRITE_EXB_IMAGE

  Sdword          exbLen;

#endif /* WRITE_EXB_IMAGE */

  byte            cascadedDeviceNo;

  byte            noOfCascadedDevices;

  FLProgressCallback progressCallback;

  dword           osakVersion;

  /* None DiskOnChip parameters */

  dword           vmAddressingLimit;

  word            embeddedCISlength;

  byte FAR1 *	  embeddedCIS;

} TLFormatParams;

#define BINARY_SIGNATURE_NAME 4
#define BINARY_SIGNATURE_LEN  8
#define SIGN_SPL       ""

/* Standard initializer for BDTLPartitionFormatParams structure */

#ifdef HW_PROTECTION
#ifdef COMPRESSION
#define STD_BDTL_PARAMS {0,2,TL_FORMAT_FAT,{0,0,0,0},NULL,2,{0,0,0,0,0,0,0,0},0,0,2}
#else
#define STD_BDTL_PARAMS {0,2,TL_FORMAT_FAT,{0,0,0,0},NULL,2,{0,0,0,0,0,0,0,0},0}
#endif /* COMPRESSION */
#else
#ifdef COMPRESSION
#define STD_BDTL_PARAMS {0,2,TL_FORMAT_FAT,{0,0,0,0},NULL,2,0,2}
#else
#define STD_BDTL_PARAMS {0,2,TL_FORMAT_FAT,{0,0,0,0},NULL,2}
#endif /* COMPRESSION */
#endif /* HW_PROTECTION */

/* Standard initializer for BinaryPartitionFormatParams structure */

#ifdef HW_PROTECTION
#define STD_BINARY_PARAMS {0,{'B','I','P','O'},8,{0,0,0,0,0,0,0,0},0}
#else
#define STD_BINARY_PARAMS {0,{'B','I','P','O'},8}
#endif /* HW_PROTECTION */

/* Standard initializer for FormatParams2 structure */

#ifdef WRITE_EXB_IMAGE
#define STD_FORMAT_PARAMS2 {98,1,0,NULL,NULL,NULL,0,0,0,0,0,0,NULL,0x10000l,0,NULL}
#else
#define STD_FORMAT_PARAMS2 {98,1,0,NULL,NULL,0,0,NULL,0x10000l,0,NULL}
#endif /* WRITE_EXB_IMAGE */

/* Standard initializer for FormatParams structure */

#define STD_FORMAT_PARAMS	{-1, 98, 2, 0x10000l, NULL, {0,0,0,0}, NULL, 2, 0, NULL}

#endif /* FORMAT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flflash.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLFLASH.H_V  $
 * 
 *    Rev 1.17   Apr 15 2002 07:36:44   oris
 * Removed the use of NDOC2window  in access routine interface.
 * FL_NO_USE_FUNC now removes all of the access routines pointers.
 * 
 *    Rev 1.16   Feb 19 2002 20:59:44   oris
 * Bug fix changed definition of FL_IPL_MODE_XSCALE from 3 to 4.
 * 
 *    Rev 1.15   Jan 29 2002 20:08:26   oris
 * Changed FLAccessStruct definition to prevent compilation errors.
 * Added FL_IPL_MODE_XSCALE definition and change FL_IPL_XXX values.
 * 
 *    Rev 1.14   Jan 28 2002 21:24:48   oris
 * Added FL_IPL_DOWNLOAD flag to writeIPL routine in order to control whether the IPL will be reloaded after the update.
 * Added FLAccessStruct definition - used to get and set DiskOnChip memory access routines.
 * Removed win_io field from FLFlash record.
 * 
 *    Rev 1.13   Jan 23 2002 23:31:34   oris
 * Missing declaration of globalReadBack buffer, when MTD_RECONSTRUCT is defined.
 * 
 *    Rev 1.12   Jan 21 2002 20:44:32   oris
 * Bug fix - PARTIAL_EDC flag was support to incorporate EDC flag.
 * 
 *    Rev 1.11   Jan 20 2002 09:44:00   oris
 * Bug fix - changed include directive of flBuffer.h  to flbuffer.h
 * 
 *    Rev 1.10   Jan 17 2002 23:01:28   oris
 * Added flFlashOf() prototype.
 * New memory access routines mechanism :
 *  - Added memory access routines pointers in FLFlash.
 *  - Added win_io and win fields to FLFlash record pointing to DiskOnChip IO registers and window base.
 *  - Added busAccessType.
 * Moved CardAddress typedef and NDOC2window typedefs from flbase.h
 * Added DiskOnChip Millennium Plus 16MB type MDOCP_16_TYPE.
 * Added the following definitions FL_IPL_MODE_NORMAL / FL_IPL_MODE_SA /  MAX_PROTECTED_PARTITIONS /MAX_SECTORS_PER_BLOCK
 * Added Another flag to writeIPL for Strong Arm mode.
 * 
 *    Rev 1.9   Sep 15 2001 23:46:08   oris
 * Changed erase routine to support up to 64K erase blocks.
 * Added reconstruct flag to readBBT routine - stating whether to reconstruct BBT if it is not available.
 * 
 *    Rev 1.8   Jul 13 2001 01:04:48   oris
 * Added include directive to flBuffer and readBack buffer forward definition under the MTD_STANDALONE compilation flag.
 * Added volNo field to the socket record under the MTD_STANDALONE compilation flag.
 * Added definition for PARTIAL_EDC flash read mode.
 * Added protection default key.
 * Added bad block marking in the BBT (BBT_BAD_UNIT).
 * Moved syndrome length definition to reedsol files.
 * Added new field in FLFlash record - Max Erase Cycles of the flash.
 * Changed interleave field in FLFlash record to signed.
 *
 *    Rev 1.7   May 16 2001 21:18:30   oris
 * Moved SYNDROM_BYTES definition from diskonc.h and mdocplus.h.
 * Added forward definition for saveSyndromForDumping global EDC\ECC syndrome buffer.
 * Changed DATA definition to FL_DATA.
 *
 *    Rev 1.6   May 02 2001 06:40:58   oris
 * Removed the lastUsableBlock variable.
 * Added the BBT_UNAVAIL_UNIT defintion.
 *
 *    Rev 1.5   Apr 24 2001 17:08:12   oris
 * Added lastUsableBlock field and changed firstUsableBlock type to dword.
 *
 *    Rev 1.4   Apr 16 2001 13:40:48   oris
 * Added firstUsableBlock.
 * Removed warrnings by changing some of the fields types.
 *
 *    Rev 1.3   Apr 12 2001 06:51:12   oris
 * Changed protectionBounries and protectionSet routine to be floor specific.
 * Changed powerdown prototype.
 * Added download prototype.
 *
 *    Rev 1.2   Apr 01 2001 07:54:24   oris
 * copywrite notice.
 * Moved protection attributes definition from mdocplus.h
 * Changed prototype of routine pointers in flflash struct :read,write routines to dword length.
 * Other routine pointer prototypes have been changed as well.
 * Removed interface b routine pointers from flflash struct (experimental MTD interface for mdocp).
 * Changed prototype of :read,write routine to enabled dword length.
 * Changed unsigned char to byte.
 * Changed unsigned long to dword.
 * Changed long int to Sdword.
 * Spelling mistake "changable".
 *
 *    Rev 1.1   Feb 13 2001 01:37:38   oris
 * Changed ENTER_DEEP_POWER_DOWN_MODE to DEEP_POWER_DOWN
 * Changed LOCKED to LOCKED_OTP
 *
 *    Rev 1.0   Feb 04 2001 11:30:44   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef FLFLASH_H
#define FLFLASH_H

#include "flbase.h"
#ifndef MTD_STANDALONE
#include "flsocket.h"
#else
#include "flbuffer.h" /* defintion for READ_BACK_BUFFER_SIZE */

  typedef struct tSocket FLSocket;
  struct tSocket
  {
    unsigned      volNo;   /* Volume no. of socket */
    void FAR0 *   base;    /* Pointer to window base */
    Sdword        size;    /* Window size (must by power of 2) */
  };

#if (defined (VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT))
extern byte globalReadBack[SOCKETS][READ_BACK_BUFFER_SIZE];
#endif /* VERIFY_WRITE */

extern FLSocket *flSocketOf(unsigned volNo);
extern FLBuffer  globalMTDBuffer;
extern int       noOfMTDs;

/* Replacement for various TrueFFS typedefs */

typedef unsigned long CardAddress;        /* Physical offset on card */

#endif /* MTD_STANDALONE */

/* Some useful types for mapped Flash locations */

typedef volatile byte FAR0 * FlashPTR;
typedef volatile unsigned short int FAR0 * FlashWPTR;
typedef volatile dword FAR0 * FlashDPTR;
typedef unsigned short FlashType;        /* JEDEC id */
typedef volatile unsigned char FAR0* NDOC2window;

/* DiskOnChip memory access routines type defintions */

/* Doc memory read routine         */
typedef  void (FLMemRead)(volatile byte FAR1* win,word regOffset,byte FAR1* dest,word count);
/* Doc memory write routine        */
typedef  void (FLMemWrite)(volatile byte FAR1* win,word regOffset,byte FAR1* src,word count);
/* Doc memory set routine          */
typedef  void (FLMemSet)(volatile byte FAR1* win,word regOffset,word count, byte val);
/* Doc memory 8 bit read routine   */
typedef  byte (FLMemRead8bit)(volatile byte FAR1* win,word offset);
/* Doc memory 8 bit write routine  */
typedef  void (FLMemWrite8bit)(volatile byte FAR1* win,word offset,byte Data);
/* Doc memory 16 bit read routine  */
typedef  word (FLMemRead16bit)(volatile byte FAR1* win,word offset);
/* Doc memory 16 bit write routine */
typedef  void (FLMemWrite16bit)(volatile byte FAR1* win,word offset,word Data);
/* Doc memory window size */
typedef  dword (FLMemWindowSize)(void);

typedef struct {        /* DiskOnChip memory access routines */
  dword                 access; /* Output only */
  FLMemRead       FAR1* memRead;
  FLMemWrite      FAR1* memWrite;
  FLMemSet        FAR1* memSet;
  FLMemRead8bit   FAR1* memRead8bit;
  FLMemWrite8bit  FAR1* memWrite8bit;
  FLMemRead16bit  FAR1* memRead16bit;
  FLMemWrite16bit FAR1* memWrite16bit;
  FLMemWindowSize FAR1* memWindowSize;
}FLAccessStruct;

#define NOT_FLASH          0

/* Media types */
#define NOT_DOC_TYPE       0
#define DOC_TYPE           1
#define MDOC_TYPE          2
#define DOC2000TSOP_TYPE   3
#define MDOCP_TYPE         4
#define MDOCP_16_TYPE      5

/* page characteristics flags */
#define  BIG_PAGE    0x0100             /* page size > 100H*/
#define  FULL_PAGE   0x0200                  /* no partial page programming*/
#define  BIG_ADDR    0x0400             /* 4 byte address cycle */

/* MTD write routine mode flags */
#define FL_DATA       0      /* Read/Write data area                */
#define OVERWRITE     1      /* Overwriting non-erased area         */
#define EDC           2      /* Activate ECC/EDC                    */
#define EXTRA         4      /* Read/write spare area               */
#define PARTIAL_EDC   10     /* Read with EDC even for partial page */
#define NO_SECOND_TRY 0x8000 /* do not read again on EDC error      */

/* Protection attributes */

#define PROTECTABLE           1  /* partition can recieve protection */
#define READ_PROTECTED        2  /* partition is read protected      */
#define WRITE_PROTECTED       4  /* partition is write protected     */
#define LOCK_ENABLED          8  /* HW lock signal is enabled        */
#define LOCK_ASSERTED         16 /* HW lock signal is asserted       */
#define KEY_INSERTED          32 /* key is inserted (not currently   */
#define CHANGEABLE_PROTECTION 64 /* changeable protection area type   */

/* protection specific defintions */
#define DO_NOT_COMMIT_PROTECTION 0 /* The new values will take affect only after reset */
#define COMMIT_PROTECTION        1 /* The new values will take affect imidiatly        */
#define PROTECTION_KEY_LENGTH    8 /* Size of protection key in bytes    */  
#define MAX_PROTECTED_PARTITIONS 2 /* Max Number of protected partitiosn */
#define DEFAULT_KEY              "00000000"

/* IPL modes */
#define FL_IPL_MODE_NORMAL 0 /* IPL - Written as usual                     */
#define FL_IPL_DOWNLOAD    1 /* IPL - Force download of new IPL            */
#define FL_IPL_MODE_SA     2 /* IPL - Written with Strong Arm mode enabled */
#define FL_IPL_MODE_XSCALE 4 /* IPL - Written with X-Scale mode enabled    */

/* OTP specific defintions */
#define CUSTOMER_ID_LEN          4
#define UNIQUE_ID_LEN            16

/* BBT block types */
#define BBT_GOOD_UNIT            0xff
#define BBT_UNAVAIL_UNIT         0x1
#define BBT_BAD_UNIT             0x0

/* General purpose */
#define MAX_SECTORS_PER_BLOCK    64

/*----------------------------------------------------------------------*/
/*                 Flash array identification structure                 */
/*                                                                      */
/* This structure contains a description of the Flash array and         */
/* routine pointers for the map, read, write & erase functions.         */
/*                                                                      */
/* The structure is initialized by the MTD that identifies the Flash    */
/* array.                                                               */
/* On entry to an MTD, the Flash structure contains default routines    */
/* for all operations. This routines are sufficient forread-only access */
/* to NOR Flash on a memory-mapped socket. The MTD should override the  */
/* default routines with MTD specific ones when appropriate.            */
/*----------------------------------------------------------------------*/

/* Flash array identification structure */

typedef struct tFlash FLFlash;                /* Forward definition */

struct tFlash {
  FlashType type;                 /* Flash device type (JEDEC id)           */
  byte      mediaType;            /* see media types obove                  */
  byte      ppp;                  /* number of allowed PPP                  */
  dword busAccessType;            /* saves bus access type                  */
  dword maxEraseCycles;           /* erase cycles limit per erase block     */
  dword changeableProtectedAreas; /* areas capable of changing protection   */
                                  /* attribute with no danger of loosing    */
                                  /* the entire chip                        */
  byte   totalProtectedAreas;     /* total number of protection arweas      */
  dword  erasableBlockSize;       /* Smallest physically erasable size      */
                                  /* (with interleaving taken into account) */
  byte      erasableBlockSizeBits;/* Bits representing the erasable block   */
  dword     chipSize;          /* chip size                                 */
  byte      noOfFloors;        /* no of controllers in array                */
  word      pageSize;          /* size of flash page in bytes               */
  word      noOfChips;         /* no of chips in array                      */
  dword     firstUsableBlock;  /* Some devices may not use all of the media */
                               /* blocks. For example mdocplus can not use  */
                               /* the first 3 blocks.                       */
  Sword     interleaving;      /* chip interleaving (The interleaving is    */
                               /* defined as the address difference between */
                               /* two consecutive bytes on a chip)          */
  word      flags;             /* Special capabilities & options Bits 0-7   */
                               /* may be used by FLite. Bits 8-15 are not   */
                               /* used bt FLite and may beused by MTD's for */
                               /* MTD-specific purposes.                    */
  /* Flag bit values */

#define SUSPEND_FOR_WRITE        1        /* MTD provides suspend for write */
#define NFTL_ENABLED             2        /* Flash can run NFTL             */
#define INFTL_ENABLED            4        /* Flash can run INFTL            */
#define EXTERNAL_EPROM           8        /* Can support external eprom     */

  void *    mtdVars;           /* Points to MTD private area for this socket.*/
                               /* This field, if used by the MTD, is         */
                               /* initialized bythe MTD identification       */
                               /* routine.                                   */
  FLSocket * socket;           /* Socket of this drive. Note that 2 diffrent */
                               /* records are used. One for OSAK and the     */
                               /* other forstandalone applications.          */
  NDOC2window win;             /* DiskOnChip memory windows                  */


#ifdef NT5PORT
  ULONG readBufferSize;
  VOID * readBuffer;
#endif /*NT5PORT*/

  
/*----------------------------------------------------------------------*/
/*                        f l a s h . m a p                             */
/*                                                                      */
/* MTD specific map routine                                             */
/*                                                                      */
/* The default routine maps by socket mapping, and is suitable for all  */
/* NOR Flash.                                                           */
/* NAND or other type Flash should use map-through-copy emulation: Read */
/* a block of Flash to an internal buffer and return a pointer to that  */
/* buffer.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      address            : Card address to map                        */
/*      length             : Length to map                              */
/*                                                                      */
/* Returns:                                                             */
/*        Pointer to required card address                              */
/*----------------------------------------------------------------------*/
  void FAR0 * (*map)(FLFlash *, CardAddress, int);

/*----------------------------------------------------------------------*/
/*                        f l a s h . r e a d                           */
/*                                                                      */
/* MTD specific Flash read routine                                      */
/*                                                                      */
/* The default routine reads by copying from a mapped window, and is    */
/* suitable for all NOR Flash.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      address            : Card address to read                       */
/*      buffer             : Area to read into                          */
/*      length             : Length to read                             */
/*      modes              : See write mode flags definition above      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*read)(FLFlash *, CardAddress, void FAR1 *, dword, word);

/*----------------------------------------------------------------------*/
/*                       f l a s h . w r i t e                          */
/*                                                                      */
/* MTD specific Flash write routine                                     */
/*                                                                      */
/* The default routine returns a write-protect error.                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      address            : Card address to write to                   */
/*      buffer             : Address of data to write                   */
/*      length             : Number of bytes to write                   */
/*      modes              : See write mode flags definition above      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, failed otherwise              */
/*----------------------------------------------------------------------*/
  FLStatus (*write)(FLFlash *, CardAddress, const void FAR1 *, dword, word);

/*----------------------------------------------------------------------*/
/*                       f l a s h . e r a s e                          */
/*                                                                      */
/* Erase one or more contiguous Flash erasable blocks                   */
/*                                                                      */
/* The default routine returns a write-protect error.                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                 : Pointer identifying drive                 */
/*      firstErasableBlock  : Number of first block to erase            */
/*      numOfErasableBlocks : Number of blocks to erase                 */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, failed otherwise              */
/*----------------------------------------------------------------------*/
  FLStatus (*erase)(FLFlash *, word, word);

/*----------------------------------------------------------------------*/
/*               f l a s h . s e t P o w e r O n C a l l b a c k        */
/*                                                                      */
/* Register power on callback routine. Default: no routine is           */
/* registered.                                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*setPowerOnCallback)(FLFlash *);

/*----------------------------------------------------------------------*/
/*                        f l a s h . r e a d B B T                     */
/*                                                                      */
/* MTD specific Flash routine returning the media units status          */
/* Note that a unit can contain more then 1 erase block                 */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      unitNo             : Number of the first unit to check          */
/*      unitsToRead        : Number of units to check                   */
/*      blockMultiplier    : Number of blocks per erase unit            */
/*      buffer             : Buffer to return the units status          */
/*      reconstruct        : TRUE for reconstruct BBT from virgin card  */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*readBBT)(FLFlash *, dword unitNo, dword unitsToRead,
              byte blockMultiplier,byte FAR1 * buffer, FLBoolean reconstruct);

/*----------------------------------------------------------------------*/
/*                    f l a s h . w r i t e I P L                       */
/*                                                                      */
/* MTD specific Flash write IPL area routine                            */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      buffer             : Buffer containing the data to write        */
/*      length             : Length to write                            */
/*      flags              : Flags of write IPL operation (see obove)   */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*writeIPL)(FLFlash *, const void FAR1 * buffer, word length, 
                       byte offset , unsigned flags);
/*----------------------------------------------------------------------*/
/*                     f l a s h . r e a d I P L                        */
/*                                                                      */
/* MTD specific Flash read area IPL routine                             */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      buffer             : Area to read into                          */
/*      length             : Length to read                             */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*readIPL)(FLFlash *, void FAR1 * buffer, word length);

#ifdef HW_OTP

/*----------------------------------------------------------------------*/
/*                        f l a s h . w r i t e O T P                   */
/*                                                                      */
/* MTD specific Flash write and lock OTP area routine                   */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      buffer             : buffer containing the data to write        */
/*      length             : Length to write                            */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*writeOTP)(FLFlash *, const void FAR1 * buffer,word length);

/*----------------------------------------------------------------------*/
/*                        f l a s h . r e a d O T P                     */
/*                                                                      */
/* MTD specific Flash read OTP area routine                             */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      offset             : Offset from the begining of the OTP arae   */
/*      buffer             : Area to read into                          */
/*      length             : Length to read                             */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*readOTP)(FLFlash *, word offset, void FAR1 * buffer, word length);

/*----------------------------------------------------------------------*/
/*                        f l a s h . otpSize                           */
/*                                                                      */
/* MTD specific Flash get OTP area size and state                       */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      sectionSize        : total size of the OTP area                 */
/*      usedSize           : Used (and locked) size of the OTP area     */
/*      locked             : LOCKED_OTP flag stating the locked state   */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*otpSize)(FLFlash *,  dword FAR2* sectionSize,
             dword FAR2* usedSize, word FAR2* locked);
#define LOCKED_OTP 1
#endif /* HW_OTP */
/*----------------------------------------------------------------------*/
/*                  f l a s h . g e t U n i q u e I d                   */
/*                                                                      */
/* MTD specific Flash get the chip unique ID                            */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      buffer             : byte buffer to read unique ID into         */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*getUniqueId)(FLFlash *, void FAR1 * buffer);
#ifdef  HW_PROTECTION
/*----------------------------------------------------------------------*/
/*        f l a s h . p r o t e c t i o n B o u n d r i e s             */
/*                                                                      */
/* MTD specific Flash get protection boundries  routine                 */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      areaNo             : Protection area number to work on          */
/*      addressLow         : Low boundary Address of protected area     */
/*      addressHigh        : High boundary Address of protected area    */
/*      floorNo            : The floor to work on.                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionBoundries)(FLFlash *, byte areaNo,
            CardAddress* addressLow ,CardAddress* addressHigh, byte floorNo);

/*----------------------------------------------------------------------*/
/*        f l a s h . p r o t e c t i o n K e y I n s e r t             */
/*                                                                      */
/* MTD specific Flash insert the protection key routine                 */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Note the key is inserted only to protected areas and to all floors   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      areaNo             : Protection area number to work on          */
/*      key                : protection key buffer                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionKeyInsert)(FLFlash *, byte areaNo, byte FAR1* key);

/*----------------------------------------------------------------------*/
/*        f l a s h . p r o t e c t i o n K e y R e m o v e             */
/*                                                                      */
/* MTD specific Flash remove the protection key routine                 */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Note the key is removed from all floors.                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      areaNo             : Protection area number to work on          */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionKeyRemove)(FLFlash *,byte areaNo);

/*----------------------------------------------------------------------*/
/*        f l a s h . p r o t e c t i o n T y p e                       */
/*                                                                      */
/* MTD specific Flash get protection type routine                       */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Note the type is the combined attributes of all the floors.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      areaNo             : Protection area number to work on          */
/*      areaType           : returnining the protection type            */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionType)(FLFlash *,byte areaNo, word* areaType);

/*----------------------------------------------------------------------*/
/*              f l a s h . p r o t e c t i o n S e t                   */
/*                                                                      */
/* MTD specific Flash get protection type routine                       */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol           : Pointer identifying drive                       */
/*      areaNo        : Protection area number to work on               */
/*      areaType      : Protection area type                            */
/*      addressLow    : Low boundary Address of protected area          */
/*      addressHigh   : High boundary Address of protected area         */
/*      key           : protection key buffer                           */
/*      modes         : Either COMMIT_PROTECTION will cause the new     */
/*                      values to take affect immidiatly or             */
/*                      DO_NOT_COMMIT_PROTECTION for delaying the new   */
/*                      values to take affect only after the next reset.*/
/*      floorNo       : The floor to work on.                           */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionSet )( FLFlash *,byte areaNo, word areaType ,
        CardAddress addressLow, CardAddress addressHigh,
            byte FAR1* key , byte modes , byte floorNo);

#endif /* HW_PROTECTION */

/*----------------------------------------------------------------------*/
/*      f l a s h . e n t e r D e e p P o w e r D o w n M o d e         */
/*                                                                      */
/* MTD specific Flash enter deep power down mode routine                */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      state              : DEEP_POWER_DOWN                            */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*enterDeepPowerDownMode)(FLFlash *,word state);

#define DEEP_POWER_DOWN 1 /* must be the same as in blockdev.h */

/*----------------------------------------------------------------------*/
/*                    f l a s h . d o w n l o a d                       */
/*                                                                      */
/* MTD specific - Reset download mechanizm to download IPL and          */
/*                protection attributes.                                */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*download)(FLFlash *);

/*----------------------------------------------------------------------*/
/* DiskOnChip memory access routines type defintions                    */
/*----------------------------------------------------------------------*/

  FLMemWindowSize FAR1* memWindowSize; /* Doc memory window size          */
#ifndef FL_NO_USE_FUNC
  FLMemRead       FAR1* memRead;       /* Doc memory read routine         */
  FLMemWrite      FAR1* memWrite;      /* Doc memory write routine        */
  FLMemSet        FAR1* memSet;        /* Doc memory set routine          */
  FLMemRead8bit   FAR1* memRead8bit;   /* Doc memory 8 bit read routine   */
  FLMemWrite8bit  FAR1* memWrite8bit;  /* Doc memory 8 bit write routine  */
  FLMemRead16bit  FAR1* memRead16bit;  /* Doc memory 16 bit read routine  */
  FLMemWrite16bit FAR1* memWrite16bit; /* Doc memory 16 bit write routine */
#endif /* FL_NO_USE_FUNC */
};

/* MTD registration information */

extern int noOfMTDs;        /* No. of MTDs actually registered */

typedef FLStatus (*MTDidentifyRoutine) (FLFlash *);

extern MTDidentifyRoutine mtdTable[MTDS];

/* Returns specific flash structure of the socket */

extern FLFlash * flFlashOf(unsigned volNo);

#ifdef MTD_STANDALONE
typedef FLStatus (*SOCKETidentifyRoutine) (FLSocket * ,
          dword lowAddress, dword highAddress);
typedef void     (*FREEmtd) (FLSocket vol);

extern SOCKETidentifyRoutine socketTable[MTDS];
extern FREEmtd               freeTable[MTDS];

#else

/* The address of this, if returned from map, denotes a data error */

extern FLStatus dataErrorObject;

#define dataErrorToken ((void FAR0 *) &dataErrorObject)

/* See interface documentation of functions in flflash.c        */

extern void flIntelIdentify(FLFlash *,
                void (*)(FLFlash *, CardAddress, byte, FlashPTR),
                CardAddress);

extern FLStatus        flIntelSize(FLFlash *,
                void (*)(FLFlash *, CardAddress, byte, FlashPTR),
                CardAddress);

extern FLStatus        flIdentifyFlash(FLSocket *socket, FLFlash *flash);

#ifdef NT5PORT
extern VOID * mapThroughBuffer(FLFlash *flash, CardAddress address, LONG length);
#endif /*NT5PORT*/


#endif /* MTD_STANDALONE */
#endif
/*----------------------------------------------------------------------*/
/*              f l a s h . r e s e t I n t e r r u p t                 */
/*                                                                      */
/* MTD specific Flash reset the interrupt signal routine                */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
/*void (*resetInterrupt)(FLFlash vol); */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flcustom.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Custom/FLCUSTOM.H_V  $
 * 
 *    Rev 1.12   Jan 29 2002 20:11:56   oris
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * 
 *    Rev 1.11   Jan 20 2002 20:42:34   oris
 * FL_NO_USE_FUNC  is now commented.
 * 
 *    Rev 1.10   Jan 20 2002 12:03:46   oris
 * Updated driverVersion and OSAKVersion to 5.1
 * Removed FAT- lite (FILES 0)
 * Changed VOLUMES to 4*SOCKETS
 * Commented WRITE_EXB_IMAGE / WRITE_PROTECTION.
 * Uncommneted VERIFY_WRITE (for protection against power failures).
 * Changed MAX_VOLUME_MBYTES to 1GB
 * Changed TLS to 2 (since multi-doc was removed)
 * Removed QUICK_MOUNT_FEATURE (since it is defained by default in flchkdfs)
 * Removed MULTI_DOC / SEPERATED_CASCADED / FL_BACKGROUND
 * Added FL_NO_USE_FUNC definition.
 * 
 *    Rev 1.9   Nov 16 2001 00:33:44   oris
 * Added NO_NFTL_2_INFTL compilation flag enabling 4.3 format converter.
 * 
 *    Rev 1.8   Jul 13 2001 00:56:58   oris
 * Added VERIFY_ERASE and VERIFY_WRITE.
 * 
 *    Rev 1.7   Jun 17 2001 16:43:46   oris
 * Improved documentation.
 * 
 *    Rev 1.6   Jun 17 2001 08:13:10   oris
 * Rearranged compilation flags orders.
 * 
 *    Rev 1.5   May 16 2001 23:07:02   oris
 * Increased number of Translation Layers to support Multi-DOC.
 * 
 *    Rev 1.4   May 09 2001 00:47:46   oris
 * Removed nested comments.
 * Added NO_PHYSICAL_IO, NO_IPL_CODE and NO_INQUIRE_CAPABILITIES compilation flag 
 * to reduce code.
 * 
 *    Rev 1.3   Feb 12 2001 12:19:50   oris
 * Added Multi-DOC compilation flag
 *
 *    Rev 1.2   Feb 08 2001 09:19:06   oris
 * Changed DRIVES to SOCKETS and VOLUMES
 * Moved SECTOR_SIZE_BITS to flbase.h
 * Added WRITE_EXB_IMAGE, QUICK_MOUNT_FEATURE, HW_OTP, HW_PROTECTION and BINARY_PARTITIONS
 * compilation flags. Added SEPERATED_CASCADED compilation flag.
 *
 *    Rev 1.1   Feb 05 2001 18:46:50   oris
 * Moved compilation flag sanity check to a different file in order to preserve backward
 * compatibility.
 *
 *    Rev 1.0   Feb 05 2001 12:21:36   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*              FAT-FTL Lite Software Development Kit                   */
/*              Copyright (C) M-Systems Ltd. 1995-2001                  */
/*                                                                      */
/************************************************************************/


#ifndef FLCUSTOM_H
#define FLCUSTOM_H


/* Driver & TrueFFS (OSAK) Version numbers */

#define driverVersion   "OS Less 5.1"
#define OSAKVersion     "5.1"

#define NT5PORT
#define D2000
#define DOC_DRIVES 4
/*
 *
 *              File System Customization
 *              -------------------------
 */

/* Number of sockets
 *
 * Defines the maximum number of physical drives supported.
 *
 * The actual number of sockets depends on which socket controllers are
 * actually registered and the number of sockets in the system.
 */

#define SOCKETS 8



/* Number of volumes
 *
 * Defines the maximum number of logical drives supported.
 *
 * The actual number of drives depends on which socket controllers are
 * actually registered, the amount of devices in the system and the
 * TL format of each device.
 */

#define VOLUMES		(DOC_DRIVES * 4 ) + SOCKETS - DOC_DRIVES



/* Number of open files
 *
 * Defines the maximum number of files that can be open at a time.
 */

#define FILES   0



/* Low level operations
 *
 * Uncomment the following line if you want to do low level operations
 * (i.e. read from a physical address, write to a physical address,
 * erase a unit according to its physical unit number, OTP and unique ID
 * operations.
 */

#define FL_LOW_LEVEL



/* Remove all write functions from the source. */

/* #define FL_READ_ONLY */



#ifndef FL_READ_ONLY

/* Placing EXB files
 *
 * Uncomment the following line if you need to place M-Systems firmware
 * (DOCxx.EXB file) on the media. The file will install itself as a
 * BIOS extension driver, hooking INT13h to emulate a HD.
 */

#define WRITE_EXB_IMAGE



/* Formatting
 *
 * Uncomment the following line if you need to format the media.
 */

#define FORMAT_VOLUME



/* Defragmentation
 *
 * Uncomment the following line if you need to defragment with
 * flDefragmentVolume.
 */

#define DEFRAGMENT_VOLUME

#endif /* FL_READ_ONLY */



/* Sub-directories
 *
 * Uncomment the following line if you need support for sub-directories
 * using the FAT-FLITE file system.
 */

/*#define SUB_DIRECTORY*/



/* Rename file
 *
 * Uncomment the following line if you need to rename files with
 * flRenameFile.
 */

/*#define RENAME_FILE**/



/* Split / join file
 *
 * Uncomment the following line if you need to split or join files with
 * flSplitFile and flJoinFile.
 */

/* #define SPLIT_JOIN_FILE */



/* 12-bit FAT support
 *
 * Comment the following line if you do not need support for DOS media with
 * 12-bit FAT (typically media of 8 MBytes or less).
 */

#define FAT_12BIT



/* Parse path function
 *
 * Uncomment the following line if you need to parse DOS-like path names
 * with flParsePath.
 */

/*#define PARSE_PATH*/



/* Maximum supported medium size.
 *
 * Define here the largest Flash medium size (in MBytes) you want supported.
 *
 * This define is used for the static memory allocation configuration
 * of the driver. If your TrueFFS based application or driver are using
 * dynamic allocation you should keep this define as large as possible (288L).
 *
 * Note: This define also dictates the size of the TrueFFS internal
 * "sectorNo" type forcing it to 2 bytes when MAX_VOLUME_MBYTES is less
 * then 64L. Using a smaller size than your actual device might cause
 * casting problems even when using dynamic allocation.
 */

#define MAX_VOLUME_MBYTES       1024L



/* Assumed card parameters.
 *
 * This issue is relevant only if you are not defining any dynamic allocation
 * routines in flsystem.h.
 *
 * The following are assumptions about parameters of the Flash media.
 * They affect the size of the heap buffer allocated for the translation
 * layer.
 */

/* NAND flash */
#define ASSUMED_NFTL_UNIT_SIZE  0x2000l         /* NAND */

/* NOR flash */
#define ASSUMED_FTL_UNIT_SIZE   0x20000l        /* Intel interleave-2 (NOR) */
#define ASSUMED_VM_LIMIT        0x10000l        /* limit at 64 KB */



/* Absolute read & write
 *
 * Uncomment the following line if you want to be able to read & write
 * sectors by absolute sector number (i.e. without regard to files and
 * directories).
 */

#define ABS_READ_WRITE



/* Application exit
 *
 * If the FLite application ever exits, it needs to call flEXit before
 * exiting. Uncomment the following line to enable this.
 */

#define EXIT


 
/* Number of sectors per FAT cluster
 *
 * Define the minimum cluster size in sectors.
 */

#define MIN_CLUSTER_SIZE   4



/*
 *
 * Socket Hardware Customization
 * -----------------------------
 */

/* Vpp voltage
 *
 * If your socket does not supply 12 volts, comment the following line. In
 * this case, you will be able to work only with Flash devices that do not
 * require external 12 Volt Vpp.
 *
 */

#define SOCKET_12_VOLTS



/* Fixed or removable media
 *
 * If your Flash media is fixed, uncomment the following line.
 */

/*#define FIXED_MEDIA*/



/* Interval timer
 *
 * The following defines a timer polling interval in milliseconds. If the
 * value is 0, an interval timer is not installed.
 *
 * If you select an interval timer, you should provide an implementation
 * for 'flInstallTimer' defined in flsysfun.h.
 *
 * An interval timer is not a must, but it is recommended. The following
 * will occur if an interval timer is absent:
 *
 * - Card changes can be recognized only if socket hardware detects them.
 * - The Vpp delayed turn-off procedure is not applied. This may downgrade
 *   write performance significantly if the Vpp switching time is slow.
 * - The watchdog timer that guards against certain operations being stuck
 *   indefinitely will not be active.
 */

/* Polling interval in millisec. If 0, no polling is done */

#define POLLING_INTERVAL 1500           



/* Maximum MTD's and Translation Layers
 *
 * Define here the maximum number of Memory Technology Drivers (MTD) and
 * Translation Layers (TL) that may be installed. Note that the actual
 * number installed is determined by which components are installed in
 * 'flRegisterComponents' (flcustom.c).
 */

#define MTDS	10	/* Up to 5 MTD's */

#define	TLS	3	/* Up to 3 Translation Layers */



/* BDTL cash
 *
 * Enable Block Device Translation Layer cache.
 *
 * Turning on this option improves performance but requires additional
 * RAM resources.
 *
 * The NAND Flash Translation Layer (NFTL) and (INFTL) are specifications
 * for storing data on the DiskOnChip in a way that enables accessing the
 * DiskOnChip as a Virtual Block Device. If this option is on, then the BDTL 
 * keeps in RAM a table that saves some of the flash accesses.
 * Whenever it is needed to change table entry, the BDTL updates it in the
 * RAM table and on the DiskOnChip. If NFTL has to read table entry, then you
 * can save time on reading sector from DiskOnChip.
 */

/* #define NFTL_CACHE */



/* Environment Variables
 *
 * Enable environment variables control of the TrueFFS features.
 *
 */
#define ENVIRONMENT_VARS



/* IO Controll Interface
 *
 * Support standard IOCTL interface.
 *
 */

#define IOCTL_INTERFACE



/* S/W Write protection
 *
 * Enable S/W write protection of the device.
 *
 */

#define WRITE_PROTECTION

/* Definitions required for write protection. */

#ifdef WRITE_PROTECTION
#define ABS_READ_WRITE
#define SCRAMBLE_KEY_1  647777603l
#define SCRAMBLE_KEY_2  232324057l
#endif



/* H/W OTP
 *
 * Enable H/W One Time Programing capability including unique ID/
 *
 */

#define HW_OTP



/* H/W Protection
 *
 * Enable H/W protection of the device.
 *
 */

#define HW_PROTECTION 



/* Read after write
 *
 * Add read after every write verifing data integrity. Make sure that
 * flVerifyWrite variable is also set to 1.
 *
 */

#define VERIFY_WRITE



/* Verify entire volume
 *
 * Scan the entire disk partition for power failures symptoms and correct them.
 *
 */

#define VERIFY_VOLUME 



/* Read after erase
 *
 * Add read after every erase operation verifing data integrity.
 *
 */

/* #define VERIFY_ERASE */



 /* Binary Partition
 *
 * Enables access to the Binary partition.
 *
 */

#define BDK_ACCESS



/* Definitions required for BDK operations. */

#ifdef BDK_ACCESS

 /* Number of Binary partitions on the DiskOnChip.
 *
 * Defines Maximum Number of Binary partitions on the DiskOnChip.
 *
 * The actual number of partitions depends on the format placed
 * on each device.
 */

#define BINARY_PARTITIONS 3

#endif /* BDK_ACCESS */



/* Remove runtime controll over memory access routines 
 *
 * If defined memory access routines will be set at compile time using 
 * dedicated defintions in flsystem.h
 * Note : when compile time customization is chosen, you must sepcify
 * the bus width even when working with DiskOnChip Millennium Plus.
 * Refer to Trueffs manual for more infromation.
 */

/* #define FL_NO_USE_FUNC */



/* Remove IPL code.
 *
 * Removes the IPL code (This applies only to DiskOnChip Millennium Plus 
 * and DiskOnChip 2000 TSOP).
 *
 */

/* #define NO_IPL_CODE */



/*
 * Removes Physical access code
 *
 */

/* #define NO_PHYSICAL_IO */



/*
 *  Removes the inquire capability code.
 *
 */

/* #define NO_INQUIRE_CAPABILITIES */



/*
 *  Removes read Bad Block Table code. 
 *
 */

/* #define NO_READ_BBT_CODE */



/*
 *  Removes read Bad Block Table code. 
 *
 */

/* #define NO_NFTL_2_INFTL */

#endif /* FLCUSTOM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flioctl.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLIOCTL.C_V  $
 * 
 *    Rev 1.7   May 09 2001 00:45:48   oris
 * Changed protection ioctl interface to prevent the use of input buffer as an output buffer.
 * 
 *    Rev 1.6   Apr 16 2001 13:43:28   oris
 * Removed warrnings.
 * 
 *    Rev 1.5   Apr 09 2001 15:09:20   oris
 * End with an empty line.
 * 
 *    Rev 1.4   Apr 01 2001 15:16:26   oris
 * Updated inquire capability ioctl - diffrent input and output records.
 *
 *    Rev 1.3   Apr 01 2001 07:58:30   oris
 * copywrite notice.
 * FL_IOCTL_FORMAT_PHYSICAL_DRIVE ioctl is not under the LOW_LEVEL compilation flag.
 * Bug fix - BDK_GET_INFO no longer calls bdkCreate().
 *
 *    Rev 1.2   Feb 14 2001 02:15:00   oris
 * Updated inquire capabilities ioctl.
 *
 *    Rev 1.1   Feb 13 2001 01:52:20   oris
 * Added the following new IO Controls:
 *   FL_IOCTL_FORMAT_VOLUME2,
 *   FL_IOCTL_FORMAT_PARTITION,
 *   FL_IOCTL_BDTL_HW_PROTECTION,
 *   FL_IOCTL_BINARY_HW_PROTECTION,
 *   FL_IOCTL_OTP,
 *   FL_IOCTL_CUSTOMER_ID,
 *   FL_IOCTL_UNIQUE_ID,
 *   FL_IOCTL_NUMBER_OF_PARTITIONS,
 *   FL_IOCTL_SUPPORTED_FEATURES,
 *   FL_IOCTL_SET_ENVIRONMENT_VARIABLES,
 *   FL_IOCTL_PLACE_EXB_BY_BUFFER,
 *   FL_IOCTL_WRITE_IPL,
 *   FL_IOCTL_DEEP_POWER_DOWN_MODE,
 * and BDK_GET_INFO type in FL_IOCTL_BDK_OPERATION
 * Those IOCTL were not qualed and the TrueFFS 5.0 should be release with revision 1.0 of this this file.
 *
 *    Rev 1.0   Feb 04 2001 11:37:36   oris
 * Initial revision.
 *
 */
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "flioctl.h"
#include "blockdev.h"

#ifdef IOCTL_INTERFACE

FLStatus flIOctl(IOreq FAR2 *ioreq1)
{
  IOreq ioreq2;
  void FAR1 *inputRecord;
  void FAR1 *outputRecord;

  inputRecord = ((flIOctlRecord FAR1 *)(ioreq1->irData))->inputRecord;
  outputRecord = ((flIOctlRecord FAR1 *)(ioreq1->irData))->outputRecord;
  ioreq2.irHandle = ioreq1->irHandle;

  switch (ioreq1->irFlags) {
    case FL_IOCTL_GET_INFO:
    {
      flDiskInfoOutput FAR1 *outputRec = (flDiskInfoOutput FAR1 *)outputRecord;

      ioreq2.irData = &(outputRec->info);
      outputRec->status = flVolumeInfo(&ioreq2);
      return outputRec->status;
    }

#ifdef DEFRAGMENT_VOLUME
    case FL_IOCTL_DEFRAGMENT:
    {
      flDefragInput FAR1 *inputRec = (flDefragInput FAR1 *)inputRecord;
      flDefragOutput FAR1 *outputRec = (flDefragOutput FAR1 *)outputRecord;

      ioreq2.irLength = inputRec->requiredNoOfSectors;
      outputRec->status = flDefragmentVolume(&ioreq2);
      outputRec->actualNoOfSectors = ioreq2.irLength;
      return outputRec->status;
    }
#endif /* DEFRAGMENT_VOLUME */
#ifndef FL_READ_ONLY
#ifdef WRITE_PROTECTION
    case FL_IOCTL_WRITE_PROTECT:
    {
      flWriteProtectInput FAR1 *inputRec = (flWriteProtectInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irData = inputRec->password;
      ioreq2.irFlags = inputRec->type;
      outputRec->status = flWriteProtection(&ioreq2);
      return outputRec->status;
    }
#endif /* WRITE_PROTECTION */
#endif /* FL_READ_ONLY */
    case FL_IOCTL_MOUNT_VOLUME:
    {
      flMountInput FAR1 *inputRec = (flMountInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      if (inputRec->type == FL_DISMOUNT)
        outputRec->status = flDismountVolume(&ioreq2);
      else
        outputRec->status = flAbsMountVolume(&ioreq2);
      return outputRec->status;
    }

#ifdef FORMAT_VOLUME
    case FL_IOCTL_FORMAT_VOLUME:
    {
      flFormatInput FAR1 *inputRec = (flFormatInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irFlags = inputRec->formatType;
      ioreq2.irData = &(inputRec->fp);
      outputRec->status = flFormatVolume(&ioreq2);
      return outputRec->status;
    }

    case FL_IOCTL_FORMAT_LOGICAL_DRIVE:
    {
      flFormatLogicalInput FAR1 *inputRec = (flFormatLogicalInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irData = &(inputRec->fp);
      outputRec->status = flFormatLogicalDrive(&ioreq2);
      return outputRec->status;
    }

    case FL_IOCTL_FORMAT_PHYSICAL_DRIVE:
    {
      flFormatPhysicalInput FAR1 *inputRec = (flFormatPhysicalInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irFlags = inputRec->formatType;
      ioreq2.irData = &(inputRec->fp);
      outputRec->status = flFormatPhysicalDrive(&ioreq2);
      return outputRec->status;
    }
#endif /* FORMAT_VOLUME */

#ifdef BDK_ACCESS
    case FL_IOCTL_BDK_OPERATION:
    {
      flBDKOperationInput  FAR1 *inputRec  = (flBDKOperationInput  FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irData = &(inputRec->bdkStruct);
      switch(inputRec->type) {
        case BDK_INIT_READ:
          outputRec->status = bdkReadInit(&ioreq2);
          break;
        case BDK_READ:
          outputRec->status = bdkReadBlock(&ioreq2);
          break;
        case BDK_GET_INFO:
          outputRec->status = bdkPartitionInfo(&ioreq2);
          break;
#ifndef FL_READ_ONLY
        case BDK_INIT_WRITE:
          outputRec->status = bdkWriteInit(&ioreq2);
          break;
        case BDK_WRITE:
          outputRec->status = bdkWriteBlock(&ioreq2);
          break;
        case BDK_ERASE:
          outputRec->status = bdkErase(&ioreq2);
          break;
        case BDK_CREATE:
          outputRec->status = bdkCreate(&ioreq2);
          break;
#endif   /* FL_READ_ONLY */
	default:
	  outputRec->status = flBadParameter;
          break;
      }
      return outputRec->status;
    }
#endif /* BDK_ACCESS */
#ifdef HW_PROTECTION
#ifdef BDK_ACCESS
    case FL_IOCTL_BINARY_HW_PROTECTION:
    {
      flProtectionInput    FAR1 *inputRec = (flProtectionInput FAR1 *)inputRecord;
      flProtectionOutput FAR1 *outputRec = (flProtectionOutput FAR1 *)outputRecord;

      switch(inputRec->type)
      {
	case PROTECTION_INSERT_KEY:
	  ioreq2.irData = inputRec->key;
	  outputRec->status = bdkInsertProtectionKey(&ioreq2);
	  break;
	case PROTECTION_REMOVE_KEY:
	  outputRec->status = bdkRemoveProtectionKey(&ioreq2);
	  break;
	case PROTECTION_GET_TYPE:
	  outputRec->status = bdkIdentifyProtection(&ioreq2);
	  outputRec->protectionType = (byte)ioreq2.irFlags;
	  break;
	case PROTECTION_DISABLE_LOCK:
	  ioreq2.irFlags = 0;
	  outputRec->status = bdkHardwareProtectionLock(&ioreq2);
	  break;
	case PROTECTION_ENABLE_LOCK:
	  ioreq2.irFlags = LOCK_ENABLED;
	  outputRec->status = bdkHardwareProtectionLock(&ioreq2);
	  break;
	case PROTECTION_CHANGE_KEY:
	  ioreq2.irData = inputRec->key;
	  outputRec->status = bdkChangeProtectionKey(&ioreq2);
	  break;
	case PROTECTION_CHANGE_TYPE:
	  ioreq2.irFlags = inputRec->protectionType;
	  outputRec->status = bdkChangeProtectionType(&ioreq2);
	  break;
        default:
          outputRec->status = flBadParameter;
          break;
      }
      return outputRec->status;
    }
#endif /* BDK_ACCESS */
    case FL_IOCTL_BDTL_HW_PROTECTION:
    {
      flProtectionInput  FAR1 *inputRec = (flProtectionInput FAR1 *)inputRecord;
      flProtectionOutput FAR1 *outputRec = (flProtectionOutput FAR1 *)outputRecord;

      switch(inputRec->type)
      {
	case PROTECTION_INSERT_KEY:
	  ioreq2.irData = inputRec->key;
	  outputRec->status = flInsertProtectionKey(&ioreq2);
	  break;
	case PROTECTION_REMOVE_KEY:
	  outputRec->status = flRemoveProtectionKey(&ioreq2);
	  break;
	case PROTECTION_GET_TYPE:
	  outputRec->status = flIdentifyProtection(&ioreq2);
	  outputRec->protectionType = (byte)ioreq2.irFlags;
	  break;
	case PROTECTION_DISABLE_LOCK:
	  ioreq2.irFlags = 0;
	  outputRec->status = flHardwareProtectionLock(&ioreq2);
	  break;
	case PROTECTION_ENABLE_LOCK:
	  ioreq2.irFlags = LOCK_ENABLED;
	  outputRec->status = flHardwareProtectionLock(&ioreq2);
	  break;
	case PROTECTION_CHANGE_KEY:
	  ioreq2.irData = inputRec->key;
	  outputRec->status = flChangeProtectionKey(&ioreq2);
	  break;
	case PROTECTION_CHANGE_TYPE:
	  ioreq2.irFlags = inputRec->protectionType;
	  outputRec->status = flChangeProtectionType(&ioreq2);
	  break;
	default:
	  outputRec->status = flBadParameter;
	  break;
      }
      return outputRec->status;
    }
#endif /* HW_PROTECTION */
#ifdef HW_OTP
    case FL_IOCTL_OTP:
    {
      flOtpInput           FAR1 *inputRec  = (flOtpInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      switch(inputRec->type)
      {
         case OTP_SIZE:
   	   outputRec->status = flOTPSize(&ioreq2);
	   inputRec->lockedFlag = (byte)ioreq2.irFlags;
           inputRec->length     = ioreq2.irCount ;
	   inputRec->usedSize   = ioreq2.irLength ;
           break;
         case OTP_READ:
           ioreq2.irData   = inputRec->buffer;    /* user buffer  */
	   ioreq2.irCount  = inputRec->usedSize;  /* offset       */
           ioreq2.irLength = inputRec->length;    /* size to read */
           outputRec->status = flOTPRead(&ioreq2);
	   break;
         case OTP_WRITE_LOCK:
           ioreq2.irData   = inputRec->buffer;    /* user buffer  */
           ioreq2.irLength = inputRec->length;    /* size to read */
           outputRec->status = flOTPWriteAndLock(&ioreq2);
	   break;
         default:
	   outputRec->status = flBadParameter;
           break;
      }
      return outputRec->status;
    }

    case FL_IOCTL_CUSTOMER_ID:
    {
      flCustomerIdOutput FAR1 *outputRec = (flCustomerIdOutput FAR1 *)outputRecord;

      ioreq2.irData = outputRec->id;
      outputRec->status = flGetCustomerID(&ioreq2);
      return outputRec->status;
    }

    case FL_IOCTL_UNIQUE_ID:
    {
      flUniqueIdOutput FAR1 *outputRec = (flUniqueIdOutput FAR1 *)outputRecord;

      ioreq2.irData = outputRec->id;
      outputRec->status = flGetUniqueID(&ioreq2);
      return outputRec->status;
    }
#endif /* HW_OTP */

    case FL_IOCTL_NUMBER_OF_PARTITIONS:
    {
      flCountPartitionsOutput FAR1 *outputRec = (flCountPartitionsOutput FAR1 *)outputRecord;

      outputRec->status = flCountVolumes(&ioreq2);
      outputRec->noOfPartitions = (byte) ioreq2.irFlags;
      return outputRec->status;
    }

#ifdef LOW_LEVEL

    case FL_IOCTL_INQUIRE_CAPABILITIES:
    {
      flCapabilityInput FAR1 *inputRec = (flCapabilityInput FAR1 *)inputRecord;
      flCapabilityOutput FAR1 *outputRec = (flCapabilityOutput FAR1 *)outputRecord;

      ioreq2.irLength       = inputRec->capability;
      outputRec->status     = flInquireCapabilities(&ioreq2);
      outputRec->capability = ioreq2.irLength;
      return outputRec->status;
    }

#endif /* LOW_LEVEL */
#ifdef ENVIRONMENT_VARS

		/*
    case FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES:
    {
      flEnvVarsInput  FAR1 *inputRec  = (flEnvVarsInput  FAR1 *)inputRecord;
      flEnvVarsOutput FAR1 *outputRec = (flEnvVarsOutput FAR1 *)outputRecord;
      outputRec->status = flSetEnv(inputRec->varName , inputRec->varValue, &(outputRec->prevValue));
      return outputRec->status;
    }
		*/
#endif /* ENVIRONMENT_VARS */
#ifdef LOW_LEVEL
#ifdef WRITE_EXB_IMAGE

    case FL_IOCTL_PLACE_EXB_BY_BUFFER:
    {
      flPlaceExbInput      FAR1 *inputRec  = (flPlaceExbInput      FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;
      ioreq2.irData       = inputRec->buf;
      ioreq2.irLength     = inputRec->bufLen;
      ioreq2.irWindowBase = inputRec->exbWindow;
      ioreq2.irFlags      = inputRec->exbFlags;
      outputRec->status   = flPlaceExbByBuffer(&ioreq2);
      return outputRec->status;
    }

#endif /* WRITE_EXB_IMAGE */

    case FL_IOCTL_EXTENDED_WRITE_IPL:
    {
      flIplInput           FAR1 *inputRec  = (flIplInput           FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;
      ioreq2.irData       = inputRec->buf;
      ioreq2.irLength     = inputRec->bufLen;
      outputRec->status   = flWriteIPL(&ioreq2);
      return outputRec->status;
    }

    case FL_IOCTL_DEEP_POWER_DOWN_MODE:
    {
      flPowerDownInput      FAR1 *inputRec  = (flPowerDownInput      FAR1 *)inputRecord;
      flOutputStatusRecord  FAR1 *outputRec = (flOutputStatusRecord  FAR1 *)outputRecord;
      ioreq2.irFlags    = inputRec->state;
      outputRec->status = flDeepPowerDownMode(&ioreq2);
      return outputRec->status;
    }

#endif /* LOW_LEVEL */
#ifdef ABS_READ_WRITE
#ifndef FL_READ_ONLY
    case FL_IOCTL_DELETE_SECTORS:
    {
      flDeleteSectorsInput FAR1 *inputRec = (flDeleteSectorsInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irSectorNo = inputRec->firstSector;
      ioreq2.irSectorCount = inputRec->numberOfSectors;
      outputRec->status = flAbsDelete(&ioreq2);
      return outputRec->status;
    }
#endif  /* FL_READ_ONLY */
    case FL_IOCTL_READ_SECTORS:
    {
      flReadWriteInput FAR1 *inputRec = (flReadWriteInput FAR1 *)inputRecord;
      flReadWriteOutput FAR1 *outputRec = (flReadWriteOutput FAR1 *)outputRecord;

      ioreq2.irSectorNo = inputRec->firstSector;
      ioreq2.irSectorCount = inputRec->numberOfSectors;
      ioreq2.irData = inputRec->buf;
      outputRec->status = flAbsRead(&ioreq2);
      outputRec->numberOfSectors = ioreq2.irSectorCount;
      return outputRec->status;
    }
#ifndef FL_READ_ONLY
    case FL_IOCTL_WRITE_SECTORS:
    {
      flReadWriteInput FAR1 *inputRec = (flReadWriteInput FAR1 *)inputRecord;
      flReadWriteOutput FAR1 *outputRec = (flReadWriteOutput FAR1 *)outputRecord;

      ioreq2.irSectorNo = inputRec->firstSector;
      ioreq2.irSectorCount = inputRec->numberOfSectors;
      ioreq2.irData = inputRec->buf;
      outputRec->status = flAbsWrite(&ioreq2);
      outputRec->numberOfSectors = ioreq2.irSectorCount;
      return outputRec->status;
    }
#endif   /* FL_READ_ONLY */
#endif  /* ABS_READ_WRITE */

    default:
      return flBadParameter;
  }
}

#endif /* IOCTL_INTERFACE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flioctl.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLIOCTL.H_V  $
 * 
 *    Rev 1.7   May 09 2001 00:45:48   oris
 * Changed protection ioctl interface to prevent the use of input buffer as an output buffer.
 * 
 *    Rev 1.6   Apr 16 2001 13:45:10   oris
 * Removed warrnings by changing some of the fields types to standart flite types.
 * 
 *    Rev 1.5   Apr 09 2001 15:02:22   oris
 * Added comment to ifdef statment.
 * End with an empty line.
 * 
 *    Rev 1.4   Apr 01 2001 15:16:38   oris
 * Updated inquire capability ioctl - diffrent input and output records.
 *
 *    Rev 1.3   Apr 01 2001 07:58:44   oris
 * Moved the following defines to blockdev.h:
 *   FL_PROTECT   0
 *   FL_UNPROTECT 1
 *   FL_UNLOCK    2
 *
 *    Rev 1.2   Feb 14 2001 02:16:16   oris
 * Updated inquire capabilities ioctl.
 *
 *    Rev 1.1   Feb 13 2001 01:49:06   oris
 * Added the following new IO Controls:
 *   FL_IOCTL_FORMAT_VOLUME2,
 *   FL_IOCTL_FORMAT_PARTITION,
 *   FL_IOCTL_BDTL_HW_PROTECTION,
 *   FL_IOCTL_BINARY_HW_PROTECTION,
 *   FL_IOCTL_OTP,
 *   FL_IOCTL_CUSTOMER_ID,
 *   FL_IOCTL_UNIQUE_ID,
 *   FL_IOCTL_NUMBER_OF_PARTITIONS,
 *   FL_IOCTL_SUPPORTED_FEATURES,
 *   FL_IOCTL_SET_ENVIRONMENT_VARIABLES,
 *   FL_IOCTL_PLACE_EXB_BY_BUFFER,
 *   FL_IOCTL_WRITE_IPL,
 *   FL_IOCTL_DEEP_POWER_DOWN_MODE,
 * and BDK_GET_INFO type in FL_IOCTL_BDK_OPERATION
 *
 *    Rev 1.0   Feb 04 2001 11:38:18   oris
 * Initial revision.
 *
 */
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "flbase.h"
#include "dosformt.h"
#include "blockdev.h"
#ifdef BDK_ACCESS
#include "docbdk.h"
#endif

#ifndef FLIOCTL_H
#define FLIOCTL_H

#define NT5PORT
#ifdef IOCTL_INTERFACE

#ifdef NT5PORT
#ifdef  WRITE_EXB_IMAGE
#define EXB_BUFFER_SIZE		0x200
#endif /*WRITE_EXB_IMAGE*/
#endif  /*NT5PORT*/

/* In every call to flIOctl function, the irFlags field in the structure
   IOreq should hold one of the following: */
typedef enum{FL_IOCTL_GET_INFO = FL_IOCTL_START,
             FL_IOCTL_DEFRAGMENT,
             FL_IOCTL_WRITE_PROTECT,
             FL_IOCTL_MOUNT_VOLUME,
             FL_IOCTL_FORMAT_VOLUME,
             FL_IOCTL_BDK_OPERATION,
             FL_IOCTL_DELETE_SECTORS,
             FL_IOCTL_READ_SECTORS,
             FL_IOCTL_WRITE_SECTORS,
             FL_IOCTL_FORMAT_PHYSICAL_DRIVE,
             FL_IOCTL_FORMAT_LOGICAL_DRIVE,
             FL_IOCTL_BDTL_HW_PROTECTION,
             FL_IOCTL_BINARY_HW_PROTECTION,
             FL_IOCTL_OTP,
             FL_IOCTL_CUSTOMER_ID,
             FL_IOCTL_UNIQUE_ID,
             FL_IOCTL_NUMBER_OF_PARTITIONS,
             FL_IOCTL_INQUIRE_CAPABILITIES,
             FL_IOCTL_SET_ENVIRONMENT_VARIABLES,
             FL_IOCTL_PLACE_EXB_BY_BUFFER,
             FL_IOCTL_EXTENDED_WRITE_IPL,
						 FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES,
						 FL_IOCTL_VERIFY_VOLUME,
             FL_IOCTL_DEEP_POWER_DOWN_MODE
} flIOctlFunctionNo;


FLStatus flIOctl(IOreq FAR2 *);


/* In every call to flIOctl function, the irData field in the structure
   IOreq should point to the structure defined below. The fields
   inputRecord and outputRecord should point to structures which are
   specific to each IOctl function as defined in this file. */
typedef struct {
  void FAR1 *inputRecord;
  void FAR1 *outputRecord;
} flIOctlRecord;


/* General output record that returns only status. */
typedef struct {
  FLStatus status;
} flOutputStatusRecord;



/* Input and output records for the different IOCTL functions: */
/* =========================================================== */

/* Get disk information (FL_IOCTL_GET_INFO) */
/* Input record: NULL */
/* Output record: */
typedef struct {
  VolumeInfoRecord info;  /* VolumeInfoRecord is defined in blockdev.h */
  FLStatus status;
} flDiskInfoOutput;
/* Output record: flOutputStatusRecord */

/******************************************************************************/
/* Check partition for power failures symptoms (FL_IOCTL_VERIFY_VOLUME) */
#ifdef VERIFY_VOLUME
/* Input record: NULL */
typedef struct {
  dword flags;   /* Must be set to 0 */    
} flVerifyVolumeInput;
/* Output record: */
typedef struct {
  void FAR1* callBack;   /* Must be set to null */  
  FLStatus status;
} flVerifyVolumeOutput;
#endif /* VERIFY_VOLUME */
/******************************************************************************/

/*************************************************************************/
#ifdef DEFRAGMENT_VOLUME
/* Defragment volume (FL_IOCTL_DEFRAGMENT) */
/* Input record: */
typedef struct {
  long requiredNoOfSectors;   /* Minimum number of sectors to make available.
                                  if -1 then a quick garbage collection operation
                                 is invoked. */
} flDefragInput;
/* Outout record: */
typedef struct {
  long actualNoOfSectors;     /* Actual number of sectors available */
  FLStatus status;
} flDefragOutput;
#endif
/*************************************************************************/
#ifdef WRITE_PROTECTION
/* Write protection (FL_IOCTL_WRITE_PROTECT) */

//type
//---------
#define FL_PROTECT   0
#define FL_UNPROTECT 1
#define FL_UNLOCK    2

/* Input record: */
typedef struct {
  byte type;        /*  type of operation: FL_PROTECT\FL_UNPROTECT */
  long password[2];          /*  password  */
} flWriteProtectInput;
/* Output record: flOutputStatusRecord */
#endif /* WRITE_PROTECTION */
/*************************************************************************/
/* Mount volume (FL_IOCTL_MOUNT_VOLUME) */
/* Input record: */
typedef struct {
  byte type;        /*  type of operation: FL_MOUNT\FL_DISMOUNT */
} flMountInput;
#define FL_MOUNT          0
#define FL_DISMOUNT        1
/* Output record: flOutputStatusRecord */
/*************************************************************************/

#ifdef FORMAT_VOLUME
/* Format volume (FL_IOCTL_FORMAT_VOLUME) */
/* Input record: */
typedef struct {
  byte formatType;   /* type of format as defined in blockdev.h */
  FormatParams fp;              /* Format parameters structure (defined in flformat.h) */
} flFormatInput;
/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* Format volume (FL_IOCTL_FORMAT_LOGICAL_DRIVE) */
/* Input record: */
typedef struct {
  BDTLPartitionFormatParams fp;              /* Format parameters structure (defined in flformat.h) */
} flFormatLogicalInput;
/* Output record: flOutputStatusRecord */
/*************************************************************************/
#ifdef LOW_LEVEL
/* Format volume (FL_IOCTL_FORMAT_PHYSICAL_DRIVE) */
/* Input record: */
typedef struct {
  byte formatType;   /* type of format as defined in blockdev.h */
  FormatParams2 fp;              /* Format parameters structure (defined in flformat.h) */
} flFormatPhysicalInput;


#ifdef NT5PORT
typedef struct {

/*****************************/
/* Device formatting section */
/*****************************/

byte      percentUse;
     	/* BDTL performance depends on how full the flash media is,
		   becoming slower as the media becomes closer to 100% full.
		   It is possible to avoid the worst-case performance
		   (at 100% full) by formatting the media to less than 100%
		   capacity, thus guaranteeing free space at all times. This
		   of course sacrifices some capacity. The standard value
		   used is 98 */

byte             noOfBDTLPartitions;
		/* Indicates the number of BDTL partitions (1 to 4). 0 will
           cause a single STD_BDTL_PARAMS BDTL partition */

byte            noOfBinaryPartitions;
       /* Indicates the number of binary partitions (up to 3). 0 will
	      cause formatting with no binary partition. This value is ignored
	  unless the TL_BINARY_FORMAT flag is set in the irFlags f the ioreq */

BDTLPartitionFormatParams   BDTLPartitionInfo[4];
       /* BDTL partition information array  */

BinaryPartitionFormatParams binaryPartitionInfo[3];

       /* Binary partition information array*/

/***********************************/
/* Special format features section */
/***********************************/

#ifdef WRITE_EXB_IMAGE


byte            exbBuffer[EXB_BUFFER_SIZE];
	/* A buffer containing the EXB file. Optionaly this file can
	   contain only the first 512 bytes of the file while the rest
	   will be sent using consequitive calls to flPlaceExbByBuffer */

dword           exbBufferLen;     /* Size of the given EXB buffer */

dword           exbLen; /* The specific size to leave for the EXB */

word            exbWindow; /* Set explicit DiskOnChip window base */

byte            exbFlags; /* For the flags list see doc2exb.h */

#endif /* WRITE_EXB_IMAGE */

byte            cascadedDeviceNo;
	/* Reserved for individual cascaded device formatting 0..n. For
	   this value to have any affect the TL_SINGLE_CHIP_FORMATTING flag
	   should be set in the flags field.*/

byte            noOfCascadedDevices;
	/* This field must be supplied in order to perform a format of
	   a single chip that will be eventualy assembeled as a cascaded
	   device. The field should specify the number of DiskOnChips
	   that will be eventualy cascaded on the targe plaform */

FLStatus (*progressCallback)(int totalUnitsToFormat,
			     int totalUnitsFormattedSoFar);
	/* Progress callback routine, will be called if not NULL.
	   The callback routine is called after erasing each unit,
	   and its parameters are the total number of erase units
	   to format and the number erased so far.
	   The callback routine returns a Status value. A value of
	   OK (0) allows formatting to continue. Any other value
	   will abort the formatting with the returned status code. */

/* Note the following section is not used by for DiskOnChips */
/*************************************************************/

dword        	vmAddressingLimit;
	    /* A part of the FTL Virtual Map always resides in RAM. The
	       RAM part is the one that is used to address the part of
	       the media below the VM addressing limit. Reading and
		   writing to this part is usually faster to some degree.
		   The downside is that the bigger the limit, the more RAM
		   size is required.
		   To get the extra RAM requirement in bytes, divide the
		   limit by 128 or by 256, depending on whether you
		   specified in #2.9 more than 32 or not, respectively.
		   The minimum VM limit is 0.
		   The standard value to use is 0x10000 (first 64 KBytes) */

word	    embeddedCISlength;
		/* Length in bytes of CIS to embed after the unit header */

byte embeddedCIS[0x100];
		/* The unit header is structured as a beginning of a PCMCIA
		   'tuple' chain (a CIS). The unit header contains a
		   data-organization tuple, which points past the end of the
		   unit header to a location which usually just contains
		   hex FF's which mark an 'end-of-tuple-chain'. Optionally,
		   it is possible to embed an entire CIS chain at this
		   location. If so, 'embeddedCISlength' marks the length in
		   bytes */
} UserFormatParams2;


typedef struct {
  byte formatType;   /* type of format as defined in blockdev.h */
  UserFormatParams2 fp;              /* Format parameters structure (defined in flformat.h) */
} flUserFormatPhysicalInput;
#endif //NT5PORT

/* Output record: flOutputStatusRecord */
#endif /* LOW_LEVEL */
#endif /* FORMAT_VOLUME */
/*************************************************************************/
#ifdef BDK_ACCESS
/* BDK operations read\write\erase\create (FL_IOCTL_BDK_OPERATION) */
/* Input record: */
typedef struct {
  byte type;  /* type of operation: BDK_INIT_READ\BDK_READ\BDK_INIT_WRITE\ */
                       /* BDK_WRITE\BDK_ERASE\BDK_CREATE\BDK_GET_INFO               */
  BDKStruct bdkStruct; /* parameters for BDK operations (defined in docbdk.h)       */
} flBDKOperationInput;
#define BDK_INIT_READ   0
#define BDK_READ        1
#define BDK_INIT_WRITE  2
#define BDK_WRITE       3
#define BDK_ERASE       4
#define BDK_CREATE      5
#define BDK_GET_INFO    6

#ifdef NT5PORT
#define BDK_MAX_BUFFER									0x400
typedef struct {
byte oldSign[BDK_SIGNATURE_NAME];
byte newSign[BDK_SIGNATURE_NAME];
byte signOffset;
dword startingBlock;
dword length;
byte flags;
byte bdkBuffer[BDK_MAX_BUFFER];
} UserBDKStruct;

typedef struct {
  byte partitionNumber;
  byte type;  /* type of operation: BDK_INIT_READ\BDK_READ\BDK_INIT_WRITE\ */
                       /* BDK_WRITE\BDK_ERASE\BDK_CREATE\BDK_GET_INFO               */
  UserBDKStruct bdkStruct; /* parameters for BDK operations (defined in docbdk.h)       */
} flUserBDKOperationInput;

typedef struct {
  flOutputStatusRecord statusRec;					/* The status of the operation*/
  UserBDKStruct bdkStruct; /* parameters for BDK operations (defined in docbdk.h)       */
} flUserBDKOperationOutput;
#endif				/*NT5PORT*/

/* Output record: flOutputStatusRecord */
#endif                                  /* BDK_ACCESS  */
/*************************************************************************/
#ifdef HW_PROTECTION
/* BDK and BDTL protection operations: (FL_IOCTL_BINARY_HW_PROTECTION) */
/*                                     (FL_IOCTL_BDTL_HW_PROTECTION)   */
/*   insert key \ remove key \ identify \ change key \                 */
/*   change protection type \ change lock status                       */
/* Input record: */
typedef struct {
   byte protectionType;    /* see flflash.h for the protection attributes */
   byte key[8];            /* The new key to the change Key call          */
   byte type;              /* Operation type see list bellow              */
} flProtectionInput;

#ifdef	NT5PORT
typedef struct {
   byte partitionNumber;
   byte protectionType;    /* see flflash.h for the protection attributes */
   byte key[8];            /* The new key to the change Key call          */
   byte type;              /* Operation type see list bellow              */
} flBDKProtectionInput;
#endif				/*NT5PORT*/
/*Type*/
/*--------------*/
#define PROTECTION_INSERT_KEY   0
#define PROTECTION_REMOVE_KEY   1
#define PROTECTION_GET_TYPE     2
#define PROTECTION_DISABLE_LOCK 3
#define PROTECTION_ENABLE_LOCK  4
#define PROTECTION_CHANGE_KEY   5
#define PROTECTION_CHANGE_TYPE  6

#ifdef	NT5PORT
/*protectionType*/
/*--------------*/
#define PROTECTABLE           1  /* partition can recieve protection */
#define READ_PROTECTED        2  /* partition is read protected      */
#define WRITE_PROTECTED       4  /* partition is write protected     */
#define LOCK_ENABLED          8  /* HW lock signal is enabled        */
#define LOCK_ASSERTED         16 /* HW lock signal is asserted       */
#define KEY_INSERTED          32 /* key is inserted (not currently   */
#define CHANGEABLE_PROTECTION 64 /* changeable protection area type   */
#endif				/*NT5PORT*/


/* Output record: */
typedef struct {
   byte protectionType;    /* see flflash.h for the protection attributes */
   FLStatus status;
} flProtectionOutput;

#endif /* HW_PROTECTION */
/*************************************************************************/
#ifdef HW_OTP
/* One Time Programing operations: (FL_IOCTL_OTP */
/*   OTP size \ OTP read \ OTP write and lock    */
/* Input record: */
typedef struct {
dword       length;           /* Length to read\write\size                  */
dword       usedSize;         /* The written size of the area \ Area offset */
byte        lockedFlag;       /* The area condition LOCKED_OTP (flflash.h)  */
byte        FAR1* buffer;     /* pointer to user buffer                     */
word        type;             /* defined bellow                             */
} flOtpInput;
#define OTP_SIZE        1
#define OTP_READ        2
#define OTP_WRITE_LOCK  3

#ifdef NT5PORT
typedef struct {
unsigned long          length;                /* Length to read\write\size                                  */
unsigned long          usedSize;         /* The written size of the area \ Area offset */
byte lockedFlag;       /* The area condition LOCKED_OTP (flflash.h)  */
byte buffer[0x1800];                /* pointer to user buffer                                           */
word           type;                        /* defined bellow                             */
} UserOtpInput;

typedef struct {
long          length;                /* Length to read\write\size                                  */
long          usedSize;         /* The written size of the area \ Area offset */
byte					lockedFlag;       /* The area condition LOCKED_OTP (flflash.h)  */
byte					buffer[0x1800];                /* pointer to user buffer                                           */
flOutputStatusRecord      statusRec;                        /* defined bellow                             */
} UserOtpOutput;
#endif /*NT5PORT*/

/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* Read customer ID (FL_IOCTL_CUSTOMER_ID) */
/* Input record: NULL */
/* Output record: */
typedef struct {
  byte id[4];
  FLStatus status;
} flCustomerIdOutput;
/*************************************************************************/
/* Read unique ID (FL_IOCTL_UNIQUE_ID) */
/* Input record: NULL */
/* Output record: */
typedef struct {
  byte id[16];
  FLStatus status;
} flUniqueIdOutput;
#endif /* HW_OTP */
/*************************************************************************/
/* Read unique ID (FL_IOCTL_NUMBER_OF_PARTITIONS) */
/* Input record: NULL */
/* Output record: */
typedef struct {
  byte noOfPartitions;
  FLStatus status;
} flCountPartitionsOutput;
/*************************************************************************/
/* Quary the device h/w and s/w capabilities (FL_IOCTL_INQUIRE_CAPABILITIES) */
#ifdef LOW_LEVEL
/* Input record:   */
typedef struct {
   FLCapability  capability;  /* defined in blockdev.h */
} flCapabilityInput;
/* Output record: */
typedef struct {
   FLCapability  capability;  /* defined in blockdev.h */
   FLStatus      status;
} flCapabilityOutput;
#endif /*LOW_LEVEL */


/******************************************************************************/
/* Set environment variables values (FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES) */
#ifdef ENVIRONMENT_VARS
/* Input record:  */
typedef struct {
  FLEnvVars      varName;  /* Enum describing the variable */
  dword          varValue; /* New variable value           */
  dword          flags;    /* FL_APPLY_TO_ALL    - All socket and partitions */
                           /* FL_APPLY_TO_SOCKET - All socket and partitions */
                           /* FL_APPLY_TO_VOLUME - All socket and partitions */
} flExtendedEnvVarsInput;
#define FL_APPLY_TO_ALL    1
#define FL_APPLY_TO_SOCKET 2
#define FL_APPLY_TO_VOLUME 3
/* Output record: */
typedef struct {
  dword    prevValue;   /* The previous value of the variable */
  FLStatus status;
} flExtendedEnvVarsOutput;
#endif /* ENVIRONMENT_VARS */
/******************************************************************************/

/* Set environment variables values (FL_IOCTL_SET_ENVIRONMENT_VARIABLES) */
//#ifdef ENVIRONMENT_VARS
/* Input record:  */
//typedef struct {
//  FLEnvVars      varName;  /* Enum describing the variable */
//  int            varValue; /* New variable value           */
//} flEnvVarsInput;
/* Output record: */
//typedef struct {
//  int   prevValue;   /* The previous value of the variable */
//  FLStatus status;
//} flEnvVarsOutput;
//#endif /* ENVIRONMENT_VARS */


/*************************************************************************/
/* Place EXB file by buffers (FL_IOCTL_PLACE_EXB_BY_BUFFER) */
#ifdef LOW_LEVEL
#ifdef WRITE_EXB_IMAGE
/* Input record:  */
typedef struct {
  byte FAR1* buf;  /* buffer of EXB file */
  dword bufLen;     /* buffer length      */
  byte exbFlags;   /* a combination of EXB flags see flPlaceExbByBuffer routine  */
                            /* The list of flags is defined in doc2exb.h                  */
  word exbWindow; /* explicitly set device window. 0 will automatcly set window */
} flPlaceExbInput;

#ifdef NT5PORT
typedef struct {
  byte  buf[EXB_BUFFER_SIZE];  /* buffer of EXB file */
  dword bufLen;     /* buffer length      */
  byte exbFlags;   /* a combination of EXB flags see flPlaceExbByBuffer routine  */
                            /* The list of flags is defined in doc2exb.h                  */
  word exbWindow; /* explicitly set device window. 0 will automatcly set window */
} flUserPlaceExbInput;

#endif /* NT5PORT */

#endif /* WRITE_EXB_IMAGE */
/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* Write IPL area for docPlus family (FL_IOCTL_WRITE_IPL) */
/* Input record:  */

#ifdef NT5PORT
#define IPL_MAX_SIZE			0x1000L
typedef struct {
	byte	buf[IPL_MAX_SIZE];  /* IPL data buffer        */
	word  flags;							/* IPL flags (see flflash.h) */
	word	bufLen;							/* IPL data buffer length */
} flUserIplInput;
#endif /*NT5PORT*/

typedef struct {
  byte FAR1* buf;      /* IPL data buffer           */
  word   flags;        /* IPL flags (see flflash.h) */
  word   bufLen;       /* IPL data buffer length    */
} flIplInput;
/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* Place the device into and out of the power down mode (FL_IOCTL_DEEP_POWER_DOWN_MODE) */
typedef struct {
byte state; /* DEEP_POWER_DOWN - low power consumption      */
                     /* otherwise       - regular power consumption  */
} flPowerDownInput;
/* DEEP_POWER_DOWN is defined in flflash.h */
#endif /* LOW_LEVEL */
/* Output record: flOutputStatusRecord */
/*************************************************************************/
#ifdef ABS_READ_WRITE
/* Delete logical sectors (FL_IOCTL_DELETE_SECTORS) */
/* Input record: */
typedef struct {
  long firstSector;                /* First logical sector to delete */
  long numberOfSectors;                /* Number of sectors to delete */
} flDeleteSectorsInput;
/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* read & write logical sectors (FL_IOCTL_READ_SECTORS & FL_IOCTL_WRITE_SECTORS) */
/* Input record: */
typedef struct {
  long firstSector;                  /* first logical sector */
  long numberOfSectors;         /* Number of sectors to read\write */
  byte FAR1 *buf;               /* Data to read\write */
} flReadWriteInput;
/* Output record: */
typedef struct {
  long numberOfSectors;         /* Actual Number of sectors read\written */
  FLStatus status;
} flReadWriteOutput;
#endif /* ABS_READ_WRITE */
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flfuncno.h ===
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLFUNCNO_H
#define FLFUNCNO_H

/*************************************************************************************/
/* SPECIAL NOTE                                                                      */
/* ------------                                                                      */
/* The order of the enum bellow should be strictly kept since the bdcall function    */
/* utilizes the index values to simplify the function search                         */
/*************************************************************************************/

typedef enum {

/* The following routines are files related routines */

        /*********/
        /* FILES */
        /*********/

  FL_READ_FILE                  = 0,
  FL_WRITE_FILE,
  FL_SPLIT_FILE,
  FL_JOIN_FILE,
  FL_SEEK_FILE,
  FL_FIND_NEXT_FILE,
  FL_FIND_FILE,
  INDEX_WRITE_FILE_START        = 100,
  FL_CLOSE_FILE,
  INDEX_OPENFILES_END           = 200,
  FL_OPEN_FILE,
  FL_DELETE_FILE,
  FL_FIND_FIRST_FILE,
  FL_GET_DISK_INFO,
  FL_RENAME_FILE,
  FL_MAKE_DIR,
  FL_REMOVE_DIR,
  FL_FLUSH_BUFFER,
  FL_LAST_FAT_FUNCTION          = 300,

/* The following routines will not perform valid partition check */

       /**********/
       /* BINARY */
       /**********/

  INDEX_BINARY_START            = 400,
  FL_BINARY_WRITE_INIT,
  FL_BINARY_WRITE_BLOCK,
  FL_BINARY_CREATE,
  FL_BINARY_ERASE,
  FL_BINARY_PROTECTION_CHANGE_KEY,
  FL_BINARY_PROTECTION_CHANGE_LOCK,
  FL_BINARY_PROTECTION_SET_TYPE,
  INDEX_BINARY_WRITE_END        = 500,
  FL_BINARY_READ_INIT,
  FL_BINARY_READ_BLOCK,
  FL_BINARY_PARTITION_INFO,
  FL_BINARY_PROTECTION_GET_TYPE,
  FL_BINARY_PROTECTION_INSERT_KEY,
  FL_BINARY_PROTECTION_REMOVE_KEY,
  INDEX_BINARY_END              = 600,

/* The following routines must be called with partition number 0 */

  INDEX_NEED_PARTITION_0_START  = 700,
      /* OTP */
  FL_OTP_SIZE,
  FL_OTP_READ,
  FL_OTP_WRITE,
  FL_WRITE_IPL,
  FL_READ_IPL,
      /* PHYSICAL */
  FL_DEEP_POWER_DOWN_MODE,
  FL_GET_PHYSICAL_INFO,
  FL_PHYSICAL_READ,
  FL_PHYSICAL_WRITE,
  FL_PHYSICAL_ERASE,
  FL_UPDATE_SOCKET_PARAMS,
  FL_UNIQUE_ID,
  FL_CUSTOMER_ID,
  BD_FORMAT_VOLUME,
  BD_FORMAT_PHYSICAL_DRIVE,
  FL_PLACE_EXB,
  FL_READ_BBT,
  FL_WRITE_BBT,

  INDEX_NEED_PARTITION_0_END    = 800,

/* The following routines will go through the volume validity check */

      /* PROTECTION */
  FL_PROTECTION_GET_TYPE,
  FL_PROTECTION_REMOVE_KEY,
  FL_PROTECTION_INSERT_KEY,
  FL_PROTECTION_SET_LOCK,
  FL_PROTECTION_CHANGE_KEY,
  FL_PROTECTION_CHANGE_TYPE,
  FL_COUNT_VOLUMES,
  FL_INQUIRE_CAPABILITIES,
     /* BDTL */
  FL_MOUNT_VOLUME,
  FL_ABS_MOUNT,
  BD_FORMAT_LOGICAL_DRIVE,
  FL_WRITE_PROTECTION,
  FL_DISMOUNT_VOLUME,
  FL_CHECK_VOLUME,
  FL_DEFRAGMENT_VOLUME,
  FL_ABS_WRITE,
  FL_ABS_DELETE,
  FL_ABS_READ,
  FL_ABS_ADDRESS,
  FL_GET_BPB,
  FL_SECTORS_IN_VOLUME,
  FL_VOLUME_INFO,
  FL_VERIFY_VOLUME,
  FL_CLEAR_QUICK_MOUNT_INFO
} FLFunctionNo;


#endif /* FLFUNCNO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flparse.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLPARSE.C_V  $
 * 
 *    Rev 1.2   Jan 29 2002 20:09:04   oris
 * Added NAMING_CONVENTION prefix to flParsePath public routines.
 * 
 *    Rev 1.1   Apr 01 2001 07:59:42   oris
 * copywrite notice.
 * 
 *    Rev 1.0   Feb 04 2001 11:40:12   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#include "fatlite.h"

#ifdef PARSE_PATH


/*----------------------------------------------------------------------*/
/*		         f l P a r s e P a t h				*/
/*									*/
/* Converts a DOS-like path string to a simple-path array.		*/
/*                                                                      */
/* Note: Array length received in irPath must be greater than the 	*/
/* number of path components in the path to convert.			*/
/*									*/
/* Parameters:                                                          */
/*	ioreq->irData	: address of path string to convert		*/
/*	ioreq->irPath	: address of array to receive parsed-path	*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flParsePath(IOreq FAR2 *ioreq)
{
  char FAR1 *dosPath;

  FLSimplePath FAR1 *sPath = ioreq->irPath;

  unsigned offset = 0, dots = 0, chars = 0;
  FLBoolean isExt = FALSE;
  for (dosPath = (char FAR1 *) ioreq->irData; ; dosPath++) {
    if (*dosPath == '\\' || *dosPath == 0) {
      if (offset != 0) {
	while (offset < sizeof(FLSimplePath))
	  sPath->name[offset++] = ' ';
	if (chars == 0) {
	  if (dots == 2)
	    sPath--;
	}
	else
	  sPath++;
	offset = dots = chars = 0;
	isExt = FALSE;
      }
      sPath->name[offset] = 0;
      if (*dosPath == 0)
	break;
    }
    else if (*dosPath == '.') {
      dots++;
      while (offset < sizeof sPath->name)
	sPath->name[offset++] = ' ';
      isExt = TRUE;
    }
    else if (offset < sizeof(FLSimplePath) &&
	     (isExt || offset < sizeof sPath->name)) {
      chars++;
      if (*dosPath == '*') {
	while (offset < (isExt ? sizeof(FLSimplePath) : sizeof sPath->name))
	  sPath->name[offset++] = '?';
      }
      else if (*dosPath >= 'a' && *dosPath <= 'z')
	sPath->name[offset++] = *dosPath - ('a' - 'A');
      else
	sPath->name[offset++] = *dosPath;
    }
  }

  return flOK;
}

#endif /* PARSE_PATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flreq.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLREQ.H_V  $
 * 
 *    Rev 1.3   Jan 29 2002 20:09:12   oris
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * 
 *    Rev 1.2   Apr 01 2001 07:46:16   oris
 * Updated copywrite notice
 * 
 *    Rev 1.1   Feb 18 2001 12:07:24   oris
 * Added VOLUME_ACCUPIED volume flag.
 *
 *    Rev 1.0   Feb 04 2001 11:42:12   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLREQ_H
#define FLREQ_H

#include "flbase.h"

#define VOLUME_LOW_LVL_MOUNTED 1  /* Volume is mounted for low level operations */
#define	VOLUME_MOUNTED	       2  /* Volume is mounted */
#define VOLUME_12BIT_FAT       4  /* Volume uses 12-bit FAT */
#define	VOLUME_ABS_MOUNTED     8  /* Volume is mounted for abs calls */
#define VOLUME_WRITE_PROTECTED 16 /* Volume is write protected */
#define VOLUME_ACCUPIED        32 /* Volume record bellongs to a volume */

typedef unsigned FLHandle;	/* Handle of an open file or drive.	*/
				/* Actually an index to file table or	*/
				/* drive table.				*/

/*----------------------------------------------------------------------*/
/*			P a t h - N a m e s				                                      */
/*									                                                    */
/* A path-name is represented as an array of SimplePath records.	      */
/* Each SimplePath record holds a directory or file name segment, with  */
/* the full 8.3 (spaces not compressed) name.				                    */
/*									                                                    */
/* Path-names always start at the root directory. There is no current   */
/* directory. The directories pointers '.' and '..' can be specified	  */
/* as the 'name' part of the path-segment, except at the root-directory.*/
/*									                                                    */
/* Lower-case letters are different from upper-case. To be compatible   */
/* with DOS, file-names should be upper-case. File names may contain    */
/* any character, but files starting with hex E5 are considered deleted */
/* according to DOS convention.						                              */
/*									                                                    */
/* A null (hex 0) in the first byte of the name field denotes that the  */
/* path ends here.							                                        */
/*                                                                      */
/* Note that paths can be specified as strings: For example:     	      */
/*									                                                    */
/* "UTIL       FATLITE H  "    ===> "\UTIL\FATLITE.H".			            */
/* ""				 ===> "\" (root directory)		                              */
/* "AUTOEXECBAT"                ===> "\AUTOEXEC.BAT"			              */
/* "UTIL       ..         "	 ===> "\UTIL\.." (root directory)	          */
/*									                                                    */
/* The optional service flParsePath may be used to convert regular	    */
/* string paths to this format.						                              */
/*----------------------------------------------------------------------*/

typedef struct {
  char	name[8];	/* name part of path segment */
  /* A hex 0 in 1st character indicates end of path */
  char	ext[3];		/* extension part of path segment */
} FLSimplePath;

/*----------------------------------------------------------------------*/
/*			  I O r e q					                                            */
/*									                                                    */
/* IOreq is a common structure passed to all file-system functions.	    */
/* Refer to the description of individual functions for specific usage  */
/* of fields. Some fields have different names when used by different   */
/* functions, hence the use of unions.					                        */
/*									                                                    */
/*----------------------------------------------------------------------*/

typedef struct {
  FLHandle	irHandle;	/* Handle of file or drive for operation*/
  unsigned	irFlags;	/* function-specific flags 		*/
  FLSimplePath FAR1 * irPath;	/* path of file for operation 		*/
  void FAR1 *	irData;		/* Pointer to user-buffer for operation */
  long		irLength;	/* No. of bytes, size or position for   */
				/* operation			 	*/
#if defined(ABS_READ_WRITE) || defined(FL_LOW_LEVEL)
  long		irCount;	/* Count or offset for operaion		*/
#endif
} IOreq;

/* definiftions for absolute read & write */
#define irSectorCount	irCount
#define	irSectorNo	    irLength

/* definitions for physical read & write */
#define irByteCount	    irCount
#define irAddress       irLength

/* definitions for physical erase */
#define irUnitCount     irCount
#define irUnitNo	    irLength

/* definitions for writing exb file */
#define irWindowBase    irCount

/*----------------------------------------------------------------------*/
/*		            f l I n i t					                                  */
/*									                                                    */
/* Initializes the FLite system.                                        */
/*									                                                    */
/* Calling this function is optional. If it is not called,		          */
/* initialization will be done automatically on the first FLite call.	  */
/* This function is provided for those applications who want to		      */
/* explicitly initialize the system and get an initialization status.	  */
/*									                                                    */
/* Calling flInit after initialization was done has no effect.		      */
/*									                                                    */
/* Parameters:                                                          */
/*	None								                                                */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                          */
/*----------------------------------------------------------------------*/

extern FLStatus flInit(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flsocket.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLSOCKET.H_V  $
 * 
 *    Rev 1.5   Apr 15 2002 07:37:06   oris
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.4   Feb 19 2002 20:59:58   oris
 * Removed include directive to flbase.h
 * 
 *    Rev 1.3   Jan 17 2002 23:02:22   oris
 * Added flReadBackBufferOf  prototype
 * Added curPartition and verifyWrite variables in the socket record.
 * 
 *    Rev 1.2   Jul 13 2001 01:05:44   oris
 * Add forward definition for get read back buffer pointer.
 * 
 *    Rev 1.1   Apr 01 2001 07:46:04   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 11:53:24   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef FLSOCKET_H
#define FLSOCKET_H

#include "flbuffer.h"

#define ATTRIBUTE_SPACE_MAPPED      0x8000

typedef enum {PowerOff, PowerGoingOff, PowerOn} PowerState;


/* Socket state variables */
typedef struct tSocket FLSocket;      /* Forward definition */

struct tSocket {
  unsigned        volNo;         /* Volume no. of socket */
  unsigned        serialNo;      /* Serial no. of socket on controller */

  FLBoolean       cardChanged;   /* need media change notification */

  int             VccUsers;      /* No. of current VCC users */
  int             VppUsers;      /* No. of current VPP users */

  PowerState      VccState;      /* Actual VCC state */
  PowerState      VppState;      /* Actual VPP state */
  byte            curPartition;  /* Current partition to use the socket (set busy) */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  byte            verifyWrite;   /* VerifyWrite mode                               */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
  FLBoolean       remapped;      /* set to TRUE whenever the socket window is moved */

  void            (*powerOnCallback)(void *flash); /* Notification routine for Vcc on */
  void *          flash;         /* Flash object for callback */

  struct {                       /* Window state                     */
    unsigned int  baseAddress;   /* Physical base as a 4K page       */
    unsigned int  currentPage;   /* Our current window page mapping  */
    void FAR0 *   base;          /* Pointer to window base           */
    long int      size;          /* Window size (must by power of 2) */
    unsigned      speed;         /* in nsec.                         */
    unsigned      busWidth;      /* 8 or 16 bits                     */
  } window;

/*----------------------------------------------------------------------*/
/*                      c a r d D e t e c t e d                         */
/*                                                                      */
/* Detect if a card is present (inserted)                               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/* Returns:                                                             */
/*      0 = card not present, other = card present                      */
/*----------------------------------------------------------------------*/
  FLBoolean (*cardDetected)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*                           V c c O n                                        */
/*                                                                      */
/* Turns on Vcc (3.3/5 Volts). Vcc must be known to be good on exit.      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*VccOn)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*                         V c c O f f                                        */
/*                                                                      */
/* Turns off Vcc.                                                          */
/*                                                                          */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*VccOff)(FLSocket vol);

#ifdef SOCKET_12_VOLTS

/*----------------------------------------------------------------------*/
/*                           V p p O n                                        */
/*                                                                      */
/* Turns on Vpp (12 Volts. Vpp must be known to be good on exit.      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus      : 0 on success, failed otherwise                            */
/*----------------------------------------------------------------------*/
  FLStatus (*VppOn)(FLSocket vol);


/*----------------------------------------------------------------------*/
/*                         V p p O f f                                  */
/*                                                                      */
/* Turns off Vpp.                                                       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*VppOff)(FLSocket vol);

#endif      /* SOCKET_12_VOLTS */

/*----------------------------------------------------------------------*/
/*                      i n i t S o c k e t                             */
/*                                                                      */
/* Perform all necessary initializations of the socket or controller    */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus      : 0 on success, failed otherwise                  */
/*----------------------------------------------------------------------*/
  FLStatus (*initSocket)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*                        s e t W i n d o w                             */
/*                                                                      */
/* Sets in hardware all current window parameters: Base address, size,  */
/* speed and bus width.                                                 */
/* The requested settings are given in the 'vol.window' structure.      */
/*                                                                      */
/* If it is not possible to set the window size requested in            */
/* 'vol.window.size', the window size should be set to a larger value,  */
/* if possible. In any case, 'vol.window.size' should contain the       */
/* actual window size (in 4 KB units) on exit.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*setWindow)(FLSocket vol);


/*----------------------------------------------------------------------*/
/*               s e t M a p p i n g C o n t e x t                      */
/*                                                                      */
/* Sets the window mapping register to a card address.                  */
/*                                                                      */
/* The window should be set to the value of 'vol.window.currentPage',   */
/* which is the card address divided by 4 KB. An address over 128KB,    */
/* (page over 32K) specifies an attribute-space address.                */
/*                                                                      */
/* The page to map is guaranteed to be on a full window-size boundary.  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*setMappingContext)(FLSocket vol, unsigned page);

/*----------------------------------------------------------------------*/
/*       g e t A n d C l e a r C a r d C h a n g e I n d i c a t o r    */
/*                                                                      */
/* Returns the hardware card-change indicator and clears it if set.     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/* Returns:                                                             */
/*      0 = Card not changed, other = card changed                      */
/*----------------------------------------------------------------------*/
  FLBoolean (*getAndClearCardChangeIndicator)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*                      w r i t e P r o t e c t e d                     */
/*                                                                      */
/* Returns the write-protect state of the media                         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/* Returns:                                                             */
/*      0 = not write-protected, other = write-protected                */
/*----------------------------------------------------------------------*/
  FLBoolean (*writeProtected)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*            u p d a t e S o c k e t P a r a m s                       */
/*                                                                      */
/* Pass socket parameters to the socket interface layer.                */
/* The structure passed in irData is specific for each socket interface.*/
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : pointer identifying drive                      */
/*      params             : pointer to structure that holds socket     */
/*                    parameters.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*updateSocketParams)(FLSocket vol, void FAR1 *params);


/*----------------------------------------------------------------------*/
/*                      f r e e S o c k e t                             */
/*                                                                      */
/* Free resources that were allocated for this socket.                  */
/* This function is called when FLite exits.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
#ifdef EXIT
  void (*freeSocket)(FLSocket vol);
#endif
};


#define      UNDEFINED_MAPPING      0x7fff

typedef unsigned long CardAddress;      /* Physical offset on card */

/* See interface documentation of functions in socket.c */

extern FLStatus updateSocketParameters(FLSocket *, void FAR1 *);

extern FLStatus      flInitSockets(void);

#ifdef EXIT
extern void      flExitSocket(FLSocket *);
#endif

extern unsigned  flSocketNoOf(const FLSocket *);
extern FLSocket* flSocketOf(unsigned volNo);
extern FLBuffer* flBufferOf(unsigned volNo);
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
extern byte    * flReadBackBufferOf(unsigned volNo);
#endif /* VERIFY_WRITE || VERIFY_ERASE || MTD_RECONSTRUCT_BBT || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
extern void      flNeedVcc(FLSocket *);
extern void      flDontNeedVcc(FLSocket *);
#ifdef SOCKET_12_VOLTS
extern FLStatus  flNeedVpp(FLSocket *);
extern void      flDontNeedVpp(FLSocket *);
#endif
extern void      flSocketSetBusy(FLSocket *, FLBoolean);      /* entry/exit operations */
extern FLBoolean flWriteProtected(FLSocket *); /* write-protection status */
#ifndef FIXED_MEDIA
extern FLStatus  flMediaCheck(FLSocket *);      /* check for media status change */
extern void      flResetCardChanged(FLSocket *);
#endif
extern unsigned  flGetMappingContext(FLSocket *);  /* Currently mapped 4KB page */
extern void FAR0*flMap(FLSocket *, CardAddress);      /* map and point at card address */
extern void      flSetWindowBusWidth(FLSocket *, unsigned); /* set window data-path */
extern void      flSetWindowSpeed(FLSocket *, unsigned);      /* set window speed (nsec.) */
extern void      flSetWindowSize(FLSocket *, unsigned);      /* in 4KB units */

extern void      flSetPowerOnCallback(FLSocket *, void (*)(void *), void *);
                  /* Set MTD notification for socket power on */
extern void      flIntervalRoutine(FLSocket *);      /* socket interval routine */


extern byte noOfSockets;    /* No. of drives actually registered */

/* The milliseconds counter is active when socket polling is enabled. When
   the socket interval routine is called, the counter is incremented by
   the interval in milliseconds.
   The counter can be used to avoid getting in a loop that is not guaranteed
   to terminate (such as waiting for a flash status register). Save the counter
   at entry to the loop, and check in the loop the amount of time that
   was spent in the loop. */

extern dword flMsecCounter;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flsocket.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLSOCKET.C_V  $
 * 
 *    Rev 1.11   Apr 15 2002 07:37:04   oris
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.10   Jan 17 2002 23:02:12   oris
 * Removed SINGLE_BUFFER compilation flag
 * Made sure buffers are allocated when VERIFY_VOLUME and  MTD_RECONSTRUCT_BBT are defined
 * Set socket verify write mode according to environment variable
 * Verify write buffers are allocated according to define and not runtime  variable.
 * Added flReadBackBufferOf returning pointer to the readback buffer.
 * 
 *    Rev 1.9   Nov 21 2001 11:38:42   oris
 * Changed FL_WITH_VERIFY_WRITE and FL_WITHOUT_VERIFY_WRITE to FL_ON and  FL_OFF.
 * 
 *    Rev 1.8   Nov 08 2001 10:49:30   oris
 * Added run-time contorll over verify write mode buffers.
 * 
 *    Rev 1.7   Jul 13 2001 01:05:36   oris
 * Add allocation for read back buffer.
 * 
 *    Rev 1.6   May 16 2001 21:19:16   oris
 * Added the FL_ prefix to the following defines: ON , OFF, MALLOC and FREE.
 * 
 *    Rev 1.5   Apr 10 2001 16:42:16   oris
 * Bug fix - DiskOnChip socket routines clashed with pccards socket 
 * routines. Moved all DiskOnChip socket routines to docsoc.c.
 * 
 *    Rev 1.4   Apr 09 2001 15:09:38   oris
 * End with an empty line.
 * 
 *    Rev 1.3   Apr 01 2001 07:55:04   oris
 * copywrite notice.
 * Removed defaultSocketParams routine due to a conflict in windows CE.
 * Aliggned left all # directives.
 * 
 *    Rev 1.2   Feb 14 2001 01:58:46   oris
 * Changed defaultUpdateSocketParameters prototype.
 *
 *    Rev 1.1   Feb 12 2001 12:14:06   oris
 * Added support for updateSocketParams (retreave FLSocket record)
 *
 *    Rev 1.0   Feb 04 2001 14:17:16   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#include "flsocket.h"

byte noOfSockets = 0;        /* No. of drives actually registered */

static FLSocket vols[SOCKETS];

#ifdef FL_MALLOC
static FLBuffer *volBuffers[SOCKETS];
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
static byte* readBackBuffer[SOCKETS];
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME || MTD_RECONSTRUCT_BBT || VERIFY_ERASED_SECTOR */

#else
static FLBuffer volBuffers[SOCKETS];
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
static byte readBackBuffer[SOCKETS][READ_BACK_BUFFER_SIZE];
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME || MTD_RECONSTRUCT_BBT || VERIFY_ERASED_SECTOR */
#endif /* FL_MALLOC */

/*----------------------------------------------------------------------*/
/*                        f l S o c k e t N o O f                       */
/*                                                                      */
/* Gets the volume no. connected to a socket                            */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*         volume no. of socket                                         */
/*----------------------------------------------------------------------*/

unsigned flSocketNoOf(const FLSocket vol)
{
  return vol.volNo;
}


/*----------------------------------------------------------------------*/
/*                        f l S o c k e t O f                           */
/*                                                                      */
/* Gets the socket connected to a volume no.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        volNo                : Volume no. for which to get socket     */
/*                                                                      */
/* Returns:                                                             */
/*         socket of volume no.                                         */
/*----------------------------------------------------------------------*/

FLSocket *flSocketOf(unsigned volNo)
{
  return &vols[volNo];
}


/*----------------------------------------------------------------------*/
/*                        f l B u f f e r O f                           */
/*                                                                      */
/* Gets the buffer connected to a volume no.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        volNo                : Volume no. for which to get socket     */
/*                                                                      */
/* Returns:                                                             */
/*         buffer of volume no.                                         */
/*----------------------------------------------------------------------*/

FLBuffer *flBufferOf(unsigned volNo)
{
#ifdef FL_MALLOC
  return volBuffers[volNo];
#else
  return &volBuffers[volNo];
#endif
}

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined (VERIFY_ERASED_SECTOR))
/*----------------------------------------------------------------------*/
/*                        f l R e a d B a c k B u f f e r O f           */
/*                                                                      */
/* Gets the read back buffer connected to a volume no.                  */
/*                                                                      */
/* Parameters:                                                          */
/*        volNo                : Volume no. for which to get socket     */
/*                                                                      */
/* Returns:                                                             */
/*         buffer of volume no.                                         */
/*----------------------------------------------------------------------*/

byte * flReadBackBufferOf(unsigned volNo)
{
#ifdef FL_MALLOC
  return readBackBuffer[volNo];
#else
  return &(readBackBuffer[volNo][0]);
#endif
}
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME || MTD_RECONSTRUCT_BBT || VERIFY_ERASED_SECTOR */

/*----------------------------------------------------------------------*/
/*                      f l W r i t e P r o t e c t e d                 */
/*                                                                      */
/* Returns the write-protect state of the media                         */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*        0 = not write-protected, other = write-protected              */
/*----------------------------------------------------------------------*/

FLBoolean flWriteProtected(FLSocket vol)
{
  return vol.writeProtected(&vol);
}


#ifndef FIXED_MEDIA

/*----------------------------------------------------------------------*/
/*                    f l R e s e t C a r d C h a n g e d               */
/*                                                                      */
/* Acknowledges a media-change condition and turns off the condition.   */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flResetCardChanged(FLSocket vol)
{
  if (vol.getAndClearCardChangeIndicator)
      vol.getAndClearCardChangeIndicator(&vol);  /* turn off the indicator */

  vol.cardChanged = FALSE;
}


/*----------------------------------------------------------------------*/
/*                        f l M e d i a C h e c k                       */
/*                                                                      */
/* Checks the presence and change status of the media                   */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*         flOK                ->        Media present and not changed  */
/*        driveNotReady   ->        Media not present                   */
/*        diskChange        ->        Media present but changed         */
/*----------------------------------------------------------------------*/

FLStatus flMediaCheck(FLSocket vol)
{
  if (!vol.cardDetected(&vol)) {
    vol.cardChanged = TRUE;
    return flDriveNotReady;
  }

  if (vol.getAndClearCardChangeIndicator &&
      vol.getAndClearCardChangeIndicator(&vol))
    vol.cardChanged = TRUE;

  return vol.cardChanged ? flDiskChange : flOK;
}

#endif

/*----------------------------------------------------------------------*/
/*                   f l G e t M a p p i n g C o n t e x t              */
/*                                                                      */
/* Returns the currently mapped window page (in 4KB units)              */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*        unsigned int        : Current mapped page no.                 */
/*----------------------------------------------------------------------*/

unsigned flGetMappingContext(FLSocket vol)
{
  return vol.window.currentPage;
}


/*----------------------------------------------------------------------*/
/*                              f l M a p                               */
/*                                                                      */
/* Maps the window to a specified card address and returns a pointer to */
/* that location (some offset within the window).                       */
/*                                                                      */
/* NOTE: Addresses over 128M are attribute memory. On PCMCIA adapters,  */
/* subtract 128M from the address and map to attribute memory.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol         : Pointer identifying drive                         */
/*      address     : Byte-address on card. NOT necessarily on a        */
/*                    full-window boundary.                             */
/*                    If above 128MB, address is in attribute space.    */
/*                                                                      */
/* Returns:                                                             */
/*        Pointer to a location within the window mapping the address.  */
/*----------------------------------------------------------------------*/

void FAR0 *flMap(FLSocket vol, CardAddress address)
{
  unsigned pageToMap;

  if (vol.window.currentPage == UNDEFINED_MAPPING)
    vol.setWindow(&vol);
  pageToMap = (unsigned) ((address & -vol.window.size) >> 12);

  if (vol.window.currentPage != pageToMap) {
    vol.setMappingContext(&vol, pageToMap);
    vol.window.currentPage = pageToMap;
    vol.remapped = TRUE;        /* indicate remapping done */
  }

  return addToFarPointer(vol.window.base,address & (vol.window.size - 1));
}


/*----------------------------------------------------------------------*/
/*                    f l S e t W i n d o w B u s W i d t h             */
/*                                                                      */
/* Requests to set the window bus width to 8 or 16 bits.                */
/* Whether the request is filled depends on hardware capabilities.      */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*      width                : Requested bus width                      */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSetWindowBusWidth(FLSocket vol, unsigned width)
{
  vol.window.busWidth = width;
  vol.window.currentPage = UNDEFINED_MAPPING;        /* force remapping */
}


/*----------------------------------------------------------------------*/
/*                   f l S e t W i n d o w S p e e d                    */
/*                                                                      */
/* Requests to set the window speed to a specified value.               */
/* The window speed is set to a speed equal or slower than requested,   */
/* if possible in hardware.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*      nsec                : Requested window speed in nanosec.        */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSetWindowSpeed(FLSocket vol, unsigned nsec)
{
  vol.window.speed = nsec;
  vol.window.currentPage = UNDEFINED_MAPPING;        /* force remapping */
}


/*----------------------------------------------------------------------*/
/*                    f l S e t W i n d o w S i z e                     */
/*                                                                      */
/* Requests to set the window size to a specified value (power of 2).   */
/* The window size is set to a size equal or greater than requested,    */
/* if possible in hardware.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*      sizeIn4KBUnits : Requested window size in 4 KByte units.        */
/*                         MUST be a power of 2.                        */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSetWindowSize(FLSocket vol, unsigned sizeIn4KBunits)
{
  vol.window.size = (long) (sizeIn4KBunits) * 0x1000L;
        /* Size may not be possible. Actual size will be set by 'setWindow' */
  vol.window.base = physicalToPointer((long) vol.window.baseAddress << 12,
                                      vol.window.size,vol.volNo);
  vol.window.currentPage = UNDEFINED_MAPPING;        /* force remapping */
}


/*----------------------------------------------------------------------*/
/*                   f l S o c k e t S e t B u s y                      */
/*                                                                      */
/* Notifies the start and end of a file-system operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*        vol      : Pointer identifying drive                          */
/*      state      : FL_ON (1) = operation entry                        */
/*                   FL_OFF(0) = operation exit                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSocketSetBusy(FLSocket vol, FLBoolean state)
{
  if (state == FL_OFF) 
  {
#if POLLING_INTERVAL == 0
    /* If we are not polling, activate the interval routine before exit */
    flIntervalRoutine(&vol);
#endif
  }
  else 
  {
    /* Set verify write operation to this socket */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
    if(flVerifyWrite[vol.volNo][vol.curPartition] == FL_ON)
    {
       vol.verifyWrite = FL_ON;
    }
    else
    {
       vol.verifyWrite = FL_OFF;
    }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
    vol.window.currentPage = UNDEFINED_MAPPING;        /* don't assume mapping still valid */
#ifdef FIXED_MEDIA
    vol.remapped = TRUE;
#endif /* FIXED_MEDIA */
  }
}


/*----------------------------------------------------------------------*/
/*                          f l N e e d V c c                           */
/*                                                                      */
/* Turns on Vcc, if not on already                                      */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, failed otherwise              */
/*----------------------------------------------------------------------*/

void flNeedVcc(FLSocket vol)
{
  vol.VccUsers++;
  if (vol.VccState == PowerOff) {
    vol.VccOn(&vol);
    if (vol.powerOnCallback)
      vol.powerOnCallback(vol.flash);
  }
  vol.VccState = PowerOn;
}


/*----------------------------------------------------------------------*/
/*                       f l D o n t N e e d V c c                      */
/*                                                                      */
/* Notifies that Vcc is no longer needed, allowing it to be turned off. */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flDontNeedVcc(FLSocket vol)
{
  if (vol.VccUsers > 0)
    vol.VccUsers--;
}

#ifdef SOCKET_12_VOLTS

/*----------------------------------------------------------------------*/
/*                          f l N e e d V p p                           */
/*                                                                      */
/* Turns on Vpp, if not on already                                      */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, failed otherwise              */
/*----------------------------------------------------------------------*/

FLStatus flNeedVpp(FLSocket vol)
{
  vol.VppUsers++;
  if (vol.VppState == PowerOff)
    checkStatus(vol.VppOn(&vol));
  vol.VppState = PowerOn;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                       f l D o n t N e e d V p p                      */
/*                                                                      */
/* Notifies that Vpp is no longer needed, allowing it to be turned off. */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flDontNeedVpp(FLSocket vol)
{
  if (vol.VppUsers > 0)
    vol.VppUsers--;
}

#endif        /* SOCKET_12_VOLTS */


/*----------------------------------------------------------------------*/
/*                  f l S e t P o w e r O n C a l l b a c k             */
/*                                                                      */
/* Sets a routine address to call when powering on the socket.          */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*      routine                : Routine to call when turning on power  */
/*        flash                : Flash object of routine                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSetPowerOnCallback(FLSocket vol, void (*routine)(void *flash), void *flash)
{
  vol.powerOnCallback = routine;
  vol.flash = flash;
}



/*----------------------------------------------------------------------*/
/*                    f l I n t e r v a l R o u t i n e                 */
/*                                                                      */
/* Performs periodic socket actions: Checks card presence, and handles  */
/* the Vcc & Vpp turn off mechanisms.                                   */
/*                                                                      */
/* The routine may be called from the interval timer or sunchronously.  */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flIntervalRoutine(FLSocket vol)
{
#ifndef FIXED_MEDIA
  if (vol.getAndClearCardChangeIndicator == NULL &&
      !vol.cardChanged)
    if (!vol.cardDetected(&vol))        /* Check that the card is still there */
      vol.cardChanged = TRUE;
#endif

  if (vol.VppUsers == 0) {
    if (vol.VppState == PowerOn)
      vol.VppState = PowerGoingOff;
    else if (vol.VppState == PowerGoingOff) {
      vol.VppState = PowerOff;
#ifdef SOCKET_12_VOLTS
      vol.VppOff(&vol);
#endif
    }
    if (vol.VccUsers == 0) {
      if (vol.VccState == PowerOn)
        vol.VccState = PowerGoingOff;
      else if (vol.VccState == PowerGoingOff) {
        vol.VccState = PowerOff;
        vol.VccOff(&vol);
      }
    }
  }
}

/*----------------------------------------------------------------------*/
/*                       u d a t e S o c k e t P a r a m e t e r s      */
/*                                                                      */
/* Pass socket parameters to the socket interface layer.                */
/* This function should be called after the socket parameters (like     */
/* size and base) are known. If these parameters are known at           */
/* registration time then there is no need to use this function, and    */
/* the parameters can be passed to the registration routine.            */
/* The structure passed in irData is specific for each socket interface.*/
/*                                                                      */
/* Note : When using DiskOnChip this routine returns the socekt         */
/*        parameters instead of initialiaing them.                      */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*  params  : Record returning (or sending) the flsocket record         */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus         : 0 on success                               */
/*----------------------------------------------------------------------*/
FLStatus updateSocketParameters(FLSocket vol, void FAR1 *params)
{
  if (vol.updateSocketParams)
    vol.updateSocketParams(&vol, params);

  return flOK;
}


#ifdef EXIT
/*----------------------------------------------------------------------*/
/*                    f l E x i t S o c k e t                           */
/*                                                                      */
/* Reset the socket and free resources that were allocated for this     */
/* socket.                                                              */
/* This function is called when FLite exits.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flExitSocket(FLSocket vol)
{
  flMap(&vol, 0);                           /* reset the mapping register */
  flDontNeedVcc(&vol);
  flSocketSetBusy(&vol,FL_OFF);
  vol.freeSocket(&vol);                     /* free allocated resources */
#ifdef FL_MALLOC
  FL_FREE(volBuffers[vol.volNo]);
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  FL_FREE(readBackBuffer[vol.volNo]);
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME || MTD_RECONSTRUCT_BBT || VERIFY_ERASED_SECTOR */
#endif /* FL_MALLOC */
}
#endif /* EXIT */

/*-----------------------------------------------------------------------*/
/*                       f l I n i t S o c k e t s                       */
/*                                                                       */
/* First call to this module: Initializes the controller and all sockets */
/*                                                                       */
/* Parameters:                                                           */
/*        vol                : Pointer identifying drive                 */
/*                                                                       */
/* Returns:                                                              */
/*        FLStatus        : 0 on success, failed otherwise               */
/*---_-------------------------------------------------------------------*/

FLStatus flInitSockets(void)
{
  unsigned volNo;
  FLSocket vol = vols;

  for (volNo = 0; volNo < noOfSockets; volNo++, pVol++) {
    flSetWindowSpeed(&vol, 250);
    flSetWindowBusWidth(&vol, 16);
    flSetWindowSize(&vol, 2);                /* make it 8 KBytes */

    vol.cardChanged = FALSE;

#ifdef FL_MALLOC
    /* allocate buffer for this socket */
    volBuffers[volNo] = (FLBuffer *)FL_MALLOC(sizeof(FLBuffer));
    if (volBuffers[volNo] == NULL) {
      DEBUG_PRINT(("Debug: failed allocating sector buffer.\r\n"));
      return flNotEnoughMemory;
    }
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
    /* allocate read back buffer for this socket */
    readBackBuffer[volNo] = (byte *)FL_MALLOC(READ_BACK_BUFFER_SIZE);
    if (readBackBuffer[volNo] == NULL) {
       DEBUG_PRINT(("Debug: failed allocating readBack buffer.\r\n"));
       return flNotEnoughMemory;
    }
#endif /* VERIFY_WRITE || VERIFY_ERASE || MTD_READ_BBT || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#endif /* FL_MALLOC */

    checkStatus(vol.initSocket(&vol));

#ifdef SOCKET_12_VOLTS
    vol.VppOff(&vol);
    vol.VppState = PowerOff;
    vol.VppUsers = 0;
#endif
    vol.VccOff(&vol);
    vol.VccState = PowerOff;
    vol.VccUsers = 0;
  }

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flmtl.c ===
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/flmtl.c_V  $
 * 
 *    Rev 1.11   Nov 08 2001 10:49:20   oris
 * Added support for up to 1GB DiskOnChips.
 * 
 *    Rev 1.10   Sep 24 2001 18:23:40   oris
 * Removed warnings.
 * 
 *    Rev 1.9   Sep 15 2001 23:46:16   oris
 * Changed progress callback routine to support up to 64K units.
 *
 *    Rev 1.8   Jul 13 2001 01:05:16   oris
 * Removed warnings.
 * Bug fix - exception when format routine is called with null progress call back routine.
 * Report noOfDrives as 1.
 *
 *    Rev 1.7   Jun 17 2001 08:18:40   oris
 * Add improoved the format progress call back routine.
 * Removed fack number of TLS in mtlPreMount routine.
 *
 *    Rev 1.6   May 21 2001 16:13:08   oris
 * Replaced memcpy with tffscpy Macro.
 *
 *    Rev 1.5   May 17 2001 18:54:26   oris
 * Removed warnings.
 *
 *    Rev 1.4   May 16 2001 21:19:02   oris
 * Changed the fl_MTLdefragMode variable to a global environment variable.
 * MTL now changes the noOfDriver variable after the first mount and restores it after uninstall.
 * Added missing ifdef directives.
 * Removed warnings.
 * Removed readBBT and writeBBT routines.
 * Improved MTL protection routine.
 *
 *    Rev 1.3   Apr 01 2001 08:01:18   oris
 * copywrite notice.
 * Alligned left all # directives.
 *
 *    Rev 1.2   Feb 18 2001 12:06:54   oris
 * Install mtl will now fake the noOfTLs in order to be the only TL.
 * Placed mtlFormat under FORMAT_VOLUME compilation flag.
 * Place mtlProtection under HW_PROTECTION compilation flag.
 * Changed mtlPreMount arg sanity check to include partition number.
 * Changed tmpflash to tmpFlash.
 *
 *    Rev 1.1   Feb 14 2001 02:09:38   oris
 * Changed readBBT to return media size.
 * Added boundry argument to writeBBT.
 *
 *    Rev 1.0   Feb 12 2001 12:07:02   oris
 * Initial revision.
 *
 *    Rev 1.3   Jan 24 2001 18:10:48   oris
 * Bug fix: MTL failed to register because noOfTLs wan't updated
 *
 *    Rev 1.2   Jan 24 2001 16:34:06   oris
 * MTL defragmentation changed, alt. defragmentation added.
 *
 *    Rev 1.1   Jan 22 2001 22:10:50   amirm
 * #define FL_MTL_HIDDEN_SECTORS added
 *
 *    Rev 1.0   Jan 22 2001 18:27:54   amirm
 * Initial revision.
 *
 */


/*
 * Include
 */

#include "fltl.h"


/*
 * Configuration
 */

/* This defined sets the number of sectors to ignore starting from the
 * first device. The default value should be 1 therfore ignoring sector
 * 0 of the first device. Ignioring sector 0 gurentees that the combined
 * device does not use the BPB of the first device, which does not report
 * the C/H/S of the new combined media. The next format operation would
 * write a new BPB that would fit the new combined media size.
 */

#define FL_MTL_HIDDEN_SECTORS   1

/*
 * Extern
 */

/*
 * Globals
 */

FLStatus  flRegisterMTL  (void);    /* see also stdcomp.h */
FLStatus  flmtlInstall   (void);
FLStatus  flmtlUninstall (void);

/*
 * Local types
 */

/* I/O vector for splitting I/O among physical devices */

typedef struct {
    SectorNo  startSector;
    SectorNo  sectors;
} tMTLiov;


/* Physical flash device. Part of MTL volume. */

typedef struct {
    SectorNo     virtualSectors;
    TL           tl;
    dword        physicalSize;
} tMTLPhysDev;


/* MTL volume */

struct tTLrec {
    int          noOfTLs;
    int          noOfDrives;
    SectorNo     virtualSectors;
    tMTLPhysDev  devs[SOCKETS];
};

typedef TLrec MTL;

/*
 * Local data
 */

/* only one MTL volume is supported */

static MTL mvol;

/* progress callBack routine */

FLProgressCallback globalProgressCallback = NULL;

/* access macros for MTL volume */

#define  mT(dev)            (mvol.devs[dev].tl)
#define  mS(dev)            (mvol.devs[dev].virtualSectors)
#define  mP(dev)            (mvol.devs[dev].physicalSize)

#define  mpT(pvol,dev)   ((pvol)->devs[dev].tl)
#define  mpF(pvol,dev)   ((pvol)->devs[dev].flash)
#define  mpS(pvol,dev)   ((pvol)->devs[dev].virtualSectors)

/*
 * Local routines
 */

static FLStatus  mtlSplitIO (MTL *pvol, SectorNo startSector,
                	SectorNo sectors, tMTLiov *iov);
static FLStatus  mtlWrite (MTL *pvol, SectorNo startSector,
                      SectorNo *pSectorsToWrite, void FAR1 *buf);
static FLStatus  mtlMount (unsigned volNo, TL *tl, FLFlash *flash,
                           FLFlash **notUsed);
#if defined(DEFRAGMENT_VOLUME) || defined(SINGLE_BUFFER)
static FLStatus  mtlDefragment (MTL *pvol, long FAR2 *sectorsNeeded);
#ifdef ENVIRONMENT_VARS
static FLStatus  mtlDefragmentAlt (MTL *pvol, long FAR2 *sectorsNeeded);
#endif /* ENVIRNOMETN_VARS */
#endif /* DEFRAGMENT_VOLUME || SINGLE_BUFFER */
static void      mtlUnmount (MTL *pvol);
#ifdef FORMAT_VOLUME
static FLStatus  mtlFormat (unsigned volNo, TLFormatParams* formatParams,
                                            FLFlash *flash);
#endif /* FORMAT_VOLUME */
static FLStatus  mtlWriteSector (MTL *pvol, SectorNo sectorNo,
                                            void FAR1 *fromAddress);
static FLStatus  mtlDeleteSector (MTL *pvol, SectorNo sectorNo,
                                             SectorNo noOfSectors);
static FLStatus  mtlInfo (MTL *pvol, TLInfo *tlInfo);
static FLStatus  mtlSetBusy (MTL *pvol, FLBoolean state);
static SectorNo  mtlSectorsInVolume (MTL *pvol);
static const void FAR0  *mtlMapSector (MTL *pvol, SectorNo sectorNo,
                          CardAddress *physAddress);
#ifdef HW_PROTECTION
static FLStatus  mtlProtection(FLFunctionNo callType,
                   IOreq FAR2* ioreq, FLFlash* flash);
#endif /* HW_PROTECTION */
static FLStatus  mtlPreMount(FLFunctionNo callType, IOreq FAR2* ioreq ,
                 FLFlash* flash,FLStatus* status);

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l S p l i t I O                              *
 *                                                                            *
 *  Setup I/O vector for splitting I/O request among physical devices.        *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      startSector          : starting sector # (zero-based)                 *
 *      sectors              : total number of sectors                        *
 *      iov                  : I/O vector to setup                            *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlSplitIO (MTL *pvol, SectorNo startSector, SectorNo sectors,
                                                              tMTLiov *iov)
{
    SectorNo  devFirstSectNo;
    SectorNo  devLastSectNo;
    int       iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    /* clear I/O vector */

    for (iDev = 0;  iDev < SOCKETS;  iDev++) {
      iov[iDev].sectors     = (SectorNo) 0;
      iov[iDev].startSector = (SectorNo)(-1);
    }

    /* split I/O operation among physical devices */

    devFirstSectNo = (SectorNo) 0;

    for (iDev = 0;  (iDev < noOfSockets) && (sectors > ((SectorNo) 0));  iDev++) {

        devLastSectNo = devFirstSectNo + (mpS(pvol,iDev) - ((SectorNo) 1));

        if ((startSector >= devFirstSectNo) && (startSector <= devLastSectNo)) {

          iov[iDev].startSector = startSector - devFirstSectNo + FL_MTL_HIDDEN_SECTORS;
          iov[iDev].sectors     = devLastSectNo - startSector + ((SectorNo) 1);

            startSector = devLastSectNo + ((SectorNo) 1);

            if (sectors <= iov[iDev].sectors) {
                iov[iDev].sectors = sectors;
                startSector = (SectorNo) 0;
                sectors     = (SectorNo) 0;
            }
        	  else {
               sectors -= iov[iDev].sectors;
            }
        }

        devFirstSectNo = devLastSectNo + ((SectorNo) 1);
    }

    if (sectors > ((SectorNo) 0)) {
        DEBUG_PRINT(("Debug: can't split I/O request among physical devices.\n"));
        return flNoSpaceInVolume;
    }

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l M a p S e c t o r                          *
 *                                                                            *
 *  TL's standard 'map one sector' routine.                                   *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      sectorNo             : sector # to map (zero-based)                   *
 *      physAddress          : optional pointer to receive sector's physical  *
 *                             address on the media                           *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static const void FAR0  *mtlMapSector (MTL *pvol, SectorNo sectorNo,
                                                  CardAddress *physAddress)
{
    SectorNo  sectorsToMap;
    tMTLiov   iov[SOCKETS];
    int       iDev;

    /* pass call to the TL of the respective underlaying physical device */

    sectorsToMap = (SectorNo) 1;
    if (mtlSplitIO(pvol, sectorNo, sectorsToMap, iov) != flOK)
        return NULL;

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {
        if (iov[iDev].sectors != ((SectorNo) 0)) {
           return mpT(pvol,iDev).mapSector (mpT(pvol,iDev).rec,
						      iov[iDev].startSector, physAddress);
        }
    }

    return NULL;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l W r i t e                                  *
 *                                                                            *
 *  Split call to write multiple consequitive sectors among TLs of the        *
 *  underlaying physical devices.                                             *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      startSector          : starting sector # (zero-based)                 *
 *      pSectorsToWrite      : on entry - total number of sectors to write    *
 *                             on exit  - total number of sectors written     *
 *      buf                  : buffer containing data to write to the media   *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlWrite (MTL *pvol, SectorNo startSector,
               SectorNo *pSectorsToWrite, void FAR1 *buf)
{
    tMTLiov  iov[SOCKETS];
    int      iDev;

    /* split call among TLs of the underlaying physical devices */

    checkStatus( mtlSplitIO(pvol, startSector, *pSectorsToWrite, iov) );

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {

	      if (iov[iDev].sectors != ((SectorNo) 0)) {
           checkStatus( mpT(pvol,iDev).writeSector(mpT(pvol,iDev).rec,
                            iov[iDev].startSector,buf) );
           *pSectorsToWrite -= iov[iDev].sectors;
           buf = BYTE_ADD_FAR(buf,(CardAddress)iov[iDev].sectors << SECTOR_SIZE_BITS);
        }

    }

    if (*pSectorsToWrite != ((SectorNo) 0))
        return flIncomplete;

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                          m t l W r i t e S e c t o r                       *
 *                                                                            *
 *  TL's standard 'write one sector' routine.                                 *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      sectorNo             : sector # to write to (zero-based)              *
 *      fromAddress          : buffer containing data to write to the media   *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlWriteSector (MTL *pvol, SectorNo sectorNo, void FAR1 *fromAddress)
{
    SectorNo  sectorsToWrite = (SectorNo) 1;

    /* pass call to the TL of the respective underlaying physical device */

    checkStatus( mtlWrite(pvol, sectorNo, &sectorsToWrite, (char FAR1 *)fromAddress) );

    if (sectorsToWrite != ((SectorNo) 0))
        return flIncomplete;

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        m t l D e l e t e S e c t o r                       *
 *                                                                            *
 *  TL's standard 'delete range of sectors' routine.                          *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      startSector          : starting sector # (zero-based)                 *
 *      sectors              : total number of sectors to delete              *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlDeleteSector (MTL *pvol, SectorNo startSector,
                                             SectorNo sectors)
{
    tMTLiov  iov[SOCKETS];
    int      iDev;

    /* split call among TLs of the underlaying physical devices */

    checkStatus( mtlSplitIO(pvol, startSector, sectors, iov) );

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {

        if (iov[iDev].sectors != ((SectorNo) 0)) {
           checkStatus( mpT(pvol,iDev).deleteSector(mpT(pvol,iDev).rec,
                                                     iov[iDev].startSector,
                                                     iov[iDev].sectors) );
        }

        sectors -= iov[iDev].sectors;
    }

    if (sectors != ((SectorNo) 0))
        return flIncomplete;

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l I n f o                                    *
 *                                                                            *
 *  TL's standard 'get info' routine.                                         *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      pTLinfo              : pointer to the TLInfo structure to fill in     *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlInfo (MTL *pvol, TLInfo *pTLinfo)
{
    TLInfo  tmp;
    int     iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    pTLinfo->sectorsInVolume = pvol->virtualSectors;

    /*
     * The 'eraseCycles' is reported as a sum of that of all the underlaying
     * physical devices. The 'bootAreaSize' is set to the one of the 1st
     * underlaying physical device.
     */

    pTLinfo->bootAreaSize = (dword) 0;
    pTLinfo->eraseCycles  = (dword) 0;

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {
	     if (mpT(pvol,iDev).getTLInfo != NULL) {
          checkStatus( mpT(pvol,iDev).getTLInfo(mpT(pvol,iDev).rec, &tmp) );

          pTLinfo->eraseCycles += tmp.eraseCycles;

          if (iDev == 0)
    	        pTLinfo->bootAreaSize = tmp.bootAreaSize;
			 }
    }

    return flOK;
}

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l S e t B u s y                              *
 *                                                                            *
 *  TL's standard routine which is called at the beginning and and the end of *
 *  the block device operation.                                               *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      state                : FL_ON  - start of block device operation          *
 *                             FL_OFF - end of block device operation            *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus mtlSetBusy (MTL *pvol, FLBoolean state)
{
    int iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
       return flBadDriveHandle;

    /* broadcast this call to TLs of all the underlaying physical devices */

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {
       if (mpT(pvol,iDev).tlSetBusy != NULL) {
          checkStatus( mpT(pvol,iDev).tlSetBusy(mpT(pvol,iDev).rec, state) );
       }
    }

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                  m t l S e c t o r s I n V o l u m e                       *
 *                                                                            *
 *  Report the total number of sectors in the volume.                         *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      Total number of sectors in the volume, or zero in case of error.      *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static SectorNo mtlSectorsInVolume (MTL *pvol)
{
    /* check 'pvol' for sanity */

    if (pvol != &mvol)
	return ((SectorNo) 0);

    return pvol->virtualSectors;
}




#if defined(DEFRAGMENT_VOLUME) || defined(SINGLE_BUFFER)

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l D e f r a g m e n t                        *
 *                                                                            *
 *  TL's standard garbage collection / volume defragmentaion routine.         *
 *                                                                            *
 *  Note : The garbage collection algorithm will try and free the required    *
 *         number of sectors on each of the combined devices.                 *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      sectorsNeeded        : On entry - minimum number of free sectors that *
 *                             are requested to be on the media upon call     *
 *                             completion. Two special cases: zero for        *
 *                             complete defragmentation of all the physical   *
 *                             devices, and '-1' for minimal defragmentation  *
 *                             of each physical device.                       *
 *                             On exit  - actual number of free sectors on    *
 *                             the media.                                     *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlDefragment (MTL *pvol, long FAR2 *sectorsNeeded)
{
    long      freeSectors;
    FLStatus  status;
    int       iDev;
    long      tmp;
    FLStatus  tmpStatus;

    /* check args for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    /*
     * Pass call to the TL of the respective underlaying physical device.
     * Count total number of free sectors on all devices.
     */

    status = flOK;

    freeSectors = (long) 0;

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {

      	if (mpT(pvol,iDev).defragment != NULL) {

           switch (*sectorsNeeded) {

    	        case ((long)(-1)):               /* minimal defragmenation */
                 tmp = (long)(-1);
                 break;

    	        case ((long) 0):                 /* complete defragmenation */
                 tmp = mpS(pvol,iDev);
                 break;

    	        default:                         /* partial defragmentation */
                 if (*sectorsNeeded < (long) mpS(pvol,iDev))
								 {
        	          tmp = *sectorsNeeded;
								 }
                 else
								 {
        	          tmp = mpS(pvol,iDev);    /* complete defragmentation */
								 }
                 break;
					 }

           tmpStatus = mpT(pvol,iDev).defragment (mpT(pvol,iDev).rec, ((long FAR2 *) &tmp));
           if (tmpStatus != flBadFormat)
					 {
    	        freeSectors += tmp;
					 }
           else
					 {
    	        status = tmpStatus;
					 }
				}
    }

    *sectorsNeeded = freeSectors;

    if (*sectorsNeeded == ((long) 0))
	      return flNoSpaceInVolume;

    return status;
}

#ifdef ENVIRONMENT_VARS

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        m t l D e f r a g m e n t A l t                     *
 *                                                                            *
 *  TL's alternative garbage collection / volume defragmentaion routine.      *
 *                                                                            *
 *  Note : The garbage collection algorithm Perform quick gurbage collections *
 *         from drive 0 until there is no more "garbage" to collect or until  *
 *         there is enough clean space. If the specified clean spage was not  *
 *         achieved try the next device.                                      *
 *         While this method is faster then the standard defragment, it does  *
 *         not gurantee that when the clean sectors are needed they will be   *
 *         available. This is becuase write operation on MTL will directed    *
 *         the write operation to a specific device according to the specifed *
 *         virtual sector number (not necceseraly starting from device #0).   *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      sectorsNeeded        : On entry - minimum number of free sectors that *
 *                             are requested to be on the media upon call     *
 *                             completion. Two special cases: zero for        *
 *                             complete defragmentation of all the physical   *
 *                             devices, and '-1' for minimal defragmentation  *
 *                             of each physical device.                       *
 *                             On exit  - actual number of free sectors on    *
 *                             the media.                                     *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlDefragmentAlt (MTL *pvol, long FAR2 *sectorsNeeded)
{
    long       freeSectors;
    FLBoolean  keepWorking;
    FLBoolean  driveDone[SOCKETS];
    long       freeSectorsOnDrive[SOCKETS];
    FLStatus   status;
    int        iDev;
    FLStatus   tmpStatus;
    long       tmp;

    /* check args for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    /*
     * Pass call to the TL of the respective underlaying physical device.
     * Count total number of free sectors on all devices.
     */

    status = flOK;

    freeSectors = (long) 0;

    if ((*sectorsNeeded == ((long) -1))  ||  (*sectorsNeeded == (long)0)) {

        /* Either total or minimal defragmentation of all physical devices. */

        for (iDev = 0;  iDev < noOfSockets;  iDev++) {

            if (mpT(pvol,iDev).defragment != NULL) {

                if (*sectorsNeeded == ((long) -1))
                   tmp = (long)(-1);            /* minimal defragmenation */
                else
                    tmp = mpS(pvol,iDev);        /* complete defragmenation */

                tmpStatus = mpT(pvol,iDev).defragment (mpT(pvol,iDev).rec, ((long FAR2 *) &tmp));

            if (tmpStatus != flBadFormat) {
            freeSectors += tmp;
        }
                else {
                    DEBUG_PRINT(("Debug: Error defragmenting physical device.\n"));
                status = tmpStatus;
        }

        }
        }
    }
    else {  /* Partial defragmentaion of the MTL volume */

        for (iDev = 0;  iDev < SOCKETS;  iDev++) {
      freeSectorsOnDrive[iDev] = (long) 0;
      if ((iDev < noOfSockets)  &&  (mpT(pvol,iDev).defragment != NULL))
          driveDone[iDev] = FALSE;
      else
          driveDone[iDev] = TRUE;
    }

        keepWorking = TRUE;

        while (keepWorking == TRUE) {

            keepWorking = FALSE;

            for (iDev = 0;  iDev < noOfSockets;  iDev++) {

               /*
                * Do minimal defragmentation of this physical device. If we
                * have got error, or haven't gained any more free sectors,
                * this physical device is done. If that is the case for all
                * physical devices, the MTL defragmentation is done. If the
                * required number of free sectors has been reached, MTL
                * defragmentation is done.
                */

            if (driveDone[iDev] != TRUE) {

            tmp = (long) -1;
                    tmpStatus = mpT(pvol,iDev).defragment (mpT(pvol,iDev).rec, ((long FAR2 *) &tmp));

                if (tmpStatus != flBadFormat) {

                if (freeSectorsOnDrive[iDev] < tmp) {

                            /* got few more free sectors on that physical device */

                            keepWorking = TRUE;

                            freeSectors += (tmp - freeSectorsOnDrive[iDev]);
                freeSectorsOnDrive[iDev] = tmp;

                if (freeSectors >= *sectorsNeeded) {

                                /* required number of free sectors reached */

                    keepWorking = FALSE;
                    break;
                }
            }
                else {  /* didn't gain any free sectors */
                            driveDone[iDev] = TRUE;
                }
            }
                    else {
                        DEBUG_PRINT(("Debug: Error defragmenting physical device.\n"));
                        driveDone[iDev] = TRUE;
                status = tmpStatus;
            }
        }

        }   /* for (iDev) */
    }   /* while (keepWorking */
    }

    *sectorsNeeded = freeSectors;

    if (*sectorsNeeded == ((long) 0))
        return flNoSpaceInVolume;

    return status;
}
#endif /* ENVIRONEMENT_VARS */
#endif /* DEFRAGMENT_VOLUME || SINGLE_BUFFER */
#ifdef HW_PROTECTION
/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l P r o t e c t i o n                        *
 *                                                                            *
 *  TL's protection routine.                                                  *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      callType             : pre mount protection operation type.           *
 *      ioreq                : pointer to the structure containing i\o fields *
 *      flash                : pointer to the flash record of device #0
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlProtection(FLFunctionNo callType, IOreq FAR2* ioreq,
                   FLFlash* flash)

{
    FLSocket  *socket;
    FLStatus  status;
    FLStatus  callStatus;
    FLFlash   tmpFlash;
    int       iTL;
    int       iDev = 0;
    unsigned  flags = 0;

    /*
     * Do flash recognition and identify protection attributes for devices
     * #0 .. (mvol.noOfSockets - 1) verifing that the operation can be
     * preformed and that the protection attributes of all the devieces
     * match.
     */

    tffscpy(&tmpFlash,flash,sizeof (tmpFlash)); /* Use the given flash */

    while(1)
    {
    /* The tmpFlash record is already intialized Try all the TLs */

	status = flUnknownMedia;
	for (iTL = 1;(iTL < mvol.noOfTLs) && (status == flUnknownMedia); iTL++)
    {
       if ((tlTable[iTL].formatRoutine   == NULL) || /* TL filter */
           (tlTable[iTL].preMountRoutine == NULL))
          continue;
       status = tlTable[iTL].preMountRoutine(FL_PROTECTION_GET_TYPE,
                         ioreq,&tmpFlash,&callStatus);
    }
	if (status != flOK)
    {
        DEBUG_PRINT(("Debug: no TL recognized the device, MTL protection aborted.\n"));
        return flFeatureNotSupported;
    }
	if (callStatus != flOK)
    {
       return callStatus;
    }

    /* Check protection attributes */

	if ((ioreq->irFlags & PROTECTABLE) == 0)
      return flNotProtected;

	if (iDev == 0) /* First device */
    {
       flags = ioreq->irFlags;
    }
	else
    {
       /* Diffrent protection attributes on diffrent devices */
       if (ioreq->irFlags != flags)
          return flMultiDocContrediction;
    }

    /* Validity check for the proper function call */

	switch(callType)
    {
        case FL_PROTECTION_GET_TYPE:       /* Identify protection */
           if (iDev == noOfSockets-1)
               return flOK;
         break;
        case FL_PROTECTION_SET_LOCK:       /* Change protection */
        case FL_PROTECTION_CHANGE_KEY:
        case FL_PROTECTION_CHANGE_TYPE:
           if (!(flags & CHANGEABLE_PROTECTION        ) ||
                (tmpFlash.protectionBoundries == NULL ) ||
                (tmpFlash.protectionSet       == NULL ))
                 {
                return flUnchangeableProtection;
                 }
        default:                           /* Insert and remove Key */
           break;
    }

    /* Identify flash for next device */

	if (iDev < noOfSockets - 1)
    {
       iDev++;
       socket = flSocketOf (iDev);

       /* Identify */

       status = flIdentifyFlash (socket, &tmpFlash);
       if ((status != flOK) && (status != flUnknownMedia))
       {
          DEBUG_PRINT(("Debug: no MTD recognized the device, MTL protection aborted.\n"));
          return status;
       }
    }
	else
      break;

    }  /* for(iDev) */

    /*
     * Pass call to the TL of the respective underlaying physical device.
     * Do flash recognition try all TLs registered in tlTable[]. Assume MTL
     * is in tlTable[0], so skip it. Skip all the TL filters as well.
     */

    for (iDev = 0, callStatus = flOK;
     (iDev < noOfSockets) && (callStatus == flOK);  iDev++)
    {
       socket = flSocketOf (iDev);

       /* Identify */

       status = flIdentifyFlash (socket, &tmpFlash);
       if ((status != flOK) && (status != flUnknownMedia))
       {
      DEBUG_PRINT(("Debug: no MTD recognized the device, MTL protection aborted.\n"));
      return status;
       }

       /* Try all the TLs */

       status = flUnknownMedia;
       for (iTL = 1;  (iTL < mvol.noOfTLs) && (status == flUnknownMedia);  iTL++)
       {
       if ((tlTable[iTL].formatRoutine   == NULL) || /* TL filter */
           (tlTable[iTL].preMountRoutine == NULL))
          continue;
       status = tlTable[iTL].preMountRoutine(callType,ioreq,
                         &tmpFlash,&callStatus);
       }
       if (status != flOK)
       {
       DEBUG_PRINT(("Debug: no TL recognized the device, MTL protection aborted.\n"));
       return flFeatureNotSupported;
       }
    }
    return callStatus;
}
#endif /* HW_PROTECTION */
/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l P r e M o u n t                            *
 *                                                                            *
 *  TL's standard volume pre mount routine.                                       *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      callType             : pre mount operation type.                      *
 *      ioreq                : pointer to the structure containing i\o fields *
 *      flash                : MTD attached to the 1st underlaying physical   *
 *                             device                                         *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      The routine always return flOK in order to stop other TLs from trying *
 *      to perform the operation. The true status code is returned in the     *
 *      'status' parameter. flOK on success, otherwise respective error code. *                    *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlPreMount(FLFunctionNo callType, IOreq FAR2* ioreq ,
                 FLFlash* flash,FLStatus* status)
{
    /* arg sanity check */

    if (ioreq->irHandle != 0)
    {
        DEBUG_PRINT(("Debug: can't execute, MTL must address first volume of socket 0.\n"));
        *status = flBadParameter;
        return flOK;
    }

    switch (callType)
    {
       case FL_COUNT_VOLUMES:

    /* Count VOLUMES routine. We assume that while MTL is mounted only
     * one device of each socket can be mounted.
     */

          ioreq->irFlags = 1;
          *status = flOK;
          break;

    /* Protection rouines. Call each of the underlaying physical devices. */

#ifdef HW_PROTECTION
       case FL_PROTECTION_GET_TYPE:
       case FL_PROTECTION_SET_LOCK:
       case FL_PROTECTION_CHANGE_KEY:
       case FL_PROTECTION_CHANGE_TYPE:
       case FL_PROTECTION_REMOVE_KEY:
       case FL_PROTECTION_INSERT_KEY:
      *status = mtlProtection(callType,ioreq,flash);
      break;
#endif /* HW_PROTECTION */

    /* Write Bad Block Table. Call each of the underlaying physical device. */

       case FL_WRITE_BBT:
      *status = flFeatureNotSupported/*mtlWriteBBT(ioreq)*/;
      return flFeatureNotSupported;

       default:
           return flBadParameter;
    }

    DEBUG_PRINT(("Debug: MTL premount succeeded.\n"));

    return flOK;
}

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l U n m o u n t                              *
 *                                                                            *
 *  TL's standard volume unmount routine.                                     *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      none                                                                  *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static void  mtlUnmount (MTL *pvol)
{
    int  iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
        return;

    /* broadcast this call to TLs of all the underlaying physical devices */

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {
        if (mpT(pvol,iDev).dismount != NULL) {
        mpT(pvol,iDev).dismount (mpT(pvol,iDev).rec);
        }
    }

    /* Return the real number of drives */
    noOfDrives = mvol.noOfDrives;

    DEBUG_PRINT(("Debug: MTL dismounted succeeded.\n"));

}


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l M o u n t                                  *
 *                                                                            *
 *  TL's standard volume mount routine.                                       *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      volNo                : volume #, must be zero                         *
 *      tl                   : pointer to TL structure to fill in             *
 *      flash                : MTD attached to the 1st underlaying physical   *
 *                             device                                         *
 *      forCallback          : MTD for power on callback (not used).          *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlMount (unsigned volNo, TL *tl, FLFlash *flash,
                                                   FLFlash **forCallback)
{
    FLFlash    tmpFlash;
	FLFlash    *volForCallback;
	FLSocket   *socket;
	FLStatus   status = flUnknownMedia;
	int        iTL;
	int        iDev = 0;

    /* Arg sanity check */

	if (volNo != ((unsigned) 0)) {
       DEBUG_PRINT(("Debug: can't mount, MTL volume # is not zero.\n"));
       return flBadParameter;
    }

    /*
     * Do TL mount for device #0. Routine flIdentifyFlash() has already been
     * called for this device (see arguement 'flash')
     */

	volForCallback = NULL;

/*    mT(0).recommendedClusterInfo = NULL;
	mT(0).writeMultiSector       = NULL;
	mT(0).readSectors            = NULL; */

    /*
     * Try all TLs registered in tlTable[]. Assume MTL is in tlTable[0], so
     * skip it. Skip all the TL filters as well.
     */

	for (iTL = 1;  (iTL < mvol.noOfTLs) && (status != flOK);  iTL++) {
    	if (tlTable[iTL].formatRoutine == NULL)   /* TL filter */
    	continue;
    	status = tlTable[iTL].mountRoutine (0, &mT(0), flash, &volForCallback);
    }
	if (status != flOK) {
	DEBUG_PRINT(("Debug: no TL recognized device #0, MTL mount aborted.\n"));
	return status;
    }

	mP(iDev) = (dword)(flash->chipSize * flash->noOfChips); /* Physical size */

	if (volForCallback)
    	volForCallback->setPowerOnCallback (volForCallback);

    /*
     * Do flash recognition and TL mount for devices #1 .. (mvol.noOfSockets - 1).
     * First call flIdentifyFlash() to find MTD, then try all TLs registered
     * in tlTable[]. Assume MTL is in tlTable[0], so skip it. Skip all the
     * TL filters as well.
     */

	for (iDev = 1;  iDev < noOfSockets;  iDev++) {

    	socket = flSocketOf (iDev);

    	status = flIdentifyFlash (socket, &tmpFlash);
    	if ((status != flOK) && (status != flUnknownMedia)) {
    	DEBUG_PRINT(("Debug: no MTD recognized the device, MTL mount aborted.\n"));
    	goto exitMount;
    }

	volForCallback = NULL;
	mP(iDev) = (dword)(tmpFlash.chipSize * tmpFlash.noOfChips); /* Physical size */
    mT(iDev).partitionNo = 0;
    mT(iDev).socketNo    = (byte)iDev;


/*        mT(iDev).recommendedClusterInfo = NULL;
	mT(iDev).writeMultiSector       = NULL;
	mT(iDev).readSectors            = NULL;*/

	status = flUnknownMedia;
	for (iTL = 1;  (iTL < mvol.noOfTLs) && (status != flOK);  iTL++) {
    	if (tlTable[iTL].formatRoutine == NULL)  /* TL filter */
    	continue;
    	status = tlTable[iTL].mountRoutine (iDev, &mT(iDev), &tmpFlash, &volForCallback);
    }
	if (status != flOK) {
    	DEBUG_PRINT(("Debug: no TL recognized the device, MTL mount aborted.\n"));
    	goto exitMount;
    }

	if (volForCallback)
    	volForCallback->setPowerOnCallback (volForCallback);
    }   /* for (iDev) */

    /* Count the total of virtual sectors across all devices */

	mvol.virtualSectors = (SectorNo) 0;
	for (iDev = 0;  iDev < SOCKETS;  iDev++) {
	mS(iDev) = (SectorNo) 0;
	if (iDev >= noOfSockets)
    	continue;

	mS(iDev) = mT(iDev).sectorsInVolume (mT(iDev).rec) - FL_MTL_HIDDEN_SECTORS;
	mvol.virtualSectors += mS(iDev);
    }

exitMount:
	if (status != flOK)
    {
       /* If one of the devices failed mount dismount all devices */
       for (;iDev >=0;iDev--)
       {
          if (mT(iDev).dismount != NULL)
          mT(iDev).dismount(mT(iDev).rec);
       }
       DEBUG_PRINT(("Debug: MTL mount failed.\n"));
       return status;
    }

    /*
     * Attach MTL-specific record to 'tl'. This record will be passed
     * as the first arguement to all TL calls.
     */

    tl->rec = &mvol;

    /* Fill in the TL access methods */

    tl->mapSector              = mtlMapSector;
    tl->writeSector            = mtlWriteSector;
    tl->deleteSector           = mtlDeleteSector;

#if defined(DEFRAGMENT_VOLUME) || defined(SINGLE_BUFFER)
#ifdef ENVIRONMENT_VARS
    if (flMTLdefragMode == FL_MTL_DEFRAGMENT_SEQUANTIAL)
    {
       tl->defragment         = mtlDefragmentAlt;
    }
    else
#endif /* ENVIRONMENT_VARS */
    {
       tl->defragment         = mtlDefragment;
    }
#endif

    tl->sectorsInVolume        = mtlSectorsInVolume;
    tl->getTLInfo              = mtlInfo;
    tl->tlSetBusy              = mtlSetBusy;
    tl->dismount               = mtlUnmount;
    tl->readBBT                = NULL /*mtlReadBBT*/;

    /*
     * The following methods are not supported by NFTL, and have already
     *  been set to NULL by flMount(). We just confirm this here.
     */

    tl->writeMultiSector       = NULL;
    tl->readSectors            = NULL;
	tl->recommendedClusterInfo = NULL;

    /* Fake the no of volume exported by TrueFFS */
	mvol.noOfDrives = noOfDrives;
	noOfDrives      = 1;


	DEBUG_PRINT(("Debug: MTL mount succeeded.\n"));

	return status;
}

#ifdef FORMAT_VOLUME

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                   m t l P r o g r e s s C a l l B a c k                    *
 *                                                                            *
 *  Extends the given format routine to report the full media size.           *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      totalUnitsToFormat	     : total units needed to format               *
 *      totalUnitsFormattedSoFar : unit formated so far.                      *
 *                                                                            *
 *  Notes                                                                     *
 *                                                                            *
 *  1) arguments 0 and 0 initializes the total unit counter to 0.             *
 *  2) arguments -1 and -1 indicates the ending of the last device.           *
 *                                                                            *                                                                           *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 * -------------------------------------------------------------------------- */

static FLStatus mtlProgressCallback(word totalUnitsToFormat,
                                	word totalUnitsFormattedSoFar)
{
   static int lastTotal;
   static int lastDevice;

   /* Initialize lastTotal counter */
   if ((totalUnitsToFormat == 0) && (totalUnitsFormattedSoFar == 0))
   {
      lastTotal  = 0;
      lastDevice = 0;
      return flOK;
   }

   /* Indicate a new device is being formated */
   if ((totalUnitsToFormat == 0) && (totalUnitsFormattedSoFar == 0xffff))
   {
      lastTotal += lastDevice;
      return flOK;
   }

   /* Call original call back routine */
   lastDevice = totalUnitsToFormat;
   if (globalProgressCallback == NULL)
   {
      return flOK;
   }
   else
   {
      return globalProgressCallback((word)(lastTotal + totalUnitsToFormat),
                                    (word)(lastTotal + totalUnitsFormattedSoFar));
   }
}


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l F o r m a t                                *
 *                                                                            *
 *  TL's standard volume mount routine.                                       *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      volNo                : volume #, must be zero                         *
 *      formatParams         : pointer to the structure containing format     *
 *                             parameters                                     *
 *      flash                : MTD attached to the 1st underlaying physical   *
 *                             device                                         *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- *
 *                                                                            *
 *  NOTE.  Binary area has 2 possible options:                                *
 *                                                                            *
 *       - TL_LEAVE_BINARY_AREA is set - binary area is left for all devices  *
 *       - TL_LEAVE_BINARY_AREA is off - binary area is placed only on the    *
 *                                       device #0                            *
 *                                                                            *
 *         Handling of 'formatParams.progressCallback' should be improved.    *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlFormat (unsigned volNo, TLFormatParams* formatParams,
                                        	FLFlash *flash)
{
	FLFlash    tmpFlash;
	FLSocket   *socket;
	FLStatus   status = flUnknownMedia;
	int        iTL, iDev;

    /* arg sanity check */

	if (volNo != ((unsigned) 0)) {
    	DEBUG_PRINT(("Debug: can't format, MTL socket # is not zero.\n"));
    	return flBadParameter;
    }
	if (formatParams->noOfBDTLPartitions > 1){
    	DEBUG_PRINT(("Debug: can't format, MTL with more then 1 BDTL volume.\n"));
    	return flBadParameter;
    }

	if (formatParams->flags & TL_SINGLE_FLOOR_FORMATTING){
    	DEBUG_PRINT(("Debug: can't format, MTL does not support single floor formatting.\n"));
    	return flBadParameter;
    }

    /* Initialize the progress call back routine to indicate the agregated
     * size. The actual routine is saved and mtl routine is used.
     */

     globalProgressCallback = formatParams->progressCallback;
     formatParams->progressCallback = mtlProgressCallback; /* Set new routine */
     mtlProgressCallback(0,0); /* Initialize new format operation */


    /*
     * Format device #0. Routine flIdentifyFlash() has already been called
     * for this device (see arguement 'flash'). Try all TLs registered
     * in tlTable[]. Assume MTL is in tlTable[0], so skip it. Skip all the
     * TL filters as well.
     */

	for (iTL = 1;  (iTL < mvol.noOfTLs) && (status == flUnknownMedia);  iTL++) {
    	if (tlTable[iTL].formatRoutine == NULL)   /* TL filter */
    	continue;
    	status = tlTable[iTL].formatRoutine(0, formatParams, flash);
    }
	if (status != flOK) {
    	DEBUG_PRINT(("Debug: no TL recognized device #0, MTL format aborted.\n"));
    	return status;
    }

    /*
     * Put all 'bootImageLen' and 'exbLen' to the 1st physical device unless
     * TL_LEAVE_BINARY_AREA is specified (which means to keep bootimage area
     * size as is.
     */

	if (!(formatParams->flags & TL_LEAVE_BINARY_AREA))
    {
       formatParams->bootImageLen = (long) 0;
#ifdef WRITE_EXB_IMAGE
       formatParams->exbLen = 0;
#endif /* WRITE_EXB_IMAGE */
       formatParams->noOfBinaryPartitions = 0;
    }

    /*
     * Do flash recognition and format for devices #1 .. (mvol.noOfSockets - 1).
     * First call flIdentifyFlash() to find MTD, then try all TLs registered
     * in tlTable[]. Assume MTL is in tlTable[0], so skip it. Skip all the
     * TL filters as well.
     */

	for (iDev = 1;  iDev < noOfSockets;  iDev++) {

    	socket = flSocketOf (iDev);

    	status = flIdentifyFlash (socket, &tmpFlash);
    	if ((status != flOK) && (status != flUnknownMedia)) {
        	DEBUG_PRINT(("Debug: no MTD recognized the device, MTL format aborted.\n"));
        	return status;
        }
    	mtlProgressCallback(0,0xffff); /* Initialize new device is being formated */
    	status = flUnknownMedia;
    	for (iTL = 1;  (iTL < mvol.noOfTLs) && (status == flUnknownMedia);  iTL++)
        {
        	if (tlTable[iTL].formatRoutine == NULL)  /* TL filter */
               continue;
        	status = tlTable[iTL].formatRoutine (iDev, formatParams, &tmpFlash);
        }
    	if (status != flOK)
        {
        	DEBUG_PRINT(("Debug: no TL recognized the device, MTL format aborted.\n"));
        	return status;
        }
    }   /* for(iDev) */

    DEBUG_PRINT(("Debug: MTL format succeeded.\n"));

    return flOK;
}

#endif /* FORMAT_VOLUME */


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        f l m t l U n i n s t a l l                         *
 *                                                                            *
 *  Removes MTL from the TL table.                                            *
 *                                                                            *
 *  Note: Must be called after the medium was dismounted.                     *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      none                                                                  *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

FLStatus  flmtlUninstall (void)
{
    int iTL;

	if (noOfTLs > 0)
    {
        /* search for MTL in tlTable[] */

    	for (iTL = 0;  iTL < mvol.noOfTLs;  iTL++)
        {
        	if (tlTable[iTL].mountRoutine == mtlMount)
            	break;
        }

    	if (iTL < mvol.noOfTLs)
        {

           /* MTL is found in tlTable[iTL], so remove it */

           for (;  iTL < (mvol.noOfTLs - 1);  iTL ++)
           {
            	tlTable[iTL].mountRoutine  = tlTable[iTL + 1].mountRoutine;
            	tlTable[iTL].formatRoutine = tlTable[iTL + 1].formatRoutine;
           }

           tlTable[mvol.noOfTLs - 1].mountRoutine    = NULL;
           tlTable[mvol.noOfTLs - 1].formatRoutine   = NULL;
           tlTable[mvol.noOfTLs - 1].preMountRoutine = NULL;

           noOfTLs    = mvol.noOfTLs - 1;
           noOfDrives = mvol.noOfDrives;
        }
    }

	return flOK;
}


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                         f l m t l I n s t a l l                            *
 *                                                                            *
 *  If MTL is found in TL table, it is moved into 1st slot (i.e. effectively  *
 *  enabled). If MTL isn't found in TL table, it is installed into 1st slot.  *
 *  The TL does not increament the number of TL (noOfTLs) global variable,    *
 *  but changes it to 1, therfore reporting it as the only registered TL.     *
 *                                                                            *
 *  Note : The install routine should be the last TL to be regitered.         *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      none                                                                  *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

FLStatus  flmtlInstall (void)
{
    int iTL;

	if (noOfTLs > 0)
    {
       checkStatus( flmtlUninstall() ); /* Dismount previous MTL if exists */

       /* Save number of registered TLs and number of volumes */

       mvol.noOfTLs    = noOfTLs;
       mvol.noOfDrives = noOfDrives;

       /* search for MTL in tlTable[] */

       for (iTL = 0;  iTL < noOfTLs;  iTL++)
       {
           if (tlTable[iTL].mountRoutine == mtlMount)
           break;
       }

       if (iTL >= noOfTLs) /* MTL is not found in tlTable[iTL] */
       {
          /* MTL isn't in tlTable[], we will be adding it */

          if (noOfTLs >= TLS)
          {
             DEBUG_PRINT(("Debug: can't install MTL, too many TLs.\n"));
             return flTooManyComponents;
          }
          iTL = noOfTLs;
          mvol.noOfTLs++;
       }
       else
       {
          /* MTL is found in tlTable[iTL] */
       }

       /* free the 1st slot in tlTable[] for MTL */

       while (iTL >= 1)
       {
          tlTable[iTL].mountRoutine  = tlTable[iTL - 1].mountRoutine;
          tlTable[iTL].formatRoutine = tlTable[iTL - 1].formatRoutine;
          iTL--;
       }
    }
    else
    {
       /* No other TL registered so return error code */

       return flMultiDocContrediction;
    }

    /* Make system believe that only MTL is registered */

	noOfTLs    = 1;
    noOfDrives = 1;

    /* put MTL in the 1st slot in tlTable[] */

	tlTable[0].mountRoutine     = mtlMount;
	tlTable[0].preMountRoutine  = mtlPreMount;
#ifdef FORMAT_VOLUME
	tlTable[0].formatRoutine = mtlFormat;
#else
	tlTable[0].formatRoutine = noFormat;
#endif

	return flOK;
}


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        f l R e g i s t e r M T L                           *
 *                                                                            *
 *  Standard TL's component registration routine.                             *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      none                                                                  *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

FLStatus  flRegisterMTL (void)
{
    checkStatus( flmtlInstall() );

    return flOK;
}

/* Physical routines are not a part of TrueFFS code */

#if 0
/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        m t l R e a d B B T                                 *
 *                                                                            *
 *  TL's standard 'read bad blocks table' routine.                            *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                : Pointer identifying drive                       *
 *      buf                 : Pointer to user buffer to read BB info to       *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *      mediaSize           : Size of the formated media                      *
 *      noOfBB              : Total number of bad blocks read                 *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlReadBBT (MTL *pvol, byte FAR1 * buf,
                 long FAR2 * mediaSize, unsigned FAR2 * noOfBB)

{
    CardAddress addressShift=0;
    long bufOffset = 0;
    unsigned tmpCounter;
    long tmpMediaSize;
    byte iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    /* Read bbt of each device while incrementing the address simulating a
     * big physical device */

    *mediaSize = 0;
    *noOfBB    = 0;
    for (iDev = 0;  iDev < noOfSockets;  iDev++)
    {
       checkStatus(mpT(pvol,iDev).readBBT(mpT(pvol,iDev).rec,
                  (byte FAR1 *)flAddLongToFarPointer(buf,bufOffset),
          &tmpMediaSize,&tmpCounter));
       *noOfBB += tmpCounter; /* Global BB counter */
       for (;tmpCounter>0;tmpCounter--,bufOffset+=sizeof(CardAddress))
       {
      *((CardAddress *)(buf + bufOffset)) += addressShift;
       }
       addressShift += mP(iDev);
       *mediaSize   += tmpMediaSize;
    }
    return flOK;
}

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l W r i t e B B T                            *
 *                                                                            *
 *  TL's write Bad Blocks Table routine.                                      *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      ioreq                : pointer to the structure containing i\o fields *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlWriteBBT(IOreq FAR2* ioreq)
{
    FLSocket    *socket;
    FLStatus    status;
    FLFlash     tmpFlash;
    CardAddress endUnit;
    CardAddress lastDriveAddress;
    CardAddress nextDriveAddress = 0;
    CardAddress iUnit;
    CardAddress bUnit;
	CardAddress endAddress;
    byte        iDev;
    word        badBlockNo=0;
    byte        zeroes[2] = {0,0};

    /* Initlize last erase address according to argument */

    tffsset(&endAddress,0xff,sizeof(CardAddress));
    if (ioreq->irLength == 0)
    {
        tffsset(&endAddress,0xff,sizeof(CardAddress));
    }
    else
    {
        endAddress = ioreq->irLength;
    }

    /*
     * Do flash recognition while storing physical size of devices
     * #0 .. (mvol.noOfSockets - 1). First call flIdentifyFlash() to find
     * MTD, then erase the media while marking bad blocks. Note that the
     * addresses are physical addresses of the virtual multi-doc. The address
     * should be subtructed by the physical size of the previous devices.
     */

    for (iDev = 0;  iDev < noOfSockets;  iDev++)
    {
        socket = flSocketOf (iDev);

        /* Identify */
        status = flIdentifyFlash (socket, &tmpFlash);
        if ((status != flOK) && (status != flUnknownMedia))
        {
           DEBUG_PRINT(("Debug: no MTD recognized the device, MTL writeBBT aborted.\n"));
           return status;
        }

        /* Initialize new drive boundry variables */

        mP(iDev) = (dword)(tmpFlash.chipSize * tmpFlash.noOfChips);
        lastDriveAddress = nextDriveAddress;
        nextDriveAddress += mP(iDev);
        endUnit = mP(iDev) >> tmpFlash.erasableBlockSizeBits;
        bUnit = ((*((CardAddress FAR1 *)flAddLongToFarPointer
                 (ioreq->irData,badBlockNo*sizeof(CardAddress)))) -
                 lastDriveAddress) >> tmpFlash.erasableBlockSizeBits;

        /* Erase entire media */

        for (iUnit = 0 ,badBlockNo = 0; iUnit < endUnit ; iUnit++)
        {
           if ((iUnit << tmpFlash.erasableBlockSizeBits) + lastDriveAddress >= endAddress)
               return flOK;
           tmpFlash.erase(&tmpFlash,iUnit,1);

           if (ioreq->irFlags > badBlockNo)
           {
              if (bUnit == iUnit)
              {
                 tmpFlash.write(&tmpFlash,bUnit <<
                               tmpFlash.erasableBlockSizeBits,zeroes,2,0);
                 badBlockNo++;
         bUnit = ((*((CardAddress FAR1 *)flAddLongToFarPointer
             (ioreq->irData,badBlockNo*sizeof(CardAddress)))) -
             lastDriveAddress) >> tmpFlash.erasableBlockSizeBits;
          }
       }
    }
    }
    return flOK;
}
#endif /* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flsysfun.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLSYSFUN.H_V  $
 * 
 *    Rev 1.2   Jul 13 2001 01:06:40   oris
 * Changed copywrite date.
 * 
 *    Rev 1.1   Apr 18 2001 09:31:14   oris
 * added new line at the end of the file.
 * 
 *    Rev 1.0   Feb 04 2001 11:59:26   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef FLSYSFUN_H
#define FLSYSFUN_H

/*#include "flbase.h" */

/*----------------------------------------------------------------------*/
/*      	         f l S y s f u n I n i t			*/
/*									*/
/* Do any necessary initialization for routines in this module.		*/
/*									*/
/* Called from fatlite.c (flInit)					*/
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void flSysfunInit(void);


/*----------------------------------------------------------------------*/
/*      	           f l R a n d B y t e				*/
/*									*/
/* Returns a random number between 0 and 255				*/
/*									*/
/* Called from FTLLITE.C						*/
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/* Returns:                                                             */
/*	A random number between 0 and 255				*/
/*----------------------------------------------------------------------*/

extern unsigned flRandByte(void);


/*----------------------------------------------------------------------*/
/*      	          f l D e l a y M s e c s			*/
/*									*/
/* Delays execution for a number of milliseconds.			*/
/* If there is no msec-accuracy to the clock, this routine should wait	*/
/* at least the time specified.						*/
/*									*/
/* This routine may be called from the socket interface or MTD's, and	*/
/* is not necessary for all implementations.				*/
/*									*/
/* Parameters:                                                          */
/*      milliseconds	: Milliseconds to wait				*/
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void flDelayMsecs(unsigned milliseconds);

/*----------------------------------------------------------------------*/
/* 		          f l s l e e p	                                */
/*									*/
/* wait number of milliseconds with yield CPU.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      msec            : minimum number of milliseconds to wait        */
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void flsleep(unsigned long msec);

/*----------------------------------------------------------------------*/
/*      	        f l I n s t a l l T i m e r			*/
/*									*/
/* Installs an interval timer.						*/
/* The implementation of this routine usually means hooking a clock	*/
/* interrupt. The polling interval is specified as a parameter. If the  */
/* clock frequency is faster, the interval timer should count several	*/
/* clock ticks before calling the interval routine.			*/
/*									*/
/* This routine is necessary if POLLING_INTERVAL (custom.h) is greater	*/
/* than 0. In this case this routine will be called from socket.c 	*/
/* (init). It will be called to install 'socketIntervalRoutine' with a	*/
/* period specified by POLLING_INTERVAL.				*/
/*									*/
/* Parameters:                                                          */
/*      routine		: Routine to call at each interval		*/
/*	interval	: Milliseconds per polling interval		*/
/*									*/
/* Returns:								*/
/* 	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

extern FLStatus flInstallTimer(void (*routine)(void), unsigned interval);


#ifdef EXIT

/*----------------------------------------------------------------------*/
/*      	        f l R e m o v e T i m e r 			*/
/*									*/
/* Removes the active interval timer.					*/
/* This routine removes the active interval timer set by 'removeTimer'. */
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void flRemoveTimer(void);

#endif


/*----------------------------------------------------------------------*/
/*      	         f l C u r r e n t D a t e			*/
/*									*/
/* Returns the current DOS-format date					*/
/*									*/
/* The DOS date format is documented in dosformt.h.			*/
/*                                                                      */
/* If a TOD clock is not available, return the value of 1/1/80.		*/
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/* Returns:                                                             */
/*	Current date							*/
/*----------------------------------------------------------------------*/

extern unsigned flCurrentDate(void);


/*----------------------------------------------------------------------*/
/*      	        f l C u r r e n t T i m e			*/
/*									*/
/* Returns the current DOS-format time					*/
/*									*/
/* The DOS time format is documented in dosformt.h.			*/
/*                                                                      */
/* If a TOD clock is not available, return the value of 0:00 AM.	*/
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/* Returns:                                                             */
/*	Current time							*/
/*----------------------------------------------------------------------*/

extern unsigned flCurrentTime(void);


/*----------------------------------------------------------------------*/
/*      	        f l C r e a t e M u t e x			*/
/*									*/
/* Creates and initializes a mutex object				*/
/*									*/
/* The mutex is initializes as not owned by anyone.			*/
/*									*/
/* Parameters:                                                          */
/*      mutex		: Pointer to mutex object			*/
/*                                                                      */
/* Returns:                                                             */
/* 	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

extern FLStatus flCreateMutex(FLMutex *mutex);


/*----------------------------------------------------------------------*/
/*      	        f l D e l e t e M u t e x			*/
/*									*/
/* Destroys a mutex object						*/
/*									*/
/* This function frees any resources taken by flCreateMutex.		*/
/*									*/
/* Parameters:                                                          */
/*      mutex		: Pointer to mutex object			*/
/*                                                                      */
/* Returns:                                                             */
/* 	None								*/
/*----------------------------------------------------------------------*/

extern void flDeleteMutex(FLMutex *mutex);


/*----------------------------------------------------------------------*/
/*      	          f l T a k e M u t e x				*/
/*									*/
/* Attempts to take ownership of a mutex. If the mutex is currently not */
/* owned, TRUE is returned and the mutex becomes owned. If the mutex is */
/* currently owned, FALSE is returned and ownership is not taken.	*/
/*									*/
/* Parameters:                                                          */
/*      mutex		: Pointer to mutex object			*/
/*                                                                      */
/* Returns:                                                             */
/* 	FLBoolean	: TRUE if ownership taken, FALSE otherwise	*/
/*----------------------------------------------------------------------*/

extern FLBoolean flTakeMutex(FLMutex *mutex);


/*----------------------------------------------------------------------*/
/*      	          f l F r e e M u t e x				*/
/*									*/
/* Frees ownership of a mutex						*/
/*									*/
/* Parameters:                                                          */
/*      mutex		: Pointer to mutex object			*/
/*                                                                      */
/* Returns:                                                             */
/* 	None								*/
/*----------------------------------------------------------------------*/

extern void flFreeMutex(FLMutex *mutex);


/*----------------------------------------------------------------------*/
/*      	          f l I n p o r t b				*/
/*									*/
/* Reads a byte from an I/O port.					*/
/*									*/
/* Parameters:                                                          */
/*      portId		: Id or address of port				*/
/*                                                                      */
/* Returns:                                                             */
/* 	unsigned char	: Value of I/O port								*/
/*----------------------------------------------------------------------*/

extern unsigned char flInportb(unsigned portId);


/*----------------------------------------------------------------------*/
/*      	          f l O u t p o r t b				*/
/*									*/
/* Writes a byte to an I/O port.					*/
/*									*/
/* Parameters:                                                          */
/*      portId		: Id or address of port				*/
/*      value		: Value to write				*/
/*                                                                      */
/* Returns:                                                             */
/* 	None								*/
/*----------------------------------------------------------------------*/

extern void flOutportb(unsigned portId, unsigned char value);


/*----------------------------------------------------------------------*/
/*      	          f l S w a p B y t e s				*/
/*									*/
/* Swap bytes in a given buffer.					*/
/*									*/
/* Parameters:                                                          */
/*      buf		: buffer that holds bytes to swap		*/
/*      len		: number of bytes to swap			*/
/*                                                                      */
/* Returns:                                                             */
/* 	None								*/
/*----------------------------------------------------------------------*/

extern void flSwapBytes(char FAR1 *buf, int len);


/*----------------------------------------------------------------------*/
/*                 f l A d d L o n g T o F a r P o i n t e r            */
/*									*/
/* Add unsigned long offset to the far pointer                          */
/*									*/
/* Parameters:                                                          */
/*      ptr             : far pointer                                   */
/*      offset          : offset in bytes                               */
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void FAR0* flAddLongToFarPointer(void FAR0 *ptr, unsigned long offset);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flstatus.h ===
/*
 * $Header:   V:/Flite/archives/TrueFFS5/Src/FLSTATUS.H_V   1.7   Feb 19 2002 21:00:06   oris  $
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLSTATUS.H_V  $
 * 
 *    Rev 1.7   Feb 19 2002 21:00:06   oris
 * Renamed flTimeOut status with flLeftForCompetability status.
 * 
 *    Rev 1.6   Jan 29 2002 20:06:34   oris
 * Changed spelling mistake - flMultiDocContrediction to flMultiDocContradiction.
 * 
 *    Rev 1.5   Jan 17 2002 23:02:32   oris
 * Added new states : flCanNotFold / flBadIPLBlock / flIOCommandBlocked.
 * 
 *    Rev 1.4   Sep 15 2001 23:46:32   oris
 * Added flCanNotFold status
 * 
 *    Rev 1.3   May 16 2001 21:19:34   oris
 * Added flMultiDocContrediction status code.
 * 
 *    Rev 1.2   May 02 2001 06:40:18   oris
 * flInterleaveError was misspelled.
 * 
 *    Rev 1.1   Apr 01 2001 07:58:04   oris
 * copywrite notice.
 * Added new status codes:
 *          flBadDownload             = 111,
 *          flBadBBT                  = 112,
 *          flInterlreavError         = 113,
 *          flWrongKey                = 114,
 *          flHWProtection            = 115,
 *          flTimeOut                 = 116
 * Changed flUnchangableProection to flUnchangeableProtection  = 110,
 * 
 *    Rev 1.0   Feb 04 2001 11:56:04   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLSTATUS_H
#define FLSTATUS_H

#ifndef IFLITE_ERROR_CODES
typedef enum {                          /* Status code for operation.
                       A zero value indicates success,
                       other codes are the extended
                       DOS codes. */
         flOK                      = 0,
         flBadFunction             = 1,
         flFileNotFound            = 2,
         flPathNotFound            = 3,
         flTooManyOpenFiles        = 4,
         flNoWriteAccess           = 5,
         flBadFileHandle           = 6,
         flDriveNotAvailable       = 9,
         flNonFATformat            = 10,
         flFormatNotSupported      = 11,
         flNoMoreFiles             = 18,
         flWriteProtect            = 19,
         flBadDriveHandle          = 20,
         flDriveNotReady           = 21,
         flUnknownCmd              = 22,
         flBadFormat               = 23,
         flBadLength               = 24,
         flDataError               = 25,
         flUnknownMedia            = 26,
         flSectorNotFound          = 27,
         flOutOfPaper              = 28,
         flWriteFault              = 29,
         flReadFault               = 30,
         flGeneralFailure          = 31,
         flDiskChange              = 34,
         flVppFailure              = 50,
         flBadParameter            = 51,
         flNoSpaceInVolume         = 52,
         flInvalidFATchain         = 53,
         flRootDirectoryFull       = 54,
         flNotMounted              = 55,
         flPathIsRootDirectory     = 56,
         flNotADirectory           = 57,
         flDirectoryNotEmpty       = 58,
         flFileIsADirectory        = 59,
         flAdapterNotFound         = 60,
         flFormattingError         = 62,
         flNotEnoughMemory         = 63,
         flVolumeTooSmall          = 64,
         flBufferingError          = 65,
         flFileAlreadyExists       = 80,
         flIncomplete              = 100,
         flTimedOut                = 101,
         flTooManyComponents       = 102,
         flTooManyDrives           = 103,
         flTooManyBinaryPartitions = 104,
         flPartitionNotFound       = 105,
         flFeatureNotSupported     = 106,
         flWrongVersion            = 107,
         flTooManyBadBlocks        = 108,
         flNotProtected            = 109,
         flUnchangeableProtection  = 110,
         flBadDownload             = 111,
         flBadBBT                  = 112,
         flInterleaveError         = 113,
         flWrongKey                = 114,
         flHWProtection            = 115,
         flLeftForCompetability    = 116,
         flMultiDocContradiction   = 117,
         flCanNotFold              = 118,
         flBadIPLBlock             = 119,
         flIOCommandBlocked        = 120
#else

#include "type.h"

typedef enum {                          /* Status code for operation.
                       A zero value indicates success,
                       other codes are the extended
                       DOS codes. */
             flOK                  = ERR_NONE,
             flBadFunction         = ERR_SW_HW,
             flFileNotFound        = ERR_NOTEXISTS,
             flPathNotFound        = ERR_NOTEXISTS,
             flTooManyOpenFiles    = ERR_MAX_FILES,
             flNoWriteAccess       = ERR_WRITE,
             flBadFileHandle       = ERR_NOTOPEN,
             flDriveNotAvailable   = ERR_SW_HW,
             flNonFATformat        = ERR_PARTITION,
             flFormatNotSupported  = ERR_PARTITION,
             flNoMoreFiles         = ERR_NOTEXISTS,
             flWriteProtect        = ERR_WRITE,
             flBadDriveHandle      = ERR_SW_HW,
             flDriveNotReady       = ERR_PARTITION,
             flUnknownCmd          = ERR_PARAM,
             flBadFormat           = ERR_PARTITION,
             flBadLength           = ERR_SW_HW,
             flDataError           = ERR_READ,
             flUnknownMedia        = ERR_PARTITION,
             flSectorNotFound      = ERR_READ,
             flOutOfPaper          = ERR_SW_HW,
             flWriteFault          = ERR_WRITE,
             flReadFault           = ERR_READ,
             flGeneralFailure      = ERR_SW_HW,
             flDiskChange          = ERR_PARTITION,
             flVppFailure          = ERR_WRITE,
             flBadParameter        = ERR_PARAM,
             flNoSpaceInVolume     = ERR_SPACE,
             flInvalidFATchain     = ERR_PARTITION,
             flRootDirectoryFull   = ERR_DIRECTORY,
             flNotMounted          = ERR_PARTITION,
             flPathIsRootDirectory = ERR_DIRECTORY,
             flNotADirectory       = ERR_DIRECTORY,
             flDirectoryNotEmpty   = ERR_NOT_EMPTY,
             flFileIsADirectory    = ERR_DIRECTORY,
             flAdapterNotFound     = ERR_DETECT,
             flFormattingError     = ERR_FORMAT,
             flNotEnoughMemory     = ERR_SW_HW,
             flVolumeTooSmall      = ERR_FORMAT,
             flBufferingError      = ERR_SW_HW,
             flFileAlreadyExists   = ERR_EXISTS,
             flIncomplete          = ERR_DETECT,
             flTimedOut            = ERR_SW_HW,
             flTooManyComponents   = ERR_PARAM
#endif
         } FLStatus;

#endif /* FLSTATUS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flsystem.c ===
/*
 * $Log:   P:/user/amir/lite/vcs/flsystem.c_v  $
 * 
 *    Rev 1.8   19 Aug 1997 20:04:16   danig
 * Andray's changes
 * 
 *    Rev 1.7   24 Jul 1997 18:11:48   amirban
 * Changed to flsystem.c
 * 
 *    Rev 1.6   07 Jul 1997 15:21:48   amirban
 * Ver 2.0
 * 
 *    Rev 1.5   29 Aug 1996 14:18:04   amirban
 * Less assembler
 * 
 *    Rev 1.4   18 Aug 1996 13:48:08   amirban
 * Comments
 * 
 *    Rev 1.3   09 Jul 1996 14:37:02   amirban
 * CPU_i386 define
 * 
 *    Rev 1.2   16 Jun 1996 14:02:38   amirban
 * Use int 1C instead of int 8
 * 
 *    Rev 1.1   09 Jun 1996 18:16:20   amirban
 * Added removeTimer
 * 
 *    Rev 1.0   20 Mar 1996 13:33:06   amirban
 * Initial revision.
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

#include "flbase.h"

#ifdef NT5PORT

#include <ntddk.h>
NTsocketParams driveInfo[SOCKETS];
NTsocketParams * pdriveInfo = driveInfo;
VOID *myMalloc(ULONG numberOfBytes)
{
  return ExAllocatePool(NonPagedPool, numberOfBytes);
}

VOID timerInit(VOID) {};

/* Wait for specified number of milliseconds */
void flDelayMsecs(unsigned   milliseconds)
{
	unsigned innerLoop = 0xffffL;
	unsigned i,j;
	for(i = 0;i < milliseconds; i++){
		for(j = 0;j < innerLoop; j++){
		}
	}
}

#if POLLING_INTERVAL > 0

VOID   (*intervalRoutine_flsystem)(VOID);
ULONG  timerInterval_flsystem;
extern KTIMER   timerObject;
extern KDPC     timerDpc;
extern BOOLEAN  timerWasStarted;

VOID timerRoutine(    
		  IN PKDPC Dpc,
		  IN PVOID DeferredContext,
		  IN PVOID SystemArgument1,
		  IN PVOID SystemArgument2
		  )
{
  (*intervalRoutine_flsystem)();
}

/* Install an interval timer */
FLStatus flInstallTimer(VOID (*routine)(VOID), unsigned  intervalMsec)
{ 
  intervalRoutine_flsystem = routine;
  timerInterval_flsystem = intervalMsec;
  KeInitializeDpc(&timerDpc, timerRoutine, NULL);    
  KeInitializeTimer(&timerObject);
  startIntervalTimer();
  return flOK;
}

VOID startIntervalTimer(VOID)
{
  LARGE_INTEGER dueTime;
  dueTime.QuadPart = -((LONG)timerInterval_flsystem * 10);    
  KeSetTimerEx(&timerObject, dueTime, (LONG) timerInterval_flsystem, &timerDpc);
  timerWasStarted = TRUE;
}

#ifdef EXIT

/* Remove an interval timer */
VOID flRemoveTimer(VOID)
{
  if (timerWasStarted) {	
    KeCancelTimer(&timerObject);
    timerWasStarted = FALSE;
  }
  if (intervalRoutine_flsystem != NULL) {
    (*intervalRoutine_flsystem)();       /* Call it twice to shut down everything */
    (*intervalRoutine_flsystem)();
    intervalRoutine_flsystem = NULL;
  }
}

#endif	/* EXIT */

#endif	/* POLLING_INTERVAL */


/* Return current DOS time */
unsigned  flCurrentTime(VOID)
{
  return 0;	// not used
}


/* Return current DOS date */
unsigned  flCurrentDate(VOID)
{
  return 0;	// not used
}


VOID flSysfunInit(VOID)
{
  timerInit();
}


/* Return a random number from 0 to 255 */
unsigned  flRandByte(VOID)
{
  LARGE_INTEGER tickCount;
  KeQueryTickCount(&tickCount);
  return tickCount.LowPart & 0xff;
}


/*----------------------------------------------------------------------*/
/*      	       f l C r e a t e M u t e x			*/
/*									*/
/* Creates or initializes a mutex					*/
/*									*/
/* Parameters:                                                          */
/*	mutex		: Pointer to mutex				*/
/*                                                                      */
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flCreateMutex(FLMutex *mutex)
{
	if(mutex){
		KeInitializeSpinLock(&mutex->Mutex);
		return flOK;
	}
	DEBUG_PRINT("Failed flCreateMutex()\n");
	return flGeneralFailure;

}

/*----------------------------------------------------------------------*/
/*      	       f l D e l e t e M u t e x			*/
/*									*/
/* Deletes a mutex.							*/
/*									*/
/* Parameters:                                                          */
/*	mutex		: Pointer to mutex				*/
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID flDeleteMutex(FLMutex *mutex)
{
}

/*----------------------------------------------------------------------*/
/*      	        f l T a k e M u t e x				*/
/*									*/
/* Try to take mutex, if free.						*/
/*									*/
/* Parameters:                                                          */
/*	mutex		: Pointer to mutex				*/
/*                                                                      */
/* Returns:                                                             */
/*	int		: TRUE = Mutex taken, FALSE = Mutex not free	*/
/*----------------------------------------------------------------------*/

FLBoolean flTakeMutex(FLMutex *mutex)
{
	if(mutex){		
		KeAcquireSpinLock(&mutex->Mutex, &mutex->cIrql );
		return TRUE;
	}
	DEBUG_PRINT("Failed flTakeMutex() on mutex\n");
	return FALSE;
}


/*----------------------------------------------------------------------*/
/*      	          f l F r e e M u t e x				*/
/*									*/
/* Free mutex.								*/
/*									*/
/* Parameters:                                                          */
/*	mutex		: Pointer to mutex				*/
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID flFreeMutex(FLMutex *mutex)
{
	if(mutex){
		KeReleaseSpinLock(&mutex->Mutex, mutex->cIrql);
	}
	else{
		DEBUG_PRINT("Failed flFreeMutex() on mutex\n");
	}
	
}


UCHAR flInportb(unsigned  portId)
{
  return 0;	// not used
}


VOID flOutportb(unsigned  portId, UCHAR value)
{
	// not used
}

/*----------------------------------------------------------------------*/
/*                 f l A d d L o n g T o F a r P o i n t e r            */
/*									*/
/* Add unsigned long offset to the far pointer                          */
/*									*/
/* Parameters:                                                          */
/*      ptr             : far pointer                                   */
/*      offset          : offset in bytes                               */
/*                                                                      */
/*----------------------------------------------------------------------*/
VOID FAR0*  flAddLongToFarPointer(VOID FAR0 *ptr, ULONG offset)
{
  return ((VOID FAR0 *)((UCHAR FAR0*)ptr+offset));
}

#ifdef ENVIRONMENT_VARS

void FAR0 * NAMING_CONVENTION flmemcpy(void FAR0* dest,const void FAR0 *src,size_t count)
{
  size_t i;
  unsigned char FAR0 *ldest = (unsigned char FAR0 *)dest;
  const unsigned char FAR0 *lsrc = (unsigned char FAR0 *)src;

  for(i=0;( i < count );i++,ldest++,lsrc++)
    *(ldest) = *(lsrc);
  return dest;
}


void FAR0 * NAMING_CONVENTION flmemset(void FAR0* dest,int c,size_t count)
{
  size_t i;
  unsigned char FAR0 *ldest = (unsigned char FAR0 *)dest;

  for(i=0;( i < count );i++,ldest++)
    *(ldest) = (unsigned char)c;
  return dest;
}

int NAMING_CONVENTION flmemcmp(const void FAR0* dest,const void FAR0 *src,size_t count)
{
  size_t i;
  const unsigned char FAR0 *ldest = (unsigned char FAR0 *)dest;
  const unsigned char FAR0 *lsrc = (unsigned char FAR0 *)src;

  for(i=0;( i < count );i++,ldest++,lsrc++)
    if( *(ldest) != *(lsrc) )
      return (*(ldest)-*(lsrc));
  return 0;
}

#endif

#endif /* NT5PORT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\flsystem.h ===
/*
 * $Log:   P:/user/amir/lite/vcs/flsystem.h_v  $

      Rev 1.4   11 Sep 1997 14:14:22   danig
   physicalToPointer receives drive no. when FAR == 0

      Rev 1.3   04 Sep 1997 13:58:30   danig
   DEBUG_PRINT

      Rev 1.2   28 Aug 1997 16:39:32   danig
   include stdlib.h instead of malloc.h

      Rev 1.1   19 Aug 1997 20:05:06   danig
   Andray's changes

      Rev 1.0   24 Jul 1997 18:13:06   amirban
   Initial revision.
 */

/************************************************************************/
/*                                  */
/*      FAT-FTL Lite Software Development Kit           */
/*      Copyright (C) M-Systems Ltd. 1995-1996          */
/*                                  */
/************************************************************************/


#ifndef FLSYSTEM_H
#define FLSYSTEM_H
#include <ntddk.h>
#include "flcustom.h"


/* DiskOnChip bus configuration
 *
 * When FL_NO_USE_FUNC is defined use the defintion bellow to set DiskOnChip
 * bus width access (either 8/16/32).
 * Please check the manula before deciding to use the FL_NO_USE_FUNC mode.
 */

#define DOC_ACCESS_TYPE 8

/*moti
 *                      delay With Yeald CPU disable
 *
 * Osak utiliezes the flSleep customized routine to yeald the CPU while
 * waiting for time consumming operations like flash erase. If the routine
 * is not implemented the uncomment the define bellow
 */

#define DO_NOT_YEAL_CPU

/*
 *          signed/unsigned char
 *
 * It is assumed that 'char' is signed. If this is not your compiler
 * default, use compiler switches, or insert a #pragma here to define this.
 *
 */

/*#pragma option -K-*/  /* default char is signed */


/*          CPU target
 *
 * Use compiler switches or insert a #pragma here to select the CPU type
 * you are targeting.
 *
 * If the target is an Intel 80386 or above, also uncomment the CPU_i386
 * definition.
 */

/*#pragma option -3*/   /* Select 80386 CPU */
#define CPU_i386


/*          NULL constant
 *
 * Some compilers require a different definition for the NULL pointer
 */

/*#include <_null.h>*/


/*          Little-endian/big-endian
 *
 * FAT and translation layers structures use the little-endian (Intel)
 * format for integers.
 * If your machine uses the big-endian (Motorola) format, uncomment the
 * following line.
 * Note that even on big-endian machines you may omit the BIG_ENDIAN
 * definition for smaller code size and better performance, but your media
 * will not be compatible with standard FAT and FTL.
 */

/* #define BIG_ENDIAN */


/*          Far pointers
 *
 * Specify here which pointers may be far, if any.
 * Far pointers are usually relevant only to 80x86 architectures.
 *
 * Specify FAR_LEVEL:
 *   0 -    if using a flat memory model or having no far pointers.
 *   1 -    if only the socket window may be far
 *   2 -    if only the socket window and caller's read/write buffers
 *      may be far.
 *   3 -    if socket window, caller's read/write buffers and the
 *      caller's I/O request packet may be far
 */

#define FAR_LEVEL   0


/*          Memory routines
 *
 * You need to supply library routines to copy, set and compare blocks of
 * memory, internally and to/from callers. The code uses the names 'tffscpy',
 * 'tffsset' and 'tffscmp' with parameters as in the standard 'memcpy',
 * 'memset' and 'memcmp' C library routines.
 */

#include <string.h>

#ifndef ENVIRONMENT_VARS
    #if FAR_LEVEL > 0
        #define tffscpy _fmemcpy
        #define tffscmp _fmemcmp
        #define tffsset _fmemset
    #else
        #define tffscpy memcpy
        #define tffscmp memcmp
        #define tffsset memset
    #endif
#else
    #if FAR_LEVEL > 0
        #define flcpy _fmemcpy
        #define flcmp _fmemcmp
        #define flset _fmemset
    #else
        #define flcmp flmemcmp
        #define flset flmemset
        #define flcpy flmemcpy
    #endif
#endif


/*          Pointer arithmetic
 *
 * The following macros define machine- and compiler-dependent macros for
 * handling pointers to physical window addresses. The definitions below are
 * for PC real-mode Borland-C.
 *
 * 'physicalToPointer' translates a physical flat address to a (far) pointer.
 * Note that if when your processor uses virtual memory, the code should
 * map the physical address to virtual memory, and return a pointer to that
 * memory (the size parameter tells how much memory should be mapped).
 *
 * 'addToFarPointer' adds an increment to a pointer and returns a new
 * pointer. The increment may be as large as your window size. The code
 * below assumes that the increment may be larger than 64 KB and so performs
 * huge pointer arithmetic.
 */

#if FAR_LEVEL > 0
#include <dos.h>

#define physicalToPointer(physical,size,drive)      \
    MK_FP((LONG) ((physical) >> 4),(LONG) (physical) & 0xF)

#define addToFarPointer(base,increment)     \
    MK_FP(FP_SEG(base) +            \
    ((USHORT) ((FP_OFF(base) + (increment)) >> 16) << 12), \
        FP_OFF(base) + (LONG) (increment))
#else

#include <ntddk.h>
#define freePointer(ptr,size) 1
typedef struct {
    ULONG   windowSize;
    ULONGLONG   physWindow;
    PVOID   winBase;
    ULONG   interfAlive;
    PVOID   fdoExtension;
    UCHAR   nextPartitionNumber;
} NTsocketParams;

//moti extern NTsocketParams *pdriveInfo;
extern NTsocketParams *pdriveInfo;

#define physicalToPointer(physical,size,drive)  pdriveInfo[drive & 0x0f].winBase

#define pointerToPhysical(ptr)  ((ULONG_PTR)(ptr))

#define addToFarPointer(base,increment)     \
    ((VOID *) ((UCHAR *) (base) + (increment)))
#endif


/*          Default calling convention
 *
 * C compilers usually use the C calling convention to routines (cdecl), but
 * often can also use the pascal calling convention, which is somewhat more
 * economical in code size. Some compilers also have specialized calling
 * conventions which may be suitable. Use compiler switches or insert a
 * #pragma here to select your favorite calling convention.
 */

/*#pragma option -p*/   /* Default pascal calling convention */
/* Naming convention for functions that uses non-default convention. */
#define NAMING_CONVENTION /*cdecl*/

#define FL_IOCTL_START   0


/*          Mutex type
 *
 * If you intend to access the FLite API in a multi-tasking environment,
 * you may need to implement some resource management and mutual-exclusion
 * of FLite with mutex & semaphore services that are available to you. In
 * this case, define here the Mutex type you will use, and provide your own
 * implementation of the Mutex functions incustom.c
 *
 * By default, a Mutex is defined as a simple counter, and the Mutex
 * functions in custom.c implement locking and unlocking by incrementing
 * and decrementing the counter. This will work well on all single-tasking
 * environment, as well as on many multi-tasking environments.
 */

//typedef LONG FLMutex;
typedef struct _SpinLockMutex{
    KSPIN_LOCK Mutex;
    KIRQL       cIrql;
}SpinLockMutex;

typedef SpinLockMutex FLMutex;
/*#include <dos.h>

#define flStartCriticalSection(FLMutex)     disable()
#define flEndCriticalSection(FLMutex)       enable()*/

/*          Memory allocation
 *
 * The translation layers (e.g. FTL) need to allocate memory to handle
 * Flash media. The size needed depends on the media being handled.
 *
 * You may choose to use the standard 'malloc' and 'free' to handle such
 * memory allocations, provide your own equivalent routines, or you may
 * choose not to define any memory allocation routine. In this case, the
 * memory will be allocated statically at compile-time on the assumption of
 * the largest media configuration you need to support. This is the simplest
 * choice, but may cause your RAM requirements to be larger than you
 * actually need.
 *
 * If you define routines other than malloc & free, they should have the
 * same parameters and return types as malloc & free. You should either code
 * these routines in flcustom.c or include them when you link your application.
 */

#ifdef NT5PORT



VOID * myMalloc(ULONG numberOfBytes);

#define MALLOC myMalloc
#define FREE ExFreePool


/*          Debug mode
 *
 * Uncomment the following lines if you want debug messages to be printed
 * out. Messages will be printed at initialization key points, and when
 * low-level errors occure.
 * You may choose to use 'printf' or provide your own routine.
 */

#if DBG
#define DEBUG_PRINT(str)  DbgPrint(str)
#else
#define DEBUG_PRINT(str)
#endif

VOID startIntervalTimer(VOID);

#define tffsReadByteFlash(r)     READ_REGISTER_UCHAR((PUCHAR)r)
#define tffsWriteByteFlash(r,b)  WRITE_REGISTER_UCHAR((PUCHAR)r,(UCHAR)b)
#define tffsReadWordFlash(r)     READ_REGISTER_USHORT((PUSHORT)r)
#define tffsWriteWordFlash(r,b)  WRITE_REGISTER_USHORT((PUSHORT)r,(USHORT)b)
#define tffsReadDwordFlash(r)     READ_REGISTER_ULONG((PULONG)r)
#define tffsWriteDwordFlash(r,b)  WRITE_REGISTER_ULONG((PULONG)r,(ULONG)b)

#define tffsReadByte(r)     READ_REGISTER_UCHAR((PUCHAR)&(r))
#define tffsWriteByte(r,b)  WRITE_REGISTER_UCHAR((PUCHAR)&(r),b)
#define tffsReadBuf(d,s,c)  READ_REGISTER_BUFFER_UCHAR((PUCHAR)s,d,c)
#define tffsWriteBuf(d,s,c) WRITE_REGISTER_BUFFER_UCHAR((PUCHAR)d,s,c)

extern void PRINTF(
                char * Message,
                ...
                );
#endif /* NT5PORT */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\i28f008.c ===
/*
 * $Log:   V:/i28f008.c_v  $
 *
 *    Rev 1.16	 06 Oct 1997 18:37:30	ANDRY
 * no COBUX
 *
 *    Rev 1.15	 05 Oct 1997 19:11:08	ANDRY
 * COBUX (Motorola M68360 16-bit only board)
 *
 *    Rev 1.14	 05 Oct 1997 14:35:36	ANDRY
 * flNeedVpp() and flDontNeedVpp() are under #ifdef SOCKET_12_VOLTS
 *
 *    Rev 1.13	 10 Sep 1997 16:18:10	danig
 * Got rid of generic names
 *
 *    Rev 1.12	 04 Sep 1997 18:47:20	danig
 * Debug messages
 *
 *    Rev 1.11	 31 Aug 1997 15:06:40	danig
 * Registration routine return status
 *
 *    Rev 1.10	 24 Jul 1997 17:52:30	amirban
 * FAR to FAR0
 *
 *    Rev 1.9	21 Jul 1997 14:44:06   danig
 * No parallelLimit
 *
 *    Rev 1.8	20 Jul 1997 17:17:00   amirban
 * No watchDogTimer
 *
 *    Rev 1.7	07 Jul 1997 15:22:06   amirban
 * Ver 2.0
 *
 *    Rev 1.6	15 Apr 1997 19:16:40   danig
 * Pointer conversions.
 *
 *    Rev 1.5	29 Aug 1996 14:17:48   amirban
 * Warnings
 *
 *    Rev 1.4	18 Aug 1996 13:48:44   amirban
 * Comments
 *
 *    Rev 1.3	31 Jul 1996 14:31:10   amirban
 * Background stuff
 *
 *    Rev 1.2	04 Jul 1996 18:20:06   amirban
 * New flag field
 *
 *    Rev 1.1	03 Jun 1996 16:28:58   amirban
 * Cobra additions
 *
 *    Rev 1.0	20 Mar 1996 13:33:06   amirban
 * Initial revision.
 */

/************************************************************************/
/*									*/
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*									*/
/* This MTD supports the following Flash technologies:			*/
/*									*/
/* - Intel 28F008/Cobra 8-mbit devices					*/
/* - Intel 28F016SA/28016SV/Cobra 16-mbit devices (byte-mode operation) */
/*									*/
/* And (among else), the following Flash media and cards:		*/
/*									*/
/* - Intel Series-2 PCMCIA cards					*/
/* - Intel Series-2+ PCMCIA cards					*/
/* - M-Systems ISA/Tiny/PC-104 Flash Disks				*/
/* - M-Systems NOR PCMCIA cards 					*/
/* - Intel Value-100 cards						*/
/*									*/
/*----------------------------------------------------------------------*/

#include "flflash.h"
#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif

#define flash (*pFlash)

#define SETUP_ERASE	0x20
#define SETUP_WRITE	0x40
#define CLEAR_STATUS	0x50
#define READ_STATUS	0x70
#define READ_ID 	0x90
#define SUSPEND_ERASE	0xb0
#define CONFIRM_ERASE	0xd0
#define RESUME_ERASE	0xd0
#define READ_ARRAY	0xff

#define WSM_ERROR	0x38
#define WSM_VPP_ERROR	0x08
#define WSM_SUSPENDED	0x40
#define WSM_READY	0x80

/* JEDEC ids for this MTD */
#define I28F008_FLASH	0x89a2
#define I28F016_FLASH	0x89a0
#define COBRA004_FLASH	0x89a7
#define COBRA008_FLASH	0x89a6
#define COBRA016_FLASH	0x89aa

#define MOBILE_MAX_INLV_4 0x8989
#define LDP_1MB_IN_16BIT_MODE 0x89ff

/* Definition of MTD specific vol.flags bits: */

#define NO_12VOLTS		0x100	/* Card does not need 12 Volts Vpp */

/*----------------------------------------------------------------------*/
/*			i 2 8 f 0 0 8 W r i t e 			*/
/*									*/
/* Write a block of bytes to Flash					*/
/*									*/
/* This routine will be registered as the MTD vol.write routine */
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	overwrite	: TRUE if overwriting old Flash contents	*/
/*			  FALSE if old contents are known to be erased	*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus i28f008Write(FLFlash vol,
			   CardAddress address,
			   const VOID FAR1 *buffer,
			   dword length,
			   word overwrite)
{
  /* Set timeout ot 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  FLStatus status;
  ULONG i, cLength;
  FlashPTR flashPtr;


  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (!(vol.flags & NO_12VOLTS))
    checkStatus(flNeedVpp(vol.socket));
#endif

  flashPtr = (FlashPTR) flMap(vol.socket,address);
  cLength = length;

  if (vol.interleaving == 1) {
lastByte:
#ifdef __cplusplus
    #define bFlashPtr  flashPtr
    #define bBuffer ((const UCHAR FAR1 * &) buffer)
#else
    #define bFlashPtr  flashPtr
    #define bBuffer ((const UCHAR FAR1 *) buffer)
#endif
    while (cLength >= 1) {
      tffsWriteByteFlash(bFlashPtr, SETUP_WRITE);
      tffsWriteByteFlash(bFlashPtr, *bBuffer);
      cLength--;
      bBuffer++;
      bFlashPtr++;
      while (!(tffsReadByteFlash(bFlashPtr-1) & WSM_READY) && flMsecCounter < writeTimeout)
	    ;
    }
  }
  else if (vol.interleaving == 2) {
lastWord:
#ifdef __cplusplus
    #define wFlashPtr ((FlashWPTR &) flashPtr)
    #define wBuffer ((const USHORT FAR1 * &) buffer)
#else
    #define wFlashPtr ((FlashWPTR) flashPtr)
    #define wBuffer ((const USHORT FAR1 *) buffer)
#endif
    while (cLength >= 2) {
      tffsWriteWordFlash(wFlashPtr, SETUP_WRITE * 0x101);
      tffsWriteWordFlash(wFlashPtr, *wBuffer);
      cLength -= 2;
      wBuffer++;
      wFlashPtr++;
      while ((~(tffsReadWordFlash(wFlashPtr-1)) & (WSM_READY * 0x101)) && flMsecCounter < writeTimeout)
	    ;
    }
    if (cLength > 0)
      goto lastByte;
  }
  else /* if (vol.interleaving >= 4) */ {
#ifdef __cplusplus
    #define dFlashPtr ((FlashDPTR &) flashPtr)
    #define dBuffer ((const ULONG FAR1 * &) buffer)
#else
    #define dFlashPtr ((FlashDPTR) flashPtr)
    #define dBuffer ((const ULONG FAR1 *) buffer)
#endif
    while (cLength >= 4) {
      tffsWriteDwordFlash(dFlashPtr, SETUP_WRITE * 0x1010101l);
      tffsWriteDwordFlash(dFlashPtr, *dBuffer);
      cLength -= 4;
      dBuffer++;
      dFlashPtr++;
      while ((~(tffsReadDwordFlash(dFlashPtr-1)) & (WSM_READY * 0x1010101lu)) && flMsecCounter < writeTimeout)
	    ;
    }
    if (cLength > 0)
      goto lastWord;
  }

  flashPtr -= length;
  bBuffer -= length;

  status = flOK;
  for (i = 0; i < (ULONG)vol.interleaving && i < length; i++) {
    if (tffsReadByteFlash(flashPtr + i) & WSM_ERROR) {
      DEBUG_PRINT(("Debug: write failed for 8-bit Intel media.\n"));
      status = (tffsReadByteFlash(flashPtr + i) & WSM_VPP_ERROR) ? flVppFailure : flWriteFault;
      tffsWriteByteFlash(flashPtr + i, CLEAR_STATUS);
    }
    tffsWriteByteFlash(flashPtr + i, READ_ARRAY);
  }

#ifdef SOCKET_12_VOLTS
  if (!(vol.flags & NO_12VOLTS))
    flDontNeedVpp(vol.socket);
#endif

  /* verify the data */
  if (status == flOK) {
    /* compare double words */
    for (;length >= 4; length -= 4, dFlashPtr++, dBuffer++) {
	if (tffsReadDwordFlash(dFlashPtr) != *dBuffer) {
	    DEBUG_PRINT(("Debug: write failed for 8-bit Intel media in verification.\n"));
	return flWriteFault;
	}
    }

    /* compare the last bytes */
    for (; length; length--, bFlashPtr++, bBuffer++) {
	if (tffsReadByteFlash(bFlashPtr) != *bBuffer) {
	    DEBUG_PRINT(("Debug: write failed for 8-bit Intel media in verification.\n"));
	return flWriteFault;
	}
    }
  }

  return status;
}


/*----------------------------------------------------------------------*/
/*			i 2 8 f 0 0 8 E r a s e 			*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks			*/
/*									*/
/* This routine will be registered as the MTD vol.erase routine */
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus i28f008Erase(FLFlash vol,
			   word firstErasableBlock,
			   word numOfErasableBlocks)
{
  LONG iBlock;

  FLStatus status = flOK;	/* unless proven otherwise */

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (!(vol.flags & NO_12VOLTS))
    checkStatus(flNeedVpp(vol.socket));
#endif

  for (iBlock = 0; iBlock < numOfErasableBlocks && status == flOK; iBlock++) {
    LONG j;
    FLBoolean finished;

    FlashPTR flashPtr = (FlashPTR)
	  flMap(vol.socket,
		    (firstErasableBlock + iBlock) * vol.erasableBlockSize);

    for (j = 0; j < vol.interleaving; j++) {
      tffsWriteByteFlash(flashPtr + j, SETUP_ERASE);
      tffsWriteByteFlash(flashPtr + j, CONFIRM_ERASE);
    }

    do {
#ifdef FL_BACKGROUND
      while (flForeground(1) == BG_SUSPEND) {		/* suspend */
	for (j = 0; j < vol.interleaving; j++) {
	  tffsWriteByteFlash(flashPtr + j, READ_STATUS);
	  if (!(tffsReadByteFlash(flashPtr + j) & WSM_READY)) {
	    tffsWriteByteFlash(flashPtr + j, SUSPEND_ERASE);
	    tffsWriteByteFlash(flashPtr + j, READ_STATUS);
	    while (!(tffsReadByteFlash(flashPtr + j) & WSM_READY))
	      ;
	  }
	  tffsWriteByteFlash(flashPtr + j, READ_ARRAY);
	}
      }
#endif
      finished = TRUE;
      for (j = 0; j < vol.interleaving; j++) {
	tffsWriteByteFlash(flashPtr + j, READ_STATUS);
	if (tffsReadByteFlash(flashPtr + j) & WSM_SUSPENDED) {
	  tffsWriteByteFlash(flashPtr + j, RESUME_ERASE);
	  finished = FALSE;
	}
	else if (!(tffsReadByteFlash(flashPtr + j) & WSM_READY))
	  finished = FALSE;
	else {
	  if (tffsReadByteFlash(flashPtr + j) & WSM_ERROR) {
	    DEBUG_PRINT(("Debug: erase failed for 8-bit Intel media.\n"));
	    status = (tffsReadByteFlash(flashPtr + j) & WSM_VPP_ERROR) ? flVppFailure : flWriteFault;
	    tffsWriteByteFlash(flashPtr + j, CLEAR_STATUS);
	  }
	  tffsWriteByteFlash(flashPtr + j, READ_ARRAY);
	}
    flDelayMsecs(10);
      }
    } while (!finished);
  } /* block loop */

#ifdef SOCKET_12_VOLTS
  if (!(vol.flags & NO_12VOLTS))
    flDontNeedVpp(vol.socket);
#endif

  return status;
}

/*----------------------------------------------------------------------*/
/*			  i 2 8 f 0 0 8 M a p				*/
/*									*/
/* Map through buffer. This routine will be registered as the map	*/
/* routine for this MTD.						*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Flash address to be mapped.				*/
/*	length	: number of bytes to map.				*/
/*									*/
/* Returns:								*/
/*	Pointer to the buffer data was mapped to.			*/
/*									*/
/*----------------------------------------------------------------------*/

VOID FAR0 *i28f008Map (FLFlash vol, CardAddress address, int length)
{
  vol.socket->remapped = TRUE;
  return mapThroughBuffer(&vol,address,length);
}

/*----------------------------------------------------------------------*/
/*			  i 2 8 f 0 0 8 R e a d 			*/
/*									*/
/* Read some data from the flash. This routine will be registered as	*/
/* the read routine for this MTD.					*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Address to read from. 				*/
/*	buffer	: buffer to read to.					*/
/*	length	: number of bytes to read (up to sector size).		*/
/*	modes	: EDC flag etc. 					*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failed.		*/
/*									*/
/*----------------------------------------------------------------------*/

FLStatus i28f008Read(FLFlash vol,
			 CardAddress address,
			 VOID FAR1 *buffer,
			 dword length,
			 word modes)
{
  ULONG i;
  UCHAR * byteBuffer;
  FlashPTR byteFlashPtr;
  ULONG * dwordBuffer = (ULONG *)buffer;
  FlashDPTR dwordFlashPtr = (FlashDPTR)flMap(vol.socket, address);

  for (i = 0; i < length - 4; i += 4, dwordBuffer++, dwordFlashPtr++) {
    *dwordBuffer = tffsReadDwordFlash(dwordFlashPtr);
  }
  byteBuffer = (UCHAR *)dwordBuffer;
  byteFlashPtr = (FlashPTR)dwordFlashPtr;
  for(; i < length; i++, byteBuffer++, byteFlashPtr++) {
    *byteBuffer = tffsReadByteFlash(byteFlashPtr);
  }
  return flOK ;
}

/*----------------------------------------------------------------------*/
/*		       i 2 8 f 0 0 8 I d e n t i f y			*/
/*									*/
/* Identifies media based on Intel 28F008 and Intel 28F016 and		*/
/* registers as an MTD for such 					*/
/*									*/
/* This routine will be placed on the MTD list in custom.h. It must be	*/
/* an extern routine.							*/
/*									*/
/* On successful identification, the Flash structure is filled out and	*/
/* the write and erase routines registered.				*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on positive identificaion, failed otherwise */
/*----------------------------------------------------------------------*/

FLStatus i28f008Identify(FLFlash vol)
{
  LONG iChip;

  CardAddress idOffset = 0;

  DEBUG_PRINT(("Debug: i28f008Identify :entering 8-bit Intel media identification routine.\n"));

  flSetWindowBusWidth(vol.socket, 16);/* use 16-bits */
  flSetWindowSpeed(vol.socket, 150);  /* 120 nsec. */
  flSetWindowSize(vol.socket, 2);	/* 8 KBytes */

  flIntelIdentify(&vol, NULL,0);

  if (vol.type == NOT_FLASH) {
    /* The flash may be write-protected at offset 0. Try another offset */
    idOffset = 0x80000l;
    flIntelIdentify(&vol, NULL,idOffset);
  }

   if (vol.type == LDP_1MB_IN_16BIT_MODE) {
    flSetWindowBusWidth(vol.socket, 8); 	/* use 8-bits */
    flIntelIdentify(&vol, NULL,idOffset);	/* and try to get a valid id */
  }

  switch (vol.type) {
    case COBRA004_FLASH:
      vol.chipSize = 0x80000l;
      vol.flags |= SUSPEND_FOR_WRITE | NO_12VOLTS;
      break;

    case COBRA008_FLASH:
      vol.flags |= SUSPEND_FOR_WRITE | NO_12VOLTS;
      /* no break */

    case MOBILE_MAX_INLV_4:
    case I28F008_FLASH:
      vol.chipSize = 0x100000l;
      break;

    case COBRA016_FLASH:
      vol.flags |= SUSPEND_FOR_WRITE | NO_12VOLTS;
      /* no break */

    case I28F016_FLASH:
      vol.chipSize = 0x200000l;
      break;

    default:
      DEBUG_PRINT(("Debug: failed to identify 8-bit Intel media.\n"));
      return flUnknownMedia;	/* not ours */
  }

  vol.erasableBlockSize = 0x10000l * vol.interleaving;

  checkStatus(flIntelSize(&vol, NULL,idOffset));

  if (vol.type == MOBILE_MAX_INLV_4)
    vol.type = I28F008_FLASH;

  for (iChip = 0; iChip < vol.noOfChips; iChip += vol.interleaving) {
    LONG i;

    FlashPTR flashPtr = (FlashPTR)
	    flMap(vol.socket,iChip * vol.chipSize);

    for (i = 0; i < vol.interleaving; i++)
      tffsWriteByteFlash(flashPtr + i, CLEAR_STATUS);
  }

  /* Register our flash handlers */
  vol.write = i28f008Write;
  vol.erase = i28f008Erase;
  vol.read = i28f008Read;
  vol.map = i28f008Map;

  DEBUG_PRINT(("Debug: i28f008Identify  :identified 8-bit Intel media.\n"));

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		     f l R e g i s t e r I 2 8 F 0 0 8			*/
/*									*/
/* Registers this MTD for use						*/
/*									*/
/* Parameters:								*/
/*	None								*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterI28F008(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = i28f008Identify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\fsapi.h ===
/*
 * $Log:   V:/Flite/archives/FLite/src/FSAPI.H_V  $
   
      Rev 1.4   Jan 20 2000 17:54:24   vadimk
   add FL_READ_ONLY define

      Rev 1.3   Jan 17 2000 13:43:06   vadimk
   remove fl_format_volume

      Rev 1.2   Jan 13 2000 18:28:12   vadimk
   TrueFFS OSAK 4.1

      Rev 1.1   Jul 12 1999 16:53:34   marinak
   dosFormat call is passed from blockdev.c to fatlite.c

      Rev 1.0   22 Dec 1998 14:04:34   marina
   Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-99              */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FSAPI_H
#define FSAPI_H

#include "flreq.h"

/*----------------------------------------------------------------------*/
/*		           f l C a l l   				*/
/*									*/
/* Common entry-point to all file-system functions. Macros are          */
/* to call individual function, which are separately described below.	*/
/*                                                                      */
/* Parameters:                                                          */
/*	function	: file-system function code (listed below)	*/
/*	ioreq		: IOreq structure				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

typedef enum {
  FL_OPEN_FILE,
  FL_CLOSE_FILE,
  FL_READ_FILE,
  FL_WRITE_FILE,
  FL_SEEK_FILE,
  FL_FIND_FILE,
  FL_FIND_FIRST_FILE,
  FL_FIND_NEXT_FILE,
  FL_GET_DISK_INFO,
  FL_DELETE_FILE,
  FL_RENAME_FILE,
  FL_MAKE_DIR,
  FL_REMOVE_DIR,
  FL_SPLIT_FILE,
  FL_JOIN_FILE,
  FL_FLUSH_BUFFER
} FLFunctionNo;


FLStatus flCall(FLFunctionNo functionNo, IOreq FAR2 *ioreq);



#if FILES > 0
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*		     f l F l u s h B u f f e r                                    */
/*									                                                    */
/* If there is relevant data in the RAM buffer then writes it on        */
/*   the flash memory.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)                                */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                          */
/*----------------------------------------------------------------------*/

#define flFlushBuffer(ioreq)	flCall(FL_FLUSH_BUFFER,ioreq)

#endif                                  /* READ_ONLY */
/*----------------------------------------------------------------------*/
/*		      f l O p e n F i l e				*/
/*									*/
/* Opens an existing file or creates a new file. Creates a file handle  */
/* for further file processing.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irFlags		: Access and action options, defined below	*/
/*	irPath		: path of file to open             		*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*	irHandle	: New file handle for open file                 */
/*                                                                      */
/*----------------------------------------------------------------------*/

/** Values of irFlags for flOpenFile: */

#define ACCESS_MODE_MASK	3	/* Mask for access mode bits */

/* Individual flags */

#define	ACCESS_READ_WRITE	1	/* Allow read and write */
#define ACCESS_CREATE		2	/* Create new file */

/* Access mode combinations */
#define OPEN_FOR_READ		0	/* open existing file for read-only */
#define	OPEN_FOR_UPDATE		1	/* open existing file for read/write access */
#define OPEN_FOR_WRITE		3	/* create a new file, even if it exists */


#define flOpenFile(ioreq)	flCall(FL_OPEN_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		      f l C l o s e F i l e				*/
/*									*/
/* Closes an open file, records file size and dates in directory and    */
/* releases file handle.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Handle of file to close.                      */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flCloseFile(ioreq)      flCall(FL_CLOSE_FILE,ioreq)

#ifndef FL_READ_ONLY
#ifdef SPLIT_JOIN_FILE

/*------------------------------------------------------------------------*/
/*		      f l S p l i t F i l e                               */
/*                                                                        */
/* Splits the file into two files. The original file contains the first   */
/* part, and a new file (which is created for that purpose) contains      */
/* the second part. If the current position is on a cluster               */
/* boundary, the file will be split at the current position. Otherwise,   */
/* the cluster of the current position is duplicated, one copy is the     */
/* first cluster of the new file, and the other is the last cluster of the*/
/* original file, which now ends at the current position.                 */
/*                                                                        */
/* Parameters:                                                            */
/*	file            : file to split.                                  */
/*      irPath          : Path name of the new file.                      */
/*                                                                        */
/* Returns:                                                               */
/*	irHandle        : handle of the new file.                         */
/*	FLStatus        : 0 on success, otherwise failed.                 */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define flSplitFile(ioreq)     flCall(FL_SPLIT_FILE,ioreq)


/*------------------------------------------------------------------------*/
/*		      f l J o i n F i l e                                 */
/*                                                                        */
/* joins two files. If the end of the first file is on a cluster          */
/* boundary, the files will be joined there. Otherwise, the data in       */
/* the second file from the beginning until the offset that is equal to   */
/* the offset in cluster of the end of the first file will be lost. The   */
/* rest of the second file will be joined to the first file at the end of */
/* the first file. On exit, the first file is the expanded file and the   */
/* second file is deleted.                                                */
/* Note: The second file will be open by this function, it is advised to  */
/*	 close it before calling this function in order to avoid          */
/*	 inconsistencies.                                                 */
/*                                                                        */
/* Parameters:                                                            */
/*	file            : file to join to.                                */
/*	irPath          : Path name of the file to be joined.             */
/*                                                                        */
/* Return:                                                                */
/*	FLStatus        : 0 on success, otherwise failed.                 */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define flJoinFile(ioreq)     flCall(FL_JOIN_FILE,ioreq)

#endif /* SPLIT_JOIN_FILE */
#endif /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*		      f l R e a d F i l e				*/
/*									*/
/* Reads from the current position in the file to the user-buffer.	*/
/* Parameters:                                                          */
/*	irHandle	: Handle of file to read.                       */
/*      irData		: Address of user buffer			*/
/*	irLength	: Number of bytes to read. If the read extends  */
/*			  beyond the end-of-file, the read is truncated */
/*			  at the end-of-file.				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*	irLength	: Actual number of bytes read			*/
/*----------------------------------------------------------------------*/

#define flReadFile(ioreq)	flCall(FL_READ_FILE,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*		      f l W r i t e F i l e				*/
/*									*/
/* Writes from the current position in the file from the user-buffer.   */
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Handle of file to write.			*/
/*      irData		: Address of user buffer			*/
/*	irLength	: Number of bytes to write.			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*	irLength	: Actual number of bytes written		*/
/*----------------------------------------------------------------------*/

#define flWriteFile(ioreq)	flCall(FL_WRITE_FILE,ioreq)

#endif  /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*		      f l S e e k F i l e				*/
/*									*/
/* Sets the current position in the file, relative to file start, end or*/
/* current position.							*/
/* Note: This function will not move the file pointer beyond the	*/
/* beginning or end of file, so the actual file position may be		*/
/* different from the required. The actual position is indicated on     */
/* return.								*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: File handle to close.                         */
/*      irLength	: Offset to set position.			*/
/*	irFlags		: Method code					*/
/*			  SEEK_START: absolute offset from start of file  */
/*			  SEEK_CURR:  signed offset from current position */
/*			  SEEK_END:   signed offset from end of file    */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*	irLength	: Actual absolute offset from start of file	*/
/*----------------------------------------------------------------------*/

/** Values of irFlags for flSeekFile: */

#define	SEEK_START	0	/* offset from start of file */
#define	SEEK_CURR	1	/* offset from current position */
#define	SEEK_END	2	/* offset from end of file */


#define flSeekFile(ioreq)	flCall(FL_SEEK_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		          f l F i n d F i l e				*/
/*                                                                      */
/* Finds a file entry in a directory, optionally modifying the file     */
/* time/date and/or attributes.                                         */
/* Files may be found by handle no. provided they are open, or by name. */
/* Only the Hidden, System or Read-only attributes may be modified.	*/
/* Entries may be found for any existing file or directory other than   */
/* the root. A DirectoryEntry structure describing the file is copied   */
/* to a user buffer.							*/
/*                                                                      */
/* The DirectoryEntry structure is defined in dosformt.h		*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: If by name: Drive number (0, 1, ...)		*/
/*			  else      : Handle of open file		*/
/*	irPath		: If by name: Specifies a file or directory path*/
/*	irFlags		: Options flags					*/
/*			  FIND_BY_HANDLE: Find open file by handle. 	*/
/*					  Default is access by path.    */
/*                        SET_DATETIME:	Update time/date from buffer	*/
/*			  SET_ATTRIBUTES: Update attributes from buffer	*/
/*	irDirEntry	: Address of user buffer to receive a		*/
/*			  DirectoryEntry structure			*/
/*                                                                      */
/* Returns:                                                             */
/*	irLength	: Modified					*/
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

/** Bit assignment of irFlags for flFindFile: */

#define SET_DATETIME	1	/* Change date/time */
#define	SET_ATTRIBUTES	2	/* Change attributes */
#define	FIND_BY_HANDLE	4	/* Find file by handle rather than by name */

#define	flFindFile(ioreq)	flCall(FL_FIND_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		 f l F i n d F i r s t F i l e				*/
/*                                                                      */
/* Finds the first file entry in a directory.				*/
/* This function is used in combination with the flFindNextFile call,   */
/* which returns the remaining file entries in a directory sequentially.*/
/* Entries are returned according to the unsorted directory order.	*/
/* flFindFirstFile creates a file handle, which is returned by it. Calls*/
/* to flFindNextFile will provide this file handle. When flFindNextFile */
/* returns 'noMoreEntries', the file handle is automatically closed.    */
/* Alternatively the file handle can be closed by a 'closeFile' call    */
/* before actually reaching the end of directory.			*/
/* A DirectoryEntry structure is copied to the user buffer describing   */
/* each file found. This structure is defined in dosformt.h.		*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: Specifies a directory path			*/
/*	irData		: Address of user buffer to receive a		*/
/*			  DirectoryEntry structure			*/
/*                                                                      */
/* Returns:                                                             */
/*	irHandle	: File handle to use for subsequent operations. */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define	flFindFirstFile(ioreq)	flCall(FL_FIND_FIRST_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		 f l F i n d N e x t F i l e				*/
/*                                                                      */
/* See the description of 'flFindFirstFile'.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: File handle returned by flFindFirstFile.	*/
/*	irData		: Address of user buffer to receive a		*/
/*			  DirectoryEntry structure			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define	flFindNextFile(ioreq)	flCall(FL_FIND_NEXT_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		      f l G e t D i s k I n f o				*/
/*									*/
/* Returns general allocation information.				*/
/*									*/
/* The bytes/sector, sector/cluster, total cluster and free cluster	*/
/* information are returned into a DiskInfo structure.			*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irData		: Address of DiskInfo structure                 */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

typedef struct {
  unsigned	bytesPerSector;
  unsigned	sectorsPerCluster;
  unsigned	totalClusters;
  unsigned	freeClusters;
} DiskInfo;


#define flGetDiskInfo(ioreq)	flCall(FL_GET_DISK_INFO,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*		      f l D e l e t e F i l e				*/
/*									*/
/* Deletes a file.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: path of file to delete			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flDeleteFile(ioreq)	flCall(FL_DELETE_FILE,ioreq)


#ifdef RENAME_FILE

/*----------------------------------------------------------------------*/
/*		      f l R e n a m e F i l e				*/
/*									*/
/* Renames a file to another name.					*/
/*									*/
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: path of existing file				*/
/*      irData		: path of new name.				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flRenameFile(ioreq)	flCall(FL_RENAME_FILE,ioreq)

#endif /* RENAME_FILE */


#ifdef SUB_DIRECTORY

/*----------------------------------------------------------------------*/
/*		      f l M a k e D i r					*/
/*									*/
/* Creates a new directory.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: path of new directory.			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flMakeDir(ioreq)	flCall(FL_MAKE_DIR,ioreq)


/*----------------------------------------------------------------------*/
/*		      f l R e m o v e D i r				*/
/*									*/
/* Removes an empty directory.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: path of directory to remove.			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flRemoveDir(ioreq)	flCall(FL_REMOVE_DIR,ioreq)

#endif /* SUB_DIRECTORY */
#endif /* FL_READ_ONLY */

#endif /* FILES > 0 */

#ifdef PARSE_PATH

/*----------------------------------------------------------------------*/
/*		      f l P a r s e P a t h				*/
/*									*/
/* Converts a DOS-like path string to a simple-path array.		*/
/*									*/
/* Note: Array length received in irPath must be greater than the 	*/
/* number of path components in the path to convert.			*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irData		: address of path string to convert		*/
/*	irPath		: address of array to receive parsed-path. 	*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

extern FLStatus flParsePath(IOreq FAR2 *ioreq);

#endif /* PARSE_PATH */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\fltl.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLTL.H_V  $
 * 
 *    Rev 1.7   Apr 15 2002 07:39:04   oris
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.6   Feb 19 2002 21:00:10   oris
 * Replaced blockev.h include directive with fltl.h and flreq.h
 * Added FL_LEAVE_BINARY_AREA definition.
 * 
 *    Rev 1.5   Jan 17 2002 23:02:54   oris
 * Added flash record as a parameter to flMount / flFormat / flPremount  prototypes
 * Added checkVolume routine pointer in the TL record.
 * Placed readBBT under NO_READ_BBT_CODE compilation flag.
 * Removed SINGLE_BUFFER compilation flag.
 * Added flash record as a parameter to flMount / flFormat / flPremount prototype.
 * 
 *    Rev 1.4   May 16 2001 21:19:56   oris
 * Made noOfDriver public.
 * 
 *    Rev 1.3   Apr 24 2001 17:09:02   oris
 * change readBBT routine interface.
 * 
 *    Rev 1.2   Apr 01 2001 07:57:48   oris
 * copywrite notice.
 * Changed readSectors prototype.
 * Aliggned left all # directives.
 * 
 *    Rev 1.1   Feb 14 2001 01:56:46   oris
 * Changed readBBT prototype.
 *
 *    Rev 1.0   Feb 04 2001 12:13:32   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLTL_H
#define FLTL_H

#include "flflash.h"
#include "flfuncno.h"
#include "flreq.h"

typedef struct {
  SectorNo sectorsInVolume;
  unsigned long bootAreaSize;
  unsigned long eraseCycles;
  unsigned long tlUnitBits;
} TLInfo;

/* See interface documentation of functions in ftllite.c    */

typedef struct tTL TL;        /* Forward definition */
typedef struct tTLrec TLrec;     /* Defined by translation layer */

struct tTL {
  TLrec        *rec;
  byte      partitionNo;
  byte      socketNo;

  const void FAR0 *(*mapSector)(TLrec *, SectorNo sectorNo, CardAddress *physAddr);
  FLStatus       (*writeSector)(TLrec *, SectorNo sectorNo, void FAR1 *fromAddress);

  FLStatus       (*writeMultiSector)(TLrec *, SectorNo sectorNo, void FAR1 *fromAddress,SectorNo sectorCount);
  FLStatus       (*readSectors)(TLrec *, SectorNo sectorNo, void FAR1 *dest,SectorNo sectorCount);

  FLStatus       (*deleteSector)(TLrec *, SectorNo sectorNo, SectorNo noOfSectors);
  FLStatus       (*tlSetBusy)(TLrec *, FLBoolean);
  void           (*dismount)(TLrec *);

#ifdef DEFRAGMENT_VOLUME
  FLStatus       (*defragment)(TLrec *, long FAR2 *bytesNeeded);
#endif
#if (defined(VERIFY_VOLUME) || defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR)) 
  FLStatus       (*checkVolume)(TLrec *);
#endif /* VERIFY_VOLUME || VERIFY_WRITE || VERIFY_ERASED_SECTOR */
  SectorNo       (*sectorsInVolume)(TLrec *);
  FLStatus       (*getTLInfo)(TLrec *, TLInfo *tlInfo);
  void           (*recommendedClusterInfo)(TLrec *, int *sectorsPerCluster, SectorNo *clusterAlignment);
#ifndef NO_READ_BBT_CODE
  FLStatus       (*readBBT)(TLrec *, CardAddress FAR1 * buf, long FAR2 * mediaSize, unsigned FAR2 * noOfBB);
#endif
};


#include "dosformt.h"

/* Translation layer registration information */

extern int noOfTLs;    /* No. of translation layers actually registered */

typedef struct {
  FLStatus (*mountRoutine)   (unsigned volNo, TL *tl, FLFlash *flash, FLFlash **volForCallback);
  FLStatus (*formatRoutine)  (unsigned volNo, TLFormatParams *deviceFormatParams, FLFlash *flash);
  FLStatus (*preMountRoutine)(FLFunctionNo callType, IOreq FAR2* ioreq ,FLFlash* flash,FLStatus* status);
} TLentry;

extern TLentry tlTable[TLS];
extern FLStatus noFormat (unsigned volNo, TLFormatParams *formatParams, FLFlash *flash);
extern FLStatus flMount(unsigned volNo, unsigned socketNo,TL *, FLBoolean useFilters , FLFlash *flash);
extern FLStatus flPreMount(FLFunctionNo callType, IOreq FAR2* ioreq , FLFlash *flash);
extern unsigned noOfDrives;

#ifdef FORMAT_VOLUME
extern FLStatus flFormat(unsigned volNo, TLFormatParams *formatParams, FLFlash * flash);

#define FL_LEAVE_BINARY_AREA 8
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\fltl.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLTL.C_V  $
 * 
 *    Rev 1.19   Jan 23 2002 23:33:08   oris
 * Bug fix - converting NFTL format to INFTL, with bad EDC in BBT.
 * Changed DFORMAT_PRINT syntax.
 * 
 *    Rev 1.18   Jan 20 2002 20:28:32   oris
 * Removed quick mount flag check for NFTL (no longer relevant).
 * Removed warnings (DFORMAT_PRINT).
 * 
 *    Rev 1.17   Jan 17 2002 23:02:44   oris
 * Added check for NULL pointers for readBBT and socket record.
 * Added checkVolume and defragment routine initialization.
 * Placed readBBT under NO_READ_BBT_CODE compilation flag.
 * Added include for docbdk.h
 * Added flash record as a parameter to flMount / flFormat / flPremount routine.
 * Removed check of TL_SINGLE_FLOOR_FORMATTING flag in the flFormat routine.
 * Added check for 0xFFFF FFFF binary signature.
 * 
 *    Rev 1.16   Nov 20 2001 20:25:24   oris
 * Changed debug print to dformat debug print.
 * 
 *    Rev 1.15   Nov 16 2001 00:22:06   oris
 * Fix check43to50 routine.
 * 
 *    Rev 1.14   Nov 08 2001 10:49:38   oris
 * Added format converter from NFTL to INFTL for ALON controllers (mobile DiskOnChip) NO_NFTL_2_INFTL compilation flag
 * Bug fix - support for DiskOnChip with different number of blocks in the last floor.
 * Added erase operation of bad blocks in write BBT routine (helps plant bad blocks).
 * 
 *    Rev 1.13   Sep 15 2001 23:46:40   oris
 * Removed some debug printing.
 * 
 *    Rev 1.12   Jul 15 2001 20:45:04   oris
 * Changed DFORMAT_PRINT syntax to be similar to DEBUG_PRINT.
 * 
 *    Rev 1.11   Jul 13 2001 01:06:54   oris
 * Rewritten writeBBT portion of the preMount routine - several bugs were found.
 * Millennium Plus does not support write BBT routine.
 * 
 *    Rev 1.10   Jun 17 2001 08:18:26   oris
 * Place write bbt under FORMAT_VOLUME compilation flag.
 * 
 *    Rev 1.9   May 16 2001 21:35:04   oris
 * Bug fix - write BBT did not cover the entire media.
 * 
 *    Rev 1.8   May 02 2001 06:39:46   oris
 * Removed the lastUsableBlock variable.
 * 
 *    Rev 1.7   Apr 24 2001 17:08:38   oris
 * Rebuilt writeBBT routine.
 * Added check for uninitialized socket in the premount routine (releveant to windows OS).
 * 
 *    Rev 1.6   Apr 16 2001 13:47:44   oris
 * Removed warrnings.
 * 
 *    Rev 1.5   Apr 09 2001 15:09:56   oris
 * End with an empty line.
 * 
 *    Rev 1.4   Apr 01 2001 07:57:34   oris
 * copywrite notice.
 * Removed debug massage when calling a premount routine from a TL that does not support it.
 * 
 *    Rev 1.3   Feb 18 2001 12:07:58   oris
 * Bug fix in writeBBT irLength argument is accepted if it is diffrent then 0 and not equal.
 * Bug fix in format sanity check must be sure a BDTLPartitionInfo exits before checking it for protection.
 *
 *    Rev 1.2   Feb 14 2001 01:55:12   oris
 * CountVolumes returns no of volumes in irFlags instead of irLength.
 * Added boundry argument to writeBBT.
 * Moved format varification from blockdev.c.
 *
 *    Rev 1.1   Feb 12 2001 11:57:42   oris
 * WriteBBT was moved from blockdev.c.
 *
 *    Rev 1.0   Feb 04 2001 12:07:30   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/* #include "flflash.h" */
#include "fltl.h"
#include "docbdk.h" /* Only for bdk signature size */

int noOfTLs;    /* No. of translation layers actually registered */

TLentry tlTable[TLS];

/*----------------------------------------------------------------------*/
/*                        m a r k U n i t B a d                         */
/*                                                                      */
/* Erase a unit and mark it as bad                                      */
/*                                                                      */
/* Parameters:                                                          */
/*    flash     : Pointer to MTD record                                 */
/*    badUnit   : Bad unit number to mark as bad                        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : flOK                                                */
/*----------------------------------------------------------------------*/

FLStatus markUnitBad(FLFlash * flash, CardAddress badUnit)
{
   static byte   zeroes[2] = {0,0};
   dword         offset;

   /* Mark the first page with 00. If the write operation
      fails try marking the following pages of the block */
   for (offset = 0 ; (offset < flash->erasableBlockSize) &&
       (flash->write(flash,(badUnit << flash->erasableBlockSizeBits)+offset,
        zeroes,sizeof(zeroes),0) != flOK);
        offset += flash->pageSize);
   /* Entire block can not be written to */
   if (offset == flash->erasableBlockSize)
		#ifndef NT5PORT
			DEBUG_PRINT(("Debug: Error failed marking unit as bad (address %ld).\n",badUnit));
		#else /*NT5PORT*/
			DEBUG_PRINT(("Debug: Error failed marking unit as bad (address).\n"));
		#endif /*NT5PORT*/

   return flOK;
}


#ifndef NO_NFTL_2_INFTL

/*----------------------------------------------------------------------*/
/*                        c h e c k 4 3 F o r m a t                     */
/*                                                                      */
/* Checks DiskOnChip 2000 tsop was formated using TrueFFS 4.3. If so it */
/* unformats the media.                                                 */
/*                                                                      */
/* Note - The routine will not help DiskOnChip larger then DiskOnChip   */
/*        2000 tsop formated with TrueFFS 4.3.                          */
/*                                                                      */
/* Note - How about erasing the media header last.                      */
/*                                                                      */
/* Parameters:                                                          */
/*    flash     : Pointer to MTD record                                 */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : flOK                                                */
/*                  flDataError - DiskOnChip ALON was formated with 4.3 */
/*                  but is not DiskOnChip 2000 tsop.                    */
/*----------------------------------------------------------------------*/

FLStatus check43Format(FLFlash *flash)
{
   FLStatus status;
   byte FAR1* buf;

   /* If this is an alon */
   if (flash->mediaType != DOC2000TSOP_TYPE)
      return flOK;
   buf = (flBufferOf(flSocketNoOf(flash->socket))->flData);
   if(flash->readBBT == NULL)
   {
      DFORMAT_PRINT(("ERROR : MTD read BBT routine was not initialized\r\n"));
      return flFeatureNotSupported;
   }
   status = flash->readBBT(flash,0,1,0,buf,FALSE);

   if (status == flBadBBT)
   {
      dword mediaSize = ((dword)flash->noOfChips*flash->chipSize);
      dword blockSize = 1<<flash->erasableBlockSizeBits;
      dword addr      = 0;
      dword offset;
      word  mediaHeaderBlock; /* ANAND unit number                */
      byte  blocksPerUnit;    /* Blocks per virtual unit          */
      byte  blockShift;       /* Bits to shift from block to unit */

CHECK_UNIT_WITH_ANAND:

      /* Either virgin or formated wih TrueFFS 4.3 */

      for( ; addr < mediaSize ; addr += blockSize)
      {
         checkStatus(flash->read(flash,addr,buf,5,0));
         if(tffscmp(buf,"ANAND",5) == 0)
            break;
      }

      if (addr == mediaSize) /* virgin card */
         return flOK;

      DFORMAT_PRINT(("This DiskOnChip was formated with an NFTL format.\r\n"));

      /* Calculate block multiplier bits */

      for (offset = addr + SECTOR_SIZE , status = flOK;
           (offset < addr + blockSize) && (status == flOK) ;
           offset += SECTOR_SIZE)
      {
         status = flash->read(flash,addr+offset,buf,512,EDC);
      }
      
      if(offset == addr + (SECTOR_SIZE<<1)) /* Bad EDC for NFTL unit header */
      {
         DFORMAT_PRINT(("ERROR - Unit with ANAND was found, but the BBT has bad EDC.\r\n"));
         goto CHECK_UNIT_WITH_ANAND; /* Keep searching */
      }

      offset = (offset - addr - (SECTOR_SIZE<<1)) << flash->erasableBlockSizeBits;

      for(blockShift = 0 ; offset < mediaSize ; blockShift++)
      {
         offset <<= 1;
      }
      blocksPerUnit = 1 << blockShift;

      mediaHeaderBlock = (word)(addr >> (flash->erasableBlockSizeBits + blockShift));

      DFORMAT_PRINT(("Please wait while unformating is in progress...\r\n"));

      /* Read and write 512 blocks of the BBT (start from the end) */

      for (offset = 0;
           offset < mediaSize>>(flash->erasableBlockSizeBits + blockShift);
           offset += SECTOR_SIZE)
      {
         word i;

         checkStatus(flash->read(flash,addr+offset+SECTOR_SIZE,buf,SECTOR_SIZE,EDC));
         for(i=0;i<SECTOR_SIZE;i++)
         {
            if (i+offset == mediaHeaderBlock)
               continue;

            if (buf[i]==BBT_BAD_UNIT) /* A bad block */
            {
               markUnitBad(flash , i+offset);
            }
            else                      /* A good block */
            {
               status = flash->erase(flash,(word)(i+offset),blocksPerUnit);
               if (status != flOK)
                  markUnitBad(flash , i+offset);
            }
         }
      }
      status = flash->erase(flash,mediaHeaderBlock,blocksPerUnit);
      if (status != flOK)
         markUnitBad(flash , mediaHeaderBlock);

      DFORMAT_PRINT(("Unformating of DiskOnChip 2000 tsop complete.\r\n"));
   }
   return flOK;
}
#endif /* NO_NFTL_2_INFTL */


/*----------------------------------------------------------------------*/
/*                              f l P r e M o u n t                     */
/*                                                                      */
/* Perform TL operation before the TL is mounted                        */
/*                                                                      */
/* Notes for FL_COUNT_VOLUMES routine                                   */
/* ----------------------------------                                   */
/* Note : The number of partitions returned is not neccarily the number */
/*        That can be accesses. protected partitions will need a key.   */
/* Note : TL that do not support several partitions will return 1       */
/*        unless the socket can not be mounted in which case 0 will be  */
/*        returned.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*    callType     : The type of the operation (see blockdev.h)         */
/*    ioreq        : Input Output packet                                */
/*    ioreq.irHandle : handle discribing the socket and the partition   */
/*    flash        : Location where the flash media record can be       */
/*                   stored. Note that it is not yet initialized        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/
FLStatus flPreMount(FLFunctionNo callType, IOreq FAR2* ioreq , FLFlash * flash)
{
  FLStatus layerStatus = flUnknownMedia;
  FLStatus callStatus;
  FLSocket *socket     = flSocketOf(FL_GET_SOCKET_FROM_HANDLE(ioreq));
    int iTL;

#ifdef NT5PORT
	if(socket->window.base == NULL){
		ioreq->irFlags = 1;
		return flOK;
	}
#endif /*NT5PORT*/

  /* Patch for OS drivers that call flInit before socket is initialized */
  if (callType == FL_COUNT_VOLUMES)
  {
     if((socket == NULL) || (socket->window.base==NULL))
     {
        ioreq->irFlags = 1;
        return flOK;
     }
  }

  /* Identify flash medium and initlize flash record */
  callStatus =  flIdentifyFlash(socket,flash);
  if (callStatus != flOK && callStatus != flUnknownMedia)
    return callStatus;

  /* Try sending call to the diffrent TLs */
  for (iTL = 0; (iTL < noOfTLs) && (layerStatus != flOK); iTL++)
    if (tlTable[iTL].preMountRoutine != NULL)
      layerStatus = tlTable[iTL].preMountRoutine(callType,ioreq, flash,&callStatus);

  if (layerStatus != flOK)
  {
     switch (callType)
     {
        case FL_COUNT_VOLUMES:
           ioreq->irFlags = 1;
           return flOK;

#ifdef FORMAT_VOLUME
        case FL_WRITE_BBT:
        {
           CardAddress endUnit = ((dword)(flash->chipSize * flash->noOfChips) >> flash->erasableBlockSizeBits); /* Media size */
           CardAddress unitsPerFloor = endUnit/flash->noOfFloors;
           CardAddress iUnit;
           CardAddress bUnit = *((unsigned long FAR1 *) ioreq->irData)
                               >> flash->erasableBlockSizeBits;
           word        badBlockNo;

           /* In case the user has given a specific length use it
           instead of the entire media */
           if ((ioreq->irLength != 0) && ( endUnit >
            ((dword)ioreq->irLength >> flash->erasableBlockSizeBits)))
           {
              endUnit = ioreq->irLength >> flash->erasableBlockSizeBits;
           }

           /* Millennium Plus DiskOnChip Family do not need a write bbt call */

           if ((flash->mediaType == MDOCP_TYPE   ) ||
               (flash->mediaType == MDOCP_16_TYPE)   )
           {
              DEBUG_PRINT(("DiskOnChip Millennium Plus has a H/W protected BBT.\r\n"));
              DEBUG_PRINT(("No need to erase the DiskOnChip. Simply reformat.\r\n"));
              return flFeatureNotSupported;
           }

           /* Erase entire media */

           for (iUnit = flash->firstUsableBlock ,badBlockNo = 0;
                iUnit < endUnit ;iUnit += ((iUnit+1) / unitsPerFloor) ?
                1 : flash->firstUsableBlock + 1)
           {
			#ifndef NT5PORT
              DFORMAT_PRINT(("Erasing unit number %ld\r",iUnit));
			#endif /*NT5PORT*/
              if (ioreq->irFlags > badBlockNo) /* There are additional bad blocks */
              {
                 if (bUnit == iUnit)
                 {
                    badBlockNo++;
                    bUnit = (*((CardAddress FAR1 *)flAddLongToFarPointer
                            (ioreq->irData,badBlockNo*sizeof(CardAddress))))
                             >> flash->erasableBlockSizeBits;
                    flash->erase(flash,(word)iUnit,1);
                    markUnitBad(flash,iUnit);
                    continue;
                 }
              }
              callStatus = flash->erase(flash,(word)iUnit,1);
              if (callStatus != flOK) /* Additional bad block was found */
              {
			#ifndef NT5PORT
                 DFORMAT_PRINT(("Failed erasing unit in write BBT (unit no %lu).\r\n",iUnit));
			#endif/*NT5PORT*/
                  markUnitBad(flash,iUnit);
              }
           }
           DEBUG_PRINT(("\nUnformat Complete        \r\n"));
           return flOK;
        }
#endif /* FORMAT_VOLUME */

        default : /* Protection routines */
        return flFeatureNotSupported;
     }
  }
  return callStatus;
}

/*----------------------------------------------------------------------*/
/*                       f l M o u n t                                  */
/*                                                                      */
/* Mount a translation layer                                            */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo        : Volume no.                                         */
/*    socketNo     : The socket no                                      */
/*    tl           : Where to store translation layer methods           */
/*    useFilters   : Whether to use filter translation-layers           */
/*    flash        : Location where the flash media record can be       */
/*                   stored. Note that it is not yet initialized        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

FLStatus flMount(unsigned volNo, unsigned socketNo,TL *tl,
                 FLBoolean useFilters , FLFlash * flash)
{
  FLFlash *volForCallback = NULL;
  FLSocket *socket = flSocketOf(socketNo);
  FLStatus status = flUnknownMedia;
  int iTL;

  FLStatus flashStatus = flIdentifyFlash(socket,flash);
  if (flashStatus != flOK && flashStatus != flUnknownMedia)
    return flashStatus;

  tl->recommendedClusterInfo = NULL;
  tl->writeMultiSector       = NULL;
  tl->readSectors            = NULL;
#ifndef NO_READ_BBT_CODE
  tl->readBBT                = NULL;
#endif 
#if (defined(VERIFY_VOLUME) || defined(VERIFY_WRITE))
  tl->checkVolume            = NULL;
#endif /* VERIFY_VOLUME || VERIFY_WRITE */
#ifdef DEFRAGMENT_VOLUME
  tl->defragment             = NULL;
#endif /* DEFRAGMENT */

  for (iTL = 0; (iTL < noOfTLs) && (status != flOK) && (status != flHWProtection); iTL++)
    if (tlTable[iTL].formatRoutine != NULL)    /* not a block-device filter */
      status = tlTable[iTL].mountRoutine(volNo,tl,flashStatus == flOK ? flash : NULL,&volForCallback);

  if (status == flOK) {
    if (volForCallback)
      volForCallback->setPowerOnCallback(volForCallback);

    if (useFilters)
      for (iTL = 0; iTL < noOfTLs; iTL++)
    if (tlTable[iTL].formatRoutine ==  NULL)    /* block-device filter */
      if (tlTable[iTL].mountRoutine(volNo,tl,NULL,NULL) == flOK)
        break;
  }
  return status;
}


#ifdef FORMAT_VOLUME

/*----------------------------------------------------------------------*/
/*                       f l F o r m a t                                */
/*                                                                      */
/* Formats the Flash volume                                             */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo            : Physical drive no.                             */
/*    formatParams    : Address of FormatParams structure to use        */
/*    flash        : Location where the flash media record can be       */
/*                   stored. Note that it is not yet initialized        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

FLStatus flFormat(unsigned volNo, TLFormatParams * formatParams,
                  FLFlash * flash)
{
  BinaryPartitionFormatParams FAR1* partitionPtr;
  FLSocket                        * socket = flSocketOf(volNo);
  FLStatus                          status = flUnknownMedia;
  int                               iTL,partitionNo;

  FLStatus flashStatus = flIdentifyFlash(socket,flash);
  if (flashStatus != flOK && flashStatus != flUnknownMedia)
    return flashStatus;

  /* Validity check for formatParams */

  if (!(flash->flags & INFTL_ENABLED)) /* Flash does not support INFTL */
  {
     if ((formatParams->noOfBDTLPartitions   > 1)           ||
#ifdef HW_PROTECTION
         ((formatParams->BDTLPartitionInfo != NULL) &&
          (formatParams->BDTLPartitionInfo->protectionType & PROTECTABLE))   ||
         ((formatParams->noOfBinaryPartitions > 0)&&
          (formatParams->binaryPartitionInfo->protectionType & PROTECTABLE)) ||
#endif /* HW_PROTECTION */
         (formatParams->noOfBinaryPartitions > 1))
     {
        DEBUG_PRINT(("Debug: feature not supported by the TL.\r\n"));
        return flFeatureNotSupported;
     }
  }

  for(partitionNo = 0 , partitionPtr = formatParams->binaryPartitionInfo;
      partitionNo < formatParams->noOfBinaryPartitions;
      partitionNo++,partitionPtr++)
  {

     if(*((dword FAR1*)(partitionPtr->sign)) == 0xffffffffL)
     {
        DEBUG_PRINT(("Debug: can not use 'FFFF' signature for Binary partition\r\n"));
        return flBadParameter;
     }
  }

  /* Try each of the registered TL */

#ifndef NO_NFTL_2_INFTL
  checkStatus(check43Format(flash));
#endif /* NO_NFTL_2_INFTL */

  for (iTL = 0; iTL < noOfTLs && status == flUnknownMedia; iTL++)
    if (tlTable[iTL].formatRoutine != NULL)    /* not a block-device filter */
      status = tlTable[iTL].formatRoutine(volNo,formatParams,flashStatus == flOK ? flash : NULL);

  return status;
}

#endif

FLStatus noFormat (unsigned volNo, TLFormatParams * formatParams, FLFlash *flash)
{
  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\i28f016.c ===
/*
 * $Log:   P:/user/amir/lite/vcs/i28f016.c_v  $
 *
 *    Rev 1.10	 06 Oct 1997  9:45:48	danig
 * VPP functions under #ifdef
 *
 *    Rev 1.9	10 Sep 1997 16:48:24   danig
 * Debug messages & got rid of generic names
 *
 *    Rev 1.8	31 Aug 1997 15:09:20   danig
 * Registration routine return status
 *
 *    Rev 1.7	24 Jul 1997 17:52:58   amirban
 * FAR to FAR0
 *
 *    Rev 1.6	20 Jul 1997 17:17:06   amirban
 * No watchDogTimer
 *
 *    Rev 1.5	07 Jul 1997 15:22:08   amirban
 * Ver 2.0
 *
 *    Rev 1.4	04 Mar 1997 16:44:22   amirban
 * Page buffer bug fix
 *
 *    Rev 1.3	18 Aug 1996 13:48:24   amirban
 * Comments
 *
 *    Rev 1.2	12 Aug 1996 15:49:04   amirban
 * Added suspend/resume
 *
 *    Rev 1.1	31 Jul 1996 14:30:50   amirban
 * Background stuff
 *
 *    Rev 1.0	18 Jun 1996 16:34:30   amirban
 * Initial revision.
 */

/************************************************************************/
/*									*/
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*									*/
/* This MTD supports the following Flash technologies:			*/
/*									*/
/* - Intel 28F016SA/28016SV/Cobra 16-mbit devices			*/
/*									*/
/* And (among else), the following Flash media and cards:		*/
/*									*/
/* - Intel Series-2+ PCMCIA cards					*/
/*									*/
/*----------------------------------------------------------------------*/

#include "flflash.h"
#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif

/* JEDEC ids for this MTD */
#define I28F016_FLASH	0x89a0
#define LH28F016SU_FLASH 0xB088

#define SETUP_ERASE	0x2020
#define SETUP_WRITE	0x4040
#define CLEAR_STATUS	0x5050
#define READ_STATUS	0x7070
#define READ_ID 	0x9090
#define SUSPEND_ERASE	0xb0b0
#define CONFIRM_ERASE	0xd0d0
#define RESUME_ERASE	0xd0d0
#define READ_ARRAY	0xffff

#define LOAD_PAGE_BUFFER 0xe0e0
#define WRITE_PAGE_BUFFER 0x0c0c
#define READ_EXTENDED_REGS 0x7171

#define WSM_VPP_ERROR	0x08
#define WSM_ERROR	0x38
#define WSM_SUSPENDED	0x40
#define WSM_READY	0x80

#define GSR_ERROR	0x20

#define both(word)	(vol.interleaving == 1 ? tffsReadWordFlash(word) : tffsReadWordFlash(word) & (tffsReadWordFlash(word) >> 8))
#define any(word)	(tffsReadWordFlash(word) | (tffsReadWordFlash(word) >> 8))

/*----------------------------------------------------------------------*/
/*		      i 2 8 f 0 1 6 W o r d S i z e			*/
/*									*/
/* Identify the card size for an Intel 28F016 word-mode Flash array.	*/
/* Sets the value of vol.noOfChips.					*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/

FLStatus i28f016WordSize(FLFlash vol)
{
  FlashWPTR flashPtr = (FlashWPTR) flMap(vol.socket,0);
  unsigned short id0, id1;

  tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
  tffsWriteWordFlash(flashPtr, READ_ID);
  /* We leave the first chip in Read ID mode, so that we can		*/
  /* discover an address wraparound.					*/
  if( vol.type == I28F016_FLASH ) {
    id0 = 0x0089;
    id1 = 0x66a0;
  }
  else if( vol.type == LH28F016SU_FLASH ) {
    id0 = 0x00B0;
    id1 = 0x6688;
  }

  for (vol.noOfChips = 1;	/* Scan the chips */
       vol.noOfChips < 2000;  /* Big enough ? */
       vol.noOfChips++) {
    flashPtr = (FlashWPTR) flMap(vol.socket,vol.noOfChips * vol.chipSize);

    if (tffsReadWordFlash(flashPtr) == id0 && tffsReadWordFlash(flashPtr + 1) == id1)
      break;	  /* We've wrapped around to the first chip ! */

    tffsWriteWordFlash(flashPtr, READ_ID);
    if (!(tffsReadWordFlash(flashPtr) == id0 && tffsReadWordFlash(flashPtr + 1) == id1))
      break;
    tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }

  flashPtr = (FlashWPTR) flMap(vol.socket,0);
  tffsWriteWordFlash(flashPtr, READ_ARRAY);

  return flOK;
}


/*----------------------------------------------------------------------*/
/*			i 2 8 f 0 1 6 W r i t e 			*/
/*									*/
/* Write a block of bytes to Flash					*/
/*									*/
/* This routine will be registered as the MTD flash.write routine	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	overwrite	: TRUE if overwriting old Flash contents	*/
/*			  FALSE if old contents are known to be erased	*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus i28f016Write(FLFlash vol,
			   CardAddress address,
			   const VOID FAR1 *buffer,
			   dword length,
			   word overwrite)
{
  /* Set timeout of 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  FLStatus status = flOK;
  FlashWPTR flashPtr;
  ULONG maxLength, i, from;
  UCHAR * bBuffer = (UCHAR *) buffer;
  FlashPTR bFlashPtr;
  ULONG * dBuffer = (ULONG *) buffer;
  FlashDPTR dFlashPtr;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  if ((length & 1) || (address & 1))	/* Only write words on word-boundary */
    return flBadParameter;

#ifdef SOCKET_12_VOLTS
  checkStatus(flNeedVpp(vol.socket));
#endif

  maxLength = 256 * vol.interleaving;
  for (from = 0; from < length && status == flOK; from += maxLength) {
    FlashWPTR currPtr;
    ULONG lengthWord;
    ULONG tailBytes;
    ULONG thisLength = length - from;

    if (thisLength > maxLength)
      thisLength = maxLength;
    lengthWord = (thisLength + vol.interleaving - 1) /
		 (vol.interleaving == 1 ? 2 : vol.interleaving) - 1;
    if (vol.interleaving != 1)
      lengthWord |= (lengthWord << 8);
    flashPtr = (FlashWPTR) flMap(vol.socket,address + from);

    tailBytes = ((thisLength - 1) & (vol.interleaving - 1)) + 1;
    for (i = 0, currPtr = flashPtr;
	 i < (ULONG)vol.interleaving && i < thisLength;
	 i += 2, currPtr++) {
      tffsWriteWordFlash(currPtr, LOAD_PAGE_BUFFER);
      if (i < tailBytes) {
	tffsWriteWordFlash(currPtr, (USHORT) lengthWord);
      }
      else {
	tffsWriteWordFlash(currPtr, (USHORT) (lengthWord - 1));
      }
      tffsWriteWordFlash(currPtr, 0);
    }

    dFlashPtr = (FlashDPTR) flashPtr;
    bFlashPtr = (FlashPTR) flashPtr;
    for (i = 0; i < thisLength - 4; i += 4) {
	tffsWriteDwordFlash(dFlashPtr + i, *(dBuffer + from + i));
    }
    for(; i < thisLength; i++) {
	tffsWriteByteFlash(bFlashPtr + i, *(bBuffer + from + i));
    }

    for (i = 0, currPtr = flashPtr;
	 i < (ULONG)vol.interleaving && i < thisLength;
	 i += 2, currPtr++) {
      tffsWriteWordFlash(currPtr, WRITE_PAGE_BUFFER);
      if (!((address + from + i) & vol.interleaving)) {
	/* Even address */
	tffsWriteWordFlash(currPtr, (USHORT) lengthWord);
	tffsWriteWordFlash(currPtr, 0);
      }
      else {
	/* Odd address */
	tffsWriteWordFlash(currPtr, 0);
	tffsWriteWordFlash(currPtr, (USHORT) lengthWord);
      }

    }

    /* map to the GSR & BSR */
    flashPtr = (FlashWPTR) flMap(vol.socket,
			       (CardAddress)( (address + from & -(int)vol.erasableBlockSize) +
			       4 * vol.interleaving));

    for (i = 0, currPtr = flashPtr;
	 i < (ULONG)vol.interleaving && i < thisLength;
	 i += 2, currPtr++) {
      tffsWriteWordFlash(currPtr, READ_EXTENDED_REGS);
      while (!(both(currPtr) & WSM_READY) && flMsecCounter < writeTimeout)
	    ;
      if ((any(currPtr) & GSR_ERROR) || !(both(currPtr) & WSM_READY)) {
	DEBUG_PRINT(("Debug: write failed for 16-bit Intel media.\n"));
	status = flWriteFault;
	tffsWriteWordFlash(currPtr, CLEAR_STATUS);
      }
      tffsWriteWordFlash(currPtr, READ_ARRAY);
    }
  }

#ifdef SOCKET_12_VOLTS
  flDontNeedVpp(vol.socket);
#endif

  /* verify the data */
  dFlashPtr = (FlashDPTR) flMap(vol.socket, address);
  dBuffer = (ULONG *) buffer;

  if (status == flOK) {
    /* compare double words */
    for (;length >= 4; length -= 4, dFlashPtr++, dBuffer++) {
	if (tffsReadDwordFlash(dFlashPtr) != *dBuffer) {
	    DEBUG_PRINT(("Debug: write failed for 16-bit Intel media in verification.\n"));
	return flWriteFault;
	}
    }

    /* compare the last bytes */
    bFlashPtr = (FlashPTR) dFlashPtr;
    bBuffer = (UCHAR *)dBuffer;
    for (; length; length--, bFlashPtr++, bBuffer++) {
	if (tffsReadByteFlash(bFlashPtr) != *bBuffer) {
	    DEBUG_PRINT(("Debug: write failed for 16-bit Intel media in verification.\n"));
	return flWriteFault;
	}
    }
  }

  return status;
}


/*----------------------------------------------------------------------*/
/*			i 2 8 f 0 1 6 E r a s e 			*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks			*/
/*									*/
/* This routine will be registered as the MTD vol.erase routine */
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus i28f016Erase(FLFlash vol,
			   word firstErasableBlock,
			   word numOfErasableBlocks)
{
  FLStatus status = flOK;	/* unless proven otherwise */
  LONG iBlock;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  checkStatus(flNeedVpp(vol.socket));
#endif

  for (iBlock = 0; iBlock < numOfErasableBlocks && status == flOK; iBlock++) {
    FlashWPTR currPtr;
    LONG i;
    FLBoolean finished;

    FlashWPTR flashPtr = (FlashWPTR)
	   flMap(vol.socket,(firstErasableBlock + iBlock) * vol.erasableBlockSize);

    for (i = 0, currPtr = flashPtr;
	 i < vol.interleaving;
	 i += 2, currPtr++) {
      tffsWriteWordFlash(currPtr, SETUP_ERASE);
      tffsWriteWordFlash(currPtr, CONFIRM_ERASE);
    }

    do {
#ifdef FL_BACKGROUND
      while (flForeground(1) == BG_SUSPEND) {		/* suspend */
	for (i = 0, currPtr = flashPtr;
	     i < vol.interleaving;
	     i += 2, currPtr++) {
	  tffsWriteWordFlash(currPtr, READ_STATUS);
	  if (!(both(currPtr) & WSM_READY)) {
	    tffsWriteWordFlash(currPtr, SUSPEND_ERASE);
	    tffsWriteWordFlash(currPtr, READ_STATUS);
	    while (!(both(currPtr) & WSM_READY))
	      ;
	  }
	  tffsWriteWordFlash(currPtr, READ_ARRAY);
	}
      }
#endif
      finished = TRUE;
      for (i = 0, currPtr = flashPtr;
	   i < vol.interleaving;
	   i += 2, currPtr++) {
	tffsWriteWordFlash(currPtr, READ_STATUS);

	if (any(currPtr) & WSM_SUSPENDED) {
	  tffsWriteWordFlash(currPtr, RESUME_ERASE);
	  finished = FALSE;
	}
	else if (!(both(currPtr) & WSM_READY))
	  finished = FALSE;
	else {
	  if (any(currPtr) & WSM_ERROR) {
	    DEBUG_PRINT(("Debug: erase failed for 16-bit Intel media.\n"));
	    status = (any(currPtr) & WSM_VPP_ERROR) ? flVppFailure : flWriteFault;
	    tffsWriteWordFlash(currPtr, CLEAR_STATUS);
	  }
	  tffsWriteWordFlash(currPtr, READ_ARRAY);
	}
      }
      flDelayMsecs(10);
    } while (!finished);

  }

#ifdef SOCKET_12_VOLTS
  flDontNeedVpp(vol.socket);
#endif

  return status;
}

/*----------------------------------------------------------------------*/
/*			  i 2 8 f 0 1 6 M a p				*/
/*									*/
/* Map through buffer. This routine will be registered as the map	*/
/* routine for this MTD.						*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Flash address to be mapped.				*/
/*	length	: number of bytes to map.				*/
/*									*/
/* Returns:								*/
/*	Pointer to the buffer data was mapped to.			*/
/*									*/
/*----------------------------------------------------------------------*/

VOID FAR0 *i28f016Map (FLFlash vol, CardAddress address, int length)
{
  vol.socket->remapped = TRUE;
  return mapThroughBuffer(&vol,address,length);
}

/*----------------------------------------------------------------------*/
/*			  i 2 8 f 0 1 6 R e a d 			*/
/*									*/
/* Read some data from the flash. This routine will be registered as	*/
/* the read routine for this MTD.					*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Address to read from. 				*/
/*	buffer	: buffer to read to.					*/
/*	length	: number of bytes to read (up to sector size).		*/
/*	modes	: EDC flag etc. 					*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failed.		*/
/*									*/
/*----------------------------------------------------------------------*/

FLStatus i28f016Read(FLFlash vol,
			 CardAddress address,
			 VOID FAR1 *buffer,
			 dword length,
			 word modes)
{
  ULONG i;
  UCHAR * bBuffer;
  FlashPTR bFlashPtr;
  ULONG * dBuffer = (ULONG *)buffer;
  FlashDPTR dFlashPtr = (FlashDPTR)flMap(vol.socket, address);

  for (i = 0; i < length - 4; i += 4, dBuffer++, dFlashPtr++) {
    *dBuffer = tffsReadDwordFlash(dFlashPtr);
  }
  bBuffer = (UCHAR *)dBuffer;
  bFlashPtr = (FlashPTR)dFlashPtr;
  for(; i < length; i++, bBuffer++, bFlashPtr++) {
    *bBuffer = tffsReadByteFlash(bFlashPtr);
  }
  return flOK ;
}

/*----------------------------------------------------------------------*/
/*		       i 2 8 f 0 1 6 I d e n t i f y			*/
/*									*/
/* Identifies media based on Intel 28F016 and registers as an MTD for	*/
/* such.								*/
/*									*/
/* This routine will be placed on the MTD list in custom.h. It must be	*/
/* an extern routine.							*/
/*									*/
/* On successful identification, the Flash structure is filled out and	*/
/* the write and erase routines registered.				*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on positive identificaion, failed otherwise */
/*----------------------------------------------------------------------*/

FLStatus i28f016Identify(FLFlash vol)
{
  FlashWPTR flashPtr;

  DEBUG_PRINT(("Debug: entering 16-bit Intel media identification routine.\n"));

  flSetWindowBusWidth(vol.socket,16);/* use 16-bits */
  flSetWindowSpeed(vol.socket,150);  /* 120 nsec. */
  flSetWindowSize(vol.socket,2);	/* 8 KBytes */

  flashPtr = (FlashWPTR) flMap(vol.socket,0);

  vol.noOfChips = 0;
  tffsWriteWordFlash(flashPtr, READ_ID);
  if (tffsReadWordFlash(flashPtr) == 0x0089 && tffsReadWordFlash(flashPtr + 1) == 0x66a0) {
    /* Word mode */
    vol.type = I28F016_FLASH;
    vol.interleaving = 1;
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }
  else if (tffsReadWordFlash(flashPtr) == 0x00B0 && tffsReadWordFlash(flashPtr + 1) == 0x6688) {
    /* Word mode */
    vol.type = LH28F016SU_FLASH;
    vol.interleaving = 1;
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }
  else {
    /* Use standard identification routine to detect byte-mode */
    flIntelIdentify(&vol, NULL,0);
    if (vol.interleaving == 1)
      vol.type = NOT_FLASH;	/* We cannot handle byte-mode interleaving-1 */
  }

  if( (vol.type == I28F016_FLASH) || (vol.type == LH28F016SU_FLASH) ) {
    vol.chipSize = 0x200000L;
    vol.erasableBlockSize = 0x10000L * vol.interleaving;
    checkStatus(vol.interleaving == 1 ?
		i28f016WordSize(&vol) :
		flIntelSize(&vol, NULL,0));

    /* Register our flash handlers */
    vol.write = i28f016Write;
    vol.erase = i28f016Erase;
    vol.read = i28f016Read;
    vol.map = i28f016Map;

    DEBUG_PRINT(("Debug: identified 16-bit Intel media.\n"));
    return flOK;
  }
  else {
    DEBUG_PRINT(("Debug: failed to identify 16-bit Intel media.\n"));
    return flUnknownMedia;	/* not ours */
  }
}


/*----------------------------------------------------------------------*/
/*		     f l R e g i s t e r I 2 8 F 0 1 6			*/
/*									*/
/* Registers this MTD for use						*/
/*									*/
/* Parameters:								*/
/*	None								*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterI28F016(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = i28f016Identify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\ftllite.c ===
/*
 * $Log:   V:/Flite/archives/FLite/src/FTLLITE.C_V  $
 * 
 *    Rev 1.50   12 Mar 2000 14:06:22   dimitrys
 * Change #define FL_BACKGROUND,  get rid of 
 *   warnings
 * 
 *    Rev 1.49   05 Mar 2000 18:58:08   dimitrys
 * Fix possible memory faults because of out-of-range
 *   memory access in next functions:
 *   - setupMapCache(), setVirtualMap(), writeSector()
 * 
 *    Rev 1.48   05 Mar 2000 17:41:08   dimitrys
 * Memory leaks in mountFTL  were fixed,  add setting
 *   pointers to Tables to NULL in dismountFTL() call,
 *   fix possible memory faults because of out-of-range
 *   memory access in next functions:
 *   - logical2Physical(), mapLogical(), setupMapCache(),
 *     virtual2Logical(), findFreeSector(), markAllocMap(),
 *     AllocateAndWriteSector(), closeReplacementPage(),
 *     setVirtualMap(), mapSector(), writeSector()
 *
 *    Rev 1.47   Jul 26 1999 17:54:42   marinak
 * Fix memory leaks
 *
 *    Rev 1.46   24 Feb 1999 14:17:44   marina
 * put TLrec back
 *
 *    Rev 1.45   23 Feb 1999 20:24:16   marina
 * memory leaks in formatFTL and mountFTL  were fixed; void in place of TLrec
 *
 *    Rev 1.44   31 Jan 1999 19:54:08   marina
 * WriteMultiSector
 *
 *    Rev 1.43   17 Jan 1999 17:07:16   marina
 * fix dismount bug
 *
 *    Rev 1.42   13 Jan 1999 18:55:24   marina
 * Always define sectorsInVolume
 *
 *    Rev 1.41   29 Dec 1998 11:03:02   marina
 * Get rid of warnings, prepare for unconditional dismount
 *
 *    Rev 1.40   26 Oct 1998 17:29:36   marina
 * In function flRegisterFTL formatRoutine initialization
 *    is called if not defined FORMAT_VOLUME
 *
 *    Rev 1.39   03 Sep 1998 13:59:02   ANDRY
 * better DEBUG_PRINT
 *
 *    Rev 1.38   16 Aug 1998 20:29:50   amirban
 * TL definition changes for ATA & ZIP
 *
 *    Rev 1.37   24 Mar 1998 10:48:14   Yair
 * Added casts
 *
 *    Rev 1.36   01 Mar 1998 12:59:36   amirban
 * Add parameter to mapSector
 *
 *    Rev 1.35   23 Feb 1998 17:08:32   Yair
 * Added casts
 *
 *    Rev 1.34   19 Feb 1998 19:05:46   amirban
 * Shortened FORMAT_PATTERN, and changed repl. page handling
 *
 *    Rev 1.33   23 Nov 1997 17:19:36   Yair
 * Get rid of warnings (With Danny)
 *
 *    Rev 1.32   11 Nov 1997 15:26:46   ANDRY
 * () in complex expressions to get rid of compiler warnings
 *
 *    Rev 1.31   06 Oct 1997 18:37:24   ANDRY
 * no COBUX
 *
 *    Rev 1.30   05 Oct 1997 15:31:40   ANDRY
 * for COBUX: checkForWriteInPlace() always skips even number of bytes
` *
 *    Rev 1.29   28 Sep 1997 18:22:08   danig
 * Free socket buffer in flsocket.c
 *
 *    Rev 1.28   23 Sep 1997 18:09:44   danig
 * Initialize buffer.sectorNo in initTables
 *
 *    Rev 1.27   10 Sep 1997 16:17:16   danig
 * Got rid of generic names
 *
 *    Rev 1.26   31 Aug 1997 14:28:30   danig
 * Registration routine return status
 *
 *    Rev 1.25   28 Aug 1997 19:01:28   danig
 * buffer per socket
 *
 *    Rev 1.24   28 Jul 1997 14:52:30   danig
 * volForCallback
 *
 *    Rev 1.23   24 Jul 1997 18:02:44   amirban
 * FAR to FAR0
 *
 *    Rev 1.22   21 Jul 1997 19:18:36   danig
 * Compile with SINGLE_BUFFER
 *
 *    Rev 1.21   20 Jul 1997 17:17:12   amirban
 * Get rid of warnings
 *
 *    Rev 1.20   07 Jul 1997 15:22:00   amirban
 * Ver 2.0
 *
 *    Rev 1.19   03 Jun 1997 17:08:10   amirban
 * setBusy change
 *
 *    Rev 1.18   18 May 1997 17:56:04   amirban
 * Add flash read/write flag parameter
 *
 *    Rev 1.17   01 May 1997 12:15:52   amirban
 * Initialize vol.garbageCollectStatus
 *
 *    Rev 1.16   02 Apr 1997 16:56:06   amirban
 * More Big-Endian: Virtual map
 *
 *    Rev 1.15   18 Mar 1997 15:04:06   danig
 * More Big-Endian corrections for BAM
 *
 *    Rev 1.14   10 Mar 1997 18:52:38   amirban
 * Big-Endian corrections for BAM
 *
 *    Rev 1.13   21 Oct 1996 18:03:18   amirban
 * Defragment i/f change
 *
 *    Rev 1.12   09 Oct 1996 11:55:30   amirban
 * Assign Big-Endian unit numbers
 *
 *    Rev 1.11   08 Oct 1996 12:17:46   amirban
 * Use remapped
 *
 *    Rev 1.10   03 Oct 1996 11:56:42   amirban
 * New Big-Endian
 *
 *    Rev 1.9   09 Sep 1996 11:39:12   amirban
 * Background and mapSector bugs
 *
 *    Rev 1.8   29 Aug 1996 14:19:04   amirban
 * Fix boot-image bug, warnings
 *
 *    Rev 1.7   15 Aug 1996 14:04:38   amirban
 *
 *    Rev 1.6   12 Aug 1996 15:49:54   amirban
 * Advanced background transfer, and defined setBusy
 *
 *    Rev 1.5   31 Jul 1996 14:30:28   amirban
 * Background stuff
 *
 *    Rev 1.3   08 Jul 1996 17:21:16   amirban
 * Better page scan in mount unit
 *
 *    Rev 1.2   16 Jun 1996 14:03:42   amirban
 * Added badFormat return code for mount
 *
 *    Rev 1.1   09 Jun 1996 18:16:02   amirban
 * Corrected definition of LogicalAddress
 *
 *    Rev 1.0   20 Mar 1996 13:33:06   amirban
 * Initial revision.
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

#include "flflash.h"
#include "flbuffer.h"
#include "fltl.h"

#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif

/*  Implementation constants and type definitions */

#define SECTOR_OFFSET_MASK (SECTOR_SIZE - 1)

typedef long int LogicalAddress;	/* Byte address of media in logical
					   unit no. order. */
typedef long int VirtualAddress;	/* Byte address of media as specified
					   by Virtual Map. */
typedef SectorNo LogicalSectorNo;	/* A logical sector no. is given
					   by dividing its logical address by
					   the sector size */
typedef SectorNo VirtualSectorNo;	/* A virtual sector no. is such that
					   the first page is no. 0, the 2nd
					   is 1 etc.
					   The virtual sector no. is given
					   by dividing its virtual address by
					   the sector size and adding the
					   number of pages (result always
					   positive). */
typedef unsigned short UnitNo;

#define ADDRESSES_PER_SECTOR (SECTOR_SIZE / sizeof(LogicalAddress))
#define UNASSIGNED_ADDRESS (ULONG_PTR)-1
#define DELETED_ADDRESS    0
#define DELETED_SECTOR     0

#define PAGE_SIZE_BITS (SECTOR_SIZE_BITS + (SECTOR_SIZE_BITS - 2))

/* Unit descriptor record */

#define UNASSIGNED_UNIT_NO 0xffff
#define MARKED_FOR_ERASE   0x7fff

typedef struct {
  short		noOfFreeSectors;
  short         noOfGarbageSectors;
} Unit;

typedef Unit *UnitPtr;


/* Structure of data on a unit */

#define FREE_SECTOR      0xffffffffl
#define GARBAGE_SECTOR   0
#define ALLOCATED_SECTOR 0xfffffffel
#define	FORMAT_SECTOR    0x30
#define DATA_SECTOR      0x40
#define	REPLACEMENT_PAGE 0x60
#define BAD_SECTOR       0x70


static char FORMAT_PATTERN[15] = { 0x13, 3, 'C', 'I', 'S',
                             0x46, 57, 0, 'F', 'T', 'L', '1', '0', '0', 0 };

typedef struct {
  char		formatPattern[15];
  unsigned char	noOfTransferUnits;	/* no. of transfer units */
  LEulong	wearLevelingInfo;
  LEushort	logicalUnitNo;
  unsigned char	log2SectorSize;
  unsigned char	log2UnitSize;
  LEushort	firstPhysicalEUN;	/* units reserved for boot image */
  LEushort	noOfUnits;		/* no. of formatted units */
  LEulong	virtualMediumSize;	/* virtual size of volume */
  LEulong	directAddressingMemory;	/* directly addressable memory */
  LEushort	noOfPages;		/* no. of virtual pages */
  unsigned char	flags;
  unsigned char	eccCode;
  LEulong	serialNumber;
  LEulong	altEUHoffset;
  LEulong	BAMoffset;
  char		reserved[12];
  char		embeddedCIS[4];		/* Actual length may be larger. By
					   default, this contains FF's */
} UnitHeader;

/* flags assignments */

#define	HIDDEN_AREA_FLAG	1
#define	REVERSE_POLARITY_FLASH	2
#define	DOUBLE_BAI		4


#define dummyUnit ((const UnitHeader *) 0)  /* for offset calculations */

#define logicalUnitNoOffset ((char *) &dummyUnit->logicalUnitNo -	\
			     (char *) dummyUnit)

#ifndef MALLOC

#define HEAP_SIZE						\
		((0x100000l >> PAGE_SIZE_BITS) *                \
			sizeof(LogicalSectorNo) +               \
		 (0x100000l / ASSUMED_FTL_UNIT_SIZE) *          \
			(sizeof(Unit) + sizeof(UnitPtr))) *     \
		MAX_VOLUME_MBYTES +                             \
		(ASSUMED_VM_LIMIT / SECTOR_SIZE) *              \
			sizeof(LogicalSectorNo)

#endif

#define cannotWriteOver(newContents, oldContents)		\
		((newContents) & ~(oldContents))


struct tTLrec {
  FLBoolean		badFormat;		/* true if FTL format is bad */

  VirtualSectorNo	totalFreeSectors;	/* Free sectors on volume */
  SectorNo		virtualSectors;		/* size of virtual volume */
  unsigned int		unitSizeBits;		/* log2 of unit size */
  unsigned int		erasableBlockSizeBits;	/* log2 of erasable block size */
  UnitNo		noOfUnits;
  UnitNo		noOfTransferUnits;
  UnitNo		firstPhysicalEUN;
  int			noOfPages;
  unsigned	directAddressingSectors;/* no. of directly addressable sectors */
  VirtualAddress 	directAddressingMemory;	/* end of directly addressable memory */
  CardAddress		unitOffsetMask;		/* = 1 << unitSizeBits - 1 */
  CardAddress		bamOffset;
  unsigned int		sectorsPerUnit;
  unsigned int		unitHeaderSectors;	/* sectors used by unit header */

  Unit *		physicalUnits;		/* unit table by physical no. */
  Unit **		logicalUnits;		/* unit table by logical no. */
  Unit *		transferUnit;		/* The active transfer unit */
  LogicalSectorNo *	pageTable;		/* page translation table */
						/* directly addressable sectors */
  LogicalSectorNo	replacementPageAddress;
  VirtualSectorNo	replacementPageNo;

  SectorNo 		mappedSectorNo;
  const void FAR0 *	mappedSector;
  CardAddress		mappedSectorAddress;

  unsigned long		currWearLevelingInfo;

#ifdef FL_BACKGROUND
  Unit *		unitEraseInProgress;	/* Unit currently being formatted */
  FLStatus		garbageCollectStatus;	/* Status of garbage collection */

  /* When unit transfer is in the background, and is currently in progress,
     all write operations done on the 'from' unit moust be mirrored on the
     transfer unit. If so, 'mirrorOffset' will be non-zero and will be the
     offset of the alternate address from the original. 'mirrorFrom' and
     'mirrorTo' will be the limits of the original addresses to mirror. */
  long int		mirrorOffset;
  CardAddress		mirrorFrom,
			mirrorTo;
#endif

#ifndef SINGLE_BUFFER
  FLBuffer *		volBuffer;		/* Define a sector buffer */
#endif

  FLFlash		flash;

#ifndef MALLOC
  char			heap[HEAP_SIZE];
#endif
};


typedef TLrec Flare;

static Flare vols[SOCKETS];


#ifdef SINGLE_BUFFER

extern FLBuffer buffer;

#else

#define buffer (*vol.volBuffer)

/* Virtual map cache (shares memory with buffer) */
#define mapCache	((LEulong *) buffer.flData)

#endif


/* Unit header buffer (shares memory with buffer) */
#define uh		((UnitHeader *) buffer.flData)

/* Transfer sector buffer (shares memory with buffer) */
#define sectorCopy 	((LEulong *) buffer.flData)

#define FREE_UNIT	-0x400	/* Indicates a transfer unit */

/* Function definition */
void dismountFTL(Flare vol);

/*----------------------------------------------------------------------*/
/*		         p h y s i c a l B a s e			*/
/*									*/
/* Returns the physical address of a unit.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: unit pointer					*/
/*                                                                      */
/* Returns:                                                             */
/*	physical address of unit					*/
/*----------------------------------------------------------------------*/

static CardAddress physicalBase(Flare vol,  const Unit *unit)
{
  return (CardAddress) (unit - vol.physicalUnits) << vol.unitSizeBits;
}


/*----------------------------------------------------------------------*/
/*		      l o g i c a l 2 P h y s i c a l			*/
/*									*/
/* Returns the physical address of a logical sector no.			*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	address		: logical sector no.				*/
/*                                                                      */
/* Returns:                                                             */
/*	CardAddress	: physical address of sector			*/
/*----------------------------------------------------------------------*/

static CardAddress logical2Physical(Flare vol,  LogicalSectorNo address)
{
  UnitNo index;
  CardAddress physAddr;

  index = (UnitNo)(address >> (vol.unitSizeBits - SECTOR_SIZE_BITS));
  if( index >= vol.noOfUnits )
    return UNASSIGNED_ADDRESS;
  physAddr = physicalBase(&vol,vol.logicalUnits[index]);
  physAddr |= (((CardAddress) address << SECTOR_SIZE_BITS) & vol.unitOffsetMask);
  return physAddr;
}


/*----------------------------------------------------------------------*/
/*		            m a p L o g i c a l				*/
/*									*/
/* Maps a logical sector and returns pointer to physical Flash location.*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	address		: logical sector no.				*/
/*                                                                      */
/* Returns:                                                             */
/*	Pointer to sector on Flash 					*/
/*----------------------------------------------------------------------*/

static void FAR0 *mapLogical(Flare vol, LogicalSectorNo address)
{
  CardAddress physAddress = logical2Physical(&vol,address);
  if( physAddress == UNASSIGNED_ADDRESS )
    return (void FAR0 *) ULongToPtr(UNASSIGNED_ADDRESS);
  return vol.flash.map(&vol.flash,physAddress,SECTOR_SIZE);
}


/*----------------------------------------------------------------------*/
/*		        a l l o c E n t r y O f f s e t			*/
/*									*/
/* Returns unit offset of given BAM entry				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: BAM entry no.					*/
/*                                                                      */
/* Returns:                                                             */
/*	Offset of BAM entry in unit					*/
/*----------------------------------------------------------------------*/

static int allocEntryOffset(Flare vol, int sectorNo)
{
  return (int) (vol.bamOffset + sizeof(VirtualAddress) * sectorNo);
}


/*----------------------------------------------------------------------*/
/*		         m a p U n i t H e a d e r 			*/
/*									*/
/* Map a unit header and return pointer to it.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: Unit to map header				*/
/*                                                                      */
/* Returns:                                                             */
/*	Pointer to mapped unit header					*/
/*	blockAllocMap	: (optional) Pointer to mapped BAM		*/
/*----------------------------------------------------------------------*/

static UnitHeader FAR0 *mapUnitHeader(Flare vol,
				     const Unit *unit,
				     LEulong FAR0 **blockAllocMap)
{
  UnitHeader FAR0 *unitHeader;

  int length = sizeof(UnitHeader);
  if (blockAllocMap)
    length = allocEntryOffset(&vol,vol.sectorsPerUnit);
  unitHeader = (UnitHeader FAR0 *) vol.flash.map(&vol.flash,physicalBase(&vol,unit),length);
  if (blockAllocMap)
    *blockAllocMap = (LEulong FAR0 *) ((char FAR0 *) unitHeader + allocEntryOffset(&vol,0));

  return unitHeader;
}


#ifndef SINGLE_BUFFER

/*----------------------------------------------------------------------*/
/*		          s e t u p M a p C a c h e			*/
/*									*/
/* Sets up map cache sector to contents of specified Virtual Map page	*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	pageNo		: Page no. to copy to map cache			*/
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setupMapCache(Flare vol, int pageNo)
{
  CardAddress physAddress = logical2Physical(&vol,vol.pageTable[pageNo]);
  if( physAddress == UNASSIGNED_ADDRESS )
    return flGeneralFailure;

  vol.flash.read(&vol.flash,physAddress,mapCache,SECTOR_SIZE,0);
  if ((VirtualSectorNo)pageNo == vol.replacementPageNo) {
    int i;
    LEulong FAR0 *replacementPage;
    void FAR0 *logicalAddr = mapLogical(&vol,vol.replacementPageAddress);

    if( logicalAddr == (void FAR0 *) ULongToPtr(UNASSIGNED_ADDRESS) )
      return flGeneralFailure;
    replacementPage = (LEulong FAR0 *)logicalAddr;

    for (i = 0; i < ADDRESSES_PER_SECTOR; i++) {
      if (LE4(mapCache[i]) == DELETED_ADDRESS)
	toLE4(mapCache[i],LE4(replacementPage[i]));
    }
  }
  buffer.sectorNo = pageNo;
  buffer.owner = &vol;
  return flOK;
}

#endif


/*----------------------------------------------------------------------*/
/*		        v i r t u a l 2 L o g i c a l			*/
/*									*/
/* Translates virtual sector no. to logical sector no.			*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Virtual sector no.				*/
/*                                                                      */
/* Returns:                                                             */
/*	Logical sector no. corresponding to virtual sector no.		*/
/*----------------------------------------------------------------------*/

static LogicalSectorNo virtual2Logical(Flare vol,  VirtualSectorNo sectorNo)
{
  LogicalAddress virtualMapEntry;
  FLStatus status = flOK;

  if (sectorNo < (VirtualSectorNo)vol.directAddressingSectors)
    return vol.pageTable[((unsigned)sectorNo)];
  else {
    int pageNo;
    int sectorInPage;

    sectorNo -= vol.noOfPages;
    pageNo = (int) (sectorNo >> (PAGE_SIZE_BITS - SECTOR_SIZE_BITS));
    sectorInPage = (int) (sectorNo) % ADDRESSES_PER_SECTOR;
    {
#ifdef SINGLE_BUFFER
      LogicalAddress FAR0 *virtualMapPage;

      virtualMapPage = (LogicalAddress FAR0 *) mapLogical(&vol, vol.pageTable[pageNo]);
      if( virtualMapPage == (LogicalAddress FAR0 *) UNASSIGNED_ADDRESS )
        return (LogicalSectorNo) UNASSIGNED_SECTOR;

      if( pageNo == vol.replacementPageNo &&
          virtualMapPage[sectorInPage] == DELETED_ADDRESS ) {
        virtualMapPage = (LogicalAddress FAR0 *) mapLogical(&vol, vol.replacementPageAddress);
        if( virtualMapPage == (LogicalAddress FAR0 *) UNASSIGNED_ADDRESS )
          return (LogicalSectorNo) UNASSIGNED_SECTOR;
      }
      virtualMapEntry = LE4(virtualMapPage[sectorInPage]);
#else
      if( buffer.sectorNo != (SectorNo)pageNo || buffer.owner != &vol )
        status = setupMapCache(&vol,pageNo);
        if( status != flOK )
          return (LogicalSectorNo) UNASSIGNED_SECTOR;
      virtualMapEntry = LE4(mapCache[sectorInPage]);
#endif
      if( (virtualMapEntry >> vol.unitSizeBits) < vol.noOfUnits )
        return (LogicalSectorNo) (virtualMapEntry >> SECTOR_SIZE_BITS);
      else
        return (LogicalSectorNo) UNASSIGNED_SECTOR;
    }
  }
}


/*----------------------------------------------------------------------*/
/*		          v e r i f y F o r m a t 			*/
/*									*/
/* Verify an FTL unit header.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	unitHeader	: Pointer to unit header			*/
/*                                                                      */
/* Returns:                                                             */
/*	TRUE if header is correct. FALSE if not.			*/
/*----------------------------------------------------------------------*/

static FLBoolean verifyFormat(UnitHeader FAR0 *unitHeader)
{
  FORMAT_PATTERN[6] = unitHeader->formatPattern[6];	/* TPL_LINK */
  return tffscmp(unitHeader->formatPattern + 2,
		 FORMAT_PATTERN + 2,
		 sizeof unitHeader->formatPattern - 2) == 0;
}


/*----------------------------------------------------------------------*/
/*		          f o r m a t U n i t				*/
/*									*/
/* Formats a unit by erasing it and writing a unit header.		*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: Unit to format				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus formatUnit(Flare vol,  Unit *unit)
{
  unsigned unitHeaderLength = allocEntryOffset(&vol,vol.unitHeaderSectors);

  unit->noOfFreeSectors = FREE_UNIT;
  unit->noOfGarbageSectors = 0;

#ifdef FL_BACKGROUND
  {
    FLStatus status;

    vol.unitEraseInProgress = unit;
    status = vol.flash.erase(&vol.flash,
			 (int) (physicalBase(&vol,unit) >> vol.erasableBlockSizeBits),
			 1 << (vol.unitSizeBits - vol.erasableBlockSizeBits));
    vol.unitEraseInProgress = NULL;
    if (status != flOK)
      return status;

    /* Note: This suspend to the foreground is not only nice to have, it is
       necessary ! The reason is that we may have a write from the buffer
       waiting for the erase to complete. We are next going to overwrite the
       buffer, so this break enables the write to complete before the data is
       clobbered (what a relief). */
    while (flForeground(1) == BG_SUSPEND)
      ;
  }
#else
  checkStatus(vol.flash.erase(&vol.flash,
			  (word) (physicalBase(&vol,unit) >> vol.erasableBlockSizeBits),
			  (word)(1 << (vol.unitSizeBits - vol.erasableBlockSizeBits))));
#endif

  /* We will copy the unit header as far as the format entries of the BAM
     from another unit (logical unit 0) */
#ifdef SINGLE_BUFFER
  if (buffer.dirty)
    return flBufferingError;
#endif
  buffer.sectorNo = UNASSIGNED_SECTOR;    /* Invalidate map cache so we can
					     use it as a buffer */
  if (vol.logicalUnits[vol.firstPhysicalEUN]) {
    vol.flash.read(&vol.flash,
	       physicalBase(&vol,vol.logicalUnits[vol.firstPhysicalEUN]),
	       uh,
	       unitHeaderLength,
	       0);
  }

  toLE4(uh->wearLevelingInfo,++vol.currWearLevelingInfo);
  toLE2(uh->logicalUnitNo,UNASSIGNED_UNIT_NO);

  checkStatus(vol.flash.write(&vol.flash,
			  physicalBase(&vol,unit),
			  uh,
			  unitHeaderLength,
			  0));

  return flOK;
}


#ifdef FL_BACKGROUND

/*----------------------------------------------------------------------*/
/*		          f l a s h W r i t e				*/
/*									*/
/* Writes to flash through flash.write, but, if possible, allows a	*/
/* background erase to continue while writing.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	Same as flash.write						*/
/*          								*/
/* Returns:                                                             */
/*	Same as flash.write						*/
/*----------------------------------------------------------------------*/

static FLStatus flashWrite(Flare vol,
			 CardAddress address,
			 const void FAR1 *from,
			 int length,
			 FLBoolean overwrite)
{
  if (vol.mirrorOffset != 0 &&
      address >= vol.mirrorFrom && address < vol.mirrorTo) {
    checkStatus(flashWrite(&vol,
			   address + vol.mirrorOffset,
			   from,
			   length,
			   overwrite));
  }

  if (vol.unitEraseInProgress) {
    CardAddress startChip = physicalBase(&vol,vol.unitEraseInProgress) &
				(-vol.flash.interleaving * vol.flash.chipSize);
    CardAddress endChip = startChip + vol.flash.interleaving * vol.flash.chipSize;

    if (address < startChip || address >= endChip) {
      flBackground(BG_RESUME);
      checkStatus(vol.flash.write(&vol.flash,address,from,length,overwrite));
      flBackground(BG_SUSPEND);

      return flOK;
    }
    else if (!(vol.flash.flags & SUSPEND_FOR_WRITE)) {
      do {
	flBackground(BG_RESUME);
      } while (vol.unitEraseInProgress);
    }
  }

  return vol.flash.write(&vol.flash,address,from,length,overwrite);
}

#else

#define flashWrite(v,address,from,length,overwrite)	\
		(v)->flash.write(&(v)->flash,address,from,length,overwrite)

#endif	/* FL_BACKGROUND */


/*----------------------------------------------------------------------*/
/*		           m o u n t U n i t				*/
/*									*/
/* Performs mount scan for a single unit				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: Unit to mount					*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus mountUnit(Flare vol,  Unit *unit)
{
  unsigned i;
  LogicalSectorNo sectorAddress;
  LEulong FAR0 *blockAllocMap;

  UnitHeader FAR0 *unitHeader = mapUnitHeader(&vol,unit,&blockAllocMap);

  UnitNo logicalUnitNo = LE2(unitHeader->logicalUnitNo);

  unit->noOfGarbageSectors = 0;
  unit->noOfFreeSectors = FREE_UNIT;

  if (!verifyFormat(unitHeader) ||
      ((logicalUnitNo != UNASSIGNED_UNIT_NO) &&
       ((logicalUnitNo >= vol.noOfUnits) ||
        (logicalUnitNo < vol.firstPhysicalEUN) ||
        vol.logicalUnits[logicalUnitNo]))) {
    if (vol.transferUnit == NULL)
      vol.transferUnit = unit;
    return flBadFormat;
  }

  if (logicalUnitNo == UNASSIGNED_UNIT_NO) {
    vol.transferUnit = unit;
    return flOK;		/* this is a transfer unit */
  }

  if (LE4(unitHeader->wearLevelingInfo) > vol.currWearLevelingInfo &&
      LE4(unitHeader->wearLevelingInfo) != 0xffffffffl)
    vol.currWearLevelingInfo = LE4(unitHeader->wearLevelingInfo);

  /* count sectors and setup virtual map */
  sectorAddress =
     ((LogicalSectorNo) logicalUnitNo << (vol.unitSizeBits - SECTOR_SIZE_BITS));
  unit->noOfFreeSectors = 0;
  for (i = 0; i < vol.sectorsPerUnit; i++, sectorAddress++) {
    VirtualAddress allocMapEntry = LE4(blockAllocMap[i]);

    if (allocMapEntry == GARBAGE_SECTOR || allocMapEntry == ALLOCATED_SECTOR)
      unit->noOfGarbageSectors++;
    else if (allocMapEntry == FREE_SECTOR) {
      unit->noOfFreeSectors++;
      vol.totalFreeSectors++;
    }
    else if (allocMapEntry < vol.directAddressingMemory) {
      char signature = (char)((short)(allocMapEntry) & SECTOR_OFFSET_MASK);
      if (signature == DATA_SECTOR || signature == REPLACEMENT_PAGE) {
        int pageNo = (int) (allocMapEntry >> SECTOR_SIZE_BITS) + vol.noOfPages;
        if (pageNo >= 0)
          if (signature == DATA_SECTOR)
            vol.pageTable[pageNo] = sectorAddress;
          else {
            vol.replacementPageAddress = sectorAddress;
            vol.replacementPageNo = pageNo;
          }
      }
    }
  }

  /* Place the logical mapping of the unit */
  vol.mappedSectorNo = UNASSIGNED_SECTOR;
  vol.logicalUnits[logicalUnitNo] = unit;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		           a s s i g n U n i t				*/
/*									*/
/* Assigns a logical unit no. to a unit					*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: Unit to assign				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus assignUnit(Flare vol,  Unit *unit, UnitNo logicalUnitNo)
{
  LEushort unitNoToWrite;

  toLE2(unitNoToWrite,logicalUnitNo);

  return flashWrite(&vol,
                (CardAddress)(physicalBase(&vol,unit) + logicalUnitNoOffset),
                &unitNoToWrite,
                sizeof unitNoToWrite,
                OVERWRITE);
}


/*----------------------------------------------------------------------*/
/*		    b e s t U n i t T o T r a n s f e r			*/
/*									*/
/* Find best candidate for unit transfer, usually on the basis of which	*/
/* unit has the most garbage space. A lower wear-leveling info serves	*/
/* as a tie-breaker. If 'leastUsed' is NOT specified, then the least	*/
/* wear-leveling info is the only criterion.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	leastUsed	: Whether most garbage space is the criterion	*/
/*                                                                      */
/* Returns:                                                             */
/*	Best unit to transfer						*/
/*----------------------------------------------------------------------*/

static UnitNo bestUnitToTransfer(Flare vol,  FLBoolean leastUsed)
{
  UnitNo i;

  int mostGarbageSectors = 1;
  unsigned long int leastWearLevelingInfo = 0xffffffffl;
  UnitNo bestUnitSoFar = UNASSIGNED_UNIT_NO;

  for (i = 0; i < vol.noOfUnits; i++) {
    Unit *unit = vol.logicalUnits[i];
    if (unit && (!leastUsed || (unit->noOfGarbageSectors >= mostGarbageSectors))) {
      UnitHeader FAR0 *unitHeader = mapUnitHeader(&vol,unit,NULL);
      if ((leastUsed && (unit->noOfGarbageSectors > mostGarbageSectors)) ||
	  (LE4(unitHeader->wearLevelingInfo) < leastWearLevelingInfo)) {
	mostGarbageSectors = unit->noOfGarbageSectors;
	leastWearLevelingInfo = LE4(unitHeader->wearLevelingInfo);
	bestUnitSoFar = i;
      }
    }
  }

  return bestUnitSoFar;
}


/*----------------------------------------------------------------------*/
/*		           u n i t T r a n s f e r			*/
/*									*/
/* Performs a unit transfer from a selected unit to a tranfer unit.	*/
/*                                                                      */
/* A side effect is to invalidate the map cache (reused as buffer).	*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	toUnit          : Target transfer unit				*/
/*	fromUnitNo:	: Source logical unit no.			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus unitTransfer(Flare vol,  Unit *toUnit, UnitNo fromUnitNo)
{
  unsigned i;
  Unit *fromUnit = vol.logicalUnits[fromUnitNo];

  UnitHeader FAR0 *transferUnitHeader = mapUnitHeader(&vol,toUnit,NULL);
  if (!verifyFormat(transferUnitHeader) ||
      LE2(transferUnitHeader->logicalUnitNo) != UNASSIGNED_UNIT_NO)
    /* previous formatting failed or did not complete. 		*/
    checkStatus(formatUnit(&vol,toUnit));

  /* Should the transfer not complete, the unit is marked to be erased */
  checkStatus(assignUnit(&vol,toUnit,MARKED_FOR_ERASE));

#ifdef FL_BACKGROUND
  vol.mirrorFrom = vol.mirrorTo = physicalBase(&vol,fromUnit);
  vol.mirrorOffset = physicalBase(&vol,toUnit) - vol.mirrorFrom;
#endif

  /* copy the block allocation table and the good sectors */
  for (i = 0; i < vol.sectorsPerUnit;) {
    int j;

    FLBoolean needToWrite = FALSE;
    int firstOffset = allocEntryOffset(&vol,i);

    /* Up to 128 bytes of the BAM are processed per loop */
    int nEntries = (128 - (firstOffset & 127)) / sizeof(VirtualAddress);

    /* We are going to use the Virtual Map cache as our sector buffer in the */
    /* transfer, so let's better invalidate the cache first.		   */
#ifdef SINGLE_BUFFER
    if (buffer.dirty)
      return flBufferingError;
#endif
    buffer.sectorNo = UNASSIGNED_SECTOR;

    /* Read some of the BAM */
    vol.flash.read(&vol.flash,
	       physicalBase(&vol,fromUnit) + firstOffset,
	       sectorCopy,
	       nEntries * sizeof(VirtualAddress),
	       0);

    /* Convert garbage entries to free entries */
    for (j = 0; j < nEntries && i+j < vol.sectorsPerUnit; j++) {
      unsigned bamSignature = (unsigned) LE4(sectorCopy[j]) & SECTOR_OFFSET_MASK;
      if (bamSignature == DATA_SECTOR ||
	  bamSignature == REPLACEMENT_PAGE)
	needToWrite = TRUE;
      else if (bamSignature != FORMAT_SECTOR)
	toLE4(sectorCopy[j],FREE_SECTOR);
    }

    if (needToWrite) {
      FLStatus status;

      /* Write new BAM, and copy sectors that need to be copied */
      status = flashWrite(&vol,
			  physicalBase(&vol,toUnit) + firstOffset,
			  sectorCopy,
			  nEntries * sizeof(VirtualAddress),
			  0);
      if (status != flOK) {
#ifdef FL_BACKGROUND
	vol.mirrorOffset = 0;	/* no more mirroring */
#endif
	return status;
      }

      for (j = 0; j < nEntries && i+j < vol.sectorsPerUnit; j++) {
	unsigned bamSignature = (unsigned) LE4(sectorCopy[j]) & SECTOR_OFFSET_MASK;
	if (bamSignature == DATA_SECTOR ||
	    bamSignature == REPLACEMENT_PAGE) { /* a good sector */
	  CardAddress sectorOffset = (CardAddress) (i+j) << SECTOR_SIZE_BITS;

	  vol.flash.read(&vol.flash,
		     physicalBase(&vol,fromUnit) + sectorOffset,
		     sectorCopy,SECTOR_SIZE,0);
	  status = flashWrite(&vol,
			      physicalBase(&vol,toUnit) + sectorOffset,
			      sectorCopy,
			      SECTOR_SIZE,
			      0);
	  if (status != flOK) {
#ifdef FL_BACKGROUND
	    vol.mirrorOffset = 0;	/* no more mirroring */
#endif
	    return status;
	  }
	  vol.flash.read(&vol.flash,
		     physicalBase(&vol,fromUnit) + firstOffset,
		     sectorCopy,
		     nEntries * sizeof(VirtualAddress),0);
	}
      }

#ifdef FL_BACKGROUND
      vol.mirrorTo = vol.mirrorFrom +
		     ((CardAddress) (i + nEntries) << SECTOR_SIZE_BITS);
      while (flForeground(1) == BG_SUSPEND)
	;
#endif
    }

    i += nEntries;
  }

#ifdef FL_BACKGROUND
  vol.mirrorOffset = 0;	/* no more mirroring */
#endif

  /* Write the new logical unit no. */
  checkStatus(assignUnit(&vol,toUnit,fromUnitNo));

  /* Mount the new unit in place of old one */
  vol.logicalUnits[fromUnitNo] = NULL;
  if (mountUnit(&vol,toUnit) == flOK) {
    vol.totalFreeSectors -= fromUnit->noOfFreeSectors;

    /* Finally, format the source unit (the new transfer unit) */
    vol.transferUnit = fromUnit;
    formatUnit(&vol,fromUnit);	/* nothing we can or should do if this fails */
  }
  else {		/* Something went wrong */
    vol.logicalUnits[fromUnitNo] = fromUnit;	/* reinstate original unit */
    return flGeneralFailure;
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		         g a r b a g e C o l l e c t			*/
/*									*/
/* Performs a unit transfer, selecting a unit to transfer and a		*/
/* transfer unit.                                                       */
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus garbageCollect(Flare vol)
{
  FLStatus status;
  UnitNo fromUnitNo;

  if (vol.transferUnit == NULL)
    return flWriteProtect;	/* Cannot recover space without a spare unit */

  fromUnitNo = bestUnitToTransfer(&vol,flRandByte() >= 4);
  if (fromUnitNo == UNASSIGNED_UNIT_NO)
    return flGeneralFailure;	/* nothing to collect */

  /* Find a unit we can transfer to.				*/
  status = unitTransfer(&vol,vol.transferUnit,fromUnitNo);
  if (status == flWriteFault) {
    int i;
    Unit *unit = vol.physicalUnits;

    for (i = 0; i < vol.noOfUnits; i++, unit++) {
      if (unit->noOfGarbageSectors == 0 && unit->noOfFreeSectors < 0) {
	if (unitTransfer(&vol,unit,fromUnitNo) == flOK)
	  return flOK;	/* found a good one */
      }
    }
  }

  return status;
}


#ifdef FL_BACKGROUND

/*----------------------------------------------------------------------*/
/*		        b g G a r b a g e C o l l e c t			*/
/*									*/
/* Entry point for garbage collection in the background.		*/
/*                                                                      */
/* Status is returned in vol.garbageCollectStatus			*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*          								*/
/* Returns:                                                             */
/*	None								*/
/*----------------------------------------------------------------------*/

static void bgGarbageCollect(void * object)
{
  Flare vol = (Flare *)object;

  vol.garbageCollectStatus = flIncomplete;
  vol.garbageCollectStatus = garbageCollect(&vol);
}

#endif


/*----------------------------------------------------------------------*/
/*      	            d e f r a g m e n t				*/
/*									*/
/* Performs unit transfers to arrange a minimum number of writable	*/
/* sectors.                                                             */
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorsNeeded	: Minimum required sectors			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

#define GARBAGE_COLLECT_THRESHOLD	20

static FLStatus defragment(Flare vol, long FAR2 *sectorsNeeded)
{
  while ((long)(vol.totalFreeSectors) < *sectorsNeeded
#ifdef FL_BACKGROUND
	 || vol.totalFreeSectors < GARBAGE_COLLECT_THRESHOLD
#endif
	 ) {
    if (vol.badFormat)
      return flBadFormat;

#ifdef FL_BACKGROUND
    if (vol.garbageCollectStatus == flIncomplete)
      flBackground(BG_RESUME);
    else
      flStartBackground(&vol - vols,bgGarbageCollect,&vol);
    if (vol.garbageCollectStatus != flOK &&
	vol.garbageCollectStatus != flIncomplete)
      return vol.garbageCollectStatus;

    if (vol.totalFreeSectors >= *sectorsNeeded)
      break;
  }

  if (vol.unitEraseInProgress)
    flBackground(BG_SUSPEND);
#else
    checkStatus(garbageCollect(&vol));
  }
#endif

  *sectorsNeeded = vol.totalFreeSectors;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		    b e s t U n i t T o A l l o c a t e			*/
/*									*/
/* Finds the best unit from which to allocate a sector. The unit	*/
/* selected is the one with most free space.				*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	Best unit to allocate						*/
/*----------------------------------------------------------------------*/

static Unit *bestUnitToAllocate(Flare vol)
{
  int i;

  int mostFreeSectors = 0;
  Unit *bestUnitSoFar = NULL;

  for (i = 0; i < vol.noOfUnits; i++) {
    Unit *unit = vol.logicalUnits[i];

    if (unit && unit->noOfFreeSectors > mostFreeSectors) {
      mostFreeSectors = unit->noOfFreeSectors;
      bestUnitSoFar = unit;
    }
  }

  return bestUnitSoFar;
}


/*----------------------------------------------------------------------*/
/*		       f i n d F r e e S e c t o r			*/
/*									*/
/* The allocation strategy goes this way:                               */
/*                                                                      */
/* We try to make consecutive virtual sectors physically consecutive if */
/* possible. If not, we prefer to have consecutive sectors on the same  */
/* unit at least. If all else fails, a sector is allocated on the unit  */
/* with most space available.                                           */
/*                                                                      */
/* The object of this strategy is to cluster related data (e.g. a file  */
/* data) in one unit, and to distribute unrelated data evenly among all */
/* units.								*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo        : virtual sector no. that we want to allocate.	*/
/*									*/
/* Returns:                                                             */
/*	newAddress	: Allocated logical sector no.			*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus findFreeSector(Flare vol,
			     VirtualSectorNo sectorNo,
			     LogicalSectorNo *newAddress)
{
  unsigned iSector;
  LEulong FAR0 *blockAllocMap;
  UnitHeader FAR0 *unitHeader;

  Unit *allocationUnit = NULL;

  LogicalSectorNo previousSectorAddress =
	 (sectorNo > 0 ? virtual2Logical(&vol,(VirtualSectorNo)(sectorNo - 1)) : UNASSIGNED_SECTOR);
  if( ((previousSectorAddress != UNASSIGNED_SECTOR) &&
      (previousSectorAddress != DELETED_SECTOR))    &&
      ((previousSectorAddress >> (vol.unitSizeBits - SECTOR_SIZE_BITS)) < vol.noOfUnits) ) {
    allocationUnit =
	vol.logicalUnits[(UnitNo)(previousSectorAddress >> (vol.unitSizeBits - SECTOR_SIZE_BITS))];
    if (allocationUnit->noOfFreeSectors > 0) {
      unsigned int sectorIndex = ((unsigned) previousSectorAddress & (vol.sectorsPerUnit - 1)) + 1;
      LEulong FAR0 *nextSectorAddress =
	   (LEulong FAR0 *) vol.flash.map(&vol.flash,
                                     physicalBase(&vol,allocationUnit) +
                                     allocEntryOffset(&vol, sectorIndex),
                                     sizeof(VirtualAddress));
      if (sectorIndex < vol.sectorsPerUnit && LE4(*nextSectorAddress) == FREE_SECTOR) {
	/* can write sequentially */
	*newAddress = previousSectorAddress + 1;
	return flOK;
      }
    }
    else
      allocationUnit = NULL;	/* no space here, try elsewhere */
  }

  if (allocationUnit == NULL)
    allocationUnit = bestUnitToAllocate(&vol);
  if (allocationUnit == NULL)	/* No ? then all is lost */
    return flGeneralFailure;

  unitHeader = mapUnitHeader(&vol,allocationUnit,&blockAllocMap);
  for (iSector = vol.unitHeaderSectors; iSector < vol.sectorsPerUnit; iSector++) {
    if (LE4(blockAllocMap[iSector]) == FREE_SECTOR) {
      *newAddress = ((LogicalSectorNo) (LE2(unitHeader->logicalUnitNo)) << (vol.unitSizeBits - SECTOR_SIZE_BITS)) +
		    iSector;
      return flOK;
    }
  }

  return flGeneralFailure;	/* what are we doing here ? */
}


/*----------------------------------------------------------------------*/
/*		           m a r k A l l o c M a p			*/
/*									*/
/* Writes a new value to a BAM entry.					*/
/*                                                                      */
/* This routine also updates the free & garbage sector counts.		*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorAddress	: Logical sector no. whose BAM entry to mark	*/
/*	allocMapEntry	: New BAM entry value				*/
/*	overwrite	: Whether we are overwriting some old value	*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus markAllocMap(Flare vol,
			   LogicalSectorNo sectorAddress,
			   VirtualAddress allocMapEntry,
			   FLBoolean overwrite)
{
  UnitNo unitNo = (UnitNo) (sectorAddress >> (vol.unitSizeBits - SECTOR_SIZE_BITS));
  Unit *unit;
  int sectorInUnit = (unsigned) sectorAddress & (vol.sectorsPerUnit - 1);
  LEulong bamEntry;

  if (unitNo >= vol.noOfUnits - vol.noOfTransferUnits)
    return flGeneralFailure;

  unit = vol.logicalUnits[unitNo];

  if (allocMapEntry == GARBAGE_SECTOR)
    unit->noOfGarbageSectors++;
  else if (!overwrite) {
    unit->noOfFreeSectors--;
    vol.totalFreeSectors--;
  }

  toLE4(bamEntry,allocMapEntry);

  return flashWrite(&vol,
		    physicalBase(&vol,unit) + allocEntryOffset(&vol,sectorInUnit),
		    &bamEntry,
		    sizeof bamEntry,
		    (word)overwrite);
}


/*----------------------------------------------------------------------*/
/*      	      d e l e t e L o g i c a l S e c t o r		*/
/*									*/
/* Marks a logical sector as deleted.					*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorAddress	: Logical sector no. to delete			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus deleteLogicalSector(Flare vol,  LogicalSectorNo sectorAddress)
{
  if (sectorAddress == UNASSIGNED_SECTOR ||
      sectorAddress == DELETED_SECTOR)
    return flOK;

  return markAllocMap(&vol,sectorAddress,GARBAGE_SECTOR,TRUE);
}


/* forward definition */
static FLStatus setVirtualMap(Flare vol,
			    VirtualSectorNo sectorNo,
			    LogicalSectorNo newAddress);


/*----------------------------------------------------------------------*/
/*      	     a l l o c a t e A n d W r i t e S e c t o r	*/
/*									*/
/* Allocates a sector or replacement page and (optionally) writes it.	*/
/*                                                                      */
/* An allocated replacement page also becomes the active replacement 	*/
/* page.								*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Virtual sector no. to write			*/
/*	fromAddress	: Address of sector data. If NULL, sector is	*/
/*			  not written.					*/
/*	replacementPage	: This is a replacement page sector.		*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus allocateAndWriteSector(Flare vol,
				     VirtualSectorNo sectorNo,
				     void FAR1 *fromAddress,
				     FLBoolean replacementPage)
{
  FLStatus status;
  LogicalSectorNo sectorAddress;
  VirtualAddress bamEntry =
	((VirtualAddress) sectorNo - vol.noOfPages) << SECTOR_SIZE_BITS;
  long sectorsNeeded = 1;

  checkStatus(defragment(&vol,&sectorsNeeded));  /* Organize a free sector */

  checkStatus(findFreeSector(&vol,sectorNo,&sectorAddress));

  if (replacementPage)
    bamEntry |= REPLACEMENT_PAGE;
  else
    bamEntry |= DATA_SECTOR;

  status = markAllocMap(&vol,
			sectorAddress,
			sectorNo < (VirtualSectorNo)vol.directAddressingSectors ?
			  ALLOCATED_SECTOR : bamEntry,
			FALSE);

  if( status == flOK && fromAddress) {
    CardAddress physAddress = logical2Physical(&vol,sectorAddress);
    if( physAddress == UNASSIGNED_ADDRESS )
      return flGeneralFailure;

    status = flashWrite(&vol,
                        physAddress,
			fromAddress,
			SECTOR_SIZE,
			0);
  }

  if (sectorNo < (VirtualSectorNo)vol.directAddressingSectors && status == flOK)
    status = markAllocMap(&vol,
			  sectorAddress,
			  bamEntry,
			  TRUE);

  if (status == flOK)
    if (replacementPage) {
      vol.replacementPageAddress = sectorAddress;
      vol.replacementPageNo = sectorNo;
    }
    else
      status = setVirtualMap(&vol,sectorNo,sectorAddress);

  if (status != flOK)
    markAllocMap(&vol,sectorAddress,GARBAGE_SECTOR,TRUE);

  return status;
}


/*----------------------------------------------------------------------*/
/*      	     c l o s e R e p l a c e m e n t P a g e		*/
/*									*/
/* Closes the replacement page by merging it with the primary page.	*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus closeReplacementPage(Flare vol)
{
  FLStatus status;
  CardAddress physAddress;

#ifdef SINGLE_BUFFER
  int i;
  LogicalSectorNo nextReplacementPageAddress = vol.replacementPageAddress;
  VirtualSectorNo firstSectorNo =
	((VirtualSectorNo) vol.replacementPageNo << (PAGE_SIZE_BITS - SECTOR_SIZE_BITS)) +
    vol.noOfPages;
pageRetry:
  for (i = 0; i < ADDRESSES_PER_SECTOR; i++) {
    LogicalSectorNo logicalSectorNo = virtual2Logical(&vol,firstSectorNo + i);
    LEulong entryToWrite;
    toLE4(entryToWrite,logicalSectorNo == UNASSIGNED_SECTOR ?
		       UNASSIGNED_ADDRESS :
		       (LogicalAddress) logicalSectorNo << SECTOR_SIZE_BITS);
    physAddress = logical2Physical(&vol,nextReplacementPageAddress);
    if( physAddress == UNASSIGNED_ADDRESS )
      return flGeneralFailure;

    if (flashWrite(&vol,
                   physAddress + i * sizeof(LogicalAddress),
		   &entryToWrite,
		   sizeof entryToWrite,
		   OVERWRITE) != flOK)
      break;
  }

  if (i < ADDRESSES_PER_SECTOR &&
      nextReplacementPageAddress == vol.replacementPageAddress) {
    /* Uh oh. Trouble. Let's replace this replacement page. */
    LogicalSectorNo prevReplacementPageAddress = vol.replacementPageAddress;

    checkStatus(allocateAndWriteSector(&vol,vol.replacementPageNo,NULL,TRUE));
    nextReplacementPageAddress = vol.replacementPageAddress;
    vol.replacementPageAddress = prevReplacementPageAddress;
    goto pageRetry;
  }

  if (nextReplacementPageAddress != vol.replacementPageAddress) {
    LogicalSectorNo prevReplacementPageAddress = vol.replacementPageAddress;
    vol.replacementPageAddress = nextReplacementPageAddress;
    checkStatus(deleteLogicalSector(&vol,prevReplacementPageAddress));
  }
#else
  status = setupMapCache(&vol,(unsigned)vol.replacementPageNo);  /* read replacement page into map cache */
  if( status != flOK )
    return flGeneralFailure;
  physAddress = logical2Physical(&vol,vol.replacementPageAddress);
  if( physAddress == UNASSIGNED_ADDRESS )
    return flGeneralFailure;

  status = flashWrite(&vol,
                      physAddress,
                      mapCache, SECTOR_SIZE, OVERWRITE);
  if (status != flOK) {
    /* Uh oh. Trouble. Let's replace this replacement page. */
    LogicalSectorNo prevReplacementPageAddress = vol.replacementPageAddress;

    checkStatus(allocateAndWriteSector(&vol,vol.replacementPageNo,mapCache,TRUE));
    checkStatus(deleteLogicalSector(&vol,prevReplacementPageAddress));
  }
#endif
  checkStatus(setVirtualMap(&vol,vol.replacementPageNo,vol.replacementPageAddress));
  checkStatus(markAllocMap(&vol,
			   vol.replacementPageAddress,
			   (((VirtualAddress) vol.replacementPageNo - vol.noOfPages)
				<< SECTOR_SIZE_BITS) | DATA_SECTOR,
			   TRUE));

  vol.replacementPageNo = UNASSIGNED_SECTOR;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	          s e t V i r t u a l M a p			*/
/*									*/
/* Changes an entry in the virtual map					*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Virtual sector no. whose entry is changed.	*/
/*	newAddress	: Logical sector no. to assign in Virtual Map.	*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus setVirtualMap(Flare vol,
			    VirtualSectorNo sectorNo,
			    LogicalSectorNo newAddress)
{
  unsigned pageNo;
  int sectorInPage;
  CardAddress virtualMapEntryAddress;
  LEulong addressToWrite;
  LogicalAddress oldAddress;
  LogicalSectorNo updatedPage;
  CardAddress physAddress;

  vol.mappedSectorNo = UNASSIGNED_SECTOR;

  if (sectorNo < (VirtualSectorNo)vol.directAddressingSectors) {
    checkStatus(deleteLogicalSector(&vol,vol.pageTable[(unsigned)sectorNo]));
    vol.pageTable[(unsigned)sectorNo] = newAddress;
    return flOK;
  }
  sectorNo -= vol.noOfPages;

  pageNo = (unsigned)(sectorNo >> (PAGE_SIZE_BITS - SECTOR_SIZE_BITS));
  sectorInPage = (int) (sectorNo % ADDRESSES_PER_SECTOR);
  updatedPage = vol.pageTable[pageNo];
  physAddress = logical2Physical(&vol,updatedPage);
  if( physAddress == UNASSIGNED_ADDRESS )
    return flGeneralFailure;
  virtualMapEntryAddress = physAddress +
                         sectorInPage * sizeof(LogicalAddress);
  oldAddress = LE4(*(LEulong FAR0 *)
	vol.flash.map(&vol.flash,virtualMapEntryAddress,sizeof(LogicalAddress)));

  if (oldAddress == DELETED_ADDRESS && vol.replacementPageNo == pageNo) {
    updatedPage = vol.replacementPageAddress;
    physAddress = logical2Physical(&vol,updatedPage);
    if( physAddress == UNASSIGNED_ADDRESS )
      return flGeneralFailure;
    virtualMapEntryAddress = physAddress +
                         sectorInPage * sizeof(LogicalAddress);
    oldAddress = LE4(*(LEulong FAR0 *)
	  vol.flash.map(&vol.flash,virtualMapEntryAddress,sizeof(LogicalAddress)));
  }

  if (newAddress == DELETED_ADDRESS && oldAddress == UNASSIGNED_ADDRESS)
    return flOK;

  toLE4(addressToWrite,(LogicalAddress) newAddress << SECTOR_SIZE_BITS);
  if (cannotWriteOver(LE4(addressToWrite),oldAddress)) {
    FLStatus status;

    if (pageNo != vol.replacementPageNo ||
        updatedPage == vol.replacementPageAddress) {
      if (vol.replacementPageNo != UNASSIGNED_SECTOR)
        checkStatus(closeReplacementPage(&vol));
      checkStatus(allocateAndWriteSector(&vol,(VirtualSectorNo)pageNo,NULL,TRUE));
    }

    physAddress = logical2Physical(&vol,vol.replacementPageAddress);
    if( physAddress == UNASSIGNED_ADDRESS )
      return flGeneralFailure;

    status = flashWrite(&vol,
                        physAddress + sectorInPage * sizeof(LogicalAddress),
			&addressToWrite,
			sizeof addressToWrite,
			0);
    if (status != flOK) {
      closeReplacementPage(&vol);
				/* we may get a write-error because a
				   previous cache update did not complete. */
      return status;
    }
    toLE4(addressToWrite,DELETED_ADDRESS);
    updatedPage = vol.pageTable[pageNo];
  }

  physAddress = logical2Physical(&vol,updatedPage);
  if( physAddress == UNASSIGNED_ADDRESS )
    return flGeneralFailure;
  checkStatus( flashWrite(&vol,
                         physAddress + sectorInPage * sizeof(LogicalAddress),
			 &addressToWrite,
			 (dword)sizeof addressToWrite,
			 (word)oldAddress |= UNASSIGNED_ADDRESS));

#ifndef SINGLE_BUFFER
  if (buffer.sectorNo == pageNo && buffer.owner == &vol)
    toLE4(mapCache[sectorInPage],(LogicalAddress) newAddress << SECTOR_SIZE_BITS);
#endif

  return deleteLogicalSector(&vol,(LogicalSectorNo) (oldAddress >> SECTOR_SIZE_BITS));
}


/*----------------------------------------------------------------------*/
/*      	     c h e c k F o r W r i t e I n p l a c e		*/
/*									*/
/* Checks possibility for writing Flash data inplace.			*/
/*									*/
/* Parameters:                                                          */
/*	newData		: New data to write.				*/
/*	oldData		: Old data at this location.			*/
/*                                                                      */
/* Returns:                                                             */
/*	< 0	=>	Writing inplace not possible			*/
/*	>= 0	=>	Writing inplace is possible. Value indicates    */
/*			how many bytes at the start of data are		*/
/*			identical and may be skipped.			*/
/*----------------------------------------------------------------------*/

static int checkForWriteInplace(long FAR1 *newData,
				long FAR0 *oldData)
{
  int i;

  int skipBytes = 0;
  FLBoolean stillSame = TRUE;

  for (i = SECTOR_SIZE / sizeof *newData; i > 0; i--, newData++, oldData++) {
    if (cannotWriteOver(*newData,*oldData))
      return -1;
    if (stillSame && *newData == *oldData)
      skipBytes += sizeof *newData;
    else
      stillSame = FALSE;
  }

  return skipBytes;
}


/*----------------------------------------------------------------------*/
/*      	              i n i t F T L				*/
/*									*/
/* Initializes essential volume data as a preparation for mount or	*/
/* format.								*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	flash		: Flash media mounted on this socket		*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus initFTL(Flare vol, FLFlash *flash)
{
  long int size = 1;

  if (flash == NULL) {
    DEBUG_PRINT(("Debug: media is not fit for FTL format.\n"));
    return flUnknownMedia;
  }

  vol.flash = *flash;
  for (vol.erasableBlockSizeBits = 0; ((unsigned int)size )< vol.flash.erasableBlockSize;
       vol.erasableBlockSizeBits++, size <<= 1);
  vol.unitSizeBits = vol.erasableBlockSizeBits;
  if (vol.unitSizeBits < 16)
    vol.unitSizeBits = 16;		/* At least 64 KB */
  vol.noOfUnits = (unsigned) ((vol.flash.noOfChips * vol.flash.chipSize) >> vol.unitSizeBits);
  vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
  vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  vol.bamOffset = sizeof(UnitHeader);
  vol.unitHeaderSectors = ((allocEntryOffset(&vol,vol.sectorsPerUnit) - 1) >>
				    SECTOR_SIZE_BITS) + 1;

  vol.transferUnit = NULL;
  vol.replacementPageNo = UNASSIGNED_SECTOR;
  vol.badFormat = TRUE;	/* until mount completes */
  vol.mappedSectorNo = UNASSIGNED_SECTOR;

  vol.currWearLevelingInfo = 0;

#ifdef FL_BACKGROUND
  vol.unitEraseInProgress = NULL;
  vol.garbageCollectStatus = flOK;
  vol.mirrorOffset = 0;
#endif

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	            i n i t T a b l e s				*/
/*									*/
/* Allocates and initializes the dynamic volume table, including the	*/
/* unit tables and secondary virtual map.				*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus initTables(Flare vol)
{
  unsigned iSector;
  UnitNo iUnit;

  /* Allocate the conversion tables */
#ifdef MALLOC
  vol.physicalUnits = (Unit *) MALLOC(vol.noOfUnits * sizeof(Unit));
  vol.logicalUnits = (UnitPtr *) MALLOC(vol.noOfUnits * sizeof(UnitPtr));
  vol.pageTable = (LogicalSectorNo *)
	     MALLOC(vol.directAddressingSectors * sizeof(LogicalSectorNo));
  if (vol.physicalUnits == NULL ||
      vol.logicalUnits == NULL ||
      vol.pageTable == NULL) {
    dismountFTL(&vol);
    return flNotEnoughMemory;
  }
#else
  char *heapPtr;

  heapPtr = vol.heap;
  vol.physicalUnits = (Unit *) heapPtr;
  heapPtr += vol.noOfUnits * sizeof(Unit);
  vol.logicalUnits = (UnitPtr *) heapPtr;
  heapPtr += vol.noOfUnits * sizeof(UnitPtr);
  vol.pageTable = (LogicalSectorNo *) heapPtr;
  heapPtr += vol.directAddressingSectors * sizeof(LogicalSectorNo);
  if (heapPtr > vol.heap + sizeof vol.heap)
    return flNotEnoughMemory;
#endif

#ifndef SINGLE_BUFFER
  vol.volBuffer = flBufferOf(flSocketNoOf(vol.flash.socket));
#endif

  buffer.sectorNo = UNASSIGNED_SECTOR;

  for (iSector = 0; iSector < vol.directAddressingSectors; iSector++)
    vol.pageTable[iSector] = UNASSIGNED_SECTOR;

  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
    vol.logicalUnits[iUnit] = NULL;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	             m a p S e c t o r				*/
/*									*/
/* Maps and returns location of a given sector no.			*/
/* NOTE: This function is used in place of a read-sector operation.	*/
/*									*/
/* A one-sector cache is maintained to save on map operations.		*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Sector no. to read				*/
/*	physAddress	: Optional pointer to receive sector address	*/
/*                                                                      */
/* Returns:                                                             */
/*	Pointer to physical sector location. NULL returned if sector	*/
/*	does not exist.							*/
/*----------------------------------------------------------------------*/

static const void FAR0 *mapSector(Flare vol, SectorNo sectorNo, CardAddress *physAddress)
{
  if (sectorNo != vol.mappedSectorNo || vol.flash.socket->remapped) {
    LogicalSectorNo sectorAddress;

    if (sectorNo >= vol.virtualSectors)
      vol.mappedSector = NULL;
    else {
      sectorAddress = virtual2Logical(&vol,((VirtualSectorNo)(sectorNo + vol.noOfPages)));

      if (sectorAddress == UNASSIGNED_SECTOR || sectorAddress == DELETED_SECTOR)
        vol.mappedSector = NULL;          /* no such sector */
      else {
	vol.mappedSectorAddress = logical2Physical(&vol,sectorAddress);
        if( vol.mappedSectorAddress == UNASSIGNED_ADDRESS )
          vol.mappedSector = NULL;        /* no such sector */
        else
          vol.mappedSector = vol.flash.map(&vol.flash,
					 vol.mappedSectorAddress,
					 SECTOR_SIZE);
      }
    }
    vol.mappedSectorNo = sectorNo;
    vol.flash.socket->remapped = FALSE;
  }

  if (physAddress)
    *physAddress = vol.mappedSectorAddress;

  return vol.mappedSector;
}


/*----------------------------------------------------------------------*/
/*      	          w r i t e S e c t o r				*/
/*									*/
/* Writes a sector.							*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Sector no. to write				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus writeSector(Flare vol,  SectorNo sectorNo, void FAR1 *fromAddress)
{
  LogicalSectorNo oldSectorAddress;
  int skipBytes;
  FLStatus status;
  void FAR0 *logicalAddr;

  if (vol.badFormat)
    return flBadFormat;
  if (sectorNo >= vol.virtualSectors)
    return flSectorNotFound;

  sectorNo += vol.noOfPages;
  oldSectorAddress = virtual2Logical(&vol,sectorNo);

  if( oldSectorAddress != UNASSIGNED_SECTOR && oldSectorAddress != DELETED_SECTOR ) {
    logicalAddr = mapLogical(&vol,oldSectorAddress);
    if( logicalAddr == (void FAR0 *) ULongToPtr(UNASSIGNED_ADDRESS) )
      return flGeneralFailure;
  }

  if( ((oldSectorAddress != UNASSIGNED_SECTOR) &&
       (oldSectorAddress != DELETED_SECTOR)) &&
       ((skipBytes = checkForWriteInplace((long FAR1 *) fromAddress,
           (long FAR0 *) logicalAddr)) >= 0) ) {
    if( skipBytes < SECTOR_SIZE ) {
      CardAddress physAddress = logical2Physical(&vol,oldSectorAddress);
      if( physAddress == UNASSIGNED_ADDRESS )
        return flGeneralFailure;

      status = flashWrite(&vol,
                          physAddress + skipBytes,
			  (char FAR1 *) fromAddress + skipBytes,
			  SECTOR_SIZE - skipBytes,
			  OVERWRITE);
    }
    else
      status = flOK;		/* nothing to write */
  }
  else
    status = allocateAndWriteSector(&vol,sectorNo,fromAddress,FALSE);

  if (status == flWriteFault)		/* Automatic retry */
    status = allocateAndWriteSector(&vol,sectorNo,fromAddress,FALSE);

  return status;
}


/*----------------------------------------------------------------------*/
/*      	          t l S e t B u s y				*/
/*									*/
/* Notifies the start and end of a file-system operation.		*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*      state		: ON (1) = operation entry			*/
/*			  OFF(0) = operation exit			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus tlSetBusy(Flare vol, FLBoolean state)
{
#ifdef FL_BACKGROUND
  if (vol.unitEraseInProgress)
    flBackground(state == ON ? BG_SUSPEND : BG_RESUME);
#endif

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	         d e l e t e S e c t o r			*/
/*									*/
/* Marks contiguous sectors as deleted					*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: First sector no. to delete			*/
/*	noOfSectors	: No. of sectors to delete			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus deleteSector(Flare vol,  SectorNo sectorNo, SectorNo noOfSectors)
{
  SectorNo iSector;

  if (vol.badFormat)
    return flBadFormat;
  if (sectorNo + noOfSectors > vol.virtualSectors)
    return flSectorNotFound;

  sectorNo += vol.noOfPages;
  for (iSector = 0; iSector < noOfSectors; iSector++, sectorNo++)
    checkStatus(setVirtualMap(&vol,sectorNo,DELETED_SECTOR));

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	        s e c t o r s I n V o l u m e			*/
/*									*/
/* Gets the total number of sectors in the volume			*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	Number of sectors in the volume					*/
/*----------------------------------------------------------------------*/

static SectorNo sectorsInVolume(Flare vol)
{
  return vol.virtualSectors;
}


/*----------------------------------------------------------------------*/
/*      	         d i s m o u n t F T L				*/
/*									*/
/* Dismount FTL volume							*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*									*/
/*----------------------------------------------------------------------*/

static void dismountFTL(Flare vol)
{
#ifdef MALLOC
  if( vol.physicalUnits != NULL )
    FREE(vol.physicalUnits);
  if( vol.logicalUnits != NULL )
    FREE(vol.logicalUnits);
  if( vol.pageTable != NULL )
    FREE(vol.pageTable);
  vol.physicalUnits = NULL;
  vol.logicalUnits = NULL;
  vol.pageTable = NULL;
#ifdef NT5PORT
  if( vol.flash.readBuffer != NULL ) {
    FREE(vol.flash.readBuffer);
    vol.flash.readBuffer = NULL;
  }
#endif /* NT5PORT */
#endif /* MALLOC */
}


#ifdef FORMAT_VOLUME
/*----------------------------------------------------------------------*/
/*      	           f o r m a t F T L				*/
/*									*/
/* Formats the Flash volume for FTL					*/
/*									*/
/* Parameters:                                                          */
/*	volNo		: Volume no.					*/
/*	formatParams	: Address of FormatParams structure to use	*/
/*	flash		: Flash media mounted on this socket		*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus formatFTL(unsigned volNo, TLFormatParams FAR1 *formatParams, FLFlash *flash)
{
  Flare vol = &vols[volNo];
  UnitNo iUnit;
  int iPage;
  unsigned iSector, noOfBadUnits = 0;
  LEulong *formatEntries;
  FLStatus status;


	DEBUG_PRINT(("Debug: formatFTL(): Start ... .\n"));
  checkStatus(initFTL(&vol,flash));

  if(formatParams->bootImageLen<0)
    formatParams->bootImageLen = 0;
  vol.firstPhysicalEUN =
      (UnitNo) ((formatParams->bootImageLen - 1) >> vol.unitSizeBits) + 1;
  vol.noOfTransferUnits = (UnitNo)formatParams->noOfSpareUnits;
  if (vol.noOfUnits <= vol.firstPhysicalEUN + formatParams->noOfSpareUnits)
    return flVolumeTooSmall;

  vol.virtualSectors = (SectorNo)((unsigned long) (vol.noOfUnits - vol.firstPhysicalEUN - formatParams->noOfSpareUnits) *
		   (vol.sectorsPerUnit - vol.unitHeaderSectors) *
		   formatParams->percentUse / 100);
  vol.noOfPages = (int)(((long) vol.virtualSectors * SECTOR_SIZE - 1) >> PAGE_SIZE_BITS) + 1;
  /* take off size of virtual table, and one extra sector for sector writes */
  vol.virtualSectors -= (vol.noOfPages + 1);

  vol.directAddressingMemory = formatParams->vmAddressingLimit;
  vol.directAddressingSectors = (unsigned) (formatParams->vmAddressingLimit / SECTOR_SIZE) +
				vol.noOfPages;

  checkStatus(initTables(&vol));

  tffsset(uh,0xff,SECTOR_SIZE);
  toLE2(uh->noOfUnits,vol.noOfUnits - vol.firstPhysicalEUN);
  toLE2(uh->firstPhysicalEUN,vol.firstPhysicalEUN);
  uh->noOfTransferUnits = (unsigned char) vol.noOfTransferUnits;
  tffscpy(uh->formatPattern,FORMAT_PATTERN,sizeof uh->formatPattern);
  uh->log2SectorSize = SECTOR_SIZE_BITS;
  uh->log2UnitSize = (unsigned char)vol.unitSizeBits;
  toLE4(uh->directAddressingMemory,vol.directAddressingMemory);
  uh->flags = 0;
  uh->eccCode = 0xff;
  toLE4(uh->serialNumber,0);
  toLE4(uh->altEUHoffset,0);
  toLE4(uh->virtualMediumSize,(long)vol.virtualSectors * SECTOR_SIZE);
  toLE2(uh->noOfPages,(unsigned short)vol.noOfPages);

  if (formatParams->embeddedCISlength > 0) {
    tffscpy(uh->embeddedCIS,formatParams->embeddedCIS,formatParams->embeddedCISlength);
    vol.bamOffset = sizeof(UnitHeader) - sizeof uh->embeddedCIS +
		    (formatParams->embeddedCISlength + 3) / 4 * 4;
  }
  toLE4(uh->BAMoffset,vol.bamOffset);

  formatEntries = (LEulong *) ((char *) uh + allocEntryOffset(&vol,0));
  for (iSector = 0; iSector < vol.unitHeaderSectors; iSector++)
    toLE4(formatEntries[iSector], FORMAT_SECTOR);

  for (iUnit = vol.firstPhysicalEUN; iUnit < vol.noOfUnits; iUnit++) {
    status = formatUnit(&vol,&vol.physicalUnits[iUnit]);
    if (status != flOK)
      status = formatUnit(&vol,&vol.physicalUnits[iUnit]);	/* Do it again */
    if (status == flWriteFault) {
      noOfBadUnits++;
      if (noOfBadUnits >= formatParams->noOfSpareUnits) {
        dismountFTL(&vol);  /*Free memory allocated in initTables*/
        return status;
      }
      else
        vol.transferUnit = &vol.physicalUnits[iUnit];
    }
    else if (status == flOK) {
      if (iUnit - noOfBadUnits < (unsigned)(vol.noOfUnits - formatParams->noOfSpareUnits)) {
        status = assignUnit(&vol,
                     &vol.physicalUnits[iUnit],
                     (UnitNo)(iUnit - noOfBadUnits));
        if( status != flOK ) {
          dismountFTL(&vol);  /*Free memory allocated in initTables*/
          return status;
        }
        vol.physicalUnits[iUnit].noOfFreeSectors = vol.sectorsPerUnit - vol.unitHeaderSectors;
        vol.logicalUnits[iUnit - noOfBadUnits] = &vol.physicalUnits[iUnit];
      }
      else
        vol.transferUnit = &vol.physicalUnits[iUnit];
    }
    else {
      dismountFTL(&vol);  /*Free memory allocated in initTables*/
      return status;
    }
    if (formatParams->progressCallback) {
      status = (*formatParams->progressCallback)
                  ((word)(vol.noOfUnits - vol.firstPhysicalEUN),
                  (word)((iUnit + 1) - vol.firstPhysicalEUN));
      if( status != flOK ) {
        dismountFTL(&vol);  /*Free memory allocated in initTables*/
        return status;
      }
    }
  }

  /* Allocate and write all page sectors */
  vol.totalFreeSectors = 1000;	/* Avoid any nuisance garbage collections */

  for (iPage = 0; iPage < vol.noOfPages; iPage++) {
    status = allocateAndWriteSector(&vol,(VirtualSectorNo)iPage,NULL,FALSE);
    if( status != flOK ) {
      dismountFTL(&vol);  /*Free memory allocated in initTables*/
      return status;
    }
  }
  dismountFTL(&vol);  /*Free memory allocated in initTables*/
	DEBUG_PRINT(("Debug: formatFTL(): Finished :)\n"));
  return flOK;
}

#endif


/*----------------------------------------------------------------------*/
/*      	           m o u n t F T L				*/
/*									*/
/* Mount FTL volume							*/
/*									*/
/* Parameters:                                                          */
/*	volNo		: Volume no.					*/
/*	tl		: Where to store translation layer methods	*/
/*	flash		: Flash media mounted on this socket		*/
/*      volForCallback	: Pointer to FLFlash structure for power on	*/
/*			  callback routine.				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus mountFTL(unsigned volNo, TL *tl, FLFlash *flash, FLFlash **volForCallback)
{
  Flare vol = &vols[volNo];
  UnitHeader unitHeader;
  UnitNo iUnit;
  int iPage;


  DEBUG_PRINT(("Debug: mountFTL(): Start ...\n"));
  tffsset(&unitHeader,0,sizeof(UnitHeader));

  checkStatus(initFTL(&vol,flash));
  *volForCallback = &vol.flash;

  /* Find the first properly formatted unit */
  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
    vol.flash.read(&vol.flash,
	       (CardAddress) iUnit << vol.unitSizeBits,
	       &unitHeader,
	       sizeof(UnitHeader),
	       0);
    if (verifyFormat(&unitHeader)) {
      if (unitHeader.flags || unitHeader.log2SectorSize != SECTOR_SIZE_BITS ||
          (unitHeader.eccCode != 0xff && unitHeader.eccCode != 0)) {
        dismountFTL(&vol);
	return flBadFormat;
      }
      break;
    }
  }
  if (iUnit >= vol.noOfUnits) {
    dismountFTL(&vol);
		DEBUG_PRINT(("Debug: mountFTL(): failed for unit Header\n"));
    return flUnknownMedia;
  }

  

  /* Get volume information from unit header */
  vol.noOfUnits = LE2(unitHeader.noOfUnits);
  vol.noOfTransferUnits = unitHeader.noOfTransferUnits;
  vol.firstPhysicalEUN = LE2(unitHeader.firstPhysicalEUN);
  vol.bamOffset = LE4(unitHeader.BAMoffset);
  vol.virtualSectors = (SectorNo) (LE4(unitHeader.virtualMediumSize) >> SECTOR_SIZE_BITS);
  vol.noOfPages = LE2(unitHeader.noOfPages);
  vol.noOfUnits += vol.firstPhysicalEUN;
  vol.unitSizeBits = unitHeader.log2UnitSize;
  vol.directAddressingMemory = LE4(unitHeader.directAddressingMemory);
  vol.directAddressingSectors = vol.noOfPages +
		  (unsigned) (vol.directAddressingMemory >> SECTOR_SIZE_BITS);

  vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
  vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  vol.unitHeaderSectors = ((allocEntryOffset(&vol,vol.sectorsPerUnit) - 1) >>
				    SECTOR_SIZE_BITS) + 1;

  if (vol.noOfUnits <= vol.firstPhysicalEUN ||
      LE4(unitHeader.virtualMediumSize) > MAX_VOLUME_MBYTES * 0x100000l ||
      allocEntryOffset(&vol,vol.unitHeaderSectors) > SECTOR_SIZE ||
      (int)(vol.virtualSectors >> (PAGE_SIZE_BITS - SECTOR_SIZE_BITS)) > vol.noOfPages ||
      (int)(vol.virtualSectors >> (vol.unitSizeBits - SECTOR_SIZE_BITS)) > (vol.noOfUnits - vol.firstPhysicalEUN)) {
    dismountFTL(&vol);
    return flBadFormat;
  }

  checkStatus(initTables(&vol));
  
  vol.totalFreeSectors = 0;

  /* Mount all units */
  for (iUnit = vol.firstPhysicalEUN; iUnit < vol.noOfUnits; iUnit++)
    mountUnit(&vol,&vol.physicalUnits[iUnit]);

  /* Verify the conversion tables */
  vol.badFormat = FALSE;

  for (iUnit = vol.firstPhysicalEUN; iUnit < vol.noOfUnits - vol.noOfTransferUnits; iUnit++)
    if (vol.logicalUnits[iUnit] == NULL)
      vol.badFormat = TRUE;

  if (vol.replacementPageNo != UNASSIGNED_SECTOR &&
      vol.pageTable[(unsigned)vol.replacementPageNo] == UNASSIGNED_SECTOR) {
    /* A lonely replacement page. Mark it as a regular page (may fail   */
    /* because of write protection) and use it.				*/
    markAllocMap(&vol,
		  vol.replacementPageAddress,
		  (((VirtualAddress) vol.replacementPageNo - vol.noOfPages)
		      << SECTOR_SIZE_BITS) | DATA_SECTOR,
		  TRUE);
    vol.pageTable[(unsigned)vol.replacementPageNo] = vol.replacementPageAddress;
    vol.replacementPageNo = UNASSIGNED_SECTOR;
  }

  for (iPage = 0; iPage < vol.noOfPages; iPage++)
    if (vol.pageTable[iPage] == UNASSIGNED_SECTOR)
      vol.badFormat = TRUE;

  tl->rec = &vol;
  tl->mapSector = mapSector;
  tl->writeSector = writeSector;
  tl->deleteSector = deleteSector;
#if defined(DEFRAGMENT_VOLUME) || defined(SINGLE_BUFFER)
  tl->defragment = defragment;
#endif
  tl->sectorsInVolume = sectorsInVolume;
  tl->tlSetBusy = tlSetBusy;
  tl->dismount = dismountFTL;

  tl->writeMultiSector = NULL;
  tl->readSectors = NULL;

  if( vol.badFormat ) {
    dismountFTL(&vol);
    return flBadFormat;
  }
	DEBUG_PRINT(("Debug: mountFTL(): Finished OK! :)\n"));
  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	        f l R e g i s t e r F T L			*/
/*									*/
/* Register this translation layer					*/
/*									*/
/* Parameters:                                                          */
/*	None								*/
/*                                                                      */
/* Returns:								*/
/* 	FLStatus 	: 0 on succes, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterFTL(void)
{
#ifdef MALLOC
  unsigned i,j;
#endif
  j = 0x11223344;
  PRINTF("flRegisterFTL():Started ... \n");
  if (noOfTLs >= TLS)
    return flTooManyComponents;
  PRINTF("flRegisterFTL():SUSU TEST @@@@@@@@@@@@@@@ = %x \n",j);	
  tlTable[noOfTLs].mountRoutine = mountFTL;
  PRINTF("flRegisterFTL():tlTable[noOfTLs].mountRoutine = %x \n",tlTable[noOfTLs].mountRoutine);
#ifdef FORMAT_VOLUME
  tlTable[noOfTLs].formatRoutine = formatFTL;
#else
  tlTable[noOfTLs].formatRoutine = noFormat;
  tlTable[noOfTLs].preMountRoutine  = NULL;
#endif
  noOfTLs++;

#ifdef MALLOC
  for(i=0;( i < SOCKETS );i++) {
    vols[i].physicalUnits = NULL;
    vols[i].logicalUnits = NULL;
    vols[i].pageTable = NULL;
  }
#endif

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\inftl.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/inftl.c_V  $
 *
 *    Rev 1.40   Apr 15 2002 20:14:40   oris
 * Changed the use of SecondUnitStructure for INFTLTEST utility.
 *
 *    Rev 1.39   Apr 15 2002 08:39:32   oris
 * Placed quick mount under if def of CHECK_MOUNT for INFTLTST.
 *
 *    Rev 1.38   Apr 15 2002 07:37:20   oris
 * Improved power failure resistant:
 *  - setUnavail macro was changed for improved code readability.
 *  - MarkSectorAsChecking macro was changed to  MarkSectorAsChecked
 *  - Bug fix - getSectorFlags - in case invalid sector flags are found do not forget to reset TL buffer to ff's and mark it as remapped.
 *  - Added support for VERIFY_ERASED_SECTOR compilation flag - make sure a sector is free before writing it - most of the code
 *    is found in writeAndCheck routine.
 *  - Added MAKE_SURE_IGNORE_HAS_BAD_EDC compilation flag - make sure that the sector is really marked
 *    as ignored. If not mark   the entire sector as 0.
 *  - Initialize a addition 1k buffer for the TL - used for verify erase.
 *  - Bug fix - verifySector routine had several bugs.
 *  - Bug fix - foldUnit routine bad comparison in FL_OFF mode.
 *  - Bug fix - foldBestChain routine missing update of sector count after folding failed and bad search for free unit.
 *  - Bug fix - mountUnit routine had bad handling for corrupted unit header.
 * Added support for RAM based MTD power failure tests.
 * Remove cache allocation checks - They are not needed since the cache routine itself check for proper allocation.
 * Bug fix - prevent initialization of flash record in case flash is NULL.
 * Bug fix - defragment routine used to call allocateUnit instead of foldBestChain.
 * Bug fix - bad debug print when format routine none INFTL media.
 * Bug fix - missing several dismount in INFTL format.
 * Bug fix - format routine could not place protection onto binary partition containing only the bios driver.
 * Changed format debug massages.
 *
 *    Rev 1.37   Feb 19 2002 21:00:22   oris
 * Fixed FL_READ_ONLY compilation problems.
 * Replaced TL_LEAVE_BINARY_AREA with FL_LEAVE_BINARY_AREA
 * Improved protection against power failures:
 * - formatUnit/getUnitTailer and setUnitTailer - Added argument to support temporary units (unit with erase mark on an invalid offset so that if not fixed before next mount they will be considered as free).
 * - foldUnit - Removed setUnavailable (not called only from foldBestChain) and added code to restore temporary unit into permanent ones(mark erase mark in proper place).
 * - foldBestChain - added folding not in place and several bug fixes.
 * - AllocatUnit - Change sequence to be more robust.
 * - checkFolding/applyWearLeveling - Bug fix - read newest unit in chain after allocate call it might change as part of the allocate process.
 * - deleteSector - check status of write operation.
 * - mountInftl - perforce space reclamation only if no free units.
 *
 *    Rev 1.36   Jan 29 2002 20:09:28   oris
 * Removed warnings.
 * Buf fix - chainging protection attributes of a DiskOnChip with more then a single floor.
 * Bug fix - if an invalid sector flag is found in getSectorFlags routine and read operation failed, SECTOR_IGNORED should have been returned.
 *
 *    Rev 1.35   Jan 28 2002 21:25:46   oris
 * Bug fix - discard mark write operation had bad casting causing the
 * mark to be written to much lower addresses.
 * Changed discard variable to static const.
 * allocateAndWriteSectors - improved going along chain algorithm to scan
 * chain only once.
 *
 *    Rev 1.34   Jan 23 2002 23:33:20   oris
 * Removed CHECK_DISCARD compilation flag.
 * Bug fix - bad casting caused discard mark to be written to a different unit then was expected in formatUnit().
 * Changed discardQuickMountInfo to mark quick mount area as discarded instead of erasing it.
 * Improved markAsIgnored routine.
 * Bug fix - Problems with insert and remove key routines.
 * Bug fix - write BBT for INFTL formatted DiskOnChip was not supported.
 * Changed DFORMAT_PRINT syntax
 *
 *    Rev 1.33   Jan 21 2002 20:44:56   oris
 * Bug fix - Erase of quick mount information does not take block multiplication into account.
 *
 *    Rev 1.32   Jan 20 2002 20:28:48   oris
 * Removed warnings
 * Changed putGetBuffer to handle FAR pointers (prototype and pointers arithmetic's).
 * Quick mount is now saved if either of the following occurs
 *  - Last mount did not use quick mount information.
 *  - A write operation was made in this mount
 * Bug in quickMount units size calculation (affected large DiskOnChips).
 *
 *    Rev 1.31   Jan 20 2002 10:49:52   oris
 * Added initialization of Bnand record in mount and format.
 * Removed badFormat field from Bnand record.
 * Improoved last sector cache mechanism
 * Removed support for PPP=3 interleave-2
 * Changed FL_MALLOC allocation calls to FL_FAR_MALLOC and changed RAM tables pointers to FAR1.
 * Split preMount routine into protection routine and other premount routins.
 * Added DOUBLE_MAX_UNIT_CHAIN instead of MAX_UNIT_CHAIN*2
 * Added protection agains power failures.
 *  - Added several modes of verify write :
 *     - FL_UPS no protection
 *     - FL_ON verify each and every write operation
 *     - FL_OFF full protection with minmal performance penalty.
 *     - Added verifyVolume API to scan the media for slower mount, but with not further performance penalty.
 *     - default after mount is FL_OFF
 *  - Added folding not in place.
 *  - Added verification of last sector of the chains (in folding).
 *  - Added discard mark before erasing.
 *  - Changed sector flags and unit data retrival error correction logic.
 *  - Limit foldBestChain folding tryies.
 *  - Improoved mount logic for choosing between invalid chains.
 * Quick mount mechanism
 *  - Forced quick mount as default
 *  - Delete previous data only after first write operation.
 *  - Remove previous quick mount info with an erase operation.
 *  - Added remove previous quick mount info API (In preMount).
 * Imprroved error report mechanizm of brocken chains (should never happen):
 *  - error on read return unused area of flash
 *  - error on write report flGeneralFailure
 *  - error on mount fix chains. If error on a chain that was already validated , report flGeneralFailure
 * Format routine
 *  - Force quick mount (ignoring user flag)
 *  - Bug fix - format with leave binary partition of a protected binary partition.
 *  - Removed single floor support.
 *
 *    Rev 1.30   Nov 21 2001 11:38:26   oris
 * Changed FL_MARK_DELETE to FL_ON.
 * Changed FL_WITH_VERIFY_WRITE and FL_WITHOUT_VERIFY_WRITE to FL_ON and FL_OFF.
 *
 *    Rev 1.29   Nov 16 2001 00:22:22   oris
 * Reorganized - removed function declaration, moved debug routines to a
 * separated file.
 * Bug fix - VERIFY_WRITE logic - marking unit as unavailable was done on the
 * virtual unit and not the last physical unit plus the least sector count and
 * max chain length , where not reinitialized in foldBestChange. The result
 * might cause infinite loop in foldbestchain if foldUnit fails.
 * Bug fix - Support for DiskOnChip with last floors having less chips.
 * Improved progress callback routine to show current unit starting from 1 and
 not 0 and to indicate bad and unavailable blocks as well.
 * Bug fix - all routines that changed protection attributes might not use
 * Bug fix - formatting with LEAVE_BINARY_PARTITION when binary partition is
 * exactly the floor size (virtual size). and improved it for bootAreaLen not
 * 0 and not -1 (leave only part of the previous binary partition).
 * Quick mount feature - Made sure the mount operation changes quick_mount
 * validity even if QUICK_MOUNT_FEATURE is commented.
 * Support 2 unchangeable protected partitions (not only 1).
 * Added discard mark before erase and placed this option under ifdef (default off).
 * Changed isValidUnitFlags to check all fields (isValidParityResult) not just
 * PUN and VUN.
 * getUnitData - bug in the logic of using second unit data structure.
 * No need to reread the unit data if verify write is activated after setUnitData.
 * Added check in virtual2physical to make sure this the unit found is valid.
 * initINFTLbasic - Use dword variable to calculate blocks per unit (support 64k blocks).
 * Change block multiplication from MORE then 32K units (not equal)
 * Improved support for read only mode including mount - FL_READ_ONLY
 * Add runtime option of VERIFY_WRITE
 * Bug fix - Binary partition in the first floor used only 1001 units while in
 * other floors 1002 units.
 *
 *    Rev 1.28   Oct 11 2001 23:54:58   oris
 * Bug fix - When changing protection attribute of a BDTL partition (change
 * key, change lock , change protection type) on a DiskOnChip with more then
 * a single floor, an error massage might be returned since changing
 * protection attributes uses the same buffer as the structure holding the
 * protection area to work on.
 *
 *    Rev 1.27   Sep 24 2001 18:23:50   oris
 * Bug fix - missing break in foldBestChain - very rare case.
 * Removed warnings.
 *
 *    Rev 1.26   Sep 16 2001 21:47:54   oris
 * Placed intergrity check of sector in the last unit of the virtual unit under
 * VERIFY_WRITE compilation flag.
 * Bug fix - missing big-endian conversion when using static memory allocation.
 *
 *    Rev 1.25   Sep 15 2001 23:46:54   oris
 * Removed redundant isAvailable checks.
 * Make sure mount operation does not reconstruct BBT.
 * Bug fix - folding in wear leveling does not change NAC to 1.
 * Bug fix - Bad casting caused bad protection type to be returned under BIG_ENDIAN.
 * Changed change protection attributes routine applied on protected partition
 * from flWrongKey to flHWProtection.
 * Improved algorithm reliability with VERIFY_WRITE. Following are the changes in the algorithm:
 * 1) virtual2Physical -
 * a) added flag stating if the specific sector is not free in the last unit of the chain.
 * 2) foldUnit -
 * a) if can not copy sector to the last unit of the chain, mark unit as
 * unavailable and return error code.
 * b) If verify write is enabled check even sectors that re marked as used and
 * are found on the last unit of the chain.
 * 3) foldBestChain -
 * a) Ignore unavailable units
 * b) If folding failed start looking from the beginning (it will be marked as
 * unavailable by the foldunit routine).
 * c) when done make all unit available.
 * 4) Added checkFolding routine - after folding check if succeeded. If not
 * loop up to MAX_FOLDING_LOOP each time free a unit with foldbestchain,
 * append a unit to the problematic chain and try to fold it.
 * 5) allocateUnit - Now when there are less then 2 unit reclaim space. This is
 * to minimize the chance of folding within a fold operation.
 * 6) MountINFTL - Make sure there are at least 2 free units.
 *
 *    Rev 1.24   Jul 29 2001 16:10:00   oris
 * eraseOrphanUnit bug was fixed ( we did not add vol.firstUnit to the unitNo).
 *
 *    Rev 1.23   Jul 15 2001 20:45:12   oris
 * Improoved documentation.
 * Changed unitBaseAddress function to a macro.
 * Removed unneccesary if statments in applyWearLeveling().
 *
 *    Rev 1.22   Jul 13 2001 01:06:14   oris
 * Changed multiBufferCounter to signed allowing a better buffer management.
 * Changed consequtiveNumbers routine into a macro.
 * Reorganized the DEBUG chains routines.
 * Bug fix - H/W read protected partition did not report as such.
 * Changed swapUnits routine name to applyWearleveling.
 * Added basics for last sector return mechanism -
 *     foldUnit receives an additional field.
 *     read2Sectors returns edc error sector address and actually read sector address
 * Added several static prefixes for static routines.
 * Added edc check for media header read operation.
 * Bug fix - parturition size smaller then a unit was acceptable.
 * Added default protection for unused DPSes.
 * Bug fix - formatINFTL with leave binary partition flag when previous binary
 * partition was larger then a single floor.
 * Improved mount documentation.
 * Changed policy - do not erase unit with bad erase mark.
 *
 *    Rev 1.21   Jun 17 2001 08:20:06   oris
 * Added NO_READ_BBT_CODE compilation flag to reduce code size.
 * Improoved Reliability:
 * 1) Try to return next sector in chain if the current one has EDC error
 * 2) Mount routine erases all blocks not marked with the erase mark.
 *
 * Affected routines:
 * 1) virtual2Physical can recive the physical address to start looking for and
 * not the last virtual unit of the chain.
 * 2) copySector ,foldUnit, mapSector, read2sectors- if EDC error accures
 * return try returning the next sector.
 * 3) foldUnit - if EDC error accures return try returning the next sector.
 * 4) writeMultiSecotr - improove ppp = 3
 * 5) mountINFTL - erase all units not marked with the erase mark.
 *
 *    Rev 1.21   Jun 17 2001 08:18:02   oris
 * Changed recusive include define to INFTL_H.
 * Added FL_BAD_ERASE_MARK    definition for units without the erase mark on
 * mount operation.
 *
 * For the rest of the revisions see revision 1.24 in the PVCS.
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*************************************************/
/* T r u e F F S   5.0   S o u r c e   F i l e s */
/* --------------------------------------------- */
/*************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : inftl.c                                                             *
*                                                                            *
* Description : Implementation of INFTL flash translation layer.             *
*                                                                            *
*****************************************************************************/

/* Internal compilation flags */

/* #define CHAINS_DEBUG  */ /* Prints unit chains after mount routine   */
/* #define CHECK_MOUNT   */ /* Print serious tl debug warnings to       */
                            /* tl_out global file handle                */
/* #define MAKE_SURE_IGNORE_HAS_BAD_EDC */ /* Make sure the ignore mark was */
                                           /* written. If not fill sector   */
                                           /* with 0's.                     */
/* List of included files */

#include "inftl.h"

/* Private variables */

static Bnand vols[VOLUMES];
#ifndef FL_MALLOC
#ifdef NFTL_CACHE
static ucacheEntry   socketUcache[SOCKETS][U_CACHE_SIZE];
static byte socketScache[SOCKETS][S_CACHE_SIZE];
#endif /* NFTL_CACHE */
static Sbyte socketHeap[SOCKETS][ANAND_HEAP_SIZE];
static byte multiSectorBuf[SOCKETS][SECTOR_SIZE<<1];
#else
static byte *multiSectorBuf[SOCKETS];
static Sbyte multiSectorBufCounter[SOCKETS];
#endif /* FL_MALLOC */
#ifdef NFTL_CACHE
/* translation table for Sector Flags cache */
static byte scacheTable[4] = { SECTOR_DELETED, /* 0 */
            SECTOR_IGNORE,  /* 1 */
            SECTOR_USED,    /* 2 */
            SECTOR_FREE };  /* 3 */
#endif /* NFTL_CACHE */

/* Macros */
#define roundToUnits(var) ((var > 0) ? ((ANANDUnitNo)((var - 1) >> vol.unitSizeBits) + 1) : 0)
#define NextGoodUnit(addr,bbt) for(;bbt[(addr >> vol.unitSizeBits) - vol.firstQuickMountUnit]!=ANAND_UNIT_FREE;addr+=1L<<vol.unitSizeBits)
#define countOf(unitNo)      (vol.physicalUnits[unitNo] & UNIT_COUNT)
#define isAvailable(unitNo)  ((vol.physicalUnits[unitNo] == ANAND_UNIT_FREE) || (countOf(unitNo) <= UNIT_MAX_COUNT))
#define setUnavail(unitNo)   (vol.physicalUnits[unitNo]  = UNIT_UNAVAIL)

#define setUnitCount(unitNo,unitCount) { vol.physicalUnits[unitNo] &= ~UNIT_COUNT; vol.physicalUnits[unitNo] |= (ANANDPhysUnit)unitCount; }
#define isLegalUnit(unitNo)  ((unitNo < vol.noOfUnits) || (unitNo == ANAND_NO_UNIT))
#define isValidSectorFlag(sectorFlag) ((sectorFlag==SECTOR_FREE)||(sectorFlag==SECTOR_USED)||(sectorFlag==SECTOR_DELETED))
#define badParityResult(parityResult)   (parityResult != ALL_PARITY_BITS_OK)
#define consecutiveNumbers(first,second) ((byte)(second+1)==first)
#define unitBaseAddress(vol,unitNo) ((CardAddress)((ANANDUnitNo)unitNo+(ANANDUnitNo)vol.firstUnit) << vol.unitSizeBits)
#define distanceOf(read, expected) (onesCount((byte)(read ^ expected)))
#define MarkSectorAsChecked(addr) (scannedBlocks[((addr)>>SECTOR_SIZE_BITS) & vol.sectorsPerUnitMask] = TRUE)
#define WasSectorChecked(addr)     scannedBlocks[((addr)>>SECTOR_SIZE_BITS) & vol.sectorsPerUnitMask]

/* M-Systems INFTL debug routines */
#ifndef CHECK_MOUNT
#define TL_DEBUG_PRINT(x,y,z)
#define SET_EXIT(x)
#define DID_MOUNT_FAIL 1
#endif /* CHECK_MOUNT */
#if (defined(CHECK_MOUNT) || defined (CHAINS_DEBUG))
#include "inftldbg.c"
#endif /* CHECK_MOUNT || CHAINS_DEBUG */


/*------------------------------------------------------*/
/*                o n e s C o u n t                     */
/*                                                      */
/*  counts number of bits that valued 1 in a given byte */
/*------------------------------------------------------*/

static byte onesCount(byte flag)
{
   byte counter;

   for (counter = 0; flag; flag >>= 1)
          if (flag & 1)
           counter++;

   return counter;
}


/*----------------------------------------------------------------------*/
/*                       g e t U n i t T a i l e r                      */
/*                                                                      */
/* Get the erase record of a unit.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*      eraseMark       : Receives the erase mark of the unit           */
/*      eraseCount      : Receives the erase count of the unit          */
/*      offset          : offset in unit                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus getUnitTailer(Bnand vol,
          ANANDUnitNo unitNo,
          word *eraseMark,
          dword *eraseCount,
          dword offset)
{
  UnitTailer unitTailer;
  FLStatus status;

  status = vol.flash->read(vol.flash,
      unitBaseAddress(vol,unitNo) + offset,
      &unitTailer,
      sizeof(UnitTailer),
      EXTRA);

  /* Mask out any 1 -> 0 bit faults by or'ing with spare data */
  *eraseMark = (word)(LE2(unitTailer.eraseMark) | LE2(unitTailer.eraseMark1));
  *eraseCount = LE4(unitTailer.eraseCount);
  return status;
}


#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                       s e t U n i t T a i l e r                      */
/*                                                                      */
/* Set the erase record of a unit.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*      eraseMark       : Erase mark to set                             */
/*      eraseCount      : Erase count to set                            */
/*      offset          : offset in unit                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setUnitTailer(Bnand vol,
        ANANDUnitNo unitNo,
        word eraseMark,
        dword eraseCount,
        dword offset)
{
  UnitTailer unitTailer;

  toLE2(unitTailer.eraseMark,eraseMark);
  toLE2(unitTailer.eraseMark1,eraseMark);
  toLE4(unitTailer.eraseCount,eraseCount);

  return vol.flash->write(vol.flash,
          unitBaseAddress(vol,unitNo) + offset,
          &unitTailer,
          sizeof(UnitTailer),
          EXTRA);
}


/*----------------------------------------------------------------------*/
/*                          m a r k U n i t B a d                       */
/*                                                                      */
/* Mark a unit as bad in the conversion table and the bad units table.  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical number of bad unit                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus markUnitBad(Bnand vol, ANANDUnitNo unitNo)
{
  word eraseMark;
  dword eraseCount;
  FLStatus status;

  vol.physicalUnits[unitNo] = UNIT_BAD;
  if(vol.freeUnits)
    vol.freeUnits--;

  status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
  if (status == flOK)
     status = setUnitTailer(&vol,unitNo,FL_BAD_ERASE_MARK,eraseCount,UNIT_TAILER_OFFSET);

#ifdef NFTL_CACHE
  if (vol.ucache != NULL) /* Mark unit cache as unavaialbel */
  {
     vol.ucache[unitNo].virtualUnitNo = 0xDEAD;
     vol.ucache[unitNo].prevUnitNo    = 0xDEAD;
  }
#endif /* NFTL_CACHE */
  return status;
}


/*----------------------------------------------------------------------*/
/*                        f o r m a t U n i t                           */
/*                                                                      */
/* Format one unit. Erase the unit, and mark the physical units table.  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit to format                       */
/*      eraseMarkOffset : Offset to place erase mark                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus formatUnit(Bnand vol, ANANDUnitNo unitNo,
                           dword eraseMarkOffset)
{
  word eraseMark;
  dword eraseCount;
  FLStatus status;
#ifndef RAM_MTD
  static const
#endif /* RAM_MTD */
  byte discard = (byte)CLEAR_DISCARD;

  status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
  if(status != flOK)
    return status;

#ifdef NFTL_CACHE
  /* Update ANANDUnitHeader cache to prevent re-filling from flash */
  if (vol.ucache != NULL) {
      vol.ucache[unitNo].virtualUnitNo     = ANAND_NO_UNIT;
      vol.ucache[unitNo].prevUnitNo        = ANAND_NO_UNIT;
      vol.ucache[unitNo].ANAC              = ANAND_UNIT_FREE;
      vol.ucache[unitNo].NAC               = ANAND_UNIT_FREE;
  }

  /*
   * Purge the Sector Flags cache (set entries for all the unit's
   * sectors to SECTOR_FREE).
   */

  if(vol.scache!=NULL)
  {
    tffsset(&(vol.scache[unitNo << (vol.unitSizeBits - SECTOR_SIZE_BITS-2)]),
    S_CACHE_4_SECTORS_FREE, 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2));
  }
#endif /* NFTL_CACHE */

  /* Mark unit as unusable before erase */
  vol.flash->write(vol.flash,(((dword)(vol.firstUnit + unitNo))<<vol.unitSizeBits)+DISCARD_UNIT_OFFSET,&discard,1,EXTRA);

  /* Physicaly erase unit */
  status = vol.flash->erase(vol.flash,(word)((word)(vol.firstUnit + unitNo)
           << vol.blockMultiplierBits),(word)(1 << vol.blockMultiplierBits));

  vol.eraseSum++;
  eraseCount++;
  if (eraseCount == 0)          /* was hex FF's */
    eraseCount++;

  if (status == flOK)
     status = setUnitTailer(&vol,unitNo,ERASE_MARK,eraseCount,eraseMarkOffset);

  if (status != flOK) {
    markUnitBad(&vol,unitNo);   /* make sure unit format is not valid */
    return status;
  }

  if (vol.physicalUnits[unitNo] != ANAND_UNIT_FREE)
  {
     vol.physicalUnits[unitNo] = ANAND_UNIT_FREE;
     vol.freeUnits++;
  }

  return status;
}

#endif /* FL_READ_ONLY */


/*----------------------------------------------------------------------*/
/*                       g e t U n i t D a t a                          */
/*                                                                      */
/* Get virtual unit No. and replacement unit no. of a unit.             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol              : Pointer identifying drive                    */
/*      unitNo           : Physical unit number                         */
/*      virtualUnitNo    : Returns the virtual unit no.                 */
/*      prevUnitNo       : Returns the previous unit no.                */
/*      ANAC             : Returns the Accumulating Number Along Chain. */
/*      NAC              : Returns the Number Along Chain value.        */
/*      validFields      : Returns a bit map of the valid fields.       */
/*                                                                      */
/* Returns:                                                             */
/*    flOK on success, flHWProtection on H/W read protection.           */
/*----------------------------------------------------------------------*/

static FLStatus getUnitData(Bnand vol,
        ANANDUnitNo unitNo,
        ANANDUnitNo *virtualUnitNo,
        ANANDUnitNo *prevUnitNo,
        byte *ANAC,
        byte *NAC,
        byte *validFields)
{
  ANANDUnitHeader       unitData;
  SecondANANDUnitHeader secondUnitData;
  FLStatus              status;
  byte                  parityPerField=0;
  byte                  temp;
  byte                  returnedValidField = ALL_PARITY_BITS_OK;
  byte                  curValidFields[2];
  int                   index;

#ifdef NFTL_CACHE
  /* on cache miss read ANANDUnitHeader from flash and re-fill cache */
  if ((vol.ucache != NULL)&&(vol.ucache[unitNo].virtualUnitNo != 0xDEAD) &&
      (vol.ucache[unitNo].prevUnitNo != 0xDEAD))
  {
     *virtualUnitNo = vol.ucache[unitNo].virtualUnitNo;
     *prevUnitNo = vol.ucache[unitNo].prevUnitNo;
     *ANAC = vol.ucache[unitNo].ANAC;
     *NAC = vol.ucache[unitNo].NAC;
  }
  else
#endif  /* NFTL_CACHE */
  {   /* no ANANDUnitHeader cache MUST read first header */

      *validFields       = 0; /* Set all fields to be invalid */

      /* Read first unit data */
      status = vol.flash->read(vol.flash,
                   unitBaseAddress(vol,unitNo) + UNIT_DATA_OFFSET,
                   &unitData,
                   sizeof(ANANDUnitHeader),
                   EXTRA);
      if(status != flOK)
         return status;

      *virtualUnitNo = LE2(unitData.virtualUnitNo);
      *prevUnitNo    = LE2(unitData.prevUnitNo   );
      *ANAC          = unitData.ANAC;
      *NAC           = unitData.NAC;

      for(index=0;index<2;index++)
      {
         /* If all data is 0xff assume a free unit */
         if((*virtualUnitNo     == ANAND_NO_UNIT  )&&
            (*prevUnitNo        == ANAND_NO_UNIT  )&&
            (*ANAC              == ANAND_UNIT_FREE)&&
            (*NAC               == ANAND_UNIT_FREE)&&
            (unitData.discarded == ANAND_UNIT_FREE))
         {
#ifndef FL_READ_ONLY
            if(index!=0)
            {
               /* If this is the second copy then the first was not  */
               /* erased, but since it was written first it makes no */
               /* sence. Let us erase it just in case.               */

               status = formatUnit(&vol,unitNo,UNIT_TAILER_OFFSET);
               if(status != flOK)
                  return status;
            }
#endif /* FL_READ_ONLY */
            break;
         }

         /* Not a free unit check unit data validity (discard and partity) */
         if ((onesCount((byte)(unitData.discarded^DISCARD))>1))
         {
            /* Discarded mark is more then 1 bit distance from 0xAA  */
            /* Assume erase operation was interrupted and erase unit */

            TL_DEBUG_PRINT(tl_out,"getUnitData : unit %d has an invalid discard mark\n",unitNo);
            TL_DEBUG_PRINT(tl_out,"              it might be helpful to know it was %d\n",unitData.discarded);

#ifndef FL_READ_ONLY
            status = formatUnit(&vol,unitNo,UNIT_TAILER_OFFSET);
            if(status != flOK)
               return status;
#endif /* FL_READ_ONLY */
            *virtualUnitNo = ANAND_NO_UNIT;
            *prevUnitNo    = ANAND_NO_UNIT;
            *ANAC          = ANAND_UNIT_FREE;
            *NAC           = ANAND_UNIT_FREE;
            break;
         }

         /* Discarded OK now check parity field */
         parityPerField = 0;
         temp=(byte)(((byte *)virtualUnitNo)[0]^((byte *)virtualUnitNo)[1]);
         if((onesCount(temp) & 1)==1)
            parityPerField|=VU_PARITY_BIT;
         temp=(byte)(((byte *)prevUnitNo)[0]^((byte *)prevUnitNo)[1]);
         if((onesCount(temp) & 1)==1)
            parityPerField|=PU_PARITY_BIT;
         if((onesCount(unitData.ANAC) & 1)==1)
            parityPerField|=ANAC_PARITY_BIT;
         if((onesCount(unitData.NAC) & 1)==1)
            parityPerField|=NAC_PARITY_BIT;

         /* Store valid fields using bitmap */
         curValidFields[index] = (byte)((~(parityPerField ^ unitData.parityPerField))
                         & ALL_PARITY_BITS_OK);

         if(curValidFields[index] == ALL_PARITY_BITS_OK)
         {
            /* If either copies has valid fields (all of them) use it */
            break;
         }
         else
         {
            if(index>0)
            {
               /* Use first header data if possible otherwise use second */
               returnedValidField = (byte)(curValidFields[0] | curValidFields[1]);
               TL_DEBUG_PRINT(tl_out,"getUnitData : The returned valid field indicator is %d\n",returnedValidField);
               TL_DEBUG_PRINT(tl_out,"              While %d indicates a valid unit data\n",ALL_PARITY_BITS_OK);
               if(curValidFields[0] & VU_PARITY_BIT)
                  *virtualUnitNo = LE2(unitData.virtualUnitNo);

               if(curValidFields[0] & PU_PARITY_BIT)
                  *prevUnitNo    = LE2(unitData.prevUnitNo   );

               if(curValidFields[0] & ANAC_PARITY_BIT)
                  *ANAC          = unitData.ANAC;

               if(curValidFields[0] & NAC_PARITY_BIT)
                  *NAC           = unitData.ANAC;
               break;
            }
         }

         /* Read second unit header for next iteration */
         status = vol.flash->read(vol.flash, unitBaseAddress(vol,unitNo) +
                      SECOND_HEADER_OFFSET + UNIT_DATA_OFFSET,
                      &secondUnitData,
                      sizeof(SecondANANDUnitHeader),
                      EXTRA);
         if(status != flOK)
            return status;

         *virtualUnitNo = LE2(secondUnitData.virtualUnitNo);
         *prevUnitNo    = LE2(secondUnitData.prevUnitNo   );
         *ANAC          = secondUnitData.ANAC;
         *NAC           = secondUnitData.NAC;

         TL_DEBUG_PRINT(tl_out,"getUnitData : First unit header is not OK in unit %d \n",unitNo);
         TL_DEBUG_PRINT(tl_out,"getUnitData : Virtual Unit No  = %d \n",LE2(unitData.virtualUnitNo));
         TL_DEBUG_PRINT(tl_out,"getUnitData : Previous Unit No = %d \n",LE2(unitData.prevUnitNo));
         TL_DEBUG_PRINT(tl_out,"getUnitData : ANAC             = %d \n",unitData.ANAC);
         TL_DEBUG_PRINT(tl_out,"getUnitData : NAC              = %d \n",unitData.NAC);
         TL_DEBUG_PRINT(tl_out,"getUnitData : ParityPerField   = %d \n",unitData.parityPerField);
         TL_DEBUG_PRINT(tl_out,"getUnitData : Discarded        = %d \n",unitData.discarded);

         TL_DEBUG_PRINT(tl_out,"getUnitData : Second unit header of the same unit %d is:\n",unitNo);
         TL_DEBUG_PRINT(tl_out,"getUnitData : Virtual Unit No  = %d \n",LE2(secondUnitData.virtualUnitNo));
         TL_DEBUG_PRINT(tl_out,"getUnitData : Previous Unit No = %d \n",LE2(secondUnitData.prevUnitNo));
         TL_DEBUG_PRINT(tl_out,"getUnitData : ANAC             = %d \n",secondUnitData.ANAC);
         TL_DEBUG_PRINT(tl_out,"getUnitData : NAC              = %d \n",secondUnitData.NAC);
         TL_DEBUG_PRINT(tl_out,"getUnitData : ParityPerField   = %d \n",secondUnitData.parityPerField);
      }

#ifdef NFTL_CACHE
      if ((vol.ucache != NULL) &&                     /* Cache enabled    */
          (returnedValidField == ALL_PARITY_BITS_OK)) /* All fields valid */
      {
         vol.ucache[unitNo].virtualUnitNo = *virtualUnitNo;
         vol.ucache[unitNo].prevUnitNo    = *prevUnitNo;
         vol.ucache[unitNo].ANAC          = *ANAC;
         vol.ucache[unitNo].NAC           = *NAC;
      }
#endif /* NFTL_CACHE */
   }
   *validFields = returnedValidField;
   return flOK;

}


/*----------------------------------------------------------------------*/
/*                       g e t P r e v U n i t                          */
/*                                                                      */
/* Get next unit in chain.                                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*      virUnitNo       : The expected virtual unit number              */
/*                                                                      */
/* Returns:                                                             */
/*      Physical unit number of the unit following unitNo in the chain. */
/*      If such unit do not exist, return ANAND_NO_UNIT.                */
/*----------------------------------------------------------------------*/

static ANANDUnitNo getPrevUnit(Bnand vol, ANANDUnitNo unitNo, ANANDUnitNo virUnitNo)
{
  ANANDUnitNo virtualUnitNo, replacementUnitNo;
  byte ANAC,NAC;
  byte parityPerField;

  /* If first in chain there can be not previous unit */
  if ((vol.physicalUnits[unitNo] & FIRST_IN_CHAIN))
    return ANAND_NO_UNIT;

  getUnitData(&vol,unitNo,&virtualUnitNo,&replacementUnitNo,&ANAC,&NAC,&parityPerField);

  /* check if unit is valid */
  if((badParityResult(parityPerField)) || ( virUnitNo != virtualUnitNo ))
  {
     TL_DEBUG_PRINT(tl_out,"getPrevUnit : An invalid unit was detected on getPrevUnit - parity is %x/0xf ",parityPerField);
     TL_DEBUG_PRINT(tl_out,"given virtual unit no is %d ",virUnitNo);
     TL_DEBUG_PRINT(tl_out,"where %d was read\n",virtualUnitNo);
     SET_EXIT(INFTL_FAILED_MOUNT);
     return ANAND_BAD_CHAIN_UNIT;
  }
  return replacementUnitNo;
}


#ifdef NFTL_CACHE

/*----------------------------------------------------------------------*/
/*           g e t S e c t o r F l a g s F r o m C a c h e              */
/*                                                                      */
/* Get sector flags from Sector Cache.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : starting address of the sector                */
/*                                                                      */
/* Returns:                                                             */
/*      sector flags (SECTOR_USED, SECTOR_DELETED etc.)                 */
/*----------------------------------------------------------------------*/

static byte getSectorFlagsFromCache(Bnand vol, CardAddress address)
{
  return scacheTable[((vol.scache[(address - vol.firstUnitAddress) >> (SECTOR_SIZE_BITS+2)] >>
                     (((word)address >> 8) & 0x7)) & 0x3)];
}


/*----------------------------------------------------------------------*/
/*               s e t S e c t o r F l a g s C a c h e                  */
/*                                                                      */
/* Get sector flags from Sector Cache.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : starting address of the sector                */
/*      sectorFlags     : one of SECTOR_USED, SECTOR_DELETED etc.       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setSectorFlagsCache(Bnand vol, CardAddress address,
        byte sectorFlags)
{
  register byte tmp, val;

  if (vol.scache == NULL)
    return;

  tmp = vol.scache[(address - vol.firstUnitAddress) >> (SECTOR_SIZE_BITS+2)];

  switch(sectorFlags) {
    case SECTOR_USED:          val = S_CACHE_SECTOR_USED;    break;
    case SECTOR_FREE:          val = S_CACHE_SECTOR_FREE;    break;
    case SECTOR_DELETED:       val = S_CACHE_SECTOR_DELETED; break;
    default:/* SECTOR_IGNORE */val = S_CACHE_SECTOR_IGNORE;  break;
  }

  switch (((word)address >> 8) & 0x7) {
    case 0: tmp = (tmp & 0xfc) | (val     ); break;  /* update bits 0..1 */
    case 2: tmp = (tmp & 0xf3) | (val << 2); break;  /*        bits 2..3 */
    case 4: tmp = (tmp & 0xcf) | (val << 4); break;  /*        bits 4..5 */
    case 6: tmp = (tmp & 0x3f) | (val << 6); break;  /*        bits 6..7 */
  }

  vol.scache[(address - vol.firstUnitAddress) >> (SECTOR_SIZE_BITS+2)] = tmp;
}

#endif /* NFTL_CACHE */


/*----------------------------------------------------------------------*/
/*                      g e t S e c t o r F l a g s                     */
/*                                                                      */
/* Get sector status.                                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorAddress           : Physical address of the sector        */
/*                                                                      */
/* Returns:                                                             */
/*      Return the OR of the two bytes in the sector status area (the   */
/*      bytes should contain the same data).                            */
/*----------------------------------------------------------------------*/

static byte getSectorFlags(Bnand vol, CardAddress sectorAddress)
{
  byte     flags[2];
  byte     blockFlag = SECTOR_IGNORE;
  byte     index,tmpSector;
  FLStatus status;

#ifdef NFTL_CACHE
  if (vol.scache != NULL) {  /* check for Sector Flags cache hit */

    blockFlag = getSectorFlagsFromCache(&vol, sectorAddress);
    if (blockFlag != SECTOR_IGNORE)
      return blockFlag;
  }
#endif /* NFTL_CACHE */

  vol.flash->read(vol.flash, sectorAddress + SECTOR_DATA_OFFSET,
                  flags, sizeof flags, EXTRA);

  if((flags[0] == flags[1]) && (isValidSectorFlag(flags[0])))
  {
     blockFlag = flags[0];
  }
  else /* Sector flags that were read are not legal or not valid */
  {
     TL_DEBUG_PRINT(tl_out,"getSectorFlags : Sector flags are not valid - physical addr %ld ",sectorAddress);
     TL_DEBUG_PRINT(tl_out,"first flag was %x ",flags[0]);
     TL_DEBUG_PRINT(tl_out,"while scond is %x\n",flags[1]);
     SET_EXIT(INFTL_FAILED_MOUNT);

     /* Force remapping of internal catched sector */
     vol.flash->socket->remapped = TRUE;

     /* Check for ignored sector using the EDC */
     status = vol.flash->read(vol.flash, sectorAddress,
                     inftlBuffer, SECTOR_SIZE, EDC);
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
     /* Now restore the ff's for the verifySectors routine */
     tffsset(inftlBuffer,0xff,SECTOR_SIZE);
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

     if(status == flOK)
     {
        /* Check if distance is less then 2 bits failure since */
        /* 2 bits failure can be either delete or used         */
        for (index=0 , tmpSector = (byte)SECTOR_USED ; index < 2 ;
             index++ , tmpSector = (byte)SECTOR_DELETED)
        {
           if (distanceOf(flags[0], tmpSector) +
               distanceOf(flags[1], tmpSector) <= 2)
           {
              blockFlag = tmpSector;
              break;
           }
        }
        if(index>=2)
           return SECTOR_IGNORE;
     }
     else
     {
        return SECTOR_IGNORE;
     }
  }

#ifdef NFTL_CACHE
  /* update Sector Flags cache */
  setSectorFlagsCache(&vol, sectorAddress, blockFlag);
#endif /* NFTL_CACHE */

  return blockFlag;
}


#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                       s e t U n i t D a t a                          */
/*                                                                      */
/* Set virtual unit No. and replacement unit no. of a unit.             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*      virtualUnitNo   : Virtual unit no.                              */
/*      prevUnitNo      : Previous unit no.                             */
/*      ANAC            : Accumulating Number Along Chain               */
/*      NAC             : Number Along Chain.                           */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus          : 0 on success, failed otherwise              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setUnitData(Bnand vol,
          ANANDUnitNo unitNo,
          ANANDUnitNo virtualUnitNo,
          ANANDUnitNo prevUnitNo,byte ANAC,byte NAC)
{
  ANANDUnitHeader       unitData;
  SecondANANDUnitHeader secondUnitData;
  FLStatus              status;
  ANANDUnitNo newVirtualUnitNo, newPrevUnitNo;
  byte newANAC,newNAC;
  byte temp;
  byte parityPerField = 0;

  if( prevUnitNo == unitNo )              /* prevent chain loop */
    return flGeneralFailure;

  /* Calculate parity per field */
  temp=(byte)(((byte *)&virtualUnitNo)[0]^((byte *)&virtualUnitNo)[1]);
  if((onesCount(temp) & 1)==1)
     parityPerField|=VU_PARITY_BIT;

  temp=(byte)(((byte *)&prevUnitNo)[0]^((byte *)&prevUnitNo)[1]);
  if((onesCount(temp) & 1)==1)
     parityPerField|=PU_PARITY_BIT;

  if((onesCount(ANAC) & 1)==1)
     parityPerField|=ANAC_PARITY_BIT;

  if((onesCount(NAC) & 1)==1)
     parityPerField|=NAC_PARITY_BIT;

  /* Store fields in proper unit header record */
  toLE2(unitData.virtualUnitNo,virtualUnitNo);
  toLE2(secondUnitData.virtualUnitNo,virtualUnitNo);
  toLE2(unitData.prevUnitNo,prevUnitNo);
  toLE2(secondUnitData.prevUnitNo,prevUnitNo);
  unitData.ANAC=secondUnitData.ANAC=ANAC;
  unitData.NAC=secondUnitData.NAC=NAC;
  unitData.parityPerField=secondUnitData.parityPerField=parityPerField;
  unitData.discarded=DISCARD;

  /* Write first unit header */
  status = vol.flash->write(vol.flash,
                               unitBaseAddress(vol,unitNo) + UNIT_DATA_OFFSET,
                               &unitData,
                               sizeof(ANANDUnitHeader),
                               EXTRA);
  if(status == flOK) /* Write second unit header */
     status = vol.flash->write(vol.flash, unitBaseAddress(vol,unitNo) +
                               SECOND_HEADER_OFFSET+UNIT_DATA_OFFSET,
                               &secondUnitData,
                               sizeof(SecondANANDUnitHeader),
                               EXTRA);
  if(status == flOK)
  {

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
     if (vol.flash->socket->verifyWrite == FL_ON)
        goto fillCache;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

#ifdef NFTL_CACHE
     if (vol.ucache != NULL) /* Mark unit cache as none valid before read */
     {
        vol.ucache[unitNo].virtualUnitNo = 0xDEAD;
        vol.ucache[unitNo].prevUnitNo    = 0xDEAD;
     }
#endif /* NFTL_CACHE */

     status = getUnitData(&vol,unitNo,&newVirtualUnitNo, &newPrevUnitNo,&newANAC,&newNAC,&parityPerField);
     if (status == flOK)
     {
         if ((virtualUnitNo == newVirtualUnitNo) &&
             (prevUnitNo    == newPrevUnitNo   ) &&
             (!badParityResult(parityPerField) )   )
            goto fillCache;
     }
  }

  /* If we reached here we failed in writing unit header */
  /* Erase unit and report write fault                   */

  DEBUG_PRINT(("setUnitData : Failed setting unit data\r\n"));
  status = formatUnit(&vol,unitNo,UNIT_TAILER_OFFSET);
  if (status != flOK)
  {
     markUnitBad(&vol,unitNo);
     return status;
  }
  else
  {
     return flWriteFault;
  }

fillCache: /* Unit headers were placed OK, now update cache */
#ifdef NFTL_CACHE
  /* Update ANANDUnitHeader cache to prevent re-filling from flash */
  if (vol.ucache != NULL) {
      vol.ucache[unitNo].virtualUnitNo = virtualUnitNo;
      vol.ucache[unitNo].prevUnitNo    = prevUnitNo;
      vol.ucache[unitNo].ANAC          = ANAC;
      vol.ucache[unitNo].NAC           = NAC;
  }
#endif /* NFTL_CACHE */
  return flOK;
}

/*----------------------------------------------------------------------*/
/*             d i s c a r d Q u i c k M o u n t I n f o                */
/*                                                                      */
/* Mark quick mount information is none valid.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus discardQuickMountInfo(Bnand vol)
{
#ifndef RAM_MTD
   static const
#endif /* RAM_MTD */
   dword tmp = 0;
   /* Dis - validate quick mount data */
   if(vol.firstMediaWrite == FALSE)
   {
      vol.firstMediaWrite = TRUE;
      return vol.flash->write(vol.flash, QUICK_MOUNT_VALID_SIGN_OFFSET +
                              ((dword)vol.firstQuickMountUnit <<
                                vol.unitSizeBits),
                              &tmp,
                              sizeof(tmp),
                              0);
   }
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                      m a r k A s I g n o r e d                       */
/*                                                                      */
/* Mark sector at given address as ignored.                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      addr            : Physical address of the sector                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void markAsIgnored(Bnand vol,CardAddress addr)
{
#ifndef RAM_MTD
    static const
#endif /* RAM_MTD */
    byte sectorFlags[2] = {SECTOR_IGNORE,SECTOR_IGNORE};

    DEBUG_PRINT(("markAsIgnored : A sector is being marked as ignored\r\n"));

    discardQuickMountInfo(&vol);

#ifdef NFTL_CACHE
    setSectorFlagsCache(&vol, addr, SECTOR_IGNORE);
#endif /* NFTL_CACHE */
     vol.flash->write(vol.flash,addr+SECTOR_DATA_OFFSET,sectorFlags,sizeof(sectorFlags),EXTRA);

#ifdef MAKE_SURE_IGNORE_HAS_BAD_EDC
     /* Force remapping of internal catched sector */
     vol.flash->socket->remapped = TRUE;

     /* Make sure EDC is wrong - a slite problem with PPP */
     if(vol.flash->read(vol.flash,addr,inftlBuffer,sizeof(inftlBuffer),EDC)==flOK)
     {
        tffsset(inftlBuffer,0,sizeof(inftlBuffer));
        vol.flash->write(vol.flash,addr,inftlBuffer,sizeof(inftlBuffer),0);
     }
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
     /* Now restore the ff's for the verifySectors routine */
     tffsset(inftlBuffer,0xff,sizeof(inftlBuffer));
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#endif /* MAKE_SURE_IGNORE_HAS_BAD_EDC */

}

#endif /* FL_READ_ONLY */


/*----------------------------------------------------------------------*/
/*                       v i r t u a l 2 P h y s i c a l                */
/*                                                                      */
/* Translate virtual sector number to physical address.                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Virtual sector number                         */
/*      startAddress    : Physical address to start from                */
/*      lastOK          : TRUE - the current sector in the last unit of */
/*                        virtual unit chain is free (not marked as     */
/*                        deleted / ignored or used).                   */
/*                                                                      */
/* Note: The first unit of the search is assumed to be valid.           */
/*                                                                      */
/* Returns:                                                             */
/*      physical address of sectorNo                                    */
/*----------------------------------------------------------------------*/

static CardAddress virtual2Physical(Bnand vol, SectorNo sectorNo,
                    CardAddress startAddress,FLBoolean* lastOK)
{
  word        unitOffset = (word)((sectorNo & vol.sectorsPerUnitMask) << SECTOR_SIZE_BITS);
  ANANDUnitNo unitNo, virUnitNo;
  ANANDUnitNo chainBound    = 0;
  CardAddress sectorAddress = ANAND_UNASSIGNED_ADDRESS;
  byte sectorFlags          = SECTOR_FREE;

  /* follow the chain */
  virUnitNo = (ANANDUnitNo)(sectorNo >> vol.sectorsPerUnitBits);
  if (startAddress == ANAND_UNASSIGNED_ADDRESS)
  {
     /* Start from last unit in chain */
     unitNo = vol.virtualUnits[virUnitNo];
  }
  else
  {
     /* Start from the unit that follows the given unit */

     TL_DEBUG_PRINT(tl_out,"virtual2Physical : Virtual to physical started from middle of chain on unit %d\n",virUnitNo);
     SET_EXIT(INFTL_FAILED_MOUNT);
     unitNo = getPrevUnit(&vol,(ANANDUnitNo)((startAddress >> vol.unitSizeBits) - vol.firstUnit),virUnitNo);
     if(unitNo == ANAND_BAD_CHAIN_UNIT)
        return ANAND_BAD_CHAIN_ADDRESS;
  }

  for (;unitNo != ANAND_NO_UNIT;unitNo = getPrevUnit(&vol,unitNo,virUnitNo))
  {
     if((unitNo == ANAND_BAD_CHAIN_UNIT     ) ||
        (chainBound >= DOUBLE_MAX_UNIT_CHAIN)   )
        return ANAND_BAD_CHAIN_ADDRESS;

     sectorAddress = unitBaseAddress(vol,unitNo) + unitOffset;
     sectorFlags   = getSectorFlags(&vol,sectorAddress);

     /* Report if the last unit of the chain is used */
     if ((unitNo == vol.virtualUnits[virUnitNo]) &&
         (sectorFlags != SECTOR_FREE))
        *lastOK = FALSE;

     if((sectorFlags==SECTOR_FREE) || (sectorFlags==SECTOR_IGNORE))
     {
        chainBound++;
        continue;
     }
     break;
  }

  if((sectorFlags==SECTOR_IGNORE)||(sectorFlags==SECTOR_FREE)||(sectorFlags==SECTOR_DELETED)) /* Sector was never written*/
     return  ANAND_UNASSIGNED_ADDRESS;
  return sectorAddress;
}


/*----------------------------------------------------------------------*/
/*                   i n i t I N F T L b a s i c                        */
/*                                                                      */
/* Initializes essential volume data                                    */
/*                                                                      */
/* Note : This routine is called both by the mount and format initINFTL */
/* and as a preparation for counting the number of partitions function. */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      flash           : Flash media mounted on this socket            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus initINFTLbasic(Bnand vol, FLFlash *flash)
{
  dword noOfUnits; /* Keep this variable dword , for large DiskOnChips */

  if (flash == NULL || !(flash->flags & INFTL_ENABLED))
  {
    DEBUG_PRINT(("\nDebug: media is not fit for INFTL format.\r\n"));
    return flUnknownMedia;
  }
  if(flash->readBBT == NULL)
  {
     DEBUG_PRINT(("\nDEBUG : MTD read BBT routine was not initialized\r\n"));
     return flFeatureNotSupported;
  }

  vol.flash                 = flash;
  vol.erasableBlockSizeBits = flash->erasableBlockSizeBits;
  vol.unitSizeBits          = vol.erasableBlockSizeBits;
  noOfUnits = (dword)((vol.flash->noOfChips * vol.flash->chipSize) >> vol.unitSizeBits);

  /* Bound number of units to find room in 64 Kbytes Segment */

  if((noOfUnits > MAX_UNIT_NUM) && (vol.unitSizeBits < MAX_UNIT_SIZE_BITS))
  {
    vol.unitSizeBits++;
    noOfUnits >>= 1;
  }

  vol.blockMultiplierBits = vol.unitSizeBits - vol.erasableBlockSizeBits;

  /* get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  vol.buffer              = flBufferOf(flSocketNoOf(vol.flash->socket));
#ifdef VERIFY_ERASED_SECTOR
  vol.verifyBuffer        = (dword *)flReadBackBufferOf(flSocketNoOf(flash->socket));
#endif /* VERIFY_ERASED_SECTOR */
  flash->socket->remapped = TRUE;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                           i n i t N F T L                            */
/*                                                                      */
/* Initializes essential volume data as a preparation for mount or      */
/* format.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      flash           : Flash media mounted on this socket            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus initINFTL(Bnand vol, FLFlash *flash)
{
  dword    chipSize; /* Keep this variable dword , for large DiskOnChips */
  FLStatus status;

  if(flash!=NULL)
  {
     tffsset(&vol,0,sizeof(Bnand));     /* Clear Bnand volume */

#ifdef NT5PORT
  vol.socketNo = (byte)(flSocketNoOf(flash->socket)); /* socket No */
#else
    vol.socketNo = flSocketNoOf(flash->socket); /* socket No */
#endif /*NT5PORT*/

  }

  status = initINFTLbasic(&vol, flash);
  if(status != flOK)
    return status;

  chipSize = (dword)(flash->chipSize * flash->noOfChips);

#ifndef FL_MALLOC
  if (chipSize > (dword)MAX_VOLUME_MBYTES << 20)
  {
    DEBUG_PRINT(("\nDebug: TrueFFS is customized for smaller media capacities.\r\n"));
    return flGeneralFailure;
  }
  if (ASSUMED_NFTL_UNIT_SIZE > (1L<<vol.unitSizeBits))
  {
    DEBUG_PRINT(("\nDebug: TrueFFS is customized for smaller unit sizes.\r\n"));
    return flGeneralFailure;
  }
#endif /* FL_MALLOC */

  vol.physicalUnits = NULL;
  vol.virtualUnits  = NULL;

#ifdef NFTL_CACHE
  vol.ucache        = NULL;
  vol.scache        = NULL;
#endif /* NFTL_CACHE */

  vol.mappedSectorNo      = UNASSIGNED_SECTOR;
  vol.countsValid         = 0;    /* No units have a valid count yet */
  vol.firstUnit           = 0;
  vol.sectorsPerUnit      = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  vol.sectorsPerUnitBits  = vol.unitSizeBits - SECTOR_SIZE_BITS;
  vol.sectorsPerUnitMask  = vol.sectorsPerUnit - 1;
  vol.noOfUnits           = (ANANDUnitNo)(chipSize >> vol.unitSizeBits);
  vol.firstMediaWrite     = FALSE;
#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  vol.verifiedSectorNo = 0;    /* Largest sector verified so far     */
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

#ifdef CHECK_MOUNT
  vol.debugState = 0;
#endif /* CHECK_MOUNT */

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                          i n i t T a b l e s                         */
/*                                                                      */
/* Allocates and initializes the dynamic volume table, including the    */
/* unit tables and secondary virtual map.                               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      ramForUnits   : Number of bytes allocated to previous volumes   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

#ifdef FL_MALLOC
static FLStatus initTables(Bnand vol)
{
  /* Allocate the conversion tables */

  vol.physicalUnits = (ANANDPhysUnit FAR1*) FL_FAR_MALLOC(vol.noOfUnits * sizeof(ANANDPhysUnit));
  if (vol.noOfVirtualUnits > 0)
     vol.virtualUnits = (ANANDUnitNo FAR1*) FL_FAR_MALLOC(vol.noOfVirtualUnits * sizeof(ANANDUnitNo));
  if ((vol.physicalUnits == NULL) ||
      ((vol.virtualUnits  == NULL) && (vol.noOfVirtualUnits > 0)))
  {
    DEBUG_PRINT(("\nDebug: failed allocating conversion tables for INFTL.\r\n"));
    return flNotEnoughMemory;
  }

  /* Allocate the multi-sector buffer (one per socket) */
  if (++(multiSectorBufCounter[vol.socketNo]) == 0)
  {
     multiSectorBuf[vol.socketNo] = (byte *)FL_MALLOC(SECTOR_SIZE<<1);
     if (multiSectorBuf[vol.socketNo] == NULL)
     {
        DEBUG_PRINT(("\nDebug: failed allocating multi-sector buffers for INFTL.\r\n"));
        return flNotEnoughMemory;
     }
  }
  return flOK;
}
#else
static FLStatus initTables(Bnand vol,dword ramForUnits)
{
  Sbyte *heapPtr;

  vol.heap = &socketHeap[flSocketNoOf(vol.flash->socket)][ramForUnits];
  heapPtr = vol.heap;
  vol.physicalUnits = (ANANDPhysUnit FAR1*) heapPtr;
  heapPtr += vol.noOfUnits * sizeof(ANANDPhysUnit);
  vol.virtualUnits = (ANANDUnitNo FAR1*) heapPtr;
  heapPtr += vol.noOfVirtualUnits * sizeof(ANANDUnitNo);

  if ((ANAND_HEAP_SIZE < heapPtr - vol.heap) ||
          (ASSUMED_NFTL_UNIT_SIZE > 1L << vol.unitSizeBits))
  {
    DEBUG_PRINT(("\nDebug: not enough memory for INFTL conversion tables.\r\n"));
    return flNotEnoughMemory;
  }
  return flOK;
}
#endif /* FL_MALLOC */


/*----------------------------------------------------------------------*/
/*                    f i r s t I n C h a i n                           */
/*                                                                      */
/* Find first unit in chain.                                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Start the search from this unit               */
/*      nextUnit        : Returns the Second unit of the chain.         */
/*                                                                      */
/* Returns:                                                             */
/*      Physical unit number of the last unit in chain.                 */
/*----------------------------------------------------------------------*/

static ANANDUnitNo firstInChain(Bnand vol, ANANDUnitNo unitNo,ANANDUnitNo* nextUnit)
{
  ANANDUnitNo firstVirtualUnitNo, firstReplacementUnitNo,prevVirtualUnitNo;
  ANANDUnitNo nextUnitNo,prevReplacementUnitNo;
  ANANDUnitNo chainBound = 0;
  byte ANAC,NAC,parityPerField;

  if(unitNo==ANAND_NO_UNIT) /* Sanity check */
  {
     if(nextUnit!=NULL)
         *nextUnit=ANAND_NO_UNIT;
     return unitNo;
  }

  /* If this unit is the first of its chain , no need to keep looking */
  if( vol.physicalUnits[unitNo] & FIRST_IN_CHAIN )
  {
     if(nextUnit!=NULL)
        *nextUnit=ANAND_NO_UNIT;
     return unitNo;
  }
  getUnitData(&vol,unitNo,&firstVirtualUnitNo,&firstReplacementUnitNo,&ANAC,&NAC,&parityPerField);
  /* check if unit is valid */
  if(badParityResult(parityPerField))
  {
     DEBUG_PRINT(("\nFirst In chain found bad unit header\r\n"));
     if(nextUnit!=NULL)
        *nextUnit=ANAND_NO_UNIT;
     return ANAND_BAD_CHAIN_UNIT;
  }

  nextUnitNo=unitNo;
  unitNo=firstReplacementUnitNo;
  while( (unitNo < vol.noOfUnits) &&  /* Validate replacement unit no. */
         (chainBound < DOUBLE_MAX_UNIT_CHAIN) )
  {
    if(unitNo==ANAND_NO_UNIT)
       break;
    getUnitData(&vol,unitNo,&prevVirtualUnitNo,&prevReplacementUnitNo,&ANAC,&NAC,&parityPerField);
    /* check if unit is valid */
    if(badParityResult(parityPerField))
    {
       DEBUG_PRINT(("\nFirst In chain found bad unit header\r\n"));
       if(nextUnit!=NULL)
         *nextUnit=ANAND_NO_UNIT;

       return ANAND_BAD_CHAIN_UNIT;
    }

    if(( vol.physicalUnits[unitNo] & FIRST_IN_CHAIN )&&(firstVirtualUnitNo==prevVirtualUnitNo))
    {
       if(nextUnit!=NULL)
         *nextUnit=nextUnitNo;

       return unitNo;
    }

    if( prevVirtualUnitNo != (firstVirtualUnitNo ) )
    {
       /* This one does not belong to the chain */
       if(nextUnit!=NULL)
          *nextUnit=ANAND_NO_UNIT;

       return nextUnitNo;
    }
    nextUnitNo = unitNo;
    unitNo = prevReplacementUnitNo;
    chainBound++;
  }

  return ANAND_BAD_CHAIN_UNIT;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                      w r i t e A n d C h e c k                       */
/*                                                                      */
/* Physicaly write up to 2 sectors on given address and verify.         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : Physical address of the sector to write to    */
/*      fromAddress     : Buffer of data to write                       */
/*      flags           : Write flags (ECC, overwrite etc.)             */
/*      howMany         : Number of sectors to write.                   */
/*                                                                      */
/* Returns:                                                             */
/*      Status          : 0 on success, failed otherwise.               */
/*----------------------------------------------------------------------*/

static FLStatus writeAndCheck(Bnand vol,
        CardAddress address,
        void FAR1 *fromAddress,
        unsigned flags,word howMany)
{
  FLStatus     status;
  register int i;
#ifdef VERIFY_ERASED_SECTOR
  register int noOfDword;
  int j;
#endif /* VERIFY_ERASED_SECTOR */

  /* Toggle verify write flag */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  switch (flVerifyWrite[vol.socketNo][vol.flash->socket->curPartition])
  {
     case FL_OFF:
        if (vol.verifiedSectorNo>vol.curSectorWrite+howMany)
           break;
     case FL_ON:
#ifdef VERIFY_WRITE
        vol.flash->socket->verifyWrite = FL_ON;
#endif /* VERIFY_WRITE */
#ifdef VERIFY_ERASED_SECTOR
        /* Make sure all of the sectors are really free */
        checkStatus(vol.flash->read(vol.flash,address,vol.verifyBuffer,SECTOR_SIZE*howMany,0));
        noOfDword = SECTOR_SIZE/sizeof(dword);
        for(j=0;j<howMany;j++) /* Loop over sectors */
        {
           for(i = 0;i<noOfDword;i++)          /* Loop over sector data */
           {
              if(vol.verifyBuffer[i]!=0xffffffffL)
              {
                markAsIgnored(&vol,address+j*SECTOR_SIZE);
                DEBUG_PRINT(("writeAndCheck : The sector was not erased and is ignored\r\n"));
                return flWriteFault;
              }
           }
        }
#endif /* VERIFY_ERASED_SECTOR */
        break;
     default:
        break;
  }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  /* Write sector */
  status = vol.flash->write(vol.flash,address,fromAddress,SECTOR_SIZE*howMany,(word)flags);

#ifdef VERIFY_WRITE
  if(flVerifyWrite[vol.socketNo][vol.flash->socket->curPartition] != FL_ON)
     vol.flash->socket->verifyWrite = FL_OFF;
#endif /* VERIFY_WRITE */

  /* Make sure write succeded and update sector catche */
  if (status == flWriteFault)
  {  /* write failed, ignore this sector */
    DEBUG_PRINT(("writeAndCheck : Write of a sector failed and was marked as ignored\r\n"));

    for(i=0;i<howMany;i++)
    {
       markAsIgnored(&vol,address+i*SECTOR_SIZE);
    }
  }
#ifdef NFTL_CACHE
  else
  {
    for(i=0;i<howMany;i++)
       setSectorFlagsCache(&vol, address+i*SECTOR_SIZE, SECTOR_USED);
  }
#endif /* NFTL_CACHE */

  return status;
}


/*----------------------------------------------------------------------*/
/*                         a s s i g n U n i t                          */
/*                                                                      */
/* Assigns a virtual unit no. to a unit                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol              : Pointer identifying drive                    */
/*      unitNo           : Physical unit number                         */
/*      virtualUnitNo    : Virtual unit number to assign                */
/*      ANAC             : Accumulating Number Along Chain              */
/*      NAC              : Number Along Chain.                          */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus assignUnit(Bnand vol, ANANDUnitNo unitNo,
                           ANANDUnitNo virtualUnitNo, byte ANAC,
                           byte NAC)
{
  FLStatus status;

  /* Perpare sector count */
  if((vol.countsValid > virtualUnitNo ) &&       /* Has sector count */
     (vol.virtualUnits[virtualUnitNo] != ANAND_NO_UNIT)) /* Was used */
  {
     vol.physicalUnits[unitNo] = countOf(vol.virtualUnits[virtualUnitNo]);
  }
  else
  {
     vol.physicalUnits[unitNo] = 0;
  }

  /* Vadim for ASAP policy*/
#ifdef ENVIRONMENT_VARS
  if(NAC>=MAX_UNIT_CHAIN)
     NAC=MAX_UNIT_CHAIN-1;
#endif /* ENVIRONMENT_VARS */
  status = setUnitData(&vol,unitNo,virtualUnitNo,(ANANDUnitNo)vol.virtualUnits[virtualUnitNo],(byte)(ANAC+1),(byte)(NAC+1));
  if (status != flOK)
  {
    markUnitBad(&vol,unitNo);
  }
  else
  {
    if(unitNo>vol.noOfUnits)
      return flGeneralFailure;
    vol.virtualUnits[virtualUnitNo]=unitNo;
    if(vol.freeUnits)
       vol.freeUnits--;
  }
  return status;
}


/*----------------------------------------------------------------------*/
/*                         f o r m a t C h a i n                        */
/*                                                                      */
/* Format all the units in a chain. Start from the last one and go      */
/* backwards until unitNo is reached.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Format the chain from this unit onwards       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus formatChain(Bnand vol, ANANDUnitNo unitNo)
{
  /* Erase the chain from end to start */
  ANANDUnitNo chainBound;
  ANANDUnitNo unitToErase;
  FLStatus    status;

  for (chainBound=0;; chainBound++)
  {
    /* Find last unit in chain */
    unitToErase = firstInChain(&vol,unitNo,NULL);

    if((unitToErase == ANAND_BAD_CHAIN_UNIT ) ||
       (chainBound  >= DOUBLE_MAX_UNIT_CHAIN)   )
      return flGeneralFailure;

    status = formatUnit(&vol,unitToErase,UNIT_TAILER_OFFSET);
    if(status != flOK)
       return status;

    if (unitToErase == unitNo)
      break;    /* Erased everything */
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                    c r e a t e U n i t C o u n t                     */
/*                                                                      */
/* Count the number of sectors in a unit that hold valid data.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void createUnitCount(Bnand vol, ANANDUnitNo unitNo)
{
  register int i;
  SectorNo sectorNo;
  ANANDUnitNo physicalUnitNo = vol.virtualUnits[unitNo];
  CardAddress sectorAddress;
  FLBoolean   lastOK; /* Dummy variable */

  if (physicalUnitNo == ANAND_NO_UNIT)
    return;

  /* Get a count of the valid sector in this unit */
  setUnitCount(physicalUnitNo,0);

  sectorNo = (SectorNo)unitNo << vol.sectorsPerUnitBits;
  for (i = 0; i < vol.sectorsPerUnit; i++, sectorNo++)
  {
    sectorAddress = virtual2Physical(&vol,sectorNo,ANAND_UNASSIGNED_ADDRESS,&lastOK);
    /* Do not check for brocken chain. If one exists we will have a */
    /* large sector count , which will delay folding.               */
    if (sectorAddress != ANAND_UNASSIGNED_ADDRESS)
      vol.physicalUnits[physicalUnitNo]++;
  }
}

#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))

/*----------------------------------------------------------------------*/
/*                        v e r i f y S e c t o r s                     */
/*                                                                      */
/* Verify sectors for power failures simptoms and fix if neccesary.     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorCount     : No of sectors to verify                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

FLStatus verifySectors(Bnand vol, dword sectorCount)
{
   FLStatus    status;
   word        unitOffset;
   ANANDUnitNo virUnitNo;
   ANANDUnitNo unitNo;
   dword       curRead;
   CardAddress sectorAddress;
   word        j;
   byte        chainBound,index;
   byte        sectorFlags[2];
   static      FLBoolean  scannedBlocks[MAX_SECTORS_PER_BLOCK];
   byte FAR1*  buffer;

   if (vol.verifiedSectorNo >= vol.virtualSectors)
      return flOK;

   /* Initialize variables */
   buffer      = flReadBackBufferOf(vol.socketNo);

   if(buffer==NULL)
   {
       DEBUG_PRINT(("\nDebug : Can not verify sectors since no buffer was allocated\r\n"));
       return flOK;
   }

   virUnitNo   = (ANANDUnitNo)(vol.verifiedSectorNo >> vol.sectorsPerUnitBits);
   sectorCount = TFFSMIN(vol.virtualSectors - vol.verifiedSectorNo,sectorCount);

   /* Force remapping of internal catched sector */
   vol.flash->socket->remapped = TRUE;
   tffsset(inftlBuffer,0xff,sizeof(inftlBuffer)); /* Useds as FF'S buffer */

   /* Run over required number of virtual sectors */
   for (; sectorCount > 0 ; virUnitNo++ ,sectorCount -= curRead)
   {
      /* Calculate needed number of sector in this unit */
      unitOffset = (word)((vol.verifiedSectorNo & vol.sectorsPerUnitMask) << SECTOR_SIZE_BITS);
      curRead = TFFSMIN(sectorCount,((1UL<<vol.unitSizeBits)-unitOffset)>>SECTOR_SIZE_BITS);
      unitNo  = vol.virtualUnits[virUnitNo];

      if(unitNo == ANAND_NO_UNIT) /* Unit is empty */
      {
         vol.verifiedSectorNo += ((1<<vol.unitSizeBits)-unitOffset)>>SECTOR_SIZE_BITS;
         continue;
      }

      /* Unit is not empty - initialize sector array */
      if(unitOffset==0)
          tffsset(scannedBlocks,FALSE,sizeof(scannedBlocks));

      for(chainBound=0;;chainBound++)
      {   /* Go over the chain from newest unit to oldest */

         if(chainBound!=0) /* Get next unit */
         {
            unitNo = getPrevUnit(&vol,unitNo,virUnitNo);
            if((unitNo == ANAND_BAD_CHAIN_UNIT  ) ||
               (chainBound>=DOUBLE_MAX_UNIT_CHAIN)   )
            {
              DEBUG_PRINT(("\nverifySectors : Bad chain was found\r\n"));
              return flGeneralFailure;
            }
            if(unitNo == ANAND_NO_UNIT)
               break;
         }

         /* Check required sectors of the unit - 2 sectors at a time */
         sectorAddress = unitBaseAddress(vol,unitNo)+unitOffset;
         for (index=0;index<curRead;index+=2)
         {
            /* Read sector flags if needed
             *
             * Note - getSectorFlags routine must not change the inftlBuffer
             */
            if(WasSectorChecked(sectorAddress) == FALSE)
               sectorFlags[0] = getSectorFlags(&vol,sectorAddress);
            if(WasSectorChecked(sectorAddress+SECTOR_SIZE) == FALSE)
               sectorFlags[1] = getSectorFlags(&vol,sectorAddress+SECTOR_SIZE);

            /* Try checking 2 sectors together */
            if((sectorFlags[0]==sectorFlags[1]                      ) &&
               (WasSectorChecked(sectorAddress+SECTOR_SIZE) == FALSE) &&
               (WasSectorChecked(sectorAddress)             == FALSE))
            {
               /* Indenctical sector flags - sectors are checked together */
               switch(sectorFlags[0])
               {
                  case SECTOR_FREE:
                     status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE<<1,0);
                     if(status != flOK)
                        return status;
                     if (tffscmp(inftlBuffer,buffer,sizeof(inftlBuffer)))
                     {
                        markAsIgnored(&vol,sectorAddress);
                        createUnitCount(&vol,virUnitNo);
                     }
                     if (tffscmp(inftlBuffer,buffer+sizeof(inftlBuffer),sizeof(inftlBuffer)))
                     {
                        markAsIgnored(&vol,sectorAddress+SECTOR_SIZE);
                        createUnitCount(&vol,virUnitNo);
                     }
                     break;
                  case SECTOR_DELETED:
                  case SECTOR_USED:
                     status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE<<1,EDC);
                     if(status == flDataError)
                     {
                        status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE,EDC);
                        if(status != flOK)
                        {
                           markAsIgnored(&vol,sectorAddress);
                           status = vol.flash->read(vol.flash,sectorAddress+SECTOR_SIZE,buffer,SECTOR_SIZE,EDC);
                           if(status != flOK)
                           {
                              markAsIgnored(&vol,sectorAddress+SECTOR_SIZE);
                           }
                           else
                           {
                              MarkSectorAsChecked(sectorAddress+SECTOR_SIZE);
                           }
                        }
                        else
                        {
                           MarkSectorAsChecked(sectorAddress);
                           markAsIgnored(&vol,sectorAddress+SECTOR_SIZE);
                        }
                        createUnitCount(&vol,virUnitNo);
                        break;
                     }
                     MarkSectorAsChecked(sectorAddress);
                  default: /* SECTOR_IGNORE */
                     break;
               }/* Flag type case */
               sectorAddress+=SECTOR_SIZE<<1;
            } /* Flags are indentical */
            else /* Check each sectors individualy */
            {
               for(j=0;j<2;j++,sectorAddress+=SECTOR_SIZE)
               {
                  if(WasSectorChecked(sectorAddress) == TRUE)
                     continue;

                  switch(sectorFlags[j])
                  {
                     case SECTOR_FREE:
                        status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE,0);
                        if(status != flOK)
                           return status;
                        if (tffscmp(inftlBuffer,buffer,sizeof(inftlBuffer)))
                        {
                           markAsIgnored(&vol,sectorAddress);
                           createUnitCount(&vol,virUnitNo);
                        }
                        break;
                     case SECTOR_USED:
                     case SECTOR_DELETED:
                        status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE,EDC);
                        if(status == flDataError)
                        {
                           markAsIgnored(&vol,sectorAddress);
                           createUnitCount(&vol,virUnitNo);
                        }
                        MarkSectorAsChecked(sectorAddress);
                     default: /* SECTOR_IGNORE || SECTOR_DELETED */
                        break;
                  } /* Flag type */
               } /* Try second sector */
            } /* Flags are NOT indentical */
         } /* Loop over all sector of unit or until required sectors */
      } /* Loop over all units chains */
      vol.verifiedSectorNo+=curRead;
   } /* Loop over all required sectors */
   return flOK;
}


/*----------------------------------------------------------------------*/
/*                        c h e c k V o l u m e                         */
/*                                                                      */
/* Scanthe entire media for partialy written sectors.                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus checkVolume(Bnand vol)
{
   return verifySectors(&vol, 0xffffffffL); /* Force scan of entire media */
}

#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */


/*----------------------------------------------------------------------*/
/*                           f o l d U n i t                            */
/*                                                                      */
/* Copy all the sectors that hold valid data in the chain to the last   */
/* unit of the chain and erase the chain.                               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      virtualUnitNo   : Virtual unit number of the first unit in      */
/*                        chain.                                        */
/*      foldingFlag     : One of the following flags:                   */
/*       FL_NORMAL_FOLDING - Returns fail status if can not fold        */
/*       FL_FORCE_FOLDING  - Force folding even if last sector is used  */
/*       FL_NOT_IN_PLACE   - Fold into a unit with no erase mark        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus foldUnit(Bnand vol, ANANDUnitNo virtualUnitNo,
                         int foldingFlag)
{
  ANANDUnitNo unitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo prevUnitNo;
  SectorNo    virtualSectorNo;
  CardAddress targetSectorAddress;
  int         newSectorCount = 0;
  int         i;
  byte        ANAC,NAC,parityPerField;
#ifdef ENVIRONMENT_VARS
  ANANDUnitNo nextUnitNo       = ANAND_NO_UNIT;
  CardAddress firstUnitAddress = ANAND_UNASSIGNED_ADDRESS;
  ANANDUnitNo firstUnit        = ANAND_NO_UNIT;
  FLBoolean   foldFirstOnly    = (flPolicy[vol.socketNo]
                                          [vol.flash->socket->curPartition] ==
                                          FL_COMPLETE_ASAP) ? TRUE : FALSE;
#endif /* ENVIRONMENT_VARS */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  byte        verifyWriteState = flVerifyWrite[vol.socketNo]
                                              [vol.flash->socket->curPartition];
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
  FLBoolean   lastOK;
  byte        chainBound;
  FLStatus    status;
  CardAddress sourceSectorAddress;

  /* Sanity checks */
  if(unitNo>=vol.noOfUnits) /* Empty or INVALID */
  {
     return flGeneralFailure;
  }

  /* Internal statistics */
  vol.unitsFolded++;
  /* Force remapping of internal catched sector */
  vol.flash->socket->remapped = TRUE;
  virtualSectorNo             = (SectorNo)virtualUnitNo << vol.sectorsPerUnitBits;
  targetSectorAddress         = unitBaseAddress(vol,unitNo);

  /* When verify write option is set to FL_OFF a very lazy check of the */
  /* media is done every time a folding operation is issued             */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  if(verifyWriteState == FL_OFF)
  {
     status = verifySectors(&vol,SECTORS_VERIFIED_PER_FOLDING);
     if(status != flOK)
        return status;
     vol.curSectorWrite = virtualSectorNo; /* Store virtual sector Number */
  }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  /* When policy is set to FL_COMPLETE_ASAP - folding is performed only on */
  /* the oldest unit, so find oldest unit and store its location           */
#ifdef ENVIRONMENT_VARS
  if(foldFirstOnly == TRUE)
  {
     firstUnit = firstInChain(&vol,unitNo,&nextUnitNo);
     if(firstUnit == ANAND_BAD_CHAIN_UNIT) /* Error going along chain  */
     {
        return flGeneralFailure;
     }
     firstUnitAddress = unitBaseAddress(vol,firstUnit);
  }
#endif

  /* If chain has no valid sectors simply erase it. */
  if((vol.countsValid>virtualUnitNo) && /* Unit valid sectors were counted */
     (countOf(unitNo)==0))              /* No valid sectors in unit chain  */
  {
#ifdef ENVIRONMENT_VARS
     if((foldFirstOnly == TRUE) && (nextUnitNo != ANAND_NO_UNIT))
     {
        /* Erase only first unit of chain */
        vol.physicalUnits[nextUnitNo] = FIRST_IN_CHAIN;
        return formatChain(&vol,firstUnit);
     }
     else
#endif /* ENVIRONMENT_VARS */
     {
        /* Erase chain completely */
        vol.virtualUnits[virtualUnitNo] = ANAND_NO_UNIT;
        return formatChain(&vol,unitNo);
     }
  }

  /* Single unit with valid sectors can not be folded */
  if((vol.physicalUnits[unitNo]&FIRST_IN_CHAIN)==FIRST_IN_CHAIN)
     return flGeneralFailure;

  /***********************************/
  /* Copy all sectors to target unit */
  /***********************************/

  for (i = 0; i < vol.sectorsPerUnit;
#ifdef ENVIRONMENT_VARS
       firstUnitAddress += SECTOR_SIZE,
#endif /* ENVIRONMENT_VARS */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
       vol.curSectorWrite++, /* Update virtual sector Number */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
       i++, virtualSectorNo++,targetSectorAddress += SECTOR_SIZE)
  {
    lastOK = TRUE; /* Set last sector of chain as valid */
    sourceSectorAddress = virtual2Physical(&vol,virtualSectorNo,ANAND_UNASSIGNED_ADDRESS,&lastOK);

    /* Check if sector is on the target unit. If so on some configuration we */
    /* Verify the content and on some , we just assume the data is fine.     */
    if(sourceSectorAddress == targetSectorAddress)
    {
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
       switch(verifyWriteState)
       {
          case FL_ON:  /* Always verify */
             break;
          case FL_OFF: /* Verify only if area was not scanned yet */
             if(virtualSectorNo >= vol.verifiedSectorNo)
                break;
          default: /* FL_UPS - Never verify */
             newSectorCount++;
             continue;
       }
#else
       newSectorCount++;
       continue;
#endif /* VERIFY WRITE */
    }

    /* Read sector - Loop down the chain as long as there is an EDC error */
    /* or infinit loop chain (chain bound)                                */
    for (chainBound=0 ; (sourceSectorAddress != ANAND_UNASSIGNED_ADDRESS) ; chainBound++)
    {
       if(sourceSectorAddress == ANAND_BAD_CHAIN_ADDRESS) /* Could not follow chain */
          return flGeneralFailure;

       status = vol.flash->read(vol.flash,sourceSectorAddress,
                               inftlBuffer,SECTOR_SIZE,EDC);
       if (status != flOK)
       {
          if (status == flDataError)
          {
             DEBUG_PRINT(("foldUnit : EDC error on folding\r\n"));
             if (chainBound >= MAX_UNIT_CHAIN)
                return status;
             sourceSectorAddress = virtual2Physical(&vol,virtualSectorNo,sourceSectorAddress,&lastOK);
             continue;
          }
          else
          {
             return status;
          }
       }
       break;
    } /* chain bound EDC error loop */

    if (sourceSectorAddress == ANAND_UNASSIGNED_ADDRESS) /* Sector not found */
       continue;

    newSectorCount++;
    if (sourceSectorAddress == targetSectorAddress) /* Sector already exists */
       continue;

    /* Try and copy the relevant sector */

#ifdef ENVIRONMENT_VARS
    /* On FL_COMPLETE_ASAP copy sector only if it is on the first unit */
    if((flPolicy[vol.socketNo][vol.flash->socket->curPartition]==FL_COMPLETE_ASAP) &&
       (sourceSectorAddress!=firstUnitAddress))
       continue;
#endif /* ENVIRONMENT_VARS */

    if ((lastOK == FALSE) && (foldingFlag == FL_NORMAL_FOLDING))
    {
       /* Last sector of the chain is already used */
       return flCanNotFold;
    }
    status = writeAndCheck(&vol,targetSectorAddress,inftlBuffer,EDC,1);
    vol.parasiteWrites++;

    /* On EDC error assume previous sector is empty */

    switch (status)
    {
       case flOK:         /* Success */
          break;

       case flWriteFault: /* Faild in verify write */
          if (foldingFlag == FL_NORMAL_FOLDING)
          {
             DEBUG_PRINT(("foldUnit : Failed to write a sector while folding but will not force folding\r\n"));
             return flCanNotFold;
          }
          break;

       default :          /* Protection error or any other */
          return status;
    }
  } /* Sector copy loop */

  /***************************************************************/
  /* After all sectors have been copied , erase the unused units */
  /***************************************************************/

  if(foldingFlag == FL_NOT_IN_PLACE) /* Add erase mark to validate unit */
  {
      word  eraseMark;
      dword eraseCount;

      checkStatus(getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET_2));
      checkStatus(setUnitTailer(&vol,unitNo,eraseMark,eraseCount,UNIT_TAILER_OFFSET));
  }

  if (newSectorCount > 0)  /* Some sectors remaining*/
  {
    /* Set target unit in physical unit table as first in chain */
    status = getUnitData(&vol,unitNo,&virtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
    if(status != flOK)
       return status;
    /* check if unit is valid */
    if(badParityResult(parityPerField))
       return flGeneralFailure;
#ifdef ENVIRONMENT_VARS
    /* Erase only oldest unit */
    if(flPolicy[vol.socketNo][vol.flash->socket->curPartition]==FL_COMPLETE_ASAP)
    {
       vol.physicalUnits[nextUnitNo] |= FIRST_IN_CHAIN;
       return formatUnit(&vol, firstUnit,UNIT_TAILER_OFFSET);
    }
    else
#endif
    {
       vol.physicalUnits[unitNo]     |= FIRST_IN_CHAIN;
       unitNo=prevUnitNo; /* erase all units in chain but the last one */
    }
  }
  else
  {
    /* Erase chain completely */
    vol.virtualUnits[virtualUnitNo] = ANAND_NO_UNIT;
  }

  /* Erase source units */
  return formatChain(&vol,unitNo);
}


/*----------------------------------------------------------------------*/
/*                           f o l d B e s t C h a i n                  */
/*                                                                      */
/* Find the best chain to fold and fold it.A good chain to fold is a    */
/* long chain with a small number of sectors that hold valid data.      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Receives the physical unit no. of the first   */
/*                        unit in the chain that was folded.            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus foldBestChain(Bnand vol, ANANDUnitNo *unitNo)
{
  word        leastCount, longestChain, unitCount;
  ANANDUnitNo u, firstUnitNo, newVirtualUnitNo, prevUnitNo;
  ANANDUnitNo virtualUnitNo;
  ANANDUnitNo frozenCandidate  = ANAND_NO_UNIT;
  ANANDUnitNo lazyMountCounter = 0;
  ANANDUnitNo newestUnit;
  FLStatus    status           = flOK;
  byte        NAC,ANAC,parityPerField;
  int         foldingTries;

  /* Will exit when no more units are available or up to 10 times */
  for (*unitNo = ANAND_NO_UNIT,foldingTries = 0 ;
       foldingTries < MAX_FOLDING_LOOP ; foldingTries++)
  {
     /*********************************************/
     /* Pick unit to fold using huristic function */
     /*********************************************/

     virtualUnitNo = ANAND_NO_UNIT;
     longestChain  = 1; /* Minimal chain length to fold == 1 */
     leastCount    = vol.sectorsPerUnit+1;

     for (u = 0; u < vol.noOfVirtualUnits; u++)
     {
        firstUnitNo = vol.virtualUnits[u];
        if(firstUnitNo == ANAND_NO_UNIT) /* Free unit */
           continue;

        if( !(isAvailable(firstUnitNo)) )
        {
           /* Do not attempt to fold frozen unit.                   */
           /* They will become unfrozen by the end of this routine. */
           frozenCandidate = u; /* Remember for forced folding */
           DEBUG_PRINT(("FoldBestChains : Skiped unavailable unit\r\n"));
           continue;
        }

        /* Lazy mount - Make sure unit has a valid sector count */
        if (vol.countsValid <= u)
        {
           if(lazyMountCounter>=MAX_CREATE_UNIT_COUNT)
           {
              /* If lazy mount takes too long , try and shorten it. */
              if(virtualUnitNo!=ANAND_NO_UNIT)
                 break;
           }
           createUnitCount(&vol,u);
           lazyMountCounter++;
           vol.countsValid = u + 1;
        }

        unitCount = countOf(firstUnitNo); /* No of valid sectors */

        /* If empty unit, use it. */
        if(unitCount==0)
        {
           leastCount    = unitCount; /* Store minimal sector count */
           virtualUnitNo = u;         /* Store virtual unit number  */
           break;
        }

        if ((leastCount < unitCount) ||            /* Already found a better unit */
            (vol.physicalUnits[firstUnitNo] & FIRST_IN_CHAIN)) /* 1 unit in chain */
            continue;

        /* Sector count is smaller or equal now check chains length */
        status = getUnitData(&vol,firstUnitNo,&newVirtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
        if(status != flOK)
           return status;
        /* check if unit is valid */
        if((badParityResult(parityPerField)) || (newVirtualUnitNo != u))
           return flGeneralFailure;

        if((leastCount == unitCount) &&   /* If sector count is equal */
           (longestChain >= NAC)        ) /* Use chain length         */
           continue;

        /* If we reached here the current unit is the best so far */
        longestChain   = NAC;       /* Store maximal chain length */
        leastCount     = unitCount; /* Store minimal sector count */
        virtualUnitNo  = u;         /* Store virtual unit number  */
     } /* End of unit huristic loop */

     /****************************************/
     /* Try folding the unit that was picked */
     /****************************************/

     if (virtualUnitNo != ANAND_NO_UNIT) /* Found a chain (more then 1 unit) */
     {

        *unitNo = firstInChain(&vol,vol.virtualUnits[virtualUnitNo],NULL);
        if(*unitNo==ANAND_BAD_CHAIN_UNIT)
           return flGeneralFailure;

        status = foldUnit(&vol,virtualUnitNo,FL_NORMAL_FOLDING);
        switch(status)
        {
           case flOK:
              /* Try to make sure that there are at least 2 free units */
              if(pVol->freeUnits < 2)
              {
                 DEBUG_PRINT(("foldBestChains : Folding success, but need more units.\r\n"));
                 continue;
              }
              break;
           case flCanNotFold:
              DEBUG_PRINT(("foldBestChains : Failed folding, mark as unavailable and try folding another\r\n"));
              setUnavail(vol.virtualUnits[virtualUnitNo]);
              *unitNo = ANAND_NO_UNIT;
              continue;
           default:
              DEBUG_PRINT(("foldBestChains : ERROR - Failed folding, with status diffrent then flCanNotFold.\r\n"));
              return status;
    }
     }
     else /* All remaining chains have single unit */
     {

        if (frozenCandidate == ANAND_NO_UNIT) /* Simply no chain larger then 1 */
        {
            if(*unitNo == ANAND_NO_UNIT) /* Not even 1 unit was folded */
            {
               DEBUG_PRINT(("foldBestChains : Failed - not enough units on flash.\r\n"));
               return flNotEnoughMemory;
            }
            else /* Aleady freed one unit - simply tried to get */
            {
               return flOK;
            }
        }
     }
     break;
  } /* End folding tries loop */

  /**************************************************************/
  /* Unfreeze all frozen units , and fold them using freed unit */
  /**************************************************************/

  if (frozenCandidate != ANAND_NO_UNIT) /* At least one unit was frozen */
  {
     DEBUG_PRINT(("foldBestChains : Found a frozen unit.\r\n"));
     /* find free unit to be appended */
     if(*unitNo==ANAND_NO_UNIT) /* No unit was folded */
     {
        DEBUG_PRINT(("foldBestChains : No free unit was found so far, so search for one.\r\n"));

    if(vol.freeUnits) /* There are free units */
    {
       ANANDUnitNo originalUnit = vol.roverUnit;
           do
           {
               if (++vol.roverUnit >= vol.noOfUnits)
                  vol.roverUnit = 0;

               if (vol.physicalUnits[vol.roverUnit] == ANAND_UNIT_FREE)
               { /* found a free unit, if not erased, */
                  if (formatUnit(&vol,vol.roverUnit,UNIT_TAILER_OFFSET_2) != flOK)
                     continue;   /* this unit is bad, find another */

                  *unitNo = vol.roverUnit;
                  DEBUG_PRINT(("foldBestChains : Found a free unit for folding not in place.\r\n"));
                  break;
               }
           }while (vol.roverUnit != originalUnit);
        }
    if(*unitNo==ANAND_NO_UNIT) /* No unit was found */
    {
           /* Force folding of the last frozen unit - Loose data */
           DEBUG_PRINT(("foldBestChains : Will force folding on Frozen candidate\r\n"));
           *unitNo = firstInChain(&vol,vol.virtualUnits[frozenCandidate],NULL);
           if(*unitNo==ANAND_BAD_CHAIN_UNIT)
              return flGeneralFailure;
           createUnitCount(&vol,frozenCandidate);
           status = foldUnit(&vol,frozenCandidate,FL_FORCE_FOLDING);
           if(status!= flOK)
              return status;
    }
     }

     for (u=0 ; u < vol.noOfVirtualUnits ; u++) /* Loop over units and unfreeze */
     {
        if(vol.virtualUnits[u] == ANAND_NO_UNIT)
           continue;
        if(isAvailable(vol.virtualUnits[u]))
           continue;
        createUnitCount(&vol,u);
        DEBUG_PRINT(("foldBestChains : Now free all frozen units.\r\n"));
        /* If unit is unavailable append newly found unit to chain and fold */
        checkStatus(getUnitData(&vol,vol.virtualUnits[u],&newVirtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField));
        /* check if unit is valid */
        if((badParityResult(parityPerField)) || (newVirtualUnitNo != u))
           return flGeneralFailure;
        /* Remember the appended unit */
        newestUnit = *unitNo;
    /* Remember oldest unit to return as new allocated unit */
        *unitNo = firstInChain(&vol,vol.virtualUnits[u],NULL);
    /* Erase the erase mark and move erase count to offset 6K */
        checkStatus(formatUnit(&vol,newestUnit,UNIT_TAILER_OFFSET_2));
        checkStatus(assignUnit(&vol,newestUnit,u,ANAC,NAC));
        status = foldUnit(&vol,u,FL_NOT_IN_PLACE);
        if(status != flOK)
          return status;
     }
  }
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                           a l l o c a t e U n i t                    */
/*                                                                      */
/* Find a free unit to allocate, erase it if necessary.                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Receives the physical number of the allocated */
/*                        unit                                          */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus allocateUnit(Bnand vol, ANANDUnitNo *unitNo)
{
  ANANDUnitNo originalUnit = vol.roverUnit;
  FLStatus    status;
  dword       eraseCount;
  word        eraseMark;

  if (vol.freeUnits < 2)
  {
      status = foldBestChain(&vol,unitNo);  /* make free units by folding the best chain */
      if(status != flNotEnoughMemory)
          return status;

      DEBUG_PRINT(("Debug: Using last free unit of the media.\r\n"));
  }

  do
  {
    if (++vol.roverUnit >= vol.noOfUnits)
       vol.roverUnit = 0;

    if (vol.physicalUnits[vol.roverUnit] == ANAND_UNIT_FREE)
    { /* found a free unit, if not erased, */

       status = getUnitTailer(&vol,vol.roverUnit,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
       if(status != flOK)
          return status;
       if (eraseMark != ERASE_MARK)
       {
          if (formatUnit(&vol,vol.roverUnit,UNIT_TAILER_OFFSET) != flOK)
             continue;   /* this unit is bad, find another */
       }
       *unitNo = vol.roverUnit;
       return flOK;
    }
  } while (vol.roverUnit != originalUnit);

  return foldBestChain(&vol,unitNo);  /* make free units by folding the best chain */
}


/*----------------------------------------------------------------------*/
/*                       c h e c k F o l d i n g                        */
/*                                                                      */
/* Check and complete a failed folding operation.                       */
/*                                                                      */
/* Parameters:                                                          */
/*      foldStatus      : Pointer identifying drive                     */
/*      virtualUnitNo   : Virtual unit number of the first unit in      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus checkFolding(Bnand vol,FLStatus foldStatus,ANANDUnitNo virtualUnitNo)
{
   ANANDUnitNo newVirtualUnitNo, prevUnitNo , dummyUnitNo;
   byte ANAC,NAC,parityPerField;

   if(foldStatus == flCanNotFold)
   {
      DEBUG_PRINT(("checkFolding : Perform folding not in place\r\n"));

      /* Get a new unit for extending the virtual unit */
      checkStatus(allocateUnit(&vol,&dummyUnitNo));
      checkStatus(getUnitData(&vol,vol.virtualUnits[virtualUnitNo],&newVirtualUnitNo,
                              &prevUnitNo,&ANAC,&NAC,&parityPerField));
      if((newVirtualUnitNo!=virtualUnitNo)||
         (badParityResult(parityPerField)))
      {
         return flGeneralFailure;
      }

#ifdef ENVIRONMENT_VARS
      /* Prepare NAC */
      if(NAC>=MAX_UNIT_CHAIN)
         NAC=MAX_UNIT_CHAIN-1;
#endif /* ENVIRONMENT_VARS */
      checkStatus(assignUnit(&vol,dummyUnitNo,virtualUnitNo,ANAC,NAC));
      foldStatus = foldUnit(&vol,virtualUnitNo,FL_FORCE_FOLDING);
   }
   return foldStatus;
}


/*----------------------------------------------------------------------*/
/*                  a p p l y W e a r l e v e l i n g                   */
/*                                                                      */
/* Try to extend the current vurtial chain in order to force static     */
/* files wear leveling.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus applyWearleveling(Bnand vol)
{
  ANANDUnitNo replacementUnitNo,newVirtualUnitNo;
  ANANDUnitNo startUnit,curUnit;
  FLStatus    status;
  byte        NAC,ANAC,parityPerField;

  /* Increament wear leveling counter */
  vol.wearLevel.currUnit++;
  if(vol.wearLevel.currUnit>=vol.noOfVirtualUnits)
    vol.wearLevel.currUnit=0;

  /****************************************************/
  /* Searching for a candidate virtual unit to extend */
  /****************************************************/

  startUnit = vol.wearLevel.currUnit;
  for(curUnit = startUnit ;
      vol.virtualUnits[curUnit] == ANAND_NO_UNIT;curUnit++)
  {
    if(curUnit>=vol.noOfVirtualUnits)
      curUnit = 0;
    if(startUnit == curUnit)
      break;
  }

  if(startUnit == curUnit) /* the media is empty*/
  {
     return flOK;
  }

  vol.wearLevel.currUnit = curUnit; /* Store last leveld unit */

  /***************************************************************************/
  /* Now fold the virtual chain. (if a single unit chain add before folding) */
  /***************************************************************************/

  if(vol.physicalUnits[vol.virtualUnits[curUnit]] & FIRST_IN_CHAIN) /* chain is 1 unit long */
  {
      /* This is a one unit chain, so we have to add a unit before folding */

     status = allocateUnit(&vol,&replacementUnitNo); /* Find unit to append */
     if(status != flOK)
        return status;

     if(vol.virtualUnits[curUnit] == ANAND_NO_UNIT)
     {
         /* We did folding for the very same unit and now virtual unit is FREE */
         vol.freeUnits--;
         return flOK;
     }

     /* Get previous unit information (ANAC and NAC) */
     status = getUnitData(&vol,vol.virtualUnits[curUnit],&newVirtualUnitNo, &replacementUnitNo,
                          &ANAC,&NAC,&parityPerField);
     if(status != flOK)
        return status;

     if(badParityResult(parityPerField)) /* check if unit is valid */
        return flGeneralFailure;

     if(newVirtualUnitNo != curUnit) /* Problem with RAM tables */
     {
        return flGeneralFailure;
     }

     status = assignUnit(&vol,replacementUnitNo,curUnit,ANAC,NAC);
     if(status != flOK)
        return status;
  }
  /* Perform folding and verify operation */
  status = foldUnit(&vol,curUnit,FL_NORMAL_FOLDING);
  if (status != flOK)
    return checkFolding(&vol,status,curUnit);
  return flOK;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                           m a p S e c t o r                          */
/*                                                                      */
/* Maps and returns location of a given sector no.                      */
/* NOTE: This function is used in place of a read-sector operation.     */
/*                                                                      */
/* A one-sector cache is maintained to save on map operations.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to read                            */
/*      physAddress     : Optional pointer to receive sector address    */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to physical sector location. NULL returned if sector    */
/*      does not exist.                                                 */
/*----------------------------------------------------------------------*/

static const void FAR0 *mapSector(Bnand vol, SectorNo sectorNo, CardAddress *physAddress)
{
  FLStatus  status;
  FLBoolean lastOK; /* Dummy variable */
  byte      chainBound;

  if ((sectorNo != vol.mappedSectorNo) ||
      (vol.flash->socket->remapped)    ||
      (vol.buffer->owner == &vol)        )
  {
    vol.flash->socket->remapped = TRUE;
    vol.mappedSector            = NULL;
    vol.mappedSectorAddress     = ANAND_UNASSIGNED_ADDRESS;
    if (sectorNo < vol.virtualSectors) /* While EDC error on sector read */
    {
      for (chainBound=0 ; (chainBound < DOUBLE_MAX_UNIT_CHAIN) ; chainBound++)
      {
         vol.mappedSectorAddress = virtual2Physical(&vol,sectorNo,vol.mappedSectorAddress,&lastOK);
         switch(vol.mappedSectorAddress)
         {
            case ANAND_UNASSIGNED_ADDRESS:
            case ANAND_BAD_CHAIN_ADDRESS:
               vol.mappedSector = NULL;        /* no such sector */
               break;

            default:
               vol.mappedSector = inftlBuffer;
               status = vol.flash->read(vol.flash,vol.mappedSectorAddress,inftlBuffer,SECTOR_SIZE,EDC);
               if (status == flOK)
                  break;
               if (status != flDataError)
                  return dataErrorToken;
               continue;
         }
         break;
      }
      if (chainBound >= DOUBLE_MAX_UNIT_CHAIN)
        return dataErrorToken;

      /* Store sector for next mapping operation */
      vol.mappedSectorNo = sectorNo;       /* Sector number */
      vol.buffer->owner  = &vol;           /* Partition     */
      vol.flash->socket->remapped = FALSE; /* Valid         */
    }
  }

  if (physAddress)
    *physAddress = vol.mappedSectorAddress;

  return vol.mappedSector;
}


/*----------------------------------------------------------------------*/
/*                           r e a d 2 S e c t o r s                    */
/*                                                                      */
/* read content of a set of consecutive sectors.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to read                            */
/*      dest            : pointer to buffer to read                     */
/*      sectorCount     : # of sectors to read ( up to 2 )              */
/*                                                                      */
/* Returns:                                                             */
/*      status of the read operaton                                     */
/*----------------------------------------------------------------------*/

static FLStatus read2Sectors(Bnand vol, SectorNo sectorNo, byte FAR1 *dest,
                             SectorNo sectorCount)

{
  CardAddress mappedSectorAddress[2];
  FLStatus status    = flOK;
  FLStatus retStatus = flOK;
  word i;
  byte chainBound;
  FLBoolean lastOK; /* Dummy variable */

  if ((sectorNo+sectorCount-1) >= vol.virtualSectors)
  {
     return flSectorNotFound; /* Out of bounds */
  }
  else
  {
     /* find physical location of the 2 sectors */
     for(i=0;i<sectorCount;i++)
     {
        mappedSectorAddress[i] = virtual2Physical(&vol,sectorNo+i,
                                 ANAND_UNASSIGNED_ADDRESS,&lastOK);
        /* If chain is brocken report sector not found */
        if(mappedSectorAddress[i] == ANAND_BAD_CHAIN_ADDRESS)
           mappedSectorAddress[i] = ANAND_UNASSIGNED_ADDRESS;
     }

     /* When possible read the 2 sectors together */
     if((sectorCount==2)&&
        ( mappedSectorAddress[1] > mappedSectorAddress[0]              ) &&
        ((mappedSectorAddress[1] - mappedSectorAddress[0])==SECTOR_SIZE) &&
        ( mappedSectorAddress[0] != ANAND_UNASSIGNED_ADDRESS           ) &&
        ( mappedSectorAddress[1] != ANAND_UNASSIGNED_ADDRESS           ))
     {
        if (vol.flash->read(vol.flash,mappedSectorAddress[0],
            dest,SECTOR_SIZE<<1,EDC) == flOK)
        {
           vol.sectorsRead+=2;
           return flOK;
        }
     }

     /* Sectors are not together */
     for (i=0;i<sectorCount;i++,dest = (byte FAR1 *)flAddLongToFarPointer(dest,SECTOR_SIZE))
     {
        /* While EDC error on sector read - keep reading from older unit */
        for (chainBound=0 ; (chainBound < DOUBLE_MAX_UNIT_CHAIN) ; chainBound++)
        {
           if (mappedSectorAddress[i] == ANAND_UNASSIGNED_ADDRESS)
           {
              tffsset(dest,0,SECTOR_SIZE);
              retStatus = flSectorNotFound;
              break;
           }
           else
           {
              status=vol.flash->read(vol.flash,mappedSectorAddress[i],
                                    dest,SECTOR_SIZE,EDC);
              vol.sectorsRead++;
              if (status == flOK)
              {
                 break;
              }
              else if (status == flDataError)
              {
                 mappedSectorAddress[i] = virtual2Physical(&vol,sectorNo+i,mappedSectorAddress[i],&lastOK);
                 /* If chain is brocken report sector not found */
                 if(mappedSectorAddress[i]==ANAND_BAD_CHAIN_ADDRESS)
                    mappedSectorAddress[i] = ANAND_UNASSIGNED_ADDRESS;
              }
              else
              {
                 return status;
              }
           }
        }
        if (chainBound >= DOUBLE_MAX_UNIT_CHAIN)
           return status;
     }
  }
  return retStatus;
}


/*----------------------------------------------------------------------*/
/*                      r e a d S e c t o r s                           */
/*                                                                      */
/* Read content of a set of consecutive sectors.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*      sectorNo       : Sector no. to read                             */
/*      dest           : pointer to buffer to read                      */
/*      sectorCount    : # of sectors to read                           */
/*                                                                      */
/* Returns:                                                             */
/*      status of the read operaton                                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus readSectors(Bnand vol, SectorNo sectorNo, void FAR1 *dest,
                     SectorNo sectorCount)
{
  byte FAR1* curDest;
  SectorNo   lastSector = 0;
  FLStatus   retStatus  = flOK;
  FLStatus   status;
  SectorNo   i;

#ifdef SCATTER_GATHER
  curDest = *(byte FAR1 **)dest;
#else
  curDest = (byte FAR1 *)dest;
#endif /* SCATTER_GATHER */

  if ((sectorNo+sectorCount) > vol.virtualSectors)
  {
     return flSectorNotFound; /* Out of bounds */
  }

 /****************************************************************/
 /*   Read first sector if it's only one or it has odd address   */
 /****************************************************************/
   if(((sectorNo & 1)!=0)||(sectorCount==1))
   {
      status=read2Sectors(&vol, sectorNo, curDest,1);
      if (status != flOK)
      {
         if (status == flSectorNotFound)
         {
            retStatus = flSectorNotFound;
         }
         else
         {
            return status;
         }
      }
      if(sectorCount==1)
         return status;
      sectorNo++;
      sectorCount--;
#ifdef SCATTER_GATHER
      dest = (byte FAR1 **)dest+1;
#else
      dest = flAddLongToFarPointer(dest,SECTOR_SIZE);
#endif /* SCATTER_GATHER */
   }

   if(((sectorNo+sectorCount-1) & 1)==0)   /* keep last sector if it has odd address*/
      lastSector=sectorNo+sectorCount-1;

 /*****************************************/
 /*   Read pairs of consequtive sectors   */
 /*****************************************/

#ifdef SCATTER_GATHER
   curDest = multiSectorBuf[vol.socketNo];
#else
   curDest = (byte FAR1 *)dest;
#endif /* SCATTER_GATHER */

   for(i=0;i<((sectorCount>>1)<<1);i+=2) /* read pair of sectors*/
   {
      status=read2Sectors(&vol,sectorNo+i, curDest,2);
      if (status != flOK)
      {
         if (status == flSectorNotFound)
         {
            retStatus = flSectorNotFound;
         }
         else
         {
            return status;
         }
      }
#ifdef SCATTER_GATHER
      /* copy from temporary buffer to user scattered buffers */
      tffscpy(*(byte FAR1 **)dest,curDest,SECTOR_SIZE);
      tffscpy(*((byte FAR1 **)dest+1),&(curDest[SECTOR_SIZE]),SECTOR_SIZE);
      dest = (byte FAR1 **)dest+2;
#else
      curDest=(byte FAR1 *)flAddLongToFarPointer(curDest,(SECTOR_SIZE<<1));
#endif /* SCATTER_GATHER */
   }

 /********************************/
 /*   Read last uneven sectors   */
 /********************************/

#ifdef SCATTER_GATHER
   curDest = *(byte FAR1 **)dest;
#endif /* SCATTER_GATHER */

   if(lastSector!=0)          /*  read last sector */
   {
      checkStatus(read2Sectors(&vol,lastSector, curDest,1));
   }
   return retStatus;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                   a l l o c a t e A n d W r i t e S e c t o r s      */
/*                                                                      */
/* Write to sectorNo. if necessary, allocate a free sector first.       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Virtual sector no. to write                   */
/*      fromAddress     : Address of sector data.                       */
/*      howMany         : Number of sectors to write.                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus allocateAndWriteSectors(Bnand vol,
             SectorNo sectorNo,
             void FAR1 *fromAddress,word howMany)
{
  ANANDUnitNo newVirtualUnitNo, newPrevUnitNo;
  ANANDUnitNo virtualUnitNo = (ANANDUnitNo)(sectorNo >> vol.sectorsPerUnitBits);
  ANANDUnitNo lastUnitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo unitNo,prevUnitNo;
  FLStatus    status;
  byte ANAC,NAC,parityPerField;
  word unitOffset = (word)((sectorNo & vol.sectorsPerUnitMask) << SECTOR_SIZE_BITS);
  word chainBound = 0;
  word foundSoFar = 0;
  word newSect = howMany;
  byte sectorFlags;
  FLBoolean firstUnitFound     = FALSE;
  FLBoolean secondUnitFound    = FALSE;
  FLBoolean noneFreeFound      = FALSE;
  ANANDUnitNo commonPrevUnitNo = ANAND_NO_UNIT;
  ANANDUnitNo commonUnitNo     = lastUnitNo;

  /************************************/
  /* Find a unit to write this sector */
  /************************************/

  unitNo     = lastUnitNo;    /* newest unit that either sectors is not FREE */
  prevUnitNo = ANAND_NO_UNIT; /* oldest unit with place for required sectors */

  while (unitNo != ANAND_NO_UNIT)
  {
     if(firstUnitFound == FALSE)
     {
        sectorFlags = getSectorFlags(&vol,unitBaseAddress(vol,unitNo) + unitOffset);

        switch(sectorFlags)
        {
           case SECTOR_USED:
              newSect--; /* Sector exists - do not increament counter */
           case SECTOR_DELETED:
              foundSoFar++;
              firstUnitFound = TRUE;
           case SECTOR_IGNORE:
              if(noneFreeFound == FALSE) /* Store none free space */
              {
                 commonPrevUnitNo = prevUnitNo;
                 commonUnitNo     = unitNo;
                 noneFreeFound    = TRUE;
              }
           default:
              break;
        }
     }
     if(howMany==2)
     {
        if(secondUnitFound == FALSE)
        {
           sectorFlags = getSectorFlags(&vol,unitBaseAddress(vol,unitNo) + unitOffset+512);

           switch(sectorFlags)
           {
              case SECTOR_USED:
                 newSect--; /* Sector exists - do not increament counter */
              case SECTOR_DELETED:
                 foundSoFar++;
                 secondUnitFound = TRUE;
              case SECTOR_IGNORE:
                 if(noneFreeFound == FALSE) /* Store none free space */
                 {
                    commonPrevUnitNo = prevUnitNo;
                    commonUnitNo     = unitNo;
                    noneFreeFound    = TRUE;
                 }
              default:
                 break;
           }
        }
     }

     if(foundSoFar == howMany) /* Both sectors have been found */
        break;

     /* Both sectors are FREE */
     prevUnitNo = unitNo;
     unitNo     = getPrevUnit(&vol,unitNo,virtualUnitNo);
     if(unitNo == ANAND_BAD_CHAIN_UNIT)
        return flGeneralFailure;
     chainBound++;
     if(chainBound >= DOUBLE_MAX_UNIT_CHAIN)
        return flGeneralFailure;
  } /* End of - go over chain while */
  if(noneFreeFound == TRUE)
  {
    prevUnitNo = commonPrevUnitNo; /* Common free unit for both sectors  */
    unitNo     = commonUnitNo;     /* First unit with wither used sector */
  }

  if ((prevUnitNo == ANAND_NO_UNIT)) /* No place to write sectors */
  {
    if(unitNo!=ANAND_NO_UNIT) /* Unit already exists */
    {
       status = getUnitData(&vol,unitNo,&newVirtualUnitNo, &newPrevUnitNo,&ANAC,&NAC,&parityPerField);
       if (status != flOK)
          return status;

       if(badParityResult(parityPerField)) /* check if unit is valid */
          return flGeneralFailure;

       /* Check if chain length is graeter then allowed, but remember  */
       /* that the first unit of the chain has invalid NAC.            */
       if ((NAC>=MAX_UNIT_CHAIN) &&
           ((vol.physicalUnits[unitNo]&FIRST_IN_CHAIN)!=FIRST_IN_CHAIN))
       {
          status = foldUnit(&vol,virtualUnitNo,FL_NORMAL_FOLDING);
          if (status != flOK)
          {
             status = checkFolding(&vol,status,virtualUnitNo);
             if (status != flOK)
                return status;
          }
       }
    }
    status = allocateUnit(&vol,&prevUnitNo);
    if (status != flOK)
       return status;

    unitNo = vol.virtualUnits[virtualUnitNo];

    if(unitNo==ANAND_NO_UNIT) /* Free virtual unit */
    {
       /* New Virtual unit. reinitialize NAC,ANAC and sector count */
       ANAC=NAC=0;
       /* Force FIRST_IN_CHAIN and sector count to 0. it must be done */
       /* after assignUnit, so that assign unit will not change it.   */
       unitNo=ANAND_NO_UNIT;
    }
    else /* Read unit data to set ANAC , NAC and sector count */
    {
       status = getUnitData(&vol,unitNo,&newVirtualUnitNo, &newPrevUnitNo,
                            &ANAC,&NAC,&parityPerField);
       if (status != flOK)
          return status;

       /* Check if unit is valid */
       if((badParityResult(parityPerField)) || /* Bad unit data       */
          (newVirtualUnitNo!=virtualUnitNo))   /* Bad virtual unit no */
          return flGeneralFailure;

       if(vol.physicalUnits[unitNo]&FIRST_IN_CHAIN)
          NAC=1;
    }

    status = assignUnit(&vol,prevUnitNo,virtualUnitNo,ANAC,NAC);
    if (status != flOK)
       return status;

    if(unitNo==ANAND_NO_UNIT) /* First physical unit of chain */
    {
       vol.physicalUnits[prevUnitNo]=FIRST_IN_CHAIN;
    }
    lastUnitNo = vol.virtualUnits[virtualUnitNo];
    unitNo=prevUnitNo;
  }
  else
  {
    unitNo=prevUnitNo;
  }

  /***********************************************/
  /* Area has been allocated , now write sectors */
  /***********************************************/

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  vol.curSectorWrite = sectorNo; /* Store virtual sector Number */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  status = writeAndCheck(&vol,unitBaseAddress(vol,unitNo) + unitOffset,fromAddress,EDC,howMany);
  if (status != flOK)
     return status;

  /* Take care of sector count */
  if (vol.countsValid > virtualUnitNo)
  {
    lastUnitNo=vol.virtualUnits[virtualUnitNo];

    if (countOf(lastUnitNo) + newSect <= UNIT_MAX_COUNT)
    {
       vol.physicalUnits[lastUnitNo]+=newSect; /* Increment block count */
    }
    else /* Should never happen , but sector count is not correct */
    {
       return flGeneralFailure;
    }
  }
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                        w r i t e 2 S e c t o r s                     */
/*                                                                      */
/* Writes up to 2 consecutive sector.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Virtual sector no. to write                   */
/*      fromAddress     : Data to write                                 */
/*      sectorCount     : No of sectors to write                        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus write2Sectors(Bnand vol, SectorNo sectorNo,
                              void FAR1 *fromAddress,word sectorCount)
{
  FLStatus status;
  byte i;

  if ((sectorNo+sectorCount-1) >= vol.virtualSectors)
    return flSectorNotFound;

  /* Check if cached sector is still valid */
  if ((sectorNo             == vol.mappedSectorNo                  ) &&
      (sectorNo+sectorCount == vol.mappedSectorNo + sectorCount - 1)   )
     vol.flash->socket->remapped = TRUE;

#ifdef ENVIRONMENT_VARS
  if(flPolicy[vol.socketNo][vol.flash->socket->curPartition]==FL_DEFAULT_POLICY)
#endif /* ENVIRONMENT_VARS */
  if((vol.wearLevel.currUnit!=ANAND_NO_UNIT))
  {
    vol.wearLevel.alarm++;
    if(vol.wearLevel.alarm>=WLnow)
    {
      vol.wearLevel.alarm = 0;
      status = applyWearleveling(&vol);
      if (status != flOK)
         return status;
    }
  }
  status              = flWriteFault;
  vol.sectorsWritten += sectorCount;

  /* Try writing the sector up to 4 times before reporting an error */
  for (i = 0; (i < 4) && (status == flWriteFault); i++)
    status = allocateAndWriteSectors(&vol,sectorNo,fromAddress,sectorCount);

  return status;
}


/*----------------------------------------------------------------------*/
/*                        w r i t e S e c t o r                         */
/*                                                                      */
/* Writes a sector.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Virtual sector no. to write                   */
/*      fromAddress     : Data to write                                 */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus writeSector(Bnand vol, SectorNo sectorNo,
                            void FAR1 *fromAddress)
{
  checkStatus(discardQuickMountInfo(&vol));
  return  write2Sectors( &vol, sectorNo, fromAddress, ((SectorNo)1) );
}

#ifdef ENVIRONMENT_VARS

/*----------------------------------------------------------------------*/
/*                  w r i t e F u l l U n i t                           */
/*                                                                      */
/* Write set of consecutive sectors that occupies a full unit.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to write                           */
/*      fromAddress     : Pointer to buffer to write                    */
/*                                                                      */
/* Returns:                                                             */
/*      status of the write operaton                                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus writeFullUnit(Bnand vol, SectorNo sectorNo, void FAR1 *fromAddress)
{
   ANANDUnitNo virtualUnitNo = (ANANDUnitNo)(sectorNo >> vol.sectorsPerUnitBits);
   ANANDUnitNo lastUnitNo,newVirtualUnitNo;
   ANANDUnitNo unitNo,prevUnitNo;
   FLStatus    status;
   byte        ANAC,NAC,parityPerField;

   if(virtualUnitNo==ANAND_NO_UNIT) /* Sanity check */
      return flGeneralFailure;

   status = allocateUnit(&vol,&unitNo);
   if(status != flOK)
      return status;

   lastUnitNo = vol.virtualUnits[virtualUnitNo];
   if(lastUnitNo == ANAND_NO_UNIT)
   {
      /* First time we write to this VU */
      ANAC = NAC = 0;
   }
   else
   {
      status = getUnitData(&vol,lastUnitNo,&newVirtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
      if(status != flOK)
         return status;

      /* check if unit is valid */
      if((badParityResult(parityPerField)  ) ||
         (virtualUnitNo != newVirtualUnitNo)   )
      {
         DEBUG_PRINT(("\nwriteFullUnit: Found a brocken chain\r\n"));
         return flGeneralFailure;
      }
      /* Update NAC */
      if(vol.physicalUnits[lastUnitNo]&FIRST_IN_CHAIN)
      {
         NAC = 1; /* One unit chain , set proper NAC */
      }
      else
      {
         if(NAC>=MAX_UNIT_CHAIN)
         {
            status = foldUnit(&vol,virtualUnitNo,FL_NORMAL_FOLDING);
            if (status != flOK)
            {
              status = checkFolding(&vol,status,virtualUnitNo);
              if(status != flOK)
                 return status;
            }
            if(vol.virtualUnits[virtualUnitNo]==ANAND_NO_UNIT)
            {
               /* Unit had no used sectors and was erased */
               lastUnitNo = ANAND_NO_UNIT;
               ANAC = NAC = 0;
            }
            else /* After folding must be 1 unit chain */
            {
               NAC = 1;
            }
         }
      }
   }
   status = assignUnit(&vol,unitNo,virtualUnitNo,ANAC,NAC);
   if(status != flOK)
     return status;

   setUnitCount(unitNo,vol.sectorsPerUnit);

   if(lastUnitNo==ANAND_NO_UNIT)
      vol.physicalUnits[unitNo]    |= FIRST_IN_CHAIN;
   vol.virtualUnits[virtualUnitNo]  = unitNo;

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
   /* Turn verify write off since this is a new unit */
   vol.curSectorWrite = 0; /* Store virtual sector Number */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

#ifdef SCATTER_GATHER
   /* Write in pairs (NAC is used as a simple index) */
   for (NAC=0;NAC<vol.sectorsPerUnit;NAC+=2)
   {
      tffscpy(multiSectorBuf[vol.socketNo],
              *((byte FAR1 **)fromAddress+NAC),SECTOR_SIZE);
      tffscpy(multiSectorBuf[vol.socketNo]+SECTOR_SIZE,
              *((byte FAR1 **)fromAddress+NAC+1),SECTOR_SIZE);
      status = writeAndCheck(&vol,unitBaseAddress(vol,unitNo)+
                             (NAC<<(SECTOR_SIZE_BITS+1)),
                             multiSectorBuf[vol.socketNo],EDC,2);
      if(status != flOK)
         return status;
   }
   return status;
#else
   return writeAndCheck(&vol,unitBaseAddress(vol,unitNo),fromAddress,
                        EDC,vol.sectorsPerUnit);
#endif /* SCATTER_GATHER */
}

#endif /* ENVIRONMENT_VARS */

/*----------------------------------------------------------------------*/
/*                  w r i t e M u l t i S e c t o r                     */
/*                                                                      */
/* Write set of consecutive sectors                                     */
/*                                                                      */
/* Note : Special care was taken for SCATTER_GATHER option. In this     */
/*        user buffer is given as an array of 512 bytes buffers and not */
/*        as a single large (sectors*512 Bytes) array.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to write                           */
/*      fromAddress     : pointer to buffer to write                    */
/*      sectorCount     : # of sectors to write                         */
/*                                                                      */
/* Returns:                                                             */
/*      status of the write operaton                                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus writeMultiSector(Bnand vol, SectorNo sectorNo,
                                 void FAR1 *fromAddress,SectorNo sectorCount)
{
  byte FAR1* curAddr    = (byte FAR1 *)fromAddress;
  SectorNo   lastSector;
  SectorNo   i;
  FLStatus   status = flOK;

  /* Check if sector is in virtual size boundries */
  if (sectorNo + sectorCount > vol.virtualSectors)
    return flSectorNotFound;

  checkStatus(discardQuickMountInfo(&vol));

  /*****************************************************/
  /*   Start from an odd address or only a one sector  */
  /*****************************************************/

  if(((sectorNo & 1)!=0)||(sectorCount==1))
  {
     status=write2Sectors(&vol, sectorNo,
#ifdef SCATTER_GATHER
                          *(char FAR1 **)
#endif /* SCATTER_GATHER */
                          fromAddress,1);

     if((sectorCount == 1   ) ||  /* finished (only 1 sector) */
        (status      != flOK)   ) /* or operation failed      */
        return status;

     sectorNo++;
     sectorCount--;
     /* Increament user buffer */
#ifdef SCATTER_GATHER
     fromAddress=(void FAR1 *)((char FAR1 **)fromAddress+1);
#else
     fromAddress=(byte FAR1 *)flAddLongToFarPointer(fromAddress,SECTOR_SIZE);
#endif /* SCATTER_GATHER */
  }

  /************************************************/
  /*   Write all the sequantial pair of sectors.  */
  /************************************************/

  if(((sectorNo+sectorCount-1) & 1)==0)
  {
     /* Keep last sector since it can not be written as a pair */
     lastSector = sectorNo+sectorCount-1;
  }
  else
  {
     lastSector = 0; /* All sectors can be written in pairs */
  }

  sectorCount = (sectorCount>>1)<<1; /* round down to even no' of sectors */

  for(i=0;i<sectorCount;i+=2) /* write pair of sectors*/
  {
#ifdef SCATTER_GATHER
     curAddr = (void FAR1 *)((byte FAR1 **)fromAddress+i);
#else
     curAddr=(byte FAR1 *)flAddLongToFarPointer(fromAddress,SECTOR_SIZE*i);
#endif /* SCATTER_GATHER */
#ifdef ENVIRONMENT_VARS
     if((flPolicy[vol.socketNo][vol.flash->socket->curPartition]==FL_COMPLETE_ASAP) &&
        /* sector is unit aligned */
        (((sectorNo    + i ) &  vol.sectorsPerUnitMask) == 0) &&
        /* enough sectors to fill a unit */
        ( (sectorCount - i ) >= vol.sectorsPerUnit    ))
     {
        status = writeFullUnit(&vol,sectorNo+i,curAddr);
        if(status != flOK)
           return status;
        i += vol.sectorsPerUnit-2;
        continue;
     }
#endif /* ENVIRONMENT_VARS */
#ifdef SCATTER_GATHER
     /* Copy scattered buffers to internal 1k buffer */
     tffscpy(multiSectorBuf[vol.socketNo],*((char FAR1 **)curAddr),SECTOR_SIZE);
     tffscpy(multiSectorBuf[vol.socketNo]+SECTOR_SIZE,*((char FAR1 **)curAddr+1),SECTOR_SIZE);
     curAddr = multiSectorBuf[vol.socketNo];
#endif /* SCATTER_GATHER */
     status = write2Sectors(&vol,sectorNo+i, curAddr,2);
     if(status != flOK)
        return status;
  }

  /*********************************************/
  /*   Write the last sector (not full page).  */
  /*********************************************/

  if(lastSector!=0)          /*  write last sector */
  {
#ifdef SCATTER_GATHER
     fromAddress = (void FAR1 *)((byte FAR1 **)fromAddress+i);
#else
     fromAddress = (void FAR1 *)flAddLongToFarPointer(fromAddress,SECTOR_SIZE*i);
#endif /* SCATTER_GATHER */
     status=write2Sectors(&vol, lastSector,
#ifdef SCATTER_GATHER
                          *(char FAR1 **)
#endif /* SCATTER_GATHER */
                          fromAddress,1);
  }
  return status;
}


/*----------------------------------------------------------------------*/
/*                       d e l e t e S e c t o r                        */
/*                                                                      */
/* Marks contiguous sectors as deleted.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : First sector no. to delete                    */
/*      noOfSectors     : No. of sectors to delete                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus deleteSector(Bnand vol, SectorNo sectorNo,
                             SectorNo noOfSectors)
{
  CardAddress sectorAddress;
  SectorNo    iSector;
  ANANDUnitNo virtualUnitNo;
  ANANDUnitNo currUnitNo;
  byte        sectorFlags[2] = {SECTOR_DELETED,SECTOR_DELETED};
  FLBoolean   lastOK; /* Dummy variable */

  if (sectorNo + noOfSectors > vol.virtualSectors)
    return flSectorNotFound;

  checkStatus(discardQuickMountInfo(&vol));

  for (iSector = 0; iSector < noOfSectors; iSector++, sectorNo++,
       vol.sectorsDeleted++)
  {
    sectorAddress = virtual2Physical(&vol,sectorNo,ANAND_UNASSIGNED_ADDRESS,&lastOK);
    switch(sectorAddress)
    {
       case ANAND_UNASSIGNED_ADDRESS:
          continue;

       case ANAND_BAD_CHAIN_ADDRESS:
          return flGeneralFailure;

       default:
          virtualUnitNo = (ANANDUnitNo)(sectorNo >> vol.sectorsPerUnitBits);
#ifdef NFTL_CACHE
          setSectorFlagsCache(&vol, sectorAddress, SECTOR_DELETED);
#ifdef ENVIRONMENT_VARS
          if (((flMarkDeleteOnFlash == FL_ON) &&
              (flPolicy[vol.socketNo][vol.flash->socket->curPartition] != FL_COMPLETE_ASAP)) ||
              (vol.scache == NULL))
#endif /* ENVIRONMENT_VARS */
#endif /* NFTL_CACHE */
          {

#ifndef NT5PORT
              checkStatus(vol.flash->write(vol.flash,
                              sectorAddress + SECTOR_DATA_OFFSET,
                              &sectorFlags,
                              sizeof sectorFlags,
                              EXTRA));
#else /*NT5PORT*/
             vol.flash->write(vol.flash,
                              sectorAddress + SECTOR_DATA_OFFSET,
                              sectorFlags,
                              sizeof sectorFlags,
                              EXTRA);
#endif /*NT5PORT*/

          }
          currUnitNo = vol.virtualUnits[virtualUnitNo];

          if (vol.countsValid > virtualUnitNo)
          {
             if (countOf(currUnitNo) > 0)
             {
                vol.physicalUnits[currUnitNo]--; /* Decrement block count */
             }
             else
             {
                DEBUG_PRINT(("delete sector : Unit does not apear to have any sectors\r\n"));
                return flGeneralFailure;
             }
          }
     } /* End sectorAddress switch */
  } /* End delete sector loop */

  return flOK;
}

#ifdef DEFRAGMENT_VOLUME

/*----------------------------------------------------------------------*/
/*                          d e f r a g m e n t                         */
/*                                                                      */
/* Performs unit allocations to arrange a minimum number of writable    */
/* sectors.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorsNeeded   : Minimum required sectors                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus defragment(Bnand vol, long FAR2 *sectorsNeeded)
{
  ANANDUnitNo dummyUnitNo;
  ANANDUnitNo firstFreeUnit = ANAND_NO_UNIT;
  FLBoolean   firstRound    = TRUE;
  FLStatus    status        = flOK;

  checkStatus(discardQuickMountInfo(&vol));

  if( (*sectorsNeeded) == -1 ) /* fold single best chain */
  {
    status = foldBestChain(&vol,&dummyUnitNo);
    if( (status != flOK) && (vol.freeUnits == 0) )
      return status;
    *sectorsNeeded = (long)vol.freeUnits << vol.sectorsPerUnitBits;
    return flOK;
  }

  /* Perform folding until the required number of sectors is achived */

  while (((long)vol.freeUnits << vol.sectorsPerUnitBits) < *sectorsNeeded)
  {
     status = foldBestChain(&vol,&dummyUnitNo); /* make more free units */
     if(status != flOK)
        break;
  }

  *sectorsNeeded = (long)vol.freeUnits << vol.sectorsPerUnitBits;

  return status;
}

#endif /* DEFRAGMENT */

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                        t l S e t B u s y                             */
/*                                                                      */
/* Notifies the start and end of a file-system operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      state           : FL_ON (1) = operation entry                   */
/*                        FL_OFF(0) = operation exit                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus tlSetBusy(Bnand vol, FLBoolean state)
{
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                      s e c t o r s I n V o l u m e                   */
/*                                                                      */
/* Gets the total number of sectors in the volume                       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      Number of sectors in the volume                                 */
/*----------------------------------------------------------------------*/

static SectorNo sectorsInVolume(Bnand vol)
{
  return vol.virtualSectors;
}


/*----------------------------------------------------------------------*/
/*                    p u t G e t B u f f e r                           */
/*                                                                      */
/* Write \ Read a buffer to the flash from a specific flash offset      */
/* while making sure only good units are used.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*      length         : Size of the buffer (always full pages)         */
/*      bufferPtr      : Data buffer                                    */
/*      flashAddr      : Physcial address on the flash                  */
/*      bbt            : Buffer containing BBT of the quick mount area  */
/*      readFlag       : TRUE - read data , FLASE - write data          */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*      bufferPtr      : Increamented data buffer                       */
/*      flashAddr      : Increamented physcial address on the flash     */
/*----------------------------------------------------------------------*/

#ifdef QUICK_MOUNT_FEATURE

static FLStatus putGetBuffer(Bnand vol, dword length, byte FAR1** bufferPtr,
                      CardAddress* flashAddr, byte* bbt, FLBoolean readFlag)
{
  FLStatus status;
  word     writeNow = 0;

  while (length > 0)
  {
     writeNow = (word)TFFSMIN(length,(((*flashAddr >> vol.unitSizeBits)+1)
                   << vol.unitSizeBits) - *flashAddr);
     if (readFlag)
     {
        status = vol.flash->read(vol.flash,*flashAddr,*bufferPtr,
                   (dword)writeNow,EDC);
     }
#ifndef FL_READ_ONLY
     else
     {
        status = vol.flash->write(vol.flash,*flashAddr,*bufferPtr,
                   (dword)writeNow,EDC);
     }
#endif /* FL_READ_ONLY */
     if(status != flOK)
        return status;

     length     -= writeNow;
     *flashAddr += writeNow;
     *bufferPtr  = BYTE_ADD_FAR(*bufferPtr,writeNow);
     NextGoodUnit(*flashAddr,bbt);
  }
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                   q u i c k M o u n t D a t a                        */
/*                                                                      */
/* Saves or restores the quick mount data to and from the flash         */
/*                                                                      */
/* Note : the data is saved according to the mechines architecture. Big */
/*        Indien is not converted into little indien like the rest of   */
/*        of INFTL flash data structure                                 */
/*                                                                      */
/* The following will be saved :                                        */
/*                                                                      */
/* 1) physical Units table                                              */
/* 2) virutal Units table                                               */
/* 3) TL strucutre (Not by this routien but by its caller               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      readFlag        : TRUE for retrieve data FALSE for writing it   */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success other error codes for erase\read\write failures */
/*      start           : Unit offset (from the first unit of the       */
/*                        volume to start writting quick mount data.    */
/*                        (remember migh be bad).                       */
/*----------------------------------------------------------------------*/

static FLStatus quickMountData(Bnand vol, FLBoolean readFlag, byte* start)
{
  dword       length;
  dword       remainder;
  word        partialSize;
  CardAddress flashAddr;
  FLStatus    status;
  byte FAR1*  bufferPtr = vol.physicalUnits;
  byte        bbt[MAX_QUICK_MOUNT_UNITS]; /* Minimal bad blocks table */

  /* Read bad block tabel and find the first good block of the volume */

  status = vol.flash->readBBT(vol.flash,vol.firstQuickMountUnit,
              MAX_QUICK_MOUNT_UNITS,vol.blockMultiplierBits,bbt,FALSE);
  if(status != flOK)
     return status;

  for(*start = 0 ; (*start<MAX_QUICK_MOUNT_UNITS) &&
      (bbt[*start] != BBT_GOOD_UNIT) ; (*start)++);
  if (*start == MAX_QUICK_MOUNT_UNITS)
  {
     DEBUG_PRINT(("\nDebug: Too many Bad blocks in quick mount area\r\n"));
     return flBadBBT;
  }
  /* Skip first page for Bnand record */
  flashAddr = ((CardAddress)(vol.firstQuickMountUnit + (*start))
              << vol.unitSizeBits) + vol.flash->pageSize;

  /* Only the full pages of physical table */

  length     = vol.noOfUnits * sizeof(ANANDPhysUnit); /* Physicals length  */
  remainder  = length & (SECTOR_SIZE-1)/*vol.flash->pageSize*/; /* Last partial page */
  length    -= remainder;                                 /* Round to pages    */

  status = putGetBuffer(&vol, length, &bufferPtr, &flashAddr,bbt,readFlag);
  if(status != flOK)
     return status;

  /* Partial page of the physical table + begining of virtual table */

  length      = vol.noOfVirtualUnits * sizeof(ANANDUnitNo); /* Virtuals */
  partialSize = (word)TFFSMIN(length,(dword)SECTOR_SIZE-remainder);

  if (remainder > 0)
  {
     if (readFlag)
     {
        status = vol.flash->read(vol.flash,flashAddr , inftlBuffer,
                    sizeof(inftlBuffer),EDC);
        tffscpy(bufferPtr,inftlBuffer,(word)remainder);
        tffscpy(vol.virtualUnits,inftlBuffer+(word)remainder,partialSize);
     }
#ifndef FL_READ_ONLY
     else
     {
        tffscpy(inftlBuffer,bufferPtr, (word)remainder);
        tffscpy(inftlBuffer+(word)remainder,vol.virtualUnits,partialSize);
        status = vol.flash->write(vol.flash,flashAddr,inftlBuffer,
                    sizeof(inftlBuffer),EDC);
     }
#endif /* FL_READ_ONLY */
     if(status != flOK)
        return status;

     bufferPtr  = partialSize + (byte FAR1*)vol.virtualUnits;
     flashAddr += SECTOR_SIZE/*vol.flash->pageSize*/;
     NextGoodUnit(flashAddr,bbt);        /* if needed check for next good unit */
  }
  else
  {
     bufferPtr = (byte FAR1*)vol.virtualUnits;
  }

  /* Only the full pages of virtual table */

  length    -= partialSize;                 /* Remaining virtuals */
  remainder  = length % SECTOR_SIZE/*vol.flash->pageSize*/; /* Last partial page  */
  length    -= remainder;                   /* Round to pages     */

  status = putGetBuffer(&vol,length,&bufferPtr,&flashAddr,bbt,readFlag);
  if(status != flOK)
     return status;

  /* Partial page of the virtual table */

  if (remainder>0)
  {
     if(readFlag)
     {
        status = vol.flash->read(vol.flash,flashAddr,inftlBuffer,
                                 sizeof(inftlBuffer),EDC);
        tffscpy(bufferPtr , inftlBuffer,(word)remainder);
     }
#ifndef FL_READ_ONLY
     else
     {
        tffscpy(inftlBuffer , bufferPtr , (word)remainder);
        status = vol.flash->write(vol.flash,flashAddr,inftlBuffer,
                                  sizeof(inftlBuffer),EDC);
     }
#endif /* FL_READ_ONLY */
  }
  return status;
}

#endif /* QUICK_MOUNT_FEATURE */


/*----------------------------------------------------------------------*/
/*                       d i s m o u n t I N F T L                      */
/*                                                                      */
/* Dismount INFTL volume                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void dismountINFTL(Bnand vol)
{
  DEBUG_PRINT(("\nDebug: starting INFTL dismount.\r\n"));

#if (defined(QUICK_MOUNT_FEATURE) && !defined(FL_READ_ONLY))
  if ((vol.flags & QUICK_MOUNT) && (vol.firstMediaWrite == TRUE))
  {
     savedBnand* newVol = (savedBnand*)inftlBuffer;
     byte start;
     FLStatus status;

     DEBUG_PRINT(("\nDebug: with save operation of quick mount data.\r\n"));

     start  = vol.firstUnit - vol.firstQuickMountUnit;
     status = vol.flash->erase(vol.flash,(word)(vol.firstQuickMountUnit
                        << vol.blockMultiplierBits),
                        (word)((1 << vol.blockMultiplierBits) * start));
     if (status==flOK)
     {
        vol.flags &= ~QUICK_MOUNT; /* Prevent resaving the data */
        status = quickMountData(&vol, FALSE,&start);
        if (status == flOK)
        {
           /* Place Bnand record */

           tffsset(inftlBuffer,0,sizeof(inftlBuffer)); /* Clear inftlBuffer */

           /*********************************************************/
           /* Convert internal volume to little indian dword fields */
           /*********************************************************/

           toLE4(newVol->freeUnits      , vol.freeUnits         );
           toLE4(newVol->roverUnit      , vol.roverUnit         );
           toLE4(newVol->countsValid    , vol.countsValid       );
           toLE4(newVol->sectorsRead    , vol.sectorsRead       );
           toLE4(newVol->sectorsWritten , vol.sectorsWritten    );
           toLE4(newVol->sectorsDeleted , vol.sectorsDeleted    );
           toLE4(newVol->parasiteWrites , vol.parasiteWrites    );
           toLE4(newVol->unitsFolded    , vol.unitsFolded       );
           toLE4(newVol->wearLevel_1    , vol.wearLevel.alarm   );
           toLE4(newVol->wearLevel_2    , vol.wearLevel.currUnit);
           toLE4(newVol->eraseSum       , vol.eraseSum          );
           toLE4(newVol->validate       , QUICK_MOUNT_VALID_SIGN);
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
           toLE4(newVol->verifiedSectorNo , vol.verifiedSectorNo);
#else
           toLE4(newVol->verifiedSectorNo , 0);
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

           status = vol.flash->write(vol.flash,((CardAddress)(vol.firstQuickMountUnit
           +start))<< vol.unitSizeBits,inftlBuffer, sizeof(inftlBuffer),EDC);
        }
        if (status != flOK)
           DEBUG_PRINT(("Debug: ERROR writing quick mount information.\r\n"));
     }
     else /* continue with dismount */
     {
        DEBUG_PRINT(("Debug: Error erasing quick mount information.\r\n"));
     }
  }
#endif /* QUICK_MOUNT_FEATURE && not FL_READ_ONLY */

#ifdef FL_MALLOC
  /* Free multi sector buffers */
  if (multiSectorBufCounter[vol.socketNo] == 0)
  {
     if (multiSectorBuf[vol.socketNo] != NULL)
     {
        FL_FREE(multiSectorBuf[vol.socketNo]);
        multiSectorBuf[vol.socketNo] = NULL;
     }
  }
  if (multiSectorBufCounter[vol.socketNo] >= 0)
  {
     multiSectorBufCounter[vol.socketNo]--;
  }
  /* Free convertion tables */
  if( vol.physicalUnits != NULL )
  {
#if (defined (CHAINS_DEBUG) && !defined(CHECK_MOUNT))
     FILE * out;

     out = getFileHandle(&vol,0);
     if (out == NULL)
     {
       DEBUG_PRINT(("Debug: Can not open debug file.\r\n"));
     }
     else
     {
       checkVirtualChains(&vol,out);
       checkVolumeStatistics(&vol,out);
     }
#endif /* CHAINS_DEBUG AND NOT CHECK_MOUNT*/
     FL_FAR_FREE(vol.physicalUnits);
  }
  if( vol.virtualUnits != NULL )
    FL_FAR_FREE(vol.virtualUnits);
  vol.physicalUnits = NULL;
  vol.virtualUnits  = NULL;
  /* Free catche tables */
#ifdef NFTL_CACHE
  if( vol.ucache != NULL )
    FL_FAR_FREE(vol.ucache);
  if( vol.scache != NULL )
    FL_FAR_FREE(vol.scache);
  vol.ucache = NULL;
  vol.scache = NULL;
#endif /* NFTL_CACHE */
#endif /* FL_MALLOC */
  DEBUG_PRINT(("Debug: finished INFTL dismount.\r\n"));
}


/*----------------------------------------------------------------------*/
/*                      r e t r i e v e H e a d e r                     */
/*                                                                      */
/* Retrieve media header by oring the headers of each floor             */
/*                                                                      */
/* Note:  The header of each floor is read to the first half of the     */
/*        buffer and then ORed to the second half therefor constructing */
/*        the real header in the upper half. After all copies are read  */
/*        the data is copied to the first half.                         */
/*                                                                      */
/* Note:  No endian format changes are made.                            */
/*                                                                      */
/* Parameters:                                                          */
/*  vol           : Pointer identifying drive                           */
/*  originalUnits : Array to store original units locations             */
/*  readFullBBT   : Boolean flag. When true the entire BBT will be read */
/*                  and media units locations will be returned through  */
/*                  the originalUnits argument array. When FALSE only   */
/*                  the size of HEADER_SEARCH_BOUNDRY of each floor     */
/*                  be read.                                            */
/*  retrieveData  : Boolean flag. When true the header will be read     */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success any other value on error                        */
/*      flBadFormat if header was not found                             */
/*----------------------------------------------------------------------*/

FLStatus retrieveHeader (Bnand vol , ANANDUnitNo * originalUnits,
                         FLBoolean readFullBBT , FLBoolean retrieveData)
{
  ANANDUnitNo iUnit,index;
  ANANDUnitNo noOfUnitsPerFloor;
  byte        headerSize;
  byte        floorNo;
  FLStatus    status=flOK;
  byte        bbt[HEADER_SEARCH_BOUNDRY];
  byte FAR1*  BBT;

  noOfUnitsPerFloor = (ANANDUnitNo)(vol.flash->chipSize >> vol.unitSizeBits) *
    ((vol.flash->noOfChips + (vol.flash->noOfChips % vol.flash->noOfFloors)) /
      vol.flash->noOfFloors);

  headerSize = sizeof(BNANDBootRecord)+MAX_TL_PARTITIONS*sizeof(BNANDVolumeHeaderRecord);
  tffsset(originalUnits,0,sizeof(ANANDUnitNo) * MAX_NO_OF_FLOORS);

  if (readFullBBT == TRUE) /* read entire BBT into vol records (format) */
  {
     status = vol.flash->readBBT(vol.flash,0,vol.noOfUnits,
                                 vol.blockMultiplierBits,
                                 vol.physicalUnits,TRUE);
     if(status != flOK)
        return status;
     BBT = vol.physicalUnits;
  }
  else
  {
     BBT = bbt;
  }

  /* Go over all of the media floors and find header location */

  for (floorNo = 0 ; floorNo < vol.flash->noOfFloors ; floorNo++)
  {
     iUnit = (ANANDUnitNo)floorNo * noOfUnitsPerFloor;
     if (readFullBBT == FALSE) /* read small part of the floors BBT */
     {
        status = vol.flash->readBBT(vol.flash,iUnit,
                 HEADER_SEARCH_BOUNDRY,vol.blockMultiplierBits,BBT,FALSE);
        if(status != flOK)
           return status;

        iUnit=0;
     }

     /* find and save location of the first good block of the floor */

     index = iUnit + HEADER_SEARCH_BOUNDRY;
     while ((iUnit<index)&&(BBT[iUnit]!=BBT_GOOD_UNIT))
     {
        iUnit++;
     }
     if (iUnit==index)
     {
        DEBUG_PRINT(("Debug: ERROR too many bad blocks (can not find place for INFTL header.\r\n"));
        return flBadBBT;
     }

     if (readFullBBT == FALSE) /* Restore iUnit pointer to the physical media */
     {
        iUnit += (ANANDUnitNo)floorNo * noOfUnitsPerFloor;
     }
     originalUnits[floorNo] = iUnit; /* Save origial unit location */
  }

  if (retrieveData == FALSE)
    return flOK;

  /* Need to read the previous header */

  tffsset(inftlBuffer,0,SECTOR_SIZE);
  for (floorNo = 0 ; floorNo < vol.flash->noOfFloors ; floorNo++)
  {
     for (index=0;index<NO_OF_MEDIA_HEADERS;index++) /* both 2 copies */
     {
        status = vol.flash->read(vol.flash,((CardAddress)originalUnits[floorNo]
                    << vol.unitSizeBits) + index * HEADERS_SPACING,
                    inftlBuffer + headerSize,headerSize,PARTIAL_EDC);
        if (status != flOK)
        {
           DEBUG_PRINT(("Debug: ERROR reading original unit header.\r\n"));
        }
        else
        {
           if (tffscmp(inftlBuffer + headerSize, "BNAND", sizeof("BNAND")) == 0)
              break;
        }
     }
     if (index>=NO_OF_MEDIA_HEADERS)
     {
        DEBUG_PRINT(("Debug: Media header was not found on all copies.\r\n"));
        return flBadFormat;
     }

     /* merge with previous headers */
     for (index = 0 ; headerSize > index ; index++)
     {
        inftlBuffer[index] |= inftlBuffer[index + headerSize];
     }
  } /* loop of the floors */

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                     I N F T L I n f o                                */
/*                                                                      */
/* get INFTL information.                                               */
/*                                                                      */
/* Parameters:                                                          */
/*  vol           : Pointer discribing volume.                          */
/*  tlInfo        : Pointer to user record                              */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus      : 0 on success, failed otherwise                      */
/*  tlInfo        : Record containing tl infromation.                   */
/*----------------------------------------------------------------------*/

static FLStatus  INFTLInfo(Bnand vol, TLInfo *tlInfo)
{
  tlInfo->sectorsInVolume = vol.virtualSectors;
  tlInfo->bootAreaSize    = (dword)vol.bootUnits << vol.unitSizeBits;
  tlInfo->eraseCycles     = vol.eraseSum;
  tlInfo->tlUnitBits      = vol.unitSizeBits;
  return flOK;
}

#ifndef NO_READ_BBT_CODE

/*----------------------------------------------------------------------*/
/*                      r e a d B B T                                   */
/*                                                                      */
/* Returns a pointer to the BBT of the device.                          */
/* Note: Bad unit are marked with a 4 bytes address of the unit.        */
/* Note: A unit can contain several blocks                              */
/*                                                                      */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive                                 */
/*  buf     : pointer to buffer to read into                            */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise                        */
/*  noOfBB      : returns the number of bad unit of the media           */
/*  meidaSize   : returns the media size in bytes                       */
/*----------------------------------------------------------------------*/

static FLStatus  readBBT(Bnand vol, CardAddress FAR1 * buf,
                       long FAR2 * mediaSize, unsigned FAR2 * noOfBB)
{
   dword       iUnit;
   dword       noOfUnits = (ANANDUnitNo)(((dword)vol.flash->noOfChips * vol.flash->chipSize) >> vol.unitSizeBits);
   dword       index,curRead;
   ANANDUnitNo maxBad = (ANANDUnitNo)(noOfUnits * ANAND_BAD_PERCENTAGE / 100);
   CardAddress FAR1 * ptr = buf;
   *noOfBB = 0;

   if ( vol.flash->readBBT == NULL)
   {
       DEBUG_PRINT(("Debug: ERROR unerasable BBT not supported by MTD.\r\n"));
       return flGeneralFailure;
   }
   else
   {
      for (iUnit=vol.flash->firstUsableBlock;iUnit<noOfUnits;iUnit+=curRead)
      {
        curRead = TFFSMIN(SECTOR_SIZE,noOfUnits-iUnit);
        vol.flash->readBBT(vol.flash,iUnit,curRead,vol.blockMultiplierBits,multiSectorBuf[vol.socketNo],FALSE);
        for ( index = 0 ; (index < curRead) && (*noOfBB < maxBad); index++)
           if ((*(multiSectorBuf[vol.socketNo] + index) != BBT_GOOD_UNIT) &&  /* Not good unit */
           (*(multiSectorBuf[vol.socketNo] + index) != BBT_UNAVAIL_UNIT)) /* Not used for a special purpose */
           {
              *ptr = (iUnit+index) << vol.unitSizeBits;
              ptr = (CardAddress FAR1*)flAddLongToFarPointer((byte FAR1 *)ptr,
              sizeof(CardAddress));
              (*noOfBB)++;
           }
        if ( *noOfBB == maxBad)
        {
           DEBUG_PRINT(("Debug: ERROR to many bad blocks.\r\n"));
           return flVolumeTooSmall;
        }
      }
   }
   *mediaSize = (long) noOfUnits << vol.unitSizeBits;
   return flOK;
}

#endif /* NO_READ_BBT_CODE */

/*----------------------------------------------------------------------*/
/*                  c o n v e r t C h a i n                             */
/*                                                                      */
/* Convert candidate chain to given value.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      newestUnitNo    : newest unit in chain                          */
/*      oldestUnitNo    : oldest unit in chain                          */
/*      virtualUnitNo   : virtual unit no                               */
/*      chainsMark      : new value                                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus convertChain(Bnand vol,
                             ANANDUnitNo newestUnitNo,
                             ANANDUnitNo oldestUnitNo,
                             ANANDUnitNo virtualUnitNo,
                             byte        chainsMark)
{
   ANANDUnitNo  chainBound = 0;

   for(;newestUnitNo != oldestUnitNo ; chainBound++,
        newestUnitNo  = getPrevUnit(&vol,newestUnitNo,virtualUnitNo))
   {
       if((newestUnitNo == ANAND_BAD_CHAIN_UNIT ) ||  /* Brocken chain */
          (chainBound   >= DOUBLE_MAX_UNIT_CHAIN))    /* Infinit loop  */
          return flGeneralFailure;

       vol.physicalUnits[newestUnitNo] = chainsMark;
   }
   vol.physicalUnits[oldestUnitNo]     = chainsMark;
   return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                e r a s e O r p h a n U n i t                         */
/*                                                                      */
/* Erase one unit.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Unit to format                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus eraseOrphanUnit(Bnand vol, ANANDUnitNo unitNo)
{
  word eraseMark;
  dword eraseCount;
  FLStatus status;

  status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
  if(status != flOK)
    return status;

  if(unitNo+(ANANDUnitNo)vol.firstUnit<(ANANDUnitNo)vol.firstUnit)
  {
     return flGeneralFailure;
  }

  status = vol.flash->erase(vol.flash,
                (word)(((dword)unitNo+(dword)vol.firstUnit) << (vol.unitSizeBits - vol.erasableBlockSizeBits)),
                (word)(1 << vol.blockMultiplierBits));

  if (status != flOK) {
    markUnitBad(&vol,unitNo);   /* make sure unit format is not valid */
    return status;
  }

  vol.eraseSum++;
  eraseCount++;
  if (eraseCount == 0)          /* was hex FF's */
    eraseCount++;

  return setUnitTailer(&vol,unitNo,ERASE_MARK,eraseCount,UNIT_TAILER_OFFSET);
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                      c h e c k U n i t H e a d                       */
/*                                                                      */
/* Compare 2 copies of unit header.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol              : Pointer identifying drive                    */
/*      unitNo           : Physical unit number                         */
/*                                                                      */
/* Returns:                                                             */
/*    flOK on success, flFormattingError on miscompare.                 */
/*----------------------------------------------------------------------*/

static FLStatus checkUnitHead(Bnand vol, ANANDUnitNo unitNo)
{
  ANANDUnitHeader       unitData;
  SecondANANDUnitHeader secondUnitData;

  /* Read first unit data */
  checkStatus(vol.flash->read(vol.flash,
                   unitBaseAddress(vol,unitNo) + UNIT_DATA_OFFSET,
                   &unitData,
                   sizeof(ANANDUnitHeader),
                   EXTRA));
  checkStatus(vol.flash->read(vol.flash, unitBaseAddress(vol,unitNo) +
                      SECOND_HEADER_OFFSET + UNIT_DATA_OFFSET,
                      &secondUnitData,
                      sizeof(SecondANANDUnitHeader),
                      EXTRA));
  if((LE2(secondUnitData.virtualUnitNo) != LE2(unitData.virtualUnitNo)) ||
     (LE2(secondUnitData.prevUnitNo   ) != LE2(unitData.prevUnitNo   )) ||
     (secondUnitData.ANAC               != secondUnitData.ANAC        )   )
     return flFormattingError;

  return flOK;
}

/*----------------------------------------------------------------------*/
/*                      g o A l o n g C h a i n                         */
/*                                                                      */
/* Go along the INFTL chaine while marking the chain in the convertion  */
/* tables. This routine is called by the mount routine in order to      */
/* initialize the volumes convertion tables.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit to check.                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus goAlongChain(Bnand vol,ANANDUnitNo unitNo)
{
   ANANDUnitNo origVirtualNo,virtualUnitNo,prevUnitNo;
   ANANDUnitNo lastCurrent,nextUnitNo,lastUnitNo;
   byte ANAC, NAC, prevANAC, parityPerField;
   FLStatus status;
   word  eraseMark;
   dword eraseCount;

   /* Check if already been here */
   if((vol.physicalUnits[unitNo]==FL_VALID)       ||
      (vol.physicalUnits[unitNo]==FL_FIRST_VALID) ||
      (vol.physicalUnits[unitNo]==FL_PRELIMINARY) ||
      (vol.physicalUnits[unitNo]==FL_FIRST_PRELIMINARY))
       return flOK;

   /* Read unit tailor to check the erase mark */

   status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
   if(status != flOK)
      return status;
   vol.eraseSum+=eraseCount;
   if (eraseMark != ERASE_MARK)
   {
      /* Do not perform erase in the mount. The allocateUnit routine */
      /* rechecks for the erase mark and it will erase this unit.    */
      vol.physicalUnits[unitNo] = ANAND_UNIT_FREE;
      return flOK;
   }

   status = getUnitData(&vol,unitNo,&virtualUnitNo, &prevUnitNo,
                        &ANAC,&NAC,&parityPerField);
   if(status != flOK)
      return status;

   /* Check parity result of values returned by getUnitData */

   if(badParityResult(parityPerField))
   {
      vol.physicalUnits[unitNo]=FL_PRELIMINARY;
      return flOK;
   }

   /* Check if the unit is free (all fields are FF) */

   if((virtualUnitNo == ANAND_NO_UNIT  ) &&
      (prevUnitNo    == ANAND_NO_UNIT  ) &&
      (ANAC          == ANAND_UNIT_FREE) &&
      (NAC           == ANAND_UNIT_FREE))
     return flOK;    /*  free unit */

   /* Check virtual unit number that was returned */
   if((virtualUnitNo        == ANAND_NO_UNIT) ||
      (vol.noOfVirtualUnits <= virtualUnitNo)   )
   {
      vol.physicalUnits[unitNo]=FL_PRELIMINARY;
      return flOK;
   }

   /* Save location of currently known newest unit of our chain */
   lastUnitNo = vol.virtualUnits[virtualUnitNo];


   /* If older unit is none existing then there is only one unit in this */
   /* chain so lets not complicate things.                               */

   if(prevUnitNo >= vol.noOfUnits)
   {
      if(lastUnitNo == ANAND_NO_UNIT )
      {
         /* First access to this unit therefore a one unit chain */

         vol.virtualUnits[virtualUnitNo] = unitNo;
         vol.physicalUnits[unitNo]       = FL_VALID | FIRST_IN_CHAIN;
         return flOK;
      }
      else
      {
         /* One unit chain that has 2 ends mark and deal later  */
         if(checkUnitHead(&vol,unitNo)!=flOK) /* Invalid header */
         {
            vol.physicalUnits[unitNo]          = FL_PRELIMINARY;
            return flOK;
         }
         else
         {
            if(checkUnitHead(&vol,lastUnitNo)!=flOK)
            {
               vol.physicalUnits[lastUnitNo]   = FL_PRELIMINARY;
               vol.virtualUnits[virtualUnitNo] = unitNo;
               vol.physicalUnits[unitNo]       = FL_VALID | FIRST_IN_CHAIN;
               /* Might want to check rest of chain - but not neccesary */
               return flOK;
            }
         }
         vol.physicalUnits[unitNo]             = FL_PRELIMINARY;
         DEBUG_PRINT(("Debug: We have reached a unit twice while mounting.\r\n"));
         return flOK;
      }
   }

   /* We know that our unit points to a valid unit , now check if we */
   /* already checked that older unit                                */

   if((vol.physicalUnits[prevUnitNo]     == FL_VALID)||
      (vol.physicalUnits[prevUnitNo]     == FL_FIRST_VALID))
   {
      if(lastUnitNo == prevUnitNo)
      {
         /* Our older unit is the head of the current chain. All we need */
         /* to do is append our newer unit and mark it as the new head   */

         vol.physicalUnits[unitNo]       = FL_VALID;
         vol.virtualUnits[virtualUnitNo] = unitNo;
         /* Might be nice to check for ANAC consistency */
         return flOK;
      }
      else /* The previous unit is not the newest unit of our chain */
      {
         if(lastUnitNo == ANAND_NO_UNIT)
         {
            /* This is the first time we accessed this chain, but the */
            /* unit indicated by the previous unit field is taken. We */
            /* must assume that it no longer belongs to our chain.    */

            vol.virtualUnits[virtualUnitNo] = unitNo;
            vol.physicalUnits[unitNo]       = FL_VALID | FIRST_IN_CHAIN;
            return flOK;
         }
         else /* Virtual chain already has a head - 2 ends of chain */
         {
            /* If we reached this point we have a problem - its bad.        */
            /* We were never visited, so we are'nt a part of a known chain. */
            /* Our previous unit is used and was visited so:                */
            /* a) It belong to our chain - so why is it not it's head       */
            /* b) It does not belong to our chain - so it will not lead     */
            /*    us to the rest of our chain which was already found.      */

            if(checkUnitHead(&vol,unitNo)!=flOK) /* Invalid header */
            {
               vol.physicalUnits[unitNo]    = FL_PRELIMINARY;
               return flOK;
            }
            else
            {
               if(checkUnitHead(&vol,lastUnitNo)!=flOK)
               {
                  vol.physicalUnits[lastUnitNo]   = FL_PRELIMINARY;
                  vol.virtualUnits[virtualUnitNo] = unitNo;
                  vol.physicalUnits[unitNo]       = FL_VALID | FIRST_IN_CHAIN;
                  /* Might want to check rest of chain - but not neccesary */
                  return flOK;
               }
            }
            vol.physicalUnits[unitNo]       = FL_PRELIMINARY;
            DEBUG_PRINT(("Debug: We have reached a unit twice while mounting.\r\n"));
            return flOK;
         }
      }
   }

   /* If we reached this point , we have a valid older unit pointer   */
   /* and it points to a unit we did not mark as visited yet. We need */
   /* to go along the chain and reconstruct it in the RAM tables.     */

   /* Save location of our unit and virtual unit number         */
   lastCurrent               = unitNo;
   origVirtualNo             = virtualUnitNo;

   /* Mark unit as Orphane until we shall verify the 2 ends connect */
   vol.physicalUnits[unitNo] = FL_PRELIMINARY;

   /************************************************************/
   /* Go over the chain starting the unit previous to our unit */
   /************************************************************/

   while(1)
   {
     nextUnitNo = unitNo;
     unitNo     = prevUnitNo;
     prevANAC   = ANAC;
     if(unitNo == ANAND_NO_UNIT)
        break;

     /* If already been to this unit */
     if((vol.physicalUnits[unitNo] == FL_VALID)||
        (vol.physicalUnits[unitNo] == FL_FIRST_VALID))
     {
        if(lastUnitNo == unitNo)
        {
           /* We have returned to the chains head , so the unit is valid */
           /* Convert all the units we passed as valid and mark new head */
           status = convertChain(&vol,lastCurrent,nextUnitNo,
                                 origVirtualNo,FL_VALID);
           vol.virtualUnits[origVirtualNo] = lastCurrent;
           return flOK;
        }
        /* We have reached a unit that was already checked, but was not   */
        /* registeredour as the chains head. We can safely assume it does */
        /* not belong to our virtual unit                                 */
        break;
     }

     /* Read unit header of our previous unit */

     status = getUnitData(&vol,unitNo,&virtualUnitNo, &prevUnitNo,
                          &ANAC,&NAC,&parityPerField);
     if(status != flOK)
        return status;

     if(badParityResult(parityPerField)) /* Bad unit header */
     {
        /* We can no longer follow the chain */
        vol.physicalUnits[unitNo] = FL_PRELIMINARY; /* Delete later */
        break;
     }

     /* Check if unit belongs to our chain */

     if((virtualUnitNo != origVirtualNo    ) ||  /* Correct virtual unit no */
        (!consecutiveNumbers(prevANAC,ANAC))   ) /* ANAC is consecutive     */
     {
        /* Note : none consecutive ANAC might still be connected to the end */
        /* the chain , on the next time we will read it.                    */
        break;
     }

     /* We have verified that unit belongs to our chain               */
     /* Mark unit as Orphane until we shall verify the 2 ends connect */
     vol.physicalUnits[unitNo]=FL_PRELIMINARY;
  }

  /* Chain reached a unit pointing to an invalid unit. */
  if(lastUnitNo == ANAND_NO_UNIT)
  {
     /* Chain did not have a head so mark it as a valid chain */
     status = convertChain(&vol,lastCurrent,nextUnitNo,
                           origVirtualNo,FL_VALID);
     vol.physicalUnits[nextUnitNo]   = FL_VALID | FIRST_IN_CHAIN;
     vol.virtualUnits[origVirtualNo] = lastCurrent;
  }
  else
  {
     /* Chain had a head. Check if previous head is valid. */

     if(checkUnitHead(&vol,lastUnitNo)!=flOK) /* Invalid header */
     {
        /* The unit we found earlier was a result of power failure */
        vol.physicalUnits[lastUnitNo]   = FL_PRELIMINARY;
        vol.virtualUnits[virtualUnitNo] = lastCurrent;
        status = convertChain(&vol,lastCurrent,nextUnitNo,
                              origVirtualNo,FL_VALID);
        vol.physicalUnits[nextUnitNo]   = FL_VALID | FIRST_IN_CHAIN;
        return status;
     }
     DEBUG_PRINT(("Debug: We have reached a unit twice while mounting.\r\n"));
     status = convertChain(&vol,lastCurrent,nextUnitNo,
                           origVirtualNo,FL_PRELIMINARY);
  }

  return status;
}

#ifdef QUICK_MOUNT_FEATURE

/*----------------------------------------------------------------------*/
/*                c h e c k Q u i c k M o u n t  I n f o                */
/*                                                                      */
/* Read the quick mount information and verfiy its itegrity.            */
/*                                                                      */
/* Note : If the data is valid it will be read to the vol record and    */
/*        will mark the current data as invalid.                        */
/*                                                                      */
/* Note : checksum will be added in future versions.                    */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns: TRUE if data is valid otherwise FALSE.                      */
/*----------------------------------------------------------------------*/

static FLBoolean checkQuickMountInfo(Bnand vol)
{
   byte  start;     /* The first goot unit of the quick mount data */
   FLStatus status;
   savedBnand *newVol;

   DEBUG_PRINT(("Debug: trying to read quick mount information.\r\n"));

   status = quickMountData(&vol, TRUE,&start);
   if (status==flOK)
   {
      status = vol.flash->read(vol.flash,(((CardAddress)(vol.firstQuickMountUnit
      +start))<< vol.unitSizeBits),inftlBuffer, sizeof(inftlBuffer),EDC);
      if (status == flOK)
      {
         /* Convert the dword fields  to the internal volume */

         newVol = (savedBnand *) inftlBuffer;
         if (LE4(newVol->validate) == QUICK_MOUNT_VALID_SIGN)
         {
            vol.freeUnits          = (ANANDUnitNo)LE4(newVol->freeUnits     );
            vol.roverUnit          = (ANANDUnitNo)LE4(newVol->roverUnit     );
            vol.countsValid        = (ANANDUnitNo)LE4(newVol->countsValid   );
            vol.sectorsRead        = LE4(newVol->sectorsRead   );
            vol.sectorsWritten     = LE4(newVol->sectorsWritten);
            vol.sectorsDeleted     = LE4(newVol->sectorsDeleted);
            vol.parasiteWrites     = LE4(newVol->parasiteWrites);
            vol.unitsFolded        = LE4(newVol->unitsFolded   );
            vol.wearLevel.alarm    = (word)LE4(newVol->wearLevel_1   );
            vol.wearLevel.currUnit = (ANANDUnitNo)LE4(newVol->wearLevel_2   );
            vol.eraseSum           = LE4(newVol->eraseSum      );
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
            vol.verifiedSectorNo   = LE4(newVol->verifiedSectorNo);
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
            DEBUG_PRINT(("Debug: quick mount information was successfuly restored.\r\n"));
            return TRUE;
         }
      }
   }
   DEBUG_PRINT(("Debug: Error getting quick mount information.\r\n"));
   return FALSE;
}

#endif /* QUICK_MOUNT_FEATURE */
#ifdef NFTL_CACHE

/*----------------------------------------------------------------------*/
/*                      i n i t C a t c h                               */
/*                                                                      */
/* Initialize and allocate the unit and sector catche.                  */
/*                                                                      */
/* Note - need to add check for not enough static memory.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      ramForCache     : Cache offset of previous volumes on device    */
/*                                                                      */
/* Returns:                                                             */
/*----------------------------------------------------------------------*/

#ifndef FL_MALLOC
void initCatch(Bnand vol, dword ramForCache)
#else
void initCatch(Bnand vol)
#endif /* FL_MALLOC */
{
  dword scacheSize = 0; /* Initialized to remove warrnings */
  dword iUnit;

  /* create and initialize ANANDUnitHeader cache */
#ifdef ENVIRONMENT_VARS
  if( flUseNFTLCache == 1 ) /* behave according to the value of env variable */
#endif
  {
#ifdef FL_MALLOC
     vol.ucache = (ucacheEntry FAR1*) FL_FAR_MALLOC(vol.noOfUnits * sizeof(ucacheEntry));
#else
     vol.ucache = &socketUcache[flSocketNoOf(vol.flash->socket)][ramForCache];
#endif /* FL_MALLOC */
  }
#ifdef ENVIRONMENT_VARS
  else
  {
    vol.ucache = NULL;
  }
#endif /* ENVIRONMENT_VARS */
  if (vol.ucache != NULL)
  {
    for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
    {
       vol.ucache[iUnit].virtualUnitNo = 0xDEAD;
       vol.ucache[iUnit].prevUnitNo    = 0xDEAD;
    }
  }
  else
  {
    DEBUG_PRINT(("Debug: INFTL runs without U-cache\r\n"));
  }

  /* create and initialize SectorFlags cache */
#ifdef ENVIRONMENT_VARS
  if( flUseNFTLCache == 1 ) /* behave according to the value of env variable */
#endif /* ENVIRONMENT_VARS */
  {
     scacheSize = (dword)vol.noOfUnits << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2);
#ifdef FL_MALLOC
     if( (sizeof(unsigned) < sizeof(scacheSize)) &&
         (scacheSize >= 0x10000L) )            /* Out of Segment Boundary */
     {
        vol.scache = NULL;
     }
     else
     {
        vol.scache = (byte FAR1*) FL_FAR_MALLOC(scacheSize);
     }
#else
     vol.scache = &socketScache[flSocketNoOf(vol.flash->socket)][ramForCache << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2)];
#endif /* FL_MALLOC */
  }
#ifdef ENVIRONMENT_VARS
  else
  {
    vol.scache = NULL;
  }
#endif /* ENVIRONMENT_VARS */
  if (vol.scache != NULL)
  {
    /*
     * Whenever SECTOR_IGNORE is found in Sector Flags cache it is double
     * checked by reading actual sector flags from flash-> This is way
     * all the cache entries are initially set to SECTOR_IGNORE.
     */
    byte val = (S_CACHE_SECTOR_IGNORE << 6) | (S_CACHE_SECTOR_IGNORE << 4) |
                            (S_CACHE_SECTOR_IGNORE << 2) |  S_CACHE_SECTOR_IGNORE;
    dword iC;

    for(iC=0;( iC < scacheSize );iC++)
      vol.scache[iC] = val;
  }
  else
  {
    DEBUG_PRINT(("Debug: INFTL runs without S-cache\r\n"));
  }
}
#endif /* NFTL_CACHE */

/*----------------------------------------------------------------------*/
/*                          m o u n t I N F T L                           */
/*                                                                      */
/* Mount the volume. Initialize data structures and conversion tables   */
/*                                                                      */
/* Parameters:                                                          */
/*      volNo           : Volume serial no.                             */
/*      tl              : Mounted translation layer on exit             */
/*      flash           : Flash media mounted on this socket            */
/*      volForCallback  : Pointer to FLFlash structure for power on     */
/*                        callback routine.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/
static FLStatus mountINFTL(unsigned volNo, TL *tl, FLFlash *flash, FLFlash **volForCallback)
{
  Bnand                     vol            = &vols[volNo];
  ANANDUnitNo               iUnit;
  ANANDUnitNo               originalUnits[MAX_NO_OF_FLOORS];
  BNANDBootRecord         * mediaHeader;  /* Disk header record        */
  BNANDVolumeHeaderRecord * volumeHeader; /* volume header record      */
  FLStatus                  status;
  byte                      index;
#ifndef FL_MALLOC
  dword                     ramForUnits=0;
#ifdef NFTL_CACHE
  dword                     ramForCache=0;
#endif /* NFTL_CACHE */
#endif /* FL_MALLOC */
#ifdef EXTRA_LARGE
  word                      moreUnitBits;
#endif /* EXTRA_LARGE */
#ifdef CHAINS_DEBUG
  FILE * out;
#endif /* CHAINS_DEBUG */

  DEBUG_PRINT(("Debug: starting INFTL mount.\r\n"));

  /*************************/
  /* Find the media header */
  /*************************/

  tffsset(&vol,0,sizeof(vol));
  status = initINFTL(&vol,flash);
  if(status == flOK)
     status = retrieveHeader(&vol,originalUnits,FALSE,TRUE);
  if(status != flOK)
     return status;

  mediaHeader  = (BNANDBootRecord *)inftlBuffer;
  if (tl->partitionNo >= LE4(mediaHeader->noOfBDTLPartitions))
  {
     DEBUG_PRINT(("Debug: wrong partition number.\r\n"));
     return flBadDriveHandle;
  }
  *volForCallback = vol.flash;
  vol.eraseSum    = 0;

  /* Get media information from unit header */

  volumeHeader  = (BNANDVolumeHeaderRecord *)(inftlBuffer +
                  sizeof(BNANDBootRecord) +
                  (word)((LE4(mediaHeader->noOfBinaryPartitions) *
                  sizeof(BNANDVolumeHeaderRecord))));
  vol.bootUnits = (ANANDUnitNo)LE4(volumeHeader->firstQuickMountUnit);

#ifndef FL_MALLOC

  /* calculate the memory offset for static allocation */

  for (index = tl->partitionNo;index>0;index--,volumeHeader++)
  {
     ramForUnits += LE4(volumeHeader->virtualUnits) * sizeof(ANANDUnitNo); /* virtual size */
     iUnit = (word)(LE4(volumeHeader->lastUnit) - LE4(volumeHeader->firstUnit) + 1);
     ramForUnits += iUnit * sizeof(ANANDPhysUnit);
#ifdef NFTL_CACHE
     ramForCache += iUnit;
#endif /* NFTL_CACHE */
  }
#else
  volumeHeader += tl->partitionNo;
#endif /* FL_MALLOC */

  vol.noOfVirtualUnits     = (ANANDUnitNo)LE4(volumeHeader->virtualUnits);
  vol.flags                = (byte)LE4(mediaHeader->formatFlags);
  vol.firstQuickMountUnit  = (ANANDUnitNo)LE4(volumeHeader->firstQuickMountUnit);
  vol.firstUnit            =(ANANDUnitNo) LE4(volumeHeader->firstUnit);
#ifdef NFTL_CACHE
  vol.firstUnitAddress     = (dword)vol.firstUnit << vol.unitSizeBits;
#endif /* NFTL_CACHE */

  vol.virtualSectors = (SectorNo)((LE4(volumeHeader->virtualUnits)<<
                                  vol.unitSizeBits) >> SECTOR_SIZE_BITS);
  vol.noOfUnits      = (ANANDUnitNo)(LE4(volumeHeader->lastUnit) -
                       LE4(volumeHeader->firstUnit) + 1);

  /* Validy check  */

  if((ANANDUnitNo)(vol.noOfVirtualUnits > vol.noOfUnits))
  {
     DEBUG_PRINT(("Reported no of virtual unit is larger then no of physical units\r\n"));
     return flBadFormat;
  }

#ifdef FL_MALLOC
  status = initTables(&vol);
#else
  status = initTables(&vol,ramForUnits);
#endif /* MALLOCK */
  if(status != flOK)
     return status;

#ifdef NFTL_CACHE
#ifndef FL_MALLOC
  initCatch(&vol, ramForCache);
#else
  initCatch(&vol);
#endif /* FL_MALLOC */
#endif /* NFTL_CACHE */

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  /* Default for INFTL is FL_OFF */
  flVerifyWrite[vol.socketNo][tl->partitionNo] = FL_OFF;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  /******************************************/
  /* Try mounting from the quick mount data */
  /******************************************/

#ifdef QUICK_MOUNT_FEATURE
#if (!defined(RAM_MTD) && !defined(CHECK_MOUNT))
  if (((LE4(mediaHeader->formatFlags) & QUICK_MOUNT) == 0) ||
      ( checkQuickMountInfo(&vol) == FALSE               )   )
#endif /* not RAM_MTD && not CHECK_MOUNT */
#endif /* QUICK_MOUNT_FORMAT */
  {
     vol.firstMediaWrite = TRUE; /* Force writing quick mount information */

     /***************************************/
     /* Read BBT to internal representation */
     /***************************************/

     status = flash->readBBT(vol.flash,vol.firstUnit,
              vol.noOfUnits,vol.blockMultiplierBits, vol.physicalUnits,FALSE);
     if( status != flOK )
     {
        DEBUG_PRINT(("Debug: Error reading BBT.\r\n"));
        dismountINFTL(&vol); /* Free tables must be done after call to initTables */
        return status;
     }
     /* Translate bad unit table to internal representation */
     for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
     {
        if (vol.physicalUnits[iUnit] != BBT_GOOD_UNIT)
        {
           vol.physicalUnits[iUnit] = UNIT_BAD;
        }
        else
        {
           vol.physicalUnits[iUnit] = ANAND_UNIT_FREE;
        }
     }
     /* Translate original units to bad blocks */
     for (index=0;index < vol.flash->noOfFloors;index++)
     {
        iUnit = originalUnits[index]-vol.firstUnit;
        if ((iUnit < vol.noOfUnits) && (originalUnits[index] > vol.firstUnit))
           vol.physicalUnits[iUnit] = UNIT_BAD;
     }

     /*************************/
     /* Mount the unit chains */
     /*************************/

     /* Initialize virutal units table */

     for (iUnit = 0; iUnit < vol.noOfVirtualUnits; iUnit++)
       vol.virtualUnits[iUnit] = ANAND_NO_UNIT;

#ifdef CHECK_MOUNT
     status = checkMountINFTL(&vol);
     if (status != flOK)
     {
       TL_DEBUG_PRINT(tl_out,"Failed check Mount routine with status %d\n",status);
       SET_EXIT(INFTL_FAILED_MOUNT);
     }
#endif /* CHECK_MOUNT */

     for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
     {
       if (vol.physicalUnits[iUnit] != UNIT_BAD)
       {
         status = goAlongChain(&vol,iUnit);
         if(status != flOK)
         {
            DEBUG_PRINT(("Debug: Error going along INFTL chains.\r\n"));
            dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
            return status;
         }
       }
     }
#ifdef CHAINS_DEBUG
     out = getFileHandle(&vol,0);
     if (out == NULL)
     {
        if (DID_MOUNT_FAIL)
           DEBUG_PRINT(("Debug: Can not open debug file.\r\n"));
     }
     else
     {
        checkVirtualChains(&vol,out);
     }
#endif /* CHAINS_DEBUG */
     vol.freeUnits = 0;
     for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
     {
       switch( vol.physicalUnits[iUnit] )
       {
         case ANAND_UNIT_FREE:
           vol.freeUnits++;
       break;

         case FL_FIRST_VALID:         /* Mark as first in chain */
         case FL_VALID:
           vol.physicalUnits[iUnit] &= FIRST_IN_CHAIN;
           break;

         case FL_FIRST_PRELIMINARY:        /* Vadim :erase this unit*/
         case FL_PRELIMINARY:
           DEBUG_PRINT(("Orphan unit found\r\n"));
           TL_DEBUG_PRINT(tl_out,"Orphan units found , unit no %d\n",iUnit);
           SET_EXIT(INFTL_FAILED_MOUNT);
#ifndef FL_READ_ONLY
           if( eraseOrphanUnit(&vol,iUnit) == flOK)
           {
             vol.physicalUnits[iUnit] = ANAND_UNIT_FREE;
             vol.freeUnits++;
           }
           break;
#else
#ifndef CHECK_MOUNT
           dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
           return flWriteFault;
#endif /* CHECK_MOUNT */
#endif /* FL_READ_ONLY */

         default:          /* nothing here */
           break;
       }
     }
     /* Initialize allocation rover */
     vol.roverUnit = 0;

     /* Initialize statistics */
     vol.sectorsRead = vol.sectorsWritten = vol.sectorsDeleted = 0;
     vol.parasiteWrites = vol.unitsFolded = 0;

     vol.wearLevel.alarm    = (word)(vol.eraseSum % WLnow);
     vol.wearLevel.currUnit = (ANANDUnitNo)(vol.eraseSum % vol.noOfVirtualUnits);
  } /* end quick mounted succesful if */

#ifdef CHAINS_DEBUG
  if (out != NULL)
  {
     checkVolumeStatistics(&vol,out);
  }
#endif /* CHAINS_DEBUG */

#ifdef CHECK_MOUNT
  dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
  if(vol.debugState & INFTL_FAILED_MOUNT)
  {
     TL_DEBUG_PRINT(tl_out,"Test failed\n\n");
     fclose(tl_out);
     exit(EXIT_FAILURE);
  }
  else
  {
     TL_DEBUG_PRINT(tl_out,"Test success\n\n");
     exit(EXIT_SUCCESS);
  }
#endif /* CHECK_MOUNT */

#ifndef FL_READ_ONLY
  /* Make sure there are at least 2 free units */
  if(vol.freeUnits == 0)
  {
      status = foldBestChain(&vol,&iUnit);
      switch(status)
      {
         case flNotEnoughMemory:
            DEBUG_PRINT(("Debug: Not enough free units. Media is read only.\r\n"));
         case flOK:
            break;
         default:
             return status;
      }
  }
  tl->writeSector      = writeSector;
  tl->deleteSector     = deleteSector;
  tl->writeMultiSector = writeMultiSector;
#ifdef DEFRAGMENT_VOLUME
  tl->defragment       = defragment;
#endif /* DEFRAGMENT */
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  tl->checkVolume      = checkVolume;
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#else /* FL_READ_ONLY */
  tl->writeSector      = NULL;
  tl->deleteSector     = NULL;
  tl->writeMultiSector = NULL;
#ifdef DEFRAGMENT_VOLUME
  tl->defragment       = NULL;
#endif /* DEFRAGMENT */
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  tl->checkVolume      = NULL;
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

#endif /* FL_READ_ONLY */

  tl->rec              = &vol;
  tl->mapSector        = mapSector;
  tl->sectorsInVolume  = sectorsInVolume;
  tl->getTLInfo        = INFTLInfo;
  tl->tlSetBusy        = tlSetBusy;
  tl->dismount         = dismountINFTL;
  tl->readSectors      = readSectors;
#ifndef NO_READ_BBT_CODE
  tl->readBBT          = readBBT;
#endif
  DEBUG_PRINT(("Debug: finished INFTL mount.\r\n"));
  return flOK;
}

#ifdef HW_PROTECTION

/*----------------------------------------------------------------------*/
/*                   p r o t e c t i o n I N F T L                      */
/*                                                                      */
/* Common entry point to all protection routines.                       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol       : Pointer identifying drive                           */
/*      volume    : Pointer to partition record of the media header     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus protectionINFTL(Bnand vol,BNANDVolumeHeaderRecord* volume,
                                IOreq FAR2* ioreq , FLFunctionNo callType)
{
  FLFlash *   flash = vol.flash;
  FLStatus    status;
#ifndef FL_READ_ONLY
  CardAddress low;
  CardAddress high;
  byte        floorNo;
#endif /* FL_READ_ONLY */
  byte        tempFlags = 0; /* Initialized to remove warrnings */
  byte        area;
  word        returnedFlags;

  /* Save protection area since "volume" is overwritten by protectionSet */

  area = (byte)LE4(volume->protectionArea); /* Protection area */
  if ((LE4(volume->flags) & PROTECTABLE) == 0)
     return flNotProtected;

  /* Routine that need to get the partition type before executing */
  if ((callType != FL_PROTECTION_INSERT_KEY) &&
      (callType != FL_PROTECTION_REMOVE_KEY))
  {
     tempFlags = (byte)ioreq->irFlags;
     if (flash->protectionType == NULL)
        return flFeatureNotSupported;

     status = flash->protectionType(flash,area,&returnedFlags);
     ioreq->irFlags = (unsigned)returnedFlags;
     if (status != flOK)
        return status;

     /* Routines that need to change the protection attributes */

#ifndef FL_READ_ONLY
     if (callType!=FL_PROTECTION_GET_TYPE)
     {
        if((returnedFlags & KEY_INSERTED) == 0) /* Make sure the key is inserted */
        {
           DEBUG_PRINT(("Please insert key before trying to change protection attributes\r\n"));
           return flHWProtection;
        }

        if ((flash->protectionBoundries == NULL ) ||
            (flash->protectionSet       == NULL ) ||
            (flash->protectionKeyInsert == NULL ))
        {
           DEBUG_PRINT(("Protection routine are NULL\r\n"));
           return flFeatureNotSupported;
        }

        if (!(LE4(volume->flags) & CHANGEABLE_PROTECTION))
           return flUnchangeableProtection;

        /* The DPS of unprotected partitions is protected by a default key */
        flash->protectionKeyInsert(flash,area,(byte *)DEFAULT_KEY);
     }
#endif /* FL_READ_ONLY */
  } /* End of protection change routine */


  /* Execute each of the posible protection routines */

  switch (callType)
  {
     case FL_PROTECTION_GET_TYPE:

        ioreq->irFlags |= PROTECTABLE;
        if (LE4(volume->flags) & CHANGEABLE_PROTECTION)
        {
           if ((ioreq->irFlags & CHANGEABLE_PROTECTION)==0)
           {
              DEBUG_PRINT(("Debug: INFTL reported CHANGEALE protection, but MTD does not allow it.\r\n"));
              return flBadFormat;
           }
        }
        else
        {
           ioreq->irFlags &= (~CHANGEABLE_PROTECTION);
        }
        break;

#ifndef FL_READ_ONLY

     case FL_PROTECTION_SET_LOCK:

        if (tempFlags & LOCK_ENABLED)
        {
           ioreq->irFlags |= LOCK_ENABLED;
        }
        else
        {
           ioreq->irFlags &=~LOCK_ENABLED;
        }
        for (floorNo = 0 ; floorNo < flash->noOfFloors ; floorNo++)
        {
           /* Find boundries */
           status = flash->protectionBoundries(flash,
                         area,&low,&high,floorNo);
           if(status == flOK) /* Set new protection values */
           {
              status = flash->protectionSet(flash,area,
                       (word)((high == 0) ? PROTECTABLE : ioreq->irFlags),
                       low,high,NULL,
                       (byte)((floorNo == flash->noOfFloors - 1) ?
                       COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo);
           }
           if(status != flOK)
             return status;
        }
        break;

     case FL_PROTECTION_CHANGE_KEY:

        for (floorNo = 0 ; floorNo < flash->noOfFloors ; floorNo++)
        {
           /* Find boundries */
           status = flash->protectionBoundries(flash,area,
                         &low,&high,floorNo);
           if(status == flOK) /* Set new protection values */
           {
              status = flash->protectionSet(flash,area,
                       (word)((high == 0) ? PROTECTABLE : ioreq->irFlags),
                       low,high,(byte FAR1*)ioreq->irData,
                       (byte)((floorNo == flash->noOfFloors - 1) ?
                       COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo);
           }
           if(status != flOK)
             return status;
        }
        break;

     case FL_PROTECTION_CHANGE_TYPE:

        /* Only read and or write protected types are available */
        if (((tempFlags & (READ_PROTECTED | WRITE_PROTECTED |
               PROTECTABLE)) != tempFlag